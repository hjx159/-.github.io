<!-- build time:Tue Mar 05 2024 00:59:15 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="水文 & 摄影" href="http://example.com/rss.xml"><link rel="alternate" type="application/atom+xml" title="水文 & 摄影" href="http://example.com/atom.xml"><link rel="alternate" type="application/json" title="水文 & 摄影" href="http://example.com/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><link rel="canonical" href="http://example.com/docker/docker-javaguide/"><title>docker-javaguide - docker | fantedong = 水文 & 摄影 = 为了能更好地查看图片，你需要一点魔法</title><meta name="generator" content="Hexo 6.3.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">docker-javaguide</h1><div class="meta"><span class="item" title="创建时间：2024-01-19 11:24:09"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2024-01-19T11:24:09+08:00">2024-01-19</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>17k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>16 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">fantedong</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><img src="https://pic.imgdb.cn/item/65a9ebfb871b83018a3cb132.jpg"></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/docker/" itemprop="item" rel="index" title="分类于 docker"><span itemprop="name">docker</span></a><meta itemprop="position" content="1"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://example.com/docker/docker-javaguide/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="范特东东东"><meta itemprop="description" content="为了能更好地查看图片，你需要一点魔法, "></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="水文 & 摄影"></span><div class="body md" itemprop="articleBody"><h1 id="docker-核心概念"><a class="anchor" href="#docker-核心概念">#</a> Docker 核心概念</h1><h2 id="容器"><a class="anchor" href="#容器">#</a> 容器</h2><p><strong>Docker 是世界领先的软件容器平台</strong>，所以想要搞懂 Docker 的概念我们必须先从容器开始说起。</p><h3 id="容器是什么"><a class="anchor" href="#容器是什么">#</a> 容器是什么</h3><p>一句话概括容器：<strong><font color="red">容器就是将软件打包成标准化单元，以用于开发、交付和部署。</font></strong></p><ul><li><strong>容器镜像是轻量的、可执行的独立软件包</strong>，包含软件运行所需的所有内容：代码、运行时环境、系统工具、系统库和设置。</li><li><strong>容器化软件适用于基于 Linux 和 Windows 的应用，在任何环境中都能够始终如一地运行。</strong></li><li><strong>容器赋予了软件独立性</strong>，使其免受外在环境差异（例如，开发和预演环境的差异）的影响，从而有助于减少团队间在相同基础设施上运行不同软件时的冲突。</li></ul><p>如果需要通俗地描述容器的话，我觉得容器就是一个存放东西的地方，就像书包可以装各种文具、衣柜可以放各种衣服、鞋架可以放各种鞋子一样。我们现在所说的容器存放的东西可能更偏向于应用比如网站、程序甚至是系统环境。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/container.png" alt="认识容器"></p><center>认识容器</center><h3 id="图解物理机-虚拟机-容器"><a class="anchor" href="#图解物理机-虚拟机-容器">#</a> 图解：物理机、虚拟机、容器</h3><p><strong>物理机：</strong></p><p><img data-src="https://oss.javaguide.cn/github/javaguide/tools/docker/%E7%89%A9%E7%90%86%E6%9C%BA%E5%9B%BE%E8%A7%A3.jpeg" alt="物理机"></p><p><strong>虚拟机：</strong></p><p><img data-src="https://oss.javaguide.cn/github/javaguide/tools/docker/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%9B%BE%E8%A7%A3.jpeg" alt="虚拟机"></p><p><strong>容器：</strong></p><p><img data-src="https://oss.javaguide.cn/javaguide/image-20211110104003678.png" alt="img"></p><p>通过上面这三张抽象图，我们可以大概通过类比概括出：<strong><font color="red">容器虚拟化的是操作系统而不是硬件，容器之间是共享同一套操作系统资源的</font>。虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统。<font color="red">因此容器的隔离级别会稍低一些</font>。</strong></p><h2 id="docker-思想"><a class="anchor" href="#docker-思想">#</a> Docker 思想</h2><h3 id="docker-是什么"><a class="anchor" href="#docker-是什么">#</a> Docker 是什么</h3><p>通过四点向你说明 Docker 到底是个什么东西。</p><ul><li><strong>Docker 是世界领先的<font color="red">软件容器平台</font>，基于<font color="red"> Go 语言</font> 进行开发实现。</strong></li><li><strong>Docker 可以<font color="red">对进程进行封装隔离</font>，属于操作系统层面的虚拟化技术</strong>。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。</li><li><strong><font color="red">Docker 能够自动执行重复性任务，例如搭建和配置开发环境</font>，从而解放了开发人员。</strong></li><li><strong>用户可以方便地<font color="red">创建和使用容器</font>，把自己的应用放入容器。容器还可以进行<font color="red">版本管理、复制、分享、修改</font>，就像管理普通的代码一样。</strong></li></ul><h3 id="docker-思想-2"><a class="anchor" href="#docker-思想-2">#</a> Docker 思想</h3><ul><li><strong>集装箱</strong></li><li><strong>标准化</strong><ul><li>运输方式</li><li>存储方式</li><li>API 接口</li></ul></li><li><strong>隔离</strong></li></ul><h3 id="docker-容器的特点"><a class="anchor" href="#docker-容器的特点">#</a> Docker 容器的特点</h3><p><strong><font color="red">轻量</font></strong> : 在一台机器上运行的多个 Docker 容器可以<font color="red">共享这台机器的操作系统内核</font>；它们能够迅速启动，只需<font color="red">占用很少的计算和内存资源</font>。镜像是通过文件系统层进行构造的，并共享一些公共文件。这样就能尽量降低磁盘用量，并能更快地下载镜像。</p><p><strong><font color="red">标准</font></strong> : Docker 容器<font color="red">基于开放式标准</font>，能够在所有主流 Linux 版本、Microsoft Windows 以及包括 VM、裸机服务器和云在内的任何基础设施上运行。</p><p><strong><font color="red">安全</font></strong> : Docker 赋予应用的隔离性不仅限于彼此隔离，还独立于底层的基础设施。Docker <font color="red">默认提供最强的隔离</font>，因此应用出现问题，也只是单个容器的问题，而不会波及到整台机器。</p><h3 id="为什么使用-docker"><a class="anchor" href="#为什么使用-docker">#</a> 为什么使用 Docker</h3><p><font color="red">借助 Docker，开发者可以将他们的应用以及依赖包<strong>打包</strong>到一个<strong>轻量级、可移植</strong>的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化</font>。</p><p>容器是完全使用<font color="red">沙箱机制，相互之间不会有任何接口</font>（类似 iPhone 的 app），更重要的是容器性能<font color="red">开销极低</font>。</p><p>传统的开发流程中，我们的项目通常需要使用 MySQL、Redis、FastDFS 等等环境，这些环境都是需要我们手动去进行下载并配置的，安装配置流程极其复杂，而且不同系统下的操作也不一样。</p><p>Docker 的出现完美地解决了这一问题，我们<font color="red">可以在容器中安装 MySQL、Redis 等软件环境，使得应用和环境架构分开</font>，它的优势在于：</p><ul><li><strong><font color="red">一致的运行环境</font>：Docker 的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性，从而不会再出现 “这段代码在我机器上没问题啊” 这类问题；</strong></li><li><strong><font color="red">快速启动</font>：可以做到秒级、甚至毫秒级的启动时间，大大的节约了开发、测试、部署的时间；</strong></li><li><strong><font color="red">隔离性</font>：避免公用的服务器，资源会容易受到其他用户的影响；</strong></li><li><strong><font color="red">弹性伸缩，快速扩展</font>：善于处理集中爆发的服务器使用压力；</strong></li><li><strong><font color="red">迁移方便</font>：可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况；</strong></li><li><strong><font color="red">持续交付和部署</font>：使用 Docker 可以通过定制应用镜像来实现持续集成、持续交付、部署；</strong></li></ul><h2 id="容器-vs-虚拟机"><a class="anchor" href="#容器-vs-虚拟机">#</a> 容器 vs 虚拟机</h2><blockquote><p>容器是一种虚拟化技术，常与虚拟机作比较。而 <font color="red">Docker 只是容器的一种实现</font>，是一个容器化的解决方案和平台。不要把二者混为一谈。</p></blockquote><p><strong>每当说起容器，我们不得不将其与虚拟机做一个比较。就我而言，对于两者无所谓谁会取代谁，而是<font color="red">两者可以和谐共存</font>。</strong></p><p>简单来说：<strong>容器和虚拟机具有相似的资源隔离和分配优势，但功能有所不同，因为<font color="red">容器虚拟化的是操作系统，而不是硬件，因此容器更容易移植，效率也更高</font>。</strong></p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20240121175824099.png" alt="image-20240121175824099"></p><center>虚拟化（Hypervisor）技术</center><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20240121180015087.png" alt="image-20240121180015087"></p><center>虚拟机（VM）示意图</center><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20240121180238543.png" alt="image-20240121180238543"></p><center>容器示意图</center><h3 id="对比图"><a class="anchor" href="#对比图">#</a> 对比图</h3><p>传统虚拟机技术（VM）是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；而<font color="red">容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核</font>，而且也没有进行硬件虚拟。<font color="red">因此容器要比传统虚拟机更为轻便</font>。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/2e2b95eebf60b6d03f6c1476f4d7c697.png" alt="img"></p><h3 id="二者总结"><a class="anchor" href="#二者总结">#</a> 二者总结</h3><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/4ef8691d67eb1eb53217099d0a691eb5.png" alt="img"></p><ul><li><strong><font color="red">容器是一个应用层抽象，用于将代码和依赖资源打包在一起。多个容器可以在同一台机器上运行，共享操作系统内核，但各自作为独立的进程在用户空间中运行</font></strong>。与虚拟机相比， <strong>容器占用的空间较少</strong>（容器镜像大小通常只有几十兆），<strong>瞬间就能完成启动</strong>。</li><li><strong><font color="red">虚拟机 (VM) 是一个物理硬件层抽象，用于将一台服务器变成多台服务器</font>。</strong> 管理程序允许多个 VM 在一台机器上运行。每个 VM 都包含一整套操作系统、一个或多个应用、必要的二进制文件和库资源，因此 <strong>占用大量空间</strong> 。而且 VM <strong>启动也十分缓慢</strong> 。</li></ul><p>通过 Docker 官网，我们知道了这么多 Docker 的优势，但是大家也没有必要完全否定虚拟机技术，因为两者有不同的使用场景。<strong><font color="red">虚拟机更擅长于彻底隔离整个运行环境</font></strong>。例如，云服务提供商通常采用虚拟机技术隔离不同的用户。而 <strong><font color="red">Docker 通常用于隔离不同的应用</font></strong> ，例如前端，后端以及数据库。</p><h3 id="二者可共存"><a class="anchor" href="#二者可共存">#</a> 二者可共存</h3><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/056c87751b9dd7b56f4264240fe96d00.png" alt="img"></p><center>Docker与虚拟机的共存关系</center><h2 id="docker-基本概念"><a class="anchor" href="#docker-基本概念">#</a> Docker 基本概念</h2><p>Docker 中有非常重要的三个基本概念，理解了这三个概念，就理解了 Docker 的整个生命周期。</p><ul><li><p><strong><font color="cornflowerblue">镜像（Image）</font></strong>：<font color="red">Image 是一个只读的模板</font>，可以用来创建多个 Container 。相当于是一个 root 文件系统，是<font color="red">用于创建 Container 的模板</font>。</p></li><li><p><strong><font color="cornflowerblue">容器（Container）</font></strong>：<font color="red">Container 是 Image 的一个运行实例</font>，它提供了一个独立的可移植的环境，可以在这个环境中运行应用程序。Image 和 Container 的关系，就像是面向对象程序设计中的类和实例一样，<strong><font color="red">Image 是静态的定义（类），Container 是 Image 运行时的实体（实例）</font></strong>。Container 是独立运行的一个或一组应用，<font color="red">是 Image 运行时的实体</font>，可以被创建、启动、停止、删除、暂停等。</p></li><li><p><strong><font color="cornflowerblue">仓库（Repository）</font></strong>：用来<font color="red">存放 Image </font>的仓库，类似于代码控制中心。</p><blockquote><p><strong><font color="cornflowerblue">注册表（Registry）</font></strong>：<font color="red">包含多个 Repository，每个 Repository 可以包含多个 Tag，每个 Tag 对应一个 Image </font>。</p></blockquote></li></ul><p>理解了这三个概念，就理解了<font color="red"> Docker 的整个生命周期</font>。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/docker-overview.png" alt="An Introductory Guide To Docker for Beginners"></p><center>Docker 基本概念</center><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20240121181052546.png" alt="image-20240121181052546"></p><center>Docker 架构</center><h3 id="镜像image一个特殊的文件系统"><a class="anchor" href="#镜像image一个特殊的文件系统">#</a> 镜像（Image）：一个特殊的文件系统</h3><p><strong>操作系统分为内核和用户空间</strong>。对于 Linux 而言，内核启动后，会挂载 root 文件系统为其提供用户空间支持。而 Image 就相当于是一个 root 文件系统。</p><p><strong>Image 是一个特殊的文件系统，除了<font color="red">提供容器运行时所需的程序、库、资源、配置等文件</font>外，还<font color="red">包含了一些为运行时准备的配置参数（如匿名卷、环境变量、用户等）</font>。</strong><font color="red">Image 不包含任何动态数据，其内容在构建之后也不会被改变</font>。</p><p>Docker 设计时，就充分利用 <strong>Union FS</strong> 的技术，将其设计为<strong>分层存储的架构</strong>。Image 实际是由多层文件系统联合组成。</p><p>**<font color="red">Image 是逐层构建的，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。</font>** 比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随 Image 。因此在构建 Image 的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。</p><p>分层存储的特征还使得<font color="red"> Image 的复用、定制</font>变的更为容易。甚至可以用之前构建好的 Image 作为基础层，然后进一步添加新的层，以定制自己所需的内容，构建新的 Image 。</p><h3 id="容器containerimage-运行时的实体"><a class="anchor" href="#容器containerimage-运行时的实体">#</a> 容器（Container）：Image 运行时的实体</h3><p>镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的 类 和 实例 一样，<strong><font color="red">Image 是静态的定义，Container 是 Image 运行时的实体</font>。Container 可以被创建、启动、停止、删除、暂停等</strong>。</p><p><strong>Container 的实质是进程，但与直接在宿主执行的进程不同，<font color="red">Container 进程运行于属于自己的独立的命名空间</font>。前面讲过 Image 使用的是分层存储，<font color="red">Container 也是分层存储</font>。</strong></p><p><strong><font color="red">Container 存储层的生存周期和 Container 一样</font>，Container 消亡时，Container 存储层也随之消亡。因此，任何保存于 Container 存储层的信息都会随 Container 删除而丢失。</strong></p><p>按照 Docker 最佳实践的要求，<strong><font color="red">Container 不应该向其存储层内写入任何数据</font></strong> ，容器存储层要保持无状态化。<strong>所有的文件写入操作，都应该使用数据卷（Volume）、或者绑定宿主目录</strong>，在这些位置的读写会跳过容器存储层，直接对宿主 (或网络存储) 发生读写，其性能和稳定性更高。<font color="red">数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡</font>。因此，<strong>使用数据卷后，容器可以随意删除、重新 run ，数据却不会丢失。</strong></p><h3 id="仓库repository集中存放-image-文件的地方"><a class="anchor" href="#仓库repository集中存放-image-文件的地方">#</a> 仓库（Repository）：集中存放 Image 文件的地方</h3><h4 id="概念"><a class="anchor" href="#概念">#</a> 概念</h4><p>Image 构建完成后，可以很容易的在当前宿主上运行，但是，<strong>如果需要在其它服务器上使用这个 Image，我们就需要<font color="red">一个集中的存储、分发 Image 的服务</font>，Docker Registry 就是这样的服务。</strong></p><p><strong><font color="red">一个 Registry 中可以包含多个 Repository，每个 Repository 可以包含多个 Tag，每个 Tag 对应一个 Image</font></strong>。所以说：镜像仓库是 Docker 用来集中存放镜像文件的地方，类似于我们之前常用的代码仓库。</p><p>通常，<strong>一个 Repository 会包含同一个软件不同版本的 Image</strong>，而 <strong>tag 就常用于对应该软件的各个版本</strong> 。我们可以通过 <code>&lt;仓库名&gt;:&lt;标签&gt;</code> 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 latest 作为默认标签。</p><hr><p>这里补充一下 <code>Docker Registry 公开服务</code> 和 <code>私有 Docker Registry</code> 的概念：</p><h4 id="registry-公开服务"><a class="anchor" href="#registry-公开服务">#</a> Registry 公开服务</h4><p>Docker Registry 公开服务是开放给用户使用、允许用户管理 Image 的 Registry 服务。一般这类公开服务<font color="red">允许用户免费上传、下载公开的 Image</font>，并可能提供收费服务供用户管理私有 Image 。<font color="red">最常使用的 Registry 公开服务是官方的 <strong>Docker Hub</strong> ，这也是默认的 Registry</font>，并拥有大量的高质量的官方镜像，网址为：<span class="exturl" data-url="aHR0cHM6Ly9odWIuZG9ja2VyLmNvbS8=">https://hub.docker.com/</span> 。官方是这样介绍 Docker Hub 的：</p><blockquote><p>Docker Hub 是 Docker 官方提供的一项服务，用于与您的团队查找和共享容器镜像。</p></blockquote><p>比如我们想要搜索自己想要的镜像：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20240120142613581.png" alt="利用Docker Hub 搜索镜像"></p><center>利用Docker Hub 搜索镜像</center><p>在 Docker Hub 的搜索结果中，有几项关键的信息有助于我们选择合适的镜像：</p><ul><li><strong>OFFICIAL Image</strong>：代表镜像为 Docker 官方提供和维护，相对来说稳定性和安全性较高。</li><li><strong>Stars</strong>：和点赞差不多的意思，类似 GitHub 的 Star。</li><li><strong>Downloads</strong>：代表镜像被拉取的次数，基本上能够表示镜像被使用的频度。</li></ul><p>当然，除了直接通过 Docker Hub 网站搜索镜像这种方式外，我们<font color="red">还可以通过 <code>docker search</code> 这个命令搜索 Docker Hub 中的镜像</font>，搜索的结果是一致的。</p><figure class="highlight sh"><figcaption data-lang="sh"></figcaption><table><tr><td data-num="1"></td><td><pre>➜  ~ <span class="token function">docker</span> search mysql</pre></td></tr><tr><td data-num="2"></td><td><pre>NAME                              DESCRIPTION                                     STARS               OFFICIAL            AUTOMATED</pre></td></tr><tr><td data-num="3"></td><td><pre>mysql                             MySQL is a widely used, open-source relation…   <span class="token number">8763</span>                <span class="token punctuation">[</span>OK<span class="token punctuation">]</span></pre></td></tr><tr><td data-num="4"></td><td><pre>mariadb                           MariaDB is a community-developed fork of MyS…   <span class="token number">3073</span>                <span class="token punctuation">[</span>OK<span class="token punctuation">]</span></pre></td></tr><tr><td data-num="5"></td><td><pre>mysql/mysql-server                Optimized MySQL Server Docker images. Create…   <span class="token number">650</span>                                     <span class="token punctuation">[</span>OK<span class="token punctuation">]</span></pre></td></tr></table></figure><p>在国内访问 <strong>Docker Hub</strong> 可能会比较慢，<font color="red">国内也有一些云服务商</font>提供类似于 Docker Hub 的公开服务。比如 <span class="exturl" data-url="aHR0cHM6Ly93d3cudGVueGNsb3VkLmNvbS8=">时速云镜像库</span>、<span class="exturl" data-url="aHR0cHM6Ly93d3cuMTYzeXVuLmNvbS9wcm9kdWN0L3JlcG8=">网易云镜像服务</span>、<span class="exturl" data-url="aHR0cHM6Ly93d3cuZGFvY2xvdWQuaW8v">DaoCloud 镜像市场</span>、<span class="exturl" data-url="aHR0cHM6Ly93d3cuYWxpeXVuLmNvbS9wcm9kdWN0L2NvbnRhaW5lcnNlcnZpY2U/dXRtX2NvbnRlbnQ9c2VfMTI5MjgzNg==">阿里云镜像库</span>等。</p><h4 id="私有-registry"><a class="anchor" href="#私有-registry">#</a> 私有 Registry</h4><p>除了使用公开服务外，用户还可以 **<font color="red">在本地搭建私有 Docker Registry</font>** 。Docker 官方提供了 Docker Registry 镜像，可以直接使用做为私有 Registry 服务。开源的 Docker Registry 镜像只提供了 Docker Registry API 的服务端实现，足以支持 docker 命令，不影响使用。但不包含图形界面，以及镜像维护、用户管理、访问控制等高级功能。</p><h3 id="dockerfile"><a class="anchor" href="#dockerfile">#</a> Dockerfile</h3><p>容器化的过程包括三个步骤：</p><ol><li><strong>编写 Dockerfile</strong></li><li>使用 Dockerfile <strong>构建 Image</strong></li><li>使用 Image <strong>创建和运行 Container</strong></li></ol><p>其中，<strong><font color="red">Dockerfile 是一个包含指令的文本文件</font></strong>，用于告诉 Docker 如何构建应用程序的 Image，包括应用程序的命令、依赖、配置环境和运行环境等内容。<font color="red">一般在项目根目录下创建一个名为 <code>Dockerfile</code> 的文件</font>，第一个字母 D 大写，其他都小写。</p><p>有了 Image 之后，就可以使用该 Image 来创建 Container，并<font color="red">在 Container 中运行应用程序</font>。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20240121194842382.png" alt="image-20240121194842382"></p><h3 id="docker-compose"><a class="anchor" href="#docker-compose">#</a> Docker Compose</h3><p><font color="red">docker compose 可以定义和运行多个 docker 容器和应用程序，解决服务之间关联关系的问题</font>。通过一个单独的 <code>docker-compose.yml</code> 配置文件，将一组互相关联的容器组合在一起，形成一个项目，然后<font color="red">使用一条命令 <code>docker compose up</code> 就可以启动、停止或重建这些服务，方便管理</font>。这对于提高开发效率和减少沟通成本非常有用，建议初学者学习使用。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20240121194754264.png" alt="image-20240121194754264"></p><h2 id="docker-常见命令"><a class="anchor" href="#docker-常见命令">#</a> Docker 常见命令</h2><h3 id="基本命令"><a class="anchor" href="#基本命令">#</a> 基本命令</h3><figure class="highlight sh"><figcaption data-lang="sh"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">docker</span> version <span class="token comment"># 查看 docker 版本</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">docker</span> images <span class="token comment"># 查看所有已下载镜像，等价于：docker image ls 命令</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token function">docker</span> container <span class="token function">ls</span> <span class="token comment"># 查看所有容器</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token function">docker</span> <span class="token function">ps</span> <span class="token comment">#查看正在运行的容器</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token function">docker</span> image prune <span class="token comment"># 清理临时的、没有被使用的镜像文件。-a, --all: 删除所有没有用的镜像，而不仅仅是临时文件；</span></pre></td></tr></table></figure><h3 id="拉取镜像"><a class="anchor" href="#拉取镜像">#</a> 拉取镜像</h3><figure class="highlight sh"><figcaption data-lang="sh"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">docker</span> search mysql <span class="token comment"># 查看 mysql 相关镜像</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">docker</span> pull mysql:5.7 <span class="token comment"># 拉取 mysql 镜像</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token function">docker</span> image <span class="token function">ls</span> <span class="token comment"># 查看所有已下载镜像</span></pre></td></tr></table></figure><h3 id="删除镜像"><a class="anchor" href="#删除镜像">#</a> 删除镜像</h3><p>比如我们要删除我们下载的 mysql 镜像。</p><p>通过 <code>docker rmi [image]</code> （等价于 <code>docker image rm [image]</code> ）删除镜像之前<font color="red">首先要确保这个镜像没有被容器引用</font>（可以通过 tag 名称或者 image ID 删除）。</p><p>举个例子，通过我们前面讲的 <code>docker ps</code> 命令即可查看。</p><figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre>➜  ~ <span class="token function">docker</span> <span class="token function">ps</span></pre></td></tr><tr><td data-num="2"></td><td><pre>CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                               NAMES</pre></td></tr><tr><td data-num="3"></td><td><pre>c4cd691d9f80        mysql:5.7           <span class="token string">"docker-entrypoint.s…"</span>   <span class="token number">7</span> weeks ago         Up <span class="token number">12</span> days          <span class="token number">0.0</span>.0.0:3306-<span class="token operator">></span><span class="token number">3306</span>/tcp, <span class="token number">33060</span>/tcp   mysql</pre></td></tr></table></figure><p>可以看到 mysql 正在被 id 为 c4cd691d9f80 的容器引用，我们需要首先通过 <code>docker stop c4cd691d9f80</code> 或者 <code>docker stop mysql</code> 暂停这个容器。</p><p>然后查看 mysql 镜像的 id</p><figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre>➜  ~ <span class="token function">docker</span> images</pre></td></tr><tr><td data-num="2"></td><td><pre>REPOSITORY              TAG                 IMAGE ID            CREATED             SIZE</pre></td></tr><tr><td data-num="3"></td><td><pre>mysql                   <span class="token number">5.7</span>                 f6509bac4980        <span class="token number">3</span> months ago        373MB</pre></td></tr></table></figure><p><font color="red">通过 IMAGE ID 或者 REPOSITORY 名字即可删除</font></p><figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">docker</span> rmi f6509bac4980 <span class="token comment">#  或者 docker rmi mysql</span></pre></td></tr></table></figure><h2 id="docker-两句口号"><a class="anchor" href="#docker-两句口号">#</a> Docker 两句口号</h2><ul><li><strong><font color="red">“Build, Ship and Run（搭建、发送、运行）”</font></strong></li><li><strong><font color="red">“Build once，Run anywhere（搭建一次，到处能用）”</font></strong></li></ul><p>如果你搜索 Docker 官网，会发现如下的字样：<strong>“Docker - Build, Ship, and Run Any App, Anywhere”</strong>。那么 Build, Ship, and Run 到底是在干什么呢？</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/docker-build-ship-run.jpg" alt="img"></p><ul><li><strong><font color="red">Build（构建镜像）</font></strong>：镜像就像是集装箱，包括文件以及运行环境等等资源。</li><li><strong><font color="red">Ship（运输镜像）</font></strong>：主机和仓库间运输，这里的仓库就像是超级码头一样。</li><li><strong><font color="red">Run（运行镜像）</font></strong>：运行的镜像就是一个容器，容器就是运行程序的地方。</li></ul><p><strong><font color="red">Docker 运行过程也就是去仓库把镜像拉到本地，然后用一条命令把镜像运行起来变成容器</font>。所以，我们也常常将 Docker 称为码头工人或码头装卸工，这和 Docker 的中文翻译搬运工人如出一辙。</strong></p><h2 id="docker-底层原理"><a class="anchor" href="#docker-底层原理">#</a> Docker 底层原理</h2><h3 id="虚拟化技术"><a class="anchor" href="#虚拟化技术">#</a> 虚拟化技术</h3><p>首先，Docker <strong>容器虚拟化技术</strong>为基础的软件，那么什么是虚拟化技术呢？</p><p>简单点来说，虚拟化技术可以这样定义：</p><blockquote><p>虚拟化技术是一种资源管理技术，是将计算机的各种<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU4JUE4JTg4JUU3JUFFJTk3JUU2JUE5JTlGJUU3JUE3JTkxJUU1JUFEJUI4">实体资源</span>（<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvQ1BV">CPU</span>、<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JTg2JTg1JUU1JUFEJTk4">内存</span>、<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU3JUEzJTgxJUU3JTlCJTk4JUU3JUE5JUJBJUU5JTk3JUI0">磁盘空间</span>、<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU3JUI2JUIyJUU4JUI3JUFGJUU5JTgxJUE5JUU5JTg1JThEJUU1JTk5JUE4">网络适配器</span>等），予以抽象、转换后呈现出来并可供分割、组合为一个或多个电脑配置环境。由此，打破实体结构间的不可切割的障碍，使用户可以比原本的配置更好的方式来应用这些电脑硬件资源。这些资源的新虚拟部分是不受现有资源的架设方式，地域或物理配置所限制。一般所指的虚拟化资源包括计算能力和数据存储。</p></blockquote><h3 id="docker-基于-lxc-虚拟容器技术"><a class="anchor" href="#docker-基于-lxc-虚拟容器技术">#</a> Docker 基于 LXC 虚拟容器技术</h3><p>Docker 技术是基于 <strong>LXC（Linux container- Linux 容器）虚拟容器技术</strong>的。</p><blockquote><p>LXC，其名称来自 Linux 软件容器（Linux Containers）的缩写，一种操作系统层虚拟化（Operating system–level virtualization）技术，为 Linux 内核容器功能的一个用户空间接口。它将应用软件系统打包成一个软件容器（Container），内含应用软件本身的代码，以及所需要的操作系统核心和库。通过统一的名字空间和共用 API 来分配不同软件容器的可用硬件资源，创造出应用程序的独立沙箱运行环境，使得 Linux 用户可以容易的创建和管理系统或应用容器。</p></blockquote><p><strong>LXC 技术主要是借助 Linux 内核中提供的 CGroup 功能和 namespace 来实现的，通过 LXC 可以为软件提供一个独立的操作系统运行环境</strong>。</p><p>cgroup 和 namespace 介绍：</p><ul><li><p><strong><font color="red">namespace 是 Linux 内核用来隔离内核资源的方式。</font></strong> 通过 namespace 可以让一些进程只能看到与自己相关的一部分资源，而另外一些进程也只能看到与它们自己相关的资源，这两拨进程根本就感觉不到对方的存在。具体的实现方式是把一个或多个进程的相关资源指定在同一个 namespace 中。Linux namespaces 是对全局系统资源的一种封装隔离，使得处于不同 namespace 的进程拥有独立的全局系统资源，改变一个 namespace 中的系统资源只会影响当前 namespace 里的进程，对其他 namespace 中的进程没有影响。</p></li><li><p><strong><font color="red">CGroup 是 Control Groups 的缩写，是 Linux 内核提供的一种可以限制、记录、隔离进程组 (process groups) 所使用的物力资源 (如 cpu memory i/o 等等) 的机制</font>。</strong></p></li></ul><p>cgroup 和 namespace 两者对比：</p><p><font color="red">两者都是将进程进行分组</font>，但是两者的作用还是有本质区别。<font color="red">namespace 是为了隔离进程组之间的资源，而 cgroup 是为了对一组进程进行统一的资源监控和限制</font>。</p><h2 id="总结"><a class="anchor" href="#总结">#</a> 总结</h2><p>本文主要把 Docker 中的一些常见概念做了详细的阐述，但是并不涉及 Docker 的安装、镜像的使用、容器的操作等内容。这部分东西，希望读者自己可以通过阅读书籍与官方文档的形式掌握。如果觉得官方文档阅读起来很费力的话，这里推荐以下内容：</p><ul><li><strong>《Docker 技术入门与实战第二版》[<span class="exturl" data-url="aHR0cHM6Ly95ZWFzeS5naXRib29rLmlvL2RvY2tlcl9wcmFjdGljZS8=">前言 - Docker — 从入门到实践 (gitbook.io)</span>]</strong></li><li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC81MzI2MDA5OA==">10 分钟看懂 Docker 和 K8S</span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuaW5mb3EuY24vYXJ0aWNsZS90ZTcwRmxTeXhobHRMMUNyN2d6TQ==">从零开始入门 K8s：详解 K8s 容器基本概念</span></li></ul><h1 id="docker-实战"><a class="anchor" href="#docker-实战">#</a> Docker 实战</h1><h2 id="安装"><a class="anchor" href="#安装">#</a> 安装</h2><h3 id="windows"><a class="anchor" href="#windows">#</a> Windows</h3><h3 id="mac"><a class="anchor" href="#mac">#</a> Mac</h3><p>直接使用 Homebrew 安装即可</p><figure class="highlight sh"><figcaption data-lang="sh"></figcaption><table><tr><td data-num="1"></td><td><pre>brew <span class="token function">install</span> <span class="token parameter variable">--cask</span> <span class="token function">docker</span></pre></td></tr></table></figure><h3 id="linux"><a class="anchor" href="#linux">#</a> Linux</h3><p>下面来看看 Linux 中如何安装 Docker，这里以 <strong>CentOS7</strong> 为例。</p><p>在测试或开发环境中，Docker 官方为了简化安装流程，提供了一套便捷的安装脚本，执行这个脚本后就会自动地将一切准备工作做好，并且把 Docker 的稳定版本安装在系统中。</p><figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">curl</span> <span class="token parameter variable">-fsSL</span> get.docker.com <span class="token parameter variable">-o</span> get-docker.sh</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">sh</span> get-docker.sh <span class="token parameter variable">--mirror</span> Aliyun</pre></td></tr></table></figure><p>安装完成后直接启动服务：</p><figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre>systemctl start <span class="token function">docker</span></pre></td></tr></table></figure><p>推荐设置开机自启，执行指令：</p><figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre>systemctl <span class="token builtin class-name">enable</span> <span class="token function">docker</span></pre></td></tr></table></figure><h2 id="几个概念"><a class="anchor" href="#几个概念">#</a> 几个概念</h2><h3 id="镜像image"><a class="anchor" href="#镜像image">#</a> 镜像（Image）</h3><p><font color="red">Image 是一个只读的模板，可以用来创建多个 Container </font>。</p><h3 id="容器container"><a class="anchor" href="#容器container">#</a> 容器（Container）</h3><p><font color="red">Container 是根据 Image 创建的运行实例</font>，Docker 利用 Container 独立运行一个或一组应用。它可以被启动、开始、停止、删除，每个 Container 都是相互隔离的、保证安全的平台。 可以把 Container 看作是一个简易的 Linux 环境和运行在其中的应用程序。Container 的定义和 Image 几乎一模一样，也是一堆层的统一视角，<font color="red">唯一区别在于 Container 的最上面那一层是可读可写的</font>。</p><h3 id="仓库repository"><a class="anchor" href="#仓库repository">#</a> 仓库（Repository）</h3><p><font color="red">仓库（Repository）是集中存放 Image 文件的场所</font>。仓库（Repository）和仓库注册服务器（Registry）是有区别的，<strong><font color="red">Registry 上往往存放着多个 Repository，每个 Repository 中又包含了多个 Image，每个 Image 有不同的 Tag</font></strong>。Repository 分为公开 Repository 和私有 Repository 两种形式，<font color="red">最大的公开 Repository 是 DockerHub</font>，存放了数量庞大的镜像供用户下载，<font color="red">国内的公开仓库有阿里云、网易云</font>等</p><h3 id="总结-2"><a class="anchor" href="#总结-2">#</a> 总结</h3><p>通俗点说，一个 Image 就代表一个软件；而基于某个 Image 运行就是生成一个程序实例，这个程序实例就是 Container ；而 Repository 是用来存储 Docker 中所有 Image 的。</p><p>其中 Repository 又分为远程 Repository 和本地 Repository。</p><p>和 Maven 类似，倘若每次都从远程下载依赖，则会大大降低效率。为此，Maven 的策略是第一次访问依赖时，将其下载到本地仓库，第二次、第三次使用时直接用本地仓库的依赖即可，Docker 的远程 Repository 和本地 Repository 的作用也是类似的。</p><h2 id="初体验"><a class="anchor" href="#初体验">#</a> 初体验</h2><p>下面我们来对 Docker 进行一个初步的使用，这里以下载一个 MySQL 的镜像为例 <code>(在CentOS7下进行)</code> 。</p><p>和 GitHub 一样，Docker 也提供了一个 DockerHub 用于查询各种镜像的地址和安装教程，为此，我们先访问 DockerHub：<span class="exturl" data-url="aHR0cHM6Ly9odWIuZG9ja2VyLmNvbS8=">https://hub.docker.com/</span></p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/dockerhub-com.png" alt="DockerHub"></p><center>DockerHub</center><p>在左上角的搜索框中输入 <code>MySQL</code> 并回车：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/dockerhub-mysql.png" alt="DockerHub 搜索 MySQL"></p><center>DockerHub 搜索 MySQL</center><p>可以看到相关 MySQL 的镜像非常多，若右上角有 <code>OFFICIAL IMAGE</code> 标识，则说明是官方镜像，所以我们点击第一个 MySQL 镜像：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/dockerhub-mysql-official-image.png" alt="MySQL 官方镜像"></p><center>MySQL 官方镜像</center><p>右边提供了下载 MySQL 镜像的指令为 <code>docker pull MySQL</code> ，但该指令始终会下载 MySQL 镜像的最新版本。</p><p>若是想下载指定版本的镜像，则点击下面的 <code>View Available Tags</code> ：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/dockerhub-mysql-view-available-tags.png" alt="查看其他版本的 MySQL"></p><center>查看其他版本的 MySQL</center><p>这里就可以看到各种版本的镜像，右边有下载的指令，所以若是想下载 5.7.32 版本的 MySQL 镜像，则执行：</p><figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">docker</span> pull MySQL:5.7.32</pre></td></tr></table></figure><hr><p>然而下载镜像的过程是非常慢的，所以我们需要配置一下镜像源加速下载，访问 <code>阿里云</code> 官网，点击<font color="red">控制台</font>：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/docker-aliyun-mirror-admin.png" alt="阿里云镜像加速"></p><center>阿里云镜像加速</center><p>然后点击左上角的菜单，在弹窗的窗口中，将鼠标悬停在<font color="red">产品与服务</font>上，并在右侧搜索<font color="red">容器镜像服务</font>，最后点击容器镜像服务：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/docker-aliyun-mirror-admin-accelerator.png" alt="阿里云镜像加速"></p><center>阿里云镜像加速</center><p>点击左侧的镜像加速器，并依次执行右侧的配置指令即可。</p><figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">sudo</span> <span class="token function">mkdir</span> <span class="token parameter variable">-p</span> /etc/docker</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">sudo</span> <span class="token function">tee</span> /etc/docker/daemon.json <span class="token operator">&lt;&lt;-</span><span class="token string">'EOF'</span></pre></td></tr><tr><td data-num="3"></td><td><pre>&#123;</pre></td></tr><tr><td data-num="4"></td><td><pre>  "registry-mirrors": ["https://679xpnpz.mirror.aliyuncs.com"]</pre></td></tr><tr><td data-num="5"></td><td><pre>&#125;</pre></td></tr><tr><td data-num="6"></td><td><pre>EOF</pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token function">sudo</span> systemctl daemon-reload</pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token function">sudo</span> systemctl restart <span class="token function">docker</span></pre></td></tr></table></figure><h2 id="image-指令"><a class="anchor" href="#image-指令">#</a> Image 指令</h2><p>若想 **<font color="red">查看 Docker 中当前拥有哪些镜像</font>**，则可以使用 <code>docker images</code> 命令。</p><figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token punctuation">[</span>root@izrcf5u3j3q8xaz ~<span class="token punctuation">]</span><span class="token comment"># docker images</span></pre></td></tr><tr><td data-num="2"></td><td><pre>REPOSITORY    TAG       IMAGE ID       CREATED         SIZE</pre></td></tr><tr><td data-num="3"></td><td><pre>MySQL         <span class="token number">5.7</span>.32    f07dfa83b528   <span class="token number">11</span> days ago     448MB</pre></td></tr><tr><td data-num="4"></td><td><pre>tomcat        latest    feba8d001e3f   <span class="token number">2</span> weeks ago     649MB</pre></td></tr><tr><td data-num="5"></td><td><pre>nginx         latest    ae2feff98a0c   <span class="token number">2</span> weeks ago     133MB</pre></td></tr><tr><td data-num="6"></td><td><pre>hello-world   latest    bf756fb1ae65   <span class="token number">12</span> months ago   <span class="token number">13</span>.3kB</pre></td></tr></table></figure><p>其中 <code>REPOSITORY</code> <font color="red">为镜像名</font>， <code>TAG</code> 为版本标志， <code>IMAGE ID</code> 为镜像 id (唯一的)， <code>CREATED</code> 为创建时间，注意这个时间并不是我们将镜像下载到 Docker 中的时间，而是<font color="red">镜像创建者创建的时间</font>， <code>SIZE</code> 为镜像大小。</p><hr><p>该指令能够 **<font color="red">根据镜像名查询指定镜像</font>**：</p><figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">docker</span> image MySQL</pre></td></tr></table></figure><p>若如此做，则会查询出 Docker 中的所有 MySQL 镜像：</p><figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token punctuation">[</span>root@izrcf5u3j3q8xaz ~<span class="token punctuation">]</span><span class="token comment"># docker images MySQL</span></pre></td></tr><tr><td data-num="2"></td><td><pre>REPOSITORY   TAG       IMAGE ID       CREATED         SIZE</pre></td></tr><tr><td data-num="3"></td><td><pre>MySQL        <span class="token number">5.6</span>       0ebb5600241d   <span class="token number">11</span> days ago     302MB</pre></td></tr><tr><td data-num="4"></td><td><pre>MySQL        <span class="token number">5.7</span>.32    f07dfa83b528   <span class="token number">11</span> days ago     448MB</pre></td></tr><tr><td data-num="5"></td><td><pre>MySQL        <span class="token number">5.5</span>       d404d78aa797   <span class="token number">20</span> months ago   205MB</pre></td></tr></table></figure><p>该指令还能够携带 <code>-q</code> 参数： <code>docker images -q</code> ， <code>-q</code> <font color="red">表示仅显示镜像的 id</font>：</p><figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token punctuation">[</span>root@izrcf5u3j3q8xaz ~<span class="token punctuation">]</span><span class="token comment"># docker images -q</span></pre></td></tr><tr><td data-num="2"></td><td><pre>0ebb5600241d</pre></td></tr><tr><td data-num="3"></td><td><pre>f07dfa83b528</pre></td></tr><tr><td data-num="4"></td><td><pre>feba8d001e3f</pre></td></tr><tr><td data-num="5"></td><td><pre>d404d78aa797</pre></td></tr></table></figure><hr><p>若是要 **<font color="red">下载指定版本的镜像</font>**，则使用：</p><figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">docker</span> pull MySQL:5.7</pre></td></tr></table></figure><p><code>docker pull</code> 是固定的，后面写上需要下载的镜像名及版本标志；若是不写版本标志，而是直接执行 <code>docker pull MySQL</code> ，则会下载镜像的最新版本。</p><p>一般在下载镜像前我们需要 **<font color="red">搜索一下镜像有哪些版本</font>** 才能对指定版本进行下载，使用指令：</p><figure class="highlight sh"><figcaption data-lang="sh"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">docker</span> search MySQL</pre></td></tr></table></figure><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/docker-search-mysql-terminal.png" alt="img"></p><p>不过该指令只能查看 MySQL 相关的镜像信息，而不能知道有哪些版本，若想知道版本，则只能这样查询：</p><figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">docker</span> search MySQL:5.5</pre></td></tr></table></figure><p>若是查询的版本不存在，则结果为空：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/docker-search-mysql-404-terminal.png" alt="img"></p><hr><p>**<font color="red">删除镜像</font>** 使用指令：</p><figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">docker</span> image <span class="token function">rm</span> MySQL:5.5</pre></td></tr></table></figure><p>若是不指定版本，则默认删除的也是最新版本。</p><p>还可以通过<font color="red">指定镜像 id 进行删除</font>：</p><figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">docker</span> image <span class="token function">rm</span> bf756fb1ae65</pre></td></tr></table></figure><p>然而此时报错了：</p><figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token punctuation">[</span>root@izrcf5u3j3q8xaz ~<span class="token punctuation">]</span><span class="token comment"># docker image rm bf756fb1ae65</span></pre></td></tr><tr><td data-num="2"></td><td><pre>Error response from daemon: conflict: unable to delete bf756fb1ae65 <span class="token punctuation">(</span>must be forced<span class="token punctuation">)</span> - image is being used by stopped container d5b6c177c151</pre></td></tr></table></figure><p>这是因为要删除的 <code>hello-world</code> 镜像正在运行中，所以无法删除镜像，此时需要<font color="red">强制执行删除</font>：</p><figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">docker</span> image <span class="token function">rm</span> <span class="token parameter variable">-f</span> bf756fb1ae65</pre></td></tr></table></figure><p><font color="red">该指令会将镜像和通过该镜像执行的容器全部删除，谨慎使用</font>。</p><hr><p>Docker 还提供了 **<font color="red">删除镜像的简化版本</font>**： <code>docker rmi 镜像名:版本标志</code> 。</p><p>此时我们即可借助 <code>rmi</code> 和 <code>-q</code> 进行一些联合操作，比如现在想删除所有的 MySQL 镜像，那么你需要查询出 MySQL 镜像的 id，并根据这些 id 一个一个地执行 <code>docker rmi</code> 进行删除，但是现在，我们可以这样：</p><figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">docker</span> rmi <span class="token parameter variable">-f</span> <span class="token variable"><span class="token variable">$(</span><span class="token function">docker</span> images MySQL <span class="token parameter variable">-q</span><span class="token variable">)</span></span></pre></td></tr></table></figure><p>首先通过 <code>docker images MySQL -q</code> 查询出 MySQL 的所有镜像 id， <code>-q</code> 表示仅查询 id，并将这些 id 作为参数传递给 <code>docker rmi -f</code> 指令，这样所有的 MySQL 镜像就都被删除了。</p><h2 id="container-指令"><a class="anchor" href="#container-指令">#</a> Container 指令</h2><p>掌握了镜像的相关指令之后，我们需要了解一下容器的指令，容器是基于镜像的。</p><p>若需要 **<font color="red">通过 Image 运行一个 Container</font>**，则使用：</p><figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">docker</span> run tomcat:8.0-jre8</pre></td></tr></table></figure><p>当然了，运行的前提是你拥有这个镜像，所以<font color="red">先下载镜像</font>：</p><figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">docker</span> pull tomcat:8.0-jre8</pre></td></tr></table></figure><hr><p>下载完成后就可以运行了，运行后 **<font color="red">查看一下当前运行的 Container</font>**： <code>docker ps</code> 。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/docker-ps-terminal.png" alt="img"></p><p>其中 <code>CONTAINER_ID</code> 为容器的 id， <code>IMAGE</code> 为镜像名， <code>COMMAND</code> <font color="red">为容器内执行的命令</font>， <code>CREATED</code> 为容器的创建时间， <code>STATUS</code> 为容器的状态， <code>PORTS</code> <font color="red">为容器内服务监听的端口</font>， <code>NAMES</code> <font color="red">为容器的名称</font>。</p><p>该指令有几个参数，比如 <code>-a</code> ：</p><figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">docker</span> <span class="token function">ps</span> <span class="token parameter variable">-a</span></pre></td></tr></table></figure><p>该参数会<font color="red">将运行和非运行的容器全部列举出来</font>。</p><p><code>-q</code> 参数将<font color="red">查询结果只显示容器 id</font>： <code>docker ps -q</code> 。</p><figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token punctuation">[</span>root@izrcf5u3j3q8xaz ~<span class="token punctuation">]</span><span class="token comment"># docker ps -q</span></pre></td></tr><tr><td data-num="2"></td><td><pre>f3aac8ee94a3</pre></td></tr><tr><td data-num="3"></td><td><pre>074bf575249b</pre></td></tr><tr><td data-num="4"></td><td><pre>1d557472a708</pre></td></tr><tr><td data-num="5"></td><td><pre>4421848ba294</pre></td></tr></table></figure><p>若是组合使用，则查询运行和非运行的所有容器 id： <code>docker ps -qa</code> 。</p><figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token punctuation">[</span>root@izrcf5u3j3q8xaz ~<span class="token punctuation">]</span><span class="token comment"># docker ps -aq</span></pre></td></tr><tr><td data-num="2"></td><td><pre>f3aac8ee94a3</pre></td></tr><tr><td data-num="3"></td><td><pre>7f7b0e80c841</pre></td></tr><tr><td data-num="4"></td><td><pre>074bf575249b</pre></td></tr><tr><td data-num="5"></td><td><pre>a1e830bddc4c</pre></td></tr><tr><td data-num="6"></td><td><pre>1d557472a708</pre></td></tr><tr><td data-num="7"></td><td><pre>4421848ba294</pre></td></tr><tr><td data-num="8"></td><td><pre>b0440c0a219a</pre></td></tr><tr><td data-num="9"></td><td><pre>c2f5d78c5d1a</pre></td></tr><tr><td data-num="10"></td><td><pre>5831d1bab2a6</pre></td></tr><tr><td data-num="11"></td><td><pre>d5b6c177c151</pre></td></tr></table></figure><hr><p>通过该方式运行的 tomcat 是不能直接被外部访问的，因为容器具有隔离性，若是想直接通过 8080 端口访问容器内部的 tomcat，则需要 **<font color="red">对宿主机端口与 Container 内的端口进行映射</font>**：</p><figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">docker</span> run <span class="token parameter variable">-p</span> <span class="token number">8080</span>:8080 tomcat:8.0-jre8</pre></td></tr></table></figure><p>解释一下这两个端口的作用 ( <code>8080:8080</code> )，<font color="red">第一个为宿主机端口，第二个为容器内的端口</font>，外部访问 8080 端口就会通过映射访问容器内的 8080 端口。</p><p>此时外部就可以访问 Tomcat 了：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/docker-run-tomact-8080.png" alt="img"></p><p>若是这样进行映射：</p><figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">docker</span> run <span class="token parameter variable">-p</span> <span class="token number">8088</span>:8080 tomcat:8.0-jre8</pre></td></tr></table></figure><p>则外部需访问 8088 端口才能访问 tomcat，需要注意的是，每次运行的容器都是相互独立的，所以<font color="red">同时运行多个 tomcat 容器并不会产生端口的冲突</font>。</p><hr><p><font color="red">通过 <code>-d</code> ，容器还能够以后台的方式运行</font>，这样就不会占用终端：</p><figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">-p</span> <span class="token number">8080</span>:8080 tomcat:8.0-jre8</pre></td></tr></table></figure><p>启动容器时默认会给容器一个名称，但<font color="red">容器名称其实是可以通过 <code>--name</code> 设置的</font>，使用指令：</p><figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">-p</span> <span class="token number">8080</span>:8080 <span class="token parameter variable">--name</span> tomcat01 tomcat:8.0-jre8</pre></td></tr></table></figure><p>此时的容器名称即为 tomcat01，<font color="red">容器名称必须是唯一的</font>。</p><hr><p>接下来是 **<font color="red">容器的运行、重启、暂停、杀死</font>** 指令，因为非常简单，就不过多介绍了。</p><figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">docker</span> start c2f5d78c5d1a</pre></td></tr></table></figure><p>通过该指令能够将已经停止运行的容器运行起来，可以通过容器的 id 启动，也可以通过容器的名称启动。</p><figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">docker</span> restart c2f5d78c5d1a</pre></td></tr></table></figure><p>该指令能够重启指定的容器。</p><figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">docker</span> stop c2f5d78c5d1a</pre></td></tr></table></figure><p>该指令能够停止指定的容器。</p><figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">docker</span> <span class="token function">kill</span> c2f5d78c5d1a</pre></td></tr></table></figure><p>该指令能够直接杀死指定的容器。</p><p>以上指令<font color="red">都能够通过容器的 id 和容器名称两种方式配合使用</font>。</p><hr><p>当容器被停止之后，容器虽然不再运行了，但仍然是存在的，若是想 **<font color="red">删除容器</font>**，则使用指令：</p><figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">docker</span> <span class="token function">rm</span> d5b6c177c151</pre></td></tr></table></figure><p>需要注意的是<font color="red">容器的 id 无需全部写出来，只需唯一标识即可</font>。</p><p>若是想 **<font color="red">删除正在运行的容器</font>**，则需要添加 <code>-f</code> 参数强制删除：</p><figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">docker</span> <span class="token function">rm</span> <span class="token parameter variable">-f</span> d5b6c177c151</pre></td></tr></table></figure><p>若是想 **<font color="red">删除所有容器</font>**，则可以使用组合指令：</p><figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">docker</span> <span class="token function">rm</span> <span class="token parameter variable">-f</span> <span class="token variable"><span class="token variable">$(</span><span class="token function">docker</span> <span class="token function">ps</span> <span class="token parameter variable">-qa</span><span class="token variable">)</span></span></pre></td></tr></table></figure><p>先通过 <code>docker ps -qa</code> 查询出所有容器的 id，然后通过 <code>docker rm -f</code> 进行删除。</p><hr><p>当容器以后台的方式运行时，我们无法知晓容器的运行状态，若此时需要 **<font color="red">查看容器的运行日志</font>**，则使用指令：</p><figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">docker</span> logs 289cc00dc5ed</pre></td></tr></table></figure><p>这样的方式显示的日志并不是实时的，若是想<font color="red">实时显示</font>，需要使用 <code>-f</code> 参数：</p><figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">docker</span> logs <span class="token parameter variable">-f</span> 289cc00dc5ed</pre></td></tr></table></figure><p>通过 <code>-t</code> 参数还能够<font color="red">显示日志的时间戳</font>，通常与 <code>-f</code> 参数联合使用：</p><figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">docker</span> logs <span class="token parameter variable">-ft</span> 289cc00dc5ed</pre></td></tr></table></figure><hr><p><strong><font color="red">查看容器内运行了哪些进程</font></strong>，可以使用指令：</p><figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">docker</span> <span class="token function">top</span> 289cc00dc5ed</pre></td></tr></table></figure><p>若是 **<font color="red">想与容器进行交互</font>**，则使用指令：</p><figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">docker</span> <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> 289cc00dc5ed <span class="token function">bash</span></pre></td></tr></table></figure><p><font color="red">此时终端将会进入容器内部，执行的指令都将在容器中生效</font>，在容器内只能执行一些比较简单的指令，如：ls、cd 等，若是想退出容器终端，重新回到 CentOS 中，则执行 <code>exit</code> 即可。</p><p>现在我们已经能够进入容器终端执行相关操作了，那么该如何向 tomcat 容器中部署一个项目呢？</p><figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">docker</span> <span class="token function">cp</span> ./test.html 289cc00dc5ed:/usr/local/tomcat/webapps</pre></td></tr></table></figure><p>通过 <code>docker cp</code> 指令能够将文件从 CentOS 复制到容器中， <code>./test.html</code> 为 CentOS 中的资源路径， <code>289cc00dc5ed</code> 为容器 id， <code>/usr/local/tomcat/webapps</code> 为容器的资源路径，此时 <code>test.html</code> 文件将会被复制到该路径下。</p><figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token punctuation">[</span>root@izrcf5u3j3q8xaz ~<span class="token punctuation">]</span><span class="token comment"># docker exec -it 289cc00dc5ed bash</span></pre></td></tr><tr><td data-num="2"></td><td><pre>root@289cc00dc5ed:/usr/local/tomcat<span class="token comment"># cd webapps</span></pre></td></tr><tr><td data-num="3"></td><td><pre>root@289cc00dc5ed:/usr/local/tomcat/webapps<span class="token comment"># ls</span></pre></td></tr><tr><td data-num="4"></td><td><pre>test.html</pre></td></tr><tr><td data-num="5"></td><td><pre>root@289cc00dc5ed:/usr/local/tomcat/webapps<span class="token comment">#</span></pre></td></tr></table></figure><p>若是想将容器内的文件复制到 CentOS 中，则反过来写即可：</p><figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">docker</span> <span class="token function">cp</span> 289cc00dc5ed:/usr/local/tomcat/webapps/test.html ./</pre></td></tr></table></figure><p>所以现在若是想要部署项目，则先将项目上传到 CentOS，然后将项目从 CentOS 复制到容器内，此时启动容器即可。</p><hr><p>虽然使用 Docker 启动软件环境非常简单，但同时也面临着一个问题，我们无法 **<font color="red">查看容器内部具体的细节，比如监听的端口、绑定的 ip 地址等等</font>**，好在这些 Docker 都帮我们想到了，只需使用指令：</p><figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">docker</span> inspect 923c969b0d91</pre></td></tr></table></figure><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/docker-inspect-terminal.png" alt="img"></p><hr><p>最后再介绍几个容器和镜像相关的指令：</p><figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">docker</span> commit <span class="token parameter variable">-m</span> <span class="token string">"描述信息"</span> <span class="token parameter variable">-a</span> <span class="token string">"镜像作者"</span> tomcat01 my_tomcat:1.0</pre></td></tr></table></figure><blockquote><p>tomcat01 为 Container 名称，my_tomcat 为打包后的 Image 名称，1.0 是对应的 tag。</p></blockquote><p>该指令能够 **<font color="red">将 Container 打包成一个 Image</font>**，此时查询镜像：</p><figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token punctuation">[</span>root@centos-7 _data<span class="token punctuation">]</span><span class="token comment"># docker images</span></pre></td></tr><tr><td data-num="2"></td><td><pre>REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</pre></td></tr><tr><td data-num="3"></td><td><pre>my_tomcat           <span class="token number">1.0</span>                 79ab047fade5        <span class="token number">2</span> seconds ago       463MB</pre></td></tr><tr><td data-num="4"></td><td><pre>tomcat              <span class="token number">8</span>                   a041be4a5ba5        <span class="token number">2</span> weeks ago         533MB</pre></td></tr><tr><td data-num="5"></td><td><pre>MySQL               latest              db2b37ec6181        <span class="token number">2</span> months ag</pre></td></tr></table></figure><p>若是想 **<font color="red">将 Image 备份出来</font>** 出来，则可以使用指令：</p><figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">docker</span> save my_tomcat:1.0 <span class="token parameter variable">-o</span> my-tomcat-1.0.tar</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">[</span>root@centos-7 ~<span class="token punctuation">]</span><span class="token comment"># docker save my_tomcat:1.0 -o my-tomcat-1.0.tar</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">[</span>root@centos-7 ~<span class="token punctuation">]</span><span class="token comment"># ls</span></pre></td></tr><tr><td data-num="4"></td><td><pre>anaconda-ks.cfg  initial-setup-ks.cfg  公共  视频  文档  音乐</pre></td></tr><tr><td data-num="5"></td><td><pre>get-docker.sh    my-tomcat-1.0.tar     模板  图片  下载  桌面</pre></td></tr></table></figure><p><strong><font color="red">将 .tar 格式的 Image 加载到 Docker 中</font></strong>，执行指令：</p><figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">docker</span> load <span class="token parameter variable">-i</span> my-tomcat-1.0.tar</pre></td></tr><tr><td data-num="2"></td><td><pre>root@centos-7 ~<span class="token punctuation">]</span><span class="token comment"># docker load -i my-tomcat-1.0.tar</span></pre></td></tr><tr><td data-num="3"></td><td><pre>b28ef0b6fef8: Loading layer <span class="token punctuation">[</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">></span><span class="token punctuation">]</span>  <span class="token number">105</span>.5MB/105.5MB</pre></td></tr><tr><td data-num="4"></td><td><pre>0b703c74a09c: Loading layer <span class="token punctuation">[</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">></span><span class="token punctuation">]</span>  <span class="token number">23</span>.99MB/23.99MB</pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span></pre></td></tr><tr><td data-num="6"></td><td><pre>Loaded image: my_tomcat:1.0</pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">[</span>root@centos-7 ~<span class="token punctuation">]</span><span class="token comment"># docker images</span></pre></td></tr><tr><td data-num="8"></td><td><pre>REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</pre></td></tr><tr><td data-num="9"></td><td><pre>my_tomcat           <span class="token number">1.0</span>                 79ab047fade5        <span class="token number">7</span> minutes ag</pre></td></tr></table></figure><h2 id="数据卷volume"><a class="anchor" href="#数据卷volume">#</a> 数据卷（volume）</h2><p>学习了容器的相关指令之后，我们来了解一下<font color="red"> Docker 中的数据卷，它能够实现<strong>宿主机与容器之间的文件共享</strong>，它的好处在于我们<strong>对宿主机的文件进行修改将直接影响容器</strong>，而无需再将宿主机的文件再复制到容器中</font>。</p><p>现在若是想将宿主机中 <code>/opt/apps</code> 目录与容器中 <code>webapps</code> 目录 **<font color="red">做一个数据卷</font>**，则应该通过 <code>-v</code> 参数这样编写指令：</p><figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">-p</span> <span class="token number">8080</span>:8080 <span class="token parameter variable">--name</span> tomcat01 <span class="token parameter variable">-v</span> /opt/apps:/usr/local/tomcat/webapps tomcat:8.0-jre8</pre></td></tr></table></figure><p>然而此时访问 tomcat 会发现无法访问：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/docker-data-volume-webapp-8080.png" alt="img"></p><p>这就说明我们的数据卷设置成功了，Docker 会将容器内的 <code>webapps</code> 目录与 <code>/opt/apps</code> 目录进行同步，而此时 <code>/opt/apps</code> 目录是空的，导致 <code>webapps</code> 目录也会变成空目录，所以就访问不到了。</p><p>此时我们只需向 <code>/opt/apps</code> 目录下添加文件，就会使得 <code>webapps</code> 目录也会拥有相同的文件，达到文件共享，测试一下：</p><figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token punctuation">[</span>root@centos-7 opt<span class="token punctuation">]</span><span class="token comment"># cd apps/</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">[</span>root@centos-7 apps<span class="token punctuation">]</span><span class="token comment"># vim test.html</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">[</span>root@centos-7 apps<span class="token punctuation">]</span><span class="token comment"># ls</span></pre></td></tr><tr><td data-num="4"></td><td><pre>test.html</pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">[</span>root@centos-7 apps<span class="token punctuation">]</span><span class="token comment"># cat test.html</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token operator">&lt;</span>h<span class="token operator"><span class="token file-descriptor important">1</span>></span>This is a <span class="token builtin class-name">test</span> html<span class="token operator">!</span><span class="token operator">&lt;</span>/h<span class="token operator"><span class="token file-descriptor important">1</span>></span></pre></td></tr></table></figure><p>在 <code>/opt/apps</code> 目录下创建了一个 <code>test.html</code> 文件，那么容器内的 <code>webapps</code> 目录是否会有该文件呢？进入容器的终端：</p><figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token punctuation">[</span>root@centos-7 apps<span class="token punctuation">]</span><span class="token comment"># docker exec -it tomcat01 bash</span></pre></td></tr><tr><td data-num="2"></td><td><pre>root@115155c08687:/usr/local/tomcat<span class="token comment"># cd webapps/</span></pre></td></tr><tr><td data-num="3"></td><td><pre>root@115155c08687:/usr/local/tomcat/webapps<span class="token comment"># ls</span></pre></td></tr><tr><td data-num="4"></td><td><pre>test.html</pre></td></tr></table></figure><p>容器内确实已经有了该文件，那接下来我们编写一个简单的 Web 应用：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HelloServlet</span> <span class="token keyword">extends</span> <span class="token class-name">HttpServlet</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token annotation punctuation">@Override</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">doGet</span><span class="token punctuation">(</span><span class="token class-name">HttpServletRequest</span> req<span class="token punctuation">,</span> <span class="token class-name">HttpServletResponse</span> resp<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ServletException</span><span class="token punctuation">,</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        resp<span class="token punctuation">.</span><span class="token function">getWriter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Hello World!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token annotation punctuation">@Override</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">doPost</span><span class="token punctuation">(</span><span class="token class-name">HttpServletRequest</span> req<span class="token punctuation">,</span> <span class="token class-name">HttpServletResponse</span> resp<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ServletException</span><span class="token punctuation">,</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token function">doGet</span><span class="token punctuation">(</span>req<span class="token punctuation">,</span>resp<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>这是一个非常简单的 Servlet，我们将其打包上传到 <code>/opt/apps</code> 中，那么容器内肯定就会同步到该文件，此时进行访问：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/docker-data-volume-webapp-8080-hello-world.png" alt="img"></p><hr><p>这种方式设置的数据卷称为<font color="red">自定义数据卷</font>，因为数据卷的目录是由我们自己设置的，Docker 还为我们提供了 **<font color="red">另外一种设置数据卷的方式</font>**：</p><figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">-p</span> <span class="token number">8080</span>:8080 <span class="token parameter variable">--name</span> tomcat01 <span class="token parameter variable">-v</span> aa:/usr/local/tomcat/webapps tomcat:8.0-jre8</pre></td></tr></table></figure><p>此时的 <code>aa</code> 并不是数据卷的目录，而是<font color="red">数据卷的别名</font>，Docker 会为我们自动创建一个名为 <code>aa</code> 的数据卷，并且会将容器内 <code>webapps</code> 目录下的所有内容复制到数据卷中，<font color="red">该数据卷的位置在</font> <code>/var/lib/docker/volumes</code> 目录下：</p><figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token punctuation">[</span>root@centos-7 volumes<span class="token punctuation">]</span><span class="token comment"># pwd</span></pre></td></tr><tr><td data-num="2"></td><td><pre>/var/lib/docker/volumes</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">[</span>root@centos-7 volumes<span class="token punctuation">]</span><span class="token comment"># cd aa/</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">[</span>root@centos-7 aa<span class="token punctuation">]</span><span class="token comment"># ls</span></pre></td></tr><tr><td data-num="5"></td><td><pre>_data</pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">[</span>root@centos-7 aa<span class="token punctuation">]</span><span class="token comment"># cd _data/</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">[</span>root@centos-7 _data<span class="token punctuation">]</span><span class="token comment"># ls</span></pre></td></tr><tr><td data-num="8"></td><td><pre>docs  examples  host-manager  manager  ROOT</pre></td></tr></table></figure><p>此时我们只需修改该目录的内容就能能够影响到容器。</p></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2024-01-21 19:48:45" itemprop="dateModified" datetime="2024-01-21T19:48:45+08:00">2024-01-21</time> </span><span id="docker/docker-javaguide/" class="item leancloud_visitors" data-flag-title="docker-javaguide" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>范特东东东 <i class="ic i-at"><em>@</em></i>水文 & 摄影</li><li class="link"><strong>本文链接：</strong> <a href="http://example.com/docker/docker-javaguide/" title="docker-javaguide">http://example.com/docker/docker-javaguide/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/project/12306/12306%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;hjx159&#x2F;picture-bed&#x2F;main&#x2F;img&#x2F;12306-base-biz-20230801.png" title="12306项目学习笔记"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i></span><h3>12306项目学习笔记</h3></a></div><div class="item right"><a href="/mq/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;hjx159&#x2F;picture-bed&#x2F;main&#x2F;img&#x2F;p68921.png" title="消息队列"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> 消息队列</span><h3>消息队列</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#docker-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="toc-number">1.</span> <span class="toc-text">Docker 核心概念</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8"><span class="toc-number">1.1.</span> <span class="toc-text">容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.1.1.</span> <span class="toc-text">容器是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E8%A7%A3%E7%89%A9%E7%90%86%E6%9C%BA-%E8%99%9A%E6%8B%9F%E6%9C%BA-%E5%AE%B9%E5%99%A8"><span class="toc-number">1.1.2.</span> <span class="toc-text">图解：物理机、虚拟机、容器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#docker-%E6%80%9D%E6%83%B3"><span class="toc-number">1.2.</span> <span class="toc-text">Docker 思想</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#docker-%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.2.1.</span> <span class="toc-text">Docker 是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#docker-%E6%80%9D%E6%83%B3-2"><span class="toc-number">1.2.2.</span> <span class="toc-text">Docker 思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#docker-%E5%AE%B9%E5%99%A8%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">1.2.3.</span> <span class="toc-text">Docker 容器的特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8-docker"><span class="toc-number">1.2.4.</span> <span class="toc-text">为什么使用 Docker</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8-vs-%E8%99%9A%E6%8B%9F%E6%9C%BA"><span class="toc-number">1.3.</span> <span class="toc-text">容器 vs 虚拟机</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E6%AF%94%E5%9B%BE"><span class="toc-number">1.3.1.</span> <span class="toc-text">对比图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E8%80%85%E6%80%BB%E7%BB%93"><span class="toc-number">1.3.2.</span> <span class="toc-text">二者总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E8%80%85%E5%8F%AF%E5%85%B1%E5%AD%98"><span class="toc-number">1.3.3.</span> <span class="toc-text">二者可共存</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#docker-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.4.</span> <span class="toc-text">Docker 基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%95%9C%E5%83%8Fimage%E4%B8%80%E4%B8%AA%E7%89%B9%E6%AE%8A%E7%9A%84%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.4.1.</span> <span class="toc-text">镜像（Image）：一个特殊的文件系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8containerimage-%E8%BF%90%E8%A1%8C%E6%97%B6%E7%9A%84%E5%AE%9E%E4%BD%93"><span class="toc-number">1.4.2.</span> <span class="toc-text">容器（Container）：Image 运行时的实体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%93%E5%BA%93repository%E9%9B%86%E4%B8%AD%E5%AD%98%E6%94%BE-image-%E6%96%87%E4%BB%B6%E7%9A%84%E5%9C%B0%E6%96%B9"><span class="toc-number">1.4.3.</span> <span class="toc-text">仓库（Repository）：集中存放 Image 文件的地方</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-number">1.4.3.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#registry-%E5%85%AC%E5%BC%80%E6%9C%8D%E5%8A%A1"><span class="toc-number">1.4.3.2.</span> <span class="toc-text">Registry 公开服务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A7%81%E6%9C%89-registry"><span class="toc-number">1.4.3.3.</span> <span class="toc-text">私有 Registry</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dockerfile"><span class="toc-number">1.4.4.</span> <span class="toc-text">Dockerfile</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#docker-compose"><span class="toc-number">1.4.5.</span> <span class="toc-text">Docker Compose</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#docker-%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4"><span class="toc-number">1.5.</span> <span class="toc-text">Docker 常见命令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4"><span class="toc-number">1.5.1.</span> <span class="toc-text">基本命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%89%E5%8F%96%E9%95%9C%E5%83%8F"><span class="toc-number">1.5.2.</span> <span class="toc-text">拉取镜像</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E9%95%9C%E5%83%8F"><span class="toc-number">1.5.3.</span> <span class="toc-text">删除镜像</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#docker-%E4%B8%A4%E5%8F%A5%E5%8F%A3%E5%8F%B7"><span class="toc-number">1.6.</span> <span class="toc-text">Docker 两句口号</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#docker-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="toc-number">1.7.</span> <span class="toc-text">Docker 底层原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF"><span class="toc-number">1.7.1.</span> <span class="toc-text">虚拟化技术</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#docker-%E5%9F%BA%E4%BA%8E-lxc-%E8%99%9A%E6%8B%9F%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF"><span class="toc-number">1.7.2.</span> <span class="toc-text">Docker 基于 LXC 虚拟容器技术</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.8.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#docker-%E5%AE%9E%E6%88%98"><span class="toc-number">2.</span> <span class="toc-text">Docker 实战</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E8%A3%85"><span class="toc-number">2.1.</span> <span class="toc-text">安装</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#windows"><span class="toc-number">2.1.1.</span> <span class="toc-text">Windows</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mac"><span class="toc-number">2.1.2.</span> <span class="toc-text">Mac</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#linux"><span class="toc-number">2.1.3.</span> <span class="toc-text">Linux</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%A0%E4%B8%AA%E6%A6%82%E5%BF%B5"><span class="toc-number">2.2.</span> <span class="toc-text">几个概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%95%9C%E5%83%8Fimage"><span class="toc-number">2.2.1.</span> <span class="toc-text">镜像（Image）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8container"><span class="toc-number">2.2.2.</span> <span class="toc-text">容器（Container）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%93%E5%BA%93repository"><span class="toc-number">2.2.3.</span> <span class="toc-text">仓库（Repository）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-2"><span class="toc-number">2.2.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9D%E4%BD%93%E9%AA%8C"><span class="toc-number">2.3.</span> <span class="toc-text">初体验</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#image-%E6%8C%87%E4%BB%A4"><span class="toc-number">2.4.</span> <span class="toc-text">Image 指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#container-%E6%8C%87%E4%BB%A4"><span class="toc-number">2.5.</span> <span class="toc-text">Container 指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%8D%B7volume"><span class="toc-number">2.6.</span> <span class="toc-text">数据卷（volume）</span></a></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li class="active"><a href="/docker/docker-javaguide/" rel="bookmark" title="docker-javaguide">docker-javaguide</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="范特东东东" data-src="/images/avatar.jpg"><p class="name" itemprop="name">范特东东东</p><div class="description" itemprop="description"></div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">62</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">19</span> <span class="name">分类</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hqeDE1OQ==" title="https:&#x2F;&#x2F;github.com&#x2F;hjx159"><i class="ic i-github"></i></span> <span class="exturl item xiaohongshu" data-url="aHR0cHM6Ly93d3cueGlhb2hvbmdzaHUuY29tL3VzZXIvcHJvZmlsZS81ZTAyYzhhZDAwMDAwMDAwMDEwMDFmM2U=" title="https:&#x2F;&#x2F;www.xiaohongshu.com&#x2F;user&#x2F;profile&#x2F;5e02c8ad0000000001001f3e"><i class="ic i-xiaohongshu2"></i></span> <span class="exturl item email" data-url="bWFpbHRvOjgxMjE0MzI4MEBxcS5jb20=" title="mailto:812143280@qq.com"><i class="ic i-envelope"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><a href="/categories/photography/" rel="section"><i class="ic i-photography"></i>摄影</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于我</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/project/12306/12306%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/mq/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/distributed-microservices/" title="分类于 分布式微服务">分布式微服务</a></div><span><a href="/distributed-microservices/%E5%88%86%E5%B8%83%E5%BC%8F%E7%90%86%E8%AE%BA&%E7%AE%97%E6%B3%95&%E5%8D%8F%E8%AE%AE/" title="分布式理论&amp;算法&amp;协议">分布式理论&算法&协议</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/photography/" title="分类于 摄影">摄影</a></div><span><a href="/photography/%E8%88%B9%E5%A4%AB%E8%9C%80%E9%BB%8D/" title="船夫蜀黍">船夫蜀黍</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/java/" title="分类于 Java">Java</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/" title="分类于 Java基础">Java基础</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/java-knowledge/" title="分类于 Java基础-知识点">Java基础-知识点</a></div><span><a href="/java/java-se/java-knowledge/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E5%AE%8B%E7%BA%A2%E5%BA%B7_%E7%AC%AC11%E7%AB%A0_%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%92%8C%E5%9F%BA%E7%A1%80API/" title="宋红康_第11章_常用类和基础API">宋红康_第11章_常用类和基础API</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/java/" title="分类于 Java">Java</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/" title="分类于 Java基础">Java基础</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/java-knowledge/" title="分类于 Java基础-知识点">Java基础-知识点</a></div><span><a href="/java/java-se/java-knowledge/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E5%AE%8B%E7%BA%A2%E5%BA%B7_%E7%AC%AC18%E7%AB%A0_JDK8-17%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%88%E4%B8%8B%EF%BC%89/" title="宋红康_第18章_JDK8-17新特性（下）">宋红康_第18章_JDK8-17新特性（下）</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/database/" title="分类于 数据库">数据库</a> <i class="ic i-angle-right"></i> <a href="/categories/database/redis/" title="分类于 Redis">Redis</a></div><span><a href="/database/redis/%E5%B0%9A%E7%A1%85%E8%B0%B7-%E5%91%A8%E9%98%B3-Redis7/" title="Redis7-尚硅谷-周阳">Redis7-尚硅谷-周阳</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/database/" title="分类于 数据库">数据库</a> <i class="ic i-angle-right"></i> <a href="/categories/database/mongodb/" title="分类于 MongoDB">MongoDB</a></div><span><a href="/database/mongodb/MongoDB-JavaGuide/" title="MongoDB-JavaGuide">MongoDB-JavaGuide</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/leetcode/" title="分类于 LeetCode">LeetCode</a> <i class="ic i-angle-right"></i> <a href="/categories/leetcode/carl/" title="分类于 代码随想录">代码随想录</a></div><span><a href="/leetcode/carl/%E7%AC%94%E8%AE%B0%E9%9A%8F%E6%83%B3%E5%BD%95/" title="代码随想录-笔记">代码随想录-笔记</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/java/" title="分类于 Java">Java</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/" title="分类于 Java基础">Java基础</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/java-knowledge/" title="分类于 Java基础-知识点">Java基础-知识点</a></div><span><a href="/java/java-se/java-knowledge/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E5%AE%8B%E7%BA%A2%E5%BA%B7_%E7%AC%AC02%E7%AB%A0_%E5%8F%98%E9%87%8F%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6/" title="宋红康_第02章_变量与运算符">宋红康_第02章_变量与运算符</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/project/12306/12306%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="12306项目学习笔记">12306项目学习笔记</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/java/" title="分类于 Java">Java</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/" title="分类于 Java基础">Java基础</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/java-excise/" title="分类于 Java基础-真题">Java基础-真题</a></div><span><a href="/java/java-se/java-excise/%E7%AC%AC09%E7%AB%A0%EF%BC%9A%E9%9A%8F%E5%A0%82%E5%A4%8D%E4%B9%A0%E4%B8%8E%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%A2%98%EF%BC%88%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%EF%BC%89/" title="宋红康_第09章：异常处理">宋红康_第09章：异常处理</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">范特东东东 @ fantedong</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">1.9m 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">28:54</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"docker/docker-javaguide/",favicon:{show:"(●´3｀●)欢迎回来",hide:"(〃＞皿＜)你快回来"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hrmmi -->