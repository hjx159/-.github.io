<!-- build time:Sat Jan 20 2024 16:21:29 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="水文 & 摄影" href="http://example.com/rss.xml"><link rel="alternate" type="application/atom+xml" title="水文 & 摄影" href="http://example.com/atom.xml"><link rel="alternate" type="application/json" title="水文 & 摄影" href="http://example.com/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><link rel="canonical" href="http://example.com/docker/docker-javaguide/"><title>docker-javaguide - docker | fantedong = 水文 & 摄影 = 为了能更好地访问图片，你需要一点魔法</title><meta name="generator" content="Hexo 6.3.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">docker-javaguide</h1><div class="meta"><span class="item" title="创建时间：2024-01-19 11:24:09"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2024-01-19T11:24:09+08:00">2024-01-19</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>7.7k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>7 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">fantedong</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><img src="https://pic.imgdb.cn/item/65a9ebfb871b83018a3cb132.jpg"></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/docker/" itemprop="item" rel="index" title="分类于 docker"><span itemprop="name">docker</span></a><meta itemprop="position" content="1"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://example.com/docker/docker-javaguide/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="范特东东东"><meta itemprop="description" content="为了能更好地访问图片，你需要一点魔法, "></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="水文 & 摄影"></span><div class="body md" itemprop="articleBody"><h1 id="docker-核心概念"><a class="anchor" href="#docker-核心概念">#</a> Docker 核心概念</h1><h2 id="容器"><a class="anchor" href="#容器">#</a> 容器</h2><p><strong>Docker 是世界领先的软件容器平台</strong>，所以想要搞懂 Docker 的概念我们必须先从容器开始说起。</p><h3 id="容器是什么"><a class="anchor" href="#容器是什么">#</a> 容器是什么</h3><p>一句话概括容器：<strong><font color="red">容器就是将软件打包成标准化单元，以用于开发、交付和部署。</font></strong></p><ul><li><strong>容器镜像是轻量的、可执行的独立软件包</strong>，包含软件运行所需的所有内容：代码、运行时环境、系统工具、系统库和设置。</li><li><strong>容器化软件适用于基于 Linux 和 Windows 的应用，在任何环境中都能够始终如一地运行。</strong></li><li><strong>容器赋予了软件独立性</strong>，使其免受外在环境差异（例如，开发和预演环境的差异）的影响，从而有助于减少团队间在相同基础设施上运行不同软件时的冲突。</li></ul><p>如果需要通俗地描述容器的话，我觉得容器就是一个存放东西的地方，就像书包可以装各种文具、衣柜可以放各种衣服、鞋架可以放各种鞋子一样。我们现在所说的容器存放的东西可能更偏向于应用比如网站、程序甚至是系统环境。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/container.png" alt="认识容器"></p><center>认识容器</center><h3 id="图解物理机-虚拟机-容器"><a class="anchor" href="#图解物理机-虚拟机-容器">#</a> 图解：物理机、虚拟机、容器</h3><p><strong>物理机：</strong></p><p><img data-src="https://oss.javaguide.cn/github/javaguide/tools/docker/%E7%89%A9%E7%90%86%E6%9C%BA%E5%9B%BE%E8%A7%A3.jpeg" alt="物理机"></p><p><strong>虚拟机：</strong></p><p><img data-src="https://oss.javaguide.cn/github/javaguide/tools/docker/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%9B%BE%E8%A7%A3.jpeg" alt="虚拟机"></p><p><strong>容器：</strong></p><p><img data-src="https://oss.javaguide.cn/javaguide/image-20211110104003678.png" alt="img"></p><p>通过上面这三张抽象图，我们可以大概通过类比概括出：<strong><font color="red">容器虚拟化的是操作系统而不是硬件，容器之间是共享同一套操作系统资源的</font>。虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统。<font color="red">因此容器的隔离级别会稍低一些</font>。</strong></p><h2 id="docker-思想"><a class="anchor" href="#docker-思想">#</a> Docker 思想</h2><h3 id="docker-是什么"><a class="anchor" href="#docker-是什么">#</a> Docker 是什么</h3><p>通过四点向你说明 Docker 到底是个什么东西。</p><ul><li><strong>Docker 是世界领先的<font color="red">软件容器平台</font>，基于<font color="red"> Go 语言</font> 进行开发实现。</strong></li><li><strong>Docker 可以<font color="red">对进程进行封装隔离</font>，属于操作系统层面的虚拟化技术</strong>。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。</li><li><strong><font color="red">Docker 能够自动执行重复性任务，例如搭建和配置开发环境</font>，从而解放了开发人员。</strong></li><li><strong>用户可以方便地<font color="red">创建和使用容器</font>，把自己的应用放入容器。容器还可以进行<font color="red">版本管理、复制、分享、修改</font>，就像管理普通的代码一样。</strong></li></ul><h3 id="docker-思想-2"><a class="anchor" href="#docker-思想-2">#</a> Docker 思想</h3><ul><li><strong>集装箱</strong></li><li><strong>标准化</strong><ul><li>运输方式</li><li>存储方式</li><li>API 接口</li></ul></li><li><strong>隔离</strong></li></ul><h3 id="docker-容器的特点"><a class="anchor" href="#docker-容器的特点">#</a> Docker 容器的特点</h3><p><strong><font color="red">轻量</font></strong> : 在一台机器上运行的多个 Docker 容器可以<font color="red">共享这台机器的操作系统内核</font>；它们能够迅速启动，只需<font color="red">占用很少的计算和内存资源</font>。镜像是通过文件系统层进行构造的，并共享一些公共文件。这样就能尽量降低磁盘用量，并能更快地下载镜像。</p><p><strong><font color="red">标准</font></strong> : Docker 容器<font color="red">基于开放式标准</font>，能够在所有主流 Linux 版本、Microsoft Windows 以及包括 VM、裸机服务器和云在内的任何基础设施上运行。</p><p><strong><font color="red">安全</font></strong> : Docker 赋予应用的隔离性不仅限于彼此隔离，还独立于底层的基础设施。Docker <font color="red">默认提供最强的隔离</font>，因此应用出现问题，也只是单个容器的问题，而不会波及到整台机器。</p><h3 id="为什么使用-docker"><a class="anchor" href="#为什么使用-docker">#</a> 为什么使用 Docker</h3><p><font color="red">借助 Docker，开发者可以将他们的应用以及依赖包<strong>打包</strong>到一个<strong>轻量级、可移植</strong>的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化</font>。</p><p>容器是完全使用<font color="red">沙箱机制，相互之间不会有任何接口</font>（类似 iPhone 的 app），更重要的是容器性能<font color="red">开销极低</font>。</p><p>传统的开发流程中，我们的项目通常需要使用 MySQL、Redis、FastDFS 等等环境，这些环境都是需要我们手动去进行下载并配置的，安装配置流程极其复杂，而且不同系统下的操作也不一样。</p><p>Docker 的出现完美地解决了这一问题，我们<font color="red">可以在容器中安装 MySQL、Redis 等软件环境，使得应用和环境架构分开</font>，它的优势在于：</p><ul><li><strong><font color="red">一致的运行环境</font>：Docker 的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性，从而不会再出现 “这段代码在我机器上没问题啊” 这类问题；</strong></li><li><strong><font color="red">快速启动</font>：可以做到秒级、甚至毫秒级的启动时间，大大的节约了开发、测试、部署的时间；</strong></li><li><strong><font color="red">隔离性</font>：避免公用的服务器，资源会容易受到其他用户的影响；</strong></li><li><strong><font color="red">弹性伸缩，快速扩展</font>：善于处理集中爆发的服务器使用压力；</strong></li><li><strong><font color="red">迁移方便</font>：可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况；</strong></li><li><strong><font color="red">持续交付和部署</font>：使用 Docker 可以通过定制应用镜像来实现持续集成、持续交付、部署；</strong></li></ul><h2 id="容器-vs-虚拟机"><a class="anchor" href="#容器-vs-虚拟机">#</a> 容器 vs 虚拟机</h2><p><strong>每当说起容器，我们不得不将其与虚拟机做一个比较。就我而言，对于两者无所谓谁会取代谁，而是<font color="red">两者可以和谐共存</font>。</strong></p><p>简单来说：<strong>容器和虚拟机具有相似的资源隔离和分配优势，但功能有所不同，因为<font color="red">容器虚拟化的是操作系统，而不是硬件，因此容器更容易移植，效率也更高</font>。</strong></p><h3 id="对比图"><a class="anchor" href="#对比图">#</a> 对比图</h3><p>传统虚拟机技术（VM）是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；而<font color="red">容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核</font>，而且也没有进行硬件虚拟。<font color="red">因此容器要比传统虚拟机更为轻便</font>。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/2e2b95eebf60b6d03f6c1476f4d7c697.png" alt="img"></p><h3 id="二者总结"><a class="anchor" href="#二者总结">#</a> 二者总结</h3><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/4ef8691d67eb1eb53217099d0a691eb5.png" alt="img"></p><ul><li><strong><font color="red">容器是一个应用层抽象，用于将代码和依赖资源打包在一起。多个容器可以在同一台机器上运行，共享操作系统内核，但各自作为独立的进程在用户空间中运行</font></strong>。与虚拟机相比， <strong>容器占用的空间较少</strong>（容器镜像大小通常只有几十兆），<strong>瞬间就能完成启动</strong>。</li><li><strong><font color="red">虚拟机 (VM) 是一个物理硬件层抽象，用于将一台服务器变成多台服务器</font>。</strong> 管理程序允许多个 VM 在一台机器上运行。每个 VM 都包含一整套操作系统、一个或多个应用、必要的二进制文件和库资源，因此 <strong>占用大量空间</strong> 。而且 VM <strong>启动也十分缓慢</strong> 。</li></ul><p>通过 Docker 官网，我们知道了这么多 Docker 的优势，但是大家也没有必要完全否定虚拟机技术，因为两者有不同的使用场景。<strong><font color="red">虚拟机更擅长于彻底隔离整个运行环境</font></strong>。例如，云服务提供商通常采用虚拟机技术隔离不同的用户。而 <strong><font color="red">Docker 通常用于隔离不同的应用</font></strong> ，例如前端，后端以及数据库。</p><h3 id="二者可共存"><a class="anchor" href="#二者可共存">#</a> 二者可共存</h3><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/056c87751b9dd7b56f4264240fe96d00.png" alt="img"></p><center>Docker与虚拟机的共存关系</center><h2 id="docker-基本概念"><a class="anchor" href="#docker-基本概念">#</a> Docker 基本概念</h2><p>Docker 中有非常重要的三个基本概念，理解了这三个概念，就理解了 Docker 的整个生命周期。</p><ul><li><p><strong><font color="cornflowerblue">镜像（Image）</font></strong>：相当于是一个 root 文件系统，是<font color="red">用于创建 Container 的模板</font>。</p></li><li><p><strong><font color="cornflowerblue">容器（Container）</font></strong>：Image 和 Container 的关系，就像是面向对象程序设计中的类和实例一样，<strong><font color="red">Image 是静态的定义（类），Container 是 Image 运行时的实体（实例）</font></strong>。Container 是独立运行的一个或一组应用，<font color="red">是 Image 运行时的实体</font>，可以被创建、启动、停止、删除、暂停等。</p></li><li><p><strong><font color="cornflowerblue">仓库（Repository）</font></strong>：用来<font color="red">存放 Image </font>的仓库，类似于代码控制中心。</p><blockquote><p><strong><font color="cornflowerblue">注册表（Registry）</font></strong>：<font color="red">包含多个 Repository，每个 Repository 可以包含多个 Tag，每个 Tag 对应一个 Image </font>。</p></blockquote></li></ul><p>理解了这三个概念，就理解了<font color="red"> Docker 的整个生命周期</font>。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/docker-overview.png" alt="An Introductory Guide To Docker for Beginners"></p><center>Docker 基本概念</center><h3 id="镜像image一个特殊的文件系统"><a class="anchor" href="#镜像image一个特殊的文件系统">#</a> 镜像（Image）：一个特殊的文件系统</h3><p><strong>操作系统分为内核和用户空间</strong>。对于 Linux 而言，内核启动后，会挂载 root 文件系统为其提供用户空间支持。而 Image 就相当于是一个 root 文件系统。</p><p><strong>Image 是一个特殊的文件系统，除了<font color="red">提供容器运行时所需的程序、库、资源、配置等文件</font>外，还<font color="red">包含了一些为运行时准备的配置参数（如匿名卷、环境变量、用户等）</font>。</strong><font color="red">Image 不包含任何动态数据，其内容在构建之后也不会被改变</font>。</p><p>Docker 设计时，就充分利用 <strong>Union FS</strong> 的技术，将其设计为<strong>分层存储的架构</strong>。Image 实际是由多层文件系统联合组成。</p><p>**<font color="red">Image 是逐层构建的，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。</font>** 比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随 Image 。因此在构建 Image 的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。</p><p>分层存储的特征还使得<font color="red"> Image 的复用、定制</font>变的更为容易。甚至可以用之前构建好的 Image 作为基础层，然后进一步添加新的层，以定制自己所需的内容，构建新的 Image 。</p><h3 id="容器containerimage-运行时的实体"><a class="anchor" href="#容器containerimage-运行时的实体">#</a> 容器（Container）：Image 运行时的实体</h3><p>镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的 类 和 实例 一样，<strong><font color="red">Image 是静态的定义，Container 是 Image 运行时的实体</font>。Container 可以被创建、启动、停止、删除、暂停等</strong>。</p><p><strong>Container 的实质是进程，但与直接在宿主执行的进程不同，<font color="red">Container 进程运行于属于自己的独立的命名空间</font>。前面讲过 Image 使用的是分层存储，<font color="red">Container 也是分层存储</font>。</strong></p><p><strong><font color="red">Container 存储层的生存周期和 Container 一样</font>，Container 消亡时，Container 存储层也随之消亡。因此，任何保存于 Container 存储层的信息都会随 Container 删除而丢失。</strong></p><p>按照 Docker 最佳实践的要求，<strong><font color="red">Container 不应该向其存储层内写入任何数据</font></strong> ，容器存储层要保持无状态化。<strong>所有的文件写入操作，都应该使用数据卷（Volume）、或者绑定宿主目录</strong>，在这些位置的读写会跳过容器存储层，直接对宿主 (或网络存储) 发生读写，其性能和稳定性更高。<font color="red">数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡</font>。因此，<strong>使用数据卷后，容器可以随意删除、重新 run ，数据却不会丢失。</strong></p><h3 id="仓库repository集中存放-image-文件的地方"><a class="anchor" href="#仓库repository集中存放-image-文件的地方">#</a> 仓库（Repository）：集中存放 Image 文件的地方</h3><h4 id="概念"><a class="anchor" href="#概念">#</a> 概念</h4><p>Image 构建完成后，可以很容易的在当前宿主上运行，但是，<strong>如果需要在其它服务器上使用这个 Image，我们就需要<font color="red">一个集中的存储、分发 Image 的服务</font>，Docker Registry 就是这样的服务。</strong></p><p><strong><font color="red">一个 Registry 中可以包含多个 Repository，每个 Repository 可以包含多个 Tag，每个 Tag 对应一个 Image</font></strong>。所以说：镜像仓库是 Docker 用来集中存放镜像文件的地方，类似于我们之前常用的代码仓库。</p><p>通常，<strong>一个 Repository 会包含同一个软件不同版本的 Image</strong>，而 <strong>tag 就常用于对应该软件的各个版本</strong> 。我们可以通过 <code>&lt;仓库名&gt;:&lt;标签&gt;</code> 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 latest 作为默认标签。</p><hr><p>这里补充一下 <code>Docker Registry 公开服务</code> 和 <code>私有 Docker Registry</code> 的概念：</p><h4 id="registry-公开服务"><a class="anchor" href="#registry-公开服务">#</a> Registry 公开服务</h4><p>Docker Registry 公开服务是开放给用户使用、允许用户管理 Image 的 Registry 服务。一般这类公开服务<font color="red">允许用户免费上传、下载公开的 Image</font>，并可能提供收费服务供用户管理私有 Image 。<font color="red">最常使用的 Registry 公开服务是官方的 <strong>Docker Hub</strong> ，这也是默认的 Registry</font>，并拥有大量的高质量的官方镜像，网址为：<span class="exturl" data-url="aHR0cHM6Ly9odWIuZG9ja2VyLmNvbS8=">https://hub.docker.com/</span> 。官方是这样介绍 Docker Hub 的：</p><blockquote><p>Docker Hub 是 Docker 官方提供的一项服务，用于与您的团队查找和共享容器镜像。</p></blockquote><p>比如我们想要搜索自己想要的镜像：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20240120142613581.png" alt="利用Docker Hub 搜索镜像"></p><center>利用Docker Hub 搜索镜像</center><p>在 Docker Hub 的搜索结果中，有几项关键的信息有助于我们选择合适的镜像：</p><ul><li><strong>OFFICIAL Image</strong>：代表镜像为 Docker 官方提供和维护，相对来说稳定性和安全性较高。</li><li><strong>Stars</strong>：和点赞差不多的意思，类似 GitHub 的 Star。</li><li><strong>Downloads</strong>：代表镜像被拉取的次数，基本上能够表示镜像被使用的频度。</li></ul><p>当然，除了直接通过 Docker Hub 网站搜索镜像这种方式外，我们<font color="red">还可以通过 <code>docker search</code> 这个命令搜索 Docker Hub 中的镜像</font>，搜索的结果是一致的。</p><figure class="highlight sh"><figcaption data-lang="sh"></figcaption><table><tr><td data-num="1"></td><td><pre>➜  ~ <span class="token function">docker</span> search mysql</pre></td></tr><tr><td data-num="2"></td><td><pre>NAME                              DESCRIPTION                                     STARS               OFFICIAL            AUTOMATED</pre></td></tr><tr><td data-num="3"></td><td><pre>mysql                             MySQL is a widely used, open-source relation…   <span class="token number">8763</span>                <span class="token punctuation">[</span>OK<span class="token punctuation">]</span></pre></td></tr><tr><td data-num="4"></td><td><pre>mariadb                           MariaDB is a community-developed fork of MyS…   <span class="token number">3073</span>                <span class="token punctuation">[</span>OK<span class="token punctuation">]</span></pre></td></tr><tr><td data-num="5"></td><td><pre>mysql/mysql-server                Optimized MySQL Server Docker images. Create…   <span class="token number">650</span>                                     <span class="token punctuation">[</span>OK<span class="token punctuation">]</span></pre></td></tr></table></figure><p>在国内访问 <strong>Docker Hub</strong> 可能会比较慢，<font color="red">国内也有一些云服务商</font>提供类似于 Docker Hub 的公开服务。比如 <span class="exturl" data-url="aHR0cHM6Ly93d3cudGVueGNsb3VkLmNvbS8=">时速云镜像库</span>、<span class="exturl" data-url="aHR0cHM6Ly93d3cuMTYzeXVuLmNvbS9wcm9kdWN0L3JlcG8=">网易云镜像服务</span>、<span class="exturl" data-url="aHR0cHM6Ly93d3cuZGFvY2xvdWQuaW8v">DaoCloud 镜像市场</span>、<span class="exturl" data-url="aHR0cHM6Ly93d3cuYWxpeXVuLmNvbS9wcm9kdWN0L2NvbnRhaW5lcnNlcnZpY2U/dXRtX2NvbnRlbnQ9c2VfMTI5MjgzNg==">阿里云镜像库</span>等。</p><h4 id="私有-registry"><a class="anchor" href="#私有-registry">#</a> 私有 Registry</h4><p>除了使用公开服务外，用户还可以 **<font color="red">在本地搭建私有 Docker Registry</font>** 。Docker 官方提供了 Docker Registry 镜像，可以直接使用做为私有 Registry 服务。开源的 Docker Registry 镜像只提供了 Docker Registry API 的服务端实现，足以支持 docker 命令，不影响使用。但不包含图形界面，以及镜像维护、用户管理、访问控制等高级功能。</p><h2 id="docker-常见命令"><a class="anchor" href="#docker-常见命令">#</a> Docker 常见命令</h2><h3 id="基本命令"><a class="anchor" href="#基本命令">#</a> 基本命令</h3><figure class="highlight sh"><figcaption data-lang="sh"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">docker</span> version <span class="token comment"># 查看 docker 版本</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">docker</span> images <span class="token comment"># 查看所有已下载镜像，等价于：docker image ls 命令</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token function">docker</span> container <span class="token function">ls</span> <span class="token comment"># 查看所有容器</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token function">docker</span> <span class="token function">ps</span> <span class="token comment">#查看正在运行的容器</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token function">docker</span> image prune <span class="token comment"># 清理临时的、没有被使用的镜像文件。-a, --all: 删除所有没有用的镜像，而不仅仅是临时文件；</span></pre></td></tr></table></figure><h3 id="拉取镜像"><a class="anchor" href="#拉取镜像">#</a> 拉取镜像</h3><figure class="highlight sh"><figcaption data-lang="sh"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">docker</span> search mysql <span class="token comment"># 查看 mysql 相关镜像</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">docker</span> pull mysql:5.7 <span class="token comment"># 拉取 mysql 镜像</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token function">docker</span> image <span class="token function">ls</span> <span class="token comment"># 查看所有已下载镜像</span></pre></td></tr></table></figure><h3 id="删除镜像"><a class="anchor" href="#删除镜像">#</a> 删除镜像</h3><p>比如我们要删除我们下载的 mysql 镜像。</p><p>通过 <code>docker rmi [image]</code> （等价于 <code>docker image rm [image]</code> ）删除镜像之前<font color="red">首先要确保这个镜像没有被容器引用</font>（可以通过 tag 名称或者 image ID 删除）。</p><p>举个例子，通过我们前面讲的 <code>docker ps</code> 命令即可查看。</p><figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre>➜  ~ <span class="token function">docker</span> <span class="token function">ps</span></pre></td></tr><tr><td data-num="2"></td><td><pre>CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                               NAMES</pre></td></tr><tr><td data-num="3"></td><td><pre>c4cd691d9f80        mysql:5.7           <span class="token string">"docker-entrypoint.s…"</span>   <span class="token number">7</span> weeks ago         Up <span class="token number">12</span> days          <span class="token number">0.0</span>.0.0:3306-<span class="token operator">></span><span class="token number">3306</span>/tcp, <span class="token number">33060</span>/tcp   mysql</pre></td></tr></table></figure><p>可以看到 mysql 正在被 id 为 c4cd691d9f80 的容器引用，我们需要首先通过 <code>docker stop c4cd691d9f80</code> 或者 <code>docker stop mysql</code> 暂停这个容器。</p><p>然后查看 mysql 镜像的 id</p><figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre>➜  ~ <span class="token function">docker</span> images</pre></td></tr><tr><td data-num="2"></td><td><pre>REPOSITORY              TAG                 IMAGE ID            CREATED             SIZE</pre></td></tr><tr><td data-num="3"></td><td><pre>mysql                   <span class="token number">5.7</span>                 f6509bac4980        <span class="token number">3</span> months ago        373MB</pre></td></tr></table></figure><p><font color="red">通过 IMAGE ID 或者 REPOSITORY 名字即可删除</font></p><figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">docker</span> rmi f6509bac4980 <span class="token comment">#  或者 docker rmi mysql</span></pre></td></tr></table></figure><h2 id="docker-两句口号"><a class="anchor" href="#docker-两句口号">#</a> Docker 两句口号</h2><ul><li><strong><font color="red">“Build, Ship and Run（搭建、发送、运行）”</font></strong></li><li><strong><font color="red">“Build once，Run anywhere（搭建一次，到处能用）”</font></strong></li></ul><p>如果你搜索 Docker 官网，会发现如下的字样：<strong>“Docker - Build, Ship, and Run Any App, Anywhere”</strong>。那么 Build, Ship, and Run 到底是在干什么呢？</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/docker-build-ship-run.jpg" alt="img"></p><ul><li><strong><font color="red">Build（构建镜像）</font></strong>：镜像就像是集装箱，包括文件以及运行环境等等资源。</li><li><strong><font color="red">Ship（运输镜像）</font></strong>：主机和仓库间运输，这里的仓库就像是超级码头一样。</li><li><strong><font color="red">Run（运行镜像）</font></strong>：运行的镜像就是一个容器，容器就是运行程序的地方。</li></ul><p><strong><font color="red">Docker 运行过程也就是去仓库把镜像拉到本地，然后用一条命令把镜像运行起来变成容器</font>。所以，我们也常常将 Docker 称为码头工人或码头装卸工，这和 Docker 的中文翻译搬运工人如出一辙。</strong></p><h2 id="docker-底层原理"><a class="anchor" href="#docker-底层原理">#</a> Docker 底层原理</h2><h3 id="虚拟化技术"><a class="anchor" href="#虚拟化技术">#</a> 虚拟化技术</h3><p>首先，Docker <strong>容器虚拟化技术</strong>为基础的软件，那么什么是虚拟化技术呢？</p><p>简单点来说，虚拟化技术可以这样定义：</p><blockquote><p>虚拟化技术是一种资源管理技术，是将计算机的各种<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU4JUE4JTg4JUU3JUFFJTk3JUU2JUE5JTlGJUU3JUE3JTkxJUU1JUFEJUI4">实体资源</span>（<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvQ1BV">CPU</span>、<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JTg2JTg1JUU1JUFEJTk4">内存</span>、<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU3JUEzJTgxJUU3JTlCJTk4JUU3JUE5JUJBJUU5JTk3JUI0">磁盘空间</span>、<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU3JUI2JUIyJUU4JUI3JUFGJUU5JTgxJUE5JUU5JTg1JThEJUU1JTk5JUE4">网络适配器</span>等），予以抽象、转换后呈现出来并可供分割、组合为一个或多个电脑配置环境。由此，打破实体结构间的不可切割的障碍，使用户可以比原本的配置更好的方式来应用这些电脑硬件资源。这些资源的新虚拟部分是不受现有资源的架设方式，地域或物理配置所限制。一般所指的虚拟化资源包括计算能力和数据存储。</p></blockquote><h3 id="docker-基于-lxc-虚拟容器技术"><a class="anchor" href="#docker-基于-lxc-虚拟容器技术">#</a> Docker 基于 LXC 虚拟容器技术</h3><p>Docker 技术是基于 <strong>LXC（Linux container- Linux 容器）虚拟容器技术</strong>的。</p><blockquote><p>LXC，其名称来自 Linux 软件容器（Linux Containers）的缩写，一种操作系统层虚拟化（Operating system–level virtualization）技术，为 Linux 内核容器功能的一个用户空间接口。它将应用软件系统打包成一个软件容器（Container），内含应用软件本身的代码，以及所需要的操作系统核心和库。通过统一的名字空间和共用 API 来分配不同软件容器的可用硬件资源，创造出应用程序的独立沙箱运行环境，使得 Linux 用户可以容易的创建和管理系统或应用容器。</p></blockquote><p><strong>LXC 技术主要是借助 Linux 内核中提供的 CGroup 功能和 namespace 来实现的，通过 LXC 可以为软件提供一个独立的操作系统运行环境</strong>。</p><p>cgroup 和 namespace 介绍：</p><ul><li><p><strong><font color="red">namespace 是 Linux 内核用来隔离内核资源的方式。</font></strong> 通过 namespace 可以让一些进程只能看到与自己相关的一部分资源，而另外一些进程也只能看到与它们自己相关的资源，这两拨进程根本就感觉不到对方的存在。具体的实现方式是把一个或多个进程的相关资源指定在同一个 namespace 中。Linux namespaces 是对全局系统资源的一种封装隔离，使得处于不同 namespace 的进程拥有独立的全局系统资源，改变一个 namespace 中的系统资源只会影响当前 namespace 里的进程，对其他 namespace 中的进程没有影响。</p></li><li><p><strong><font color="red">CGroup 是 Control Groups 的缩写，是 Linux 内核提供的一种可以限制、记录、隔离进程组 (process groups) 所使用的物力资源 (如 cpu memory i/o 等等) 的机制</font>。</strong></p></li></ul><p>cgroup 和 namespace 两者对比：</p><p><font color="red">两者都是将进程进行分组</font>，但是两者的作用还是有本质区别。<font color="red">namespace 是为了隔离进程组之间的资源，而 cgroup 是为了对一组进程进行统一的资源监控和限制</font>。</p><h2 id="总结"><a class="anchor" href="#总结">#</a> 总结</h2><p>本文主要把 Docker 中的一些常见概念做了详细的阐述，但是并不涉及 Docker 的安装、镜像的使用、容器的操作等内容。这部分东西，希望读者自己可以通过阅读书籍与官方文档的形式掌握。如果觉得官方文档阅读起来很费力的话，这里推荐以下内容：</p><ul><li><strong>《Docker 技术入门与实战第二版》[<span class="exturl" data-url="aHR0cHM6Ly95ZWFzeS5naXRib29rLmlvL2RvY2tlcl9wcmFjdGljZS8=">前言 - Docker — 从入门到实践 (gitbook.io)</span>]</strong></li><li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC81MzI2MDA5OA==">10 分钟看懂 Docker 和 K8S</span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuaW5mb3EuY24vYXJ0aWNsZS90ZTcwRmxTeXhobHRMMUNyN2d6TQ==">从零开始入门 K8s：详解 K8s 容器基本概念</span></li></ul><h1 id="docker-实战"><a class="anchor" href="#docker-实战">#</a> Docker 实战</h1><h2 id="安装"><a class="anchor" href="#安装">#</a> 安装</h2><h2 id="几个概念"><a class="anchor" href="#几个概念">#</a> 几个概念</h2><h2 id="初体验"><a class="anchor" href="#初体验">#</a> 初体验</h2><h2 id="镜像指令"><a class="anchor" href="#镜像指令">#</a> 镜像指令</h2><h2 id="容器指令"><a class="anchor" href="#容器指令">#</a> 容器指令</h2><h2 id="数据卷"><a class="anchor" href="#数据卷">#</a> 数据卷</h2></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2024-01-20 16:19:35" itemprop="dateModified" datetime="2024-01-20T16:19:35+08:00">2024-01-20</time> </span><span id="docker/docker-javaguide/" class="item leancloud_visitors" data-flag-title="docker-javaguide" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>范特东东东 <i class="ic i-at"><em>@</em></i>水文 & 摄影</li><li class="link"><strong>本文链接：</strong> <a href="http://example.com/docker/docker-javaguide/" title="docker-javaguide">http://example.com/docker/docker-javaguide/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/project/12306/12306%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;hjx159&#x2F;picture-bed&#x2F;main&#x2F;img&#x2F;12306-base-biz-20230801.png" title="12306项目学习笔记"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i></span><h3>12306项目学习笔记</h3></a></div><div class="item right"></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#docker-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="toc-number">1.</span> <span class="toc-text">Docker 核心概念</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8"><span class="toc-number">1.1.</span> <span class="toc-text">容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.1.1.</span> <span class="toc-text">容器是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E8%A7%A3%E7%89%A9%E7%90%86%E6%9C%BA-%E8%99%9A%E6%8B%9F%E6%9C%BA-%E5%AE%B9%E5%99%A8"><span class="toc-number">1.1.2.</span> <span class="toc-text">图解：物理机、虚拟机、容器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#docker-%E6%80%9D%E6%83%B3"><span class="toc-number">1.2.</span> <span class="toc-text">Docker 思想</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#docker-%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.2.1.</span> <span class="toc-text">Docker 是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#docker-%E6%80%9D%E6%83%B3-2"><span class="toc-number">1.2.2.</span> <span class="toc-text">Docker 思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#docker-%E5%AE%B9%E5%99%A8%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">1.2.3.</span> <span class="toc-text">Docker 容器的特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8-docker"><span class="toc-number">1.2.4.</span> <span class="toc-text">为什么使用 Docker</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8-vs-%E8%99%9A%E6%8B%9F%E6%9C%BA"><span class="toc-number">1.3.</span> <span class="toc-text">容器 vs 虚拟机</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E6%AF%94%E5%9B%BE"><span class="toc-number">1.3.1.</span> <span class="toc-text">对比图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E8%80%85%E6%80%BB%E7%BB%93"><span class="toc-number">1.3.2.</span> <span class="toc-text">二者总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E8%80%85%E5%8F%AF%E5%85%B1%E5%AD%98"><span class="toc-number">1.3.3.</span> <span class="toc-text">二者可共存</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#docker-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.4.</span> <span class="toc-text">Docker 基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%95%9C%E5%83%8Fimage%E4%B8%80%E4%B8%AA%E7%89%B9%E6%AE%8A%E7%9A%84%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.4.1.</span> <span class="toc-text">镜像（Image）：一个特殊的文件系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8containerimage-%E8%BF%90%E8%A1%8C%E6%97%B6%E7%9A%84%E5%AE%9E%E4%BD%93"><span class="toc-number">1.4.2.</span> <span class="toc-text">容器（Container）：Image 运行时的实体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%93%E5%BA%93repository%E9%9B%86%E4%B8%AD%E5%AD%98%E6%94%BE-image-%E6%96%87%E4%BB%B6%E7%9A%84%E5%9C%B0%E6%96%B9"><span class="toc-number">1.4.3.</span> <span class="toc-text">仓库（Repository）：集中存放 Image 文件的地方</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-number">1.4.3.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#registry-%E5%85%AC%E5%BC%80%E6%9C%8D%E5%8A%A1"><span class="toc-number">1.4.3.2.</span> <span class="toc-text">Registry 公开服务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A7%81%E6%9C%89-registry"><span class="toc-number">1.4.3.3.</span> <span class="toc-text">私有 Registry</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#docker-%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4"><span class="toc-number">1.5.</span> <span class="toc-text">Docker 常见命令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4"><span class="toc-number">1.5.1.</span> <span class="toc-text">基本命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%89%E5%8F%96%E9%95%9C%E5%83%8F"><span class="toc-number">1.5.2.</span> <span class="toc-text">拉取镜像</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E9%95%9C%E5%83%8F"><span class="toc-number">1.5.3.</span> <span class="toc-text">删除镜像</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#docker-%E4%B8%A4%E5%8F%A5%E5%8F%A3%E5%8F%B7"><span class="toc-number">1.6.</span> <span class="toc-text">Docker 两句口号</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#docker-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="toc-number">1.7.</span> <span class="toc-text">Docker 底层原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF"><span class="toc-number">1.7.1.</span> <span class="toc-text">虚拟化技术</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#docker-%E5%9F%BA%E4%BA%8E-lxc-%E8%99%9A%E6%8B%9F%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF"><span class="toc-number">1.7.2.</span> <span class="toc-text">Docker 基于 LXC 虚拟容器技术</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.8.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#docker-%E5%AE%9E%E6%88%98"><span class="toc-number">2.</span> <span class="toc-text">Docker 实战</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E8%A3%85"><span class="toc-number">2.1.</span> <span class="toc-text">安装</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%A0%E4%B8%AA%E6%A6%82%E5%BF%B5"><span class="toc-number">2.2.</span> <span class="toc-text">几个概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9D%E4%BD%93%E9%AA%8C"><span class="toc-number">2.3.</span> <span class="toc-text">初体验</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%95%9C%E5%83%8F%E6%8C%87%E4%BB%A4"><span class="toc-number">2.4.</span> <span class="toc-text">镜像指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E6%8C%87%E4%BB%A4"><span class="toc-number">2.5.</span> <span class="toc-text">容器指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%8D%B7"><span class="toc-number">2.6.</span> <span class="toc-text">数据卷</span></a></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li class="active"><a href="/docker/docker-javaguide/" rel="bookmark" title="docker-javaguide">docker-javaguide</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="范特东东东" data-src="/images/avatar.jpg"><p class="name" itemprop="name">范特东东东</p><div class="description" itemprop="description"></div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">59</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">18</span> <span class="name">分类</span></a></div></nav><div class="social"><span class="exturl item xiaohongshu" data-url="aHR0cHM6Ly93d3cueGlhb2hvbmdzaHUuY29tL3VzZXIvcHJvZmlsZS81ZTAyYzhhZDAwMDAwMDAwMDEwMDFmM2U=" title="https:&#x2F;&#x2F;www.xiaohongshu.com&#x2F;user&#x2F;profile&#x2F;5e02c8ad0000000001001f3e"><i class="ic i-xiaohongshu"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于我</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><span class="exturl" data-url="aHR0cHM6Ly9oangxNTkuZ2l0aHViLmlvL2NhdGVnb3JpZXMvcGhvdG9ncmFwaHkv"><i class="ic i-photography"></i>摄影</span></li></ul></div></div></div><ul id="quick"><li class="prev pjax"></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/photography/" title="分类于 摄影">摄影</a></div><span><a href="/photography/%E6%9C%9D%E9%98%B3%E5%85%AC%E5%9B%AD/" title="朝阳公园">朝阳公园</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/java/" title="分类于 Java">Java</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/" title="分类于 Java基础">Java基础</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/java-excise/" title="分类于 Java基础-真题">Java基础-真题</a></div><span><a href="/java/java-se/java-excise/%E7%AC%AC04%E7%AB%A0%EF%BC%9A%E9%9A%8F%E5%A0%82%E5%A4%8D%E4%B9%A0%E4%B8%8E%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%A2%98%EF%BC%88IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%89/" title="宋红康_第04章：IDEA安装与使用">宋红康_第04章：IDEA安装与使用</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/java/" title="分类于 Java">Java</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/" title="分类于 Java基础">Java基础</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/java-knowledge/" title="分类于 Java基础-知识点">Java基础-知识点</a></div><span><a href="/java/java-se/java-knowledge/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E5%AE%8B%E7%BA%A2%E5%BA%B7_%E7%AC%AC10%E7%AB%A0_%E5%A4%9A%E7%BA%BF%E7%A8%8B/" title="宋红康_第10章_多线程">宋红康_第10章_多线程</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/java/" title="分类于 Java">Java</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/" title="分类于 Java基础">Java基础</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/java-knowledge/" title="分类于 Java基础-知识点">Java基础-知识点</a></div><span><a href="/java/java-se/java-knowledge/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E5%AE%8B%E7%BA%A2%E5%BA%B7_%E7%AC%AC05%E7%AB%A0_%E6%95%B0%E7%BB%84/" title="宋红康_第05章_数组">宋红康_第05章_数组</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/distributed-microservices/" title="分类于 分布式微服务">分布式微服务</a></div><span><a href="/distributed-microservices/%E5%88%86%E5%B8%83%E5%BC%8F%E7%90%86%E8%AE%BA&%E7%AE%97%E6%B3%95&%E5%8D%8F%E8%AE%AE/" title="分布式理论&amp;算法&amp;协议">分布式理论&算法&协议</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/java/" title="分类于 Java">Java</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/" title="分类于 Java基础">Java基础</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/java-excise/" title="分类于 Java基础-真题">Java基础-真题</a></div><span><a href="/java/java-se/java-excise/%E7%AC%AC15%E7%AB%A0%EF%BC%9A%E9%9A%8F%E5%A0%82%E5%A4%8D%E4%B9%A0%E4%B8%8E%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%A2%98%EF%BC%88File%E7%B1%BB%E4%B8%8EIO%E6%B5%81%EF%BC%89/" title="宋红康_第15章：File类与IO流">宋红康_第15章：File类与IO流</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/leetcode/" title="分类于 LeetCode">LeetCode</a> <i class="ic i-angle-right"></i> <a href="/categories/leetcode/carl/" title="分类于 代码随想录">代码随想录</a></div><span><a href="/leetcode/carl/%E7%AC%94%E8%AE%B0%E9%9A%8F%E6%83%B3%E5%BD%95/" title="代码随想录-笔记">代码随想录-笔记</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/java/" title="分类于 Java">Java</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/" title="分类于 Java基础">Java基础</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/java-knowledge/" title="分类于 Java基础-知识点">Java基础-知识点</a></div><span><a href="/java/java-se/java-knowledge/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E5%AE%8B%E7%BA%A2%E5%BA%B7_%E7%AC%AC14%E7%AB%A0_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/" title="宋红康_第14章_数据结构与集合源码">宋红康_第14章_数据结构与集合源码</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/java/" title="分类于 Java">Java</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/" title="分类于 Java基础">Java基础</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/java-excise/" title="分类于 Java基础-真题">Java基础-真题</a></div><span><a href="/java/java-se/java-excise/%E7%AC%AC08%E7%AB%A0%EF%BC%9A%E9%9A%8F%E5%A0%82%E5%A4%8D%E4%B9%A0%E4%B8%8E%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%A2%98%EF%BC%88%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E9%AB%98%E7%BA%A7%EF%BC%89/" title="宋红康_第08章：面向对象-高级">宋红康_第08章：面向对象-高级</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/java/" title="分类于 Java">Java</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/" title="分类于 Java基础">Java基础</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/java-knowledge/" title="分类于 Java基础-知识点">Java基础-知识点</a></div><span><a href="/java/java-se/java-knowledge/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E5%AE%8B%E7%BA%A2%E5%BA%B7_%E7%AC%AC12%E7%AB%A0_%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/" title="宋红康_第12章_集合框架">宋红康_第12章_集合框架</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">范特东东东 @ fantedong</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">1.8m 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">27:37</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"docker/docker-javaguide/",favicon:{show:"(●´3｀●)欢迎回来",hide:"(〃＞皿＜)你快回来"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hrmmi -->