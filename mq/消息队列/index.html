<!-- build time:Sun Mar 17 2024 17:47:12 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="水文 & 摄影" href="http://example.com/rss.xml"><link rel="alternate" type="application/atom+xml" title="水文 & 摄影" href="http://example.com/atom.xml"><link rel="alternate" type="application/json" title="水文 & 摄影" href="http://example.com/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><link rel="canonical" href="http://example.com/mq/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"><title>消息队列 - 消息队列 | fantedong = 水文 & 摄影 = 为了能更好地查看图片，你需要一点魔法</title><meta name="generator" content="Hexo 6.3.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">消息队列</h1><div class="meta"><span class="item" title="创建时间：2024-01-26 02:59:25"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2024-01-26T02:59:25+08:00">2024-01-26</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>39k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>36 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">fantedong</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><img src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/p68921.png"></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/mq/" itemprop="item" rel="index" title="分类于 消息队列"><span itemprop="name">消息队列</span></a><meta itemprop="position" content="1"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://example.com/mq/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="范特东东东"><meta itemprop="description" content="为了能更好地查看图片，你需要一点魔法, "></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="水文 & 摄影"></span><div class="body md" itemprop="articleBody"><h1 id="消息队列"><a class="anchor" href="#消息队列">#</a> 消息队列</h1><blockquote><p>特指分布式消息队列</p></blockquote><h2 id="消息队列基础知识"><a class="anchor" href="#消息队列基础知识">#</a> 消息队列基础知识</h2><h3 id="消息队列的定义"><a class="anchor" href="#消息队列的定义">#</a> 消息队列的定义</h3><p>可以把消息队列看作是<font color="red">一个存放消息的容器</font>，当我们需要使用消息的时候，直接从容器中取出消息供自己使用即可。由于<font color="red">队列 Queue</font> 是一种先进先出的数据结构，所以消费消息时也<font color="red">按照顺序来消费</font>。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/message-queue-small.png" alt="img"></p><p>消息队列是一种 <strong>Pub/Sub 模型（发布 / 订阅模型）</strong>，参与消息传递的双方称为<strong>生产者</strong>和<strong>消费者</strong>，生产者负责发送消息，消费者负责处理消息。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/message-queue-pub-sub-model-63a717b4.png" alt="发布/订阅（Pub/Sub）模型"></p><center>发布/订阅（Pub/Sub）模型</center><p>我们知道操作系统中的进程通信的一种很重要的方式就是消息队列。我们这里提到的消息队列稍微有点区别，<font color="red">更多指的是各个服务以及系统内部各个组件 / 模块之前的通信</font>，属于一种<strong>中间件</strong>。</p><p>简单来说：<strong>中间件是一类服务于应用软件的软件，应用软件是为用户服务的，用户不会接触或者使用到中间件。</strong></p><p>随着分布式和微服务系统的发展，消息队列在系统设计中有了更大的发挥空间，使用消息队列<font color="red">可以降低系统耦合性、实现任务异步、有效地进行流量削峰</font>，是分布式和微服务系统中重要的组件之一。</p><h3 id="消息队列的作用"><a class="anchor" href="#消息队列的作用">#</a> 消息队列的作用</h3><p>通常来说，使用消息队列能为我们的系统带来下面三点好处：</p><ol><li><strong>通过异步处理提高系统性能（减少响应所需时间）</strong></li><li><strong>削峰 / 限流</strong></li><li><strong>降低系统耦合性</strong></li><li><strong>实现分布式事务</strong></li></ol><p>如果在面试的时候你被面试官问到这个问题的话，一般情况是你在你的简历上涉及到消息队列这方面的内容，这个时候推荐<font color="red">结合自己的项目来回答</font>。</p><h4 id="作用1通过异步处理提高系统性能减少响应所需时间"><a class="anchor" href="#作用1通过异步处理提高系统性能减少响应所需时间">#</a> 作用 1：通过异步处理提高系统性能（减少响应所需时间）</h4><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/Asynchronous-message-queue.png" alt="通过异步处理提高系统性能"></p><center>通过异步处理提高系统性能</center><p><font color="red">服务端将用户的请求数据存储到消息队列后，立即返回结果</font>。随后，系统再对消息进行消费。</p><p>因为用户请求数据写入消息队列之后就立即返回给用户了，但是请求数据在后续的业务校验、写数据库等操作中可能失败。因此，<strong>使用消息队列进行异步处理之后，需要适当修改业务流程进行配合</strong>，比如用户在提交订单之后，订单数据写入消息队列，不能立即返回用户订单提交成功，需要在消息队列的订单消费者进程真正处理完该订单之后，甚至出库后，再通过电子邮件或短信通知用户订单成功，以免交易纠纷。这就类似我们平时手机订火车票和电影票。</p><h4 id="作用2削峰限流"><a class="anchor" href="#作用2削峰限流">#</a> 作用 2：削峰 / 限流</h4><p><strong>先将短时间高并发产生的事务消息存储在消息队列中，然后后端服务再慢慢根据自己的能力去消费这些消息，这样就避免大量事务直接把后端服务冲垮。</strong></p><p>举例：在电子商务一些秒杀、促销活动中，合理使用消息队列可以有效抵御促销活动刚开始大量订单涌入对系统的冲击。如下图所示：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231025224518547.png" alt="削峰"></p><center>削峰</center><h4 id="作用3降低系统的耦合性"><a class="anchor" href="#作用3降低系统的耦合性">#</a> 作用 3：降低系统的耦合性</h4><p>使用消息队列还可以降低系统耦合性。我们知道如果模块之间不存在直接调用，那么新增模块或者修改模块就对其他模块影响较小，这样系统的可扩展性无疑更好一些。还是直接上图吧：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231025224821246.png" alt="image-20231025224821246"></p><p>生产者（客户端）发送消息到消息队列中去，接受者（服务端）处理消息，需要消费的系统直接去消息队列获取消息进行消费即可，而不需要和其他系统有耦合，这显然也提高了系统的扩展性。</p><p>** 消息队列使用 Pub/Sub 模式（发布 / 订阅模式）工作，生产者发布消息，一个或多个消费者订阅消息。** 从上图可以看到<font color="red">生产者和消费者之间没有直接耦合</font>，</p><ul><li>生产者将消息发送至分布式消息队列即结束对消息的处理</li><li>消费者从分布式消息队列获取该消息后进行后续处理，并不需要知道该消息从何而来。</li></ul><p><font color="red">对新增业务，只要对该类消息感兴趣，即可订阅该消息，对原有系统和业务没有任何影响，从而实现网站业务的可扩展性设计</font>。</p><p>消费者对消息进行过滤、处理、包装后，构造成一个新的消息类型，将消息继续发送出去，等待其他消费者订阅该消息。因此基于事件（消息对象）驱动的业务架构可以是一系列流程。</p><p>另外，<font color="red">为了避免 “消息队列服务器” 宕机造成消息丢失，会将成功发送到消息队列的消息存储在 “生产者服务器” 上，等消息真正被 “消费者服务器” 处理后才删除消息</font>。在消息队列服务器宕机后，生产者服务器会选择分布式消息队列服务器集群中的其他服务器发布消息。</p><p>备注：不要认为消息队列只能利用发布 - 订阅模式工作，只不过在解耦这个特定业务环境下是使用发布 - 订阅模式的。除了发布 - 订阅模式，还有<strong>点对点订阅模式</strong>（一个消息只有一个消费者），我们比较常用的是发布 - 订阅模式。</p><h4 id="作用4实现分布式事务"><a class="anchor" href="#作用4实现分布式事务">#</a> 作用 4：实现分布式事务</h4><p>分布式事务的解决方案之一就是 MQ 事务。</p><p>RocketMQ、Kafka、Pulsar、QMQ 都提供了事务相关的功能。<font color="red">事务允许事件流应用将生产、处理、消费消息的整个过程定义为一个原子操作</font>。</p><p>详细介绍可以查看 <span class="exturl" data-url="aHR0cHM6Ly9qYXZhZ3VpZGUuY24vZGlzdHJpYnV0ZWQtc3lzdGVtL2Rpc3RyaWJ1dGVkLXRyYW5zYWN0aW9uLmh0bWw=">分布式事务详解 (付费)</span> 这篇文章。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/07b338324a7d8894b8aef4b659b76d92.png" alt="分布式事务详解 - MQ事务"></p><center>分布式事务详解 - MQ事务</center><h3 id="消息队列存在的问题"><a class="anchor" href="#消息队列存在的问题">#</a> 消息队列存在的问题</h3><p><strong>系统可用性降低</strong>：在加入 MQ 之前，你不用考虑<font color="red">消息丢失、 MQ 挂掉</font>等等的情况，但是引入 MQ 之后你就需要去考虑了！</p><p><strong>系统复杂性提高</strong>：加入 MQ 之后，你需要<font color="red">保证消息没有被重复消费、处理消息丢失的情况、保证消息传递的顺序性</font>等等问题！</p><p><strong>一致性问题</strong>：消息队列可以实现异步，确实可以提高系统响应速度。但是，万一消息的真正消费者并没有正确消费消息怎么办？这样就会导致<font color="red">数据不一致</font>的情况了！</p><h3 id="jms-和-amqp"><a class="anchor" href="#jms-和-amqp">#</a> JMS 和 AMQP</h3><h4 id="jms-定义"><a class="anchor" href="#jms-定义">#</a> JMS 定义</h4><p><strong>JMS（JAVA Message Service）是 Java 的消息服务，其 API 是一个消息服务的标准 / 规范</strong>。JMS 的客户端之间可以通过 JMS 服务进行异步的消息传输。它允许应用程序组件基于 JavaEE 平台创建、发送、接收和读取消息。它使分布式通信耦合度更低，消息服务更加可靠以及异步性。</p><p>JMS 定义了<font color="gree">五种不同消息</font>的正文格式以及调用的消息类型，允许你发送并接收一些不同形式的数据：</p><ul><li><code>StreamMessage</code> ：Java 原始值的数据流</li><li><code>MapMessage</code> ：一套名称 - 值对</li><li><code>TextMessage</code> ：一个字符串对象</li><li><code>ObjectMessage</code> ：一个序列化的 Java 对象</li><li><code>BytesMessage</code> ：一个字节的数据流</li></ul><h4 id="jms-两种消息模型"><a class="anchor" href="#jms-两种消息模型">#</a> JMS 两种消息模型</h4><h5 id="点到点模型p2p"><a class="anchor" href="#点到点模型p2p">#</a> 点到点模型（P2P）</h5><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/message-queue-queue-model-3aa809bf.png" alt="队列模型"></p><p>使用<strong>队列（Queue）<strong>作为消息通信载体，满足</strong>生产者与消费者模式</strong>，<strong><font color="red">一条消息只能被一个消费者使用</font></strong>，未被消费的消息在队列中保留直到被消费或超时。比如：生产者发送 100 条消息的话，两个消费者来消费，一般情况下两个消费者会按照消息发送的顺序各自消费一半（也就是你一个我一个的消费）。</p><h5 id="发布订阅模型pubsub"><a class="anchor" href="#发布订阅模型pubsub">#</a> 发布 / 订阅模型（Pub/Sub）</h5><p><img data-src="https://javaguide.cn/assets/message-queue-pub-sub-model-63a717b4.png" alt="发布/订阅（Pub/Sub）模型"></p><center>发布/订阅（Pub/Sub）模型</center><p>使用<strong>主题（Topic）<strong>作为消息通信载体，类似于</strong>广播模式</strong>；发布者发布一条消息，<strong><font color="red">该消息通过主题传递给所有的订阅者</font></strong>。</p><h4 id="amqp-定义"><a class="anchor" href="#amqp-定义">#</a> AMQP 定义</h4><p>AMQP，即 <code>Advanced Message Queuing Protocol</code> ，一个提供统一消息服务的应用层标准<strong>高级消息队列协议</strong>（二进制应用层协议），是<font color="red">应用层协议</font>的一个开放标准，为面向消息的中间件设计，兼容 JMS。<font color="red">基于此协议的客户端与消息中间件可传递消息</font>，并不受客户端 / 中间件产品，不同的开发语言等条件的限制。</p><p><strong>RabbitMQ 就是基于 AMQP 协议实现的。</strong></p><h4 id="jms-vs-amqp"><a class="anchor" href="#jms-vs-amqp">#</a> JMS vs AMQP</h4><table><thead><tr><th style="text-align:center"></th><th style="text-align:left">JMS</th><th style="text-align:left">AMQP</th></tr></thead><tbody><tr><td style="text-align:center">定义</td><td style="text-align:left"><strong>Java API</strong></td><td style="text-align:left">协议</td></tr><tr><td style="text-align:center">跨语言</td><td style="text-align:left">否</td><td style="text-align:left"><strong>是</strong></td></tr><tr><td style="text-align:center">跨平台</td><td style="text-align:left">否</td><td style="text-align:left"><strong>是</strong></td></tr><tr><td style="text-align:center">支持消息类型</td><td style="text-align:left">提供两种消息模型：①P2P;②Pub/sub</td><td style="text-align:left">提供了五种消息模型：①direct exchange；②fanout exchange；③topic change；④headers exchange；⑤system exchange。本质来讲，后四种和 JMS 的 pub/sub 模型没有太大差别，仅是在路由机制上做了更详细的划分；</td></tr><tr><td style="text-align:center">支持消息类型</td><td style="text-align:left"><strong>多种消息类型</strong></td><td style="text-align:left"><strong>byte []（二进制）</strong></td></tr></tbody></table><p><strong>总结：</strong></p><ul><li>AMQP 为消息定义了线路层的协议，而 JMS 所定义的是 API 规范。在 Java 体系中，多个 client 均可以通过 JMS 进行交互，不需要应用修改代码，但是其对跨平台的支持较差。而 <strong>AMQP 天然具有跨平台、跨语言特性</strong>。</li><li><strong>JMS 支持 <code>TextMessage</code> 、 <code>MapMessage</code> 等复杂的消息类型</strong>；而 <strong>AMQP 仅支持 <code>byte[]</code> 消息类型</strong>（复杂的类型可序列化后发送）。</li><li>由于 Exchange 提供的路由算法，<strong>AMQP 可以提供多样化的路由方式</strong>来传递消息到消息队列，<strong>而 JMS 仅支持 P2P 和 Pub/Sub 方式两种</strong>。</li></ul><h3 id="rpc-和消息队列的区别"><a class="anchor" href="#rpc-和消息队列的区别">#</a> RPC 和消息队列的区别</h3><p>RPC 和消息队列都是分布式微服务系统中重要的组件之一，下面我们来简单对比一下两者：</p><ul><li><strong>用途</strong>：<ul><li>RPC：主要用来解决两个服务的远程通信问题，不需要了解底层网络的通信机制。通过 RPC 可以帮助我们<font color="red">远程调用某个服务的方法</font>，这个过程就像调用本地方法一样简单。</li><li>消息队列：主要用来<font color="red">降低系统耦合性、实现任务异步、流量削峰</font>。</li></ul></li><li><strong>通信方式</strong>：<ul><li>RPC：<font color="red">双向直接网络通讯</font></li><li>消息队列：<font color="red">单向引入中间载体</font>的网络通讯</li></ul></li><li><strong>架构</strong>：<ul><li>RPC：<font color="red">不需要存储消息</font>，因为是双向直接网络通讯</li><li>消息队列：需要把消息存储起来</li></ul></li><li><strong>请求处理的时效性</strong>：<ul><li>通过 RPC 发出的调用一般会<font color="red">立即被处理</font></li><li>存放在消息队列中的消息<font color="red">并不一定会立即被处理</font></li></ul></li></ul><p><font color="red">RPC 和消息队列本质上是网络通讯的两种不同的实现机制，两者的用途不同</font>，万不可将两者混为一谈。</p><h3 id="消息队列选型"><a class="anchor" href="#消息队列选型">#</a> <mark>消息队列选型</mark></h3><h4 id="常见的消息队列"><a class="anchor" href="#常见的消息队列">#</a> 常见的消息队列</h4><h5 id="kafka"><a class="anchor" href="#kafka">#</a> Kafka</h5><blockquote><p>Kafka 官网：<span class="exturl" data-url="aHR0cDovL2thZmthLmFwYWNoZS5vcmcv">http://kafka.apache.org/</span></p><p>Kafka 更新记录（可以直观看到项目是否还在维护）：<span class="exturl" data-url="aHR0cHM6Ly9rYWZrYS5hcGFjaGUub3JnL2Rvd25sb2Fkcw==">https://kafka.apache.org/downloads</span></p></blockquote><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/kafka-logo.png" alt="img"></p><p>Kafka 是 LinkedIn 开源的一个<font color="red">分布式流式处理平台</font>，已经成为 Apache 顶级项目，早期被用来用于<font color="red">处理海量的日志</font>，后面才慢慢发展成了一款功能全面的<font color="red">高性能消息队列</font>。</p><p>流式处理平台具有三个关键功能：</p><ol><li><strong>消息队列</strong>：<font color="red">发布和订阅消息流</font>。</li><li><strong>持久方式存储消息流</strong>：Kafka 会<font color="red">把消息持久化到磁盘</font>，有效地避免了消息丢失的风险。</li><li><strong>流式处理平台</strong>：在消息发布的时候进行处理，Kafka 提供了一个完整的流式处理类库。</li></ol><p>Kafka 是一个分布式系统，由通过高性能<font color="red"> TCP 网络协议</font>进行通信的服务器和客户端组成，可以部署在在本地和云环境中的裸机硬件、虚拟机和容器上。</p><p>在 Kafka 2.8 之前，Kafka 最被大家诟病的就是其重度依赖于 Zookeeper 做元数据管理和集群的高可用。<font color="red">在 Kafka 2.8 之后，引入了基于 Raft 协议的 KRaft 模式，不再依赖 Zookeeper，大大简化了 Kafka 的架构</font>。</p><p>提示一下：<font color="red">如果要使用 KRaft 模式的话，建议选择较高版本的 Kafka</font>，因为这个功能还在持续完善优化中。Kafka 3.3.1 版本是第一个将 KRaft（Kafka Raft）共识协议标记为生产就绪的版本。</p><h5 id="rocketmq"><a class="anchor" href="#rocketmq">#</a> RocketMQ</h5><blockquote><p>RocketMQ 官网：<span class="exturl" data-url="aHR0cHM6Ly9yb2NrZXRtcS5hcGFjaGUub3JnLw==">https://rocketmq.apache.org/</span> （文档很详细，推荐阅读）</p><p>RocketMQ 更新记录（可以直观看到项目是否还在维护）：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FwYWNoZS9yb2NrZXRtcS9yZWxlYXNlcw==">https://github.com/apache/rocketmq/releases</span></p></blockquote><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/rocketmq-logo.png" alt="img"></p><p>RocketMQ 是阿里开源的一款<font color="red">云原生 “消息、事件、流” 实时数据处理平台</font>，借鉴了 Kafka，已经成为 Apache 顶级项目。</p><p>RocketMQ 的核心特性（摘自 RocketMQ 官网）：</p><ul><li><strong>云原生</strong>：生与云，长与云，<font color="red">无限弹性扩缩，K8s 友好</font></li><li><strong>高吞吐</strong>：万亿级吞吐保证，同时满足微服务与大数据场景。</li><li><strong>流处理</strong>：提供轻量、高扩展、高性能和丰富功能的流计算引擎。</li><li><strong>金融级</strong>：金融级的稳定性，广泛用于交易核心链路。</li><li><strong>架构极简</strong>：<font color="red">零外部依赖</font>，Shared-nothing 架构。</li><li><strong>生态友好</strong>：无缝对接微服务、实时计算、数据湖等周边生态。</li></ul><p>根据官网介绍：</p><blockquote><p>Apache RocketMQ 自诞生以来，因其架构简单、业务功能丰富、具备极强可扩展性等特点<font color="red">被众多企业开发者以及云厂商广泛采用</font>。历经十余年的大规模场景打磨，RocketMQ 已经成为<font color="red">业内共识的金融级可靠业务消息首选方案</font>，被广泛应用于互联网、大数据、移动互联网、物联网等领域的业务场景。</p></blockquote><h5 id="rabbitmq"><a class="anchor" href="#rabbitmq">#</a> RabbitMQ</h5><blockquote><p>RabbitMQ 官网：<span class="exturl" data-url="aHR0cHM6Ly93d3cucmFiYml0bXEuY29tLw==">https://www.rabbitmq.com/</span> 。</p><p>RabbitMQ 更新记录（可以直观看到项目是否还在维护）：<span class="exturl" data-url="aHR0cHM6Ly93d3cucmFiYml0bXEuY29tL25ld3MuaHRtbA==">https://www.rabbitmq.com/news.html</span></p></blockquote><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/rabbitmq-logo.png" alt="img"></p><p>RabbitMQ 是采用 Erlang 语言实现 <font color="red">AMQP (Advanced Message Queuing Protocol，高级消息队列协议）</font>的消息中间件，它最初起源于金融系统，用于在分布式系统中<font color="red">存储转发消息</font>。</p><p>RabbitMQ 发展到今天，被越来越多的人认可，这和它在易用性、扩展性、可靠性和高可用性等方面的卓著表现是分不开的。RabbitMQ 的具体特点可以概括为以下几点：</p><ul><li><strong>可靠性</strong>：RabbitMQ 使用一些机制来保证消息的可靠性，如<font color="red">持久化、传输确认、发布确认</font>等。</li><li><strong>灵活的路由</strong>：在消息进入队列之前，<font color="red">通过交换器来路由消息</font>。对于典型的路由功能，RabbitMQ 己经提供了一些内置的交换器来实现。针对更复杂的路由功能，可以将多个交换器绑定在一起，也可以通过插件机制来实现自己的交换器。这个后面会在我们讲 RabbitMQ 核心概念的时候详细介绍到。</li><li><strong>扩展性</strong>：多个 RabbitMQ 节点可以组成一个<font color="red">集群</font>，也可以根据实际业务情况动态地扩展集群中节点。</li><li><strong>高可用性</strong>：队列可以在集群中的机器上<font color="red">设置镜像</font>，使得在部分节点出现问题的情况下队列仍然可用。</li><li><strong>支持多种协议</strong>：RabbitMQ 除了原生支持 AMQP 协议，还支持 <font color="red">STOMP、MQTT</font> 等多种消息中间件协议。</li><li><strong>多语言客户端</strong>：RabbitMQ 几乎<font color="red">支持所有常用语言</font>，比如 Java、Python、Ruby、PHP、C#、JavaScript 等。</li><li><strong>易用的管理界面</strong>：RabbitMQ 提供了一个<font color="red">易用的用户界面</font>，使得用户可以<font color="red">监控和管理消息、集群中的节点</font>等。在安装 RabbitMQ 的时候会介绍到，安装好 RabbitMQ 就自带管理界面。</li><li><strong>插件机制</strong>：RabbitMQ 提供了许多插件，以实现从多方面进行扩展，当然也可以编写自己的插件。感觉这个有点类似 Dubbo 的 SPI 机制。</li></ul><h5 id="activemq"><a class="anchor" href="#activemq">#</a> ActiveMQ</h5><p>目前已经被淘汰，不推荐使用，不建议学习。</p><h4 id="对比"><a class="anchor" href="#对比">#</a> 对比</h4><blockquote><p>参考《Java 工程师面试突击第 1 季 - 中华石杉老师》</p></blockquote><table><thead><tr><th>对比方向</th><th>概要</th></tr></thead><tbody><tr><td>吞吐量</td><td>万级的 ActiveMQ 和 RabbitMQ 的吞吐量（ActiveMQ 的性能最差）要比十万级甚至是百万级的 <font color="red">RocketMQ 和 Kafka</font> 低一个数量级。</td></tr><tr><td>可用性</td><td><font color="red">都可以实现高可用</font>。ActiveMQ 和 RabbitMQ 都是基于<font color="red">主从架构</font>实现高可用性。RocketMQ 基于<font color="red">分布式架构</font>。 Kafka 也是分布式的，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用</td></tr><tr><td>时效性</td><td><font color="red">RabbitMQ</font> 基于 Erlang 开发，所以并发能力很强，性能极其好，延时很低，达到微秒级，其他几个都是 ms 级。</td></tr><tr><td>功能支持</td><td><font color="red">Pulsar</font> 的功能更全面，支持多租户、多种消费模式和持久性模式等功能，是下一代云原生分布式消息流平台。</td></tr><tr><td>消息丢失</td><td>ActiveMQ 和 RabbitMQ 丢失的可能性非常低， <font color="red">Kafka、RocketMQ 和 Pulsar</font> 理论上可以做到 0 丢失。</td></tr></tbody></table><p>总结：</p><ul><li>ActiveMQ 的社区算是比较成熟，但是较目前来说，ActiveMQ 的性能比较差，而且版本迭代很慢，不推荐使用，已经被淘汰了。</li><li>RabbitMQ 在吞吐量方面虽然稍逊于 Kafka、RocketMQ 和 Pulsar，但是由于它基于 Erlang 开发，所以并发能力很强，性能极其好，延时很低，达到微秒级。但是也因为 RabbitMQ 基于 Erlang 开发，所以国内很少有公司有实力做 Erlang 源码级别的研究和定制。如果业务场景对并发量要求不是太高（十万级、百万级），那这几种消息队列中，RabbitMQ 或许是你的首选。</li><li>RocketMQ 和 Pulsar 支持强一致性，对消息一致性要求比较高的场景可以使用。</li><li>RocketMQ 阿里出品，Java 系开源项目，源代码我们可以直接阅读，然后可以定制自己公司的 MQ，并且 RocketMQ 有阿里巴巴的实际业务场景的实战考验。</li><li>Kafka 仅仅提供较少的核心功能，但是提供超高的吞吐量，ms 级的延迟，极高的可用性以及可靠性，而且分布式可以任意扩展。同时 Kafka 最好是支撑较少的 topic 数量即可，保证其超高吞吐量。<font color="red">Kafka 唯一的一点劣势是有可能消息重复消费</font>，那么对数据准确性会造成极其轻微的影响，在大数据领域中以及日志采集中，这点轻微影响可以忽略这个特性天然适合大数据实时计算以及日志收集。如果是<font color="red">大数据领域的实时计算、日志采集等场景</font>，用 Kafka 是业内标准的，绝对没问题，社区活跃度很高，绝对不会黄，何况几乎是全世界这个领域的事实性规范。</li></ul><h2 id="kafka-2"><a class="anchor" href="#kafka-2">#</a> Kafka</h2><h3 id="基础"><a class="anchor" href="#基础">#</a> 基础</h3><h4 id="功能-应用场景"><a class="anchor" href="#功能-应用场景">#</a> 功能、应用场景</h4><p>Kafka 是一个<strong>分布式流式处理平台</strong>，流平台具有三个关键功能：</p><ol><li><strong><font color="red">消息队列</font></strong>：<font color="red">发布和订阅消息流</font>，这个功能类似于消息队列，这也是 Kafka 也被归类为消息队列的原因。</li><li><strong><font color="red">容错的持久方式存储记录消息流</font></strong>：Kafka 会<font color="red">把消息持久化到磁盘</font>，有效避免了消息丢失的风险。</li><li>**<font color="red">流式处理平台</font>：** 在消息发布的时候进行处理，Kafka 提供了一个<font color="red">完整的流式处理类库</font>。</li></ol><p>Kafka 主要有两大应用场景：</p><ol><li><strong><font color="red">消息队列</font></strong>：建立实时流数据管道，以可靠地在系统或应用程序之间获取数据。</li><li>**<font color="red">数据处理</font>：** 构建实时的流数据处理程序来转换或处理数据流。</li></ol><h4 id="相比其他-mq-的优势"><a class="anchor" href="#相比其他-mq-的优势">#</a> 相比其他 MQ 的优势</h4><p>Kafka 相比其他消息队列主要的优势如下：</p><ol><li><strong><font color="red">极致的性能</font></strong>：基于 Scala 和 Java 语言开发，设计中大量使用了<font color="red">批量处理</font>和<font color="red">异步</font>的思想，最高<font color="red">每秒可以处理千万级别的消息</font>。</li><li><strong><font color="red">生态系统兼容性无可匹敌</font></strong>：Kafka 与周边生态系统的兼容性是最好的没有之一，尤其在大数据和流计算领域。</li></ol><h4 id="消息模型"><a class="anchor" href="#消息模型">#</a> 消息模型</h4><blockquote><p>题外话：早期的 <code>JMS</code> 和 <code>AMQP</code> 属于消息服务领域权威组织所做的相关的标准，但是这些标准的进化跟不上消息队列的演进速度，<font color="red">这些标准实际上已经属于废弃状态</font>。所以，可能存在的情况是：<font color="red">不同的消息队列都有自己的一套消息模型</font>。</p></blockquote><h5 id="队列模型p2p"><a class="anchor" href="#队列模型p2p">#</a> 队列模型（P2P）</h5><blockquote><p>早期的消息模型</p></blockquote><p><img data-src="https://oss.javaguide.cn/github/javaguide/high-performance/message-queue/%E9%98%9F%E5%88%97%E6%A8%A1%E5%9E%8B23.png" alt="队列模型"></p><center>队列模型</center><p>使用<strong>队列（Queue）<strong>作为消息通信载体，满足生产者与消费者模式，</strong><font color="red">一条消息只能被一个消费者使用，未被消费的消息在队列中保留直到被消费或超时</font></strong>。比如：我们生产者发送 100 条消息的话，两个消费者来消费，一般情况下两个消费者会按照消息发送的顺序各自消费一半（也就是你一个我一个的消费。）</p><p>队列模型存在的问题：<font color="red">无法将生产者产生的消息分发给多个消费者，并保证每个消费者都能接收到完整的消息内容</font>。这种情况，队列模型就不好解决了。很多比较杠精的人就说：我们可以为每个消费者创建一个单独的队列，让生产者发送多份。这是一种非常愚蠢的做法，浪费资源不说，还违背了使用消息队列的目的。</p><h5 id="发布-订阅模型pub-sub"><a class="anchor" href="#发布-订阅模型pub-sub">#</a> 发布 - 订阅模型（Pub-Sub）</h5><blockquote><p><strong><font color="red">Kafka 采用的消息模型</font></strong>，为了解决队列模型存在的问题</p></blockquote><p><img data-src="https://oss.javaguide.cn/java-guide-blog/%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%9E%8B.png" alt="发布订阅模型"></p><center>发布订阅模型</center><p>发布 - 订阅模型（Pub-Sub） 使用<strong>主题（Topic）<strong>作为消息通信载体，类似于</strong>广播模式</strong>。<strong>发布者发布一条消息，该消息通过主题传递给所有的订阅者，在一条消息广播之后才订阅的用户则是收不到该条消息的</strong>。</p><p>在发布 - 订阅模型中，<font color="red">如果只有一个订阅者，那它和队列模型就基本是一样的了</font>。所以说，发布 - 订阅模型在功能层面上是可以兼容队列模型的。</p><blockquote><p><strong>RocketMQ 的消息模型和 Kafka 基本是完全一样的。唯一的区别是 Kafka 中没有队列这个概念，与之对应的是 Partition（分区）。</strong></p></blockquote><h3 id="核心概念"><a class="anchor" href="#核心概念">#</a> 核心概念</h3><h4 id="producer-comsumer-broker-topic-partition"><a class="anchor" href="#producer-comsumer-broker-topic-partition">#</a> Producer、Comsumer、Broker、Topic、Partition</h4><p>Kafka 将生产者发布的消息发送到 **Topic（主题）** 中，需要这些消息的消费者可以订阅这些 Topic，如下图所示：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/message-queue20210507200944439.png" alt="img"></p><p>上面这张图也为我们引出了，Kafka 比较重要的几个概念：</p><ol><li><p>Producer（生产者）: 产生消息的一方。</p></li><li><p>Consumer（消费者）: 消费消息的一方。</p></li><li><p><strong>Broker（代理）</strong>: 可以看作是<font color="red">一个独立的 Kafka 实例</font>。多个 Kafka Broker 组成一个 Kafka <strong>Cluster（集群）</strong>。每个 Broker 中又包含：</p><ul><li><p><strong>Topic（主题）</strong>: Producer 将消息发送到特定的主题，Consumer 通过订阅特定的 Topic (主题) 来消费消息。</p></li><li><p><strong>Partition（分区）</strong>: <font color="red">属于 Topic 的一部分</font>。一个 Topic 可以有多个 Partition ，并且 **<font color="red">同一 Topic 下的 Partition 可以分布在不同的 Broker 上，表明一个 Topic 可以横跨多个 Broker</font>**。</p></li></ul></li></ol><h4 id="多副本机制replica"><a class="anchor" href="#多副本机制replica">#</a> 多副本机制（Replica）</h4><blockquote><p>类似于 <strong>Redis 中的主从复制（Replica）</strong></p></blockquote><p>Kafka 为分区（Partition）引入了<strong>多副本（Replica）机制</strong>。Partition 中的多个副本之间会有一个叫做 <code>leader</code> 的家伙，其他副本称为 <code>follower</code> 。<font color="red">发送的消息先被发送到 leader 副本，然后 follower 副本才能从 leader 副本中拉取消息进行同步</font>。</p><blockquote><p><strong><font color="red">生产者和消费者只与 leader 副本交互</font></strong>。可以理解为<font color="red">其他副本只是 leader 副本的拷贝，它们的存在只是为了保证消息存储的安全性</font>。<font color="red">当 leader 副本发生故障时会从 follower 中选举出一个 leader，前提是该 follower 和 leader 同步程度一致</font>。</p></blockquote><p>Kafka 多副本（Replica）机制的好处如下：</p><ol><li><strong><font color="red">负载均衡</font></strong>：Kafka 通过给特定 Topic 指定多个 Partition，而各个 Partition 可以分布在不同的 Broker 上，这样便能提供比较好的<font color="red">并发能力</font>。</li><li><strong><font color="red">数据容灾能力</font></strong>：Partition 可以指定对应的 Replica 数，极大地提高了消息存储的安全性与容灾能力，不过也相应地增加了所需要的存储空间。</li></ol><h3 id="kafka-与-zookeeper-的关系"><a class="anchor" href="#kafka-与-zookeeper-的关系">#</a> Kafka 与 Zookeeper 的关系</h3><h4 id="zookeeper-在-kafka-中的作用"><a class="anchor" href="#zookeeper-在-kafka-中的作用">#</a> Zookeeper 在 Kafka 中的作用</h4><p>下图就是我的本地 Zookeeper，它成功和我本地的 Kafka 关联上（以下文件夹结构借助 idea 插件 Zookeeper tool 实现）。</p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/zookeeper-kafka.jpg" alt="img" style="zoom:50%"><p>ZooKeeper 主要为 Kafka 提供<strong>元数据的管理</strong>的功能。</p><p>从图中我们可以看出，Zookeeper 主要为 Kafka 做了下面这些事情：</p><ol><li><strong><font color="red">Broker 注册</font></strong>：在 Zookeeper 上会有一个专门用来<font color="red">记录 Broker 服务器列表</font>的节点。每个 Broker 在启动时，都会到 Zookeeper 上进行注册，即到 <code>/brokers/ids</code> 下创建属于自己的节点。每个 Broker 就会将自己的 IP 地址和端口等信息记录到该节点中去</li><li><strong><font color="red">Topic 注册</font></strong>：在 Kafka 中，<font color="red">同一个 Topic 的消息会被分成多个 Partition</font>，并将其分布在多个 Broker 上。<font color="red">这些 Partition 信息及与 Broker 的对应关系也都是由 Zookeeper 在维护</font>。比如我创建了一个名字为 my-topic 的 Topic 并且它有两个 Partition ，对应到 zookeeper 中会创建这些文件夹： <code>/brokers/topics/my-topic/Partitions/0</code> 、 <code>/brokers/topics/my-topic/Partitions/1</code></li><li><strong><font color="red">负载均衡</font></strong>：上面也说过了 Kafka 通过给特定 Topic 指定多个 Partition，而各个 Partition 可以分布在不同的 Broker 上，这样便能提供比较好的并发能力。<font color="red">对于同一个 Topic 的不同 Partition，Kafka 会尽力将这些 Partition 分布到不同的 Broker 服务器上</font>。<ul><li>当 Provider 产生消息时，会尽量投递到不同 Broker 的 Partition 里面。</li><li>当 Consumer 消费消息时，Zookeeper 会可以根据当前的 Partition 数量以及 Consumer 数量来实现动态负载均衡。</li></ul></li><li>……</li></ol><h4 id="kafka-不再依赖于-zookeeper"><a class="anchor" href="#kafka-不再依赖于-zookeeper">#</a> Kafka 不再依赖于 Zookeeper</h4><p>在 Kafka 2.8 之前，Kafka 最被大家诟病的就是其重度依赖于 Zookeeper。<font color="red">在 Kafka 2.8 之后，引入了基于 Raft 协议的 KRaft 模式，不再依赖 Zookeeper，大大简化了 Kafka 的架构，让你可以以一种轻量级的方式来使用 Kafka</font>。</p><p>不过，要提示一下：如果要使用 KRaft 模式的话，建议选择较高版本的 Kafka，因为这个功能还在持续完善优化中。Kafka 3.3.1 版本是第一个将 KRaft（Kafka Raft）共识协议标记为生产就绪的版本。</p><p>![](<span class="exturl" data-url="aHR0cHM6Ly9vc3MuamF2YWd1aWRlLmNuL2dpdGh1Yi9qYXZhZ3VpZGUvaGlnaC1wZXJmb3JtYW5jZS9tZXNzYWdlLXF1ZXVlL2thZmthMy4zLjEta3JhZnQt">https://oss.javaguide.cn/github/javaguide/high-performance/message-queue/kafka3.3.1-kraft-</span> production-ready.png)</p><h3 id="消费顺序-消息丢失-重复消费"><a class="anchor" href="#消费顺序-消息丢失-重复消费">#</a> 消费顺序、消息丢失、重复消费</h3><h4 id="如何保证消息的消费顺序"><a class="anchor" href="#如何保证消息的消费顺序">#</a> 如何保证消息的消费顺序？</h4><p>我们在使用消息队列的过程中经常有业务场景需要严格保证消息的消费顺序，比如我们同时发了 2 个消息，这 2 个消息对应的操作分别对应的数据库操作是：</p><ol><li>更改用户会员等级。</li><li>根据会员等级计算订单价格。</li></ol><p>假如这两条消息的消费顺序不一样造成的最终结果就会截然不同。</p><p>我们知道<font color="red"> Kafka 中 Partition (分区) 是真正保存消息的地方</font>，我们发送的消息都被放在了这里。而 Partition (分区) 又存在于 Topic (主题) 概念中，并且我们可以给特定 Topic 指定多个 Partition。</p><p><img data-src="https://oss.javaguide.cn/github/javaguide/high-performance/message-queue/KafkaTopicPartionsLayout.png" alt="img"></p><p>每次添加消息到 Partition (分区) 的时候都会采用 **<font color="red">尾加法</font>**，如上图所示。 <font color="red">Kafka 只能为我们保证 Partition（分区）中的消息有序，通过 **offset（偏移量）** 实现</font>。</p><blockquote><p>消息在被追加到 Partition (分区) 的时候都会分配一个特定的偏移量（offset）。</p></blockquote><p>所以，我们就有一种很简单的保证消息消费顺序的方法：1 个 Topic 只对应一个 Partition。这样当然可以解决问题，但是破坏了 Kafka 的设计初衷。</p><p>Kafka 中发送 1 条消息的时候，可以指定 topic、partition、key、data（数据）4 个参数。如果你发送消息的时候指定了 Partition 的话，所有消息都会被发送到指定的 Partition。并且，<font color="red">同一个 key 的消息可以保证只发送到同一个 partition</font>，这个我们可以采用表 / 对象的 id 来作为 key 。</p><p>总结一下，对于如何保证 Kafka 中消息消费的顺序，有了下面两种方法：</p><ol><li>1 个 Topic 只对应一个 Partition。</li><li>（推荐）<strong>发送消息的时候指定 key/Partition</strong>。</li></ol><p>当然不仅仅只有上面两种方法，上面两种方法是我觉得比较好理解的。</p><h4 id="如何保证消息不丢失"><a class="anchor" href="#如何保证消息不丢失">#</a> 如何保证消息不丢失？</h4><h5 id="情况1producer-丢失消息"><a class="anchor" href="#情况1producer-丢失消息">#</a> 情况 1：Producer 丢失消息</h5><p>Producer 调用 <code>send</code> 方法发送消息之后，消息可能因为网络问题并没有发送过去。所以，我们不能默认在调用 <code>send</code> 方法发送消息之后消息发送成功了。</p><p>为了确定消息是发送成功，我们要判断消息发送的结果。但是要注意的是<font color="red"> Kafka 中 Producer 使用 <code>send</code> 方法发送消息实际上是异步的操作，可以通过 <code>get()</code> 方法获取调用结果，但是这样也让它变为了同步操作</font>，示例代码如下：</p><blockquote><p>详细代码见这篇文章：<span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3M/X19iaXo9TXpnMk9UQTBOamswT0E9PSZhbXA7bWlkPTIyNDc0ODYyNjkmYW1wO2lkeD0yJmFtcDtzbj1lYzAwNDE3YWQ2NDFkZDhjM2QxNDVkNzRjYWZhMDljZSZhbXA7Y2hrc209Y2VhMjQ0ZjZmOWQ1Y2RlMGM4ZWIyMzNmY2M0Y2Y4MmUxMWFjZDA2NDQ2NzE5YTdhZjU1MjMwNjQ5ODYzYTNkZGQ5NWY3OGQxMTFkZSZhbXA7dG9rZW49MTYzMzk1NzI2MiZhbXA7bGFuZz16aF9DTiNyZA==">Kafka 系列第三篇！10 分钟学会如何在 Spring Boot 程序中使用 Kafka 作为消息队列？</span></p></blockquote><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">SendResult</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">></span></span> sendResult <span class="token operator">=</span> kafkaTemplate<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>topic<span class="token punctuation">,</span> o<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">if</span> <span class="token punctuation">(</span>sendResult<span class="token punctuation">.</span><span class="token function">getRecordMetadata</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  logger<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"生产者成功发送消息到"</span> <span class="token operator">+</span> sendResult<span class="token punctuation">.</span><span class="token function">getProducerRecord</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">topic</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"-> "</span> <span class="token operator">+</span> sendRe</pre></td></tr><tr><td data-num="4"></td><td><pre>              sult<span class="token punctuation">.</span><span class="token function">getProducerRecord</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>但是<font color="red">一般不推荐这么做</font>！可以<strong>借助  <code>ListenableFuture</code> 为 Producer 的 <code>send</code> 方法添加回调函数</strong>的形式，示例代码如下：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">ListenableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">SendResult</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">></span><span class="token punctuation">></span></span> future <span class="token operator">=</span> kafkaTemplate<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>topic<span class="token punctuation">,</span> o<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>        future<span class="token punctuation">.</span><span class="token function">addCallback</span><span class="token punctuation">(</span>result <span class="token operator">-></span> logger<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"生产者成功发送消息到topic:&#123;&#125; partition:&#123;&#125;的消息"</span><span class="token punctuation">,</span> result<span class="token punctuation">.</span><span class="token function">getRecordMetadata</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">topic</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> result<span class="token punctuation">.</span><span class="token function">getRecordMetadata</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">partition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="3"></td><td><pre>                ex <span class="token operator">-></span> logger<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"生产者发送消息失败，原因：&#123;&#125;"</span><span class="token punctuation">,</span> ex<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p><strong><font color="red">如果消息发送失败的话，我们检查失败的原因之后重新发送即可</font></strong>！</p><ul><li><p>这里推荐<font color="red">为 Producer 的  <code>retries</code> （重试次数）设置一个比较合理的值，一般是 3 </font>，但是为了保证消息不丢失的话一般会设置比较大一点。设置完成之后，当出现网络问题之后能够自动重试消息发送，避免消息丢失。</p></li><li><p>另外，<font color="red">建议还要设置重试间隔</font>，因为间隔太小的话重试的效果就不明显了，网络波动一次你 3 次一下子就重试完了。</p></li></ul><h5 id="情况2consumer-丢失消息"><a class="anchor" href="#情况2consumer-丢失消息">#</a> 情况 2：Consumer 丢失消息</h5><p>我们知道消息在被追加到 Partition (分区) 的时候都会分配一个特定的 offset（偏移量）。<font color="red">offset 表示 Consumer 当前消费到的 Partition (分区) 的所在位置</font>。Kafka 通过偏移量（offset）可以保证消息在分区内的顺序性。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/kafka-offset.jpg" alt="kafka offset"></p><center>kafka offset</center><p><font color="red">当 Consumer 拉取到了 Partition 的某个消息之后，Consumer 会自动提交了 offset </font>。自动提交的话会有一个问题，试想一下，当 Consumer 刚拿到这个消息准备进行真正消费的时候，突然挂掉了，消息实际上并没有被消费，但是 offset 却被自动提交了。</p><p>解决办法也比较粗暴，我们 ** 关闭自动提交 offset，每次在真正消费完消息之后再手动提交 offset **。 但是，细心的朋友一定会发现，<font color="red">这样会带来消息被重新消费的问题</font>。比如你刚刚消费完消息之后，还没提交 offset，结果自己挂掉了，那么这个消息理论上就会被消费两次。</p><h5 id="情况3kafka-丢失消息"><a class="anchor" href="#情况3kafka-丢失消息">#</a> 情况 3：Kafka 丢失消息</h5><p>我们知道<font color="red"> Kafka 为 Partition 引入了多副本（Replica）机制</font>。Partition 中的多个副本之间会有一个叫做 leader 的家伙，其他副本称为 follower。我们发送的消息会被发送到 leader 副本，然后 follower 副本才能从 leader 副本中拉取消息进行同步。Producer 和 Comsumer 只与 leader 副本交互。可以理解为其他 follower 副本只是 leader 副本的拷贝，它们的存在只是为了保证消息存储的安全性。</p><p>试想一种情况：<font color="red">假如 leader 副本所在的 broker 突然挂掉，但是 leader 的数据还有一些没有被 follower 副本的同步的话，就会造成<strong>消息丢失</strong></font>。</p><ul><li><p><strong>设置 <code>acks = all</code> </strong>：<font color="red">acks 是 Kafka Producer 很重要的一个参数，其默认值为 1，代表我们的消息被 leader 副本接收之后就算被成功发送</font>。<strong><font color="red">配置 <code>acks = all</code> 表示只有所有 ISR 列表的副本全部收到消息时，Producer 才会接收到来自服务器的响应</font></strong>。这种模式是<font color="red">最高级别、最安全</font>的，可以确保不止一个 Broker 接收到了消息，但副作用是<font color="red">延迟会很高</font>。</p><blockquote><p>Partition 中的所有副本统称为 <strong><code>AR</code> </strong>（Assigned Repllicas）。所有与 leader 副本保持一定程度同步的副本（包括 Leader 本身）组成 <strong><code>ISR</code> </strong>（In-Sync Replicas），ISR 集合是 AR 集合中的一个子集。</p></blockquote></li><li><p><strong>设置 <code>replication.factor &gt;= 3</code> </strong>：为了保证 leader 副本能有 follower 副本能同步消息，可以 **<font color="red">确保每个 Partition 至少有 3 个副本</font>**。虽然造成了数据冗余，但是带来了<font color="red">数据的安全性</font>。</p></li><li><p><strong>设置 <code>min.insync.replicas &gt; 1</code> </strong>：<strong><font color="red">代表消息至少要被写入到 2 个副本才算是被成功发送</font></strong>。其默认值为 1 ，在实际生产中应尽量避免。</p></li><li><p><strong>确保 <code>replication.factor &gt; min.insync.replicas</code> </strong>：<font color="red">为了保证整个 Kafka 服务的高可用性</font>。设想一下假如两者相等的话，只要是有一个副本挂掉，整个 Partition 就无法正常工作了。这明显违反高可用性！<font color="red">一般推荐设置成 <code>replication.factor = min.insync.replicas + 1</code> </font>。</p></li><li><p><strong>设置 <code>unclean.leader.election.enable = false</code> </strong>：</p><blockquote><p>Kafka 从 0.11.0.0 版本开始， <code>unclean.leader.election.enable</code> 参数的默认值改为 false</p></blockquote><p>我们最开始也说了我们发送的消息会被发送到 leader 副本，然后 follower 副本才能从 leader 副本中拉取消息进行同步，多个 follower 副本之间的消息同步情况不一样。当我们配置了 unclean.leader.election.enable = false 的话，<strong><font color="red">当 leader 副本发生故障时，就不会从同步程度达不到要求的 follower 副本中选择出 leader</font></strong>，降低了消息丢失的可能性。</p></li></ul><h4 id="如何保证消息不被重复消费"><a class="anchor" href="#如何保证消息不被重复消费">#</a> 如何保证消息不被重复消费？</h4><p>kafka 出现消息重复消费的原因：</p><ul><li><p><strong><font color="red">根本原因：Consumer 已经消费了消息，但没有成功提交 offset</font></strong></p></li><li><p>直接原因：Consumer 由于处理业务时间长或者网络链接等原因，<font color="red">让 Kafka 认为服务假死，触发了 Partition <code>rebalance</code> </font>。</p></li></ul><p>解决方案：</p><ul><li><strong>Consumer 消费消息服务做幂等校验</strong>，比如 Redis 的 set、MySQL 的主键等天然的幂等功能，这种方法最有效。</li><li><strong>将 <code>enable.auto.commit</code> 参数设置为 false，关闭 offset 的自动提交，开发者在代码中手动提交 offset</strong>。那么这里会有个问题：什么时候提交 offset 合适？<ul><li>处理完消息再提交：依旧有消息重复消费的风险，和自动提交一样</li><li><strong>拉取到消息即提交</strong>：会有消息丢失的风险。允许消息延时的场景，一般会采用这种方式。然后，通过定时任务在业务不繁忙（比如凌晨）的时候做数据兜底。</li></ul></li></ul><h3 id="重试机制"><a class="anchor" href="#重试机制">#</a> 重试机制</h3><blockquote><p>在 Kafka 如何保证消息不丢失中提到了 Kafka 的重试机制。</p><p>网上关于 Spring Kafka 的默认重试机制文章很多，但大多都是过时的，和实际运行结果完全不一样。以下是根据 <span class="exturl" data-url="aHR0cHM6Ly9tdm5yZXBvc2l0b3J5LmNvbS9hcnRpZmFjdC9vcmcuc3ByaW5nZnJhbWV3b3JrLmthZmthL3NwcmluZy1rYWZrYS8yLjkuMw==">spring-kafka-2.9.3</span> 源码重新梳理一下。</p></blockquote><h4 id="消费失败后会先重试多次重试失败后会跳过"><a class="anchor" href="#消费失败后会先重试多次重试失败后会跳过">#</a> 消费失败后会先重试，多次重试失败后会跳过</h4><p>Producer 代码：</p><pre><code class="language-Java"> for (int i = 0; i &lt; 10; i++) &#123;
   kafkaTemplate.send(KafkaConst.TEST_TOPIC, String.valueOf(i))
 &#125;
</code></pre><p>Comsumer 代码：</p><pre><code class="language-Java">   @KafkaListener(topics = &#123;KafkaConst.TEST_TOPIC&#125;,groupId = &quot;apple&quot;)
   private void customer(String message) throws InterruptedException &#123;
       log.info(&quot;kafka customer:&#123;&#125;&quot;,message);
       Integer n = Integer.parseInt(message);
       if (n%5==0)&#123; // 当n为0和5时抛出异常
           throw new  RuntimeException();
       &#125;
   &#125;
</code></pre><p><strong>在默认配置下，当消费异常会进行重试，重试多次后会跳过当前消息，继续进行后续消息的消费，不会一直卡在当前消息</strong>。</p><p>下面是一段消费的日志，可以看出当 <code>test-0@95</code> 重试多次后会被跳过。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token number">2023</span><span class="token operator">-</span><span class="token number">08</span><span class="token operator">-</span><span class="token number">10</span> <span class="token number">12</span><span class="token operator">:</span><span class="token number">03</span><span class="token operator">:</span><span class="token number">32.918</span> <span class="token constant">DEBUG</span> <span class="token number">9700</span> <span class="token operator">--</span><span class="token operator">-</span> <span class="token punctuation">[</span>ntainer#<span class="token number">0</span><span class="token operator">-</span><span class="token number">0</span><span class="token operator">-</span><span class="token class-name">C</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token class-name"><span class="token namespace">o<span class="token punctuation">.</span>s<span class="token punctuation">.</span>kafka<span class="token punctuation">.</span>listener<span class="token punctuation">.</span></span>DefaultErrorHandler</span>   <span class="token operator">:</span> <span class="token class-name">Skipping</span> seek of<span class="token operator">:</span> test<span class="token operator">-</span><span class="token number">0</span><span class="token annotation punctuation">@95</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token number">2023</span><span class="token operator">-</span><span class="token number">08</span><span class="token operator">-</span><span class="token number">10</span> <span class="token number">12</span><span class="token operator">:</span><span class="token number">03</span><span class="token operator">:</span><span class="token number">32.918</span> <span class="token constant">TRACE</span> <span class="token number">9700</span> <span class="token operator">--</span><span class="token operator">-</span> <span class="token punctuation">[</span>ntainer#<span class="token number">0</span><span class="token operator">-</span><span class="token number">0</span><span class="token operator">-</span><span class="token class-name">C</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token class-name"><span class="token namespace">o<span class="token punctuation">.</span>s<span class="token punctuation">.</span>kafka<span class="token punctuation">.</span>listener<span class="token punctuation">.</span></span>DefaultErrorHandler</span>   <span class="token operator">:</span> <span class="token class-name">Seeking</span><span class="token operator">:</span> test<span class="token operator">-</span><span class="token number">0</span> <span class="token keyword">to</span><span class="token operator">:</span> <span class="token number">96</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token number">2023</span><span class="token operator">-</span><span class="token number">08</span><span class="token operator">-</span><span class="token number">10</span> <span class="token number">12</span><span class="token operator">:</span><span class="token number">03</span><span class="token operator">:</span><span class="token number">32.918</span>  <span class="token constant">INFO</span> <span class="token number">9700</span> <span class="token operator">--</span><span class="token operator">-</span> <span class="token punctuation">[</span>ntainer#<span class="token number">0</span><span class="token operator">-</span><span class="token number">0</span><span class="token operator">-</span><span class="token class-name">C</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token class-name"><span class="token namespace">o<span class="token punctuation">.</span>a<span class="token punctuation">.</span>k<span class="token punctuation">.</span>clients<span class="token punctuation">.</span>consumer<span class="token punctuation">.</span></span>KafkaConsumer</span>     <span class="token operator">:</span> <span class="token punctuation">[</span><span class="token class-name">Consumer</span> clientId<span class="token operator">=</span>consumer<span class="token operator">-</span>apple<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> groupId<span class="token operator">=</span>apple<span class="token punctuation">]</span> <span class="token class-name">Seeking</span> <span class="token keyword">to</span> <span class="token namespace">offset</span> <span class="token number">96</span> <span class="token keyword">for</span> partition test<span class="token operator">-</span><span class="token number">0</span></pre></td></tr></table></figure><h4 id="默认重试-10-次时间间隔为-0"><a class="anchor" href="#默认重试-10-次时间间隔为-0">#</a> 默认重试 10 次，时间间隔为 0</h4><blockquote><p>源码略了</p></blockquote><p>总结：<strong>Kafka Comsumer 在默认配置下会进行最多 10 次重试，每次重试的时间间隔为 0，即立即重试。如果在 10 次重试后仍然无法成功消费消息，则不再进行重试，该消息将被视为消费失败</strong>。</p><h4 id="自定义重试次数-时间间隔"><a class="anchor" href="#自定义重试次数-时间间隔">#</a> 自定义重试次数、时间间隔</h4><p>从上面的代码可以知道，默认错误处理器的重试次数以及时间间隔是由 <code>FixedBackOff</code> 控制的， <code>FixedBackOff</code> 是 <code>DefaultErrorHandler</code> 初始化时默认的。</p><p>所以自定义重试次数以及时间间隔，<strong>只需要在 <code>DefaultErrorHandler</code> 初始化的时候传入自定义的 <code>FixedBackOff</code> 即可</strong>。</p><p>重新实现一个 <code>KafkaListenerContainerFactory</code> ，调用 <code>setCommonErrorHandler</code> 设置新的自定义的错误处理器就可以实现。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token annotation punctuation">@Bean</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span> <span class="token class-name">KafkaListenerContainerFactory</span> <span class="token function">kafkaListenerContainerFactory</span><span class="token punctuation">(</span><span class="token class-name">ConsumerFactory</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">></span></span> consumerFactory<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token class-name">ConcurrentKafkaListenerContainerFactory</span> factory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentKafkaListenerContainerFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token comment">// 自定义重试时间间隔以及次数</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token class-name">FixedBackOff</span> fixedBackOff <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FixedBackOff</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    factory<span class="token punctuation">.</span><span class="token function">setCommonErrorHandler</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">DefaultErrorHandler</span><span class="token punctuation">(</span>fixedBackOff<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    factory<span class="token punctuation">.</span><span class="token function">setConsumerFactory</span><span class="token punctuation">(</span>consumerFactory<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">return</span> factory<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h4 id="重试失败后如何告警"><a class="anchor" href="#重试失败后如何告警">#</a> 重试失败后，如何告警？</h4><p>重试失败后逻辑需要手动实现，以下是一个简单的例子。<strong>继承 <code>DefaultErrorHandler</code> 并重写 <code>handleRemaining</code> 函数，加上自定义的告警等操作</strong>。</p><pre><code class="language-Java">@Slf4j
public class DelErrorHandler extends DefaultErrorHandler &#123;

    public DelErrorHandler(FixedBackOff backOff) &#123;
        super(null,backOff);
    &#125;

    @Override
    public void handleRemaining(Exception thrownException, List&lt;ConsumerRecord&lt;?, ?&gt;&gt; records, Consumer&lt;?, ?&gt; consumer, MessageListenerContainer container) &#123;
        super.handleRemaining(thrownException, records, consumer, container);
        log.info(&quot;重试多次失败&quot;);
        // 自定义操作
    &#125;
&#125;
</code></pre><p><code>DefaultErrorHandler</code> 只是默认的一个错误处理器，Spring Kafka 还提供了 <code>CommonErrorHandler</code> 接口。手动实现 <code>CommonErrorHandler</code> 就可以实现更多的自定义操作，有很高的灵活性。例如根据不同的错误类型，实现不同的重试逻辑以及业务逻辑等。</p><h4 id="重试最大次数失败后如何再次处理该消息"><a class="anchor" href="#重试最大次数失败后如何再次处理该消息">#</a> 重试最大次数失败后，如何再次处理该消息？</h4><p>当达到最大重试次数后，消息数据会被直接跳过，继续向后进行。当代码修复后，如何重新消费这些重试失败的消息数据呢？</p><p><strong>死信队列（Dead Letter Queue，简称 DLQ）</strong> 是消息中间件中的一种特殊队列。它主要 **<font color="red">用于处理无法被 Comsumer 正确处理的消息</font>**，通常是因为<font color="red">消息格式错误、处理失败、消费超时</font>等情况导致的消息被 &quot;丢弃&quot; 或 &quot;死亡&quot; 的情况。</p><p>当消息进入队列后，消费者会尝试处理它。如果处理失败，或者超过一定的重试次数仍无法被成功处理，消息可以发送到死信队列中，而不是被永久性地丢弃。<font color="red">在死信队列中，可以进一步分析、处理这些无法正常消费的消息，以便定位问题、修复错误，并采取适当的措施</font>。</p><h4 id="重试注解-retryabletopic"><a class="anchor" href="#重试注解-retryabletopic">#</a> 重试注解 <code>@RetryableTopic</code></h4><p>这是 Spring Kafka 中的一个注解，<strong><font color="red">用于配置某个 Topic 支持消息重试</font></strong>，更推荐使用这个注解来完成重试。</p><pre><code class="language-Java">// 重试 5 次，重试间隔 100 毫秒,最大间隔 1 秒
@RetryableTopic(
        attempts = &quot;5&quot;,
        backoff = @Backoff(delay = 100, maxDelay = 1000)
)
@KafkaListener(topics = &#123;KafkaConst.TEST_TOPIC&#125;, groupId = &quot;apple&quot;)
private void customer(String message) &#123;
    log.info(&quot;kafka customer:&#123;&#125;&quot;, message);
    Integer n = Integer.parseInt(message);
    if (n % 5 == 0) &#123;
        throw new RuntimeException();
    &#125;
    System.out.println(n);
&#125;
</code></pre><p>当达到最大重试次数后，如果仍然无法成功处理消息，消息会被发送到对应的死信队列中。<font color="red">对于死信队列的处理，既可以用 <code>@DltHandler</code> 处理，也可以使用 <code>@KafkaListener</code> 重新消费</font>。</p><h3 id="面试题kafka-消费组有什么特性"><a class="anchor" href="#面试题kafka-消费组有什么特性">#</a> 【面试题】kafka 消费组有什么特性？</h3><p>Kafka 消费组：是 Kafka 提供的<font color="red">可扩展、具有容错性的 Comsumer 机制</font>。同一个消费组的多个 Comsumer 能分布到多个物理机器上<font color="red">加速消费</font>，同时也可以实现<font color="red">负载均衡</font>。</p><p>当某个 Comsumer 宕机时，其他 Comsumer 可以继续消费该 Partition 的数据，从而保证了<font color="red">数据的可靠性和持久性</font>。</p><p>因此，Kafka 消费组有以下特性：</p><ul><li>同一个消费组内的<font color="red">所有 Comsumer 共享一个公共 ID</font>。</li><li>消费组内的<font color="red">每个 Comsumer 都有自己的 offset (偏移量)</font>，用于记录已经消费过的消息位置。</li><li>消费组内的<font color="red">每个 Comsumer 可以处理 Partition 中的所有消息</font>。</li></ul><h3 id="面试题kafka-多-topic-为什么有性能问题"><a class="anchor" href="#面试题kafka-多-topic-为什么有性能问题">#</a> 【面试题】kafka 多 topic 为什么有性能问题？</h3><p>kafka 多 topic 可能会导致性能问题的<font color="gree">原因</font>：</p><ul><li><strong>Partition 数量增加</strong>：每个 topic 都会被分成多个 Partition，当有大量的 topic 存在时， Partition 数量也会相应增加。这会导致 Kafka 需要处理更多的 Partition，增加了系统的负载和资源消耗。</li><li><strong>网络开销增加</strong>：Kafka 的多 topic 会导致更多的网络通信开销。当一个 Producer 同时向多个 topic 发送消息时，需要建立多个网络连接，并且需要维护多个网络通信的状态。这增加了网络开销和延迟。</li><li><strong>资源竞争</strong>：多个 topic 同时进行读写操作时，会引起资源的竞争。例如，多个 Comsumer 同时消费不同的 topic，会导致 Comsumer 之间的竞争和争夺资源的情况，从而影响系统的性能。</li><li><strong>数据分布不均衡</strong>：当有大量的 topic 存在时，数据的分布可能会不均衡。某些 topic 可能会有更多的数据量，而某些 topic 可能会有较少的数据量。这会<font color="red">导致某些 broker 负载过重</font>，而其他 broker 负载较轻，从而影响整个系统的性能。</li></ul><p>为了解决这些性能问题，可以采取以下<font color="gree">措施</font>：</p><ul><li><strong>合并 topic</strong>：如果有多个 topic 的数据量较小，可以考虑将它们合并为一个 topic，减少分区数量和网络开销。</li><li><strong>增加资源</strong>：<font color="red">增加 Kafka 集群的 broker 数量和 C omsumer 数量</font>，以便更好地处理多 topic 的负载。</li><li><strong>均衡数据分布</strong>：通过调整 Partition 分配策略，使得数据在各个 broker 上均衡分布，避免负载不均的情况。</li><li><strong>使用分区策略</strong>：根据业务需求，合理地选择分区策略，避免数据集中在某个 Partition 或某个 broker 上。</li><li><strong>优化网络通信</strong>：通过合理的网络配置和优化，减少网络开销和延迟，提高系统的性能。</li></ul><h2 id="rocketmq-2"><a class="anchor" href="#rocketmq-2">#</a> RocketMQ</h2><p>RocketMQ 是一款功能强大的<strong>分布式消息系统</strong>，广泛应用于多个领域，包括异步通信解耦、企业解决方案、金融支付、电信、电子商务、快递物流、广告营销、社交、即时通信、移动应用、手游、视频、物联网、车联网等。</p><p>RocketMQ 源码地址：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FwYWNoZS9yb2NrZXRtcQ==">https://github.com/apache/rocketmq</span></p><p>RocketMQ 官方网站：<span class="exturl" data-url="aHR0cHM6Ly9yb2NrZXRtcS5hcGFjaGUub3JnL3poLw==">https://rocketmq.apache.org</span></p><p>文章描述 RocketMQ 相关概念和知识，如无特别声明，均是 <code>Apache RocketMQ 4.x</code> 版本。</p><p><span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vbmFnZW9mZmVyL3NwcmluZ2Jvb3QtbGFkZGVy">🔥SpringBoot Ladder</span>：从零到一学习 SpringBoot 各种组件框架实战的项目，让 Demo 变得简单。咱们文章中的 RocketMQ 示例也在这个项目。</p><h3 id="使用场景"><a class="anchor" href="#使用场景">#</a> 使用场景</h3><h4 id="异步解耦"><a class="anchor" href="#异步解耦">#</a> <mark>异步解耦</mark></h4><p>最常见的一个场景是用户注册后，需要发送注册邮件和短信通知，以告知用户注册成功。传统的做法有以下两种：</p><h5 id="串行方式"><a class="anchor" href="#串行方式">#</a> 串行方式</h5><p>串行方式下的注册流程如下图所示。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/p429262.png" alt="img"></p><p>数据流动如下所述：</p><ol><li>您在注册页面填写账号和密码并提交注册信息，这些注册信息首先会被写入注册系统。</li><li>注册信息写入注册系统成功后，再发送请求至邮件通知系统。邮件通知系统收到请求后向用户发送邮件通知。</li><li>邮件通知系统接收注册系统请求后再向下游的短信通知系统发送请求。短信通知系统收到请求后向用户发送短信通知。</li></ol><p>以上三个任务全部完成后，才返回注册结果到客户端，用户才能使用账号登录。</p><p>假设每个任务耗时分别为 50ms，则用户需要在注册页面等待总共 150ms 才能登录。</p><h5 id="并行方式"><a class="anchor" href="#并行方式">#</a> 并行方式</h5><p>并行方式下的注册流程如下图所示。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/p429331.png" alt="img"></p><p>数据流动如下所述：</p><ol><li>用户在注册页面填写账号和密码并提交注册信息，这些注册信息首先会被写入注册系统。</li><li>注册信息写入注册系统成功后，再<font color="red">同时发送请求至邮件和短信通知系统</font>。邮件和短信通知系统收到请求后分别向用户发送邮件和短信通知。</li></ol><p>以上两个任务全部完成后，才返回注册结果到客户端，用户才能使用账号登录。</p><p>假设每个任务耗时分别为 50ms，其中，邮件和短信通知并行完成，则用户需要在注册页面等待总共 100ms 才能登录。</p><h5 id="异步解耦-2"><a class="anchor" href="#异步解耦-2">#</a> 异步解耦</h5><p>对于用户来说，注册功能实际只需要注册系统存储用户的账户信息后，该用户便可以登录，后续的注册短信和邮件不是即时需要关注的步骤。</p><p>对于注册系统而言，发送注册成功的短信和邮件通知并不一定要绑定在一起同步完成，所以实际<font color="red">当数据写入注册系统后，注册系统就可以把其他的操作放入对应的 RocketMQ 中然后马上返回用户结果，由 RocketMQ 异步地进行这些操作</font>。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/p429333.png" alt="img"></p><p>数据流动如下所述：</p><ol><li>用户在注册页面填写账号和密码并提交注册信息，这些注册信息首先会被写入注册系统。</li><li><font color="red">注册信息写入注册系统成功后，再发送消息至 RocketMQ。RocketMQ 会马上返回响应给注册系统，注册完成。用户可立即登录。</font></li><li><font color="red">下游的邮件和短信通知系统订阅 RocketMQ 的此类注册请求消息</font>，即可向用户发送邮件和短信通知，完成所有的注册流程。</li></ol><p>用户只需在注册页面等待注册数据写入注册系统和 RocketMQ 的时间，即等待 55ms 即可登录。</p><h4 id="流量削峰"><a class="anchor" href="#流量削峰">#</a> <mark>流量削峰</mark></h4><p>流量削峰也是 RocketMQ 的常用场景，一般在<font color="red">秒杀或团队抢购</font>活动中使用广泛。</p><p>在秒杀或团队抢购活动中，由于<font color="red">用户请求量较大</font>，导致流量暴增，秒杀的应用在处理如此大量的访问流量后，下游的通知系统无法承载海量的调用量，甚至会导致系统崩溃等问题而发生漏通知的情况。为解决这些问题，<font color="red">可在应用和下游通知系统之间加入 RocketMQ</font>。</p><p><img data-src="https://images-machen.oss-cn-beijing.aliyuncs.com/p429350.png" alt="img"></p><p>秒杀处理流程如下所述：</p><ol><li>用户发起海量秒杀请求到秒杀业务处理系统。</li><li>秒杀处理系统按照秒杀处理逻辑<font color="red">将满足秒杀条件的请求发送 RocketMQ</font>。</li><li><font color="red">下游的通知系统订阅 RocketMQ 的秒杀相关消息</font>，再将秒杀成功的消息发送到相应用户。</li><li>用户收到秒杀成功的通知。</li></ol><h4 id="顺序消息"><a class="anchor" href="#顺序消息">#</a> 顺序消息</h4><blockquote><p>详细请见 “消息类型 - 顺序消息” 小节</p></blockquote><p>顺序消息是 RocketMQ 提供的<strong>一种对消息发送、消费顺序有严格要求的消息</strong>。</p><h4 id="分布式模缓存同步"><a class="anchor" href="#分布式模缓存同步">#</a> 分布式模缓存同步</h4><p>双十一大促时，各个分会场会有琳琅满目的商品，每件商品的价格都会实时变化。使用缓存技术也无法满足对商品价格的访问需求，缓存服务器网卡满载。访问较多次商品价格查询影响会场页面的打开速度。</p><p>此时需要提供一种广播机制，一条消息本来只可以被集群的一台机器消费，如果使用 RocketMQ 的<strong>广播消费模式</strong>，那么<font color="red">这条消息会被所有节点消费一次，相当于把价格信息同步到需要的每台机器上，取代缓存的作用</font>。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/TB1ki7KXgMPMeJjy1XdXXasrXXa-1530-1140.png" alt="img"></p><h4 id="分布式定时延时调度"><a class="anchor" href="#分布式定时延时调度">#</a> 分布式定时 / 延时调度</h4><blockquote><p>详细请见 “消息类型 - 定时消息” 小节</p></blockquote><p>RocketMQ 提供<strong>精确度到秒级的分布式定时消息能力</strong>（5.0 架构后），可广泛应用于<font color="red">订单超时中心处理、分布式延时调度系统</font>等场景。</p><h3 id="消息类型"><a class="anchor" href="#消息类型">#</a> 消息类型</h3><h4 id="普通消息"><a class="anchor" href="#普通消息">#</a> 普通消息</h4><p>普通消息一般应用于微服务解耦、事件驱动、数据集成等场景，这些场景大多数要求数据传输通道具有可靠的传输能力，且<font color="red">对消息的处理时机、处理顺序没有特别要求</font>。</p><p>以在线的电商交易场景为例，上游订单系统将用户下单支付这一业务事件封装成独立的普通消息并发送至 RocketMQ 服务端，下游按需从服务端订阅消息，并按照本地消费逻辑处理下游任务。<font color="red">每个消息之间都是相互独立的，且不需要产生关联</font>。</p><p>另外还有日志系统，以离线的日志收集场景为例，通过埋点组件收集前端应用的相关操作日志，并转发到 RocketMQ 。</p><p><font color="gree">普通消息的生命周期</font>：</p><p><img data-src="https://rocketmq.apache.org/zh/assets/images/lifecyclefornormal-e8a2a7e42a0722f681eb129b51e1bd66.png" alt="img"></p><ul><li><font color="cornflowerblue">初始化（Initialized）</font>：消息被 Producer 构建并完成初始化，<font color="red">待发送到服务端</font>的状态。</li><li><font color="cornflowerblue">待消费（Ready）</font>：<font color="red">消息被发送到服务端</font>，对 Consumer 可见，等待消费的状态。</li><li><font color="cornflowerblue">消费中（Inflight）</font>：<font color="red">消息被 Consumer 获取</font>，并按照其本地的业务逻辑进行处理的过程。此时服务端会等待 Consumer 完成消费并提交消费结果，如果一定时间后没有收到 Consumer 的响应，RocketMQ 会对消息进行<font color="red">重试</font>处理。</li><li><font color="cornflowerblue">消费提交（Acked）</font>：Consumer 完成消费处理，并向服务端提交消费结果，服务端标记当前消息已经被处理（包括消费成功和失败）。RocketMQ 默认支持保留所有消息，此时消息数据并不会立即被删除，<font color="red">只是逻辑标记已消费</font>。消息在保存时间到期或存储空间不足被删除前，<font color="red">Consumer 仍然可以回溯消息，重新消费</font>。</li><li><font color="cornflowerblue">消息删除（Deleted）</font>：RocketMQ 按照消息保存机制滚动清理最早的消息数据，<font color="red">将消息从物理文件中删除</font>。</li></ul><h4 id="定时消息"><a class="anchor" href="#定时消息">#</a> 定时消息</h4><p>在分布式定时调度触发、任务超时处理等场景，需要实现精准、可靠的定时事件触发。使用 RocketMQ 的定时消息可以<font color="red">简化定时调度任务的开发逻辑</font>，实现高性能、可扩展、高可靠的定时触发能力。</p><p><strong><font color="red">定时消息仅支持在 MessageType 为 Delay 的 Topic 内使用</font></strong>，即定时消息只能发送至类型为定时消息的 Topic 中，发送的消息的类型必须和 Topic 的类型一致。</p><p>基于定时消息的超时任务处理具备如下优势：</p><ul><li><font color="red">定时精度高、开发门槛低</font>：消息定时时间不存在阶梯间隔，可以轻松实现任意精度事件触发，无需业务去重。</li><li><font color="red">高性能、可扩展</font>：传统的定时实现方案较为复杂，需要进行数据库扫描，容易遇到性能瓶颈的问题，RocketMQ 可以基于定时消息特性完成事件驱动，实现百万级消息 TPS 能力。</li></ul><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/p433720.png" alt="img"></p><p><font color="gree">定时消息的生命周期</font>：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/lifecyclefordelay-2ce8278df69cd026dd11ffd27ab09a17.png" alt="img"></p><ul><li><font color="cornflowerblue">初始化（Initialized）</font>：消息被生产者构建并完成初始化，待发送到服务端的状态。</li><li><strong><font color="cornflowerblue">定时中（In timing）</font></strong>：消息被发送到服务端，和普通消息不同的是，<strong>服务端不会直接构建消息索引，而是会将定时消息单独存储在定时存储系统中，等待定时时刻到达</strong>。</li><li><font color="cornflowerblue">待消费（Ready）</font>：<strong>定时时刻到达后，服务端将定时消息重新写入普通存储引擎，对下游消费者可见</strong>，等待消费者消费的状态。</li><li><font color="cornflowerblue">消费中（Inflight）</font>：消息被消费者获取，并按照消费者本地的业务逻辑进行处理的过程。此时服务端会等待消费者完成消费并提交消费结果，如果一定时间后没有收到消费者的响应，RocketMQ 会对消息进行重试处理。</li><li><font color="cornflowerblue">消费提交（Acked）</font>：消费者完成消费处理，并向服务端提交消费结果，服务端标记当前消息已经被处理（包括消费成功和失败）。RocketMQ 默认支持保留所有消息，此时消息数据并不会立即被删除，只是逻辑标记已消费。消息在保存时间到期或存储空间不足被删除前，消费者仍然可以回溯消息重新消费。</li><li><font color="cornflowerblue">消息删除（Deleted）</font>：Apache RocketMQ 按照消息保存机制滚动清理最早的消息数据，将消息从物理文件中删除。</li></ul><p>定时消息的实现逻辑：先经过定时存储等待触发，<font color="red">定时时间到达后才会被投递给 Consumer</font>。因此，如果将大量定时消息的定时时间设置为同一时刻，则到达该时刻后会有大量消息同时需要被处理，会造成系统压力过大，导致消息分发延迟，影响定时精度。</p><h4 id="顺序消息-2"><a class="anchor" href="#顺序消息-2">#</a> 顺序消息</h4><p>顺序消息是 RocketMQ 提供的<strong>一种对消息发送、消费顺序有严格要求的消息</strong>。<strong><font color="red">顺序消息仅支持在 MessageType 为 FIFO 的 Topic 内使用</font></strong>，对于一个指定的 Topic，消息严格按照<font color="red">先进先出（FIFO）</font>的原则进行消息发布和消费，即先发布的消息先消费，后发布的消息后消费。</p><p>顺序消息分为分区顺序消息和全局顺序消息。</p><ul><li><strong><font color="cornflowerblue">分区顺序消息</font></strong>：对于指定的一个 Topic，所有消息<font color="red">根据 Sharding Key 进行区块分区</font>，同一个 Partition 内的消息按照严格的先进先出（FIFO）原则进行发布和消费。<strong><font color="red">同一 Partition 内的消息保证顺序，不同 Partition 之间的消息顺序不做要求</font></strong>。<ul><li>适用场景：适用于性能要求高，以 Sharding Key 作为分区字段，在同一个区块中严格地按照先进先出（FIFO）原则进行消息发布和消费的场景。</li><li>示例<ul><li>用户注册需要<font color="red">发送验证码</font>，以用户 ID 作为 Sharding Key，那么同一个用户发送的消息都会按照发布的先后顺序来消费。</li><li>电商的<font color="red">订单创建</font>，以订单 ID 作为 Sharding Key，那么同一个订单相关的创建订单消息、订单支付消息、订单退款消息、订单物流消息都会按照发布的先后顺序来消费。</li></ul></li></ul></li><li><strong><font color="cornflowerblue">全局顺序消息</font></strong>：<strong><font color="red">对于指定的一个 Topic，所有消息按照严格的先入先出（FIFO）的顺序来发布和消费</font></strong>。<ul><li>适用场景：适用于性能要求不高，所有的消息严格按照 FIFO 原则来发布和消费的场景。</li><li>示例：在证券处理中，以人民币兑换美元为 Topic，在价格相同的情况下，先出价者优先处理，则可以按照 FIFO 的方式发布和消费全局顺序消息。</li></ul></li></ul><p><strong><font color="red">全局顺序消息实际上是一种特殊的分区顺序消息，即 Topic 中只有一个分区</font></strong>，因此全局顺序和分区顺序的实现原理相同。因为分区顺序消息有多个分区，所以<font color="red">分区顺序消息比全局顺序消息的并发度和性能更高</font>。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/p326576.png" alt="img"></p><p>和普通消息发送相比，<font color="red">顺序消息发送必须要设置消息组</font>（推荐实现 MessageQueueSelector 的方式，见下文）。要保证消息的顺序性需要单一 Producer 串行发送。</p><p>单线程使用 MessageListenerConcurrently 可以顺序消费，多线程环境下使用 MessageListenerOrderly 才能顺序消费。</p><h4 id="事务消息"><a class="anchor" href="#事务消息">#</a> 事务消息</h4><h3 id="基础概念"><a class="anchor" href="#基础概念">#</a> 基础概念</h3><blockquote><p>RocketMQ 消息模型：<strong>在一个 <code>Topic</code> 中配置多个 <code>Queue</code> ，并且每个 <code>Queue</code> 维护每个 <code>Consumer组</code> 的 <code>offset</code> （消费位置）</strong> 实现了 <strong>主题模式 / 发布订阅模式</strong>。</p></blockquote><h4 id="topic-主题"><a class="anchor" href="#topic-主题">#</a> Topic 主题</h4><p><strong>Topic 是消息传输和存储的顶层容器，用于标识同一类业务逻辑的消息</strong>。Topic 的作用主要如下：</p><ul><li><strong>定义数据的分类隔离</strong>：在 Apache RocketMQ 的方案设计中，<font color="red">建议将不同业务类型的数据拆分到不同的 Topic 中管理，实现存储的隔离性和订阅隔离性</font>。</li><li><strong>定义数据的身份和权限</strong>：Apache RocketMQ 的消息本身是匿名无身份的<font color="red">，同一分类的消息使用相同的 Topic 来做身份识别和权限管理</font>。</li></ul><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/archifortopic-ef512066703a22865613ea9216c4c300.png" alt="img"></p><h4 id="queue-队列"><a class="anchor" href="#queue-队列">#</a> Queue 队列</h4><blockquote><p>类似于 **Kafka 中的 Partition（分区）** 这一概念？</p></blockquote><p><strong>Queue 是消息存储和传输的实际容器，也是消息的最小存储单元</strong>。<font color="red">每个 Topic 都是由多个 Queue 组成的</font>，以此实现 Queue 数量的水平拆分和 Queue 内部的流式存储。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/archiforqueue-dd6788b33bf2fc96b4a1dab83a1b0d71.png" alt="img"></p><h4 id="message-消息"><a class="anchor" href="#message-消息">#</a> Message 消息</h4><p><strong>Message 是最小数据传输单元</strong>。Producer 将业务数据的负载和拓展属性包装成 Message 发送到 Apache RocketMQ 服务端，服务端按照相关语义将 Message 投递到消费端进行消费。</p><h4 id="producer-生产者"><a class="anchor" href="#producer-生产者">#</a> Producer 生产者</h4><p>发布消息的角色。<strong>Producer 通过 MQ 的负载均衡模块选择相应的 Broker 集群队列进行消息投递，投递的过程支持快速失败和重试</strong>。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/archiforproducer-ebb8ff832f6e857cbebc2c17c2044a3b.png" alt="img"></p><h4 id="consumer-消费者"><a class="anchor" href="#consumer-消费者">#</a> Consumer 消费者</h4><p>消息消费的角色。</p><ul><li>支持以 ** 推（push）、拉（pull）** 两种模式对消息进行消费。</li><li>同时也支持<strong>集群方式</strong>和<strong>广播方式</strong>的消费。</li><li>提供<strong>实时消息订阅机制</strong>，可以满足大多数用户的需求。</li></ul><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/archiforconsumer-24914573add839fdf2ba2cbc0fcab7c4.png" alt="img"></p><h4 id="broker-代理服务器"><a class="anchor" href="#broker-代理服务器">#</a> <mark>Broker 代理服务器</mark></h4><p><strong>Broker 负责消息的存储、投递和查询，并保证服务高可用</strong>。其实 Broker 就是 MQ 服务器，Producer 生产消息到 Broker，Consumer 从 Broker 拉取并消费消息。</p><p><font color="gree">Broker、Topic、Queue 的关系</font>：</p><ul><li>一个 Topic 中存在多个 Queue</li><li>一个 Topic 分布在多个 Broker 上，而一个 Broker 可以配置多个 Topic，即 <font color="red">Topic 和 Broker 之间是多对多的关系</font></li></ul><p>如果某个 Topic 消息量很大，应该给它多配置几个 Queue (提高并发能力)，并且<strong>尽量多分布在不同 Broker 上，以减轻某个 Broker 的压力</strong>。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/16ef38687488a5a4.jpg" alt="img"></p><p>Broker 集群遵从 <strong>Master-Slave 架构</strong> ：</p><ul><li>Broker 分为 Master 与 Slave</li><li>一个 Master 可以对应多个 Slave，但是一个 Slave 只能对应一个 Master</li><li>Master 与 Slave 的对应关系通过指定相同的 BrokerName，不同的 BrokerId 来定义，<font color="red">BrokerId 为 0 表示 Master</font>，非 0 表示 Slave</li><li>Master 也可以部署多个</li></ul><h4 id="nameserver-名字服务器"><a class="anchor" href="#nameserver-名字服务器">#</a> <mark>NameServer 名字服务器</mark></h4><blockquote><p>为 Broker 和 Producer、Consumer 解耦，类似于 SpringCloud 中的 Eureka / Nacos</p></blockquote><p>NameServer 是一个简单的 <strong>Broker 路由注册中心</strong>，支持 Broker 的注册与发现，主要提供两个功能：</p><ul><li><strong>Broker 管理</strong>：<ul><li><font color="red">NameServer 接受并保存 Broker 所提交的注册信息，作为 Broker 路由表的基本数据</font></li><li><font color="red">提供心跳检测机制，检查 Broker 是否还存活</font></li></ul></li><li><strong>路由信息管理</strong>：<ul><li>每个 NameServer 保存了关于 Broker 集群的整个路由信息、用于客户端查询的 Queue 信息</li><li><font color="red">Producer 和 Consumer 通过 NameServer 中的 Broker 路由表就可以知道整个 Broker 集群的路由信息，从而和对应的 Broker 进行消息的投递和消费</font>（Producer 和 Consumer 定期会向 NameServer 查询相关的 Broker 信息）</li></ul></li></ul><p><font color="red">NameServer 通常会有多个实例部署，各实例间相互不进行信息通讯</font>。<font color="red">Broker 向每一台 NameServer 注册自己的路由信息</font>，所以每一个 NameServer 实例上面都保存一份完整的路由信息。当某个 NameServer 因某种原因下线了，客户端仍然可以向其它 NameServer 获取路由信息。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/16ef386c6d1e8bdb.jpg" alt="img"></p><center>Producer、Consumer、Broker、NameServer</center><blockquote><p>上图中的四个角色实际上都需要做集群。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/16ef386fa3be1e53.jpg" alt="img"></p><center>官方架构图</center><ul><li><strong><code>Broker</code> 做了集群，并且还进行了主从部署</strong>：由于消息分布在各个 <code>Broker</code> 上，一旦某个 <code>Broker</code> 宕机，则该 <code>Broker</code> 上的消息读写都会受到影响。所以 <code>RocketMQ</code> 提供了 <code>master/slave</code> 的结构， <code>salve</code> 定时从 <code>master</code> 同步数据 (同步刷盘或者异步刷盘)，<strong>如果 <code>master</code> 宕机，则 <code>slave</code> 提供消费服务，但是不能写入消息</strong> (后面我还会提到哦)。</li><li><strong>为了保证高可用 <code>HA</code> ， <code>NameServer</code> 也做了集群部署，但它是去中心化的</strong>：意味着 <code>NameServer</code> 没有 master 节点，在 <code>RocketMQ</code> 中是通过 <strong>单个 Broker 和所有 NameServer 保持长连接</strong> ，并且 <code>Broker</code> 会定期向所有 <code>Nameserver</code> 发送心跳，其中包含了自身的 <code>Topic</code> 配置信息，这个步骤就对应图中的 <code>Routing Info</code> 。</li><li>在 <code>Producer</code> 需要向 <code>Broker</code> 发送消息的时候，<strong>需要先从 <code>NameServer</code> 获取关于 <code>Broker</code> 的路由信息</strong>，然后通过 <strong>轮询</strong> 的方式向每个 Queue 中生产数据，以达到<strong>负载均衡</strong>的效果。</li><li><code>Comsumer</code> 通过 <code>NameServer</code> 获取所有 <code>Broker</code> 的路由信息后，向 <code>Broker</code> 发送 <code>Pull</code> 请求来获取消息数据。 <code>Consumer</code> 可以以两种模式启动 —— <strong>广播（Broadcast）和集群（Cluster）</strong>：<ul><li>广播模式下，一条消息会发送给 <strong>同一个消费组中的所有消费者</strong></li><li>集群模式下消息只会发送给一个消费者</li></ul></li></ul></blockquote><h4 id="部署模型小结"><a class="anchor" href="#部署模型小结">#</a> 部署模型小结</h4><ul><li><p>每个 Broker 与 NameServer 集群中的所有节点建立长连接，定时将 Topic 信息注册到所有 NameServer。</p></li><li><p>Producer 与 NameServer 集群中的其中一个节点建立长连接，定期从 NameServer 获取 Topic/Broker 路由信息。并向提供 Topic 服务的 Broker Master 建立长连接，且定时向 Broker Master 发送心跳。Producer 完全无状态。</p></li><li><p>Consumer 与 NameServer 集群中的其中一个节点建立长连接，定期从 NameServer 获取 Topic/Broker 路由信息，并向提供 Topic 服务的 Broker Master、Broker Slave 建立长连接，且定时向 Broker Master、Broker Slave 发送心跳。</p><blockquote><p><font color="red">Consumer 既可以从 Broker Master 订阅消息，也可以从 Broker Slave 订阅消息</font>。</p></blockquote></li></ul><h3 id="工作原理"><a class="anchor" href="#工作原理">#</a> 工作原理</h3><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/p68921.png" alt="img"></p><h4 id="1-启动-nameserver"><a class="anchor" href="#1-启动-nameserver">#</a> 1、启动 NameServer</h4><p>启动 NameServer。NameServer 启动后监听端口，等待 Broker、Producer、Consumer 连接，相当于一个<font color="red">路由控制中心</font>。</p><h4 id="2-启动-broker"><a class="anchor" href="#2-启动-broker">#</a> 2、启动 Broker</h4><p>启动 Broker。<font color="red">与所有 NameServer 保持长连接，定时发送心跳包</font>（包含当前 Broker 信息以及存储的所有 Topic 信息）。注册成功后，NameServer 集群中就有 Topic 跟 Broker 的映射关系。</p><h4 id="3-创建-topic"><a class="anchor" href="#3-创建-topic">#</a> 3、创建 Topic</h4><p><font color="red">创建 Topic 时需要指定该 Topic 要存储在哪些 Broker 上</font>，也可以在发送消息时自动创建 Topic。</p><h4 id="4-producer-发送消息"><a class="anchor" href="#4-producer-发送消息">#</a> 4、Producer 发送消息</h4><p>Producer 发送消息。启动时先跟 NameServer 集群中的其中一台建立长连接，并从 NameServer 中查询当前发送的 Topic 存在于哪些 Broker 上，轮询从对应 Broker 上的 Queue 列表中选择一个 Queue，然后与该 Queue 所在的 Broker 建立长连接，从而向 Broker 发消息。</p><h4 id="5-consumer-接收消息"><a class="anchor" href="#5-consumer-接收消息">#</a> 5、Consumer 接收消息</h4><p>Consumer 接受消息。跟其中一台 NameServer 建立长连接，获取当前订阅 Topic 存在于哪些 Broker 上，然后直接跟 Broker 建立连接通道，然后开始消费消息。</p><h3 id="如何正确发送消息"><a class="anchor" href="#如何正确发送消息">#</a> 如何正确发送消息</h3><h4 id="不建议单一进程创建大量-producer"><a class="anchor" href="#不建议单一进程创建大量-producer">#</a> 不建议单一进程创建大量 Producer</h4><p>Apache RocketMQ 的 Producer 和 Topic 是多对多的关系，支持同一个 Producer 向多个 Topic 发送消息。<font color="red">对于 Producer 的创建和初始化，建议遵循够用即可、最大化复用原则</font>，如果有需要发送消息到多个 Topic 的场景，无需为每个 Topic 都创建一个 Producer。</p><h4 id="不建议频繁创建和销毁-producer"><a class="anchor" href="#不建议频繁创建和销毁-producer">#</a> 不建议频繁创建和销毁 Producer</h4><p>Apache RocketMQ 的 <font color="red">Producer 是可以重复利用的底层资源</font>，类似数据库的连接池。因此不需要在每次发送消息时动态创建 Producer，且在发送结束后销毁 Producer。这样频繁的创建销毁会在服务端产生大量短连接请求，严重影响系统性能。</p><p>正确示例：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">Producer</span> p <span class="token operator">=</span> <span class="token class-name">ProducerBuilder</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token class-name">Message</span> m<span class="token operator">=</span> <span class="token class-name">MessageBuilder</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    p<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>p<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h3 id="consumer-分类"><a class="anchor" href="#consumer-分类">#</a> Consumer 分类</h3><ul><li>PushConsumer</li><li>SimpleConsumer</li><li>PullConsumer</li></ul><h3 id="producer-和-consumer-分组"><a class="anchor" href="#producer-和-consumer-分组">#</a> Producer 和 Consumer 分组</h3><h4 id="producer-分组"><a class="anchor" href="#producer-分组">#</a> Producer 分组</h4><p>RocketMQ 服务端 5.x 版本开始，<strong>Producer 是匿名的，无需管理 Producer 分组（ProducerGroup）</strong>。</p><p>对于历史版本服务端 3.x 和 4.x 版本，已经使用的 ProducerGroup 可以废弃无需再设置，且不会对当前业务产生影响。</p><h4 id="consumer-分组"><a class="anchor" href="#consumer-分组">#</a> Consumer 分组</h4><p><strong>Consumer 分组是多个消费行为一致的 Consumer 的负载均衡分组</strong>。Consumer 分组不是具体实体而是一个逻辑资源。通过 Consumer 分组实现消费性能的水平扩展以及高可用容灾。</p><p>Consumer 分组中的订阅关系、投递顺序性、消费重试策略是一致的。</p><ul><li>订阅关系：Apache RocketMQ 以 Consumer 分组的粒度管理订阅关系，实现订阅关系的管理和追溯。</li><li>投递顺序性：Apache RocketMQ 的服务端将消息投递给 Consumer 消费时，支持顺序投递和并发投递，投递方式在 Consumer 分组中统一配置。</li><li>消费重试策略：Consumer 消费消息失败时的重试策略，包括重试次数、死信队列设置等。</li></ul><p>RocketMQ 服务端 5.x 版本：上述 Consumer 的消费行为从关联的 Consumer 分组中统一获取，因此同一分组内所有 Consumer 的消费行为必然是一致的，客户端无需关注。</p><p>RocketMQ 服务端 3.x/4.x 历史版本：上述消费逻辑由消费者客户端接口定义，因此，您需要自己在消费者客户端设置时保证同一分组下的消费者的消费行为一致。[来自官方网站]</p><h3 id="如何解决顺序消费-重复消费"><a class="anchor" href="#如何解决顺序消费-重复消费">#</a> 如何解决顺序消费、重复消费？</h3><p>其实 <code>RocketMQ</code> 的架构基本和 <code>Kafka</code> 类似，只不过：</p><ul><li>RocketMQ 的注册中心是 <code>NameServer</code> ，而 Kafka 的是 <code>Zookeeper</code></li><li>RocketMQ 的 **Queue（队列）** 相当于是 Kafka 的 <strong>Partition（分区）</strong></li></ul><h4 id="顺序消费"><a class="anchor" href="#顺序消费">#</a> 顺序消费</h4><blockquote><p>可以参考 “消息类型 - 顺序消息” 小节</p></blockquote><p><strong><code>RocketMQ</code> 在 Topic 上是无序的、它只有在 Queue 层面才保证有序</strong>：</p><ul><li><font color="cornflowerblue">普通顺序（分区顺序消息）</font>：对于一个 Topic，同一 Queue 内的消息保证顺序，不同 Queue 之间的消息顺序不做要求。</li><li><font color="cornflowerblue">严格顺序（全局顺序消息）</font>：对于指定的一个 Topic，所有消息按照严格的先入先出（FIFO）的顺序来发布和消费。</li></ul><p>严格顺序的代价巨大，而 MQ 一般能容忍短暂的乱序，所以<font color="red">推荐使用普通顺序模式！</font></p><hr><p>在 Producer 生产消息的时候，会轮询同一 Topic 的不同 Queue 来发送消息。那么如果此时我有几个消息分别是同一个订单的创建、支付、发货，<font color="red">在轮询的策略下这<strong>三个消息会被发送到不同的 Queue</strong>，那么此时就无法使用  <code>RocketMQ</code> 的队列有序特性来保证消息有序性了</font>。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/16ef3874585e096e.jpg" alt="img"></p><p>解决方法很简单，<strong>只需要将同一语义下的消息放入同一个队列</strong>（比如这里是同一个订单)，那我们就可以使用 <strong><font color="red">Hash 取模法</font></strong> 来保证同一个订单在同一个队列中就行了。</p><p>RocketMQ 实现了两种<font color="gree"> Queue 选择算法</font>：</p><ul><li><p><font color="cornflowerblue">轮询算法</font></p><ul><li><font color="red">向消息指定的 Topic 所在 Queue 中依次发送消息</font>，保证消息均匀分布</li><li>是 RocketMQ <font color="red">默认</font>队列选择算法</li></ul></li><li><p><font color="cornflowerblue">最小投递延迟算法</font></p><ul><li><p>每次消息投递的时候统计消息投递的延迟，<font color="red">优先选择消息延时小的 Queue</font>，导致消息分布不均匀，按照如下设置即可。</p></li><li><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre>producer<span class="token punctuation">.</span><span class="token function">setSendLatencyFaultEnable</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure></li></ul></li><li><p><font color="cornflowerblue">继承 <code>MessageQueueSelector</code> 实现自定义的选择算法</font></p><ul><li><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">SendResult</span> sendResult <span class="token operator">=</span> producer<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>msg<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">MessageQueueSelector</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token annotation punctuation">@Override</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">MessageQueue</span> <span class="token function">select</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">MessageQueue</span><span class="token punctuation">></span></span> mqs<span class="token punctuation">,</span> <span class="token class-name">Message</span> msg<span class="token punctuation">,</span> <span class="token class-name">Object</span> arg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token comment">// 从 mqs 中选择一个队列，可以根据 msg 特点选择</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure></li></ul></li></ul><h4 id="特殊情况"><a class="anchor" href="#特殊情况">#</a> 特殊情况</h4><h5 id="发送异常"><a class="anchor" href="#发送异常">#</a> 发送异常</h5><p>选择 Queue 后会与 Broker 建立连接，通过网络请求将消息发送到 Broker 上，如果 Broker 挂了或者网络波动发送消息超时，此时 RocketMQ 会进行重试。</p><p>重新选择其他 Broker 中的 Queue 进行发送，默认重试两次，可以手动设置。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre>producer<span class="token punctuation">.</span><span class="token function">setRetryTimesWhenSendFailed</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h5 id="消息过大"><a class="anchor" href="#消息过大">#</a> 消息过大</h5><p>消息超过 4k 时 RocketMQ 会将消息压缩后再发送到 Broker 上，减少网络资源的占用。</p><h4 id="重复消费"><a class="anchor" href="#重复消费">#</a> 重复消费</h4><p>需求：有一个订单的处理积分的系统 FrancisQ，每当来一个消息的时候它就负责为创建这个订单的用户的积分加上相应的数值。可是有一次，消息队列发送给订单系统 FrancisQ 的订单信息，其要求是给 FrancisQ 的积分加上 500。但是积分系统在收到 FrancisQ 的订单信息处理完成之后返回给消息队列处理成功的信息的时候出现了网络波动 (当然还有很多种情况，比如 Broker 意外重启等等)，这条回应没有发送成功。那么，消息队列没收到积分系统的回应会不会尝试重发这个消息？问题就来了，我再发这个消息，万一它又给 FrancisQ 的账户加上 500 积分怎么办呢？</p><hr><p>解决方法：<strong>让 Consumer 实现幂等校验</strong>！即<font color="red">对同一个消息的处理结果，执行多少次都不变</font>。</p><blockquote><p>幂等操作的特点：其执行任意多次所产生的影响，均与执行一次的影响相同。</p></blockquote><p>那么如何给业务实现幂等呢？这个还是需要结合具体的业务的。</p><ul><li>可以使用 **<font color="cornflowerblue">写入 <code>Redis</code> </font>** 来保证，因为 <code>Redis</code> 的 <code>key</code> 和 <code>value</code> 就是天然支持幂等的。</li><li>可以使用 **<font color="cornflowerblue">数据库插入法</font>**，基于数据库的<font color="red">唯一键</font>来保证重复数据不会被插入多条。</li></ul><p>需要根据特定场景使用特定的解决方案，你要知道你的消息消费是否是完全不可重复消费还是可以忍受重复消费的，然后再选择强校验和弱校验的方式。毕竟在 CS 领域还是很少有技术银弹的说法。</p><hr><p>而在互联网领域，幂等不仅仅适用于 **<font color="red">消息队列的重复消费问题</font><strong>，也同样适用于在其他场景中来解决</strong><font color="red">重复请求或者重复调用的问题</font>**：</p><ul><li>比如将 HTTP 服务设计成幂等的<font color="red">解决前端或者 APP 重复提交表单数据的问题</font></li><li>可以将一个微服务设计成幂等的，解决 <code>RPC</code> 框架<font color="red">自动重试导致的重复调用问题</font>。</li></ul><h3 id="如何实现分布式事务"><a class="anchor" href="#如何实现分布式事务">#</a> 如何实现分布式事务？</h3><p>事务指的是要么都执行，要么都不执行。在分布式架构中，很多服务是部署在不同系统之间的，那么如何实现分布式事务呢？常见的分布式事务实现有：</p><ul><li><font color="cornflowerblue">2PC（两阶段提交）</font>：优点是简单，缺点是同步阻塞、中心化问题、数据不一致、太过保守...</li><li><font color="cornflowerblue">TCC（Try Confirm/Cancel）</font>：也是 2PC 的一种。</li><li><font color="cornflowerblue">事务消息（half 半消息机制）</font>：RocketMQ 支持这种类型的消息。</li></ul><p>这三种实现都有特定的使用场景和各自的局限，并不完美。</p><hr><p>RocketMQ 中使用的是<strong>事务消息（half 半消息机制） + 事务反查机制</strong>来解决分布式事务问题的，可以对照着图进行理解。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/16ef38798d7a987f.png" alt="img"></p><p>在第 1 步发送的 half 消息，它的意思是<font color="red">在事务提交之前，对于 Consumer 来说这个消息是不可见的</font>。</p><blockquote><p>那么，如何做到写入消息但是对 Consumer 不可见呢？RocketMQ 事务消息的做法是：</p><ol><li>如果消息是 half 消息，将备份原消息的 Topic 与消息消费队列</li><li>然后<strong>改变 Topic 为 RMQ_SYS_TRANS_HALF_TOPIC</strong>，由于 Consumer 未订阅该 Topic，故无法消费 half 类型的消息。</li><li>然后 <strong>RocketMQ 会开启一个定时任务，从该 Topic 中拉取消息进行消费</strong>，根据 Producer 组获取一个服务提供者，发送回查事务状态请求，根据事务状态来决定是提交或回滚消息。</li></ol></blockquote><p>如果没有从第 5 步开始的<font color="red">事务反查机制</font>，如果出现网路波动第 4 步没有发送成功，这样就会产生 MQ 不知道是不是需要给 Consumer 消费的问题。在 <code>RocketMQ</code> 中就是使用的上述的事务反查来解决的，而在 <code>Kafka</code> 中通常是直接抛出一个异常让用户来自行解决。</p><p>你还需要注意的是， <code>MQ Server</code> 指向系统 B 的操作已经和系统 A 不相关了，也就是说在消息队列中的分布式事务是：<strong><font color="red">本地事务和存储消息到消息队列才是同一个事务</font></strong>。这样也就产生了事务的<font color="red">最终一致性</font>，因为整个过程是异步的，<strong><font color="red">每个系统只要保证它自己那一部分的事务就行了</font></strong>。</p><h3 id="如何解决消息堆积问题"><a class="anchor" href="#如何解决消息堆积问题">#</a> 如何解决消息堆积问题？</h3><p>在上面我们提到了消息队列的一个很重要的功能 ——<strong> 削峰</strong>。那么如果这个峰值太大了导致消息堆积在队列中怎么办呢？</p><p>其实这个问题可以将它广义化，因为产生消息堆积的根源其实就只有两个：</p><ul><li><p>Producer 生产太快：<strong>限流降级</strong>，或者<strong>增加 Consumer 实例</strong>以水平扩展消费能力（<font color="red">同时还需要增加每个 Topic 的 Queue 数量</font>）。</p><blockquote><p>别忘了在 <code>RocketMQ</code> 中，<strong>一个 Queue 只会被一个 Consumer 消费</strong> ，如果你仅仅是增加 Consumer 实例就会出现我一开始给你画的架构图的那种情况：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/16ef387d939ab66d.jpg" alt="img"></p></blockquote></li><li><p>Consumer 消费太慢：先检查 <strong>Consumer 是否出现了大量的消费错误</strong>，或者打印日志查看是否有哪一个线程卡死，导致了锁资源不释放等问题。</p></li></ul><h3 id="回溯消费"><a class="anchor" href="#回溯消费">#</a> 回溯消费</h3><p>回溯消费是指 <code>Consumer</code> 已经消费成功的消息，由于业务上需求需要重新消费。在 <code>RocketMQ</code> 中， <code>Broker</code> 在向 <code>Consumer</code> 投递成功消息后，<font color="red">消息仍然需要保留</font>。并且重新消费一般是按照时间维度，例如由于 <code>Consumer</code> 系统故障，恢复后需要重新消费 1 小时前的数据，那么 <code>Broker</code> 要提供一种机制，可以按照时间维度来回退消费进度。 <code>RocketMQ</code> 支持按照时间回溯消费，时间维度精确到毫秒。</p><h3 id="如何保证高性能读写"><a class="anchor" href="#如何保证高性能读写">#</a> 如何保证高性能读写？</h3><blockquote><p>可参考 “Java IO - IO 模型 - NIO” 小节，略了。</p></blockquote><ul><li>传统 IO 方式：即 <code>read + write</code> ，整个过程会发生 4 次上下文切换和 4 次数据的拷贝，这在高并发场景下会严重影响读写性能，故引入了零拷贝技术。<ul><li>用户调用 read () 方法，开始读取数据，此时发生一次上下文从用户态到内核态的切换，也就是图示的切换 1</li><li>将磁盘数据通过 DMA 拷贝到内核缓存区</li><li>将内核缓存区的数据拷贝到用户缓冲区，这样用户，也就是我们写的代码就能拿到文件的数据</li><li>read () 方法返回，此时就会从内核态切换到用户态，也就是图示的切换 2</li><li>当我们拿到数据之后，就可以调用 write () 方法，此时上下文会从用户态切换到内核态，即图示切换 3</li><li>CPU 将用户缓冲区的数据拷贝到 Socket 缓冲区</li><li>将 Socket 缓冲区数据拷贝至网卡</li><li>write () 方法返回，上下文重新从内核态切换到用户态，即图示切换 4</li></ul></li><li>零拷贝技术<ul><li><code>mmap</code> ：</li><li><code>sendfile</code> ：</li></ul></li></ul><h3 id="刷盘机制"><a class="anchor" href="#刷盘机制">#</a> 刷盘机制</h3><h4 id="同步刷盘-异步刷盘"><a class="anchor" href="#同步刷盘-异步刷盘">#</a> 同步刷盘、异步刷盘</h4><blockquote><p>在单个节点层面</p></blockquote><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/16ef387fba311cda-20230814005009889.jpg" alt="img"></p><p><font color="cornflowerblue">同步刷盘</font>：<strong><font color="red">需要等待一个刷盘成功的 <code>ACK</code> </font></strong>，对<font color="red">消息可靠性</font>来说是一种不错的保障，但是<font color="red">性能上会有较大影响</font>，一般适用于金融等特定业务场景。</p><p><font color="cornflowerblue">异步刷盘</font>：<strong><font color="red">开启一个线程去异步地执行刷盘操作</font></strong>。消息刷盘采用后台异步线程提交的方式进行，<font color="red">降低了读写延迟</font>，<font color="red">提高了 <code>MQ</code> 的性能和吞吐量</font>，一般适用于如发验证码等<font color="red">对于消息保证要求不太高</font>的业务场景。</p><p>一般地，<strong>异步刷盘只有在 <code>Broker</code> 意外宕机的时候会丢失部分数据</strong>，你可以设置 <code>Broker</code> 的参数 <code>FlushDiskType</code> 来调整你的刷盘策略 (ASYNC_FLUSH 或者 SYNC_FLUSH)。</p><h4 id="同步复制-异步复制"><a class="anchor" href="#同步复制-异步复制">#</a> 同步复制、异步复制</h4><blockquote><p>在 Broker 主从模式下，master 返回消息给客户端时是否需要同步 slave</p></blockquote><p><font color="cornflowerblue">同步复制</font>：也叫 “同步双写”，即<strong>只有消息同步双写到主从节点上时，才返回写入成功</strong>。</p><p><font color="cornflowerblue">异步复制</font>：<strong>消息写入主节点之后，直接返回写入成功</strong>。</p><p>然而，很多事情是没有完美的方案的，就比如我们进行消息写入的节点越多就更能保证消息的可靠性，但是随之的性能也会下降，所以需要程序员根据特定业务场景去选择适应的主从复制方案。</p><p><font color="red">异步复制不会像异步刷盘那样影响消息的可靠性</font>，因为两者是不同的概念，对于消息可靠性是通过不同的刷盘策略保证的，而像异步同步复制策略<font color="red">仅仅是影响到了可用性</font>。为什么呢？其主要原因是 <strong><code>RocketMQ</code> 是不支持自动主从切换的，当 master 节点挂掉之后，Producer 就不能再给这个 master 节点生产消息了</strong>。</p><p>比如这个时候采用异步复制的方式，在主节点还未发送完需要同步的消息的时候主节点挂掉了，这个时候从节点就少了一部分消息。但是此时生产者无法再给主节点生产消息了，<strong>消费者可以自动切换到从节点进行消费</strong> (仅仅是消费)，所以在主节点挂掉的时间只会产生主从结点短暂的消息不一致的情况，降低了可用性，而当主节点重启之后，从节点那部分未来得及复制的消息还会继续复制。</p><p>在单主从架构中，如果一个主节点挂掉了，那么也就意味着整个系统不能再生产了。那么这个可用性的问题能否解决呢？<strong>一个主从不行那就多个主从的呗</strong>，别忘了在我们最初的架构图中，每个 <code>Topic</code> 是分布在不同 <code>Broker</code> 中的。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/16ef38687488a5asadasfg4.jpg" alt="img"></p><p>但是这种复制方式同样也会带来一个问题，那就是无法保证 <strong>严格顺序</strong> 。在上文中我们提到了如何保证的消息顺序性是通过将一个语义的消息发送在同一个队列中，使用 <code>Topic</code> 下的队列来保证顺序性的。如果此时我们主节点 A 负责的是订单 A 的一系列语义消息，然后它挂了，这样其他节点是无法代替主节点 A 的，如果我们任意节点都可以存入任何消息，那就没有顺序性可言了。</p><p>而在 <code>RocketMQ</code> 中采用了 <code>Dledger</code> 解决这个问题。他要求在写入消息的时候，要求<strong>至少消息复制到半数以上的节点之后</strong>，才给客⼾端返回写⼊成功，并且它是⽀持通过选举来动态切换主节点的。这里我就不展开说明了，读者可以自己去了解。</p><blockquote><p>也不是说 <code>Dledger</code> 是个完美的方案，至少在 <code>Dledger</code> 选举过程中是无法提供服务的，而且他必须要使用三个节点或以上，如果多数节点同时挂掉他也是无法保证可用性的，而且要求消息复制半数以上节点的效率和直接异步复制还是有一定的差距的。</p></blockquote><h4 id="存储机制"><a class="anchor" href="#存储机制">#</a> 存储机制</h4><h3 id="动手发一条消息"><a class="anchor" href="#动手发一条消息">#</a> 动手发一条消息</h3><h4 id="1-启动-rocketmq"><a class="anchor" href="#1-启动-rocketmq">#</a> 1、启动 RocketMQ</h4><p><font color="gree">安装 NameServer</font></p><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">-p</span> <span class="token number">9876</span>:9876 <span class="token parameter variable">--name</span> rmqnamesrv foxiswho/rocketmq:server-4.5.1</pre></td></tr></table></figure><p><font color="gree">安装 Broker</font></p><p>1）新建配置目录。</p><p>如果是 Windows 需要替换为 Windows 的电脑路径，和 Linux 还是有点差异。</p><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">mkdir</span> <span class="token parameter variable">-p</span> <span class="token variable">$&#123;<span class="token environment constant">HOME</span>&#125;</span>/docker/software/rocketmq/conf</pre></td></tr></table></figure><p>2）新建配置文件 broker.conf。</p><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>brokerClusterName <span class="token operator">=</span> DefaultCluster</pre></td></tr><tr><td data-num="2"></td><td><pre>brokerName <span class="token operator">=</span> broker-a</pre></td></tr><tr><td data-num="3"></td><td><pre>brokerId <span class="token operator">=</span> <span class="token number">0</span></pre></td></tr><tr><td data-num="4"></td><td><pre>deleteWhen <span class="token operator">=</span> 04</pre></td></tr><tr><td data-num="5"></td><td><pre>fileReservedTime <span class="token operator">=</span> <span class="token number">48</span></pre></td></tr><tr><td data-num="6"></td><td><pre>brokerRole <span class="token operator">=</span> ASYNC_MASTER</pre></td></tr><tr><td data-num="7"></td><td><pre>flushDiskType <span class="token operator">=</span> ASYNC_FLUSH</pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token comment"># 此处为本地 ip, 如果部署服务器，需要填写服务器外网 ip</span></pre></td></tr><tr><td data-num="9"></td><td><pre>brokerIP1 <span class="token operator">=</span> xx.xx.xx.xx</pre></td></tr></table></figure><p>3）创建容器。</p><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token punctuation">\</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token parameter variable">-p</span> <span class="token number">10911</span>:10911 <span class="token punctuation">\</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token parameter variable">-p</span> <span class="token number">10909</span>:10909 <span class="token punctuation">\</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token parameter variable">--name</span> rmqbroker <span class="token punctuation">\</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token parameter variable">--link</span> rmqnamesrv:namesrv <span class="token punctuation">\</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token parameter variable">-v</span> <span class="token variable">$&#123;<span class="token environment constant">HOME</span>&#125;</span>/docker/software/rocketmq/conf/broker.conf:/etc/rocketmq/broker.conf <span class="token punctuation">\</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token parameter variable">-e</span> <span class="token string">"NAMESRV_ADDR=namesrv:9876"</span> <span class="token punctuation">\</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token parameter variable">-e</span> <span class="token string">"JAVA_OPTS=-Duser.home=/opt"</span> <span class="token punctuation">\</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token parameter variable">-e</span> <span class="token string">"JAVA_OPT_EXT=-server -Xms512m -Xmx512m"</span> <span class="token punctuation">\</span></pre></td></tr><tr><td data-num="10"></td><td><pre>foxiswho/rocketmq:broker-4.5.1</pre></td></tr></table></figure><p><font color="gree">安装 RocketMQ 控制台</font></p><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">docker</span> pull pangliang/rocketmq-console-ng</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token punctuation">\</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token parameter variable">--link</span> rmqnamesrv:namesrv <span class="token punctuation">\</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token parameter variable">-e</span> <span class="token string">"JAVA_OPTS=-Drocketmq.config.namesrvAddr=namesrv:9876 -Drocketmq.config.isVIPChannel=false"</span> <span class="token punctuation">\</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token parameter variable">--name</span> rmqconsole <span class="token punctuation">\</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token parameter variable">-p</span> <span class="token number">8088</span>:8080 <span class="token punctuation">\</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token parameter variable">-t</span> pangliang/rocketmq-console-ng</pre></td></tr></table></figure><p>运行成功，稍等几秒启动时间，浏览器输入 <code>localhost:8088</code> 查看控制台。</p><h4 id="2-发送普通消息"><a class="anchor" href="#2-发送普通消息">#</a> 2、发送普通消息</h4><p>下述完整 Demo 详情查看<span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vbmFnZW9mZmVyL3NwcmluZ2Jvb3QtbGFkZGVyL3RyZWUvbWFpbi9tcS1yb2NrZXRtcS00eA=="> springboot-ladder/mq-rocketmq-4x</span> 项目模块。</p><h5 id="21-引入-rocketmq-依赖"><a class="anchor" href="#21-引入-rocketmq-依赖">#</a> 2.1、引入 RocketMQ 依赖</h5><pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.apache.rocketmq&lt;/groupId&gt;
    &lt;artifactId&gt;rocketmq-spring-boot-starter&lt;/artifactId&gt;
    &lt;version&gt;2.2.3&lt;/version&gt;
&lt;/dependency&gt;
</code></pre><h5 id="22-启动自动装配"><a class="anchor" href="#22-启动自动装配">#</a> 2.2、启动自动装配</h5><p>因为咱们 Demo 中使用的是 SpringBoot3，RocketMQ 最新版本 2.2.3 没有适配 SpringBoot3，所以需要手动搞定自动装配。</p><blockquote><p>如果 SpringBoot2 版本，就不需要执行这一步。</p></blockquote><p>resources 目录下创建 META-INF/spring 目录，并创建 <code>org.springframework.boot.autoconfigure.AutoConfiguration.imports</code> 文件。</p><figure class="highlight properties"><figcaption data-lang=".properties"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment"># RocketMQ 2.2.3 version does not adapt to SpringBoot3</span></pre></td></tr><tr><td data-num="2"></td><td><pre>org.apache.rocketmq.spring.autoconfigure.RocketMQAutoConfiguration</pre></td></tr></table></figure><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230924172750462.png" alt="img"></p><h5 id="23-producer"><a class="anchor" href="#23-producer">#</a> 2.3、Producer</h5><p>配置文件中引入 RocketMQ 相关配置定义，比如连接 NameServer 地址等。</p><figure class="highlight yaml"><figcaption data-lang="YAML"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token key atrule">server</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">6060</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token key atrule">rocketmq</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="5"></td><td><pre>  <span class="token key atrule">name-server</span><span class="token punctuation">:</span> 127.0.0.1<span class="token punctuation">:</span><span class="token number">9876</span> <span class="token comment"># NameServer 地址</span></pre></td></tr><tr><td data-num="6"></td><td><pre>  <span class="token key atrule">producer</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token key atrule">group</span><span class="token punctuation">:</span> rocketmq<span class="token punctuation">-</span>4x<span class="token punctuation">-</span>service_common<span class="token punctuation">-</span>message<span class="token punctuation">-</span>execute_pg <span class="token comment"># 全局发送者组定义</span></pre></td></tr></table></figure><p>定义消息生产者，通过 <code>RocketMQTemplate</code> 向 RocketMQ 发送普通常规消息。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">import</span> <span class="token import"><span class="token namespace">cn<span class="token punctuation">.</span>hutool<span class="token punctuation">.</span>core<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">StrUtil</span></span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">import</span> <span class="token import"><span class="token namespace">com<span class="token punctuation">.</span>alibaba<span class="token punctuation">.</span>fastjson<span class="token punctuation">.</span></span><span class="token class-name">JSON</span></span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">import</span> <span class="token import"><span class="token namespace">com<span class="token punctuation">.</span>nageoffer<span class="token punctuation">.</span>springbootladder<span class="token punctuation">.</span>rocketmq4x<span class="token punctuation">.</span>event<span class="token punctuation">.</span></span><span class="token class-name">GeneralMessageEvent</span></span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">import</span> <span class="token import"><span class="token namespace">lombok<span class="token punctuation">.</span></span><span class="token class-name">RequiredArgsConstructor</span></span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">import</span> <span class="token import"><span class="token namespace">lombok<span class="token punctuation">.</span>extern<span class="token punctuation">.</span>slf4j<span class="token punctuation">.</span></span><span class="token class-name">Slf4j</span></span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>rocketmq<span class="token punctuation">.</span>client<span class="token punctuation">.</span>producer<span class="token punctuation">.</span></span><span class="token class-name">SendResult</span></span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>rocketmq<span class="token punctuation">.</span>common<span class="token punctuation">.</span>message<span class="token punctuation">.</span></span><span class="token class-name">MessageConst</span></span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>rocketmq<span class="token punctuation">.</span>spring<span class="token punctuation">.</span>core<span class="token punctuation">.</span></span><span class="token class-name">RocketMQTemplate</span></span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>messaging<span class="token punctuation">.</span></span><span class="token class-name">Message</span></span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>messaging<span class="token punctuation">.</span>support<span class="token punctuation">.</span></span><span class="token class-name">MessageBuilder</span></span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>stereotype<span class="token punctuation">.</span></span><span class="token class-name">Component</span></span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token comment">/**</span></pre></td></tr><tr><td data-num="14"></td><td><pre> * 普通消息发送者</pre></td></tr><tr><td data-num="15"></td><td><pre> *</pre></td></tr><tr><td data-num="16"></td><td><pre> * @公众号：马丁玩编程，回复：加群，添加马哥微信（备注：ladder）获取更多项目资料</pre></td></tr><tr><td data-num="17"></td><td><pre> */</pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token annotation punctuation">@Slf4j</span></pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token annotation punctuation">@Component</span></pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token annotation punctuation">@RequiredArgsConstructor</span></pre></td></tr><tr><td data-num="21"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GeneralMessageDemoProduce</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="22"></td><td><pre></pre></td></tr><tr><td data-num="23"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">RocketMQTemplate</span> rocketMQTemplate<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre></pre></td></tr><tr><td data-num="25"></td><td><pre>    <span class="token comment">/**</span></pre></td></tr><tr><td data-num="26"></td><td><pre>     * 发送普通消息</pre></td></tr><tr><td data-num="27"></td><td><pre>     *</pre></td></tr><tr><td data-num="28"></td><td><pre>     * @param topic            消息发送主题，用于标识同一类业务逻辑的消息</pre></td></tr><tr><td data-num="29"></td><td><pre>     * @param tag              消息的过滤标签，消费者可通过 Tag 对消息进行过滤，仅接收指定标签的消息。</pre></td></tr><tr><td data-num="30"></td><td><pre>     * @param keys             消息索引键，可根据关键字精确查找某条消息</pre></td></tr><tr><td data-num="31"></td><td><pre>     * @param messageSendEvent 普通消息发送事件，自定义对象，最终都会序列化为字符串</pre></td></tr><tr><td data-num="32"></td><td><pre>     * @return 消息发送 RocketMQ 返回结果</pre></td></tr><tr><td data-num="33"></td><td><pre>     */</pre></td></tr><tr><td data-num="34"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">SendResult</span> <span class="token function">sendMessage</span><span class="token punctuation">(</span><span class="token class-name">String</span> topic<span class="token punctuation">,</span> <span class="token class-name">String</span> tag<span class="token punctuation">,</span> <span class="token class-name">String</span> keys<span class="token punctuation">,</span> <span class="token class-name">GeneralMessageEvent</span> messageSendEvent<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="35"></td><td><pre>        <span class="token class-name">SendResult</span> sendResult<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="36"></td><td><pre>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="37"></td><td><pre>            <span class="token class-name">StringBuilder</span> destinationBuilder <span class="token operator">=</span> <span class="token class-name">StrUtil</span><span class="token punctuation">.</span><span class="token function">builder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>topic<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="38"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">StrUtil</span><span class="token punctuation">.</span><span class="token function">isNotBlank</span><span class="token punctuation">(</span>tag<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="39"></td><td><pre>                destinationBuilder<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">":"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>tag<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="40"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="41"></td><td><pre>            <span class="token class-name">Message</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> message <span class="token operator">=</span> <span class="token class-name">MessageBuilder</span></pre></td></tr><tr><td data-num="42"></td><td><pre>                    <span class="token punctuation">.</span><span class="token function">withPayload</span><span class="token punctuation">(</span>messageSendEvent<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="43"></td><td><pre>                    <span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token class-name">MessageConst</span><span class="token punctuation">.</span><span class="token constant">PROPERTY_KEYS</span><span class="token punctuation">,</span> keys<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="44"></td><td><pre>                    <span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token class-name">MessageConst</span><span class="token punctuation">.</span><span class="token constant">PROPERTY_TAGS</span><span class="token punctuation">,</span> tag<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="45"></td><td><pre>                    <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="46"></td><td><pre>            sendResult <span class="token operator">=</span> rocketMQTemplate<span class="token punctuation">.</span><span class="token function">syncSend</span><span class="token punctuation">(</span></pre></td></tr><tr><td data-num="47"></td><td><pre>                    destinationBuilder<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="48"></td><td><pre>                    message<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="49"></td><td><pre>                    <span class="token number">2000L</span></pre></td></tr><tr><td data-num="50"></td><td><pre>            <span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="51"></td><td><pre>            log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"[普通消息] 消息发送结果：&#123;&#125;，消息ID：&#123;&#125;，消息Keys：&#123;&#125;"</span><span class="token punctuation">,</span> sendResult<span class="token punctuation">.</span><span class="token function">getSendStatus</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> sendResult<span class="token punctuation">.</span><span class="token function">getMsgId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> keys<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="52"></td><td><pre>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> ex<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="53"></td><td><pre>            log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"[普通消息] 消息发送失败，消息体：&#123;&#125;"</span><span class="token punctuation">,</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>messageSendEvent<span class="token punctuation">)</span><span class="token punctuation">,</span> ex<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="54"></td><td><pre>            <span class="token keyword">throw</span> ex<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="55"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="56"></td><td><pre>        <span class="token keyword">return</span> sendResult<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="57"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="58"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h5 id="24-consumer"><a class="anchor" href="#24-consumer">#</a> 2.4、Consumer</h5><p>定义消息消费者，从 RocketMQ Broker 拉取对应 Topic Tag 的消息列表。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">import</span> <span class="token import"><span class="token namespace">com<span class="token punctuation">.</span>alibaba<span class="token punctuation">.</span>fastjson<span class="token punctuation">.</span></span><span class="token class-name">JSON</span></span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">import</span> <span class="token import"><span class="token namespace">com<span class="token punctuation">.</span>nageoffer<span class="token punctuation">.</span>springbootladder<span class="token punctuation">.</span>rocketmq4x<span class="token punctuation">.</span>event<span class="token punctuation">.</span></span><span class="token class-name">GeneralMessageEvent</span></span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">import</span> <span class="token import"><span class="token namespace">lombok<span class="token punctuation">.</span></span><span class="token class-name">RequiredArgsConstructor</span></span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">import</span> <span class="token import"><span class="token namespace">lombok<span class="token punctuation">.</span>extern<span class="token punctuation">.</span>slf4j<span class="token punctuation">.</span></span><span class="token class-name">Slf4j</span></span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>rocketmq<span class="token punctuation">.</span>spring<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">RocketMQMessageListener</span></span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>rocketmq<span class="token punctuation">.</span>spring<span class="token punctuation">.</span>core<span class="token punctuation">.</span></span><span class="token class-name">RocketMQListener</span></span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>stereotype<span class="token punctuation">.</span></span><span class="token class-name">Component</span></span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token comment">/**</span></pre></td></tr><tr><td data-num="10"></td><td><pre> * 普通消息消费者</pre></td></tr><tr><td data-num="11"></td><td><pre> *</pre></td></tr><tr><td data-num="12"></td><td><pre> * @公众号：马丁玩编程，回复：加群，添加马哥微信（备注：ladder）获取更多项目资料</pre></td></tr><tr><td data-num="13"></td><td><pre> */</pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token annotation punctuation">@Slf4j</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token annotation punctuation">@Component</span></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token annotation punctuation">@RequiredArgsConstructor</span></pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token annotation punctuation">@RocketMQMessageListener</span><span class="token punctuation">(</span></pre></td></tr><tr><td data-num="18"></td><td><pre>        topic <span class="token operator">=</span> <span class="token string">"rocketmq-demo_common-message_topic"</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="19"></td><td><pre>        selectorExpression <span class="token operator">=</span> <span class="token string">"general"</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="20"></td><td><pre>        consumerGroup <span class="token operator">=</span> <span class="token string">"rocketmq-demo_general-message_cg"</span></pre></td></tr><tr><td data-num="21"></td><td><pre><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="22"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GeneralMessageDemoConsume</span> <span class="token keyword">implements</span> <span class="token class-name">RocketMQListener</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">GeneralMessageEvent</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="23"></td><td><pre></pre></td></tr><tr><td data-num="24"></td><td><pre>    <span class="token annotation punctuation">@Override</span></pre></td></tr><tr><td data-num="25"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onMessage</span><span class="token punctuation">(</span><span class="token class-name">GeneralMessageEvent</span> message<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"接到到RocketMQ消息，消息体：&#123;&#125;"</span><span class="token punctuation">,</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="28"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h5 id="25-发送一条消息"><a class="anchor" href="#25-发送一条消息">#</a> 2.5、发送一条消息</h5><p>定义消息发送程序，这里为了避免类过多，直接写在 SpringBoot 的启动程序里。发送普通消息的方法返回值就是发送 RocketMQ Broker 返回的状态码，成功的话就是 <code>SEND_OK</code> 。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">import</span> <span class="token import"><span class="token namespace">com<span class="token punctuation">.</span>nageoffer<span class="token punctuation">.</span>springbootladder<span class="token punctuation">.</span>rocketmq4x<span class="token punctuation">.</span>event<span class="token punctuation">.</span></span><span class="token class-name">GeneralMessageEvent</span></span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">import</span> <span class="token import"><span class="token namespace">com<span class="token punctuation">.</span>nageoffer<span class="token punctuation">.</span>springbootladder<span class="token punctuation">.</span>rocketmq4x<span class="token punctuation">.</span>produce<span class="token punctuation">.</span></span><span class="token class-name">GeneralMessageDemoProduce</span></span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">import</span> <span class="token import"><span class="token namespace">io<span class="token punctuation">.</span>swagger<span class="token punctuation">.</span>v3<span class="token punctuation">.</span>oas<span class="token punctuation">.</span>annotations<span class="token punctuation">.</span></span><span class="token class-name">Operation</span></span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">import</span> <span class="token import"><span class="token namespace">io<span class="token punctuation">.</span>swagger<span class="token punctuation">.</span>v3<span class="token punctuation">.</span>oas<span class="token punctuation">.</span>annotations<span class="token punctuation">.</span>tags<span class="token punctuation">.</span></span><span class="token class-name">Tag</span></span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">import</span> <span class="token import"><span class="token namespace">lombok<span class="token punctuation">.</span></span><span class="token class-name">RequiredArgsConstructor</span></span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>rocketmq<span class="token punctuation">.</span>client<span class="token punctuation">.</span>producer<span class="token punctuation">.</span></span><span class="token class-name">SendResult</span></span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span></span><span class="token class-name">SpringApplication</span></span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span></span><span class="token class-name">SpringBootApplication</span></span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>bind<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">PostMapping</span></span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>bind<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">RestController</span></span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">UUID</span></span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token annotation punctuation">@RestController</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token annotation punctuation">@RequiredArgsConstructor</span></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token annotation punctuation">@SpringBootApplication</span></pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token annotation punctuation">@Tag</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"RocketMQ发送示例"</span><span class="token punctuation">,</span> description <span class="token operator">=</span> <span class="token string">"RocketMQ发送示例启动器"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RocketMQDemoApplication</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="19"></td><td><pre></pre></td></tr><tr><td data-num="20"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">GeneralMessageDemoProduce</span> generalMessageDemoProduce<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre></pre></td></tr><tr><td data-num="22"></td><td><pre>    <span class="token annotation punctuation">@PostMapping</span><span class="token punctuation">(</span><span class="token string">"/test/send/general-message"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="23"></td><td><pre>    <span class="token annotation punctuation">@Operation</span><span class="token punctuation">(</span>summary <span class="token operator">=</span> <span class="token string">"发送RocketMQ普通消息"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="24"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">sendGeneralMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>        <span class="token class-name">String</span> keys <span class="token operator">=</span> <span class="token constant">UUID</span><span class="token punctuation">.</span><span class="token function">randomUUID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>        <span class="token class-name">GeneralMessageEvent</span> generalMessageEvent <span class="token operator">=</span> <span class="token class-name">GeneralMessageEvent</span><span class="token punctuation">.</span><span class="token function">builder</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="27"></td><td><pre>                <span class="token punctuation">.</span><span class="token function">body</span><span class="token punctuation">(</span><span class="token string">"消息具体内容，可以是自定义对象，最终都会序列化为字符串。如果是取消订单，这里应该是订单ID或者相关联的信息"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="28"></td><td><pre>                <span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>keys<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="29"></td><td><pre>                <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>        <span class="token class-name">SendResult</span> sendResult <span class="token operator">=</span> generalMessageDemoProduce<span class="token punctuation">.</span><span class="token function">sendMessage</span><span class="token punctuation">(</span></pre></td></tr><tr><td data-num="31"></td><td><pre>                <span class="token string">"rocketmq-demo_common-message_topic"</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="32"></td><td><pre>                <span class="token string">"general"</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="33"></td><td><pre>                keys<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="34"></td><td><pre>                generalMessageEvent</pre></td></tr><tr><td data-num="35"></td><td><pre>        <span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="36"></td><td><pre>        <span class="token keyword">return</span> sendResult<span class="token punctuation">.</span><span class="token function">getSendStatus</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="37"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="38"></td><td><pre></pre></td></tr><tr><td data-num="39"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="40"></td><td><pre>        <span class="token class-name">SpringApplication</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token class-name">RocketMQDemoApplication</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="41"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="42"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>项目中引入了 Swagger3，通过界面 UI 发送一条消息测试效果。访问 <code>http://127.0.0.1:6060/swagger-ui/index.html</code> ，调用定义的发送 RocketMQ 普通消息方法。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230924173811738.png" alt="img"></p><p>点击 Execute 执行方法调用。</p><p><img data-src="https://images-machen.oss-cn-beijing.aliyuncs.com/image-20230924173837160.png" alt="img"></p><p>通过方法调用得知，返回数据为成功。</p><p><img data-src="https://images-machen.oss-cn-beijing.aliyuncs.com/image-20230924173948187.png" alt="img"></p><p>也能看到 RocketMQ 对应的生产者和消费者对应日志。</p><figure class="highlight text"><figcaption data-lang="text"></figcaption><table><tr><td data-num="1"></td><td><pre>2023-09-24T17:38:57.457+08:00  INFO 48437 --- [nio-6060-exec-6] c.n.s.r.p.GeneralMessageDemoProduce      : [普通消息] 消息发送结果：SEND_OK，消息ID：7F000001BD35251A69D77A3BC5280002，消息Keys：7a60c853-08dc-46cd-a647-398d45b54966</pre></td></tr><tr><td data-num="2"></td><td><pre>2023-09-24T17:38:57.459+08:00  INFO 48437 --- [al-message_cg_3] c.n.s.r.c.GeneralMessageDemoConsume      : 接到RocketMQ消息，消息体：&#123;"body":"消息具体内容，可以是自定义对象，最终都会序列化为字符串。如果是取消订单，这里应该是订单ID或者相关联的信息","keys":"7a60c853-08dc-46cd-a647-398d45b54966"&#125;</pre></td></tr></table></figure><h4 id="3-扩展框架-springcloud-stream"><a class="anchor" href="#3-扩展框架-springcloud-stream">#</a> 3、扩展框架 SpringCloud Stream</h4><p>Spring Cloud Stream 是一个<strong>用于构建基于消息的微服务应用</strong>框架。它基于 SpringBoot 来创建具有生产级别的单机 Spring 应用，并且使用 <code>Spring Integration</code> 与 Broker 进行连接。</p><p>Spring Cloud Stream 提供了消息中间件配置的统一抽象，推出了 publish-subscribe、consumer groups、partition 这些统一的概念。</p><p>Spring Cloud Stream 内部有两个概念：Binder 和 Binding。</p><ul><li><code>Binder</code> ：跟外部消息中间件集成的组件，用来创建 Binding，各消息中间件都有自己的 Binder 实现。</li></ul><p>比如 <code>Kafka</code> 的实现 <code>KafkaMessageChannelBinder</code> ， <code>RabbitMQ</code> 的实现 <code>RabbitMessageChannelBinder</code> 以及 <code>RocketMQ</code> 的实现 <code>RocketMQMessageChannelBinder</code> 。</p><ul><li><code>Binding</code> ：包括 Input Binding 和 Output Binding。</li></ul><p>Binding 在消息中间件与应用程序提供的 Provider 和 Consumer 之间提供了一个桥梁，实现了开发者只需使用应用程序的 Provider 或 Consumer 生产或消费数据即可，屏蔽了开发者与底层消息中间件的接触。</p><p>下图是 Spring Cloud Stream 的架构设计。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/68747470733a2f2f646f63732e737072696e672e696f2f737072696e672d636c6f75642d73747265616d2f646f63732f63757272656e742f7265666572656e63652f68746d6c2f696d616765732f534353742d776974682d62696e6465722e706e67.png" alt="img"></p><p>SpringCloud Stream RocketMQ 不是咱们本次介绍的重点，所以只是抛砖引玉，大家需要了解详情参考：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FsaWJhYmEvc3ByaW5nLWNsb3VkLWFsaWJhYmEvYmxvYi8yLjIueC9zcHJpbmctY2xvdWQtYWxpYmFiYS1leGFtcGxlcy9yb2NrZXRtcS1leGFtcGxlL3JlYWRtZS16aC5tZA==">RocketMQ Example</span></p><h3 id="部署架构"><a class="anchor" href="#部署架构">#</a> 部署架构</h3><h4 id="本地部署"><a class="anchor" href="#本地部署">#</a> 本地部署</h4><h5 id="单组节点单副本模式"><a class="anchor" href="#单组节点单副本模式">#</a> 单组节点单副本模式</h5><p>这种方式风险较大，因为 Broker 只有一个节点，一旦 Broker 重启或者宕机时，会导致整个服务不可用。不建议线上环境使用，可以用于本地测试。</p><h5 id="多组节点集群单副本模式"><a class="anchor" href="#多组节点集群单副本模式">#</a> 多组节点（集群）单副本模式</h5><p>一个集群内全部部署 Master 角色，不部署 Slave 副本，例如 2 个 Master 或者 3 个 Master，这种模式的优缺点如下：</p><ul><li>优点：配置简单，单个 Master 宕机或重启维护对应用无影响，在磁盘配置为 RAID10 时，即使机器宕机不可恢复情况下，由于 RAID10 磁盘非常可靠，消息也不会丢（异步刷盘丢失少量消息，同步刷盘一条不丢），性能最高；</li><li>缺点：单台机器宕机期间，这台机器上未被消费的消息在机器恢复之前不可订阅，消息实时性会受到影响。</li></ul><h4 id="生产部署"><a class="anchor" href="#生产部署">#</a> 生产部署</h4><h5 id="多节点集群多副本模式异步复制"><a class="anchor" href="#多节点集群多副本模式异步复制">#</a> 多节点（集群）多副本模式：异步复制</h5><p><font color="red">每个 Master 配置一个 Slave</font>，有多组 Master-Slave，HA 采用<strong>异步复制</strong>方式，主备有短暂消息延迟（毫秒级），这种模式的优缺点如下：</p><ul><li>优点：即使磁盘损坏，消息丢失的非常少，且消息实时性不会受影响，同时 Master 宕机后，消费者仍然可以从 Slave 消费，而且此过程对应用透明，不需要人工干预，性能同多 Master 模式几乎一样；</li><li>缺点：Master 宕机，磁盘损坏情况下会丢失少量消息。</li></ul><h5 id="多节点集群多副本模式同步双写"><a class="anchor" href="#多节点集群多副本模式同步双写">#</a> 多节点（集群）多副本模式：同步双写</h5><p><font color="red">每个 Master 配置一个 Slave</font>，有多对 Master-Slave，HA 采用<strong>同步双写</strong>方式，即只有主备都写成功，才向应用返回成功，这种模式的优缺点如下：</p><ul><li>优点：数据与服务都无单点故障，Master 宕机情况下，消息无延迟，服务可用性与数据可用性都非常高；</li><li>缺点：性能比异步复制模式略低（大约低 10% 左右），发送单个消息的 RT 会略高，且目前版本在主节点宕机后，备机不能自动切换为主机。</li></ul></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2024-03-02 17:34:13" itemprop="dateModified" datetime="2024-03-02T17:34:13+08:00">2024-03-02</time> </span><span id="mq/消息队列/" class="item leancloud_visitors" data-flag-title="消息队列" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>范特东东东 <i class="ic i-at"><em>@</em></i>水文 & 摄影</li><li class="link"><strong>本文链接：</strong> <a href="http://example.com/mq/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" title="消息队列">http://example.com/mq/消息队列/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/docker/docker-javaguide/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;pic.imgdb.cn&#x2F;item&#x2F;65a9ebfb871b83018a3cb132.jpg" title="docker-javaguide"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> docker</span><h3>docker-javaguide</h3></a></div><div class="item right"><a href="/distributed-microservices/ShardingSphere/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;hjx159&#x2F;picture-bed&#x2F;main&#x2F;img&#x2F;image-20230926142358927.png" title="ShardingSphere"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> 分布式微服务</span><h3>ShardingSphere</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-number">1.</span> <span class="toc-text">消息队列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">1.1.</span> <span class="toc-text">消息队列基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">1.1.1.</span> <span class="toc-text">消息队列的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">1.1.2.</span> <span class="toc-text">消息队列的作用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%9C%E7%94%A81%E9%80%9A%E8%BF%87%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86%E6%8F%90%E9%AB%98%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%E5%87%8F%E5%B0%91%E5%93%8D%E5%BA%94%E6%89%80%E9%9C%80%E6%97%B6%E9%97%B4"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">作用 1：通过异步处理提高系统性能（减少响应所需时间）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%9C%E7%94%A82%E5%89%8A%E5%B3%B0%E9%99%90%E6%B5%81"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">作用 2：削峰 &#x2F; 限流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%9C%E7%94%A83%E9%99%8D%E4%BD%8E%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%80%A6%E5%90%88%E6%80%A7"><span class="toc-number">1.1.2.3.</span> <span class="toc-text">作用 3：降低系统的耦合性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%9C%E7%94%A84%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1"><span class="toc-number">1.1.2.4.</span> <span class="toc-text">作用 4：实现分布式事务</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">1.1.3.</span> <span class="toc-text">消息队列存在的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jms-%E5%92%8C-amqp"><span class="toc-number">1.1.4.</span> <span class="toc-text">JMS 和 AMQP</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#jms-%E5%AE%9A%E4%B9%89"><span class="toc-number">1.1.4.1.</span> <span class="toc-text">JMS 定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#jms-%E4%B8%A4%E7%A7%8D%E6%B6%88%E6%81%AF%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.1.4.2.</span> <span class="toc-text">JMS 两种消息模型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%82%B9%E5%88%B0%E7%82%B9%E6%A8%A1%E5%9E%8Bp2p"><span class="toc-number">1.1.4.2.1.</span> <span class="toc-text">点到点模型（P2P）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%9E%8Bpubsub"><span class="toc-number">1.1.4.2.2.</span> <span class="toc-text">发布 &#x2F; 订阅模型（Pub&#x2F;Sub）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#amqp-%E5%AE%9A%E4%B9%89"><span class="toc-number">1.1.4.3.</span> <span class="toc-text">AMQP 定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#jms-vs-amqp"><span class="toc-number">1.1.4.4.</span> <span class="toc-text">JMS vs AMQP</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rpc-%E5%92%8C%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.1.5.</span> <span class="toc-text">RPC 和消息队列的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E9%80%89%E5%9E%8B"><span class="toc-number">1.1.6.</span> <span class="toc-text">消息队列选型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-number">1.1.6.1.</span> <span class="toc-text">常见的消息队列</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#kafka"><span class="toc-number">1.1.6.1.1.</span> <span class="toc-text">Kafka</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#rocketmq"><span class="toc-number">1.1.6.1.2.</span> <span class="toc-text">RocketMQ</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#rabbitmq"><span class="toc-number">1.1.6.1.3.</span> <span class="toc-text">RabbitMQ</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#activemq"><span class="toc-number">1.1.6.1.4.</span> <span class="toc-text">ActiveMQ</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E6%AF%94"><span class="toc-number">1.1.6.2.</span> <span class="toc-text">对比</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#kafka-2"><span class="toc-number">1.2.</span> <span class="toc-text">Kafka</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80"><span class="toc-number">1.2.1.</span> <span class="toc-text">基础</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%9F%E8%83%BD-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">功能、应用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E6%AF%94%E5%85%B6%E4%BB%96-mq-%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">相比其他 MQ 的优势</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.2.1.3.</span> <span class="toc-text">消息模型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%98%9F%E5%88%97%E6%A8%A1%E5%9E%8Bp2p"><span class="toc-number">1.2.1.3.1.</span> <span class="toc-text">队列模型（P2P）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%91%E5%B8%83-%E8%AE%A2%E9%98%85%E6%A8%A1%E5%9E%8Bpub-sub"><span class="toc-number">1.2.1.3.2.</span> <span class="toc-text">发布 - 订阅模型（Pub-Sub）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="toc-number">1.2.2.</span> <span class="toc-text">核心概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#producer-comsumer-broker-topic-partition"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">Producer、Comsumer、Broker、Topic、Partition</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E5%89%AF%E6%9C%AC%E6%9C%BA%E5%88%B6replica"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">多副本机制（Replica）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#kafka-%E4%B8%8E-zookeeper-%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">1.2.3.</span> <span class="toc-text">Kafka 与 Zookeeper 的关系</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#zookeeper-%E5%9C%A8-kafka-%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">Zookeeper 在 Kafka 中的作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#kafka-%E4%B8%8D%E5%86%8D%E4%BE%9D%E8%B5%96%E4%BA%8E-zookeeper"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">Kafka 不再依赖于 Zookeeper</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E8%B4%B9%E9%A1%BA%E5%BA%8F-%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1-%E9%87%8D%E5%A4%8D%E6%B6%88%E8%B4%B9"><span class="toc-number">1.2.4.</span> <span class="toc-text">消费顺序、消息丢失、重复消费</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E7%9A%84%E6%B6%88%E8%B4%B9%E9%A1%BA%E5%BA%8F"><span class="toc-number">1.2.4.1.</span> <span class="toc-text">如何保证消息的消费顺序？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E4%B8%8D%E4%B8%A2%E5%A4%B1"><span class="toc-number">1.2.4.2.</span> <span class="toc-text">如何保证消息不丢失？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%83%85%E5%86%B51producer-%E4%B8%A2%E5%A4%B1%E6%B6%88%E6%81%AF"><span class="toc-number">1.2.4.2.1.</span> <span class="toc-text">情况 1：Producer 丢失消息</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%83%85%E5%86%B52consumer-%E4%B8%A2%E5%A4%B1%E6%B6%88%E6%81%AF"><span class="toc-number">1.2.4.2.2.</span> <span class="toc-text">情况 2：Consumer 丢失消息</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%83%85%E5%86%B53kafka-%E4%B8%A2%E5%A4%B1%E6%B6%88%E6%81%AF"><span class="toc-number">1.2.4.2.3.</span> <span class="toc-text">情况 3：Kafka 丢失消息</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E4%B8%8D%E8%A2%AB%E9%87%8D%E5%A4%8D%E6%B6%88%E8%B4%B9"><span class="toc-number">1.2.4.3.</span> <span class="toc-text">如何保证消息不被重复消费？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E8%AF%95%E6%9C%BA%E5%88%B6"><span class="toc-number">1.2.5.</span> <span class="toc-text">重试机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E8%B4%B9%E5%A4%B1%E8%B4%A5%E5%90%8E%E4%BC%9A%E5%85%88%E9%87%8D%E8%AF%95%E5%A4%9A%E6%AC%A1%E9%87%8D%E8%AF%95%E5%A4%B1%E8%B4%A5%E5%90%8E%E4%BC%9A%E8%B7%B3%E8%BF%87"><span class="toc-number">1.2.5.1.</span> <span class="toc-text">消费失败后会先重试，多次重试失败后会跳过</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E9%87%8D%E8%AF%95-10-%E6%AC%A1%E6%97%B6%E9%97%B4%E9%97%B4%E9%9A%94%E4%B8%BA-0"><span class="toc-number">1.2.5.2.</span> <span class="toc-text">默认重试 10 次，时间间隔为 0</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E9%87%8D%E8%AF%95%E6%AC%A1%E6%95%B0-%E6%97%B6%E9%97%B4%E9%97%B4%E9%9A%94"><span class="toc-number">1.2.5.3.</span> <span class="toc-text">自定义重试次数、时间间隔</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E8%AF%95%E5%A4%B1%E8%B4%A5%E5%90%8E%E5%A6%82%E4%BD%95%E5%91%8A%E8%AD%A6"><span class="toc-number">1.2.5.4.</span> <span class="toc-text">重试失败后，如何告警？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E8%AF%95%E6%9C%80%E5%A4%A7%E6%AC%A1%E6%95%B0%E5%A4%B1%E8%B4%A5%E5%90%8E%E5%A6%82%E4%BD%95%E5%86%8D%E6%AC%A1%E5%A4%84%E7%90%86%E8%AF%A5%E6%B6%88%E6%81%AF"><span class="toc-number">1.2.5.5.</span> <span class="toc-text">重试最大次数失败后，如何再次处理该消息？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E8%AF%95%E6%B3%A8%E8%A7%A3-retryabletopic"><span class="toc-number">1.2.5.6.</span> <span class="toc-text">重试注解 @RetryableTopic</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98kafka-%E6%B6%88%E8%B4%B9%E7%BB%84%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E6%80%A7"><span class="toc-number">1.2.6.</span> <span class="toc-text">【面试题】kafka 消费组有什么特性？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98kafka-%E5%A4%9A-topic-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98"><span class="toc-number">1.2.7.</span> <span class="toc-text">【面试题】kafka 多 topic 为什么有性能问题？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#rocketmq-2"><span class="toc-number">1.3.</span> <span class="toc-text">RocketMQ</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.3.1.</span> <span class="toc-text">使用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E8%A7%A3%E8%80%A6"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">异步解耦</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%B2%E8%A1%8C%E6%96%B9%E5%BC%8F"><span class="toc-number">1.3.1.1.1.</span> <span class="toc-text">串行方式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B9%B6%E8%A1%8C%E6%96%B9%E5%BC%8F"><span class="toc-number">1.3.1.1.2.</span> <span class="toc-text">并行方式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E8%A7%A3%E8%80%A6-2"><span class="toc-number">1.3.1.1.3.</span> <span class="toc-text">异步解耦</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%81%E9%87%8F%E5%89%8A%E5%B3%B0"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">流量削峰</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E6%B6%88%E6%81%AF"><span class="toc-number">1.3.1.3.</span> <span class="toc-text">顺序消息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E6%A8%A1%E7%BC%93%E5%AD%98%E5%90%8C%E6%AD%A5"><span class="toc-number">1.3.1.4.</span> <span class="toc-text">分布式模缓存同步</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E5%AE%9A%E6%97%B6%E5%BB%B6%E6%97%B6%E8%B0%83%E5%BA%A6"><span class="toc-number">1.3.1.5.</span> <span class="toc-text">分布式定时 &#x2F; 延时调度</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.3.2.</span> <span class="toc-text">消息类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E6%B6%88%E6%81%AF"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">普通消息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E6%97%B6%E6%B6%88%E6%81%AF"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">定时消息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E6%B6%88%E6%81%AF-2"><span class="toc-number">1.3.2.3.</span> <span class="toc-text">顺序消息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF"><span class="toc-number">1.3.2.4.</span> <span class="toc-text">事务消息</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5"><span class="toc-number">1.3.3.</span> <span class="toc-text">基础概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#topic-%E4%B8%BB%E9%A2%98"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">Topic 主题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#queue-%E9%98%9F%E5%88%97"><span class="toc-number">1.3.3.2.</span> <span class="toc-text">Queue 队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#message-%E6%B6%88%E6%81%AF"><span class="toc-number">1.3.3.3.</span> <span class="toc-text">Message 消息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#producer-%E7%94%9F%E4%BA%A7%E8%80%85"><span class="toc-number">1.3.3.4.</span> <span class="toc-text">Producer 生产者</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#consumer-%E6%B6%88%E8%B4%B9%E8%80%85"><span class="toc-number">1.3.3.5.</span> <span class="toc-text">Consumer 消费者</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#broker-%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">1.3.3.6.</span> <span class="toc-text">Broker 代理服务器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#nameserver-%E5%90%8D%E5%AD%97%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">1.3.3.7.</span> <span class="toc-text">NameServer 名字服务器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%83%A8%E7%BD%B2%E6%A8%A1%E5%9E%8B%E5%B0%8F%E7%BB%93"><span class="toc-number">1.3.3.8.</span> <span class="toc-text">部署模型小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">1.3.4.</span> <span class="toc-text">工作原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%90%AF%E5%8A%A8-nameserver"><span class="toc-number">1.3.4.1.</span> <span class="toc-text">1、启动 NameServer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%90%AF%E5%8A%A8-broker"><span class="toc-number">1.3.4.2.</span> <span class="toc-text">2、启动 Broker</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%88%9B%E5%BB%BA-topic"><span class="toc-number">1.3.4.3.</span> <span class="toc-text">3、创建 Topic</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-producer-%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF"><span class="toc-number">1.3.4.4.</span> <span class="toc-text">4、Producer 发送消息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-consumer-%E6%8E%A5%E6%94%B6%E6%B6%88%E6%81%AF"><span class="toc-number">1.3.4.5.</span> <span class="toc-text">5、Consumer 接收消息</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF"><span class="toc-number">1.3.5.</span> <span class="toc-text">如何正确发送消息</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E5%BB%BA%E8%AE%AE%E5%8D%95%E4%B8%80%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA%E5%A4%A7%E9%87%8F-producer"><span class="toc-number">1.3.5.1.</span> <span class="toc-text">不建议单一进程创建大量 Producer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E5%BB%BA%E8%AE%AE%E9%A2%91%E7%B9%81%E5%88%9B%E5%BB%BA%E5%92%8C%E9%94%80%E6%AF%81-producer"><span class="toc-number">1.3.5.2.</span> <span class="toc-text">不建议频繁创建和销毁 Producer</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#consumer-%E5%88%86%E7%B1%BB"><span class="toc-number">1.3.6.</span> <span class="toc-text">Consumer 分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#producer-%E5%92%8C-consumer-%E5%88%86%E7%BB%84"><span class="toc-number">1.3.7.</span> <span class="toc-text">Producer 和 Consumer 分组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#producer-%E5%88%86%E7%BB%84"><span class="toc-number">1.3.7.1.</span> <span class="toc-text">Producer 分组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#consumer-%E5%88%86%E7%BB%84"><span class="toc-number">1.3.7.2.</span> <span class="toc-text">Consumer 分组</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E9%A1%BA%E5%BA%8F%E6%B6%88%E8%B4%B9-%E9%87%8D%E5%A4%8D%E6%B6%88%E8%B4%B9"><span class="toc-number">1.3.8.</span> <span class="toc-text">如何解决顺序消费、重复消费？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E6%B6%88%E8%B4%B9"><span class="toc-number">1.3.8.1.</span> <span class="toc-text">顺序消费</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E6%83%85%E5%86%B5"><span class="toc-number">1.3.8.2.</span> <span class="toc-text">特殊情况</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%91%E9%80%81%E5%BC%82%E5%B8%B8"><span class="toc-number">1.3.8.2.1.</span> <span class="toc-text">发送异常</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E8%BF%87%E5%A4%A7"><span class="toc-number">1.3.8.2.2.</span> <span class="toc-text">消息过大</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E5%A4%8D%E6%B6%88%E8%B4%B9"><span class="toc-number">1.3.8.3.</span> <span class="toc-text">重复消费</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1"><span class="toc-number">1.3.9.</span> <span class="toc-text">如何实现分布式事务？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E6%B6%88%E6%81%AF%E5%A0%86%E7%A7%AF%E9%97%AE%E9%A2%98"><span class="toc-number">1.3.10.</span> <span class="toc-text">如何解决消息堆积问题？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF%E6%B6%88%E8%B4%B9"><span class="toc-number">1.3.11.</span> <span class="toc-text">回溯消费</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E9%AB%98%E6%80%A7%E8%83%BD%E8%AF%BB%E5%86%99"><span class="toc-number">1.3.12.</span> <span class="toc-text">如何保证高性能读写？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%B7%E7%9B%98%E6%9C%BA%E5%88%B6"><span class="toc-number">1.3.13.</span> <span class="toc-text">刷盘机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E5%88%B7%E7%9B%98-%E5%BC%82%E6%AD%A5%E5%88%B7%E7%9B%98"><span class="toc-number">1.3.13.1.</span> <span class="toc-text">同步刷盘、异步刷盘</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E5%A4%8D%E5%88%B6-%E5%BC%82%E6%AD%A5%E5%A4%8D%E5%88%B6"><span class="toc-number">1.3.13.2.</span> <span class="toc-text">同步复制、异步复制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E6%9C%BA%E5%88%B6"><span class="toc-number">1.3.13.3.</span> <span class="toc-text">存储机制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%89%8B%E5%8F%91%E4%B8%80%E6%9D%A1%E6%B6%88%E6%81%AF"><span class="toc-number">1.3.14.</span> <span class="toc-text">动手发一条消息</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%90%AF%E5%8A%A8-rocketmq"><span class="toc-number">1.3.14.1.</span> <span class="toc-text">1、启动 RocketMQ</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%8F%91%E9%80%81%E6%99%AE%E9%80%9A%E6%B6%88%E6%81%AF"><span class="toc-number">1.3.14.2.</span> <span class="toc-text">2、发送普通消息</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#21-%E5%BC%95%E5%85%A5-rocketmq-%E4%BE%9D%E8%B5%96"><span class="toc-number">1.3.14.2.1.</span> <span class="toc-text">2.1、引入 RocketMQ 依赖</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#22-%E5%90%AF%E5%8A%A8%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D"><span class="toc-number">1.3.14.2.2.</span> <span class="toc-text">2.2、启动自动装配</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#23-producer"><span class="toc-number">1.3.14.2.3.</span> <span class="toc-text">2.3、Producer</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#24-consumer"><span class="toc-number">1.3.14.2.4.</span> <span class="toc-text">2.4、Consumer</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#25-%E5%8F%91%E9%80%81%E4%B8%80%E6%9D%A1%E6%B6%88%E6%81%AF"><span class="toc-number">1.3.14.2.5.</span> <span class="toc-text">2.5、发送一条消息</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%89%A9%E5%B1%95%E6%A1%86%E6%9E%B6-springcloud-stream"><span class="toc-number">1.3.14.3.</span> <span class="toc-text">3、扩展框架 SpringCloud Stream</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%83%A8%E7%BD%B2%E6%9E%B6%E6%9E%84"><span class="toc-number">1.3.15.</span> <span class="toc-text">部署架构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2"><span class="toc-number">1.3.15.1.</span> <span class="toc-text">本地部署</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8D%95%E7%BB%84%E8%8A%82%E7%82%B9%E5%8D%95%E5%89%AF%E6%9C%AC%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.3.15.1.1.</span> <span class="toc-text">单组节点单副本模式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%9A%E7%BB%84%E8%8A%82%E7%82%B9%E9%9B%86%E7%BE%A4%E5%8D%95%E5%89%AF%E6%9C%AC%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.3.15.1.2.</span> <span class="toc-text">多组节点（集群）单副本模式</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E9%83%A8%E7%BD%B2"><span class="toc-number">1.3.15.2.</span> <span class="toc-text">生产部署</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%9A%E8%8A%82%E7%82%B9%E9%9B%86%E7%BE%A4%E5%A4%9A%E5%89%AF%E6%9C%AC%E6%A8%A1%E5%BC%8F%E5%BC%82%E6%AD%A5%E5%A4%8D%E5%88%B6"><span class="toc-number">1.3.15.2.1.</span> <span class="toc-text">多节点（集群）多副本模式：异步复制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%9A%E8%8A%82%E7%82%B9%E9%9B%86%E7%BE%A4%E5%A4%9A%E5%89%AF%E6%9C%AC%E6%A8%A1%E5%BC%8F%E5%90%8C%E6%AD%A5%E5%8F%8C%E5%86%99"><span class="toc-number">1.3.15.2.2.</span> <span class="toc-text">多节点（集群）多副本模式：同步双写</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li class="active"><a href="/mq/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" rel="bookmark" title="消息队列">消息队列</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="范特东东东" data-src="/images/avatar.jpg"><p class="name" itemprop="name">范特东东东</p><div class="description" itemprop="description"></div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">64</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">23</span> <span class="name">分类</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hqeDE1OQ==" title="https:&#x2F;&#x2F;github.com&#x2F;hjx159"><i class="ic i-github"></i></span> <span class="exturl item xiaohongshu" data-url="aHR0cHM6Ly93d3cueGlhb2hvbmdzaHUuY29tL3VzZXIvcHJvZmlsZS81ZTAyYzhhZDAwMDAwMDAwMDEwMDFmM2U=" title="https:&#x2F;&#x2F;www.xiaohongshu.com&#x2F;user&#x2F;profile&#x2F;5e02c8ad0000000001001f3e"><i class="ic i-xiaohongshu2"></i></span> <span class="exturl item email" data-url="bWFpbHRvOjgxMjE0MzI4MEBxcS5jb20=" title="mailto:812143280@qq.com"><i class="ic i-envelope"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><a href="/categories/photography/" rel="section"><i class="ic i-photography"></i>摄影</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于我</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/docker/docker-javaguide/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/distributed-microservices/ShardingSphere/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/java/" title="分类于 Java">Java</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/" title="分类于 Java基础">Java基础</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/java-excise/" title="分类于 Java基础-真题">Java基础-真题</a></div><span><a href="/java/java-se/java-excise/%E7%AC%AC04%E7%AB%A0%EF%BC%9A%E9%9A%8F%E5%A0%82%E5%A4%8D%E4%B9%A0%E4%B8%8E%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%A2%98%EF%BC%88IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%89/" title="宋红康_第04章：IDEA安装与使用">宋红康_第04章：IDEA安装与使用</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/database/" title="分类于 数据库">数据库</a> <i class="ic i-angle-right"></i> <a href="/categories/database/redis/" title="分类于 Redis">Redis</a></div><span><a href="/database/redis/%E5%B0%9A%E7%A1%85%E8%B0%B7-%E5%91%A8%E9%98%B3-Redis7/" title="Redis7-尚硅谷-周阳">Redis7-尚硅谷-周阳</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/java/" title="分类于 Java">Java</a> <i class="ic i-angle-right"></i> <a href="/categories/java/jvm/" title="分类于 JVM">JVM</a></div><span><a href="/java/jvm/JVM%E7%AC%94%E8%AE%B0/" title="JVM笔记">JVM笔记</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/java/" title="分类于 Java">Java</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/" title="分类于 Java基础">Java基础</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/java-excise/" title="分类于 Java基础-真题">Java基础-真题</a></div><span><a href="/java/java-se/java-excise/%E7%AC%AC08%E7%AB%A0%EF%BC%9A%E9%9A%8F%E5%A0%82%E5%A4%8D%E4%B9%A0%E4%B8%8E%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%A2%98%EF%BC%88%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E9%AB%98%E7%BA%A7%EF%BC%89/" title="宋红康_第08章：面向对象-高级">宋红康_第08章：面向对象-高级</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/database/" title="分类于 数据库">数据库</a> <i class="ic i-angle-right"></i> <a href="/categories/database/mongodb/" title="分类于 MongoDB">MongoDB</a></div><span><a href="/database/mongodb/MongoDB-JavaGuide/" title="MongoDB-JavaGuide">MongoDB-JavaGuide</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/java/" title="分类于 Java">Java</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/" title="分类于 Java基础">Java基础</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/java-excise/" title="分类于 Java基础-真题">Java基础-真题</a></div><span><a href="/java/java-se/java-excise/%E7%AC%AC14%E7%AB%A0%EF%BC%9A%E9%9A%8F%E5%A0%82%E5%A4%8D%E4%B9%A0%E4%B8%8E%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%A2%98%EF%BC%88%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%EF%BC%89/" title="宋红康_第14章：数据结构与集合源码">宋红康_第14章：数据结构与集合源码</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/distributed-microservices/" title="分类于 分布式微服务">分布式微服务</a></div><span><a href="/distributed-microservices/ShardingSphere/" title="ShardingSphere">ShardingSphere</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/distributed-microservices/" title="分类于 分布式微服务">分布式微服务</a></div><span><a href="/distributed-microservices/API%E7%BD%91%E5%85%B3&SpringCloud%20Gateway/" title="API网关 &amp; SpringCloud Gateway">API网关 & SpringCloud Gateway</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/photography/" title="分类于 摄影">摄影</a></div><span><a href="/photography/%E8%93%9D%E4%B8%8E%E9%BB%84/" title="蓝与黄">蓝与黄</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/java/" title="分类于 Java">Java</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/" title="分类于 Java基础">Java基础</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/java-knowledge/" title="分类于 Java基础-知识点">Java基础-知识点</a></div><span><a href="/java/java-se/java-knowledge/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E5%AE%8B%E7%BA%A2%E5%BA%B7_%E7%AC%AC03%E7%AB%A0_%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/" title="宋红康_第03章_流程控制语句">宋红康_第03章_流程控制语句</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">范特东东东 @ fantedong</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">2m 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">30:47</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"mq/消息队列/",favicon:{show:"(●´3｀●)欢迎回来",hide:"(〃＞皿＜)你快回来"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hrmmi -->