<!-- build time:Thu Jan 25 2024 11:41:45 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="水文 & 摄影" href="http://example.com/rss.xml"><link rel="alternate" type="application/atom+xml" title="水文 & 摄影" href="http://example.com/atom.xml"><link rel="alternate" type="application/json" title="水文 & 摄影" href="http://example.com/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><link rel="canonical" href="http://example.com/database/mysql/MySQL-JavaGuide/"><title>MySQL-JavaGuide - MySQL - 数据库 | fantedong = 水文 & 摄影 = 为了能更好地访问图片，你需要一点魔法</title><meta name="generator" content="Hexo 6.3.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">MySQL-JavaGuide</h1><div class="meta"><span class="item" title="创建时间：2023-11-17 19:50:54"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2023-11-17T19:50:54+08:00">2023-11-17</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>101k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>1:32</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">fantedong</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><img src="https://oss.javaguide.cn/github/javaguide/csdn/20210327143351823.png"></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/database/" itemprop="item" rel="index" title="分类于 数据库"><span itemprop="name">数据库</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/database/mysql/" itemprop="item" rel="index" title="分类于 MySQL"><span itemprop="name">MySQL</span></a><meta itemprop="position" content="2"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://example.com/database/mysql/MySQL-JavaGuide/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="范特东东东"><meta itemprop="description" content="为了能更好地访问图片，你需要一点魔法, "></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="水文 & 摄影"></span><div class="body md" itemprop="articleBody"><h1 id="mysql"><a class="anchor" href="#mysql">#</a> MySQL</h1><h2 id="数据库基础知识"><a class="anchor" href="#数据库基础知识">#</a> 数据库基础知识</h2><h3 id="数据库-数据库管理系统-数据库系统-数据库管理员"><a class="anchor" href="#数据库-数据库管理系统-数据库系统-数据库管理员">#</a> 数据库，数据库管理系统，数据库系统，数据库管理员</h3><ul><li><strong>数据库</strong>（DataBase 简称 <code>DB</code> ）：就是信息的集合，或者说是由数据库管理系统管理的数据的集合。</li><li><strong>数据库管理系统</strong>（Database Management System 简称 <code>DBMS</code> ）：是一种操纵和管理数据库的大型软件，通常用于建立、使用和维护数据库。</li><li><strong>数据库系统</strong>（Data Base System，简称 <code>DBS</code> ）：通常由软件、数据库和数据管理员 (DBA) 组成。</li><li><strong>数据库管理员</strong>（Database Administrator, 简称 <code>DBA</code> ）：负责全面管理和控制数据库系统。</li></ul><h3 id="元组-码-候选码-主码-外码-主属性-非主属性"><a class="anchor" href="#元组-码-候选码-主码-外码-主属性-非主属性">#</a> 元组，码，候选码，主码，外码，主属性，非主属性</h3><ul><li><strong>元组</strong>（tuple）：是关系数据库中的基本概念，关系是一张表，表中的<font color="red">每行（即数据库中的每条记录）就是一个元组</font>，每列就是一个属性。在二维表里，元组也称为行。</li><li><strong>码</strong>：码就是<font color="red">能唯一标识实体的属性</font>，对应表中的列。</li><li><strong>候选码</strong>：若关系中的<font color="red">某一属性或属性组的值能唯一标识一个元组，而其任何、子集都不能再标识</font>，则称该属性组为候选码。例如：在学生实体中，“学号” 是能唯一的区分学生实体的，同时又假设 “姓名”、“班级” 的属性组合足以区分学生实体，那么 {学号} 和 {姓名，班级} 都是候选码。</li><li><strong>主码</strong>：主码也叫主键。主码是从候选码中选出来的。<font color="red">一个实体集中只能有一个主码，但可以有多个候选码</font>。</li><li><strong>外码</strong>：外码也叫外键。如果一个关系中的一个属性是另外一个关系中的主码则这个属性为外码。</li><li><strong>主属性</strong>：<font color="red">候选码中出现过的属性称为主属性</font>。比如关系 工人（工号，身份证号，姓名，性别，部门）. 显然工号和身份证号都能够唯一标示这个关系，所以都是候选码。工号、身份证号这两个属性就是主属性。如果主码是一个属性组，那么属性组中的属性都是主属性。</li><li><strong>非主属性：</strong><font color="red">不包含在任何一个候选码中的属性称为非主属性</font>。比如在关系 —— 学生（学号，姓名，年龄，性别，班级）中，主码是 “学号”，那么其他的 “姓名”、“年龄”、“性别”、“班级” 就都可以称为非主属性。</li></ul><h3 id="er-图"><a class="anchor" href="#er-图">#</a> ER 图</h3><p><strong>ER 图</strong> 全称是 Entity Relationship Diagram（<font color="red">实体联系图</font>），提供了表示实体类型、属性和联系的方法，用来设计数据库。</p><p>ER 图由下面 3 个要素组成：</p><ul><li><strong>实体</strong>：通常是现实世界的业务对象，当然使用一些逻辑对象也可以。比如对于一个校园管理系统，会涉及学生、教师、课程、班级等等实体。在 ER 图中，实体使用<font color="red">矩形框</font>表示。</li><li><strong>属性</strong>：即某个实体拥有的属性，属性用来描述组成实体的要素，对于产品设计来说可以理解为字段。在 ER 图中，属性使用<font color="red">椭圆形</font>表示。</li><li><strong>联系</strong>：即实体与实体之间的关系，在 ER 图中用<font color="red">菱形</font>表示，这个关系不仅有业务关联关系，还能通过数字表示实体之间的数量对照关系。例如，一个班级会有多个学生就是一种实体间的联系。</li></ul><p>下图是一个学生选课的 ER 图，每个学生可以选若干门课程，同一门课程也可以被若干人选择，所以它们之间的关系是<font color="red">多对多（M: N</font>）。另外，还有其他两种实体之间的关系是：<font color="red">1 对 1（1:1）</font>、<font color="red">1 对多（1: N）</font>。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231129163909791.png" alt="image-20231129163909791"></p><center>学生与课程之间联系的E-R图</center><h3 id="数据库三大范式"><a class="anchor" href="#数据库三大范式">#</a> <mark>🌟数据库三大范式</mark></h3><p>数据库范式有 3 种：</p><ul><li><p>1NF (第一范式)：<strong><font color="red">属性不可再分</font></strong>，即每个属性都是不可分割的原子项。</p></li><li><p>2NF (第二范式)：满足第一范式；且 **<font color="red">不存在部分函数依赖</font>**，即<font color="red">非主属性必须完全依赖于主属性</font>。</p><blockquote><p>主属性即主键；完全依赖是针对于联合主键的情况，非主键列不能只依赖于主键的一部分；</p></blockquote></li><li><p>3NF (第三范式)：满足第二范式；且 **<font color="red">不存在传递函数依赖</font>**，即非主属性必须直接依赖于主属性。</p></li></ul><h3 id="不推荐使用外键与级联"><a class="anchor" href="#不推荐使用外键与级联">#</a> 不推荐使用外键与级联</h3><p>对于外键和级联，阿里巴巴开发手册这样说到：</p><blockquote><p>【强制】<strong><font color="red">不得使用外键与级联，一切外键概念必须在应用层解决</font></strong>。</p><p>说明：以学生和成绩的关系为例，学生表中的 student_id 是主键，那么成绩表中的 student_id 则为外键。如果更新学生表中的 student_id，同时触发成绩表中的 student_id 更新，即为级联更新。</p><ul><li>外键与级联更新适用于单机低并发，<font color="red">不适合分布式、高并发集群</font>；</li><li><font color="red">级联更新是强阻塞，存在数据库更新风暴的风险</font>；</li><li><font color="red">外键影响数据库的插入速度</font>；</li></ul></blockquote><h3 id="存储过程"><a class="anchor" href="#存储过程">#</a> 存储过程</h3><p>我们可以把存储过程看成是<strong>一些 SQL 语句的集合，中间加了点逻辑控制语句</strong>。存储过程在业务比较复杂的时候是非常实用的，比如很多时候我们完成一个操作可能需要写一大串 SQL 语句，这时候我们就可以写有一个存储过程，这样也方便了我们下一次的调用。<font color="red">存储过程一旦调试完成通过后就能稳定运行</font>，另外，<font color="red">使用存储过程比单纯 SQL 语句执行要快，因为存储过程是预编译过的</font>。</p><p>存储过程在互联网公司应用不多，因为<font color="red">存储过程难以调试和扩展，而且没有移植性，还会消耗数据库资源</font>。</p><p>阿里巴巴 Java 开发手册里要求 **<font color="red">禁止使用存储过程</font>**。</p><h3 id="drop-delete-与-truncate-的区别"><a class="anchor" href="#drop-delete-与-truncate-的区别">#</a> drop、delete 与 truncate 的区别</h3><h4 id="用法不同"><a class="anchor" href="#用法不同">#</a> 用法不同</h4><ul><li><code>drop</code> (丢弃数据): <code>drop table 表名</code> ，直接将表都删除掉，在<strong>删除表</strong>的时候使用。</li><li><code>truncate</code> (清空数据) : <code>truncate table 表名</code> ，只删除表中的数据，<font color="red">再插入数据的时候自增长 id 又从 1 开始</font>，在<strong>清空表</strong>中数据的时候使用。</li><li><code>delete</code> （删除数据） : <code>delete from 表名 where 列名=值</code> ，<strong>删除某一行</strong>的数据，如果不加 <code>where</code> 子句和 <code>truncate table 表名</code> 作用类似。</li></ul><p>注意：<strong> <code>truncate</code> 和 <code>delete</code> 只删除数据不删除表的结构 (定义)，执行 <code>drop</code> 语句，此表的结构也会删除，也就是执行 <code>drop</code> 之后对应的表不复存在。</strong></p><h4 id="属于不同的数据库语言"><a class="anchor" href="#属于不同的数据库语言">#</a> 属于不同的数据库语言</h4><ul><li><p><code>truncate</code> 和 <code>drop</code> 属于 **DDL (数据定义语言)** 语句，操作立即生效，原数据不放到 rollback segment 中，<font color="red">不能回滚</font>，操作不触发 trigger。</p></li><li><p>而 <code>delete</code> 语句是 **DML (数据库操作语言)** 语句，这个操作会放到 rollback segement 中，<font color="red">可以回滚</font>，事务提交之后才生效。</p></li></ul><p><strong>DML 语句和 DDL 语句区别：</strong></p><ul><li>DML 是数据库操作语言（Data Manipulation Language）的缩写，是指<font color="red">对数据库中表记录的操作</font>，主要包括表记录的插入、更新、删除和查询，是开发人员日常使用最频繁的操作。</li><li>DDL （Data Definition Language）是数据定义语言的缩写，简单来说，就是<font color="red">对数据库内部的对象进行创建、删除、修改</font>的操作语言。</li><li>二者最大区别：<strong><font color="red"> DML 只是对表内部数据的操作，而不涉及到表的定义、结构的修改</font></strong>，更不会涉及到其他对象。DDL 语句更多的被数据库管理员（DBA）所使用，一般的开发人员很少使用。</li></ul><p>另外，由于 <code>select</code> 不会对表进行破坏，所以有的地方也会把 <code>select</code> 单独区分开叫做数据库查询语言 DQL（Data Query Language）。</p><h4 id="执行速度不同"><a class="anchor" href="#执行速度不同">#</a> 执行速度不同</h4><p>一般来说： <code>drop</code> &gt; <code>truncate</code> &gt; <code>delete</code> （这个我没有设计测试过）。</p><ul><li><code>delete</code> 命令执行的时候<font color="red">会产生数据库的 <code>binlog</code> 日志，而日志记录是需要消耗时间的</font>，但是也有个<font color="red">好处是方便数据回滚恢复</font>。</li><li><code>truncate</code> 命令执行的时候<font color="red">不会产生数据库日志</font>，因此比 <code>delete</code> 要快。除此之外，还<font color="red">会把表的自增值重置和索引恢复到初始大小等</font>。</li><li><code>drop</code> 命令会<font color="red">把表占用的空间全部释放掉</font>。</li></ul><p>Tips：你应该更多地关注在使用场景上，而不是执行效率。</p><h3 id="数据库设计通常分为哪几步"><a class="anchor" href="#数据库设计通常分为哪几步">#</a> 数据库设计通常分为哪几步？</h3><ol><li><strong>需求分析</strong>：分析用户的需求，包括数据、功能和性能需求。</li><li><strong>概念结构设计</strong>：主要采用 E-R 模型进行设计，包括画 <code>E-R 图</code> 。</li><li><strong>逻辑结构设计</strong>：通过将 E-R 图转换成 <code>表</code> ，实现从 E-R 模型到关系模型的转换。</li><li><strong>物理结构设计</strong>：主要是为所设计的数据库<font color="red">选择合适的存储结构和存取路径</font>。</li><li><strong>数据库实施</strong>：包括编程、测试和试运行</li><li><strong>数据库的运行和维护</strong>：系统的运行与数据库的日常维护。</li></ol><h2 id="nosql非关系型数据库基础"><a class="anchor" href="#nosql非关系型数据库基础">#</a> NoSQL（非关系型数据库）基础</h2><h3 id="nosql-是什么"><a class="anchor" href="#nosql-是什么">#</a> NoSQL 是什么？</h3><p><code>NoSQL</code> （Not Only SQL）非关系型的数据库，主要针对的是<font color="red">键值、文档、图形类型</font>数据存储。并且，NoSQL 数据库<font color="red">天生支持分布式，数据冗余和数据分片</font>等特性，<font color="red">旨在提供可扩展、高可用、高性能的数据存储解决方案</font>。</p><p>一个常见的误解是 NoSQL 数据库或非关系型数据库不能很好地存储关系型数据。<font color="red">NoSQL 数据库可以存储关系型数据</font>— 它们与关系型数据库的存储方式不同。</p><p>NoSQL 数据库代表：HBase 、Cassandra、MongoDB、Redis。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/sql-nosql-tushi.png" alt="img"></p><h3 id="sql数据库-和-nosql数据库-的区别"><a class="anchor" href="#sql数据库-和-nosql数据库-的区别">#</a> <mark>🌟SQL 数据库 和 NoSQL 数据库 的区别</mark></h3><p>即关系型数据库与非关系型数据库的区别：</p><table><thead><tr><th style="text-align:left"></th><th>SQL 数据库</th><th>NoSQL 数据库</th></tr></thead><tbody><tr><td style="text-align:left">发展历程</td><td>开发于 1970 年代，重点是<font color="red">减少数据重复</font></td><td>开发于 2000 年代后期，重点是<font color="red">提升可扩展性</font>，<font color="red">减少大规模数据的存储成本</font></td></tr><tr><td style="text-align:left">例子</td><td><code>Oracle</code> 、 <code>MySQL</code> 、Microsoft SQL Server 、PostgreSQL</td><td>文档： <code>MongoDB</code> 、CouchDB，键值： <code>Redis</code> 、DynamoDB，宽列：Cassandra 、 <code>HBase</code> ，图表： <code>Neo4j</code> 、 Amazon Neptune、Giraph</td></tr><tr><td style="text-align:left">数据存储模型</td><td><font color="red">结构化存储</font>，具有固定行和列的表格</td><td><font color="red">非结构化存储</font>。文档：JSON 文档，键值：键值对，宽列：包含行和动态列的表，图：节点和边</td></tr><tr><td style="text-align:left">数据模式</td><td><font color="red">必须先定义好表结构，才能添加数据</font></td><td><font color="red">数据可以在任何时候任何地方添加，不需要预先定义</font></td></tr><tr><td style="text-align:left">事务支持</td><td>支持对事务原子性细粒度控制，并且易于回滚事务</td><td><font color="red">没有事务这个概念</font>，每一个数据集都是原子级别的</td></tr><tr><td style="text-align:left">ACID 属性</td><td>提供<font color="red">原子性、一致性、隔离性、持久性</font>(ACID) 属性</td><td><font color="red">通常不支持 ACID 事务</font>，为了可扩展、高性能进行了权衡，少部分支持比如 MongoDB 。不过，MongoDB 对 ACID 事务 的支持和 MySQL 还是有所区别的。</td></tr><tr><td style="text-align:left">查询速度</td><td><font color="red">数据存储在磁盘中，查询速度较慢</font></td><td><font color="red">数据存储在缓存中，且不需要经过 SQL 层的解析，查询速度较快</font></td></tr><tr><td style="text-align:left">性能</td><td>性能通常取决于磁盘子系统。要获得最佳性能，通常需要<font color="red">优化查询、索引、表结构</font>。</td><td>性能通常由底层硬件集群大小、网络延迟以及调用应用程序来决定。</td></tr><tr><td style="text-align:left">扩展</td><td><font color="red">垂直</font>（使用性能更强大的服务器进行扩展）、读写分离、分库分表</td><td><font color="red">横向</font>（增加服务器的方式横向扩展，通常是基于分片机制）</td></tr><tr><td style="text-align:left">用途</td><td>普通企业级的项目的数据存储</td><td>用途广泛比如图数据库支持分析和遍历连接数据之间的关系、键值数据库可以处理大量数据扩展和极高的状态变化</td></tr><tr><td style="text-align:left">查询语法</td><td><font color="red">结构化查询语言 (SQL)</font></td><td>数据访问语法可能<font color="red">因数据库而异</font></td></tr></tbody></table><h3 id="nosql-数据库的优势"><a class="anchor" href="#nosql-数据库的优势">#</a> NoSQL 数据库的优势</h3><p>NoSQL 数据库非常适合许多现代应用程序，例如移动、Web 和游戏等应用程序，它们需要灵活、可扩展、高性能和功能强大的数据库以提供卓越的用户体验。</p><ul><li><strong>灵活性：</strong> NoSQL 数据库通常提供灵活的架构，以实现更快速、更多的迭代开发。<font color="red">灵活的数据模型</font>使 NoSQL 数据库成为 **<font color="red">半结构化和非结构化数据</font>** 的理想之选。</li><li><strong>可扩展性：</strong> NoSQL 数据库通常被设计为<font color="red">通过使用分布式硬件集群来横向扩展</font>，而不是通过添加昂贵和强大的服务器来纵向扩展。</li><li><strong>高性能：</strong> NoSQL 数据库<font color="red">针对特定的数据模型和访问模式进行了优化</font>，这与尝试使用关系数据库完成类似功能相比可实现更高的性能。</li><li><strong>强大的功能：</strong> NoSQL 数据库提供功能<font color="red">强大的 API 和数据类型</font>，专门针对其各自的数据模型而构建。</li></ul><h3 id="nosql-数据库有哪些类型"><a class="anchor" href="#nosql-数据库有哪些类型">#</a> NoSQL 数据库有哪些类型？</h3><p>NoSQL 数据库主要可以分为下面四种类型：</p><ul><li><strong>键值</strong> ：键值数据库是一种较简单的数据库，其中<font color="red">每个项都包含键和值</font>。这是极为灵活的 NoSQL 数据库类型，因为应用可以完全控制 value 字段中存储的内容，没有任何限制。 <code>Redis</code> 和 DynanoDB 是两款非常流行的键值数据库。</li><li><strong>文档</strong> ：文档数据库中的数据被存储在类似于 <code>JSON</code> （JavaScript 对象表示法）对象的文档中，非常清晰直观。<font color="red">每个文档包含成对的字段和值</font>。这些值通常可以是各种类型，包括字符串、数字、布尔值、数组或对象等，并且它们的<font color="red">结构通常与开发者在代码中使用的对象保持一致</font>。 <code>MongoDB</code> 就是一款非常流行的文档数据库。</li><li><strong>图形</strong> ：图形数据库旨在轻松构建和运行与高度连接的数据集一起使用的应用程序。图形数据库的典型使用案例包括社交网络、推荐引擎、欺诈检测和知识图谱。 <code>Neo4j</code> 和 Giraph 是两款非常流行的图形数据库。</li><li><strong>宽列</strong> ：宽列存储数据库<font color="red">非常适合需要存储大量的数据</font>。Cassandra 和 <code>HBase</code> 是两款非常流行的宽列存储数据库。</li></ul><p>下面这张图片来源于 <span class="exturl" data-url="aHR0cHM6Ly9sZWFybi5taWNyb3NvZnQuY29tL2VuLXVzL2RvdG5ldC9hcmNoaXRlY3R1cmUvY2xvdWQtbmF0aXZlL3JlbGF0aW9uYWwtdnMtbm9zcWwtZGF0YQ==">微软的官方文档 | 关系数据与 NoSQL 数据</span>。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/types-of-nosql-datastores.png" alt="NoSQL 数据模型"></p><h2 id="mysql-常见面试题"><a class="anchor" href="#mysql-常见面试题">#</a> MySQL 常见面试题</h2><h3 id="mysql基础"><a class="anchor" href="#mysql基础">#</a> MySQL 基础</h3><h4 id="什么是关系型数据库"><a class="anchor" href="#什么是关系型数据库">#</a> 什么是关系型数据库？</h4><p>顾名思义， <code>关系型数据库（RDBMS，Relational Database Management System）</code> 就是<font color="red">一种建立在<u>关系模型</u>的基础上的数据库</font>。关系模型表明了数据库中所存储的<font color="red">数据之间的联系（一对一、一对多、多对多）</font>。</p><p>关系型数据库中，我们的数据都被存放在了各种表中（比如用户表），表中的每一行就存放着一条数据（比如一个用户的信息）。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/5e3c1a71724a38245aa43b02_99bf70d46cc247be878de9d3a88f0c44.png" alt="关系型数据库表关系"></p><p>大部分关系型数据库都使用 SQL 来操作数据库中的数据。并且，大部分关系型数据库都支持<font color="red">事务的四大特性 (ACID)</font>。</p><p>常见的关系型数据库：MySQL、PostgreSQL、Oracle、SQL Server、SQLite（微信本地的聊天记录的存储就是用的 SQLite） ......。</p><h4 id="什么是-sql"><a class="anchor" href="#什么是-sql">#</a> 什么是 SQL？</h4><p>SQL 是一种 <code>结构化查询语言(Structured Query Language)</code> ，专门用来与数据库打交道，目的是提供一种<font color="red">从数据库中读写数据</font>的简单有效的方法。</p><p>几乎所有的主流关系数据库都支持 SQL ，适用性非常强。并且，一些非关系型数据库也兼容 SQL 或者使用的是类似于 SQL 的查询语言。</p><p>SQL 可以帮助我们：</p><ul><li>新建数据库、数据表、字段；</li><li>在数据库中增加，删除，修改，查询数据；</li><li>新建视图、函数、存储过程；</li><li>对数据库中的数据进行简单的数据分析；</li><li>搭配 Hive，Spark SQL 做大数据；</li><li>搭配 SQLFlow 做机器学习；</li><li>......</li></ul><h4 id="什么是-mysql"><a class="anchor" href="#什么是-mysql">#</a> 什么是 MySQL？</h4><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/20210327143351823.png" alt="img"></p><p><strong>MySQL 是一种关系型数据库，主要用于持久化存储我们的系统中的一些数据比如用户信息。</strong></p><p>由于 MySQL 是开源免费并且比较成熟的数据库，因此，MySQL 被大量使用在各种系统中。任何人都可以在 GPL (General Public License) 的许可下下载并根据个性化的需要对其进行修改。MySQL 的默认端口号是<strong> 3306</strong>。</p><h4 id="mysql-有什么优点"><a class="anchor" href="#mysql-有什么优点">#</a> MySQL 有什么优点？</h4><p>这个问题本质上是在问 MySQL 如此流行的原因。</p><p>MySQL 主要具有下面这些优点：</p><ol><li>成熟稳定，功能完善。</li><li>开源免费。</li><li>文档丰富，既有详细的官方文档，又有非常多优质文章可供参考学习。</li><li>开箱即用，操作简单，维护成本低。</li><li>兼容性好，支持常见的操作系统，支持多种开发语言。</li><li>社区活跃，生态完善。</li><li><strong>事务支持</strong>优秀， InnoDB 存储引擎默认使用 REPEATABLE-READ 并不会有任何性能损失，并且 InnoDB 实现的 REPEATABLE-READ 隔离级别其实是可以解决幻读问题发生的。</li><li>支持<strong>分库分表、读写分离、高可用</strong>。</li></ol><h4 id="mysql-中主键和-unique-的区别"><a class="anchor" href="#mysql-中主键和-unique-的区别">#</a> <mark>MySQL 中主键和 unique 的区别</mark></h4><p>主键和 UNIQUE 约束<font color="red">都能保证某个列或者列组合的唯⼀性</font>，但是有以下不同：</p><ul><li><p><font color="red">⼀张表中只能定义⼀个主键</font>，却可以定义多个 UNIQUE 约束！</p></li><li><p><font color="red">主键列不允许存放 NULL</font>，⽽声明了 UNIQUE 属性的列可以存放 NULL ，⽽且 NULL 可以重复地出现在多条记录中！</p></li></ul><h3 id="mysql字段类型"><a class="anchor" href="#mysql字段类型">#</a> MySQL 字段类型</h3><h4 id="整数类型的-unsigned-属性有什么用"><a class="anchor" href="#整数类型的-unsigned-属性有什么用">#</a> 整数类型的 UNSIGNED 属性有什么用？</h4><p><strong>UNSIGNED 属性来表示不允许负值的无符号整数，因此可以将正整数的上限提高一倍</strong>，因为它不需要存储负数值。</p><p>例如， TINYINT UNSIGNED 类型的取值范围是 0 ~ 255，而普通的 TINYINT 类型的值范围是 -128 ~ 127。INT UNSIGNED 类型的取值范围是 0 ~ 4,294,967,295，而普通的 INT 类型的值范围是 2,147,483,648 ~ 2,147,483,647。</p><p>对于<font color="red">从 0 开始递增的 ID 列</font>，使用 UNSIGNED 属性可以非常适合，因为不允许负值并且可以拥有更大的上限范围，提供了更多的 ID 值可用。</p><h4 id="char-和-varchar-的区别是什么"><a class="anchor" href="#char-和-varchar-的区别是什么">#</a> CHAR 和 VARCHAR 的区别是什么？</h4><p><strong>CHAR 是定长字符串，VARCHAR 是变长字符串。</strong></p><ul><li>CHAR 在存储时会在右边<font color="red">填充空格</font>以达到指定的长度，检索时会<font color="red">去掉空格</font>；VARCHAR 在存储时需要<font color="red">使用 1 或 2 个额外字节记录字符串的长度</font>，检索时不需要处理。</li><li>CHAR 更适合存储<font color="red">长度较短或者长度都差不多</font>的字符串，例如 Bcrypt 算法、MD5 算法加密后的密码、身份证号码。VARCHAR 类型适合存储<font color="red">长度不确定或者差异较大</font>的字符串，例如用户昵称、文章标题等。</li><li>CHAR (M) 和 VARCHAR (M) 的 M 都代表能够保存的字符数的最大值，<font color="red">无论是字母、数字还是中文，每个都只占用一个字符</font>。</li></ul><h4 id="varchar100和-varchar10的区别是什么"><a class="anchor" href="#varchar100和-varchar10的区别是什么">#</a> VARCHAR (100) 和 VARCHAR (10) 的区别是什么？</h4><p>VARCHAR (100) 和 VARCHAR (10) 都是变长类型，表示能存储最多 100 个字符和 10 个字符。因此，<font color="red">VARCHAR (100) 可以满足更大范围的字符存储需求</font>，有更好的业务拓展性。而 VARCHAR (10) 存储超过 10 个字符时，就需要修改表结构才可以。</p><p>虽说 VARCHAR (100) 和 VARCHAR (10) 能存储的字符范围不同，但二者存储相同的字符串，所占用磁盘的存储空间其实是一样的，这也是很多人容易误解的一点。</p><p>不过，<font color="red">VARCHAR (100) 会消耗更多的内存</font>。这是因为 VARCHAR 类型在内存中操作时，<font color="red">通常会分配固定大小的内存块</font>来保存值，即使用字符类型中定义的长度。例如在进行排序的时候，VARCHAR (100) 是按照 100 这个长度来进行的，也就会消耗更多内存。</p><h4 id="decimal-和-floatdouble-的区别是什么"><a class="anchor" href="#decimal-和-floatdouble-的区别是什么">#</a> DECIMAL 和 FLOAT/DOUBLE 的区别是什么？</h4><p><strong>DECIMAL 是定点数，可以存储精确的小数值；FLOAT/DOUBLE 是浮点数，只能存储近似的小数值。</strong></p><p>在 Java 中，MySQL 的 DECIMAL 类型对应的是 Java 类 <code>java.math.BigDecimal</code> 。</p><h4 id="为什么不推荐使用-text-和-blob"><a class="anchor" href="#为什么不推荐使用-text-和-blob">#</a> 为什么不推荐使用 TEXT 和 BLOB？</h4><p>TEXT 类型类似于 CHAR（0-255 字节）和 VARCHAR（0-65,535 字节），但可以存储更长的字符串，即<font color="cornflowerblue">长文本数据</font>，例如博客内容。</p><table><thead><tr><th>类型</th><th>可存储大小</th><th>用途</th></tr></thead><tbody><tr><td>TINYTEXT</td><td>0-255 字节</td><td>一般文本字符串</td></tr><tr><td>TEXT</td><td>0-65,535 字节</td><td>长文本字符串</td></tr><tr><td>MEDIUMTEXT</td><td>0-16,772,150 字节</td><td>较大文本数据</td></tr><tr><td>LONGTEXT</td><td>0-4,294,967,295 字节</td><td>极大文本数据</td></tr></tbody></table><p>BLOB 类型主要用于存储<font color="cornflowerblue">二进制大对象，例如图片、音视频等文件</font>。</p><table><thead><tr><th>类型</th><th>可存储大小</th><th>用途</th></tr></thead><tbody><tr><td>TINYBLOB</td><td>0-255 字节</td><td>短文本二进制字符串</td></tr><tr><td>BLOB</td><td>0-65KB</td><td>二进制字符串</td></tr><tr><td>MEDIUMBLOB</td><td>0-16MB</td><td>二进制形式的长文本数据</td></tr><tr><td>LONGBLOB</td><td>0-4GB</td><td>二进制形式的极大文本数据</td></tr></tbody></table><p>在日常开发中，很少使用 TEXT 类型，但偶尔会用到，而 BLOB 类型则基本不常用。<font color="red">如果预期长度范围可以通过 VARCHAR 来满足，建议避免使用 TEXT</font>。</p><p>数据库规范通常不推荐使用 BLOB 和 TEXT 类型，这两种类型具有一些缺点和限制，例如：</p><ul><li><font color="red">不能有默认值</font></li><li>在使用临时表时<font color="red">无法使用内存临时表，只能在磁盘上创建临时表</font>（《高性能 MySQL》书中有提到）</li><li><font color="red">检索效率较低</font></li><li><font color="red">不能直接创建索引</font>，需要指定前缀长度</li><li><font color="red">会消耗大量的网络和 IO 带宽</font></li><li>可能导致表上的<font color="red"> DML 操作变慢</font></li><li>……</li></ul><h4 id="datetime-和-timestamp-的区别是什么"><a class="anchor" href="#datetime-和-timestamp-的区别是什么">#</a> DATETIME 和 TIMESTAMP 的区别是什么？</h4><p><strong>DATETIME 类型没有时区信息，TIMESTAMP 和时区有关</strong>。</p><p><font color="red">TIMESTAMP 只需要使用 4 个字节的存储空间，但是 DATETIME 需要耗费 8 个字节的存储空间</font>。但是，这样同样造成了一个问题，<font color="red">Timestamp 表示的时间范围更小</font>。</p><ul><li>DATETIME：1000-01-01 00:00:00 ~ 9999-12-31 23:59:59</li><li>Timestamp：1970-01-01 00:00:01 ~ 2037-12-31 23:59:59</li></ul><h4 id="null-和-的区别是什么"><a class="anchor" href="#null-和-的区别是什么">#</a> NULL 和 '' 的区别是什么？</h4><p><code>NULL</code> 跟 <code>''</code> (空字符串) 是两个完全不一样的值，区别如下：</p><ul><li><strong><code>NULL</code> 代表一个不确定的值，但占用空间</strong>。就算是两个 <code>NULL</code> ，它俩也不一定相等。例如， <code>SELECT NULL=NULL</code> 的结果为 false，但是在我们使用 <code>DISTINCT</code> ， <code>GROUP BY</code> ， <code>ORDER BY</code> 时， <code>NULL</code> 又被认为是相等的。</li><li><strong><code>''</code> 是长度为 0 的字符串，不占用空间</strong>。</li><li><font color="red"><code>NULL</code> 会影响聚合函数的结果</font>。例如， <code>SUM</code> 、 <code>AVG</code> 、 <code>MIN</code> 、 <code>MAX</code> 等聚合函数会忽略 <code>NULL</code> 值。 <code>COUNT</code> 的处理方式取决于参数的类型。如果参数是 <code>*</code> ( <code>COUNT(*)</code> )，则会统计所有的记录数，包括 <code>NULL</code> 值；如果参数是某个字段名 ( <code>COUNT(列名)</code> )，则会忽略 <code>NULL</code> 值，只统计非空值的个数。</li><li><font color="red">查询 <code>NULL</code> 值时，必须使用 <code>IS NULL</code> 或 <code>IS NOT NULLl</code> 来判断</font>，而不能使用 =、!=、 &lt;、&gt; 之类的比较运算符。而 <code>''</code> 是可以使用这些比较运算符的。</li></ul><p><strong>因此，MySQL 不建议使用 <code>NULL</code> 作为列默认值。</strong></p><h4 id="boolean-类型如何表示"><a class="anchor" href="#boolean-类型如何表示">#</a> Boolean 类型如何表示？</h4><p>MySQL 中没有专门的布尔类型，而是<strong>用 TINYINT (1) 类型来表示布尔值</strong>。TINYINT (1) 类型可以存储 0 或 1，分别对应 false 或 true。</p><h3 id="mysql基础架构"><a class="anchor" href="#mysql基础架构">#</a> MySQL 基础架构</h3><blockquote><p>配合 <a href="">SQL 语句在 MySQL 中的执行过程</a> 这篇文章来理解 MySQL 基础架构。</p></blockquote><p>一个 SQL 语句在 MySQL 中的执行流程，包括 SQL 的查询在 MySQL 内部会怎么流转，SQL 语句的更新是怎么完成的。</p><p>在分析之前先看看 MySQL 的基础架构，知道了 MySQL 由那些组件组成，以及这些组件的作用是什么，可以帮助我们理解和解决这些问题。</p><h4 id="1-mysql-基础架构分析"><a class="anchor" href="#1-mysql-基础架构分析">#</a> 1、MySQL 基础架构分析</h4><h5 id="11-架构概览"><a class="anchor" href="#11-架构概览">#</a> 1.1、架构概览</h5><p>下图是 MySQL 的一个简要架构图，可以很清晰地看到客户端的一条 SQL 语句在 MySQL 内部是如何执行的。</p><p>从图中可以看出，MySQL 主要由下面几部分构成：</p><ul><li><strong>连接器：</strong><font color="red">连接管理、身份认证和权限</font>相关 (登录 MySQL 的时候)。</li><li>** 查询缓存：** 执行查询语句的时候，会<font color="red">先查询缓存，命中则直接返回</font>（<font color="red">MySQL 8.0 版本后移除</font>，因为这个功能不太实用）。</li><li><strong>分析器：</strong><font color="red">对 SQL 语句进行词法分析、语法分析</font>。说白了就是要先看 SQL 语句要干嘛，再检查 SQL 语句语法是否正确。</li><li><strong>优化器：</strong><font color="red">执行计划生产，索引选择</font>。按照 MySQL 认为<font color="red">最优的方案</font>去执行。</li><li>** 执行器：** 执行语句，然后<font color="red">从存储引擎返回数据</font>。</li><li><strong>插件式存储引擎</strong>：主要负责<font color="red">数据的存储和读取</font>，采用的是 <code>插件式架构</code> ，支持 InnoDB、MyISAM、Memory 等多种存储引擎。</li></ul><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/13526879-3037b144ed09eb88.png" alt="img"></p><center>MySQL 简要架构图</center><p>MySQL 主要分为 Server 层和存储引擎层：</p><ul><li><strong>Server 层</strong>：主要包括<font color="red">连接器、查询缓存、分析器、优化器、执行器</font>等，所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图，函数等，还有一个通用的日志模块 **<font color="red"> binlog 日志模块</font>**。</li><li><strong>存储引擎层</strong>：主要负责<font color="red">数据的存储和读取</font>，采用可以替换的插件式架构，支持 <font color="red">InnoDB、MyISAM、Memory</font> 等多个存储引擎。其中 InnoDB 引擎有自有的日志模块 **<font color="red"> redolog 日志模块</font><strong>。</strong><font color="red">现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5 版本开始就被当做默认存储引擎了</font>**。</li></ul><h5 id="12-server-层的组件介绍"><a class="anchor" href="#12-server-层的组件介绍">#</a> 1.2、Server 层的组件介绍</h5><h6 id="1连接器"><a class="anchor" href="#1连接器">#</a> 1）连接器</h6><p>连接器主要和 **<font color="red">身份认证和权限相关</font>** 的功能相关，就好比一个级别很高的门卫一样。</p><p>主要负责用户登录数据库，进行用户的身份认证，包括校验账户密码，权限等操作。如果用户账户密码已通过，连接器会到权限表中查询该用户的所有权限，之后在这个连接里的权限逻辑判断都<font color="red">仅依赖起始连接成功时读取到的权限数据</font>。也就是说，<font color="red">后续只要这个连接不断开，即使管理员修改了该用户的权限，该用户也是不受影响的</font>。</p><h6 id="2查询缓存"><a class="anchor" href="#2查询缓存">#</a> 2）查询缓存</h6><blockquote><p><strong>从 MySQL8.0 后移除</strong></p></blockquote><p>查询缓存主要 **<font color="red">用来缓存所执行的 SELECT 语句以及该语句的结果集</font>**。</p><p>若连接成功建立，<font color="red">执行查询语句的时候，会先查询缓存</font>。</p><ul><li>MySQL 会先校验这个 SQL 是否执行过，<font color="red">以 Key-Value 的形式缓存在内存中，Key 是查询语句，Value 是结果集</font>。</li><li>如果缓存 key 被命中，就会直接返回给客户端。</li><li>如果缓存 key 没有命中，就会执行后续的操作，<font color="red">完成后也会把结果缓存起来，方便下一次调用</font>。</li></ul><p><strong><font color="red">MySQL 查询不建议使用缓存，因为表更新会清空表上的所有查询缓存，导致查询缓存频繁失效</font></strong>。假如你对一个表更新的话，这个表上的所有的查询缓存都会被清空。对于不经常更新的数据来说，使用缓存还是可以的。</p><p>MySQL 8.0 版本后删除了缓存的功能，官方也是认为该功能在实际的应用场景比较少，所以干脆直接删掉了。</p><h6 id="3分析器"><a class="anchor" href="#3分析器">#</a> 3）分析器</h6><p><font color="red">MySQL 没有命中缓存，那么就会进入分析器</font>。</p><p><strong><font color="red">第一步，词法分析</font></strong>：一条 SQL 语句有多个字符串组成，首先要<font color="red">提取关键字</font>，比如 select，提出查询的表，提出字段名，提出查询条件等等。</p><p><strong><font color="red">第二步，语法分析</font></strong>：主要就是判断你输入的 SQL 是否正确，<font color="red">判断是否符合 MySQL 的语法</font>。</p><p>完成这 2 步之后，MySQL 就准备开始执行了，但是如何执行，怎么执行是最好的结果呢？这个时候就需要优化器上场了。</p><h6 id="4优化器"><a class="anchor" href="#4优化器">#</a> 4）优化器</h6><p>优化器的作用就是 **<font color="red">按照它认为的最优执行方案去执行</font>**，比如多个索引的时候该<font color="red">如何选择索引</font>，多表查询的时候<font color="red">如何选择关联顺序</font>等。</p><p>可以说，经过了优化器之后，这个语句具体该如何执行就已经定下来。</p><h6 id="5执行器"><a class="anchor" href="#5执行器">#</a> 5）执行器</h6><p>当选择了执行方案后，MySQL 就准备开始执行了。首先执行前会校验该用户有没有权限，如果没有权限，就会返回错误信息。<strong><font color="red">如果有权限，就会去调用存储引擎的接口，返回执行结果</font></strong>。</p><h4 id="2-sql-执行过程分析"><a class="anchor" href="#2-sql-执行过程分析">#</a> 2、SQL 执行过程分析</h4><h5 id="21-dql-查询语句"><a class="anchor" href="#21-dql-查询语句">#</a> 2.1、DQL 查询语句</h5><blockquote><p>select</p></blockquote><p>针对 select 语句：</p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tb_student  A <span class="token keyword">where</span> A<span class="token punctuation">.</span>age<span class="token operator">=</span><span class="token string">'18'</span> <span class="token operator">and</span> A<span class="token punctuation">.</span>name<span class="token operator">=</span><span class="token string">' 张三 '</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>结合上面的说明，我们分析下这个语句的执行流程：</p><ol><li><strong>检查该语句是否有权限</strong>：<ul><li>如果没有权限，直接返回错误信息。</li><li>如果有权限，在 MySQL8.0 版本以前，会<strong>查询缓存</strong>，以这条 SQL 语句为 key 在内存中查询是否有结果，有则直接返回，无则执行下一步。</li></ul></li><li><strong>通过分析器对 SQL 语句进行词法分析、语法分析</strong>。<ul><li><font color="red">提取关键元素</font>，比如提取上面这个语句是查询 select，提取需要查询的表名为 tb_student，需要查询所有的列，查询条件是这个表的 id='1'。</li><li><font color="red">判断是否有语法错误</font>，比如关键词是否正确等等，如果检查没问题就执行下一步。</li></ul></li><li><strong>优化器确定执行方案</strong>。上面的 SQL 语句，可以有两种执行方案：a. 先查询学生表中姓名为 “张三” 的学生，然后判断是否年龄是 18。b. 先找出学生中年龄 18 岁的学生，然后再查询姓名为 “张三” 的学生。那么<font color="red">优化器根据优化算法选择执行效率最好的一个方案（优化器认为，有时候不一定最好）</font>。那么确认了执行计划后就准备开始执行了。</li><li>执行语句之前，先进行权限校验，如果没有权限就会返回错误信息。<strong>如果有权限，执行器就会调用存储引擎接口，返回执行结果</strong>。</li></ol><h5 id="22-dml-更新语句"><a class="anchor" href="#22-dml-更新语句">#</a> 2.2、DML 更新语句</h5><blockquote><p>以 update 为例</p></blockquote><p>针对 update 语句：</p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">update</span> tb_student A <span class="token keyword">set</span> A<span class="token punctuation">.</span>age<span class="token operator">=</span><span class="token string">'19'</span> <span class="token keyword">where</span> A<span class="token punctuation">.</span>name<span class="token operator">=</span><span class="token string">' 张三 '</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p><font color="red">这条语句也基本上会沿着上一个查询的流程走，只不过<strong>执行更新的时候肯定要记录日志</strong>，这就会引入日志模块了</font>。</p><p>MySQL 自带的日志模块是 <strong><font color="cornflowerblue">binlog（归档日志）</font></strong>，所有的存储引擎都可以使用。而常用的 InnoDB 引擎还自带了一个日志模块 <strong><font color="cornflowerblue">redo log（重做日志）</font></strong>。</p><p>我们就以 InnoDB 模式下来探讨这个语句的执行流程：</p><ol><li><p><font color="red">先查询到这一条数据</font>（根据 name = 张三），如果有缓存，也是会用到缓存。</p></li><li><p>然后拿到查询的语句，<font color="red">把 age 改为 19</font>，然后<font color="red">调用存储引擎 API 接口，写入这一行数据</font>。InnoDB 引擎把数据保存在内存中，同时 **<font color="red">InnoDB 引擎记录 redo log，此时 redo log 进入 prepare 状态</font>**。然后告诉执行器，执行完成了，随时可以提交。</p></li><li><p><strong><font color="red">执行器收到 InnoDB 引擎的通知后，记录 binlog</font></strong>。然后 **<font color="red">执行器调用引擎接口，提交 redo log 为提交状态</font>**。</p></li><li><p>更新完成。</p></li></ol><hr><p>为什么要用两个日志模块，用一个日志模块不行吗？</p><p>这是因为最开始 MySQL 并没有 InnoDB 引擎（InnoDB 引擎是其他公司以插件形式插入 MySQL 的），MySQL 自带的引擎是 MyISAM。但是我们知道<font color="red"> redo log 是 InnoDB 引擎特有的，其他存储引擎都没有，这就导致会没有 crash-safe 的能力</font>（crash-safe 的能力即使数据库发生异常重启，之前提交的记录都不会丢失），<font color="red">而 binlog 日志只能用来归档</font>。</p><p>并不是说只用一个日志模块不可以，只是 **<font color="red"> InnoDB 引擎就是通过 redo log 来支持事务的</font>**。那么，又会有同学问，我用两个日志模块，但是不要这么复杂行不行，为什么 redo log 要引入 prepare 预提交状态？这里我们用反证法来说明下为什么要这么做？</p><ul><li>先写 redo log 直接提交，然后写 binlog：假设写完 redo log 后，机器挂了，binlog 日志没有被写入，那么机器重启后，这台机器会通过 redo log 恢复数据，但是这个时候 binlog 并没有记录该数据，后续进行机器备份的时候，就会丢失这一条数据，同时主从同步也会丢失这一条数据。</li><li>先写 binlog，然后写 redo log：假设写完了 binlog，机器异常重启了，由于没有 redo log，本机是无法恢复这一条记录的，但是 binlog 又有记录，那么和上面同样的道理，就会产生数据不一致的情况。</li></ul><p><strong><font color="red">redo log 两阶段提交的方式可以保证数据的一致性</font></strong>。写完 binlog 后，然后再提交 redo log 就会防止出现上述的问题，从而保证了数据的一致性。那么问题来了，有没有一个极端的情况呢？<font color="red">假设 redo log 处于 prepare 状态，binlog 也已经写完了，这个时候发生了异常重启会怎么样呢？</font> 这个就要依赖于 MySQL 的处理机制了：</p><ul><li>判断 redo log 是否完整，如果判断是完整的，就立即提交。</li><li>如果 redo log 只是 prepare，但不是 commit 状态，这个时候就会去判断 binlog 是否完整，如果完整就提交 redo log, 不完整就回滚事务。</li></ul><p>这样就解决了数据一致性的问题。</p><h4 id="3-小结"><a class="anchor" href="#3-小结">#</a> 3、小结</h4><ul><li>MySQL 主要分为 <font color="cornflowerblue">Server 层</font>和<font color="cornflowerblue">引擎层</font>，Server 层主要包括<font color="red">连接器、查询缓存、分析器、优化器、执行器</font>，同时还有一个<font color="red">归档日志模块（binlog）</font>，这个日志模块所有执行引擎都可以共用，<font color="red">而重做日志模块（redolog）只有 InnoDB 有</font>。</li><li>Server 层中各组件的功能：<ul><li><strong>连接器</strong>：管理连接、权限验证；</li><li><strong>查询缓存</strong>：命中缓存则直接返回结果；</li><li><strong>分析器</strong>：对 SQL 进行词法分析、语法分析；</li><li><strong>优化器</strong>：执行计划生成、选择索引；</li><li><strong>执行器</strong>：操作引擎、返回结果；</li><li><strong>存储引擎</strong>：存储数据、提供读写接口。</li></ul></li><li>引擎层是插件式的，目前主要包括，<font color="red">MyISAM、InnoDB、Memory</font>等。</li><li><font color="gree">查询语句</font>的执行流程如下：<font color="red">权限校验 ---&gt; 查询缓存（如果命中，直接返回）---&gt; 分析器 ---&gt; 优化器 ---&gt;<strong> 权限校验</strong> ---&gt; 执行器 ---&gt; 引擎</font></li><li><font color="gree">更新语句</font>执行流程如下：<font color="red">分析器 ----&gt; 权限校验 ----&gt; 执行器 ---&gt; 引擎 ---<strong>redo log (prepare 状态)</strong>---&gt;<strong>binlog</strong>---&gt;<strong>redo log (commit 状态)</strong></font></li><li>笼统点的回答，<strong>一条 SQL 的执行过程</strong>：<ol><li>客户端请求 -&gt;</li><li>连接器（验证用户身份，给予权限） -&gt;</li><li>查询缓存（存在缓存则直接返回，不存在则执行后续操作）-&gt;</li><li>分析器（对 SQL 进行词法分析、语法分析） -&gt;</li><li>优化器（选择最优的 SQL 执行方案） -&gt;</li><li>执行器（先检查用户是否有执行权限，有的话才调用引擎接口，执行 SQL）-&gt;</li><li>从引擎层获取数据返回（如果开启查询缓存，则会缓存查询结果）</li></ol></li></ul><h3 id="mysql存储引擎"><a class="anchor" href="#mysql存储引擎">#</a> MySQL 存储引擎</h3><h4 id="mysql-体系结构"><a class="anchor" href="#mysql-体系结构">#</a> MySQL 体系结构</h4><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231125095453053.png" alt="image-20231125095453053"></p><ol><li><p>连接层：负责客户端和连接服务，例如连接处理、授权认证、及相关的安全方案</p></li><li><p>服务层：负责 SQL 接口，SQL 的解析和优化，并完成缓存的查询，部分内置函数的执行。</p><blockquote><p>所有跨存储引擎的功能也在这一层实现，如过程、函数等。</p></blockquote></li><li><p>引擎层：负责 MySQL 中数据的存储和读取，根据需要选择合适的存储引擎，索引就是在这一层实现的。</p></li><li><p>存储层：负责将数据持久化地存储到文件系统中，并完成与存储引擎的交互。</p></li></ol><h4 id="存储引擎介绍"><a class="anchor" href="#存储引擎介绍">#</a> 存储引擎介绍</h4><p>存储引擎的特点：</p><ul><li>存储引擎就是<font color="red">存储数据、<strong>建立索引</strong>、更新 / 查询数据</font>的实现方式。</li><li>存储引擎<font color="red">是基于表的</font>，而不是基于库的。</li><li><font color="red">默认的存储引擎是 InnoDB</font>。</li></ul><p>与存储引擎有关的 SQL 语句：</p><ul><li><p>建表时指定存储引擎：</p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">create</span> <span class="token keyword">table</span> 表名<span class="token punctuation">(</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">)</span> <span class="token keyword">engine</span><span class="token operator">=</span><span class="token keyword">InnoDB</span><span class="token punctuation">;</span></pre></td></tr></table></figure></li><li><p>查询建表语句：</p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">show</span> <span class="token keyword">create</span> <span class="token keyword">table</span> 表名<span class="token punctuation">;</span></pre></td></tr></table></figure></li><li><p>查看当前数据库支持的存储引擎：</p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">show</span> engines<span class="token punctuation">;</span></pre></td></tr></table></figure></li></ul><h4 id="常用的存储引擎"><a class="anchor" href="#常用的存储引擎">#</a> <mark>常用的存储引擎</mark></h4><p>重点介绍三种存储引擎 InnoDB、MyISAM、Memory 的特点。</p><h5 id="innodb"><a class="anchor" href="#innodb">#</a> InnoDB</h5><p>（1）介绍</p><p>MySQL 5.5 版本开始，<strong><font color="red">默认使用 InnoDB 作为存储引擎</font></strong>。它<font color="red">擅长处理事务，具有崩溃恢复的特性</font>，是一种兼顾<font color="red">高可靠性、高性能</font>的通用存储引擎。</p><p>（2）特点</p><ul><li><strong><font color="#B32015">支持事务</font></strong>：<ul><li>DML 操作遵循 ACID 模型</li><li>实现了 SQL 标准定义了<font color="red">四个隔离级别</font>，具有<font color="red">提交 (commit) 和回滚 (rollback) 事务</font>的能力</li><li>提供<font color="red">一组用来记录事务性活动的日志文件</font></li><li>InnoDB 默认使用的 REPEATABLE-READ（可重读）隔离级别是<font color="red">可以解决幻读问题</font>发生的（基于 MVCC 和 Next-Key Lock）</li></ul></li><li><strong><font color="#B32015">支持行级锁</font></strong>：因此 InnoDB <font color="red">并发写的性能更高</font></li><li><strong><font color="#B32015">支持外键</font></strong>：<font color="red">能维护数据的一致性和完整性</font>（级联删除、级联更新），<font color="red">但对性能有一定的损耗</font>。但阿里的《Java 开发手册》明令禁止使用外键！</li></ul><p>（3）存储文件</p><ul><li><code>.sdi</code> ：表结构</li><li><mark><code>.ibd 表空间文件</code> </mark>：数据、索引。每张 InnoDB 表对应一个 .ibd 表空间文件</li></ul><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231125113620280.png" alt="image-20231125113620280"></p><p>（4）逻辑存储结构</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231125111944812.png" alt="image-20231125111944812"></p><ul><li><strong>表空间（Tablespace）</strong>：即<font color="red"> ibd 文件</font>，由多个 Segment 组成</li><li><strong>段（Segment）</strong>：分为<font color="red">数据段、索引段、回滚段</font>等，由 InnoDB 自身管理，由多个 Extent 组成</li><li><strong>区（Extent）</strong>：<font color="red">固定大小为 1M，由 64 个连续的 Page 组成</font></li><li><strong>页（Page）</strong>：<font color="red">固定大小为 16 KB</font>，是 InnoDB 磁盘管理的最小单元</li><li><strong>行（Row）</strong>：<font color="red">存放行记录数据</font>，由最后一次事务的 id、回滚指针、各个字段的值组成</li></ul><h5 id="myisam"><a class="anchor" href="#myisam">#</a> MyISAM</h5><p>（1）介绍</p><p>MyISAM 是 MySQL <font color="red">早期的</font>默认存储引擎。</p><p>（2）特点</p><ul><li>不支持事务与外键，仅支持表级锁</li><li>灵活的 AUTO_INCREMENT 字段处理</li><li>可被转换为压缩、只读表来节省空间</li></ul><p>（3）存储文件</p><ul><li><code>.sdi</code> ：表结构</li><li><code>.MYD</code> ：数据</li><li><code>.MYI</code> ：索引</li></ul><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231125113606459.png" alt="image-20231125113606459"></p><h5 id="memory"><a class="anchor" href="#memory">#</a> Memory</h5><p>（1）介绍</p><p>Memory 引擎表的 **<font color="red">数据存储在内存中</font>**，由于受到硬件问题、或断电问题的影响，只能将这些表作为<font color="red">临时表或缓存</font>使用。</p><p>（2）特点</p><ul><li>数据存放在内存中</li><li>默认采用 <font color="red">hash 索引</font> 结构</li></ul><p>（3）文件</p><ul><li><code>.sdi</code> ：表结构</li></ul><h5 id="特点对比"><a class="anchor" href="#特点对比">#</a> <mark>特点对比</mark></h5><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231125113958109.png" alt="image-20231125113958109"></p><p>MySQL 中常用的三种存储引擎分别是：InnoDB、MyISAM、MEMORY，区别如下：</p><ul><li><font color="cornflowerblue">InnoDB</font>：<strong><font color="red">支持事务处理、行级锁、外键，拥有崩溃修复能力、并发控制</font></strong>。如果需要<font color="red">对事务的完整性要求比较高</font>（比如银行），<font color="red">要求实现并发控制</font>（比如售票），那选择 InnoDB 有很大的优势。如果<font color="red">需要频繁的更新、删除操作</font>的数据库，也可以选择 InnoDB，因为支持事务的提交（commit）和回滚（rollback）。</li><li><font color="cornflowerblue">MyISAM</font>：<strong><font color="red">插入数据快，空间和内存使用比较低</font></strong>。如果表主要是用于<font color="red">插入新记录和读出记录</font>，那么选择 MyISAM 能实现处理高效率。如果应用的<font color="red">完整性、并发性要求比较低</font>，也可以使用。</li><li><font color="cornflowerblue">MEMORY</font>：<strong><font color="red">所有的数据都在内存中，数据的处理速度快，但是安全性不高</font></strong>。如果<font color="red">需要很快的读写速度，对数据的安全性要求较低</font>，可以选择 MEMOEY。它对表的大小有要求，<font color="red">不能建立太大的表</font>。所以，这类数据库只使用在相对较小的数据库表。如果只是<font color="red">临时存放数据，数据量不大，并且不需要较高的数据安全性</font>，可以选择将数据保存在内存中的 Memory 引擎，MySQL 中使用该引擎 **<font color="red">作为临时表，存放查询的中间结果</font>**。</li></ul><h4 id="存储引擎选择"><a class="anchor" href="#存储引擎选择">#</a> 存储引擎选择</h4><ul><li>InnoDB：适用于<font color="red">较多的数据更新操作</font>，对<font color="red">事务、并发、数据完整性</font>要求较高的核心数据。</li><li>MyISAM：适用于<font color="red">大量的数据读操作</font>，常被 MongoDB 取代。</li><li>Memory：因为访问速度快，适用于<font color="red">临时表、缓存</font>，但<font color="red">对表大小有限制</font>（太大的表无法缓存到内存中），并且<font color="red">无法保障数据的安全性</font>，常被 Redis 取代。</li></ul><h4 id="面试题"><a class="anchor" href="#面试题">#</a> 面试题</h4><h5 id="mysql-支持哪些存储引擎默认使用哪个"><a class="anchor" href="#mysql-支持哪些存储引擎默认使用哪个">#</a> MySQL 支持哪些存储引擎？默认使用哪个？</h5><p>MySQL 支持多种存储引擎，你可以通过 <code>show engines</code> 命令来查看 MySQL 支持的所有存储引擎。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20220510105408703.png" alt="查看 MySQL 提供的所有存储引擎"></p><p>从上图我们可以查看出，<strong>MySQL 5.5.5 之后，默认的存储引擎是 InnoDB</strong>。并且，<strong>只有 InnoDB 支持事务、行级锁、外键</strong>。</p><p>MySQL 5.5.5 之前，MyISAM 是 MySQL 的默认存储引擎。5.5.5 版本之后，InnoDB 是 MySQL 的默认存储引擎。</p><h5 id="mysql-存储引擎架构了解吗"><a class="anchor" href="#mysql-存储引擎架构了解吗">#</a> MySQL 存储引擎架构了解吗？</h5><p>MySQL 存储引擎采用的是<strong>插件式架构，支持多种存储引擎</strong>。我们甚至可以为不同的数据库表设置不同的存储引擎以适应不同场景的需要。<strong>存储引擎是基于表的，而不是数据库。</strong></p><h5 id="myisam-和-innodb-有什么区别"><a class="anchor" href="#myisam-和-innodb-有什么区别">#</a> <mark>MyISAM 和 InnoDB 有什么区别？</mark></h5><p>MySQL 5.5 之前，MyISAM 引擎是 MySQL 的默认存储引擎，可谓是风光一时。</p><p>虽然，MyISAM 的性能还行，各种特性也还不错（比如全文索引、压缩、空间函数等）。但是，<strong><font color="red">MyISAM 不支持事务、行级锁和外键，而且最大的缺陷就是崩溃后无法自动恢复数据</font></strong>。</p><p>MySQL 5.5 版本之后，InnoDB 是 MySQL 的默认存储引擎。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231108152443561.png" alt="image-20231108152443561"></p><p>言归正传！咱们下面还是来简单对比一下两者：</p><p><strong>1. 是否支持事务</strong></p><ul><li><p>MyISAM 不支持事务，但<font color="red">每次查询都是原子的</font>；</p></li><li><p>InnoDB 支持 ACID 的事务，实现了四种隔离级别。具有提交 ( <code>commit</code> ) 和回滚 ( <code>rollback</code> ) 事务的能力；</p><blockquote><p>并且 InnoDB 默认的 RR 隔离级别是可以解决幻读问题发生的（基于 MVCC 和 Next-Key Lock）。</p></blockquote></li></ul><p>关于 MySQL 事务的详细介绍：<a href="#==4%E7%A7%8D%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB==">4 种隔离级别</a>。</p><p><strong>2. 是否支持行级锁</strong></p><ul><li>MyISAM 只支持表级锁，即每次操作都是对整个表加锁；</li><li>InnoDB 不仅支持表级锁，<font color="red">还支持行级锁（默认），因此支持并发写</font>；</li></ul><p><strong>3. 是否支持外键</strong></p><ul><li>MyISAM 不支持外键约束；</li><li><font color="red">InnoDB 支持外键约束</font>；</li></ul><p>外键对于维护数据一致性非常有帮助，但是<font color="red">外键对性能有一定的损耗</font>。因此，通常情况下，我们是不建议在实际生产项目中使用外键的，在业务代码中进行约束即可！</p><p><strong>4. 是否存储表的总行数</strong></p><ul><li><font color="red">MyISAM 存储表的总行数</font></li><li>InnoDB 不存储表的总行数</li></ul><p><strong>5. 存储文件</strong></p><ul><li>一个 MyISAM 表有三个文件：表结构文件（.sdi)、数据文件（.MYD）、索引文件（.MYI）</li><li>一个 InnoDB 表有两个文件：表结构文件（.sdi)、<font color="red">数据和索引文件（ <code>.ibd 表空间文件</code> ）</font></li></ul><p><strong>6. 是否采用聚集索引</strong></p><ul><li><font color="red">MyISAM 采用非聚集索引</font>，索引文件的数据域存储的是指向数据文件的指针。辅索引与主索引基本一致，但是辅索引不用保证唯一性；</li><li><font color="red">InnoDB 主键索采用聚集索引（索引的数域存数据文件本身），辅助索引的数域存储主键的值</font>。因此从索引查找数据时，需要先通过辅助索引找到主键值，再访问聚集索引。因此最好使用自增主键，防止插入数据时乱序，导致页分裂，性能低下。</li></ul><p><strong>7. 是否支持数据库异常崩溃后的安全恢复</strong></p><ul><li><p>MyISAM 不支持</p></li><li><p><font color="red">InnoDB 支持数据库异常崩溃后的安全恢复</font></p><blockquote><p>使用 InnoDB 的数据库在异常崩溃后，数据库重新启动时会保证数据库恢复到崩溃前的状态。这个恢复的过程依赖于 InnoDB 的<strong>重做日志模块 <code>redo log</code> </strong>。</p></blockquote></li></ul><p><strong>8. 是否支持 MVCC</strong></p><p><font color="red">MVCC 可以看作是行级锁的一个升级，可以有效减少加锁操作，提高性能</font>。</p><ul><li>MyISAM 不支持，它连行级锁都不支持</li><li><font color="red">InnoDB 支持 MVCC</font></li></ul><p><strong>9. 索引实现不一样</strong></p><p>虽然 MyISAM 引擎和 InnoDB 引擎<font color="red">都是使用 B+Tree 作为索引结构</font>，但是两者的实现方式不太一样。</p><ul><li><p>MyISAM 中，B+Tree 叶节点的 data 域存放的是<font color="gree">数据记录的地址</font>。在索引检索的时候，首先按照 B+Tree 搜索算法搜索索引，如果指定的 Key 存在，则取出其 data 域的值，然后以 data 域的值为地址读取相应的数据记录。这被称为 **<font color="#B32015">非聚集索引</font>**。</p></li><li><p>InnoDB 中，<font color="red">其数据文件本身就是（主）索引文件</font>，按 B+Tree 组织的一个索引结构，树的叶节点中 key 域是主键，data 域是<font color="gree">完整的数据记录</font>，这被称为 **<font color="#B32015">聚集索引</font><strong>。而<font color="red">其余的索引都作为</font></strong>辅助索引 **，树的叶节点中 key 域是非主键字段，data 域存放的是<font color="gree">主键</font>。</p><blockquote><ul><li><p>在根据主索引搜索时，直接找到 key 所在的节点即可取出完整的数据记录；</p></li><li><p>而在根据辅助索引查找时，则需要先取出主键的值，然后再走一遍主索引，称为<strong>二次查询（回表）</strong>。</p></li></ul></blockquote></li></ul><p><strong>10. 性能有差别</strong></p><ul><li><p>MyISAM 的读写不能并发，<font color="red">它的处理能力跟核数没关系</font></p></li><li><p><font color="red">InnoDB 的性能比 MyISAM 更强大</font>，不管是在读写混合模式下还是只读模式下。且随着 CPU 核数的增加，InnoDB 的读写能力呈线性增长。</p></li></ul><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/innodb-myisam-performance-comparison.png" alt="InnoDB 和 MyISAM 性能对比"></p><p><strong>总结</strong> ：</p><ul><li><strong>InnoDB 支持事务处理，而 MyISAM 不支持</strong>。</li><li><strong>InnoDB 支持行级锁，而 MyISAM 只支持表级锁</strong>。</li><li><strong>InnoDB 支持外键，而 MyISAM 不支持</strong>。</li><li><font color="red">InnoDB 支持 MVCC</font>，而 MyISAM 不支持。</li><li>虽然 MyISAM 引擎和 InnoDB 引擎都是使用 B+Tree 作为索引结构，但是<font color="red">两者的索引实现方式不太一样</font>。</li><li><font color="red">InnoDB 支持数据库异常崩溃后的安全恢复</font>，而 MyISAM 不支持。</li><li><font color="red">InnoDB 的性能比 MyISAM 更强大</font>。</li></ul><p>最后，再分享一张图片给你，这张图片详细对比了常见的几种 MySQL 存储引擎。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/comparison-of-common-mysql-storage-engines.png" alt="常见的几种 MySQL 存储引擎对比"></p><h5 id="myisam-和-innodb-如何选择"><a class="anchor" href="#myisam-和-innodb-如何选择">#</a> MyISAM 和 InnoDB 如何选择？</h5><p><strong>大多数情况使用的都是 InnoDB 存储引擎</strong>。在某些读密集的情况下，使用 MyISAM 也是合适的。不过，前提是你的项目不介意<font color="red"> MyISAM 不支持事务、崩溃恢复</font>等缺点（可是～我们一般都会介意啊！）。</p><h3 id="innodb-引擎"><a class="anchor" href="#innodb-引擎">#</a> <mark>🌟InnoDB 引擎</mark></h3><p>从 MySQL 5.5 版本开始默认使用 InnoDB 作为存储引擎，它擅长处理事务，具有自动崩溃恢复的特性，在日常开发中使用非常广泛。</p><h4 id="逻辑存储结构"><a class="anchor" href="#逻辑存储结构">#</a> 逻辑存储结构</h4><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231125111944812.png" alt="image-20231125111944812"></p><ul><li><strong>表空间（Tablespace）</strong>：<ul><li>是 InnoDB 逻辑存储结构的最高层</li><li><font color="red">每张表都有一个对应的表空间</font>（.ibd 文件），前提是用户启用了参数 innodb_file_per_table（在 8.0 版本中默认开启）</li><li>即<font color="red"> ibd 文件</font>，由多个 Segment 组成</li></ul></li><li><strong>段（Segment）</strong>：<ul><li>分为<font color="red">数据段（Leaf node segment）、索引段（Non-leaf node segment）、回滚段（Rollback segment）</font>等</li><li>数据段即 B + 树的叶子节点，索引段即 B + 树的非叶子节点</li><li>由 InnoDB 自身管理，由多个 Extent 组成</li></ul></li><li><strong>区（Extent）</strong>：<ul><li>是表空间的单元结构</li><li><font color="red">固定大小为 1M，由 64 个连续的 Page 组成</font></li></ul></li><li><strong>页（Page）</strong>：<ul><li>是 InnoDB 磁盘管理的最小单元</li><li><font color="red">固定大小为 16 KB</font></li><li>为了保证页的连续性，InnoDB 一次性从磁盘申请 4~5 个区</li></ul></li><li><strong>行（Row）</strong>：<ul><li>InnoDB 的数据是按行存放的，Row 存放的就是<font color="red">行记录数据</font></li><li>组成情况：<ul><li><font color="red">Trx_id</font>：最后一次事务的 id。每次对某行记录改动时，都会把对应的事务 id 赋值给 Trx_id</li><li><font color="red">Roll_pointer</font>：回滚指针。每次对某行记录改动时，都会把旧版本写入 undo 日志中，该列相当于一个指针，指向该记录修改前的信息</li><li><font color="red">各个字段的值</font></li></ul></li></ul></li></ul><h4 id="架构"><a class="anchor" href="#架构">#</a> <mark>🌟架构</mark></h4><h5 id="概述"><a class="anchor" href="#概述">#</a> 概述</h5><p>下面是 InnoDB 架构图，左侧为内存结构，右侧为磁盘结构。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231125133202521.png" alt="image-20231125133202521"></p><h5 id="内存结构"><a class="anchor" href="#内存结构">#</a> 内存结构</h5><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231125133305129.png" alt="image-20231125133305129"></p><h6 id="buffer-pool缓冲池"><a class="anchor" href="#buffer-pool缓冲池">#</a> Buffer Pool（缓冲池)</h6><p>简称 BP，<font color="red">是主内存中的一块区域</font>，<strong><font color="red">作用是缓存表数据与索引</font></strong>。InnoDB 是基于磁盘文件存储的，为了弥补在物理硬盘与内存之间的 IO 访问速度差值，<font color="red">需要把经常使用的数据加载到 BP 中</font>，避免每次访问都进行磁盘 IO。具体地，在执行增删改查时，<font color="red">先操作 BP 中的数据（若无则从磁盘加载并缓存），然后再以一定频率刷新到磁盘</font>，从而减少磁盘 IO，加快处理速度。</p><hr><p><strong><font color="b">Buffer Pool 的组成：</font></strong></p><ul><li><font color="cornflowerblue">缓存页（Page）</font>：用于缓存<font color="red">表数据与索引</font></li><li><font color="cornflowerblue">控制块</font>：用来描述缓存页，与缓存页一一对应。存储着<font color="red">对应缓存页的所属表空间、数据页编号、以及在 Buffer Pool 中的地址</font>等信息。</li></ul><p><font color="red">BP 以 Page 为单位，默认大小是 128 M</font>，Page 默认大小是 16 K，而<font color="red">控制块的大小约为 Page 的 5%，大概是 800 byte</font>。</p><blockquote><p>注：BP 大小为 128M 指的就是缓存页（Page）的大小。而控制块则一般占 5%，所以每次会多申请 6M 的内存空间。</p></blockquote><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/1680014940345-c4b81c48-94d1-46cd-97bd-fa4f242e91cf.jpeg" alt="03.jpg"></p><p>在专用服务器上，通常将多达 80％ 的物理内存分配给 Buffer Pool。可以通过以下参数设置：</p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">show</span> variables <span class="token operator">like</span> <span class="token string">'innodb_buffer_pool_size'</span><span class="token punctuation">;</span></pre></td></tr></table></figure><hr><p><strong><font color="b">如何判断一个页是否缓存在 BP 中？</font></strong></p><p>MySQL 中有一个哈希表数据结构，它的 k-v 结构是<font color="red">（表空间号 + 数据页号，缓冲页对应的控制块）</font>。</p><p>因此，当需要访问某个页的数据时，先从哈希表中根据 表空间号 + 数据页号 看看是否存在对应缓冲页的控制块。</p><ul><li>如果有，则直接使用；</li><li>如果没有，就从<font color="red">free 链表</font>中选出一个空闲的缓冲页，然后把磁盘中对应的页加载到该缓冲页的位置；</li></ul><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/1680015043156-2f7c1410-3f41-4d8f-892c-d8384a8cd752.jpeg" alt="10.jpg" style="zoom:67%"><hr><p><strong><font color="b">Page 分类</font></strong></p><p><font color="red">Buffer Pool 以 Page 为单位</font>，底层采用 <strong><font color="red">链表</font></strong> 来管理 Page。在 InnoDB 访问表记录和索引时会在 Page 中缓存，以后使用时，可以减少磁盘 IO 操作。</p><p>根据状态，将 Page 分为三种类型：</p><ul><li><font color="cornflowerblue">free page</font>：空闲 page，未被使用。</li><li><font color="cornflowerblue">clean page</font>：被使用 page，但<font color="red">数据在刷盘后没有被修改过</font>，与磁盘的数据保持一致。</li><li><strong><font color="cornflowerblue">dirty page</font></strong>：<font color="red">脏页</font>，被使用 page，但<font color="red">数据在刷盘后被修改过</font>，与磁盘的数据产生了不一致。</li></ul><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/1680015221485-20f5036b-94b6-4125-8cf9-304a2deaf4e7.jpeg" alt="05.jpg"></p><hr><p><strong><font color="b">Page 管理</font></strong></p><p>InnoDB 通过三种链表结构来维护和管理上述三类 Page 对应的<font color="red">控制块</font>：</p><ul><li><p><font color="cornflowerblue">free list</font>：**<font color="red">空闲</font>** 缓冲区，管理 free page</p><ul><li>Buffer Pool 的初始化过程中，先向操作系统申请连续的内存空间，然后把它划分成若干个【控制块 &amp; 缓冲页】的键值对</li><li><font color="red">free list 把所有<u>空闲的缓冲页对应的控制块</u>作为一个个的节点放到链表中</font></li><li><font color="red">基节点</font>: free list 中只有一个基节点，它不记录任何缓存页的信息（单独申请空间），只记录当前 free list 的头节点地址、尾节点地址，以及当前 free list 的节点个数</li><li>从磁盘中将数据页进行缓存的流程：<ol><li>从 free list 中取出一个空闲的控制块（对应缓冲页）</li><li>根据数据页所在的表空间、页号之类的信息，填写该控制块的信息</li><li>把该缓冲页对应的 free list 节点（即控制块）从链表中移除，表示该缓冲页已经被使用了</li></ol></li></ul><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/1680015343358-c3d841dd-7c74-4b96-b01f-56109ffa94bc.jpeg" alt="07.jpg"></p></li><li><p><font color="cornflowerblue">flush list</font>：**<font color="red">需要刷盘</font>** 的缓冲区，管理 dirty page，按修改时间排序</p><blockquote><p>注：脏页既存在于 flush list，也在 LRU list 中，但是两种互不影响。<font color="red">LRU list 负责管理 page 的可用性和释放，而 flush list 负责管理脏页的刷盘操作</font>。</p></blockquote><ul><li>InnoDB 为了提高处理效率，在每次修改缓冲页后，并不是立刻把修改刷新到磁盘上，而是在未来的某个时间点进行刷盘操作。</li><li>所以需要使用 flush list 存储脏页，凡是<font color="red"><u>被修改过的缓冲页对应的控制块</u></font>都会作为节点加入到 flush list 中。</li><li>flush list 的结构与 free list 相似</li></ul><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/1680015501833-6f3d1fcb-2894-4f32-b551-fd4495b9788c.jpeg" alt="08.jpg"></p></li><li><p><font color="cornflowerblue">lru list</font>：**<font color="red">正在使用</font>** 的缓冲区，管理 clean page 和 dirty page</p><blockquote><p>有点复杂，略了...</p></blockquote></li></ul><hr><h6 id="change-buffer更改缓冲区"><a class="anchor" href="#change-buffer更改缓冲区">#</a> Change Buffer（更改缓冲区）</h6><blockquote><p>略了...</p></blockquote><p>可以在 Buffer Pool 中进行合并处理，减少磁盘 IO。</p><h6 id="adaptive-hash-index自适应hash索引"><a class="anchor" href="#adaptive-hash-index自适应hash索引">#</a> Adaptive Hash Index（自适应 hash 索引）</h6><blockquote><p>参数：adaptive_hash_index</p></blockquote><p>InnoDB 会监控对表上各索引页的查询，<font color="red">如果观察到 hash 索引可以提升索引页的查询速度，则自动建立 hash 索引</font>，无需人工参与，称之为自适应 hash 索引。</p><ul><li><font color="red">hash 索引的等值匹配性能高于 B + 树的</font>：因为 hash 索引一般只需要一次 IO 即可；而 B + 树，可能需要几次匹配</li><li>但是，<font color="red">hash 索引又不适合做范围查询、模糊匹配等</font></li></ul><h6 id="log-buffer日志缓冲区"><a class="anchor" href="#log-buffer日志缓冲区">#</a> Log Buffer（日志缓冲区）</h6><p>作用：</p><ul><li><p><font color="red">用来保存要写入到磁盘中的日志数据（ <code>redo log</code> 、 <code>undo log</code> ），数据会定期刷新到磁盘中</font>，默认大小为 16MB。如果需要更新、插入或删除许多行的事务，增加日志缓冲区的大小可以节省磁盘 I/O</p></li><li><p>用来优化每次更新操作之后都要写入 redo log 而产生的磁盘 IO 问题</p></li><li><p>Log Buffer 空间满了后会自动写入磁盘。可以通过将 <code>innodb_log_buffer_size</code> 参数调大，以减少磁盘 IO 频率</p></li></ul><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/1680016593449-c23ff9d8-4c0f-48d4-9a55-b66b0a922895.jpeg" alt="14.jpg"></p><h5 id="磁盘结构"><a class="anchor" href="#磁盘结构">#</a> 磁盘结构</h5><blockquote><p>实在是太抽象了，略了。。。</p></blockquote><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231125133316649.png" alt="image-20231125133316649"></p><h6 id="system-tablespace系统表空间"><a class="anchor" href="#system-tablespace系统表空间">#</a> System Tablespace (系统表空间)</h6><h6 id="file-per-table-tablespaces每个表的文件表空间"><a class="anchor" href="#file-per-table-tablespaces每个表的文件表空间">#</a> File-Per-Table Tablespaces（每个表的文件表空间）</h6><h6 id="general-tablespaces通用表空间"><a class="anchor" href="#general-tablespaces通用表空间">#</a> General Tablespaces（通用表空间）</h6><h6 id="undo-tablespaces撤销表空间"><a class="anchor" href="#undo-tablespaces撤销表空间">#</a> Undo Tablespaces（撤销表空间）</h6><h6 id="temporary-tables临时表空间"><a class="anchor" href="#temporary-tables临时表空间">#</a> Temporary Tables（临时表空间）</h6><h6 id="doublewrite-buffer-files双写缓冲区文件"><a class="anchor" href="#doublewrite-buffer-files双写缓冲区文件">#</a> Doublewrite Buffer Files（双写缓冲区文件）</h6><h6 id="redo-log重做日志"><a class="anchor" href="#redo-log重做日志">#</a> Redo Log（重做日志）</h6><h5 id="后台线程"><a class="anchor" href="#后台线程">#</a> 后台线程</h5><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231125133329251.png" alt="image-20231125133329251"></p><h6 id="master-thread核心后台线程"><a class="anchor" href="#master-thread核心后台线程">#</a> Master Thread（核心后台线程）</h6><p><font color="red">负责调度其他线程</font>，还<font color="red">负责将缓冲池中的数据异步刷新到磁盘中</font>，保持数据的一致性，还包括<font color="red">脏页的刷新、合并插入缓存、undo 页的回收</font>。</p><h6 id="io-threadio线程"><a class="anchor" href="#io-threadio线程">#</a> IO Thread（IO 线程）</h6><p>在 InnoDB 存储引擎中大量使用了 AIO 来处理 IO 请求，这样可以极大地提高数据库的性能，而 IO Thread 主要<font color="red">负责这些 IO 请求的回调</font>。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231125150451252.png" alt="image-20231125150451252"></p><h6 id="purge-thread回收线程"><a class="anchor" href="#purge-thread回收线程">#</a> Purge Thread（回收线程）</h6><p>主要用于<font color="red">回收事务已经提交了的 undo log</font>，在事务提交之后，undo log 可能不用了，就用它来回收。</p><h6 id="page-cleaner-thread脏页刷新线程"><a class="anchor" href="#page-cleaner-thread脏页刷新线程">#</a> Page Cleaner Thread（脏页刷新线程）</h6><p>协助 Master Thread <font color="red">刷新脏页</font>到磁盘，可以减轻 Master Thread 的工作压力，减少阻塞。</p><h4 id="事务原理"><a class="anchor" href="#事务原理">#</a> <mark>🌟事务原理</mark></h4><h5 id="事务基础"><a class="anchor" href="#事务基础">#</a> 事务基础</h5><p>关于事务的基础知识，具体可见<a href="#==MySQL%E4%BA%8B%E5%8A%A1=="> MySQL 事务</a>。</p><ul><li><p><strong>原子性</strong>（ <code>Atomicity</code> ）：事务是不可分割的最小操作单元，内部的所有操作要么全部成功，要么全部失败（要么全部 commit 成功，要么全部失败 rollback）；</p></li><li><p><strong>一致性</strong>（ <code>Consistency</code> ）：事务完成前后，数据库必须保持一致状态，即都是合理的数据状态。例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；</p></li><li><p><strong>隔离性</strong>（ <code>Isolation</code> ）：数据库提供的隔离机制，可以保证事务在不受外部并发操作影响的独立环境下运行。即并发访问数据库时，一个事务不会干扰其他事务的运行，该事务所做的修改在最终提交前，对其他事务是不可见的。各并发事务之间，数据库是独立的；</p></li><li><p><strong>持久性</strong>（ <code>Durability</code> ）：事务一旦提交，它对数据库中数据的更改就是持久的。即使数据库发生故障，这种更改也不会丢失。</p></li></ul><p>那么实际上，<font color="red">InnoDB 引擎是如何保证事务的四大特性（ACID）的呢？</font>而对于这四大特性，实际上分为两个部分：</p><ul><li>原子性（A）、一致性（C）、持久性（D）：由 InnoDB 中的 <font color="red">redo log 日志和 undo log 日志</font>来保证</li><li>隔离性（I）：通过数据库的<font color="red">锁和 MVCC</font>来保证的</li></ul><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231125152532382.png" alt="image-20231125152532382"></p><h5 id="redo-log"><a class="anchor" href="#redo-log">#</a> redo log</h5><p>redo log 是重做日志，<strong><font color="red">记录事务提交时数据页的物理修改</font></strong>。当刷新脏页到磁盘发生错误时，进行数据恢复，用来实现事务的持久性。由两部分组成：</p><ul><li><font color="cornflowerblue">redo log buffer</font>：<font color="red">在内存中</font>的缓冲区</li><li><font color="cornflowerblue">redo log file</font>：<font color="red">在磁盘中</font>的文件</li></ul><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/1680016593449-c23ff9d8-4c0f-48d4-9a55-b66b0a922895.jpeg" alt="14.jpg"></p><p><img data-src="https://oss.javaguide.cn/github/javaguide/03.png" alt="img"></p><hr><p><strong><font color="b">如果没有 redo log，可能会存在什么问题？</font></strong></p><p>在 InnoDB 中的内存结构中，主要的内存区域就是 Buffer Pool（缓冲池），在缓冲池中缓存了很多的数据页。</p><p>当我们在一个事务中，执行多个增删改的操作时，InnoDB 会先操作缓冲池中的数据，如果缓冲区没有对应的数据，会通过后台线程将磁盘中的数据加载到缓冲区中，然后修改缓冲池中的数据，修改后的数据页我们称为<font color="red">脏页</font>。而脏页则会在一定的时机，通过后台线程刷新到磁盘中，从而保证缓冲区与磁盘的数据一致。</p><p>但缓冲区的脏页数据并不是实时刷新的，而是一段时间之后将缓冲区的数据刷新到磁盘中，<font color="red">假如将脏页刷盘的过程出错了，但提示给用户事务提交成功，而数据却没有持久化下来，这就出现问题了，<strong>没有保证事务的持久性</strong></font>。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231126165158628.png" alt="image-20231126165158628"></p><p><strong><font color="b">redo log 是如何确保事务的持久性的？</font></strong></p><p>有了 redo log 之后，</p><ul><li><font color="red">当对缓冲区的数据进行增删改之后，会首先将对缓冲页的变化记录在 <code>redo log buffer</code> 中</font></li><li><font color="red">在<u>每次</u>事务提交时，会将内存中的  <code>redo log buffer</code> 的数据刷新到磁盘文件  <code>redo log file</code> 中</font></li><li>过一段时间之后，<strong><font color="red">如果刷新缓冲区的脏页到磁盘时发生错误，此时就可以借助于 redo log 进行数据恢复，这样就保证了事务的持久性</font></strong></li><li>而<font color="red">如果脏页成功刷新到磁盘，或者涉及到的数据已经落盘，此时 redo log 就可以删除了，所以存在的两个 redo log 文件是循环写的</font></li></ul><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231126165234873.png" alt="image-20231126165234873"></p><p><strong><font color="b">为什么每次提交事务，要刷新 redo log 到磁盘中，而不是直接将 buffer pool 中的脏页刷新到磁盘呢？</font></strong></p><p>因为在业务操作中，我们<font color="red">操作数据一般都是随机读写磁盘的</font>，而不是顺序读写磁盘。 而 redo log 在向磁盘文件中写入数据，<font color="red">日志文件都是顺序写的</font>。<strong><font color="red">顺序写的效率，要远大于随机写</font></strong>。这种<font color="red">先写日志的方式</font>，称之为 <code>WAL（Write-Ahead Logging）</code> 。</p><hr><h5 id="undo-log"><a class="anchor" href="#undo-log">#</a> undo log</h5><p>undo log（回滚日志）是在执行 DML 语句的时候产生的便于数据回滚的日志，用于<font color="red">记录数据被修改前的信息</font>。</p><p>与 redo log 记录物理日志不一样，<font color="red">undo log 是逻辑日志，记录的是逻辑相反的操作信息</font>。可以认为当 delete 一条记录时，undo log 中会记录一条对应的 insert 记录；反之亦然，当 update 一条记录时，它记录一条对应相反的 update 记录。<font color="red">当执行 rollback 时，就可以从 undo log 中的逻辑记录读取到相应的内容并进行回滚</font>。</p><p>undo log 主要有两个作用：</p><ol><li><p><strong><font color="red">提供事务回滚（保证事务的原子性）</font></strong>：当事务回滚时将数据恢复到修改前的样子</p></li><li><p><strong><font color="red">MVCC（多版本并发控制）</font></strong>：当读取记录时，若该记录被其他事务占用，或者当前版本对该事务不可见，则可以通过 undo log <font color="red">读取之前的版本数据</font>，以此实现非锁定读</p></li></ol><p>undo log 销毁：undo log 在事务执行时产生，事务提交时，并不会立即删除 undo log，因为这些日志可能还用于 MVCC。</p><p>undo log 存储：undo log 采用段的方式进行管理和记录，存放在前面介绍的 rollback segment 回滚段中，内部包含 1024 个 undo log segment。</p><h5 id="innodb-如何实现事务"><a class="anchor" href="#innodb-如何实现事务">#</a> <mark>🌟InnoDB 如何实现事务</mark></h5><p>InnoDB 通过 Buffer Pool、Log Buffer、Redo Log、Undo Log 来实现事务，以一条 update 语句为例：</p><ol><li><p>InnoDB 在收到一条 update 语句后，会先根据条件找到数据所在的页，并将该页缓存在 <code>Buffer Pool</code> 中</p></li><li><p>针对 update 语句生成 <code>Undo Log</code> 日志，用于后续事务回滚</p></li><li><p><code>执行器</code> 执行 update 语句，修改 Buffer Pool 中的数据，即内存中的数据</p></li><li><p>针对 update 语句生成一个 <code>Redo Log</code> 对象，并写入 <code>Log Buffer</code> 中</p></li><li><p>如果事务提交，那么将 Log Buffer 中的 Redo Log 对象持久化到磁盘中的 <code>Redo Log File</code> 中</p><blockquote><p>后续还有其他机制将 Buffer Pool 中所修改的数据页持久化到磁盘中（脏页刷盘）</p></blockquote></li><li><p>如果事务回滚，则利用 Undo Log 日志进行回滚</p></li></ol><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/1680016593449-c23ff9d8-4c0f-48d4-9a55-b66b0a922895.jpeg" alt="14.jpg"></p><h4 id="对-mvcc-的实现方式"><a class="anchor" href="#对-mvcc-的实现方式">#</a> <mark>🌟对 MVCC 的实现方式</mark></h4><h5 id="innodb-为什么要采用-mvcc快照读"><a class="anchor" href="#innodb-为什么要采用-mvcc快照读">#</a> <mark>🌟InnoDB 为什么要采用 MVCC 快照读 ？</mark></h5><p>这是因为一个事务的操作有可能成功 commit，也有可能失败 rollback。在一个事务 commit 之前，被其他事务读到还没提交的变更记录，会产生数据不一样的现象（<font color="red">脏读</font>），这种情况就是 InnoDB 最低的隔离级别 READ UNCOMMITTED，可以读到没有 commit 的数据。</p><p><font color="red">那么如果想要不产生脏读，容易想到的是采用锁的方式</font>，当一个事务更改某行记录，就加上锁，其他并发事务等待该事务执行完毕才能读取到该行记录。但是这样做的话 **<font color="red">会产生大量的锁占用与等待，效率是非常低下的，因此 InnoDB 采用了 MVCC 的方式</font>**。</p><p>简单的说，在 RU 隔离级别下，若 A 事务变更某行记录，InnoDB 会产生对应的 undo log，如果接下来 A 事务进行回滚，InnoDB 可以根据 undo log 将记录回滚到事务开始之前的状态。在 A 事务没有结束时，如果 B 事务来查询该行记录，B 事务会根据 A 事务变更后的记录值（在内存中）加上 undo log “计算” 出 A 事务开始前的该行记录值，从而读取到该行记录的一个快照，其中<font color="red">并不会产生锁与等待</font>。</p><p>如果是 RR 的隔离级别（默认隔离级别），B 事务进行过程中看到的始终会是 B 事务开始前的记录行快照信息，不管 B 事务进行过程中 A 事务有没有完成；</p><p>如果是 RC 的隔离级别，B 事务进行过程中，可以看到 A 事务提交对记录行修改值（即如果 A 事务没有完成，B 查询到的是 A 事务开始前的记录值，如果 A 事务完成了，B 事务查询到的是 A 事务完成后的记录值），在这种情况下会产生不可重复读的现象，即同一次事务中多次查询看到的结果会不一样。</p><h5 id="基本概念"><a class="anchor" href="#基本概念">#</a> 基本概念</h5><h6 id="快照读一致性u非锁定读u"><a class="anchor" href="#快照读一致性u非锁定读u">#</a> 快照读（一致性<u>非锁定读</u>）</h6><p>就是<font color="red">简单的 <code>SELECT</code> 语句（不加锁）</font>，是非阻塞读。</p><p><font color="red">快照即记录的历史版本</font>，每行记录可能存在多个历史版本（多版本技术），读取的是记录数据的可见版本。</p><p>快照读的情况下，如果读取的记录正在执行 UPDATE/DELETE 操作，<font color="red">读取操作不会因此去等待记录上 X 锁的释放，而是会去读取行的一个快照（历史数据）</font>。</p><p>只有在事务隔离级别 RC (读取已提交) 和 RR（可重读）下，InnoDB 才会使用快照读（一致性非锁定读）：</p><ul><li><font color="gree">在 RC 级别下</font>，快照读总是<font color="red">读取被锁定行的最新一份快照数据</font>。</li><li><font color="gree">在 RR 级别下</font>，快照读总是 **<font color="red">读取本事务开始时的行数据版本（快照）</font>**。</li><li><font color="gree">在 SERIALIZABLE 级别下</font>，<font color="red">快照读退化成当前读</font>。</li></ul><p>快照读比较<font color="red">适合对数据一致性要求不是特别高，且追求极致性能的业务场景</font>。</p><hr><p>对于快照读的实现，通常做法是加一个 **<font color="red">版本号或者时间戳字段</font>**，</p><ul><li>更新数据时，<font color="red">版本号 + 1 或者更新时间戳</font>。</li><li>查询数据时，将当前可见的版本号与对应记录的版本号进行比对，<font color="red">如果记录的版本小于可见版本，则表示该记录可见</font></li></ul><p>在 InnoDB 中，<font color="cornflowerblue">多版本控制（multi versioning）</font>就是对快照读的实现。如果读取的行正在执行 <code>DELETE</code> 或 <code>UPDATE</code> 操作，这时读取操作不会去等待行上 X 锁的释放。相反地，InnoDB 会去读取行的一个快照数据，对于这种读取历史数据的方式，我们叫它快照读（snapshot read）。</p><h6 id="当前读一致性u锁定读u"><a class="anchor" href="#当前读一致性u锁定读u">#</a> 当前读（一致性<u>锁定读</u>）</h6><p><font color="red">读取行记录时会添加 X 锁或 S 锁</font>，以防其他并发事务修改当前记录，因此 **<font color="red">读取的是记录的最新版本</font>**，是悲观锁的一种操作。</p><ul><li><code>select ... lock in share mode</code> ：对记录加 <code>S</code> 锁，其它事务也可以加 <code>S</code> 锁，但如果加 <code>X</code> 锁则会被阻塞</li><li><code>select ... for update</code> 、 <code>insert</code> 、 <code>update</code> 、 <code>delete</code> ：对记录加 <code>X</code> 锁，且其它事务不能加任何锁</li></ul><p>当前读的一些常见 SQL 语句类型如下：</p><blockquote><p><code>select ... for update</code> 仅适用于 InnoDB，且必须在事务块 (BEGIN/COMMIT) 中才能生效。在进行事务操作时，通过 for update 语句，MySQL 会对查询结果集中每行数据都添加 **<font color="#B32015">排他锁</font>**，<font color="red">其他线程对该记录的更新与删除操作都会阻塞</font>。排他锁包含行锁、表锁。</p><p>InnoDB 行锁是通过给索引上的索引项加锁来实现的，只有通过索引条件检索数据，InnoDB 才使用行级锁，否则，InnoDB 将使用表锁。</p><p><code>select ... for share</code> ：我选择一些记录，这些记录可以 share，<font color="red">其他事务也可以读</font>，但是如果你要修改，不好意思，我加了一个 s 锁，你是<font color="red">不可以修改</font>的。这个语句的应用场景之一是 **<font color="red">用来读取到最新的数据</font>**。</p><p><code>select ... for update</code> ：我选择一些记录，这些 select 的记录是我下一步要 update 的，你要读或者修改这些记录，不好意思，我加的是 x 锁，你<font color="red">读不了也改不了</font>。只有我当前事务提交了，这些记录你才可以读到或者修改。这个语句的应用场景之一是 **<font color="red">为了防止更新丢失</font>**。</p></blockquote><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment"># 对读的记录加一个 S 锁（MySQL 5.7 和 MySQL 8.0）</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">SELECT</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">LOCK</span> <span class="token operator">IN</span> <span class="token keyword">SHARE</span> <span class="token keyword">MODE</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment"># 对读的记录加一个 S 锁（MySQL 8.0）</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">SELECT</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">FOR</span> <span class="token keyword">SHARE</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token comment"># 对读的记录加一个 X 锁</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">SELECT</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">FOR</span> <span class="token keyword">UPDATE</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token comment"># 对修改的记录加一个 X 锁</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">INSERT</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token keyword">UPDATE</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token keyword">DELETE</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr></table></figure><hr><p>在快照读下，即时读取的记录已被其它事务加上 <code>X</code> 锁，这时记录也是可以被读取的，即读取的快照数据。上面说了，在 RR 隔离级别下 MVCC 防止了部分幻读。这里的 “部分” 是指在 <code>快照读</code> 情况下，只能读取到第一次查询之前所插入的数据（根据 Read View 判断数据可见性，Read View 在第一次查询时生成）。</p><p>但是！<font color="red">如果是 <code>当前读</code> ，每次读取的都是最新数据，这时如果两次查询中间有其它事务插入数据，就会产生幻读</font>。</p><p>所以，<strong><font color="#B32015">InnoDB 在实现 RR 隔离级别时，如果执行的是 <code>当前读</code> ，则会对读取的记录使用 <code>临键锁（Next-key Lock）</code> ，来防止其它并发事务在间隙间插入数据</font></strong>。</p><hr><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231127104552414.png" alt="image-20231127104552414"></p><p>在测试中，即使是在默认的 RR 隔离级别下，事务 A 中依然可以读取到事务 B 最新提交的内容，因为在查询语句后面加上了 <code>lock in share mode</code> 共享锁，此时是当前读操作。当然，当我们加排他锁的时候，也是当前读操作。</p><h6 id="mvcc多版本并发控制"><a class="anchor" href="#mvcc多版本并发控制">#</a> MVCC（多版本并发控制）</h6><p>MVCC 的全称是 <code>Multi-Version Concurrency Control</code> ，是一种并发控制机制，用于在多个并发事务同时读写数据库时保持数据的一致性和隔离性。<strong><font color="#B32015">MVCC 在每个数据行上维护多个版本的数据，形成一条由 undo log 组成的版本链</font></strong>，使得读写操作没有冲突。</p><p>MVCC 解决的问题：<strong><font color="#B32015">读 — 写冲突的无锁并发控制</font></strong>。为事务分配单向增长的时间戳，为每个数据修改保存一个版本（与事务时间戳相关联）。读操作只读取该事务开始前的数据库快照。</p><ul><li><p><font color="red">能解决并发读 - 写问题</font>：可以做到读操作不阻塞写操作，同时写操作也不会阻塞读操作</p></li><li><p><font color="red">能解决脏读、幻读、不可重复读</font>等一致性问题，但<font color="red">不能解决写 - 写中的修改丢失问题</font>。</p></li></ul><hr><p>1、读操作（SELECT）：</p><p>当一个事务执行读操作时，它会使用<font color="red">快照读取</font>。<strong><font color="red">在 InnoDB 默认的 RR 隔离级别下，快照读取是基于事务开始时数据库中的状态创建的</font></strong>，因此事务不会读取到其他事务尚未提交的修改。具体工作情况如下：</p><blockquote><p>在 RR 级别下</p></blockquote><ul><li>对于读取操作，事务会查找符合条件的数据行，并选择符合事务开始时间的数据版本进行读取。</li><li>如果某个数据行有多个版本，事务会<font color="red">选择不晚于事务开始时间的最新版本</font>，确保事务只读取在它开始之前已经存在的数据。</li><li><font color="red">事务读取的是快照数据，因此其他并发事务对数据行的修改不会影响当前事务的读取操作，当前事务对快照数据的修改也不会影响实际的数据行</font>。</li></ul><p>2、写操作（INSERT、UPDATE、DELETE）：</p><p><strong><font color="red">当一个事务执行写操作时，它会为要修改的数据行创建一个新的版本（快照数据），对其修改后再写入数据库</font></strong>。具体工作情况如下：</p><ul><li>对于写操作，事务会为要修改的数据行创建一个新的版本，并将修改后的数据写入新版本。</li><li><font color="red">新版本的数据会带有当前事务的版本号</font>，以便其他事务能够正确读取相应版本的数据。</li><li><font color="red">原始版本的数据仍然存在，供其他事务使用快照读取，这保证了其他事务不受当前事务的写操作影响</font>。</li></ul><p>3、事务的提交和回滚（COMMIT、ROLLBACK）：</p><ul><li>当一个事务提交时，它所做的修改将成为数据库的最新版本，并且对其他事务可见。</li><li>当一个事务回滚时，它所做的修改将被撤销，对其他事务不可见。</li></ul><p>4、版本的回收：</p><p><font color="red">为了防止数据库中的版本无限增长，MVCC 会定期进行版本的回收。回收机制会删除已经不再需要的旧版本数据，从而释放空间</font>。</p><p><strong><font color="#B32015">MVCC 通过<u>创建数据的多个版本</u>和使用<u>快照读取</u>来实现并发控制</font></strong>。<font color="red">读操作使用旧版本数据的快照，写操作创建新版本，并确保原始版本仍然可用</font>。这样，不同的事务可以在一定程度上并发执行，而不会相互干扰，从而提高了数据库的并发性能和数据一致性。</p><h5 id="innodb-对-mvcc-的实现方式"><a class="anchor" href="#innodb-对-mvcc-的实现方式">#</a> <mark>🌟InnoDB 对 MVCC 的实现方式</mark></h5><p>InnoDB 对 MVCC 的具体实现依赖于：<strong>隐藏字段、ReadView、undo log</strong>。</p><ul><li>在内部实现中，InnoDB 通过数据行的 <code>DB_TRX_ID</code> 和 <code>ReadView</code> 来判断数据的可见性。</li><li>如不可见，则通过数据行的 <code>DB_ROLL_PTR</code> 找到 <code>undo log</code> 中的历史版本。</li><li>每个事务读到的数据版本可能是不一样的，在同一个事务中，用户只能看到该事务创建 <code>ReadView</code> 之前已经提交的修改和该事务本身做的修改。</li></ul><blockquote><p>这里看不懂没关系，先看下文</p></blockquote><h6 id="隐藏字段"><a class="anchor" href="#隐藏字段">#</a> 隐藏字段</h6><p>InnoDB 为每行记录添加了三个隐藏字段：</p><blockquote><p>前两个字段是肯定会添加的，是否添加最后一个字段 DB_ROW_ID，得看当前表有没有主键或者唯一非空索引，若有则不会添加该隐藏字段。</p></blockquote><ul><li><p><code>DB_TRX_ID</code> （6 字节）：<font color="red">插入这行记录或者最后一次修改该记录的事务 id</font>；</p><blockquote><p>delete 操作在内部被视为更新（即逻辑删除），会在记录头 Record header 中的 deleted_flag 字段将其标记为已删除</p></blockquote></li><li><p><code>DB_ROLL_PTR</code> （7 字节）：<font color="red">回滚指针，指向该行对应的 undo log，即上一个版本（存于回滚段中）</font></p><blockquote><p>如果该行记录未被更新，则为空；</p></blockquote></li><li><p><code>DB_ROW_ID</code> （6 字节）：<font color="red">当前行记录隐含的自增 ID</font>，如果当前表没有设置主键且没有唯一非空索引时，InnoDB 会使用 DB_ROW_ID 来<strong>生成一个聚集索引</strong>；</p></li></ul><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/816762-20210616144139574-1740941399.jpg" alt="img"></p><p>如上图，DB_ROW_ID 是数据库默认为该行记录生成的唯一隐式主键，DB_TRX_ID 是当前操作该记录的事务 ID，而 DB_ROLL_PTR 是一个回滚指针，用于配合 undo log，指向上一个旧版本。</p><h6 id="undo-log-2"><a class="anchor" href="#undo-log-2">#</a> undo log</h6><p><strong><font color="b">undo log 介绍</font></strong></p><p>undo log（回滚日志）是在执行 DML 语句的时候产生的便于数据回滚的日志，用于<font color="red">记录数据被修改前的信息</font>。</p><p>与 redo log 记录物理日志不同，<font color="red">undo log 是逻辑日志，记录的是逻辑相反的操作信息</font>。因此当执行 rollback 时，就可以直接从 undo log 中的逻辑记录读取到相应的内容并进行回滚。</p><p>undo log 主要有两个作用：</p><ol><li><p><strong><font color="red">提供事务回滚（保证事务的原子性）</font></strong>：当事务回滚时将数据恢复到修改前的样子</p></li><li><p><strong><font color="red">MVCC（多版本并发控制）</font></strong>：当读取记录时，若该记录被其他事务占用，或者当前版本对该事务不可见，则可以通过 undo log <font color="red">读取之前的版本数据</font>，以此实现非锁定读</p></li></ol><p>在 InnoDB 中 undo log 分为两种：</p><ul><li><p><code>insert undo log</code> ：在<font color="red"> insert 操作</font>中产生的 undo log。因为 insert 操作的记录只对事务本身可见，只在回滚时需要，因此<font color="red"> insert undo log 在事务提交后可以直接删除，不需要进行 purge 操作</font>。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/317e91e1-1ee1-42ad-9412-9098d5c6a9ad-dc43aed3.png" alt="img"></p><center>（insert 时的数据初始状态）</center></li><li><p><code>update undo log</code> ：<font color="red">update 或 delete 操作</font>中产生的 undo log。update undo log 不仅在回滚时需要，可能需要提供 MVCC 机制，因此不能在事务提交时就进行删除。<font color="red">事务提交时放入 undo log 链表，等待 purge 线程进行最后的删除</font>。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/c52ff79f-10e6-46cb-b5d4-3c9cbcc1934a-b60a6e78.png" alt="img"></p><center>（数据第一次被修改时）</center><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/6a276e7a-b0da-4c7b-bdf7-c0c7b7b3b31c-2e496ea1.png" alt="img"></p><center>（数据第二次被修改时）</center></li></ul><hr><p><strong><font color="b">版本链</font></strong></p><p><strong><font color="red">不同事务或者相同事务对同一记录行的修改，会使该记录行的 undo log 成为一条链表，链首就是最新的记录，链尾就是最早的旧记录</font></strong>。</p><p>有一张表原始数据为：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231128102126782.png" alt="image-20231128102126782"></p><blockquote><p><code>DB_TRX_ID</code> ：代表最近修改事务 ID，记录插入这条记录或最后一次修改该记录的事务 ID，是自增的。<br><code>DB_ROLL_PTR</code> ：由于这条数据是刚刚才插入的，没有被更新过，所以该字段值为 null。</p></blockquote><p>然后，有四个并发事务同时在访问这张表。</p><p>A. 第一步：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231128102320440.png" alt="image-20231128102320440"></p><p>当事务 2 执行第一条修改语句时：</p><ol><li>先记录 undo log 日志，记录数据变更之前的样子；</li><li>然后更新记录，并且记录本次操作的事务 ID 与回滚指针。其中回滚指针用来指定如果发生回滚，回滚到哪一个版本；</li></ol><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231128102520925.png" alt="image-20231128102520925"></p><p>B. 第二步</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231128102822352.png" alt="image-20231128102822352"></p><p>当事务 3 执行第一条修改语句时：</p><ol><li>先记录 undo log 日志，记录数据变更之前的样子；</li><li>然后更新记录，并且记录本次操作的事务 ID 与回滚指针；</li></ol><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231128103013206.png" alt="image-20231128103013206"></p><p>C. 第三步</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231128103104640.png" alt="image-20231128103104640"></p><p>当事务 4 执行第一条修改语句时：</p><ol><li>先记录 undo log 日志，记录数据变更之前的样子；</li><li>然后更新记录，并且记录本次操作的事务 ID 与回滚指针；</li></ol><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231128103205546.png" alt="image-20231128103205546"></p><h6 id="read-view"><a class="anchor" href="#read-view">#</a> Read View</h6><p>Read View 说白了就是<font color="red">事务进行快照读操作时产生的读视图</font>。在该事务执行快照读的那一刻，会生成一个当前数据库系统的快照，该快照记录并维护了系统当前活跃事务的 ID（当每个事务开启时，都会被分配一个 ID, 这个 ID 是递增的，所以最新的事务，ID 值越大）。</p><p>Read View 是用来做 **<font color="red">可见性判断</font><strong>的，里面保存了</strong><font color="red">当前对本事务不可见的其他活跃的（未提交的）事务</font>**。当某个事务执行快照读的时候，会对该记录创建一个 Read View，把它比作条件<font color="red">用来判断当前事务能够看到哪个版本的数据</font>，既可能是当前最新的数据，也有可能是该行记录在 undo log 里面的某个版本的数据。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">ReadView</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  <span class="token comment">/* ... */</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">private</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="4"></td><td><pre>  trx_id_t m_low_limit_id<span class="token punctuation">;</span>      <span class="token comment">/* 表示目前出现过的最大的事务 ID + 1，大于等于这个 ID 的事务均不可见 */</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre>  trx_id_t m_up_limit_id<span class="token punctuation">;</span>       <span class="token comment">/* 表示活跃事务列表 m_ids 中最小的事务 ID，小于这个 ID 的事务均可见 */</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre>  trx_id_t m_creator_trx_id<span class="token punctuation">;</span>    <span class="token comment">/* 创建该 Read View 的事务 ID */</span></pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre>  trx_id_t m_low_limit_no<span class="token punctuation">;</span>      <span class="token comment">/* 事务 Number, 小于该 Number 的 Undo Logs 均可以被 Purge */</span></pre></td></tr><tr><td data-num="11"></td><td><pre></pre></td></tr><tr><td data-num="12"></td><td><pre>  ids_t m_ids<span class="token punctuation">;</span>                  <span class="token comment">/* 创建 Read View 时的活跃事务列表 */</span></pre></td></tr><tr><td data-num="13"></td><td><pre></pre></td></tr><tr><td data-num="14"></td><td><pre>  m_closed<span class="token punctuation">;</span>                     <span class="token comment">/* 标记 Read View 是否 close */</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>主要有以下字段：</p><ul><li><p><code>m_ids</code> ：<font color="red">ReadView 创建时，其他活跃的（即未提交的）事务 ID 列表</font>。创建 ReadView 时，将当前所有未提交的事务的 ID 记录下来，后续即使它们修改了行记录的值，对于当前事务也是不可见的</p><blockquote><p>不包括当前事务自己和已提交的事务（正在内存中）</p></blockquote></li><li><p><code>m_low_limit_id</code> ：<font color="red">目前出现过的最大的事务 ID + 1</font>，即下一个将被分配的事务 ID</p><blockquote><p>大于等于这个 ID 的数据版本均不可见</p></blockquote></li><li><p><code>m_up_limit_id</code> ：<font color="red">活跃事务列表 m_ids 中最小的事务 ID</font>，如果 m_ids 为空，则 <code>m_up_limit_id = m_low_limit_id</code></p><blockquote><p>小于这个 ID 的数据版本均可见</p></blockquote></li><li><p><code>m_creator_trx_id</code> ：<font color="red">创建该 ReadView 的事务 ID</font></p></li></ul><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/trans_visible-048192c5.png" alt="trans_visible"></p><center>事务可见性示意图</center><h6 id="数据可见性算法"><a class="anchor" href="#数据可见性算法">#</a> 数据可见性算法</h6><p>在 InnoDB 中，<font color="red">创建一个新事务后，执行每个 select 语句前，都会创建一个 Read View</font>。<strong><font color="#B32015">Read View 中保存了当前数据库系统中正处于活跃（即没有 commit）的事务的 ID 号</font></strong>。</p><p>简单的说，保存的是系统中当前不应该被本事务看到的其他事务的 ID 列表（即 m_ids）。<font color="red">当用户在本事务中要读取某个记录行的时候，InnoDB 会将该记录行的 <code>DB_TRX_ID</code> 与 Read View 中的一些变量及当前事务 ID 进行比较，判断是否满足可见性条件</font>。具体的比较算法如下：</p><blockquote><p>参与比较的对象：</p><ol><li><code>DB_TRX_ID</code> ：<font color="red">表示插入这行记录或者最后一次修改该行记录的事务 id</font></li><li><code>m_creator_trx_id</code> ：<font color="red">表示创建该 ReadView 的事务 ID</font></li><li><code>m_up_limit_id</code> ：ReadView 中的一个变量，<font color="red">表示活跃事务列表 m_ids 中最小的事务 ID</font>。事务 ID 小于它的事务均已提交，因此小于这个 ID 的数据版本均可见</li><li><code>m_low_limit_id</code> ：ReadView 中的一个变量，表示下一个将被分配的事务 ID，即<font color="red">目前出现过的最大的事务 ID + 1</font>。事务 ID 大于它的事务均未提交，因此大于等于这个 ID 的数据版本均不可见</li></ol></blockquote><p><code>changes_visible()</code> 返回 true 代表可见， false 代表不可见。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231128104943951.png" alt="image-20231128104943951"></p><table><thead><tr><th>步骤</th><th>条件</th><th>是否可以访问该版本</th><th>说明</th></tr></thead><tbody><tr><td>0</td><td>DB_TRX_ID == m_creator_trx_id</td><td>可见</td><td>表明最新修改该行记录的事务（DB_TRX_ID）就是创建 ReadView 的当前事务！</td></tr><tr><td>1</td><td>DB_TRX_ID &lt; m_up_limit_id</td><td>可见</td><td>表明最新修改该行记录的事务（DB_TRX_ID）在<u>当前事务</u>创建 ReadView 之前就提交了，因此该行记录的值对当前事务是可见的。</td></tr><tr><td>2</td><td>DB_TRX_ID &gt;= m_low_limit_id</td><td>不可见</td><td>表明最新修改该行的事务（DB_TRX_ID）在<u>当前事务</u>创建 ReadView 之后才修改该行，所以该记录行的值对当前事务不可见。<font color="red">跳到步骤 5</font></td></tr><tr><td>3</td><td>m_ids 为空</td><td>可见</td><td>说明当前不存在活跃的事务，表明在当前事务创建 ReadView 之前，修改该行的事务就已经提交了，所以该记录行的值对当前事务是可见的</td></tr><tr><td>4</td><td>m_up_limit_id &lt;= DB_TRX_ID &lt; m_low_limit_id</td><td>1. 如果 DB_TRX_ID 在 m_ids 中，不可见；<br>2. 如果 DB_TRX_ID 不在 m_ids 中，可见；</td><td>表明最新修改该行的事务（DB_TRX_ID）在<u>当前事务</u>创建 ReadView 的时候可能处于 “活动状态” 或者 “已提交状态”，因此就要对活跃事务列表 m_ids 进行查找，分为两种情况：<br>1. 如果在活跃事务列表 m_ids 中能找到 DB_TRX_ID，表明：① 在当前事务创建 ReadView 前，该记录行的值被事务 ID 为 DB_TRX_ID 的事务修改了，但没有提交；或者 ② 在当前事务创建 ReadView 后，该记录行的值被事务 ID 为 DB_TRX_ID 的事务修改了。这些情况下，这个记录行的值对当前事务都是不可见的。<font color="red">跳到步骤 5</font><br>2. 在活跃事务列表中找不到，则表明 “id 为 DB_TRX_ID 的事务” 在修改 “该记录行的值” 后，在 “当前事务” 创建 ReadView 前就已经提交了，所以记录行对当前事务可见</td></tr><tr><td>5</td><td></td><td></td><td>在该行记录的 DB_ROLL_PTR 指针所指向的 undo log 取出快照记录，用其中的 DB_TRX_ID <font color="red">跳到步骤 1</font> 重新开始判断，直到找到满足的快照版本或返回空</td></tr></tbody></table><h5 id="rc-和-rr-下-mvcc-的差异"><a class="anchor" href="#rc-和-rr-下-mvcc-的差异">#</a> <mark>🌟RC 和 RR 下 MVCC 的差异</mark></h5><p>在事务隔离级别 RC 和 RR 下，虽然 InnoDB 都通过 MVCC 来读取快照数据（一致性非锁定读），但它们<font color="red">生成 ReadView 的时机不同</font>：</p><ul><li>RC：<strong>在事务中的<font color="red">每一次执行快照读时</font>，都会生成并设置新的 Read View，所以会导致不可重复读</strong>！</li><li>RR：<strong>仅在事务中的<font color="red">第一次执行快照读时</font>，生成一个 Read View（m_ids 列表），后续复用该 ReadView。<font color="red">因此在一个事务中，执行两次相同的 select 语句，查询到的结果是一样的</font></strong>。</li></ul><h6 id="rc-下-readview-的生成情况"><a class="anchor" href="#rc-下-readview-的生成情况">#</a> RC 下 ReadView 的生成情况</h6><p>具体示例略了...</p><h6 id="rr-下-readview-的生成情况"><a class="anchor" href="#rr-下-readview-的生成情况">#</a> RR 下 ReadView 的生成情况</h6><p>具体示例略了...</p><h5 id="mvccnext-key-lock-防止幻读"><a class="anchor" href="#mvccnext-key-lock-防止幻读">#</a> <mark>🌟MVCC➕Next-key Lock 防止幻读</mark></h5><blockquote><p>幻读：一个事务读取了几行数据，接着另一个并发事务<font color="red">插入</font>了一些数据。第一个事务在随后的查询中就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</p></blockquote><p><strong><font color="#B32015">InnoDB 在 RR 级别下通过 MVCC 和 临键锁（Next-key Lock）来解决幻读问题</font></strong>：</p><p>1、<strong><font color="red">执行普通 select 时会以 MVCC <u>快照读</u>的方式读取数据</font></strong></p><blockquote><p>理所当然能防止 “幻读”</p></blockquote><p>在快照读的情况下，RR 隔离级别只会在事务开启后的第一次查询时生成 Read View ，并复用直至事务提交。所以在生成 Read View 之后其它事务所做的更新、插入记录版本对当前事务并不可见，实现了可重复读和<font color="red">防止快照读下的 “幻读”</font>。</p><p>2、<strong><font color="red">执行 select...for update/lock in share mode、insert、update、delete 等当前读</font></strong></p><blockquote><p>得益于临键锁（Next-key Lock）才能防止 “幻读”</p></blockquote><p>在当前读下，读取的都是最新的数据，如果其它事务有插入新的记录，并且刚好在当前事务查询范围内，就会产生幻读！InnoDB 使用 <strong><font color="red">临键锁（Next-key Lock）</font></strong> 来防止幻读。<strong><font color="red">当执行当前读时，会锁定读取到的记录，同时会锁定它们的间隙，防止其它并发事务在查询范围内插入数据</font></strong>。只要我不让你插入，就不会发生幻读。</p><h3 id="mysql索引"><a class="anchor" href="#mysql索引">#</a> <mark>🌟MySQL 索引</mark></h3><h4 id="索引原理"><a class="anchor" href="#索引原理">#</a> <mark>🌟索引原理</mark></h4><p>索引（Index）是<font color="red">一种帮助 MySQL 高效获取数据的有序数据结构</font>，协助 MySQL 快速查询、更新表中数据。MySQL 支持多种类型的索引，包括 B-tree 索引、哈希索引、全文索引等。</p><p>索引的基本原理如下：</p><ol><li>把创建索引列的内容进行排序</li><li>对排序的结果生成倒排表</li><li>在倒排表内容上拼接上数据行地址</li><li>查询数据时，先拿到倒排表内容，在取出数据行地址，从而拿到具体的数据</li></ol><p>数据是以文件的形式存放在磁盘上面的，每一行数据都有它的磁盘地址，如果没有索引的话，我们要从千万行数据里面检索一条数据，只能依次遍历这张表的全部数据， 直到找到这条数据。</p><p>但是有了索引之后，只需要在索引里面去检索这条数据就行了，因为它是特殊的专门用来快速检索的数据结构，我们找到数据存放的磁盘地址以后，就可以拿到数据了。</p><h4 id="索引介绍"><a class="anchor" href="#索引介绍">#</a> 索引介绍</h4><p><strong>索引是一种帮助存储引擎快速查询和检索数据的数据结构（有序）。</strong></p><p>索引的底层数据结构存在很多种类型，常见的索引结构有：红黑树、B 树、B + 树、Hash。</p><p><font color="red">在 MySQL 中，Innodb 和 MyIsam，都使用 B + 树 作为索引结构</font>。</p><h4 id="索引的优缺点"><a class="anchor" href="#索引的优缺点">#</a> 索引的优缺点</h4><p><strong>优点</strong>：</p><ul><li>使用索引可以大大<font color="red">加快数据的检索速度</font>（大大减少检索的数据量），这也是创建索引的最主要的原因。</li><li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</li></ul><p><strong>缺点</strong>：</p><ul><li><font color="red">创建和维护索引需要耗费许多时间</font>。当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低 SQL 执行效率。</li><li>索引需要使用物理文件存储，也会耗费一定空间。</li></ul><h4 id="索引的底层数据结构选型"><a class="anchor" href="#索引的底层数据结构选型">#</a> <mark>🌟索引的底层数据结构选型</mark></h4><p>不同存储引擎对索引结构的支持情况：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231117203129938.png" alt="image-20231117203129938"></p><h5 id="hash-表"><a class="anchor" href="#hash-表">#</a> Hash 表</h5><p>哈希索引使用哈希算法<font color="red">将索引列的值映射到哈希表中</font>，然后通过哈希表的查找算法快速定位到目标数据。哈希索引的优点是查找速度非常快，但是它<font color="red">不支持范围查找，只适用于等值查找</font>。</p><p>哈希表是键值对的集合，通过键 (key) 即可快速取出对应的值 (value)，因此哈希表可以快速检索数据（接近 O（1））。</p><p>通过哈希算法，我们可以快速找到 key 对应的 index，找到了 index 也就找到了对应的 value。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre>hash <span class="token operator">=</span> <span class="token function">hashfunc</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre>index <span class="token operator">=</span> hash <span class="token operator">%</span> array_size</pre></td></tr></table></figure><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/mysql20210513092328171.png" alt="img"></p><p>但是！哈希算法有个 <strong>Hash 冲突</strong> 问题，也就是说多个不同的 key 最后得到的 index 相同。通常情况下，我们常用的解决办法是<strong>链地址法</strong>。链地址法就<font color="red">是将哈希冲的突数据存放在链表中</font>。</p><p>比如 JDK1.8 之前 <code>HashMap</code> 就是通过链地址法来解决哈希冲突的。不过，JDK1.8 以后 <code>HashMap</code> 为了减少链表过长时搜索时间过长引入了红黑树。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/mysql20210513092224836.png" alt="img"></p><p>为了减少 Hash 冲突的发生，一个好的哈希函数应该 “均匀地” 将数据分布在整个可能的哈希值集合中。</p><hr><p>InnoDB 存储引擎不直接支持常规的哈希索引，但存在一种特殊的<strong>自适应哈希索引（Adaptive Hash Index）</strong>，结合了 B+Tree 和哈希索引的特点，以便更好地适应实际应用中的数据访问模式和性能需求。自适应哈希索引的<font color="red">每个哈希桶实际上是一个小型的 B+Tree 结构</font>。这个 B+Tree 结构可以存储多个键值对，而不仅仅是一个键。这有助于减少哈希冲突链的长度，提高了索引的效率。关于 Adaptive Hash Index 的详细介绍，可以查看 <span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvcmE0djFYUjVwelNXYy1xdEdPLWRCZw==">MySQL 各种 “Buffer” 之 Adaptive Hash Index</span> 这篇文章。</p><p>既然哈希表这么快，为什么 MySQL 没有使用其作为索引的数据结构呢？主要是<strong>因为 Hash 索引不支持排序、范围查询</strong>。假如我们要对表中的数据进行排序或者进行范围查询，那 Hash 索引可就不行了。并且，每次 IO 只能取一个。</p><p>试想一种情况:</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token constant">SELECT</span> <span class="token operator">*</span> <span class="token constant">FROM</span> tb1 <span class="token constant">WHERE</span> id <span class="token operator">&lt;</span> <span class="token number">500</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>在这种范围查询中，直接遍历比 500 小的叶子节点就够了。而 Hash 索引是根据 hash 算法来定位的，难不成还要把 1 - 499 的数据，每个都进行一次 hash 计算来定位吗？这就是 Hash 最大的缺点了。</p><h5 id="全文索引full-text"><a class="anchor" href="#全文索引full-text">#</a> 全文索引（Full-text）</h5><p>全文索引是一种特殊的索引类型，它可以用于对文本数据进行全文检索。全文索引的基本原理是<font color="red">将文本数据分词，然后将每个词作为关键字建立索引</font>。全文索引可以用于<font color="red">对文本数据进行模糊匹配、关键字搜索</font>等操作。</p><h5 id="二叉查找树bst"><a class="anchor" href="#二叉查找树bst">#</a> 二叉查找树（BST）</h5><p>二叉查找树（Binary Search Tree）是一种基于二叉树的数据结构，它具有以下特点：</p><ol><li>左子树所有节点的值均小于根节点的值。</li><li>右子树所有节点的值均大于根节点的值。</li><li>左右子树也分别为二叉查找树。</li></ol><p>二叉查找树的时间复杂度：</p><ul><li>当二叉查找树平衡时，也就是树的每个节点的左右子树深度相差不超过 1 的时候，查询的时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:.01968em">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:.03588em">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，具有比较高的效率。</li><li>然而，当二叉查找树不平衡时，例如在最坏情况下（有序插入节点），树会退化成线性链表（也被称为<font color="red">斜树</font>），相当于<font color="red">全表扫描</font>，导致查询效率急剧下降，时间复杂退化为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mtext>（</mtext><mi>N</mi><mtext>）</mtext></mrow><annotation encoding="application/x-tex">O（N）</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mord cjk_fallback">（</span><span class="mord mathnormal" style="margin-right:.10903em">N</span><span class="mord cjk_fallback">）</span></span></span></span>。</li></ul><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/oblique-tree.png" alt="斜树"></p><center>斜树</center><p>也就是说，<strong>二叉查找树的性能非常依赖于它的平衡程度，这就导致其不适合作为 MySQL 底层索引的数据结构。</strong></p><p>为了解决这个问题，并提高查询效率，人们发明了多种在二叉查找树基础上的改进型数据结构，如平衡二叉树、B-Tree、B+Tree 等。</p><h5 id="avl-树自平衡的bst"><a class="anchor" href="#avl-树自平衡的bst">#</a> AVL 树（自平衡的 BST）</h5><p>AVL 树的特点是<font color="red">保证任何节点的左右子树高度之差不超过 1</font>，因此也被称为高度平衡二叉树。<font color="red">它的查找、插入和删除在平均和最坏情况下的时间复杂度都是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:.01968em">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:.03588em">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></font>。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/avl-tree.png" alt="AVL 树"></p><p>AVL 树采用了<font color="red">旋转操作</font>来保持平衡。主要有四种旋转操作：LL 旋转、RR 旋转、LR 旋转和 RL 旋转。其中 LL 旋转和 RR 旋转分别用于处理左左和右右失衡，而 LR 旋转和 RL 旋转则用于处理左右和右左失衡。</p><p>由于 AVL 树<font color="red">需要频繁地进行旋转操作来保持平衡</font>，因此会有较大的计算开销进而降低了查询性能。并且， 在使用 AVL 树时，每个树节点仅存储一个数据，而每次进行磁盘 IO 时只能读取一个节点的数据，如果需要查询的数据分布在多个节点上，那么就需要进行多次磁盘 IO。 <strong>磁盘 IO 是一项耗时的操作，在设计数据库索引时，我们需要优先考虑如何最大限度地减少磁盘 IO 操作的次数。</strong></p><p>实际应用中，AVL 树使用的并不多。</p><h5 id="红黑树自平衡的bst"><a class="anchor" href="#红黑树自平衡的bst">#</a> 红黑树（自平衡的 BST）</h5><p>与 AVL 树一样，红黑树也是一种自平衡二叉查找树，通过在插入和删除节点时进行<font color="red">颜色变换、旋转操作</font>，使得树始终保持平衡状态，它具有以下特点：</p><ol><li>每个节点非红即黑；</li><li>根节点总是黑色的；</li><li>每个叶子节点都是黑色的空节点（NIL 节点）；</li><li>如果节点是红色的，则它的子节点必须是黑色的（反之不一定）；</li><li>从根节点到叶节点或空子节点的每条路径，必须包含相同数目的黑色节点（即相同的黑色高度）。</li></ol><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/red-black-tree.png" alt="红黑树"></p><p>和 AVL 树不同的是，<strong><font color="red">红黑树并不追求严格的平衡，而是大致的平衡，因此红黑树的查询效率稍有下降</font></strong>。因为红黑树的平衡性相对较弱，可能会导致树的高度较高，这可能会导致一些数据需要进行多次磁盘 IO 操作才能查询到，这也是 MySQL 没有选择红黑树的主要原因。</p><p>也正因如此，<strong><font color="red">红黑树的插入和删除操作效率大大提高了</font></strong><font color="red">，因为红黑树在插入和删除节点时只需进行 O (1) 次数的旋转和变色操作，即可保持基本平衡状态</font>，而不需要像 AVL 树一样进行 O (logn) 次数的旋转操作。</p><p>红黑树的应用还是比较广泛的，<font color="red">TreeMap、TreeSet 以及 JDK1.8 的 HashMap 底层都用到了红黑树</font>。对于数据在内存中的这种情况来说，红黑树的表现是非常优异的。</p><h5 id="b树-b树"><a class="anchor" href="#b树-b树">#</a> <mark>🌟B 树 &amp; B + 树</mark></h5><blockquote><p>最常用</p></blockquote><p>B 树全称为<strong>多路平衡查找树</strong> ，B+ 树是 B 树的一种变体，其中 B 是 <code>Balanced</code> （平衡）的意思。</p><p><font color="red">目前大部分数据库系统及文件系统都采用 B-Tree 或其变种 B+Tree 作为<u>索引结构</u></font>。</p><p>B-tree 索引可以在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:.01968em">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:.03588em">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 的时间复杂度内查找数据，基本原理如下：</p><ol><li>将索引列的值按照一定的顺序存储在 B-tree 中</li><li>然后通过 B-tree 的查找算法快速定位到目标数据</li><li>B-tree 索引的叶子节点存储了指向数据行的指针，因此可以通过 B-tree 索引快速定位到目标数据行</li></ol><p><strong>B 树与 B + 树的区别</strong>：</p><ul><li><p><strong><font color="red">B 树的所有节点都存放<u>索引列值（key）</u>和数据（data）</font></strong>；而 **<font color="red"> B+ 树只有叶子节点才同时存放 key 和 data，其他内节点只存放 key</font>**。</p><blockquote><p>这样 B+ 树中每个内节点可以存储更多 key 值，从而降低 B + 树的高度，提高检索效率。</p></blockquote></li><li><p><font color="red">B 树的叶子节点都是独立的</font>；而 <strong><font color="red">B+ 树的所有叶子节点构成一个<u>有序的双向链表</u></font></strong>。</p><blockquote><p>因此 B+ 树可以按照 key 来有序遍历全部记录，且便于区间查找和搜索。</p></blockquote></li><li><p>B 树的检索的过程相当于对范围内的每个节点的 key 做二分查找，可能还没有到达叶子节点，检索就结束了。而 <strong><font color="red">B+ 树的检索效率就很稳定了，任何查找都是从根节点到叶子节点的过程，叶子节点的顺序检索很明显</font></strong>。</p></li><li><p>在 B 树中进行范围查询时，首先找到要查找的下限，然后对 B 树进行中序遍历，直到找到查找的上限；而 <strong><font color="red">B+ 树的范围查询，只需要对有序的双向链表进行遍历即可</font></strong>。</p></li></ul><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/249993-20170525154141810-591706803.png" alt="img"></p><center>B树索引（3阶）</center><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/249993-20170531161139243-491884410.png" alt="img"></p><center>（B+树索引）</center><p>综上，B + 树与 B 树相比，具备 **<font color="red">更高，更稳定的查询效率、更适用于范围查询</font>** 这些优势。</p><h5 id="mysql-选择-b-树作为索引结构的原因"><a class="anchor" href="#mysql-选择-b-树作为索引结构的原因">#</a> <mark>🌟MySQL 选择 B+ 树作为索引结构的原因</mark></h5><p><strong>1、为什么不使用二叉查找树（BST）？</strong></p><p>二叉查找树可能因为失衡严重出现<font color="red">“斜树”，退化为线性链表，相当于全表扫描</font>，高度太高了，查找效率不稳定。</p><p><strong>2、为什么不使用平衡二叉树？</strong></p><p>平衡二叉树解决了二叉树高度太高，查找效率不稳定的问题。但是，平衡二叉树的<font color="red">每个节点只存储一个键值和数据，如果数据非常的多，二叉树的结点将会非常多，高度也会很高，查找效率降低</font>。</p><p><strong>3、为什么不使用 B 树？</strong></p><ul><li><p><strong><font color="red">B 树只适合随机检索</font></strong>，而 B + 树同时支持随机检索和顺序 / 范围检索；</p></li><li><p><strong><font color="red">B + 树的空间利用率更高</font></strong>：因为 B + 树的内部节点（非叶子节点，也称索引节点）不存储数据，只存储索引值，相比较 B 树来说，B + 树一个节点可存储更多的索引值，使得整颗 B + 树变得更矮，减少 I/O 次数，磁盘读写代价更低，I/O 读写次数是影响索引检索效率的最大因素；</p></li><li><p><strong><font color="red">B + 树查询效率更加稳定</font></strong>：因为在 B + 树中，顺序检索比较明显，随机检索时，由于 B + 树所有的 data 域（结点中存储数据元素的部分）都在根节点，任何关键字的查找都必须走一条从根节点到叶节点的路，所有关键字的查找路径相同，导致每一个关键字的查询效率基本相同，时间复杂度固定为 O (log n)；而 B 树搜索有可能会在非叶子节点结束，越靠近根节点的记录查找时间越短，其性能等价于在关键字全集内做一次二分查找，查询时间复杂度不固定，与 key 在树中的位置有关，最好情况为 O (1)；</p></li><li><p><strong><font color="red">B + 树范围查询性能更优</font></strong>：因为 B + 树的叶子节点使用了指针顺序（链表）从小到大地连接在一起，B + 树叶节点两两相连可大大增加区间访问性，只要遍历叶子节点就可以实现整棵树的遍历；而 B 树的叶子节点是相互独立的，每个节点 key（索引）和 data 在一起，则无法查找区间；</p><p>根据空间局部性原理：如果一个存储器的某个位置被访问，那么将它附近的位置也会被访问。若访问节点 key 为 50，则 key 为 55、60、62 的节点将来也可能被访问，可利用磁盘预读原理提前将这些数据读入内存，减少了磁盘 IO 的次数。当然 B + 树也能够很好的完成范围查询，比如同时也会查询 key 值在 50-70 之间的节点。</p></li><li><p><strong><font color="red">B + 树增删文件（节点）时效率更高</font></strong>：因为 B + 树的叶子节点包含了所有关键字，并以有序的链表结构存储。</p></li></ul><h4 id="索引分类"><a class="anchor" href="#索引分类">#</a> 索引分类</h4><p>按照<font color="gree">数据结构</font>分类：</p><ul><li><strong><font color="cornflowerblue">B + 树索引</font></strong>：MySQL 里<font color="red">默认的</font>索引类型。<font color="red">只有叶子节点存储 value，非叶子节点只有指针和 key</font>。存储引擎 MyISAM 和 InnoDB 实现索引都是使用 B+Tree，但二者实现方式不一样。</li><li><font color="cornflowerblue">hash 索引</font>：类似键值对的形式，一次即可定位。</li><li><font color="cornflowerblue">R 树索引</font>：一般不会使用，<font color="red">仅支持 geometry 数据类型</font>，优势在于范围查找，效率较低，通常使用搜索引擎如 ElasticSearch 代替。</li><li><font color="cornflowerblue">全文索引</font>：<font color="red">对文本的内容进行分词，进行搜索</font>。目前只有 <code>CHAR</code> 、 <code>VARCHAR</code> ， <code>TEXT</code> 列上可以创建全文索引。<font color="red">一般不会使用，效率较低</font>，通常使用搜索引擎如 ElasticSearch 代替。</li></ul><p>按照<font color="gree">底层存储方式</font>划分：</p><ul><li><p><strong><font color="cornflowerblue">聚集索引</font></strong>：聚集索引的<strong>叶子节点存储的是<u>整行记录</u></strong>。<font color="red">可以直接查找到数据，查询速度快。每个表只能有一个聚集索引</font>。例如 <font color="red">InnoDB 引擎中的主键索引</font>。</p><blockquote><p>在 MySQL 中，InnoDB 引擎表的 <code>.ibd</code> 表空间文件包含了该表的索引和数据，因此该表的索引 (B + 树) 的每个非叶子节点存储索引，叶子节点存储索引和索引对应的数据。</p></blockquote></li><li><p><strong><font color="cornflowerblue">非聚集索引</font></strong>：非聚集索引的<strong>叶子节点存储的是<u>索引列的值、指向对应行记录的指针</u></strong>。查询速度相对较慢。<font color="red">MyISAM 引擎，无论主键还是非主键，使用的都是非聚集索引</font>。</p></li></ul><p>按照<font color="gree">应用维度</font>划分：</p><ul><li><font color="cornflowerblue">主键索引</font>：加速查询 + 列值唯一（不可以有 NULL）+ 表中只有一个。</li><li><font color="cornflowerblue">普通索引</font>：仅加速查询。</li><li><font color="cornflowerblue">唯一索引</font>：加速查询 + 列值唯一（可以有 NULL）。</li><li><font color="cornflowerblue">覆盖索引</font>：一个索引包含（或者说覆盖）所有需要查询的字段的值。</li><li><font color="cornflowerblue">联合索引</font>：<font color="red">多列值组成一个索引</font>，专门用于组合搜索，其效率大于索引合并。</li><li><font color="cornflowerblue">全文索引</font>：对文本的内容进行分词，进行搜索。目前只有 <code>CHAR</code> 、 <code>VARCHAR</code> ， <code>TEXT</code> 列上可以创建全文索引。一般不会使用，效率较低，通常使用搜索引擎如 ElasticSearch 代替。</li></ul><p>MySQL 8.x 中实现的<font color="gree">索引新特性</font>：</p><ul><li><font color="cornflowerblue">隐藏索引</font>：也称为不可见索引，不会被优化器使用，但是仍然需要维护，通常会软删除和灰度发布的场景中使用。主键不能设置为隐藏（包括显式设置或隐式设置）。</li><li><font color="cornflowerblue">降序索引</font>：之前的版本就支持通过 desc 来指定索引为降序，但实际上创建的仍然是常规的升序索引。直到 MySQL 8.x 版本才开始真正支持降序索引。另外，在 MySQL 8.x 版本中，不再对 GROUP BY 语句进行隐式排序。</li><li><font color="cornflowerblue">函数索引</font>：从 MySQL 8.0.13 版本开始支持在索引中使用函数或者表达式的值，也就是在索引中可以包含函数或者表达式。</li></ul><h5 id="主键索引"><a class="anchor" href="#主键索引">#</a> 主键索引</h5><p>数据表的<font color="red">主键列</font>使用的就是主键索引。</p><p>一张数据表有只能有一个主键，并且主键不能为 null，不能重复。</p><p>在 MySQL 的 InnoDB 的表中，当没有显示的指定表的主键时，InnoDB 会自动先检查表中是否有唯一索引且不允许存在 null 值的字段，如果有，则选择该字段为默认的主键，否则 InnoDB 将会自动创建一个 6 Byte 的自增主键。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/cluster-index.png" alt="主键索引"></p><center>主键索引</center><h5 id="二级索引"><a class="anchor" href="#二级索引">#</a> 二级索引</h5><p>二级索引（Secondary Index）又称为辅助索引，是一种非聚集索引，因为<strong>二级索引的叶子节点仅仅存储<u>索引列的值、对应行记录的主键 key</u></strong>。也就是说，<font color="red">通过二级索引，可以定位主键的位置，再根据主键索引查找行记录 data，这就是<strong>二次查询（回表）</strong>，因此二级索引的查询速度较慢</font>。</p><p>唯一索引，普通索引，前缀索引、全文索引都属于二级索引：</p><ol><li><font color="cornflowerblue">唯一索引 (Unique Key)</font>：唯一索引也是一种约束。<font color="red">唯一索引的属性列不能出现重复的数据，但是允许数据为 NULL，一张表允许创建多个唯一索引</font>。建立唯一索引的目的大部分时候都是<font color="red">为了该属性列的数据的唯一性，而不是为了查询效率</font>。</li><li><font color="cornflowerblue">普通索引 (Index)</font>：普通索引的唯一作用就是<font color="red">为了快速查询数据</font>，一张表允许创建多个普通索引，并允许数据重复和 NULL。</li><li><font color="cornflowerblue">前缀索引 (Prefix)</font>：前缀索引只适用于字符串类型的数据。前缀索引是<font color="red">对文本的前几个字符创建索引，相比普通索引建立的数据更小</font>，因为只取前几个字符。</li><li><font color="cornflowerblue">全文索引 (Full Text)</font>：全文索引主要是<font color="red">为了检索大文本数据中的关键字信息</font>，是目前搜索引擎数据库使用的一种技术。Mysql 5.6 之前只有 MYISAM 引擎支持全文索引，5.6 之后 InnoDB 也支持了全文索引。</li></ol><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/no-cluster-index.png" alt="二级索引"></p><center>二级索引</center><h5 id="聚集索引"><a class="anchor" href="#聚集索引">#</a> 聚集索引</h5><p>聚集索引（Clustered Index）的<strong>叶子节点存储的是<u>整行记录</u></strong>。<font color="red">可以直接查找到数据，查询速度快。每个表只能有一个聚集索引</font>。例如 <font color="red">InnoDB 引擎中的主键索引</font>。</p><p>在 MySQL 中，<font color="red">InnoDB 引擎的表的 <code>.ibd</code> 表空间文件就包含了该表的索引和数据</font>，对于 InnoDB 引擎表来说，该表的索引 (B + 树) 的每个非叶子节点存储索引，叶子节点存储索引和索引对应的数据。</p><p>优点：</p><ul><li><strong>查询速度非常快</strong>：因为整个 B+ 树本身就是一颗多叉平衡树，叶子节点也都是有序的，定位到索引的节点，就相当于定位到了数据。<font color="red">相比于非聚集索引， 聚集索引少了一次读取数据的 IO 操作</font>。</li><li><strong>对排序查找和范围查找优化</strong>：对于主键的排序查找和范围查找速度非常快。</li></ul><p>缺点：</p><ul><li><strong>依赖于有序的数据</strong>：因为 B+ 树是多路平衡树，如果索引的数据不是有序的，那么就<font color="red">需要在插入时排序</font>，如果数据是整型还好，否则类似于字符串或 UUID 这种又长又难比较的数据，<font color="red">插入或查找的速度肯定比较慢</font>。</li><li><strong>修改更新的代价大</strong>：如果索引列的数据被修改，那么对应的索引也将会被修改，而且聚集索引的叶子节点还存放着数据，修改代价肯定是较大的。所以对于主键索引来说，主键一般都是不可被修改的。</li></ul><h5 id="非聚集索引"><a class="anchor" href="#非聚集索引">#</a> 非聚集索引</h5><p>非聚集索引（Non-Clustered Index）的<strong>叶子节点存储的是<u>索引列的值、指向对应行记录的指针</u></strong>。查询速度相对较慢。二级索引 (辅助索引) 就属于非聚集索引。<font color="red">MyISAM 引擎，无论主键还是非主键，使用的都是非聚集索引</font>。</p><p>非聚集索引的叶子节点并不一定存放数据的指针，因为<font color="red">二级索引的叶子节点就存放的是主键，根据主键再回表查数据</font>。</p><p>优点：</p><ul><li><strong>更新代价比聚集索引要小</strong>：因为非聚集索引的<font color="red">叶子节点是不存放数据的</font></li></ul><p>缺点：</p><ul><li><p><strong>依赖于有序的数据</strong>：跟聚簇索引一样，非聚簇索引也依赖于有序的数据</p></li><li><p><strong><font color="orange">可能会二次查询 (回表查询)</font></strong>: 这应该是非聚簇索引最大的缺点了。<strong><font color="red">当查到非聚集索引对应的指针或主键后，可能还需要根据指针或主键再到数据文件或表中查询</font></strong>。</p><blockquote><p><strong>非聚集索引不一定回表查询。</strong></p><p>试想一种情况，用户准备使用 SQL 查询用户名，而用户名字段正好建立了索引。</p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">SELECT</span> name <span class="token keyword">FROM</span> <span class="token keyword">table</span> <span class="token keyword">WHERE</span> name<span class="token operator">=</span><span class="token string">'guang19'</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>那么这个<font color="red">索引的 key 本身就是要查询的字段</font>，查到对应的 name 直接返回就行了，无需回表查询。</p><p>即使是 MYISAM 也是这样，虽然 MYISAM 的主键索引确实需要回表，因为它的主键索引的叶子节点存放的是指针。但是！<strong>如果 SQL 查的就是主键呢？</strong></p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">SELECT</span> id <span class="token keyword">FROM</span> <span class="token keyword">table</span> <span class="token keyword">WHERE</span> id<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>主键索引本身的 key 就是主键，查到返回就行了。这种情况就称之为<strong>覆盖索引</strong>了。</p></blockquote></li></ul><p>这是 MySQL 的 InnoDB、MyISAM 表的文件截图：</p><blockquote><p><strong>InnoDB、MyISAM、Memory 这三种存储引擎的存储文件内容</strong>：</p><ul><li>无论哪种引擎，<font color="gree">表的结构</font>都存储在 <code>.sdi</code> 文件中</li><li>对于 InnoDB，表的索引和数据都存储在 <code>.ibd 表空间文件</code> 中</li><li>对于 MyISAM，表的索引存储在 <code>.MYI</code> 文件中，表的数据存储在 <code>.MYD</code> 文件中</li><li>对于 Memory，表的索引和数据都存储在 <code>内存</code> 中</li></ul></blockquote><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/mysql20210420165311654.png" alt="MySQL 表的文件"></p><h5 id="聚集索引和非聚集索引的区别"><a class="anchor" href="#聚集索引和非聚集索引的区别">#</a> <mark>🌟聚集索引和非聚集索引的区别</mark></h5><p>聚集索引：</p><ul><li><p>数据存储方式：表中的数据与索引按顺序存放在一块，<font color="red">找到索引也就找到了数据</font>，即数据的物理存放顺序与索引顺序是一致的</p></li><li><p>叶节点的 k-v：<font color="red">（主键，行记录）</font></p></li><li><p>唯一性：<font color="red">表中只能有一个聚集索引，通常是主键</font>（因为主键要求其值在表中唯一且非空）</p></li><li><p>查询性能：<font color="red">范围查询、排序查询的性能高</font>，但<font color="red">插入速度严重依赖于插入顺序</font>；<font color="red">更新主键的代价很高</font>。</p><blockquote><p><font color="red">按照主键顺序插入</font>是最快的方式，否则将会出现<font color="red">页分裂</font>，严重影响性能。因此，对于 InnoDB 表，我们一般都会定义一个<font color="red">自增的 ID 列为主键</font>。</p><p>更新主键会导致被更新的行移动。因此对于 InnoDB 表，<font color="red">一般定义主键为不可更新</font>。</p></blockquote></li></ul><p>非聚集索引：</p><ul><li>数据存储方式：<font color="red">索引和实际数据的物理存储是分离的</font>，索引中存储了指向实际数据行的指针</li><li>叶节点的 k-v：<font color="red">（索引列，指向行记录的指针）</font></li><li>唯一性：<font color="red">表可以有多个非聚集索引，包括唯一索引</font>。非聚集索引不要求索引列的值唯一</li><li>查询性能：<font color="red">插入数据的速度快</font>，但<font color="red">查询可能涉及回表，速度较慢</font></li></ul><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231119111458997.png" alt="image-20231119111458997"></p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/mysql20210420165326946.png" alt="聚簇索引和非聚簇索引"></p><h5 id="倒排索引"><a class="anchor" href="#倒排索引">#</a> <mark>🌟倒排索引</mark></h5><p>先讲正排索引，意思就是我们的所有文档都有唯一一个文档 id，根据文档里的内容算出每个文档中关键字的内容和次数，类似于通过 key 去找 value 的形式，如果正牌索引，我们每次寻找关键字查询，就得搜索所有的文档去看是否有这个关键字，这样查询效率太慢了。</p><p>于是有了倒排索引，是通过关键字去查文档，我们建立一个索引库，里面的 key 是关键字，value 是每个文档的 id，倒排在构建索引的时候较为耗时且维护成本较高，但是搜索耗时短，所以我们可以定时去更新索引库。</p><p>正排索引和倒排索引是搜索引擎中的两种索引类型。</p><ul><li>正排索引：每个文档都有一个唯一的文档 ID，<font color="red">按照文档 ID 等有序的方式将每个文档存储在索引中</font>，通过文档 ID 进行检索。这种方式类似于数据库表的行，可以很方便地根据文档 ID 检索到具体的文档，但是<font color="red">不适合处理大规模文档库的情况</font>。</li><li>倒排索引：<font color="red">按照单词或关键字将文档进行索引</font>，并记录包含该词汇的文档列表。</li></ul><p><font color="red">倒排索引的优势在于查找包含某个项的文档，即用于搜索查询</font>；相反，<font color="red">正排索引的优势是确定哪些项是否存在单个文档里</font>。</p><p>二者均是在 index-time 时创建，保存在 Lucene 文件中（序列化到磁盘）。</p><h5 id="覆盖索引"><a class="anchor" href="#覆盖索引">#</a> <mark>🌟覆盖索引</mark></h5><blockquote><p>我们都知道 InnoDB 中索引分为两类：</p><ul><li><font color="red">聚集索引（主键索引）</font>：（<font color="gree">主键</font>，除主键外的完整行记录）</li><li><font color="red">非聚集索引（辅助索引 / 普通索引）</font>：（索引列的值，<font color="gree">主键</font>）</li></ul><p>想要搞清除什么是覆盖索引，首先得弄懂 **<font color="#B32015">回表查询</font>**：当使用<u>普通索引（辅助索引）</u>进行查询时，先得到行记录的主键值（<font color="red">但仍未得到所需的所有列数据</font>），然后再根据主键值到<u>聚集索引（主键索引）</u>中找到对应的完整行记录。</p><p>由于<font color="red">回表导致多次扫描索引树，会降低查询效率</font>。那么如何避免回表查询？</p><p><font color="red">常用的方法是：将查询需要的字段添加到索引中，建立<u>联合索引</u></font>。比如上面提到的查询语句，可以将 (NAME,CITY) 做成一个联合索引，这样在首次扫描索引树的时候就能从索引树本身获取到需要的所有信息，从而避免了回表。这里使用的方法就是<strong>覆盖索引</strong>。</p><hr><p>举个回表查询的例子，对于 InnoDB 表 EMPLOYEE，由三个字段（ID、NAME、CITY）组成，其中在 ID 上建立了主键索引（聚集索引），在 NAME 上建立了普通索引。</p><p>现在需要进行一次如下的查询：</p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">select</span> NAME<span class="token punctuation">,</span>CITY <span class="token keyword">from</span> EMPLOYEE <span class="token keyword">where</span> NAME<span class="token operator">=</span><span class="token string">"Lee"</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>首先通过普通索引去找到 NAME=&quot;Lee&quot; 对应的叶节点，获取到行记录的主键值（ID=8）。而该查询语句还需要获取 CITY 字段的值，于是 MySQL 要再根据该主键值（ID=8）通过主键索引查找，从而获得完整的数据。这个过程就是所谓的<strong>回表查询</strong>。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/4cfbd83c40884036b46e895d31a70726.png" alt="在这里插入图片描述"></p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/28608822ef07481187c583b22bc3c80a.png" alt="在这里插入图片描述"></p></blockquote><p>如果一个 **<font color="#B32015">索引包含了所有需要查询的字段</font>**，就称之为覆盖索引（Covering Index）。在 InnoDB 中，如果不是主键索引，叶子节点存储的是索引列值 + 主键。最终还是要 “回表”，也就是要通过主键再查找一次，这样就会比较慢。<font color="red">而覆盖索引就是把要查询出的列和索引是对应的，不做回表操作！因为所查询的字段都在当前索引的叶子节点上存在，可以直接作为结果返回了。</font></p><p>** 覆盖索引，即需要查询的字段正好是索引的字段，那么直接根据该索引就可以查到数据了，而无需回表查询。** 因此，<font color="red">应该尽量使用覆盖索引，减少 <code>select *</code> </font>。</p><blockquote><p>如主键索引，如果一条 SQL 需要查询主键，那么正好根据主键索引就可以查到主键。再如普通索引，如果一条 SQL 需要查询 name，name 字段正好有索引，那么直接根据这个索引就可以查到数据，也无需回表。</p></blockquote><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/mysql20210420165341868.png" alt="覆盖索引"></p><h5 id="联合索引"><a class="anchor" href="#联合索引">#</a> 联合索引</h5><p>使用表中的<strong>多个字段创建索引</strong>，就是 联合索引，也叫 组合索引 或 复合索引。</p><p>以 <code>score</code> 和 <code>name</code> 两个字段建立联合索引：</p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> <span class="token identifier"><span class="token punctuation">`</span>cus_order<span class="token punctuation">`</span></span> <span class="token keyword">ADD</span> <span class="token keyword">INDEX</span> id_score_name<span class="token punctuation">(</span>score<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h4 id="最左前缀匹配原则"><a class="anchor" href="#最左前缀匹配原则">#</a> <mark>🌟最左前缀匹配原则</mark></h4><p>最左前缀法则：<strong><font color="#B32015">查询条件中的各个列必须是联合索引中从最左边开始的连续子列。</font></strong></p><ul><li><font color="red">如果跳跃了<u>中间的某一列</u>，那么联合索引将会<u>部分失效</u>（后面的字段索引都失效）。</font></li><li><strong>如果跳跃了<u>最左列</u>，那么联合索引将会<u>全部失效</u>，转而进行全表扫描！</strong></li></ul><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231117221133910.png" alt="image-20231117221133910"></p><blockquote><p>注意：<strong>联合索引的最左边字段必须在 SQL 的查询条件中存在，但是与 SQL 的查询条件中编写的字段先后顺序无关</strong>。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231117221449634.png" alt="image-20231117221449634"></p><center>因此对于这种情况，联合索引是全部生效的！</center></blockquote><p>所以，<strong>在使用联合索引时，可以将区分度高的字段放在最左边，这也可以过滤更多数据</strong>。</p><p><strong>在联合索引的使用中，如果 SQL 出现范围查询（如 <code>&gt;</code> 、 <code>&lt;</code> ），那么范围查询右侧的列索引会失效！</strong></p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231117221945853.png" alt="image-20231117221945853"></p><blockquote><p>但对于 <strong><code>&gt;=</code> </strong>、<strong> <code>&lt;=</code> </strong>、<strong> <code>BETWEEN</code> </strong>、<strong> <code>like</code> </strong>前缀匹配的范围查询，并不会停止匹配。</p></blockquote><h4 id="索引下推"><a class="anchor" href="#索引下推">#</a> 索引下推</h4><p><strong>索引下推（Index Condition Pushdown）</strong> 是 <strong>MySQL 5.6</strong> 版本中提供的一项索引优化功能，可以在非聚簇索引遍历过程中，对索引中包含的字段先做判断，过滤掉不符合条件的记录，减少回表次数。</p><h4 id="索引失效"><a class="anchor" href="#索引失效">#</a> <mark>🌟索引失效</mark></h4><p><strong><font color="red">索引失效后导致使用全表扫描来查询数据</font></strong>，这也是慢查询的主要原因之一，查询中导致索引失效的常见情况有这些：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/iaIdQfEric9Twmk46GNqLLRSboGCk9Pkk48jba0ibtuuic2ic9elp0r52TBmB0AbBKFK0sOZ9gf3GWPLicL34Chqrevw" alt="img"></p><ol><li><strong><font color="#B32015">MySQL 自身评估使用全表扫描的查询速度比使用索引的更快</font></strong>：MySQL 在查询时，会评估全表扫描的查询效率与使用索引的效率，如果全表扫描更快，则放弃索引，走全表扫描。这种情况一般是 <code>SELECT *</code> 语句。</li></ol><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231118133740655.png" alt="image-20231118133740655"></p><ol start="2"><li><p><strong><font color="#B32015">创建了联合索引，但查询条件未遵循<u>最左前缀匹配原则</u>，或者涉及范围查询（如 <code>&gt;</code> 、 <code>&lt;</code> ）</font></strong>。</p><blockquote><p>指路→<a href="#==%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80%E5%8C%B9%E9%85%8D%E5%8E%9F%E5%88%99==">最左前缀匹配原则</a></p></blockquote></li></ol><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231118133951572.png" alt="image-20231118133951572"></p><center>未遵循最左前缀匹配原则</center><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231117221945853.png" alt="image-20231117221945853"></p><center>涉及范围查询</center><ol start="3"><li><strong><font color="#B32015">查询条件中，对索引列进行了数学运算、函数等操作</font></strong>：<font color="red">因为索引保存的是索引字段的原始值</font>，而不是表达式计算后的值 / 函数计算后的值，自然无法走索引了，只能通过把索引字段的取值都取出来，然后依次进行表达式计算 / 函数计算来进行条件判断，因此采用的就是<font color="red">全表扫描</font>的方式。</li></ol><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231118133046959.png" alt="image-20231118133046959"></p><ol start="4"><li><strong><font color="#B32015">查询条件中，对索引列进行以 % 开头的 LIKE 模糊查询</font></strong>：当我们使用左或者左右模糊匹配的时候，也就是 like % xx 或者 like % xx% 这两种方式都会造成索引失效。<font color="red">因为索引 B+ 树是按照「索引值」有序排列存储的，只能根据前缀进行比较</font>。</li></ol><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231118133112182.png" alt="image-20231118133112182"></p><ol start="5"><li><strong><font color="#B32015">查询条件中，OR 前后存在非索引的列</font></strong>：因为 OR 的含义就是两个只要满足一个即可，因此只有一个条件列是索引列是没有意义的，<font color="red">只要有一个条件列不是索引列，就会进行全表扫描</font>。要想使用 OR，又想让索引生效，只能将 OR 条件中的每个列都加上索引。</li></ol><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231118133312921.png" alt="image-20231118133312921"></p><center>age没有索引，id、phone有索引</center><ol start="6"><li><p><strong><font color="#B32015">查询条件中，IN /NOT IN 的取值范围较大</font></strong>：导致索引失效，走全表扫描；</p></li><li><p><strong><font color="#B32015">发生<span class="exturl" data-url="aHR0cHM6Ly9qYXZhZ3VpZGUuY24vZGF0YWJhc2UvbXlzcWwvaW5kZXgtaW52YWxpZGF0aW9uLWNhdXNlZC1ieS1pbXBsaWNpdC1jb252ZXJzaW9uLmh0bWw=">隐式类型转换</span></font></strong>：<font color="red">当索引列是字符串类型时，若查询条件中数据不加单引号，虽然对于查询结果没什么影响，但是数据库会进行隐式类型转换，导致索引列失效</font>。</p></li></ol><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231118132957838.png" alt="image-20231118132957838"></p><ol start="8"><li>……</li></ol><p>推荐阅读这篇文章：<span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvbXdNRTNxdWtIQkZ1bDU3V1FMa09ZZw==">美团暑期实习一面：MySQl 索引失效的场景有哪些？</span>。</p><h4 id="索引的正确使用建议"><a class="anchor" href="#索引的正确使用建议">#</a> <mark>🌟索引的正确使用建议</mark></h4><blockquote><p>索引设计原则</p></blockquote><h5 id="避免索引失效"><a class="anchor" href="#避免索引失效">#</a> 避免索引失效</h5><blockquote><p>上一节</p></blockquote><h5 id="针对数据量大且查询频繁的表建立索引"><a class="anchor" href="#针对数据量大且查询频繁的表建立索引">#</a> 针对数据量大，且查询频繁的表建立索引</h5><p>基数较小的表，索引效果较差，没有必要在此列建立索引。</p><h5 id="选择合适的字段创建索引"><a class="anchor" href="#选择合适的字段创建索引">#</a> 选择合适的字段创建索引</h5><ul><li><p><strong>不为 NULL 的字段</strong>：索引字段的数据应该尽量不为 NULL，因为<font color="red">对于数据值为 NULL 的字段，数据库较难优化</font>。如果字段频繁被查询，但又避免不了为 NULL，<font color="red">建议使用 0,1,true,false </font>这样语义较为清晰的短值或短字符作为替代。</p></li><li><p><strong>被频繁查询的字段</strong>：我们创建索引的字段应该是查询操作非常频繁的字段。</p></li><li><p><strong>常作为查询条件（where）、排序（order by）、分组（group by）操作的字段</strong>：被作为 WHERE 条件查询的字段，应该被考虑建立索引。索引已经排序，这样查询可以利用索引的排序，加快排序查询时间。</p></li><li><p><strong>被经常频繁用于连接子句中的字段</strong>：经常用于连接的字段可能是一些外键列，对于外键列并不一定要建立外键，只是说该列涉及到表与表的关系。对于频繁被连接查询的字段，可以考虑建立索引，<font color="red">提高多表连接查询的效率</font>。</p></li></ul><h5 id="被频繁更新的字段应该慎重建立索引"><a class="anchor" href="#被频繁更新的字段应该慎重建立索引">#</a> 被频繁更新的字段应该慎重建立索引</h5><p>因为字段的更新会导致索引的更新，而维护索引的成本也是不小的。因此如果一个字段不被经常查询，反而被经常修改，那么就更不应该在这种字段上建立索引了。</p><h5 id="限制每张表上的索引数量"><a class="anchor" href="#限制每张表上的索引数量">#</a> 限制每张表上的索引数量</h5><p>索引需要额外的磁盘空间，并降低写操作的性能。<font color="red">在修改表内容的时候，索引会进行更新甚至重构，索引列越多，这个时间就会越长</font>。所以只保持需要的索引有利于查询即可。</p><p><font color="red">建议单张表索引不超过 5 个！</font></p><p><font color="red">索引可以增加查询效率，但同样也会降低插入和更新的效率</font>，甚至有些情况下会降低查询效率。</p><h5 id="尽量考虑联合索引而不是单列索引"><a class="anchor" href="#尽量考虑联合索引而不是单列索引">#</a> 尽量考虑联合索引，而不是单列索引</h5><p>因为索引是需要占用磁盘空间的，可以简单理解为每个索引都对应着一颗 B+ 树。如果一个表的字段过多，索引过多，那么当这个表的数据达到一个体量后，索引占用的空间也是很多的，且修改索引时，耗费的时间也是较多的。<font color="red">如果是联合索引，多个字段在一个索引上，那么将会节约很大磁盘空间，且修改数据的操作效率也会提升</font>。</p><h5 id="注意避免冗余索引"><a class="anchor" href="#注意避免冗余索引">#</a> 注意避免冗余索引</h5><p>冗余索引指的是索引的功能相同，能够命中索引 (a, b) 就肯定能命中索引 (a) ，那么索引 (a) 就是冗余索引。如（name,city ）和（name ）这两个索引就是冗余索引，能够命中前者的查询肯定是能够命中后者的。在大多数情况下，都应该尽量扩展已有的索引而不是创建新索引。</p><h5 id="针对字符串类型的字段使用前缀索引短索引"><a class="anchor" href="#针对字符串类型的字段使用前缀索引短索引">#</a> 针对字符串类型的字段，使用前缀索引（短索引）</h5><p><font color="red">前缀索引（短索引）仅限于字符串类型，只对字符串的一部分前缀建立索引，大大节约索引空间，提高索引效率</font>。</p><h5 id="删除长期未使用的索引"><a class="anchor" href="#删除长期未使用的索引">#</a> 删除长期未使用的索引</h5><p>不用的索引会造成不必要的性能损耗。MySQL 5.7 可以通过查询 <code>sys</code> 库的 <code>schema_unused_indexes</code> 视图来查询哪些索引从未被使用。</p><h5 id="不能有效区分数据的字段不适合做索引列"><a class="anchor" href="#不能有效区分数据的字段不适合做索引列">#</a> 不能有效区分数据的字段不适合做索引列</h5><p>如性别（男 / 女 / 未知），最多也就三种，区分度实在太低。</p><h5 id="利用-explain-命令分析-sql-是否走索引查询"><a class="anchor" href="#利用-explain-命令分析-sql-是否走索引查询">#</a> 利用 EXPLAIN 命令分析 SQL 是否走索引查询</h5><p>我们可以使用 <strong><code>EXPLAIN</code> 命令</strong>来分析 SQL 的<strong>执行计划</strong> ，这样就知道语句是否命中索引了。执行计划是指<strong>一条 SQL 语句在经过 MySQL 查询优化器的优化后，具体的执行方式</strong>。</p><p><code>EXPLAIN</code> 并不会真的去执行相关的语句，而是通过 <strong>查询优化器</strong> 对语句进行分析，找出最优的查询方案，并显示对应的信息。</p><p><code>EXPLAIN</code> 的输出格式如下：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231118141340551.png" alt="image-20231118141340551"></p><p>各个字段的含义如下：</p><table><thead><tr><th><strong>列名</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>id</td><td>SELECT 查询的序列标识符</td></tr><tr><td>select_type</td><td>SELECT 关键字对应的查询类型</td></tr><tr><td>table</td><td>用到的表名</td></tr><tr><td>partitions</td><td>匹配的分区，对于未分区的表，值为 NULL</td></tr><tr><td><strong>type</strong></td><td><font color="red">表的访问方法</font></td></tr><tr><td>possible_keys</td><td><font color="red">可能用到的索引</font></td></tr><tr><td><strong>key</strong></td><td><font color="red">实际用到的索引</font></td></tr><tr><td>key_len</td><td><font color="red">所选索引的长度</font></td></tr><tr><td>ref</td><td>当使用索引等值查询时，与索引作比较的列或常量</td></tr><tr><td>rows</td><td>预计要读取的行数</td></tr><tr><td>filtered</td><td>按表条件过滤后，留存的记录数的百分比</td></tr><tr><td><strong>Extra</strong></td><td><font color="red">附加信息</font></td></tr></tbody></table><p>篇幅问题，我这里只是简单介绍了一下 MySQL 执行计划，详细介绍请看：<a href="">MySQL 执行计划分析</a>这篇文章。</p><h3 id="mysql执行计划"><a class="anchor" href="#mysql执行计划">#</a> MySQL 执行计划</h3><h4 id="各个字段"><a class="anchor" href="#各个字段">#</a> 各个字段</h4><h5 id="id"><a class="anchor" href="#id">#</a> id</h5><p>SELECT 标识符，是查询中 SELECT 的序号，用来标识整个查询中 SELELCT 语句的顺序。</p><ul><li><font color="red">id 如果相同，从上往下依次执行</font>。</li><li>id 不同，<font color="red">id 值越大，执行优先级越高</font>，如果行引用其他行的并集结果，则该值可以为 NULL。</li></ul><h5 id="select_type"><a class="anchor" href="#select_type">#</a> select_type</h5><p>查询的类型，主要用于区分普通查询、联合查询、子查询等复杂的查询，常见的值有：</p><ul><li><strong>SIMPLE</strong>：<font color="red">简单查询</font>，不包含 UNION 或者子查询。</li><li><strong>PRIMARY</strong>：查询中如果包含子查询或其他部分，<font color="red">外层的 SELECT </font>将被标记为 PRIMARY。</li><li><strong>SUBQUERY</strong>：<font color="red">子查询中的第一个 SELECT</font>。</li><li><strong>UNION</strong>：在 UNION 语句中，<font color="red">UNION 之后出现的 SELECT</font>。</li><li><strong>DERIVED</strong>：<font color="red">在 FROM 中出现的子查询</font>将被标记为 DERIVED。</li><li><strong>UNION RESULT</strong>：UNION 查询的结果。</li></ul><h5 id="table"><a class="anchor" href="#table">#</a> table</h5><p>查询用到的表名，每行都有对应的表名，表名除了正常的表之外，也可能是以下列出的值：</p><ul><li><strong><code>&lt;unionM,N&gt;</code> </strong>: 本行引用了 id 为 M 和 N 的行的 UNION 结果；</li><li><strong><code>&lt;derivedN&gt;</code> </strong>: 本行引用了 id 为 N 的表所产生的的派生表结果。派生表有可能产生自 FROM 语句中的子查询。</li><li><strong><code>&lt;subqueryN&gt;</code> </strong>: 本行引用了 id 为 N 的表所产生的的物化子查询结果。</li></ul><h5 id="type重要"><a class="anchor" href="#type重要">#</a> <mark>type（重要）</mark></h5><p>查询执行的类型，描述了查询是如何执行的。所有值的顺序从最优到最差排序为：system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL</p><p>常见的几种类型具体含义如下（<strong>按照执行效率从低到高的顺序</strong>）：</p><ul><li><p><font color="cornflowerblue">All（全表扫描）</font>：最坏的情况，因为采用了<font color="red">全表扫描</font>的方式</p></li><li><p><font color="cornflowerblue">index（全索引扫描）</font>：<font color="red">查询遍历了整棵索引树</font>，和 all 差不多，只不过扫描的是索引，而索引一般在内存中，速度更快。只不过 index <font color="red">对索引表进行全扫描</font>。这样做的好处是不再需要对数据进行排序，但是开销依然很大。</p><blockquote><p>所以要尽量避免全表扫描和全索引扫描。</p></blockquote></li><li><p><font color="cornflowerblue">range（对索引进行范围扫描）</font>：一般在 where 子句中使用 &lt;、&gt;、in、between 等关键词，只检索给定范围的行，属于范围查找。执行计划中的 key 列表示哪个索引被使用了。</p><blockquote><p><strong><font color="red">从这一级别开始，索引的作用会越来越明显，因此我们需要尽量让 SQL 查询可以使用到 range 这一级别及以上的 type 访问方式</font></strong>。</p></blockquote></li><li><p><font color="cornflowerblue">ref（非唯一索引扫描）</font>：<font color="red">采用了非唯一索引，或者是唯一索引的非唯一性前缀</font>，<font color="red">查询结果可能返回多条符合条件的行</font>。因为虽然使用了索引，但<font color="red">该索引列的值并不唯一，有重复</font>。这样即使使用索引快速查找到了第一条数据，仍然不能停止，要进行目标值附近的小范围扫描。但它的<font color="red">好处是它并不需要扫全表，因为索引是有序的，即便有重复值，也是在一个非常小的范围内扫描</font>。</p></li><li><p><font color="cornflowerblue">eq_ref（唯一索引扫描）</font>：<font color="red">使用主键索引或唯一索引</font>时产生的访问方式，<font color="red">通常使用在多表联查中</font>。比如，对两张表进行联查，关联条件是两张表的 user_id 相等，且 user_id 是唯一索引，那么使用 EXPLAIN 进行执行计划查看的时候，type 就会显示 eq_ref。</p></li><li><p><font color="cornflowerblue">const</font>：<font color="red">使用了主键或者唯一索引与常量值进行比较</font>，表中最多只有一行匹配的记录，一次查询就可以找到。比如 select name from product where id=1。</p></li></ul><p>需要说明的是 const 类型和 eq_ref 都使用了主键或唯一索引，不过这两个类型有所区别，<strong><font color="red">const 是与常量进行比较，查询效率会更快；而 eq_ref 通常用于多表联查中</font></strong>。</p><ul><li><font color="cornflowerblue">system</font>：如果表使用的引擎对于表行数统计是精确的（如：MyISAM），且表中只有一行记录的情况下，访问方法是 system ，是 const 的一种特例。</li></ul><p>下面这个不知道性能如何...</p><ul><li><strong>index_merge</strong>：当查询条件使用了多个索引时，表示开启了 Index Merge 优化，此时执行计划中的 key 列列出了使用到的索引。</li></ul><h5 id="possible_keys"><a class="anchor" href="#possible_keys">#</a> possible_keys</h5><p>possible_keys 列表示<font color="red"> MySQL 执行查询时可能用到的索引</font>。如果这一列为 NULL ，则表示没有可能用到的索引；这种情况下，需要检查 WHERE 语句中所使用的的列，看是否可以通过给这些列中某个或多个添加索引的方法来提高查询性能。</p><h5 id="key重要"><a class="anchor" href="#key重要">#</a> key（重要）</h5><p>key 列表示<font color="red"> MySQL 实际使用到的索引</font>。如果为 NULL，则表示未用到索引。</p><h5 id="key_len"><a class="anchor" href="#key_len">#</a> key_len</h5><p>key_len 列表示 MySQL 实际使用的索引的最大长度；当使用到联合索引时，有可能是多个列的长度和。在满足需求的前提下越短越好。如果 key 列显示 NULL ，则 key_len 列也显示 NULL 。</p><h5 id="rows"><a class="anchor" href="#rows">#</a> rows</h5><p>rows 列表示根据表统计信息及选用情况，大致估算出找到所需的记录或所需读取的行数，数值越小越好。</p><h5 id="extra重要"><a class="anchor" href="#extra重要">#</a> <mark>Extra（重要）</mark></h5><p>这列包含了 MySQL 解析查询的额外信息，通过这些信息，可以更准确的理解 MySQL 到底是如何执行查询的。常见的值如下：</p><ul><li><strong><font color="cornflowerblue">Using filesort</font></strong>：在排序时使用了外部的索引排序，没有用到表内索引进行排序。</li><li><strong><font color="cornflowerblue">Using temporary</font></strong>：MySQL 需要创建临时表来存储查询的结果，常见于 ORDER BY 和 GROUP BY。</li><li><strong><font color="cornflowerblue">Using index</font></strong>：表明查询使用了覆盖索引，不用回表，查询效率非常高。</li><li><strong>Using index condition</strong>：表示查询优化器选择使用了索引条件下推这个特性。</li><li><strong>Using where</strong>：表明查询使用了 WHERE 子句进行条件过滤。一般在没有使用到索引的时候会出现。</li><li><strong>Using join buffer (Block Nested Loop)</strong>：连表查询的方式，表示当被驱动表的没有使用索引的时候，MySQL 会先将驱动表读出来放到 join buffer 中，再遍历被驱动表与驱动表进行查询。</li></ul><p>这里提醒下，当 Extra 列包含 Using filesort 或 Using temporary 时，MySQL 的性能可能会存在问题，需要尽可能避免。</p><h4 id="explain的结果有哪些有哪些信息去告诉你怎么优化"><a class="anchor" href="#explain的结果有哪些有哪些信息去告诉你怎么优化">#</a> <mark>🌟explain 的结果有哪些？有哪些信息去告诉你怎么优化？</mark></h4><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231130210942311.png" alt="image-20231130210942311"></p><p>对于执行计划，参数有：</p><ul><li><code>possible_keys</code> ：可能用到的索引；</li><li><code>key</code> ：<font color="red">实际用的索引</font>。如果这一项为 NULL，说明没有使用索引；</li><li><code>key_len</code> ：索引的长度；</li><li><code>rows</code> ：扫描的数据行数；</li><li><code>type</code> ：<font color="red">数据扫描类型</font>；</li><li><code>Extra</code> ：<font color="red">MySQL 解析查询的额外信息</font>；</li></ul><h5 id="type-字段"><a class="anchor" href="#type-字段">#</a> type 字段</h5><p>type 字段描述了<font color="red">找到所需数据时使用的扫描方式</font>是什么，常见扫描类型的 **<font color="#B32015">执行效率从低到高的顺序为</font>**：</p><ul><li><p><font color="cornflowerblue">All（全表扫描）</font>：最坏的情况，因为采用了<font color="red">全表扫描</font>的方式</p></li><li><p><font color="cornflowerblue">index（全索引扫描）</font>： 和 all 差不多，只不过 index <font color="red">对索引表进行全扫描</font>。这样做的好处是不再需要对数据进行排序，但是开销依然很大。</p><blockquote><p>所以要尽量避免全表扫描和全索引扫描。</p></blockquote></li><li><p><font color="cornflowerblue">range（索引范围扫描）</font>：一般在 where 子句中使用 &lt;、&gt;、in、between 等关键词，只检索给定范围的行，属于范围查找。</p><blockquote><p><strong><font color="red">从这一级别开始，索引的作用会越来越明显，因此我们需要尽量让 SQL 查询可以使用到 range 这一级别及以上的 type 访问方式</font></strong>。</p></blockquote></li><li><p><font color="cornflowerblue">ref（非唯一索引扫描）</font>：采用了非唯一索引，或者是唯一索引的非唯一性前缀，<font color="red">返回的数据可能是多条</font>。因为虽然使用了索引，但<font color="red">该索引列的值并不唯一，有重复</font>。这样即使使用索引快速查找到了第一条数据，仍然不能停止，要进行目标值附近的小范围扫描。但它的<font color="red">好处是它并不需要扫全表，因为索引是有序的，即便有重复值，也是在一个非常小的范围内扫描</font>。</p></li><li><p><font color="cornflowerblue">eq_ref（唯一索引扫描）</font>：<font color="red">使用主键索引或唯一索引</font>时产生的访问方式，<font color="red">通常使用在多表联查中</font>。比如，对两张表进行联查，关联条件是两张表的 user_id 相等，且 user_id 是唯一索引，那么使用 EXPLAIN 进行执行计划查看的时候，type 就会显示 eq_ref。</p></li><li><p><font color="cornflowerblue">const（结果只有一条的主键或唯一索引扫描）</font>：<font color="red">使用了主键或者唯一索引与常量值进行比较</font>，比如 select name from product where id=1。</p></li></ul><p>需要说明的是 const 类型和 eq_ref 都使用了主键或唯一索引，不过这两个类型有所区别，<strong><font color="red">const 是与常量进行比较，查询效率会更快；而 eq_ref 通常用于多表联查中</font></strong>。</p><h5 id="extra-字段"><a class="anchor" href="#extra-字段">#</a> Extra 字段</h5><p>这里说几个重要的参考指标：</p><ul><li><font color="cornflowerblue">Using filesort</font>：当查询语句中包含 group by 操作，而且无法利用索引完成排序操作的时候，这时<font color="red">不得不选择相应的排序算法进行，甚至可能会通过文件排序，效率是很低的</font>，所以要避免这种问题的出现。</li><li><font color="cornflowerblue">Using temporary</font>：<font color="red">使用临时表保存中间结果</font>，MySQL 在对查询结果排序时使用临时表，常见于排序 order by 和分组查询 group by。效率低，要避免这种问题的出现。</li><li><font color="cornflowerblue">Using index</font>：所需数据只需在索引即可全部获得，不须要再到表中取数据，也就是<font color="red">使用了覆盖索引，避免了回表操作</font>，效率不错。</li></ul><h3 id="mysql查询缓存"><a class="anchor" href="#mysql查询缓存">#</a> MySQL 查询缓存</h3><h4 id="介绍"><a class="anchor" href="#介绍">#</a> 介绍</h4><p><font color="red">执行查询语句的时候，会先查询缓存</font>。不过，<strong><font color="#B32015">MySQL 8.0 版本后移除</font></strong>，因为这个功能不太实用。</p><p><code>my.cnf</code> 加入以下配置，重启 MySQL 开启查询缓存：</p><figure class="highlight properties"><figcaption data-lang=".properties"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token key attr-name">query_cache_type</span><span class="token punctuation">=</span><span class="token value attr-value">1</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token key attr-name">query_cache_size</span><span class="token punctuation">=</span><span class="token value attr-value">600000</span></pre></td></tr></table></figure><p>MySQL 执行以下命令也可以开启查询缓存：</p><figure class="highlight properties"><figcaption data-lang=".properties"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token key attr-name">set</span> <span class="token value attr-value">global  query_cache_type=1;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token key attr-name">set</span> <span class="token value attr-value">global  query_cache_size=600000;</span></pre></td></tr></table></figure><p>如上，<strong><font color="red">开启查询缓存后，在同样的查询条件以及数据情况下，会直接在缓存中返回结果</font></strong>。这里的查询条件包括查询本身、当前要查询的数据库、客户端协议版本号等一些可能影响结果的信息。</p><p><strong>查询缓存不命中的情况：</strong></p><ol><li><font color="red">任何两个查询在任何字符上的不同</font>都会导致缓存不命中。</li><li>如果查询中包含任何<font color="red">用户自定义函数、存储函数、用户变量、临时表、MySQL 库中的系统表</font>，其查询结果也不会被缓存。</li><li>缓存建立之后，MySQL 的查询缓存系统会跟踪查询中涉及的每张表，<font color="red">如果这些表（数据或结构）发生变化，那么相关的所有缓存数据都将失效</font>。</li></ol><p>** 缓存虽然能够提升数据库的查询性能，但是缓存同时也带来了额外的开销，每次查询后都要做一次缓存操作，失效后还要销毁。** 因此，开启查询缓存要谨慎，尤其对于写密集的应用来说更是如此。如果开启，要注意合理控制缓存空间大小，一般来说其大小设置为几十 MB 比较合适。</p><p>此外，还可以通过 <code>sql_cache</code> 和 <code>sql_no_cache</code> 来控制某个查询语句是否需要缓存：</p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">select</span> sql_no_cache <span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">from</span> usr<span class="token punctuation">;</span></pre></td></tr></table></figure><h4 id="总结"><a class="anchor" href="#总结">#</a> 总结</h4><p><font color="red">MySQL 中的查询缓存虽然能够提升数据库的查询性能，但是查询同时也带来了额外的开销，每次查询后都要做一次缓存操作，失效后还要销毁</font>。</p><p>查询缓存是一个适用较少情况的缓存机制。如果你的应用对数据库的更新很少，那么查询缓存将会作用显著。比较典型的如博客系统，一般博客<font color="red">更新相对较慢，数据表相对稳定不变，这时候查询缓存的作用会比较明显</font>。</p><p>简单总结一下查询缓存的<font color="gree">适用场景</font>：</p><ul><li>表数据修改不频繁、数据较静态</li><li>查询（Select）重复度高</li><li>查询结果集小于 1 MB</li></ul><p>对于一个更新频繁的系统来说，查询缓存缓存的作用是很微小的，在某些情况下开启查询缓存会带来性能的下降。</p><p>简单总结一下查询缓存<font color="gree">不适用的场景</font>：</p><ul><li>表中的数据、表结构或者索引变动频繁</li><li>重复的查询很少</li><li>查询的结果集很大</li></ul><p>《高性能 MySQL》这样写到：</p><blockquote><p>根据我们的经验，<strong><font color="red">在高并发压力环境中查询缓存会导致系统性能的下降，甚至僵死</font></strong>。如果你一定要使用查询缓存，那么不要设置太大内存，而且只有在明确收益的时候才使用（数据库内容修改次数较少）。</p></blockquote><p>确实是这样的！<strong><font color="red">实际项目中，更建议使用本地缓存（比如 Caffeine）或者分布式缓存（比如 Redis），性能更好，更通用一些。</font></strong></p><h3 id="mysql三大日志"><a class="anchor" href="#mysql三大日志">#</a> <mark>🌟MySQL 三大日志</mark></h3><blockquote><p>binlog、redo log、undo log</p></blockquote><h4 id="简介"><a class="anchor" href="#简介">#</a> <mark>🌟简介</mark></h4><p><code>MySQL</code> 日志 主要包括错误日志、查询日志、事务日志、二进制日志几大类。其中，比较重要的还要属：</p><ul><li>二进制日志： <code>binlog</code> （归档日志）</li><li>事务日志： <code>redo log</code> （重做日志）、 <code>undo log</code> （回滚日志）</li></ul><p>下面对这三种日志进行简介：</p><ul><li><strong><font color="cornflowerblue">binlog（二进制日志 / 归档日志）</font></strong>：<font color="red">是逻辑日志，记录了语句的原始逻辑</font>。无论用哪种存储引擎，<font color="red">只要表发生了数据更新，都会产生 binlog 日志</font>。<strong><font color="red">主要用于主从复制（读写分离）</font></strong>，在主从复制中，从库利用主库上的 binlog 进行重播，实现主从数据同步。</li><li><strong><font color="cornflowerblue">redo log（重做日志）</font></strong>：<font color="red">是物理日志，记录了在某个数据页上做了什么修改</font>。防止在发生故障的时间点，尚有脏页未写入磁盘，在重启 mysql 服务的时候，<strong><font color="red">根据 redo log 进行重做，从而确保事务的持久性（D）</font></strong>。</li><li><strong><font color="cornflowerblue">undo log（回滚日志）</font></strong>：<font color="red">是逻辑日志，记录的是逻辑相反的操作信息</font>。可以 **<font color="red">用于回滚</font><strong>，当执行 rollback 时，就可以从 undo log 中的逻辑记录读取到相应的内容并进行回滚，以确保事务的原子性（A）。同时</strong><font color="red">可以提供 MVCC 下的读（即非锁定读 / 快照读）</font>**。</li></ul><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/01.png" alt="img"></p><h4 id="redo-log重做日志-2"><a class="anchor" href="#redo-log重做日志-2">#</a> redo log（重做日志）</h4><p><code>redo log</code> （重做日志）<font color="red">是 InnoDB 存储引擎独有的</font>，它让 <code>MySQL</code> 拥有了<strong>崩溃恢复能力</strong>。</p><p>比如 <code>MySQL</code> 实例挂了或宕机了，重启时， <code>InnoDB</code> 存储引擎会使用 <code>redo log</code> 恢复数据，保证数据的持久性与完整性。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/02.png" alt="img"></p><p>InnoDB 表的读写流程：</p><ol><li><font color="red">MySQL 中数据以页为单位</font>，你查询一条记录，会从硬盘把一页的数据加载出来，加载出来的数据叫<strong>数据页</strong>，会放入到 <strong>缓冲池 Buffer Pool</strong> 中。</li><li>后续的查询都是先从 缓冲池 Buffer Pool 中找，没有命中再去硬盘加载，减少硬盘 <code>IO</code> 开销，提升性能。更新表数据的时候，也是如此，发现缓冲池 Buffer Pool 里存在要更新的数据，就直接在缓冲池 Buffer Pool 里更新。</li><li>然后会把 “在某个数据页上做了什么修改” 记录到 ** 重做日志缓存（ <code>redo log buffer</code> ）** 里</li><li>最后，清空 redo log buffer，并刷盘到 <strong>redo log file</strong> 中</li></ol><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/03.png" alt="img"></p><h5 id="刷盘时机"><a class="anchor" href="#刷盘时机">#</a> 刷盘时机</h5><blockquote><p>小贴士：<font color="red">每条 redo 记录由 “表空间号 + 数据页号 + 偏移量 + 修改数据长度 + 具体修改的数据” 组成</font>。</p></blockquote><p>InnoDB 将 redo log buffer 刷到磁盘上有几种情况：</p><ol><li><p><strong>事务提交</strong>：当事务提交时，redo log buffer 里的 redo log 会被刷新到磁盘（可以通过 <code>innodb_flush_log_at_trx_commit</code> 参数控制，后文会提到）。</p></li><li><p><strong>log buffer 空间不足时</strong>：当 log buffer 的容量被占满大约一半时，就需要把这些日志刷新到磁盘上。</p></li><li><p><strong>事务日志缓冲区（transaction log buffer）满时</strong>：InnoDB 使用一个事务日志缓冲区来暂时存储事务的重做日志条目。当缓冲区满时，会触发日志的刷新，将日志写入磁盘。</p></li><li><p><strong>定期执行 Checkpoint（检查点）操作时</strong>：InnoDB 定期会执行检查点操作，将内存中的<font color="red">脏数据（已修改但尚未写入磁盘的数据）</font>刷新到磁盘，并且会将相应的重做日志一同刷新，以确保数据的一致性。</p></li><li><p><strong><font color="#B32015">后台线程会周期性刷盘</font></strong>：InnoDB 启动了一个后台线程，负责周期性（每隔 1 秒）地把 redo log buffer 中的内容写到<strong>文件系统缓存（page cache）</strong>，然后调用 <strong><code>fsync</code> </strong>刷盘。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/04.png" alt="img"></p></li><li><p><strong>正常关闭服务器时</strong>：MySQL 关闭的时候，redo log 都会刷入到磁盘里去。</p></li></ol><p>总之，InnoDB 在多种情况下会刷新重做日志，以保证数据的持久性和一致性。</p><hr><p>我们要注意设置正确的 **<font color="red">刷盘策略参数 <code>innodb_flush_log_at_trx_commit</code> </font>**。根据 MySQL 配置的刷盘策略的不同，MySQL 宕机之后可能会存在轻微的数据丢失问题。该参数的取值有 3 种，也就是共有 3 种刷盘策略：</p><ul><li><p><strong>0</strong>：设置为 0 的时候，表示<font color="red">每次事务提交时不进行刷盘操作</font>，而是等待后台线程定期（1 秒）刷盘。这种方式性能最高，但是也最不安全，因为如果 MySQL 挂了或宕机了，可能会丢失最近 1 秒内的事务。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/06.png" alt="img"></p></li><li><p><strong>1</strong>：设置为 1 的时候，表示<font color="red">每次事务提交时都将进行刷盘操作</font>。这种方式性能最低，但是也最安全，因为只要事务提交成功，redo log 记录就一定在磁盘里，不会有任何数据丢失。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/07.png" alt="img"></p></li><li><p><strong>2</strong>：设置为 2 的时候，表示<font color="red">每次事务提交时都只把 log buffer 里的 redo log 内容写入 page cache（文件系统缓存）</font>。page cache 是专门用来缓存文件的，这里被缓存的文件就是 redo log 文件。这种方式的性能和安全性都介于前两者中间。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/09.png" alt="img"></p></li></ul><h5 id="日志文件组"><a class="anchor" href="#日志文件组">#</a> 日志文件组</h5><p>硬盘上存储的 <code>redo log</code> 是以一个<strong>日志文件组</strong>的形式出现的，每个日志文件的大小都一样。</p><p>比如可以配置为一组 4 个文件，每个文件的大小是 1GB，那么整个 <code>redo log</code> 日志文件组可以记录 4G 的内容。</p><p>它采用的是<font color="red">环形数组形式</font>，从头开始写，写到末尾又回到头循环写，如下图所示。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/10.png" alt="img"></p><p>在日志文件组中还有两个重要的属性：</p><ul><li><strong>write pos</strong> ：当前记录的写入位置，一边写一边后移</li><li><strong>checkpoint</strong>：当前要擦除的位置，也是往后推移</li></ul><p>每次刷盘 <code>redo log</code> 记录到<strong>日志文件组</strong>中， <code>write pos</code> 位置就会后移更新。</p><p>每次 MySQL 加载<strong>日志文件组</strong>恢复数据时，会清空加载过的 <code>redo log</code> 记录，并把 <code>checkpoint</code> 后移更新。</p><p><code>write pos</code> 和 <code>checkpoint</code> 之间的还空着的部分可以用来写入新的 <code>redo log</code> 记录。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/11.png" alt="img"></p><p>如果 <code>write pos</code> 追上 <code>checkpoint</code> ，表示<strong>日志文件组</strong>满了，这时候不能再写入新的 <code>redo log</code> 记录， <code>MySQL</code> 得停下来，清空一些记录，把 <code>checkpoint</code> 推进一下。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/12.png" alt="img"></p><p>在 MySQL 8.0.30 之前，可以通过 <code>innodb_log_files_in_group</code> 和 <code>innodb_log_file_size</code> 配置日志文件组的文件数和文件大小。</p><p>但在 MySQL 8.0.30 及之后的版本中，这两个变量已被废弃，即使被指定也是用来计算 <code>innodb_redo_log_capacity</code> 的值。而<font color="red">日志文件组的文件数则固定为 32，文件大小则为 <code>innodb_redo_log_capacity / 32</code> </font>。</p><h5 id="小结"><a class="anchor" href="#小结">#</a> 小结</h5><p>思考一个问题：<strong>只要每次把修改后的数据页直接刷盘不就好了，还有 <code>redo log</code> 什么事？</strong></p><p>它们不都是刷盘么？差别在哪里？</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token number">1</span> <span class="token class-name">Byte</span> <span class="token operator">=</span> <span class="token number">8</span>bit</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token number">1</span> <span class="token constant">KB</span> <span class="token operator">=</span> <span class="token number">1024</span> <span class="token class-name">Byte</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token number">1</span> <span class="token constant">MB</span> <span class="token operator">=</span> <span class="token number">1024</span> <span class="token constant">KB</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token number">1</span> <span class="token constant">GB</span> <span class="token operator">=</span> <span class="token number">1024</span> <span class="token constant">MB</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token number">1</span> <span class="token constant">TB</span> <span class="token operator">=</span> <span class="token number">1024</span> <span class="token constant">GB</span></pre></td></tr></table></figure><p>实际上，<font color="red">数据页大小是 <code>16KB</code> ，刷盘比较耗时</font>，可能就修改了数据页里的几 <code>Byte</code> 数据，有必要把完整的数据页刷盘吗？</p><p>而且数据页刷盘是随机写，因为一个数据页对应的位置可能在硬盘文件的随机位置，所以性能是很差。</p><p>如果是写 <code>redo log</code> ，一行记录可能就占几十 <code>Byte</code> ，只包含表空间号、数据页号、磁盘文件偏移量、更新值，再加上是顺序写，所以刷盘速度很快。</p><p>所以<font color="red">用 <code>redo log</code> 形式记录修改内容，性能会远远超过刷数据页的方式，这也让数据库的并发能力更强</font>。</p><blockquote><p>其实内存的数据页在一定时机也会刷盘，我们把这称为<strong>页合并</strong>，讲 <code>Buffer Pool</code> 的时候会对这块细说</p></blockquote><h4 id="binlog归档日志"><a class="anchor" href="#binlog归档日志">#</a> binlog（归档日志）</h4><p><code>redo log</code> 它是物理日志，记录内容是 “在某个数据页上做了什么修改”，属于 <code>InnoDB</code> 存储引擎。</p><p>而 <font color="red"><code>binlog</code> 是逻辑日志，记录内容是语句的原始逻辑，会记录所有涉及更新数据的逻辑操作，并且是顺序写。</font>类似于 “给 ID=2 这一行的 c 字段加 1”，属于 <code>MySQL Server</code> 层。</p><p>不管用什么存储引擎，<font color="red">只要发生了表数据更新，都会产生 <code>binlog</code> 日志</font>。</p><p>可以说 <code>MySQL</code> 数据库的<font color="red">数据备份、主备、主主、主从</font>都离不开 <code>binlog</code> ，需要依靠 <code>binlog</code> 来<strong>同步数据，保证数据一致性</strong>。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/01-20220305234724956.png" alt="img"></p><h5 id="记录格式"><a class="anchor" href="#记录格式">#</a> 记录格式</h5><p><code>binlog</code> 日志有三种格式，可以通过 <code>binlog_format</code> 参数指定。</p><ul><li><p><strong>statement</strong>：记录的是 **<font color="red">SQL 语句原文</font>**。比如执行一条 <code>update T set update_time=now() where id=1</code> ，记录的内容如下：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/02-20220305234738688.png" alt="img"></p><p>同步数据时，会执行记录的 SQL 语句，但是有个问题， <code>update_time=now()</code> 这里会获取当前系统时间，直接执行会导致与原库的数据不一致。为了解决这种问题，我们需要指定为 <code>row</code> 。</p></li><li><p><strong>row</strong>：<font color="red">防止数据不一致</font>，记录的是 **<font color="red">包含具体操作数据的 SQL 语句</font>**，需要通过工具 <code>mysqlbinlog</code> 解析。这样就能保证同步数据的一致性，通常情况下都是指定为 <code>row</code> ，这样可以<font color="red">为数据库的恢复与同步带来更好的可靠性</font>。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/03-20220305234742460.png" alt="img"></p><p>但是这种格式，<font color="red">需要更大的容量来记录，比较占用空间</font>，恢复与同步时会更消耗 IO 资源，影响执行速度。</p></li><li><p><strong>mixed</strong>：一种折中的方案，记录的是 **<font color="red">前两者的混合</font>**。MySQL 会<font color="red">判断这条 SQL 语句是否可能引起数据不一致，如果是，就用 <code>row</code> 格式，否则就用 <code>statement</code> 格式</font>。</p></li></ul><h5 id="写入机制"><a class="anchor" href="#写入机制">#</a> 写入机制</h5><p><code>binlog</code> 的写入时机也非常简单，<strong>事务执行过程中，先把日志写到 <code>binlog cache</code> ，事务提交的时候，再把 <code>binlog cache</code> 写到 <code>binlog</code> 文件中</strong>。</p><p>因为一个事务的 <code>binlog</code> 不能被拆开，无论这个事务多大，也要确保一次性写入，所以系统会给每个线程分配一个块内存作为 <code>binlog cache</code> 。</p><p>我们可以通过 <code>binlog_cache_size</code> 参数控制单个线程 binlog cache 大小，如果存储内容超过了这个参数，就要暂存到磁盘（ <code>Swap</code> ）。</p><hr><p><code>binlog</code> 日志刷盘流程如下：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/04-20220305234747840.png" alt="img"></p><ul><li><strong>write：把 binlog 日志写入到文件系统的 page cache，并没有把数据持久化到磁盘，所以速度比较快</strong></li><li><strong>fsync：将数据持久化到磁盘的操作</strong></li></ul><hr><p>write 和 fsync 的时机，可以由 ** 参数 <code>sync_binlog</code> ** 控制，默认是 1。</p><p>为 0 的时候，表示每次提交事务都只 <code>write</code> ，由系统自行判断什么时候执行 <code>fsync</code> 。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/05-20220305234754405.png" alt="img"></p><p>虽然性能得到提升，但是机器宕机， <code>page cache</code> 里面的 binlog 会丢失。</p><p>为了安全起见，可以设置为 <code>1</code> ，表示每次提交事务都会执行 <code>fsync</code> ，就如同 <strong>redo log 日志刷盘流程</strong> 一样。</p><hr><p>还有一种折中方式，可以设置为 <code>N(N&gt;1)</code> ，表示每次提交事务都 <code>write</code> ，但累积 <code>N</code> 个事务后才 <code>fsync</code> 。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/06-20220305234801592.png" alt="img"></p><p>在出现 <code>IO</code> 瓶颈的场景里，将 <code>sync_binlog</code> 设置成一个比较大的值，可以提升性能。</p><p>同样的，如果机器宕机，会丢失最近 <code>N</code> 个事务的 <code>binlog</code> 日志。</p><h4 id="两阶段提交"><a class="anchor" href="#两阶段提交">#</a> <mark>🌟两阶段提交</mark></h4><blockquote><p>解决 redo log 和 binlog 的一致性问题</p></blockquote><p>在执行更新语句过程，会记录 <code>redo log</code> 与 <code>binlog</code> 两块日志，以基本的事务为单位，<font color="red"> <code>redo log</code> 在事务执行过程中可以不断写入，而 <code>binlog</code> 只有在提交事务时才写入</font>，所以 <code>redo log</code> 与 <code>binlog</code> 的写入时机不一样。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/01-20220305234816065.png" alt="img"></p><hr><p>为了解决两份日志之间的逻辑一致问题， <code>InnoDB</code> 存储引擎使用 <strong>两阶段提交</strong> 方案。原理很简单，<font color="red">将  <code>redo log</code> 的写入拆成了两个步骤  <code>prepare</code> 和  <code>commit</code> </font>。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/04-20220305234956774.png" alt="img"></p><p><font color="red">使用两阶段提交后，写入  <code>binlog</code> 时发生异常也不会有影响，因为 MySQL 根据  <code>redo log</code> 日志恢复数据时，发现  <code>redo log</code> 还处于  <code>prepare</code> 阶段，并且没有对应  <code>binlog</code> 日志，就会回滚该事务</font>。</p><hr><p>再看一个场景， <code>redo log</code> 设置 <code>commit</code> 阶段发生异常，此时不会回滚事务。它会执行下图框住的逻辑，虽然 <code>redo log</code> 是处于 <code>prepare</code> 阶段，但是能通过事务 <code>id</code> 找到对应的 <code>binlog</code> 日志，所以 <code>MySQL</code> 认为是完整的，就会提交事务恢复数据。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/06-20220305234907651.png" alt="img"></p><hr><p>这意味着一个事务到底有没有成功，看 <code>redo log</code> 里面有没有 commit 记录，如果有 commit 记录，那么 <code>binlog</code> 一定是持久化成功了，也就是说事务成功了。</p><h4 id="undo-log回滚日志"><a class="anchor" href="#undo-log回滚日志">#</a> undo log（回滚日志）</h4><p>我们知道如果想要保证事务的原子性，就需要在异常发生时，对已经执行的操作进行<strong>回滚</strong>。在 MySQL 中，恢复机制是通过 ** 回滚日志（undo log）** 实现的。</p><p>所有事务进行的修改都会先记录到这个回滚日志中，然后再执行相关的操作。如果执行过程中遇到异常的话，我们直接利用回滚日志中的信息将数据回滚到修改之前的样子即可！</p><p>并且，回滚日志会先于数据持久化到磁盘上。这样就保证了即使遇到数据库突然宕机等情况，当用户再次启动数据库的时候，数据库还能够通过查询回滚日志来回滚将之前未完成的事务。</p><p>另外， <code>MVCC</code> 的实现依赖于：<strong>隐藏字段、Read View、undo log</strong>。在内部实现中， <code>InnoDB</code> 通过数据行的 <code>DB_TRX_ID</code> 和 <code>Read View</code> 来判断数据的可见性，如不可见，则通过数据行的 <code>DB_ROLL_PTR</code> 找到 <code>undo log</code> 中的历史版本。每个事务读到的数据版本可能是不一样的，在同一个事务中，用户只能看到该事务创建 <code>Read View</code> 之前已经提交的修改和该事务本身做的修改。</p><h4 id="总结-2"><a class="anchor" href="#总结-2">#</a> 总结</h4><p>InnoDB 引擎使用 <strong>redo log (重做日志)</strong> 保证事务的<strong>持久性</strong>，使用 <strong>undo log (回滚日志)</strong> 来保证事务的<strong>原子性</strong>。</p><p>MySQL 数据库的<strong>数据备份、主备、主主、主从</strong>都离不开 <code>binlog</code> ，需要依靠 <code>binlog</code> 来同步数据，保证数据一致性。</p><h4 id="常见面试题"><a class="anchor" href="#常见面试题">#</a> 常见面试题</h4><h5 id="mysql-中常见的日志有哪些"><a class="anchor" href="#mysql-中常见的日志有哪些">#</a> <mark>MySQL 中常见的日志有哪些？</mark></h5><p>MySQL 中常见的日志有以下几种：</p><ul><li><strong><font color="cornflowerblue">归档日志（binlog）</font></strong>：记录了所有修改了数据库结构或数据内容的操作，以便在主从复制时将这些操作同步到从库。二进制日志是<font color="red">逻辑日志</font>，记录的是对<font color="red">数据库结构或数据内容</font>的修改。</li><li><strong><font color="cornflowerblue">重做日志（redo log）</font></strong>：redo log 是 MySQL 的一种日志，<strong>是 InnoDB 存储引擎独有的，它让 MySQL 拥有了崩溃恢复能力</strong>。<font color="red">redo log 只记录该存储引擎中表的修改，而 binlog 是在数据库层面产生的，所有存储引擎对数据库进行修改都会产生 binlog</font>。redo log 是<font color="red">物理日志</font>，记录的是对<font color="red">数据页</font>的修改，而不是对数据的修改。</li><li><strong><font color="cornflowerblue">回滚日志（undo log）</font></strong>：<strong>是 InnoDB 存储引擎独有的</strong>，记录了所有修改了数据的操作，以便在事务回滚时撤销这些操作。回滚日志是<font color="red">逻辑日志</font>，记录的是对<font color="red">数据</font>的修改，而不是对数据页的修改。</li><li>错误日志（errorlog）：记录了 MySQL 服务器启动、运行过程中出现的错误信息。</li><li><font color="cornflowerblue">慢查询日志（slow query log）</font>：<font color="red">记录了执行时间超过指定阈值的 DQL 语句</font>，因此可以查看该日志来优化 DQL 语句。慢查询日志<font color="red">默认是不开启的</font>。</li><li>一般查询日志（general log）：记录了 MySQL 服务器接收到的所有 SQL 语句，包括执行时间、执行结果等信息。一般查询日志可以用于调试和安全审计。</li><li>中继日志（relay log）：是 MySQL 主从复制结构中<font color="red">从节点上的日志，用于保存主节点传输过来的数据变更事件，然后将这些事件应用于从节点</font>。</li></ul><h5 id="慢查询日志有什么用"><a class="anchor" href="#慢查询日志有什么用">#</a> 慢查询日志有什么用？</h5><p>用来<font color="red">记录在 MySQL 中响应时间超过阀值的语句</font>，具体指运行时间超过 long_query_time 值的 SQL，则会被记录到慢查询日志中。long_query_time 的默认值为 10，意思是运行 10 秒以上的 SQL 语句。慢查询日志<font color="red">可以帮助开发人员找出哪些语句的执行效率低，以便进行优化</font>。</p><h5 id="mysql-如何优化一个慢查询语句"><a class="anchor" href="#mysql-如何优化一个慢查询语句">#</a> <mark>MySQL 如何优化一个慢查询语句？</mark></h5><p>指路→<a href="#==%E6%85%A2%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E4%BC%98%E5%8C%96==">慢查询语句优化</a></p><h5 id="binlog-主要记录了什么"><a class="anchor" href="#binlog-主要记录了什么">#</a> binlog 主要记录了什么？</h5><p>binlog 是 MySQL 的二进制日志，主要<font color="red">记录了对 MySQL 数据库进行的所有更改操作，包括插入、更新和删除操作</font>。binlog 可以用于数据恢复、数据同步和数据备份等方面 。</p><h5 id="介绍一下redo-log以及它如何保证事务的持久性"><a class="anchor" href="#介绍一下redo-log以及它如何保证事务的持久性">#</a> 介绍一下 redo log，以及它如何保证事务的持久性？</h5><p>redo log 是 MySQL 的一种日志，<strong>是 InnoDB 存储引擎独有的，它让 MySQL 拥有了崩溃恢复能力</strong>。<font color="red">redo log 只记录该存储引擎中表的修改，而 binlog 是在数据库层面产生的，所有存储引擎对数据库进行修改都会产生 binlog</font>。</p><p>redo log 是 MySQL 数据库用于保证事务的持久性的机制之一。在执行一个事务时，<font color="red">MySQL 会将事务所做出的修改操作先写入 redo log 而不是直接保存到磁盘</font>，也就是 <code>WAL（write ahead log)机制</code> 。这是因为将数据直接写入磁盘的开销较大，而将修改操作写入 redo log 可以大幅减少磁盘 IO 的次数。</p><blockquote><p>WAL（write ahead log）机制的基本思想：</p><p>在修改数据之前，先将修改操作记录到一个日志文件中，然后再将修改操作应用到数据库中。这样，即使在修改数据的过程中出现了故障，也可以通过日志文件来恢复数据 。</p></blockquote><p>当一个事务提交后，<font color="red">MySQL 会从 redo log 中读取相应的修改操作，并将其写入磁盘</font>。<font color="red">只要 redo log 已经持久化（即已经写入磁盘），那么就可以保证故障发生后能够完成数据恢复</font>。如果 MySQL 在执行修改操作时遇到了宕机等问题，在重启后会重新应用 redo log 里未被应用的操作，从而实现事务的持久性。</p><h5 id="数据页是什么"><a class="anchor" href="#数据页是什么">#</a> 数据页是什么？</h5><p>数据页是 InnoDB 存储引擎中的一个重要概念，它<strong>是 InnoDB 存储引擎中的最小存储单位。InnoDB 存储引擎将表空间分为多个大小相等的数据页，每个数据页默认大小为 16KB</strong>。在 InnoDB 存储引擎中，每个表都有一个独立的表空间，表空间由多个数据文件组成。当表中的数据发生变化时，InnoDB 存储引擎会将修改操作记录到 redo log 中，并将修改操作应用到内存中的数据页中。当内存中的数据页被修改后，InnoDB 存储引擎会将修改操作异步刷新到磁盘上的数据文件中，从而保证了数据的持久性。</p><h5 id="页修改之后为什么不直接刷盘呢"><a class="anchor" href="#页修改之后为什么不直接刷盘呢">#</a> 页修改之后为什么不直接刷盘呢？</h5><p>在数据库中，将修改的数据直接刷盘（写入磁盘）可能会产生一些性能开销。这是因为在执行随机磁盘 IO 的过程中，磁盘的寻址时间和磁道切换时间等所需的开销较大，说明磁盘 IO 时需要耗费较长的时间。因此<strong>直接刷盘会导致大量的磁盘 I/O，降低系统的性能</strong>。</p><p>为了避免这种情况，InnoDB 存储引擎采用了一种称为 “ <code>脏页刷盘</code> ” 的机制。<font color="red">在数据库缓存中，如果一个数据页上的数据已经被修改了，但还没有被同步写入磁盘，那么这个数据页就被称为 “ <code>脏页</code> ”</font>。 <code>脏页刷盘</code> 机制是指 InnoDB 存储引擎在<font color="red">将内存中的数据页刷新到磁盘上</font>时，会根据一定的策略来决定哪些数据页需要被刷新到磁盘上，哪些数据页可以暂时不刷新。</p><ul><li><font color="red">当内存中的数据页被修改前，InnoDB 存储引擎会将修改操作记录到 redo log 中，并将修改操作应用到内存中的数据页中</font>。</li><li><font color="red">当内存中的数据页被修改后，InnoDB 存储引擎会将修改操作异步刷新到磁盘上的数据文件中，从而保证了数据的持久性</font>。在这个过程中，InnoDB 存储引擎会根据一定的策略来决定哪些数据页需要被刷新到磁盘上，哪些数据页可以暂时不刷新。这样可以避免大量的磁盘 I/O，提高系统的性能。</li></ul><h5 id="binlog-和-redolog-有什么区别"><a class="anchor" href="#binlog-和-redolog-有什么区别">#</a> binlog 和 redolog 有什么区别？</h5><p>binlog 和 redolog 都是 MySQL 数据库中的日志文件，用于记录数据库的修改操作。它们的主要区别在于：</p><ol><li><p>binlog 是 MySQL 的归档日志，用于<font color="red">记录所有的修改操作，包括数据的增删改操作和表结构的变更操作等</font>。binlog 的作用是<font color="red">用于数据恢复、主从复制和数据同步</font>等场景。</p></li><li><p>redolog 是 InnoDB 存储引擎的事务日志，用于<font color="red">记录事务的修改操作</font>。redolog 的作用是<font color="red">用于保证事务的原子性、一致性和持久性</font>。当一个事务提交时，会将该事务所做的所有修改操作先记录在 redo log 中并刷到磁盘上，然后再将这些修改操作同步到数据库的数据文件中。</p></li></ol><p>区别:</p><ul><li>binlog 是整个<font color="red">数据库实例级别</font>的，记录了对整个数据库实例进行的所有更改操作，而 redolog 是每个<font color="red">InnoDB 存储引擎实例级别</font>的，只记录了在该存储引擎实例中发生的事务更改操作。</li><li>binlog 是对<font color="red">数据库执行的语句级别</font>的日志，redolog 是对<font color="red">事务级别</font>的日志，记录了事务的具体操作信息。</li><li>binlog 通常<font color="red">用于 JDBC 等客户端进行异地灾难恢复</font>，而 redolog<font color="red">用于保证事务的 ACID 属性（原子性、一致性、隔离性和持久性）</font>。</li></ul><p>因为<font color="red"> binlog 记录了所有的修改操作，所以它比 redolog 更加全面，但也更加耗费磁盘空间</font>。而 <font color="red">redolog 只记录了事务的修改操作，所以它比 binlog 更加高效，但也更加局限</font>。</p><h5 id="undo-log-如何保证事务的原子性"><a class="anchor" href="#undo-log-如何保证事务的原子性">#</a> undo log 如何保证事务的原子性？</h5><p>undo log <font color="red">是 InnoDB 存储引擎的</font>回滚日志，<font color="red">用于记录事务的回滚操作</font>。</p><p>当一个事务需要回滚时，InnoDB 存储引擎会根据 undo log 中的信息将数据页恢复到事务开始之前的状态。因此，undo log 可以保证事务的原子性。</p><p>在 InnoDB 存储引擎中，每个事务都有一个对应的 undo log，用于记录该事务所做的修改操作。当事务提交时，InnoDB 存储引擎会将 undo log 中的信息删除，从而释放磁盘空间。如果事务回滚，则 InnoDB 存储引擎会根据 undo log 中的信息将数据页恢复到事务开始之前的状态。这样可以保证事务的原子性。</p><h3 id="mysql事务"><a class="anchor" href="#mysql事务">#</a> <mark>🌟MySQL 事务</mark></h3><h4 id="事务"><a class="anchor" href="#事务">#</a> 事务</h4><p><font color="red">事务是一个完整的业务逻辑，内部的所有操作要么全部成功，要么全部失败</font>。</p><h4 id="数据库事务"><a class="anchor" href="#数据库事务">#</a> 数据库事务</h4><p><font color="red">对于数据库来说，事务是由批量的 DML 语句所构成的逻辑整体，要么全执行成功，要么全执行失败</font>。</p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment"># 开启一个事务</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">START</span> <span class="token keyword">TRANSACTION</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment"># 多条 SQL 语句</span></pre></td></tr><tr><td data-num="4"></td><td><pre>SQL1<span class="token punctuation">,</span>SQL2<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token comment">## 提交事务</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">COMMIT</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230424112420132.png" alt="image-20230424112420132"></p><h4 id="acid-特征"><a class="anchor" href="#acid-特征">#</a> <mark>🌟ACID 特征</mark></h4><p>关系型数据库（例如： <code>MySQL</code> 、 <code>SQL Server</code> 、 <code>Oracle</code> 等）事务都有 <strong>ACID</strong> 特性：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230424112518237.png" alt="image-20230424112518237"></p><ul><li><p><strong>原子性</strong>（ <code>Atomicity</code> ）：事务是不可分割的最小操作单元，内部的所有操作要么全部成功，要么全部失败；</p><blockquote><p><font color="red">由 Undo Log 日志保证</font>，记录了需要回滚的日志信息，事务回滚时撤销已经执行成功的 SQL 语句。</p></blockquote></li><li><p><strong>一致性</strong>（ <code>Consistency</code> ）：事务完成前后，数据库必须保持一致状态，即都是合理的数据状态。例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；</p><blockquote><p><font color="red">由 A、I、D 共同保证</font></p></blockquote></li><li><p><strong>隔离性</strong>（ <code>Isolation</code> ）：数据库提供的隔离机制，可以保证事务在不受外部并发操作影响的独立环境下运行。即并发访问数据库时，一个事务所做的修改在最终提交前，对其他并发事务是不可见的。各并发事务之间，数据库是独立的；</p><blockquote><p><font color="red">由 MVCC 保证</font></p></blockquote></li><li><p><strong>持久性</strong>（ <code>Durability</code> ）：事务一旦提交，它对数据库中数据的更改就是持久的。即使数据库发生故障，这种更改也不会丢失。</p><blockquote><p><font color="red">由 内存 + Redo Log 保证</font>，MySQL 修改数据同时在内存和 Redo Log 记录这次操作，宕机时可从 Redo Log 恢复数据。</p></blockquote></li></ul><blockquote><p>**A、I、D 是手段，C 才是目的！** 只有保证了事务的原子性、隔离性、持久性之后，一致性才能得到保障。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230424112548870.png" alt="image-20230424112548870"></p></blockquote><h4 id="4个一致性问题"><a class="anchor" href="#4个一致性问题">#</a> <mark>🌟4 个一致性问题</mark></h4><p>多个事务并发运行，经常会操作相同的数据来完成各自的任务（例如多个客户端并发地访问同一个表），如果事务之间没有设置合理的隔离级别，可能会导致以下 4 种问题。</p><h5 id="脏读dirty-read"><a class="anchor" href="#脏读dirty-read">#</a> 脏读（Dirty read）</h5><p>一个事务读取并修改了数据，这个修改对其他并发事务来说是可见的，即使该事务还没有提交。这时另一个并发事务读取了这个还未提交的数据，但是第一个事务突然回滚，导致数据并没有被提交到数据库。那第二个事务读取到的就是脏数据，这也就是脏读的由来。</p><p>例如：事务 1 读取某表中的数据 A=20，事务 1 修改 A=A-1，事务 2 读取到 A = 19, 事务 1 回滚导致对 A 的修改并为提交到数据库， A 的值还是 20。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230424112618536.png" alt="脏读"></p><center>脏读（Dirty read）</center><h5 id="丢失修改lost-to-modify"><a class="anchor" href="#丢失修改lost-to-modify">#</a> 丢失修改（Lost to modify）</h5><p>在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。</p><p>例如：事务 1 读取某表中的数据 A=20，事务 2 也读取 A=20，事务 1 先修改 A=A-1，事务 2 后来也修改 A=A-1，最终结果 A=19，事务 1 的修改被丢失。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230424112636565.png" alt="image-20230424112636565"></p><center>丢失修改（Lost to modify）</center><h5 id="不可重复读unrepeatable-read"><a class="anchor" href="#不可重复读unrepeatable-read">#</a> 不可重复读（Unrepeatable read）</h5><p>在一个事务内多次读同一数据。在一个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。</p><p>例如：事务 1 读取某表中的数据 A=20，事务 2 也读取 A=20，事务 1 修改 A=A-1，事务 2 再次读取 A =19，此时读取的结果和第一次读取的结果不同。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230424112650372.png" alt="image-20230424112650372"></p><center>不可重复读（Unrepeatable read）</center><h5 id="幻读phantom-read"><a class="anchor" href="#幻读phantom-read">#</a> 幻读（Phantom read）</h5><p>一个事务读取了几行数据，接着另一个并发事务<font color="red">插入</font>了一些数据时。第一个事务在随后的查询中就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</p><p>例如：事务 2 读取某个范围的数据，事务 1 在这个范围插入了新的数据，事务 2 再次读取这个范围的数据发现相比于第一次读取的结果多了新的数据。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230424112700267.png" alt="image-20230424112700267"></p><center>幻读（Phantom read）</center><h4 id="不可重复读和幻读的区别"><a class="anchor" href="#不可重复读和幻读的区别">#</a> 不可重复读和幻读的区别</h4><ul><li><font color="red">不可重复读的重点是<u>字段值修改</u>或<u>记录减少</u></font>。比如多次读取一条记录，发现其中某些字段的值被修改了。</li><li><font color="red">幻读的重点在于<u>记录新增</u></font>。比如多次执行同一条查询语句（DQL）时，发现查到的记录增加了。</li></ul><p>幻读其实可以看作是不可重复读的一种特殊情况，区分二者的原因是二者的解决方案不一样。</p><p>举个例子：执行 <code>delete</code> 和 <code>update</code> 操作的时候，可以直接对记录加锁，保证事务安全。而执行 <code>insert</code> 操作的时候，由于记录锁（Record Lock）只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁（Gap Lock）。也就是说执行 <code>insert</code> 操作的时候需要依赖 Next-Key Lock（Record Lock+Gap Lock） 进行加锁来保证不出现幻读。</p><h4 id="并发事务的控制方式隔离性"><a class="anchor" href="#并发事务的控制方式隔离性">#</a> 并发事务的控制方式（隔离性）</h4><p>MySQL 中并发事务的控制方式无非就两种：<strong>锁</strong> 和 <strong>多版本并发控制（MVCC）</strong>。</p><p>锁可以看作是悲观控制的模式，多版本并发控制（MVCC，Multiversion concurrency control）可以看作是乐观控制的模式。</p><h5 id="锁"><a class="anchor" href="#锁">#</a> 锁</h5><p>通过锁来显示地控制共享资源，而不是通过调度手段。MySQL 中主要是通过<strong>读写锁</strong>来实现并发控制。</p><ul><li><strong>共享锁（S 锁）</strong>：又称<font color="red">读锁</font>。事务在读取记录的时候获取共享锁，允许多个事务同时获取（锁兼容）。</li><li><strong>排他锁（X 锁）</strong>：又称<font color="red">写锁 / 独占锁</font>。事务在修改记录的时候获取排他锁，不允许多个事务同时获取。如果一个记录已经被加了排他锁，那其他事务不能再对这条记录加任何类型的锁（锁不兼容）。</li></ul><p>读写锁可以做到读读并行，但是<font color="red">无法做到读写并行、写写并行</font>。</p><p>另外，根据根据锁粒度的不同，又被分为<strong>表级锁 (table-level locking)<strong> 和</strong>行级锁 (row-level locking)</strong>。<font color="red">InnoDB 不光支持表级锁，还支持行级锁</font>，默认为行级锁。行级锁的粒度更小，仅对相关的记录上锁即可（对一行或者多行记录加锁）。所以对于并发写入操作来说，InnoDB 的性能更高。</p><p><font color="red">不论是表级锁还是行级锁，都存在共享锁（Share Lock，S 锁）和排他锁（Exclusive Lock，X 锁）这两类</font>。</p><h5 id="多版本并发控制mvcc"><a class="anchor" href="#多版本并发控制mvcc">#</a> 多版本并发控制（MVCC）</h5><p><strong>MVCC</strong> 是多版本并发控制方法，即<font color="red">对一份数据会存储多个版本</font>，通过事务的可见性来保证事务能看到自己应该看到的版本。<font color="red">通常会有一个全局的版本分配器来为每一行数据设置版本号，版本号是唯一的</font>。</p><p>MVCC 在 MySQL 中实现所依赖的手段主要是：</p><ul><li><strong>undo log</strong>：记录某行数据的多个版本的数据。</li><li><strong>read view</strong> 和 <strong>隐藏字段</strong>：判断当前版本数据的可见性。</li></ul><p>关于 InnoDB 对 MVCC 的具体实现可以看这篇文章：<span class="exturl" data-url="aHR0cHM6Ly9qYXZhZ3VpZGUuY24vZGF0YWJhc2UvbXlzcWwvaW5ub2RiLWltcGxlbWVudGF0aW9uLW9mLW12Y2MuaHRtbA==">InnoDB 存储引擎对 MVCC 的实现</span> 。</p><h4 id="4种隔离级别"><a class="anchor" href="#4种隔离级别">#</a> <mark>🌟4 种隔离级别</mark></h4><p>SQL 标准为事务定义了四种隔离级别：</p><ul><li><p><strong>READ-UNCOMMITTED（读未提交）</strong>：最低的隔离级别，<font color="red">允许当前事务读取其他并发事务尚未提交的数据</font>，存在脏读、不可重复读、幻读问题。</p><blockquote><p>用户本来应该读取到 id=1 的用户 age 应该是 10，结果读取到了其他事务还没有提交的事务，结果读取 age=20，这就是脏读。</p></blockquote></li><li><p><strong>READ-COMMITTED（读已提交）</strong>：<font color="red">允许当前事务读取其他并发事务已经提交的数据</font>。可以避免脏读，但是存在不可重复读、幻读问题。</p><blockquote><p>用户开启事务读取 id=1 的用户，查询到 age=16，再次读取发现结果 age=20，在同一个事务里同一个查询读取到不同的结果，叫做不可重复读。</p></blockquote></li><li><p><strong>REPEATABLE-READ（可重复读）</strong>：MySQL 的默认隔离级别，<font color="red">当前事务对同一数据的多次读取结果都是一样的</font>（都是复用事务刚开始时的数据读取结果副本），除非数据被本身事务所修改。可以避免脏读和不可重复读，但幻读仍有可能发生。</p></li><li><p><strong>SERIALIZABLE（串行化 / 序列化）</strong>：最高的隔离级别，完全服从 ACID 的隔离级别。<font color="red">所有的事务依次串行执行</font>，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。</p></li></ul><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231118212951118.png" alt="image-20231118212951118"></p><table><thead><tr><th style="text-align:center">隔离级别</th><th style="text-align:center">脏读</th><th style="text-align:center">不可重复读</th><th style="text-align:center">幻读</th></tr></thead><tbody><tr><td style="text-align:center">READ-UNCOMMITTED</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">√</td></tr><tr><td style="text-align:center">READ-COMMITTED</td><td style="text-align:center">×</td><td style="text-align:center">√</td><td style="text-align:center">√</td></tr><tr><td style="text-align:center">REPEATABLE-READ</td><td style="text-align:center">×</td><td style="text-align:center">×</td><td style="text-align:center">√/×（InnoDB）</td></tr><tr><td style="text-align:center">SERIALIZABLE</td><td style="text-align:center">×</td><td style="text-align:center">×</td><td style="text-align:center">×</td></tr></tbody></table><h4 id="mysql-的隔离级别是基于锁和-mvcc-机制共同实现的"><a class="anchor" href="#mysql-的隔离级别是基于锁和-mvcc-机制共同实现的">#</a> MySQL 的隔离级别是基于锁和 MVCC 机制共同实现的</h4><p>SERIALIZABLE 隔离级别是通过锁来实现的，READ-COMMITTED 和 REPEATABLE-READ 隔离级别是基于 MVCC 实现的。不过，SERIALIZABLE 之外的其他隔离级别可能也需要用到锁机制，就比如 REPEATABLE-READ 在当前读情况下需要使用加锁读来保证不会出现幻读。</p><h4 id="mysqlinnodb的默认隔离级别是-repeatable-read可重读"><a class="anchor" href="#mysqlinnodb的默认隔离级别是-repeatable-read可重读">#</a> MySQL（InnoDB）的默认隔离级别是 REPEATABLE-READ（可重读）</h4><p>MySQL（InnoDB）默认支持的隔离级别是 <strong>REPEATABLE-READ（可重读）</strong>。</p><p>可以通过 <code>SELECT @@tx_isolation;</code> 命令来查看，MySQL 8.0 该命令改为 <code>SELECT @@transaction_isolation;</code></p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre>mysql<span class="token operator">></span> <span class="token keyword">SELECT</span> @<span class="token variable">@tx_isolation</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token operator">+</span><span class="token comment">-----------------+</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token operator">|</span> @<span class="token variable">@tx_isolation</span>  <span class="token operator">|</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token operator">+</span><span class="token comment">-----------------+</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token operator">|</span> <span class="token keyword">REPEATABLE</span><span class="token operator">-</span><span class="token keyword">READ</span> <span class="token operator">|</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token operator">+</span><span class="token comment">-----------------+</span></pre></td></tr></table></figure><p>关于 MySQL 事务隔离级别的详细介绍，可以看看我写的这篇文章：<span class="exturl" data-url="aHR0cHM6Ly9qYXZhZ3VpZGUuY24vZGF0YWJhc2UvbXlzcWwvdHJhbnNhY3Rpb24taXNvbGF0aW9uLWxldmVsLmh0bWw=">MySQL 事务隔离级别详解</span>。</p><h4 id="mysql-事务隔离级别与一致性问题的演示"><a class="anchor" href="#mysql-事务隔离级别与一致性问题的演示">#</a> MySQL 事务隔离级别与一致性问题的演示</h4><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/2019-31-1%25E8%2584%258F%25E8%25AF%25BB(%25E8%25AF%25BB%25E6%259C%25AA%25E6%258F%2590%25E4%25BA%25A4)%25E5%25AE%259E%25E4%25BE%258B.jpg" alt="img"></p><center>脏读（读未提交）</center><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/2019-31-2%25E8%25AF%25BB%25E5%25B7%25B2%25E6%258F%2590%25E4%25BA%25A4%25E5%25AE%259E%25E4%25BE%258B.jpg" alt="img"></p><center>避免脏读（读已提交）</center><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/2019-32-1%25E4%25B8%258D%25E5%258F%25AF%25E9%2587%258D%25E5%25A4%258D%25E8%25AF%25BB%25E5%25AE%259E%25E4%25BE%258B.jpg" alt="img"></p><center>不可重复读（读已提交）</center><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/2019-33-2%25E5%258F%25AF%25E9%2587%258D%25E5%25A4%258D%25E8%25AF%25BB.jpg" alt="img"></p><center>可重复读</center><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/phantom_read.png" alt="img"></p><center>幻读</center><p>SQL 脚本 1 在第一次查询工资为 500 的记录时只有一条，SQL 脚本 2 插入了一条工资为 500 的记录，提交之后；SQL 脚本 1 在同一个事务中再次使用当前读查询发现出现了两条工资为 500 的记录这种就是幻读。</p><p><font color="red">幻读的解决方法：核心思想就是一个事务在操作某张表数据的时候，另外一个事务不允许新增或者删除这张表中的数据了</font>。解决幻读的方式主要有以下几种：</p><ol><li>将事务隔离级别调整为 <code>SERIALIZABLE</code> 。</li><li>在可重复读的事务级别下，给事务操作的这张表添加<font color="red">表锁</font>。</li><li>在可重复读的事务级别下，给事务操作的这张表添加 <code>Next-key Lock（Record Lock+Gap Lock）</code> 。</li></ol><h3 id="mysql锁"><a class="anchor" href="#mysql锁">#</a> <mark>🌟MySQL 锁</mark></h3><h4 id="概述-2"><a class="anchor" href="#概述-2">#</a> 概述</h4><p>在数据库中，数据是一种供许多用户共享的资源，必须保证数据并发访问的一致性、有效性。</p><p>MySQL 中的锁，按照锁的粒度分，分为以下三类：</p><ul><li><p><font color="cornflowerblue">全局锁</font>：锁定<font color="red">整个数据库</font>。</p></li><li><p><font color="cornflowerblue">表级锁</font>：每次操作锁住<font color="red">整张表</font>。</p><ul><li>表锁：</li><li>元数据锁（meta data lock，MDL）：加锁过程是系统自动控制的</li><li>意向锁：不与行级锁冲突，由 InnoDB 自动添加，无需用户干预。<ul><li>意向共享锁（IS）</li><li>意向排他锁（IX）</li></ul></li></ul></li><li><p><font color="cornflowerblue">行级锁</font>：每次操作锁住对应的<font color="red">行数据</font>，其<font color="red">实现依赖于索引</font>，而不是记录。</p><ul><li>行锁 / 记录锁（Record Lock）：存在于包括主键索引在内的唯一索引中，锁定<font color="red">单条索引记录</font></li><li>间隙锁（Gap Lock）：存在于非唯一索引中，锁定<font color="red">开区间</font>范围内的一段间隔</li><li>临键锁（Next-Key Lock）：存在于非唯一索引中，锁定<font color="red">左开右闭</font>的索引区间</li></ul></li></ul><h4 id="全局锁"><a class="anchor" href="#全局锁">#</a> 全局锁</h4><h5 id="介绍-2"><a class="anchor" href="#介绍-2">#</a> 介绍</h5><p>全局锁就是<font color="red">对整个数据库实例加锁，加锁后整个实例就处于只读状态，后续的 DML 的写语句，DDL 语句，已经更新操作的事务提交语句都将被阻塞</font>。</p><p>典型的使用场景是做<font color="red">全库的逻辑备份</font>，对所有的表进行锁定，从而获取一致性视图，保证数据的完整性。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231119154827391.png" alt="image-20231119154827391"></p><center>不加MySQL全局锁会导致备份数据的不一致</center><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231119154907407.png" alt="image-20231119154907407"></p><center>加了MySQL全局锁后只能执行DQL语句，数据库处于只读状态，保证了数据的一致性和完整性</center><h5 id="语法"><a class="anchor" href="#语法">#</a> 语法</h5><ol><li><p>添加全局锁：</p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre>flush <span class="token keyword">tables</span> <span class="token keyword">with</span> <span class="token keyword">read</span> <span class="token keyword">lock</span> <span class="token punctuation">;</span></pre></td></tr></table></figure></li><li><p>数据备份（退出 mysql，在 Windows 的 cmd 窗口中执行）：</p><figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre>mysqldump <span class="token parameter variable">-uroot</span> –p1234 itcast <span class="token operator">></span> itcast.sql <span class="token punctuation">;</span></pre></td></tr></table></figure></li><li><p>释放锁：</p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">unlock</span> <span class="token keyword">tables</span> <span class="token punctuation">;</span></pre></td></tr></table></figure></li></ol><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231119155453030.png" alt="image-20231119155453030"></p><h5 id="特点"><a class="anchor" href="#特点">#</a> 特点</h5><p>数据库中加全局锁，是一个比较重的操作，存在以下问题：</p><ul><li>如果在<font color="gree">主库</font>上备份，那么<font color="red">在备份期间都不能执行更新，业务基本上就得停摆</font>。</li><li>如果在<font color="gree">从库</font>上备份，那么<font color="red">在备份期间从库不能执行主库同步过来的二进制日志（binlog），会导致主从延迟</font>。</li></ul><p>为了解决上述问题，在 InnoDB 引擎中可以在备份时加上参数 <code>--single-transaction</code> 参数来完成 **<font color="#B32015">不加锁的一致性数据备份</font>**。</p><blockquote><p><strong>快照读</strong></p></blockquote><figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre>mysqldump --single-transaction <span class="token parameter variable">-uroot</span> –p123456 itcast <span class="token operator">></span> itcast.sql</pre></td></tr></table></figure><h4 id="表级锁"><a class="anchor" href="#表级锁">#</a> 表级锁</h4><h5 id="介绍-3"><a class="anchor" href="#介绍-3">#</a> 介绍</h5><p>表级锁，即锁住整张表，MyISAM、InnoDB、BDB 等存储引擎都支持，主要分为以下三类：</p><blockquote><p><strong>每类表级锁，都分为<font color="cyan">共享锁（S 锁 / 读锁）</font>和<font color="cyan">排他锁（X 锁 / 写锁）</font></strong></p></blockquote><ul><li><font color="cornflowerblue">表锁</font></li><li><font color="cornflowerblue">元数据锁</font>（meta data lock，MDL）</li><li><font color="cornflowerblue">意向锁</font></li></ul><h5 id="表锁"><a class="anchor" href="#表锁">#</a> 表锁</h5><p>对于表锁，分为两类：</p><blockquote><p>结论:</p><ul><li>读锁不会阻塞其他客户端的读，但是会阻塞写。</li><li>写锁既会阻塞其他客户端的读，又会阻塞其他客户端的写。</li></ul></blockquote><ul><li><p><font color="cyan">表锁共享锁（Shared）</font>：又称<font color="red">读锁</font></p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231119161818290.png" alt="image-20231119161818290"></p><center>左侧为客户端一，对指定表加了读锁，只能读不能写。<font color="red">不会影响右侧客户端二的读，但是会阻塞右侧客户端的写</font>。</center><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231119161947749.png" alt="image-20231119161947749"></p></li><li><p><font color="cyan">表锁排他锁（eXclusive）</font>：又称<font color="red">写锁</font></p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231119162023867.png" alt="image-20231119162023867"></p><center>左侧为客户端一，对指定表加了写锁，可以读和写。<font color="red">但是会阻塞右侧客户端的读和写</font>。</center><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231119162246255.png" alt="image-20231119162246255"></p></li></ul><p>语法：</p><ul><li><p>加锁：</p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">lock</span> <span class="token keyword">tables</span> 表名<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">read</span><span class="token operator">/</span><span class="token keyword">write</span></pre></td></tr></table></figure></li><li><p>释放锁：客户端断开连接，或者</p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">unlock</span> <span class="token keyword">tables</span></pre></td></tr></table></figure></li></ul><h5 id="元数据锁"><a class="anchor" href="#元数据锁">#</a> 元数据锁</h5><blockquote><p>全称为 meta data lock，简写 MDL，这里的元数据，大家可以简单理解为就是一张表的表结构。</p></blockquote><p><strong><font color="red">MDL 加锁过程是系统自动控制的</font></strong>，无需显式使用，在访问一张表的时候会自动加上。</p><p>MDL 锁<font color="red">主要作用是维护表元数据的数据一致性，在表上有活动事务的时候，不可以对元数据进行写入操作</font>。<strong><font color="#B32015">为了避免 DML 与 DDL 冲突，保证读写的正确性</font></strong>。也就是说，某一张表涉及到未提交的事务时，是不能够修改这张表的表结构的。</p><p>在 MySQL5.5 中引入了 MDL，</p><ul><li><font color="red">当对一张表的数据进行增删改查（DML、DQL）的时候，加<font color="cyan"> MDL 共享锁</font></font></li><li><font color="red">当对表结构进行变更操作（DDL）的时候，加<font color="cyan"> MDL 排他锁</font></font></li></ul><p>举个例子，对于常见的 SQL 操作，所添加的 MDL 锁：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231119172457594.png" alt="image-20231119172457594"></p><h5 id="意向锁"><a class="anchor" href="#意向锁">#</a> 意向锁</h5><h6 id="介绍-4"><a class="anchor" href="#介绍-4">#</a> 介绍</h6><p>为了避免 DML 在执行时，加的行锁与表锁的冲突，在 InnoDB 中引入了意向锁，<font color="red">使得表锁不用检查每行数据是否加锁</font>，减少表锁的检查。</p><p>意向锁的工作机制如下：</p><ol><li>客户端在<font color="red">执行 DML 时，会对涉及的记录加行锁，同时对该表加上<u>意向锁</u></font></li><li>其他客户端在尝试对该表加表锁时，<font color="red">会根据该表上所加的<u>意向锁</u>来判定是否可以成功加表锁，而不用逐行判断行锁情况了</font>。</li></ol><h6 id="分类"><a class="anchor" href="#分类">#</a> 分类</h6><blockquote><p><font color="red">意向锁之间不会互斥。并且一旦事务提交了，意向锁就自动释放了</font>。</p></blockquote><ul><li><p><font color="cyan">意向共享锁 (IS)</font>: 由语句 <code>select ... lock in share mode</code> 添加。</p><blockquote><p>与表锁共享锁 (read) 兼容，与表锁排他锁 (write) 互斥。</p></blockquote></li><li><p><font color="cyan">意向排他锁 (IX)</font>: 由 <code>insert</code> 、 <code>update</code> 、 <code>delete</code> 、 <code>select...for update</code> 添加。</p><blockquote><p>与表锁共享锁 (read) 及表锁排他锁 (write) 都互斥。</p></blockquote></li></ul><h6 id="演示"><a class="anchor" href="#演示">#</a> 演示</h6><p>可以通过以下 SQL，查看意向锁及行锁的加锁情况：</p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">select</span> object_schema<span class="token punctuation">,</span>object_name<span class="token punctuation">,</span>index_name<span class="token punctuation">,</span>lock_type<span class="token punctuation">,</span>lock_mode<span class="token punctuation">,</span>lock_data <span class="token keyword">from</span></pre></td></tr><tr><td data-num="2"></td><td><pre>performance_schema<span class="token punctuation">.</span>data_locks<span class="token punctuation">;</span></pre></td></tr></table></figure><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231119185250184.png" alt="image-20231119185250184"></p><center>意向共享锁与表锁共享锁(read)是兼容的</center><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231119185354166.png" alt="image-20231119185354166"></p><center>意向排他锁与表锁共享锁(read)、表锁排他锁(write)都是互斥的</center><h4 id="行级锁"><a class="anchor" href="#行级锁">#</a> 行级锁</h4><h5 id="介绍-5"><a class="anchor" href="#介绍-5">#</a> 介绍</h5><p>行级锁，每次操作<font color="red">锁住对应的行数据</font>。锁定粒度最小，<font color="red">发生锁冲突的概率最低，并发度最高</font>。</p><p><strong><font color="#B32015">只有 InnoDB 存储引擎支持行级锁</font></strong>。InnoDB 的数据是基于索引组织的，<strong><font color="red">行锁是通过对索引上的索引项加锁来实现的，而不是对记录加的锁</font></strong>。</p><p>对于行级锁，主要分为以下三类：</p><ul><li><p><font color="cornflowerblue">行锁（Record Lock）</font>：也称记录锁，<font color="red">锁定单个行记录</font>，防止其他事务对此行进行 <code>update</code> 和 <code>delete</code> 。</p><blockquote><p>在 RC、RR 隔离级别下都支持。</p><p><strong>与表级锁类似，行锁也分为<font color="cyan">共享锁（S 锁 / 读锁）</font>和<font color="cyan">排他锁（X 锁 / 写锁）</font></strong></p></blockquote><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231119190445520.png" alt="image-20231119190445520"></p><ul><li><p><font color="cyan">行锁共享锁（S）</font>：允许一个事务去读一行，阻止其他事务获得相同数据集的排它锁。</p></li><li><p><font color="cyan">行锁排他锁（X）</font>：允许获取排他锁的事务更新数据，阻止其他事务获得相同数据集的共享锁和排他锁。</p><blockquote><p>两种行锁的兼容情况如下：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231119192050128.png" alt="image-20231119192050128"></p><p>对于常见的 SQL 语句，在执行时，所加的行锁如下：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231119192231878.png" alt="image-20231119192231878"></p></blockquote></li></ul></li><li><p><font color="cornflowerblue">间隙锁（Gap Lock）</font>：<font color="red">锁定索引记录的间隙（不含记录）</font>，确保索引记录间隙不变，<strong><font color="#B32015">防止其他事务在这个间隙进行 <code>insert</code> ，产生幻读</font></strong>。</p><blockquote><p>在 RR 隔离级别下支持。</p></blockquote><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231119191003502.png" alt="image-20231119191003502"></p></li><li><p><font color="cornflowerblue">临键锁（Next-Key Lock）</font>：<font color="red">行锁和间隙锁组合，锁住记录的同时也锁住数据前面的所有间隙</font>。</p><blockquote><p>在 RR 隔离级别下支持。还记得在 MySQL 事务的隔离级别中提到的下表吗？当时之所以说<strong> InnoDB 引擎中的 RR 隔离级别可以避免幻读现象</strong>，就是因为 InnoDB 引擎支持行级锁中的临键锁（next-key）！</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231119190721496.png" alt="image-20231119190721496"></p></blockquote><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231119191537038.png" alt="image-20231119191537038"></p></li></ul><h5 id="行锁演示"><a class="anchor" href="#行锁演示">#</a> 行锁演示</h5><ul><li>针对唯一索引进行检索时，对已存在的记录进行等值匹配时，将会自动将临键锁（next-key）<font color="red">优化为行锁</font>。</li><li>InnoDB 的行锁是针对于索引加的锁，不通过索引条件检索数据，那么 InnoDB 将对表中的所有记录加锁，此时就会<font color="red">升级为表锁</font>。</li></ul><hr><p>可以通过以下 SQL，查看意向锁及行锁的加锁情况：</p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">select</span> object_schema<span class="token punctuation">,</span>object_name<span class="token punctuation">,</span>index_name<span class="token punctuation">,</span>lock_type<span class="token punctuation">,</span>lock_mode<span class="token punctuation">,</span>lock_data <span class="token keyword">from</span></pre></td></tr><tr><td data-num="2"></td><td><pre>performance_schema<span class="token punctuation">.</span>data_locks<span class="token punctuation">;</span></pre></td></tr></table></figure><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231119193115917.png" alt="image-20231119193115917"></p><center>普通的select语句，执行时，不会加锁。</center><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231119193133442.png" alt="image-20231119193133442"></p><center>select...lock in share mode，加共享锁，共享锁与共享锁之间兼容。</center><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231119193207569.png" alt="image-20231119193207569"></p><center>共享锁与排他锁之间互斥。</center><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231119193242470.png" alt="image-20231119193242470"></p><center>排他锁之间互斥</center><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231119193535207.png" alt="image-20231119193535207"></p><center>根据name字段进行更新时，由于name字段是没有索引的，此时行锁会升级为表锁（因为行锁是对索引项加的锁）</center><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231119193708274.png" alt="image-20231119193708274"></p><center><font color="red">对name字段创建索引，再对其进行更新，可以避免行锁升级为表锁</font></center><h5 id="间隙锁临键锁演示"><a class="anchor" href="#间隙锁临键锁演示">#</a> 间隙锁 &amp; 临键锁演示</h5><p>默认情况下，InnoDB 的事务隔离级别为 <font color="red">REPEATABLE-READ（可重复读）</font>，InnoDB 使用 <font color="cornflowerblue">临键锁（next-key）</font>进行搜索和索引扫描，以防出现幻读。</p><ul><li><p>索引上的等值查询（唯一索引），给不存在的记录加锁时，优化为间隙锁</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231119195154766.png" alt="image-20231119195154766"></p></li><li><p>索引上的等值查询（非唯一的普通索引），向右遍历时最后一个值不满足查询需求时，临键锁（next-key）退化为间隙锁</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231119195335874.png" alt="image-20231119195335874"></p></li><li><p>索引上的范围查询 (唯一索引)-- 会访问到不满足条件的第一个值为止</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231119195724781.png" alt="image-20231119195724781"></p></li></ul><blockquote><p><strong>间隙锁唯一目的是防止其他事务插入间隙</strong>。</p><p><strong>间隙锁可以共存</strong>，一个事务采用的间隙锁不会阻止另一个事务在同一间隙上采用间隙锁。</p></blockquote><h4 id="总结-3"><a class="anchor" href="#总结-3">#</a> 总结</h4><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231119200231781.png" alt="image-20231119200231781" style="zoom:67%"><h4 id="面试题-2"><a class="anchor" href="#面试题-2">#</a> 面试题</h4><p>锁是一种常见的并发事务的控制方式。</p><h5 id="表级锁和行级锁了解吗有什么区别"><a class="anchor" href="#表级锁和行级锁了解吗有什么区别">#</a> 表级锁和行级锁了解吗？有什么区别？</h5><p><font color="red">MyISAM 仅仅支持表级锁</font>，在并发写的情况下性能非常差。<strong><font color="red">InnoDB 不仅支持表级锁，还支持行级锁</font></strong>，默认为行级锁。</p><p>行级锁的粒度更小，仅对相关的记录上锁即可（一行或者多行记录），所以对于并发写操作来说，InnoDB 的性能更高。</p><ul><li><p><strong>表级锁：</strong></p><ul><li>是 **<font color="red">针对非索引字段</font>** 加的锁，对当前操作的整张表加锁</li><li>优点：<font color="red">加锁快，资源消耗也比较少，不会出现死锁</font>。</li><li>缺点：<font color="red">触发锁冲突的概率最高，高并发下效率极低</font>。</li><li><font color="red">MyISAM 和 InnoDB 引擎都支持表级锁</font>。</li></ul></li><li><p><strong>行级锁：</strong></p><ul><li>MySQL 中锁定粒度最小的一种锁，是 **<font color="#B32015">针对索引字段</font>** 加的锁，只针对当前操作的行记录进行加锁。</li><li>优点：<font color="red">能大大减少数据库操作的锁冲突</font>。其加锁粒度最小，<font color="red">并发度高</font>。</li><li>缺点：<font color="red">加锁慢，加锁的开销大，会出现死锁</font>。</li><li><font color="red">行级锁和存储引擎有关，仅有 InnoDB 引擎支持行级锁</font>。</li></ul></li></ul><h5 id="行级锁的使用有什么注意事项"><a class="anchor" href="#行级锁的使用有什么注意事项">#</a> 行级锁的使用有什么注意事项？</h5><p>InnoDB 的行锁是针对索引字段加的锁，表级锁是针对非索引字段加的锁。</p><p><strong><font color="#B32015">行级锁退化成表级锁</font></strong>：<font color="red">当我们执行 <code>UPDATE</code> 、 <code>DELETE</code> 语句时，如果 <code>WHERE</code> 条件中字段没有命中唯一索引或者索引失效的话，就会导致扫描全表对表中的所有行记录进行加锁</font>。这个在我们日常工作开发中经常会遇到，一定要多多注意！！！</p><p>不过，很多时候<font color="red">即使用了索引也有可能会走全表扫描，这是因为 MySQL 优化器的原因，它认为全表扫描的效率比使用索引更高</font>。</p><h5 id="innodb-有哪几类行级锁"><a class="anchor" href="#innodb-有哪几类行级锁">#</a> InnoDB 有哪几类行级锁？</h5><p>InnoDB 行级锁是通过对索引数据页上的<font color="red">索引项</font>加锁实现的，MySQL InnoDB 支持三种行锁定方式：</p><ul><li><strong><font color="#B32015">记录锁（Record Lock）</font></strong>：也被称为行锁，锁的是已经存在的单个行记录。</li><li><strong><font color="#B32015">间隙锁（Gap Lock）</font></strong>：锁定一个范围，不包括记录本身。<font color="red">为了避免插入新记录</font>，需要依赖间隙锁。</li><li><strong><font color="#B32015">临键锁（Next-Key Lock）</font></strong>：可以理解为<font color="red">行锁 + 间隙锁</font> 的组合，锁定一个行记录，及其之前的所有间隙范围。主要目的是 **<font color="red">为了解决幻读问题</font>**（MySQL 事务部分提到过）。</li></ul><p><strong>在 InnoDB 默认的隔离级别 REPEATABLE-READ（可重复读）下，行级锁默认使用的是<u>临键锁（Next-Key）</u>。</strong></p><blockquote><p>但是，如果操作的索引是唯一索引或主键，InnoDB 会将临键锁（Next-Key）降级为<u>记录锁（Record Lock）</u>，即仅锁住索引本身，而不是范围。</p></blockquote><h5 id="共享锁和排他锁呢"><a class="anchor" href="#共享锁和排他锁呢">#</a> 共享锁和排他锁呢？</h5><p><font color="red">不论是表级锁还是行级锁</font>，都存在共享锁（Share Lock，S 锁）和排他锁（eXclusive Lock，X 锁）这两类：</p><ul><li><strong>共享锁（S 锁）</strong>：又称<font color="red">读锁</font>，事务在读取记录的时候获取共享锁，允许多个事务同时获取（锁兼容）。</li><li><strong>排他锁（X 锁）</strong>：又称<font color="red">写锁 / 独占锁</font>，事务在修改记录的时候获取排他锁，不允许多个事务同时获取。如果一个记录已经被加了排他锁，那其他事务不能再对这条事务加任何类型的锁（锁不兼容）。</li></ul><p><font color="red">排他锁与任何的锁都不兼容，共享锁仅和共享锁兼容</font>。</p><table><thead><tr><th style="text-align:left"></th><th style="text-align:left">S 锁</th><th style="text-align:left">X 锁</th></tr></thead><tbody><tr><td style="text-align:left">S 锁</td><td style="text-align:left"><font color="red">不冲突</font></td><td style="text-align:left">冲突</td></tr><tr><td style="text-align:left">X 锁</td><td style="text-align:left">冲突</td><td style="text-align:left">冲突</td></tr></tbody></table><p><font color="red">由于 MVCC（多版本并发控制）的存在，对于一般的 <code>SELECT</code> 语句，InnoDB 不会加任何锁</font>。不过，可以通过以下语句<font color="red">显式地加共享锁或排他锁</font>：</p><ul><li>共享锁（MySQL 5.7 和 MySQL 8.0）： <code>SELECT ... LOCK IN SHARE MODE;</code></li><li>共享锁（MySQL 8.0）： <code>SELECT ... FOR SHARE;</code></li><li>排他锁： <code>SELECT ... FOR UPDATE;</code></li></ul><h5 id="意向锁有什么作用"><a class="anchor" href="#意向锁有什么作用">#</a> 意向锁有什么作用？</h5><p>意向锁是一种表级锁，<strong><font color="red">作用是快速判断是否可以对某个表使用表锁，而不用逐行检查是否有行级锁</font></strong>。</p><blockquote><p><font color="red">意向锁之间不会互斥。并且一旦事务提交了，意向锁就自动释放了</font>。</p></blockquote><ul><li><p><font color="cyan">意向共享锁 (IS 锁)</font>: 事务有意向对表中的某些记录加共享锁（S 锁），加共享锁前必须先取得该表的 IS 锁。由语句 <code>select ... lock in share mode</code> 添加。</p><blockquote><p>与表锁共享锁 (read) 兼容，与表锁排他锁 (write) 互斥。</p></blockquote></li><li><p><font color="cyan">意向排他锁 (IX 锁)</font>: 事务有意向对表中的某些记录加排他锁（X 锁），加排他锁之前必须先取得该表的 IX 锁。由 <code>insert</code> 、 <code>update</code> 、 <code>delete</code> 、 <code>select...for update</code> 添加。</p><blockquote><p>与表锁共享锁 (read) 及表锁排他锁 (write) 都互斥。</p></blockquote></li></ul><p><strong>意向锁是由存储引擎自己维护的，用户无法手动操作意向锁。<font color="red">在为数据行加共享锁 / 排他锁之前，InooDB 会先获取该数据行所在数据表的对应意向锁</font>。</strong></p><p><font color="red">意向锁之间是互相兼容的</font>。</p><table><thead><tr><th></th><th>IS 锁</th><th>IX 锁</th></tr></thead><tbody><tr><td>IS 锁</td><td>兼容</td><td>兼容</td></tr><tr><td>IX 锁</td><td>兼容</td><td>兼容</td></tr></tbody></table><p><font color="red">意向锁与表级别的共享锁和排它锁的互斥情况如下：</font></p><blockquote><p>意向锁不会与行级别的共享锁和排他锁互斥</p></blockquote><table><thead><tr><th></th><th>IS 锁</th><th>IX 锁</th></tr></thead><tbody><tr><td>S 锁</td><td><font color="red">兼容</font></td><td>互斥</td></tr><tr><td>X 锁</td><td>互斥</td><td>互斥</td></tr></tbody></table><h5 id="快照读和当前读有什么区别"><a class="anchor" href="#快照读和当前读有什么区别">#</a> 快照读和当前读有什么区别？</h5><p><strong><font color="#B32015">快照读</font></strong>（<font color="red">一致性<u>非锁定读</u></font>）就是<font color="red">简单的 <code>SELECT</code> 语句</font>。</p><p><font color="red">快照即记录的历史版本</font>，每行记录可能存在多个历史版本（多版本技术）。</p><p>快照读的情况下，如果读取的记录正在执行 UPDATE/DELETE 操作，<font color="red">读取操作不会因此去等待记录上 X 锁的释放，而是会去读取行的一个快照</font>。</p><p>只有在事务隔离级别 RC (读取已提交) 和 RR（可重读）下，InnoDB 才会使用快照读（一致性非锁定读）：</p><ul><li><font color="gree">在 RC 级别下</font>，对于快照数据，一致性非锁定读总是<font color="red">读取被锁定行的最新一份快照数据</font>。</li><li><font color="gree">在 RR 级别下</font>，对于快照数据，一致性非锁定读总是 **<font color="red">读取本事务开始时的行数据版本</font>**。</li></ul><p>快照读比较<font color="red">适合对数据一致性要求不是特别高，且追求极致性能的业务场景</font>。</p><hr><p><strong><font color="#B32015">当前读</font></strong>（<font color="red">一致性<u>锁定读</u></font>）就是<font color="red">给行记录加 X 锁或 S 锁</font>。</p><p>当前读的一些常见 SQL 语句类型如下：</p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment"># 对读的记录加一个 X 锁</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">SELECT</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">FOR</span> <span class="token keyword">UPDATE</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment"># 对读的记录加一个 S 锁（MySQL 5.7 和 MySQL 8.0）</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">SELECT</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">LOCK</span> <span class="token operator">IN</span> <span class="token keyword">SHARE</span> <span class="token keyword">MODE</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token comment"># 对读的记录加一个 S 锁（MySQL 8.0）</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">SELECT</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">FOR</span> <span class="token keyword">SHARE</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token comment"># 对修改的记录加一个 X 锁</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token keyword">INSERT</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">UPDATE</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token keyword">DELETE</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr></table></figure><h3 id="mysql性能优化"><a class="anchor" href="#mysql性能优化">#</a> MySQL 性能优化</h3><h4 id="能用-mysql-直接存储文件比如图片吗"><a class="anchor" href="#能用-mysql-直接存储文件比如图片吗">#</a> 能用 MySQL 直接存储文件（比如图片）吗？</h4><p>虽然可以直接将文件对应的二进制数据存储到 MySQL 中，不过还是建议不要在数据库中存储文件。因为会<font color="red">严重影响数据库性能，消耗过多存储空间</font>。</p><p>可以选择使用云服务厂商提供的开箱即用的 **<font color="#B32015">文件存储服务</font>**，成熟稳定，价格也比较低。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/oss-search.png" alt="img"></p><p>也可以选择<font color="red">自建文件存储服务</font>，实现起来也不难，基于 FastDFS、MinIO（推荐） 等开源项目就可以实现分布式文件服务。</p><p><strong><font color="#B32015">数据库只存储文件地址信息，文件本身由文件存储服务负责存储。</font></strong></p><p>相关阅读：<span class="exturl" data-url="aHR0cHM6Ly93d3cuNTFjdG8uY29tL2FydGljbGUvNzE2OTc4Lmh0bWw=">Spring Boot 整合 MinIO 实现分布式文件服务</span> 。</p><h4 id="mysql-如何存储-ip-地址"><a class="anchor" href="#mysql-如何存储-ip-地址">#</a> MySQL 如何存储 IP 地址？</h4><p>可以将 IP 地址 **<font color="red">转换成整形数据存储</font>**，性能更好，占用空间也更小。</p><p>MySQL 提供了两个（互逆的）方法来处理 ip 地址：</p><ul><li><code>INET_ATON()</code> ：把 ip 转为无符号整型（4-8 位）</li><li><code>INET_NTOA()</code> ：把整型的 ip 转为地址</li></ul><p>插入数据前，先用 <code>INET_ATON()</code> 把 ip 地址转为整型。显示数据时，使用 <code>INET_NTOA()</code> 把整型的 ip 地址转为地址显示即可。</p><h4 id="常见的-sql-优化手段"><a class="anchor" href="#常见的-sql-优化手段">#</a> 常见的 SQL 优化手段</h4><blockquote><p>指路→<a href="#==SQL%E4%BC%98%E5%8C%96==">SQL 优化</a></p></blockquote><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/javamianshizhibei-sql-optimization.png" alt="常见的 SQL 优化手段"></p><h4 id="如何分析-sql-的性能"><a class="anchor" href="#如何分析-sql-的性能">#</a> 如何分析 SQL 的性能？</h4><p>可以使用 <code>EXPLAIN</code> 命令来分析 SQL 的 <strong><font color="#B32015">执行计划</font></strong> 。执行计划是指一条 SQL 语句在经过 MySQL 查询优化器的优化后的具体的执行方式。</p><p><code>EXPLAIN</code> 并不会真的去执行相关的语句，而是通过 <strong><font color="#B32015">查询优化器</font></strong> 对语句进行分析，找出最优的查询方案，并显示对应的信息。</p><blockquote><p>指路→[利用 EXPLAIN 命令分析 SQL 是否走索引查询](# 利用 EXPLAIN 命令分析 SQL 是否走索引查询)</p></blockquote><h4 id="读写分离-分库分表"><a class="anchor" href="#读写分离-分库分表">#</a> <mark>🌟读写分离、分库分表</mark></h4><h5 id="读写分离"><a class="anchor" href="#读写分离">#</a> 读写分离</h5><blockquote><p>解决的问题：<font color="red">数据库读并发</font></p></blockquote><h6 id="什么是读写分离"><a class="anchor" href="#什么是读写分离">#</a> 什么是读写分离？</h6><p>见名思意，根据读写分离的名字，我们就可以知道：读写分离主要是为了 **<font color="#B32015">将对数据库的读写操作分散到不同的数据库节点上。</font>** 这样的话，就能够<font color="red">小幅提升写性能，大幅提升读性能</font>。</p><p>我简单画了一张图来帮助不太清楚读写分离的小伙伴理解。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/read-and-write-separation.png" alt="读写分离示意图"></p><center>读写分离示意图</center><p>一般情况下，我们都会选择 **<font color="#B32015">一主多从</font>**，也就是<font color="red">一台主数据库负责写，其他的从数据库负责读</font>。<font color="red">主库和从库之间会进行数据实时同步（<strong>主从复制</strong>），以保证从库中数据的准确性</font>。这样的架构实现起来比较简单，并且也符合系统的<font color="red">写少读多</font>的特点。</p><h6 id="如何实现读写分离"><a class="anchor" href="#如何实现读写分离">#</a> 如何实现读写分离？</h6><p>不论是使用哪一种读写分离具体的实现方案，想要实现读写分离一般包含如下几步：</p><ol><li>部署多台数据库，选择其中的一台作为主数据库，其他的一台或者多台作为从数据库。</li><li>保证主数据库和从数据库之间的数据是实时同步的（主从复制）。</li><li>系统将写请求交给主数据库处理，读请求交给从数据库处理。</li></ol><p>落实到项目本身的话，常用的方式有两种：</p><ol><li><p><strong><font color="cornflowerblue">代理方式</font></strong></p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/read-and-write-separation-proxy.png" alt="代理方式实现读写分离"></p><center>代理方式实现读写分离</center><p>我们可以在应用和数据中间加了一个 **<font color="red">代理层</font>**。</p><p>应用程序所有的数据请求都交给代理层处理，<font color="red">代理层负责分离读写请求，将它们路由到对应的数据库中</font>。</p><p>提供类似功能的中间件有 <strong>MySQL Router</strong>（官方）、<strong>Atlas</strong>（基于 MySQL Proxy）、<strong>MaxScale</strong>、<strong>MyCat</strong>。</p></li><li><p><strong><font color="cornflowerblue">第三方组件方式</font></strong></p><blockquote><p>推荐的方式</p></blockquote><p>在这种方式中，我们可以通过引入第三方组件来帮助我们读写请求。</p><p>这也是我比较<font color="red">推荐的一种方式</font>。这种方式目前在各种互联网公司中用的最多的，相关的实际的案例也非常多。</p><p>如果你要采用这种方式的话，推荐使用 <code>sharding-jdbc</code> ，直接引入 jar 包即可使用，非常方便。同时，也节省了很多运维的成本。</p><blockquote><p>你可以在 shardingsphere 官方找到 <span class="exturl" data-url="aHR0cHM6Ly9zaGFyZGluZ3NwaGVyZS5hcGFjaGUub3JnL2RvY3VtZW50L2xlZ2FjeS8zLngvZG9jdW1lbnQvY24vbWFudWFsL3NoYXJkaW5nLWpkYmMvdXNhZ2UvcmVhZC13cml0ZS1zcGxpdHRpbmcv">sharding-jdbc 关于读写分离的操作</span>。</p></blockquote></li></ol><h6 id="主从复制的原理"><a class="anchor" href="#主从复制的原理">#</a> <mark>🌟主从复制的原理</mark></h6><p><font color="red">MySQL <code>binlog</code> （二进制日志文件）主要记录了 MySQL 数据库中数据的所有变化（数据库执行的所有 DDL 和 DML 语句）</font>。</p><p>binlog 主要有两个作用：</p><ol><li><strong><font color="#B32015">主从复制</font></strong></li><li><strong><font color="#B32015">数据恢复</font></strong></li></ol><p>因此，<strong><font color="red">可以根据主库的 MySQL binlog 日志就能够将主库的数据同步复制到从库中</font></strong>。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231129103209731.png" alt="image-20231129103209731"></p><center>MySQL主从复制</center><ol><li><p>master 将数据库中数据的变化写入到 <code>binlog</code> 中</p></li><li><p>slave 连接 master</p></li><li><p>slave 会创建一个 <code>I/O 线程</code> 向 master 请求更新的 binlog</p></li><li><p>master 会创建一个 <code>binlog dump 线程</code> 来发送 binlog，由 slave 中的 I/O 线程负责接收</p></li><li><p>slave 的 I/O 线程将接收的 binlog 写入到 <code>relay log</code> （中继日志）中</p></li><li><p>slave 的 <code>SQL 线程</code> 读取 relay log 同步数据本地（也就是再执行一遍 SQL ）</p></li></ol><blockquote><p>扩展：阿里开源的一个叫做 canal 的工具可以帮助我们同步 MySQL 数据到其他数据源（例如 Elasticsearch/MySQL）。其原理就是模拟 MySQL 主从复制的过程，解析 binlog 将数据同步到其他的数据源。</p><p>另外，像咱们常用的分布式缓存组件 Redis 也是通过主从复制实现的读写分离。</p></blockquote><p>小结一下：</p><p><strong><font color="#B32015">MySQL 主从复制依赖于 binlog。另外，常见的一些同步 MySQL 数据到其他数据源的工具（比如 canal）的底层一般也是依赖 binlog 。</font></strong></p><h6 id="如何避免主从同步延迟"><a class="anchor" href="#如何避免主从同步延迟">#</a> 如何避免主从同步延迟？</h6><p>读写分离对于提升数据库的并发非常有效，但也同时引来一个问题：主库和从库的数据存在延迟，比如你写完主库之后，主库的数据同步到从库是需要时间的，这个时间差就导致了主库和从库的数据不一致性问题。这也就是我们经常说的 **<font color="#B32015">主从同步延迟</font>** 。</p><p>如果我们的业务场景无法容忍主从同步延迟的话，应该<u>如何避免</u>呢？</p><p>这里提供两种方案：</p><p>（1）<strong><font color="cornflowerblue">强制将读请求路由到 master 处理</font></strong></p><blockquote><p>使用最多的一种方式</p></blockquote><p>既然 slave 的数据过期了，那就直接从 master 读取呗！这种方案虽然会增加 master 的压力，但是实现起来比较简单，也是我了解到的 **<font color="red">使用最多的一种方式</font>**。</p><p>比如 <code>Sharding-JDBC</code> 就是采用的这种方案。通过使用 Sharding-JDBC 的 <code>HintManager</code> 分片键值管理器，我们可以强制使用 master。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">HintManager</span> hintManager <span class="token operator">=</span> <span class="token class-name">HintManager</span><span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>hintManager<span class="token punctuation">.</span><span class="token function">setMasterRouteOnly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">// 继续 JDBC 操作</span></pre></td></tr></table></figure><p>对于这种方案，<font color="red">可以将那些必须获取最新数据的读请求都交给 master 处理</font>。</p><p>（2）<font color="cornflowerblue">延迟读取</font></p><blockquote><p>没办法完全避免主从延迟，只能说可以减少出现延迟的概率而已，实际项目中一般不会使用</p></blockquote><p>还有一些朋友肯定会想既然主从同步存在延迟，那我就在延迟之后读取啊，比如主从同步延迟 0.5s, 那我就 1s 之后再读取数据。这样多方便啊！<strong><font color="red">方便是方便，但是也很扯淡</font></strong>。</p><p>不过，如果你是这样设计业务流程就会好很多：对于一些对数据比较敏感的场景，<font color="red">可以在完成写请求之后，避免立即进行请求操作</font>。比如你支付成功之后，跳转到一个支付成功的页面，当你点击返回之后才返回自己的账户。</p><h6 id="主从同步延迟的原因如何尽量减少延迟"><a class="anchor" href="#主从同步延迟的原因如何尽量减少延迟">#</a> 主从同步延迟的原因？如何尽量减少延迟？</h6><p>MySQL 主从同步延迟指的是<font color="red">从库的数据落后于主库的数据</font>。这种情况可能有以下<font color="gree">2 个原因</font>：</p><ol><li>从库 I/O 线程接收 binlog 的速度跟不上主库写入 binlog 的速度，导致从库 relay log 的数据滞后于主库 binlog 的数据；</li><li>从库 SQL 线程执行 relay log 的速度跟不上从库 I/O 线程接收 binlog 的速度，导致从库的数据滞后于从库 relay log 的数据。</li></ol><p>与主从同步有关的<font color="gree">3 个时间点</font>：</p><ol><li>主库执行完一个事务，写入 binlog，将这个时刻记为 T1；</li><li>从库 I/O 线程接收到 binlog 并写入 relay log 的时刻记为 T2；</li><li>从库 SQL 线程读取 relay log 同步数据本地的时刻记为 T3。</li></ol><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231129113009937.png" alt="image-20231129113009937"></p><p>结合我们上面讲到的主从复制原理，可以得出<font color="gree">2 个结论</font>：</p><ul><li>T2 和 T1 的差值反映了<font color="red">从库 I/O 线程的性能和网络传输的效率</font>，这个差值越小说明从库 I/O 线程的性能和网络传输效率越高。</li><li>T3 和 T2 的差值反映了<font color="red">从库 SQL 线程执行的速度</font>，这个差值越小，说明从库 SQL 线程执行速度越快。</li></ul><p>这里列举主从同步延迟的<font color="gree">几种常见情况</font>：</p><ol><li><strong>从库机器性能比主库差</strong>：从库接收 binlog 并写入 relay log 以及执行 SQL 语句的速度会比较慢（也就是 T2-T1 和 T3-T2 的值会较大），进而导致延迟。解决方法是<font color="red">选择与主库一样规格或更高规格的机器作为从库，或者对从库进行性能优化</font>，比如调整参数、增加缓存、使用 SSD 等。</li><li><strong>从库处理的读请求过多</strong>：从库需要执行主库的所有写操作，同时还要响应读请求，如果读请求过多，会占用从库的 CPU、内存、网络等资源，影响从库的复制效率（也就是 T2-T1 和 T3-T2 的值会较大，和前一种情况类似）。解决方法是<font color="red">引入缓存（推荐）、使用一主多从的架构，将读请求分散到不同的从库，或者使用其他系统来提供查询的能力</font>，比如将 binlog 接入到 Hadoop、Elasticsearch 等系统中。</li><li><strong>大事务</strong>：<font color="red">运行时间比较长，长时间未提交的事务</font>就可以称为大事务。由于大事务执行时间长，并且从库上的大事务会比主库上的大事务花费更多的时间和资源，因此非常容易造成主从延迟。解决办法是<font color="red">避免大批量修改数据，尽量分批进行</font>。类似的情况还有执行时间较长的慢 SQL，实际项目<font color="red">遇到慢 SQL 应该进行优化</font>。</li><li><strong>从库太多</strong>：主库需要将 binlog 同步到所有的从库，如果从库数量太多，会增加同步的时间和开销（也就是 T2-T1 的值会比较大，但这里是因为主库同步压力大导致的）。解决方案是<font color="red">减少从库的数量，或者将从库分为不同的层级，让上层的从库再同步给下层的从库，减少主库的压力</font>。</li><li><strong>网络延迟</strong>：如果主从之间的网络传输速度慢，或者出现丢包、抖动等问题，那么就会影响 binlog 的传输效率，导致从库延迟。解决方法是<font color="red">优化网络环境</font>，比如提升带宽、降低延迟、增加稳定性等。</li><li><strong>单线程复制</strong>：MySQL5.5 及之前，只支持单线程复制。为了优化复制性能，MySQL 5.6 引入了 <strong>多线程复制</strong>，MySQL 5.7 还进一步完善了多线程复制。</li><li><strong>复制模式</strong>：<font color="red">MySQL 默认的复制是异步的，必然会存在延迟问题</font>。全同步复制不存在延迟问题，但性能太差了。<font color="red">半同步复制是一种折中方案，相对于异步复制，半同步复制提高了数据的安全性，减少了主从延迟（还是有一定程度的延迟）</font>。MySQL 5.5 开始，MySQL 以插件的形式支持 <strong>semi-sync 半同步复制</strong>。并且，MySQL 5.7 引入了 <strong>增强半同步复制</strong> 。</li><li>……</li></ol><p><span class="exturl" data-url="aHR0cHM6Ly90aW1lLmdlZWtiYW5nLm9yZy9jb2x1bW4vaW50cm8vMTAwMDIwODAxP2NvZGU9aWVZOEhlUlNsRHNGYnVSdGdnYkJRR3hkVGgtMWpNQVNxRUllcXpIQUtySSUzRA==">《MySQL 实战 45 讲》</span>这个专栏中的<span class="exturl" data-url="aHR0cHM6Ly90aW1lLmdlZWtiYW5nLm9yZy9jb2x1bW4vYXJ0aWNsZS83NzYzNg==">读写分离有哪些坑？</span>这篇文章也有对主从延迟解决方案这一话题进行探讨，感兴趣的可以阅读学习一下。</p><h5 id="分库分表"><a class="anchor" href="#分库分表">#</a> 分库分表</h5><blockquote><p>解决的问题：<font color="red">数据库存储</font></p></blockquote><p>读写分离主要应对的是数据库读并发，没有解决数据库存储问题。试想一下：** 如果 MySQL 一张表的数据量过大怎么办？** 换言之，<strong>我们该如何解决 MySQL 的存储压力呢？</strong></p><p>答案之一就是 **<font color="#B32015">分库分表</font>**。</p><h6 id="分库"><a class="anchor" href="#分库">#</a> 分库</h6><p>分库就是<font color="red">将数据库中的数据分散到不同的数据库上</font>，可以分为两种：</p><ul><li><p><strong><font color="cornflowerblue">垂直分库</font></strong></p><p>就是把单一数据库 **<font color="red">按照业务进行划分</font>**，不同的业务使用不同的数据库，进而将一个数据库的压力分担到多个数据库。</p><p>举个例子：说你将数据库中的用户表、订单表和商品表分别单独拆分为用户数据库、订单数据库和商品数据库。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231129114419366.png" alt="image-20231129114419366"></p><center>垂直分库</center></li><li><p><strong><font color="cornflowerblue">水平分库</font></strong></p><p>就是把同一个表 **<font color="red">按一定规则拆分</font>** 到不同的数据库中，每个库可以位于不同的服务器上，这样就实现了水平扩展，解决了单表的存储和性能瓶颈的问题。</p><p>举个例子：订单表数据量太大，你对订单表进行了水平切分（水平分表），然后将切分后的 2 张订单表分别放在两个不同的数据库。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/horizontal-slicing-database-53fbc43a.png" alt="水平分库"></p><center>水平分库</center></li></ul><h6 id="分表"><a class="anchor" href="#分表">#</a> 分表</h6><p>分表就是<font color="red">对单表的数据进行拆分</font>，也可以分为两种：</p><ul><li><p><strong><font color="cornflowerblue">垂直分表</font></strong></p><p>是 **<font color="red">对列的拆分</font>**，把一张列比较多的表拆分为多张表。</p><p>举个例子：我们可以将用户信息表中的一些列单独抽出来作为一个表。</p></li><li><p><strong><font color="cornflowerblue">水平分表</font></strong></p><p>是 **<font color="red">对行的拆分</font>**，把一张行比较多的表拆分为多张表，可以解决单一表数据量过大的问题。</p><p>举个例子：我们可以将用户信息表拆分成多个用户信息表。</p><p>水平拆分只能解决单表数据量大的问题，为了提升性能，我们通常会选择将拆分后的多张表放在不同的数据库中。也就是说，<font color="red">水平分表通常和水平分库同时出现</font>。</p></li></ul><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/two-forms-of-sub-table-3475ce44.png" alt="分表"></p><center>分表</center><h6 id="什么情况下需要分库分表"><a class="anchor" href="#什么情况下需要分库分表">#</a> 什么情况下需要分库分表？</h6><p>遇到下面几种场景可以考虑分库分表：</p><ul><li>单表的数据达到千万级别以上，数据库读写速度比较缓慢</li><li>数据库中的数据占用的空间越来越大，备份时间越来越长</li><li>应用的并发量太大</li></ul><h6 id="常见的分片算法"><a class="anchor" href="#常见的分片算法">#</a> 常见的分片算法</h6><p>分片算法主要 **<font color="red">解决了数据被水平分片之后，数据究竟该存放在哪个表的问题</font>**。</p><ul><li><strong><font color="cornflowerblue">哈希分片</font></strong>：求指定 key（比如 id） 的哈希，然后根据哈希值确定数据应被放置在哪个表中。哈希分片比较<font color="red">适合随机读写的场景，不太适合经常需要范围查询的场景</font>。</li><li><strong><font color="cornflowerblue">范围分片</font></strong>：按照特性的范围区间（比如时间区间、ID 区间）来分配数据，比如 将 id 为 1~299999 的记录分到第一个库， 300000~599999 的分到第二个库。范围分片<font color="red">适合需要经常进行范围查找的场景，不太适合随机读写的场景（数据未被分散，容易出现热点数据的问题）</font>。</li><li><strong><font color="cornflowerblue">地理位置分片</font></strong>：很多 NewSQL 数据库都支持地理位置分片算法，也就是<font color="red">根据地理位置（如城市、地域）来分配数据</font>。</li><li><strong><font color="cornflowerblue">融合算法</font></strong>：<font color="red">灵活组合多种分片算法</font>，比如将哈希分片和范围分片组合。</li><li>……</li></ul><h6 id="分库分表会带来什么问题"><a class="anchor" href="#分库分表会带来什么问题">#</a> 分库分表会带来什么问题？</h6><p>记住，你在公司做的任何技术决策，不光是要考虑这个技术能不能满足我们的要求，是否适合当前业务场景，还要重点考虑其带来的成本。</p><p>引入分库分表之后，会给系统带来什么挑战呢？</p><ul><li><strong><font color="red">join 操作</font></strong>：同一个数据库中的表分布在了不同的数据库中，导致无法使用 join 操作。这样就导致我们需要手动进行数据的封装，比如你在一个数据库中查询到一个数据之后，再根据这个数据去另外一个数据库中找对应的数据。不过，很多大厂的资深 DBA 都是建议<font color="red">尽量不要使用 join 操作</font>。因为 join 的效率低，并且会对分库分表造成影响。对于需要用到 join 操作的地方，<font color="red">可以采用多次查询业务层进行数据组装的方法</font>。不过，这种方法需要考虑业务上多次查询的事务性的容忍度。</li><li><strong><font color="red">事务问题</font></strong>：同一个数据库中的表分布在了不同的数据库中，如果单个操作涉及到多个数据库，那么数据库自带的事务就无法满足我们的要求了。这个时候，我们就<font color="red">需要引入分布式事务</font>了。关于分布式事务常见解决方案总结，网站上也有对应的总结：<span class="exturl" data-url="aHR0cHM6Ly9qYXZhZ3VpZGUuY24vZGlzdHJpYnV0ZWQtc3lzdGVtL2Rpc3RyaWJ1dGVkLXRyYW5zYWN0aW9uLmh0bWw=">https://javaguide.cn/distributed-system/distributed-transaction.html</span> 。</li><li><strong><font color="red">分布式 ID</font></strong>：分库之后，数据遍布在不同服务器上的数据库，数据库的<font color="red">自增主键已经没办法满足生成的主键唯一了</font>。我们如何为不同的数据节点生成全局唯一主键呢？这个时候，我们就需要为我们的系统<font color="red">引入分布式 ID </font>了。关于分布式 ID 的详细介绍 &amp; 实现方案总结，网站上也有对应的总结：<span class="exturl" data-url="aHR0cHM6Ly9qYXZhZ3VpZGUuY24vZGlzdHJpYnV0ZWQtc3lzdGVtL2Rpc3RyaWJ1dGVkLWlkLmh0bWw=">https://javaguide.cn/distributed-system/distributed-id.html</span> 。</li><li><strong><font color="red">跨库聚合查询问题</font></strong>：分库分表会导致常规聚合查询操作，如 group by，order by 等变得异常复杂。这是因为这些操作需要在多个分片上进行数据汇总和排序，而不是在单个数据库上进行。为了实现这些操作，<font color="red">需要编写复杂的业务代码，或者使用中间件来协调分片间的通信和数据传输</font>。这样会增加开发和维护的成本，以及影响查询的性能和可扩展性。</li><li>……</li></ul><p>另外，<font color="red">引入分库分表之后，一般需要 DBA 的参与，同时还需要更多的数据库服务器</font>，这些都属于成本。</p><h6 id="分库分表有没有什么比较推荐的方案"><a class="anchor" href="#分库分表有没有什么比较推荐的方案">#</a> 分库分表有没有什么比较推荐的方案？</h6><p>Apache <code>ShardingSphere</code> 是一款分布式的数据库生态系统，<strong><font color="red">可以将任意数据库转换为分布式数据库，并通过数据分片、弹性伸缩、加密等能力对原有数据库进行增强</font></strong>。</p><p>ShardingSphere 项目（包括 Sharding-JDBC、Sharding-Proxy 和 Sharding-Sidecar）是当当捐入 Apache 的，目前主要由京东数科的一些巨佬维护。</p><p>**ShardingSphere 绝对可以说是当前分库分表的首选！**ShardingSphere 的功能完善，<font color="red">除了支持读写分离和分库分表，还提供分布式事务、数据库治理、影子库、数据加密和脱敏等功能</font>。</p><p>ShardingSphere 提供的功能如下：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/shardingsphere-features.png" alt="ShardingSphere 提供的功能"></p><p>ShardingSphere 的优势如下：</p><ul><li>极致性能：驱动程序端历经长年打磨，效率接近原生 JDBC，性能极致。</li><li>生态兼容：代理端支持任何通过 MySQL/PostgreSQL 协议的应用访问，驱动程序端可对接任意实现 JDBC 规范的数据库。</li><li>业务零侵入：面对数据库替换场景，ShardingSphere 可满足业务无需改造，实现平滑业务迁移。</li><li>运维低成本：在保留原技术栈不变前提下，对 DBA 学习、管理成本低，交互友好。</li><li>安全稳定：基于成熟数据库底座之上提供增量能力，兼顾安全性及稳定性。</li><li>弹性扩展：具备计算、存储平滑在线扩展能力，可满足业务多变的需求。</li><li>开放生态：通过多层次（内核、功能、生态）插件化能力，为用户提供可定制满足自身特殊需求的独有系统。</li></ul><p>另外，ShardingSphere 的生态体系完善，社区活跃，文档完善，更新和发布比较频繁。</p><p>艿艿之前写了一篇分库分表的实战文章，各位朋友可以看看：<span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvQTJNWU9GVDdTUC03a0dPb244cUphdw==">《芋道 Spring Boot 分库分表入门》</span> 。</p><h6 id="分库分表后数据怎么迁移呢"><a class="anchor" href="#分库分表后数据怎么迁移呢">#</a> 分库分表后，数据怎么迁移呢？</h6><p>分库分表之后，我们<font color="red">如何将老库（单库单表）的数据迁移到新库（分库分表后的数据库系统）呢？</font></p><p>比较简单同时也是<font color="red">非常常用</font>的方案就是 **<font color="cornflowerblue">停机迁移</font>**，写个脚本将老库的数据写到新库中。比如你在凌晨 2 点，系统使用的人数非常少的时候，挂一个公告说系统要维护升级预计 1 小时。然后，你写一个脚本将老库的数据都同步到新库中。</p><p>如果你<font color="red">不想停机迁移数据的话</font>，也可以考虑 **<font color="cornflowerblue">双写方案</font>**。双写方案是针对那种不能停机迁移的场景，实现起来要稍微麻烦一些。具体原理是这样的：</p><ul><li>我们<font color="red">对老库的更新操作（增删改），同时也要写入新库（双写）</font>。如果操作的数据不存在于新库的话，需要插入到新库中。这样就能保证，咱们新库里的数据是最新的。</li><li>在迁移过程，双写只会让被更新操作过的老库中的数据同步到新库，我们<font color="red">还需要自己写脚本将老库中的数据和新库的数据做比对</font>。如果新库中没有，那咱们就把数据插入到新库。如果新库有，旧库没有，就把新库对应的数据删除（冗余数据清理）。</li><li>重复上一步的操作，<font color="red">直到老库和新库的数据一致为止</font>。</li></ul><p>想要在项目中实施双写还是比较麻烦的，很容易会出现问题。我们<font color="red">可以借助上面提到的数据库同步工具 Canal 做增量数据迁移</font>（还是依赖 binlog，开发和维护成本较低）。</p><h5 id="总结-4"><a class="anchor" href="#总结-4">#</a> 总结</h5><ul><li><p><font color="red">读写分离主要是为了将对数据库的读写操作分散到不同的数据库节点上</font>。这样的话，就能够小幅提升写性能，大幅提升读性能。</p></li><li><p><font color="red">读写分离基于主从复制，而 MySQL 主从复制依赖于 <code>binlog</code> </font>。</p></li><li><p>分库就是将数据库中的数据分散到不同的数据库上。分表就是对单表的数据进行拆分，可以是垂直拆分，也可以是水平拆分。</p></li><li><p>引入分库分表之后，需要系统解决事务、分布式 id、无法 join 操作问题。</p></li><li><p><font color="red">ShardingSphere 绝对可以说是当前分库分表的首选</font>！ShardingSphere 的功能完善，除了支持读写分离和分库分表，还提供分布式事务、数据库治理等功能。另外，ShardingSphere 的生态体系完善，社区活跃，文档完善，更新和发布比较频繁。</p></li></ul><h2 id="mysql-高性能优化规范建议"><a class="anchor" href="#mysql-高性能优化规范建议">#</a> MySQL 高性能优化规范建议</h2><h3 id="命名规范"><a class="anchor" href="#命名规范">#</a> 命名规范</h3><ul><li><p>所有数据库对象名称必须使用<font color="red">小写字母</font>并用<font color="red">下划线分割</font></p></li><li><p>所有数据库对象名称<font color="red">禁止使用 MySQL 保留关键字</font>（如果表名中包含关键字查询时，需要将其用单引号括起来）</p></li><li><p>数据库对象的命名要能做到<font color="red">见名识意，并且最后不要超过 32 个字符</font></p></li><li><p><font color="red">临时库表必须以 <code>tmp_</code> 为前缀并以日期为后缀</font>，<font color="red">备份表必须以 <code>bak_</code> 为前缀并以日期 (时间戳) 为后缀</font></p></li><li><p>所有存储相同数据的列名和列类型必须一致（一般作为关联列，<font color="red">如果查询时关联列类型不一致会自动进行数据类型隐式转换，造成列上的索引失效</font>，导致查询效率降低）</p></li></ul><h3 id="基本设计规范"><a class="anchor" href="#基本设计规范">#</a> 基本设计规范</h3><h4 id="所有表必须使用-innodb-存储引擎"><a class="anchor" href="#所有表必须使用-innodb-存储引擎">#</a> 所有表必须使用 InnoDB 存储引擎</h4><p>没有特殊要求（即 InnoDB 无法满足的功能如：列存储，存储空间数据等）的情况下，所有表必须使用 InnoDB 存储引擎（MySQL5.5 之前默认使用 MyISAM，5.6 以后默认的为 InnoDB）。</p><p><font color="red">InnoDB 支持事务、行级锁、外键约束，有更好的恢复性，高并发下性能更好</font>。</p><h4 id="数据库和表的字符集统一使用-utf8"><a class="anchor" href="#数据库和表的字符集统一使用-utf8">#</a> 数据库和表的字符集统一使用 UTF8</h4><p>兼容性更好，统一字符集可以避免由于字符集转换产生的乱码，<font color="red">不同的字符集进行比较前需要进行转换会造成索引失效</font>。</p><p>如果数据库中有存储 emoji 表情的需要，字符集需要采用 utf8mb4 字符集。</p><h4 id="所有表和字段都需要添加注释"><a class="anchor" href="#所有表和字段都需要添加注释">#</a> 所有表和字段都需要添加注释</h4><p>使用 comment 从句添加表和列的备注，从一开始就进行<font color="red">数据字典的维护</font>。</p><h4 id="尽量控制单表数据量的大小建议控制在-500-万以内"><a class="anchor" href="#尽量控制单表数据量的大小建议控制在-500-万以内">#</a> 尽量控制单表数据量的大小，建议控制在 500 万以内</h4><p>500 万并不是 MySQL 数据库的限制，过大会造成修改表结构，备份，恢复都会有很大的问题。</p><p>可以用<font color="red">历史数据归档（应用于日志数据）</font>，<font color="red">分库分表（应用于业务数据）</font>等手段来控制数据量大小。</p><h4 id="谨慎使用-mysql-分区表"><a class="anchor" href="#谨慎使用-mysql-分区表">#</a> 谨慎使用 MySQL 分区表</h4><p>分区表在物理上表现为多个文件，在逻辑上表现为一个表；</p><p>谨慎选择分区键，<font color="red">跨分区查询效率可能更低</font>；</p><p><font color="red">建议采用物理分表</font>的方式管理大数据。</p><h4 id="经常一起使用的列放到一个表中"><a class="anchor" href="#经常一起使用的列放到一个表中">#</a> 经常一起使用的列放到一个表中</h4><p>避免更多的关联操作。</p><h4 id="禁止在表中建立预留字段"><a class="anchor" href="#禁止在表中建立预留字段">#</a> 禁止在表中建立预留字段</h4><ul><li>预留字段的命名<font color="red">很难做到见名识义</font>。</li><li>预留字段<font color="red">无法确认存储的数据类型</font>，所以无法选择合适的类型。</li><li>对预留字段类型的修改，会对表进行锁定。</li></ul><h4 id="禁止在数据库中存储文件比如图片这类大的二进制数据"><a class="anchor" href="#禁止在数据库中存储文件比如图片这类大的二进制数据">#</a> 禁止在数据库中存储文件（比如图片）这类大的二进制数据</h4><p>在数据库中存储文件<font color="red">会严重影响数据库性能，消耗过多存储空间</font>。</p><p>这类大的二进制数据文件（比如图片）<font color="red">通常存储于文件服务器，数据库只存储文件地址信息</font>。</p><h4 id="不要被数据库范式所束缚"><a class="anchor" href="#不要被数据库范式所束缚">#</a> 不要被数据库范式所束缚</h4><p>一般来说，设计关系数据库时需要满足第三范式，但<font color="red">为了满足第三范式，我们可能会拆分出多张表</font>。而在进行查询时需要对多张表进行关联查询，<font color="red">有时为了提高查询效率，会降低范式的要求，在表中保存一定的冗余信息，也叫做反范式</font>。但要注意反范式一定要适度。</p><h4 id="禁止在线上做数据库压力测试"><a class="anchor" href="#禁止在线上做数据库压力测试">#</a> 禁止在线上做数据库压力测试</h4><h4 id="禁止从开发环境-测试环境直接连接生产环境数据库"><a class="anchor" href="#禁止从开发环境-测试环境直接连接生产环境数据库">#</a> 禁止从开发环境、测试环境直接连接生产环境数据库</h4><p>安全隐患极大，要对生产环境抱有敬畏之心！</p><h3 id="字段设计规范"><a class="anchor" href="#字段设计规范">#</a> 字段设计规范</h3><h4 id="优先选择符合存储需要的最小的数据类型"><a class="anchor" href="#优先选择符合存储需要的最小的数据类型">#</a> 优先选择符合存储需要的最小的数据类型</h4><p>存储字节越小，占用也就空间越小，性能也越好。</p><p><strong>a. 某些字符串可以转换成数字类型存储，比如可以将 IP 地址转换成整型数据。</strong></p><p>数字是连续的，性能更好，占用空间也更小。</p><p>MySQL 提供了两个方法来处理 ip 地址</p><ul><li><code>INET_ATON()</code> ：把 ip 转为无符号整型 (4-8 位)</li><li><code>INET_NTOA()</code> : 把整型的 ip 转为地址</li></ul><p>插入数据前，先用 <code>INET_ATON()</code> 把 ip 地址转为整型，显示数据时，使用 <code>INET_NTOA()</code> 把整型的 ip 地址转为地址显示即可。</p><p><strong>b. 对于非负型的数据 (如自增 ID、整型 IP、年龄) 来说，要优先使用无符号整型来存储。</strong></p><p><font color="red">无符号相对于有符号可以多出一倍的存储空间</font></p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre>SIGNED <span class="token keyword">INT</span> <span class="token operator">-</span><span class="token number">2147483648</span><span class="token operator">~</span><span class="token number">2147483647</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">UNSIGNED</span> <span class="token keyword">INT</span> <span class="token number">0</span><span class="token operator">~</span><span class="token number">4294967295</span></pre></td></tr></table></figure><p><strong>c. 小数值类型（比如年龄、状态表示如 0/1）优先使用 TINYINT 类型。</strong></p><h4 id="避免使用-text-blob-数据类型最常见的-text-类型可以存储-64k-的数据"><a class="anchor" href="#避免使用-text-blob-数据类型最常见的-text-类型可以存储-64k-的数据">#</a> 避免使用 TEXT、BLOB 数据类型，最常见的 TEXT 类型可以存储 64k 的数据</h4><p><strong>a. 建议把 BLOB 或是 TEXT 列分离到单独的扩展表中。</strong></p><p>MySQL <font color="red">内存临时表不支持 TEXT、BLOB 这样的大数据类型</font>，如果查询中包含这样的数据，在排序等操作时，就不能使用内存临时表，<font color="red">必须使用磁盘临时表进行</font>。而且对于这种数据，MySQL 还是要进行二次查询，会使 sql 性能变得很差，但是不是说一定不能使用这样的数据类型。</p><p><font color="red">如果一定要使用，建议把 BLOB 或是 TEXT 列分离到单独的扩展表中</font>，查询时一定不要使用 <code>select *</code> 而只需要取出必要的列，不需要 TEXT 列的数据时不要对该列进行查询。</p><p><strong>2、TEXT 或 BLOB 类型只能使用前缀索引</strong></p><p>因为 MySQL 对索引字段长度是有限制的，所以 TEXT 类型只能使用前缀索引，并且 TEXT 列上是不能有默认值的。</p><h4 id="避免使用-enum-类型"><a class="anchor" href="#避免使用-enum-类型">#</a> 避免使用 ENUM 类型</h4><ul><li><font color="red">修改 ENUM 值需要使用 ALTER 语句</font>；</li><li>ENUM 类型的 <font color="red">ORDER BY 操作效率低</font>，需要额外操作；</li><li>ENUM 数据类型存在一些限制，比如建议不要使用数值作为 ENUM 的枚举值。</li></ul><p>相关阅读：<span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzQwNDQyMjI1NS9hbnN3ZXIvMTY2MTY5ODQ5OQ==">是否推荐使用 MySQL 的 enum 类型？ - 架构文摘 - 知乎</span></p><h4 id="尽可能把所有列定义为-not-null"><a class="anchor" href="#尽可能把所有列定义为-not-null">#</a> 尽可能把所有列定义为 NOT NULL</h4><p>除非有特别的原因使用 NULL 值，应该总是让字段保持 NOT NULL。</p><ul><li>索引 NULL 列需要额外的空间来保存，所以要占用更多的空间；</li><li>进行比较和计算时要对 NULL 值做特别的处理。</li></ul><p>相关阅读：<span class="exturl" data-url="aHR0cHM6Ly9vcGVuc291cmNlLmFjdGlvbnNreS5jb20vMjAxOTA3MTAtbXlzcWwv">技术分享 | MySQL 默认值选型（是空，还是 NULL）</span></p><h4 id="一定不要用字符串存储日期"><a class="anchor" href="#一定不要用字符串存储日期">#</a> 一定不要用字符串存储日期</h4><p>对于日期类型来说，一定不要用字符串存储日期。<font color="red">可以考虑 DATETIME、TIMESTAMP、数值型时间戳</font>。</p><p>这三种方式都有各自的优势，根据实际场景选择最合适的才是王道。下面再对这三种方式做一个简单的对比，以供大家实际开发中选择正确的存放时间的数据类型：</p><table><thead><tr><th>类型</th><th>存储空间</th><th>日期格式</th><th>日期范围</th><th>是否带时区信息</th></tr></thead><tbody><tr><td>DATETIME</td><td>5~8 字节</td><td>YYYY-MM-DD hh:mm:ss[.fraction]</td><td>1000-01-01 00:00:00[.000000] ～ 9999-12-31 23:59:59[.999999]</td><td>否</td></tr><tr><td>TIMESTAMP</td><td>4~7 字节</td><td>YYYY-MM-DD hh:mm:ss[.fraction]</td><td>1970-01-01 00:00:01[.000000] ～ 2038-01-19 03:14:07[.999999]</td><td>是</td></tr><tr><td>数值型时间戳</td><td>4 字节</td><td>全数字如 1578707612</td><td>1970-01-01 00:00:01 之后的时间</td><td>否</td></tr></tbody></table><p>MySQL 时间类型选择的详细介绍请看这篇：<span class="exturl" data-url="aHR0cHM6Ly9qYXZhZ3VpZGUuY24vZGF0YWJhc2UvbXlzcWwvc29tZS10aG91Z2h0cy1vbi1kYXRhYmFzZS1zdG9yYWdlLXRpbWUuaHRtbA==">MySQL 时间类型数据存储建议</span>。</p><h4 id="财务相关的金额类数据必须使用-decimal-类型"><a class="anchor" href="#财务相关的金额类数据必须使用-decimal-类型">#</a> 财务相关的金额类数据必须使用 decimal 类型</h4><ul><li><strong>非精准浮点</strong>：float、double</li><li><strong><font color="#B32015">精准浮点</font></strong>：decimal</li></ul><p>decimal 类型为精准浮点数，<font color="red">在计算时不会丢失精度</font>。占用空间由定义的宽度决定，每 4 个字节可以存储 9 位数字，并且小数点要占用一个字节。并且，<font color="red">decimal 可用于存储比 bigint 更大的整型数据</font>。</p><p>不过，由于 decimal <font color="red">需要额外的空间和计算开销</font>，应该尽量只在需要对数据进行精确计算时才使用 decimal 。</p><h4 id="单表不要包含过多字段"><a class="anchor" href="#单表不要包含过多字段">#</a> 单表不要包含过多字段</h4><p>如果一个表包含过多字段的话，可以考虑将其<font color="red">垂直分表</font>，必要时增加中间表进行关联。</p><h3 id="索引设计规范"><a class="anchor" href="#索引设计规范">#</a> 索引设计规范</h3><h4 id="限制每张表上的索引数量建议单张表索引不超过-5-个"><a class="anchor" href="#限制每张表上的索引数量建议单张表索引不超过-5-个">#</a> 限制每张表上的索引数量，建议单张表索引不超过 5 个</h4><p>索引并不是越多越好！索引可以提高效率同样可以降低效率。</p><p><font color="red">索引可以增加查询效率，但同样也会降低插入和更新的效率</font>，甚至有些情况下会降低查询效率。</p><p>因为 MySQL 优化器在选择如何优化查询时，会根据统一信息，对每一个可以用到的索引来进行评估，以生成出一个最好的执行计划，如果同时有很多个索引都可以用于查询，就会增加<font color="red"> MySQL 优化器生成执行计划的时间</font>，同样会降低查询性能。</p><h4 id="禁止使用全文索引"><a class="anchor" href="#禁止使用全文索引">#</a> 禁止使用全文索引</h4><p>全文索引不适用于 OLTP（联机事务处理）场景。</p><h4 id="禁止给表中的每一列都建立单独的索引"><a class="anchor" href="#禁止给表中的每一列都建立单独的索引">#</a> 禁止给表中的每一列都建立单独的索引</h4><p>5.6 版本之前，一个 sql 只能使用到一个表中的一个索引；5.6 以后，虽然有了合并索引的优化方式，但是还是远远没有使用一个联合索引的查询方式好。</p><h4 id="每个-innodb-表必须有个主键"><a class="anchor" href="#每个-innodb-表必须有个主键">#</a> 每个 InnoDB 表必须有个主键</h4><p>InnoDB 是一种索引组织表：<font color="red">数据存储的逻辑顺序和索引的顺序是相同的</font>。每个表都可以有多个索引，但是表的存储顺序只能有一种。</p><p>InnoDB 是 **<font color="red">按照主键索引的顺序来组织表</font>** 的</p><ul><li>不要使用更新频繁的列作为主键，不使用多列主键（相当于联合索引）</li><li>不要使用 UUID,MD5,HASH, 字符串列作为主键（无法保证数据的顺序增长）</li><li><font color="red">主键建议使用自增 ID 值</font></li></ul><h4 id="常见索引列建议"><a class="anchor" href="#常见索引列建议">#</a> 常见索引列建议</h4><ul><li><p>出现在 WHERE 子句中的列</p></li><li><p>包含在 ORDER BY、GROUP BY、DISTINCT 中的字段</p></li><li><p><font color="red">通常将上述两种情况的字段建立<u>联合索引</u>，效果更好</font></p></li><li><p>多表 join 的<font color="red">关联列</font></p></li></ul><h4 id="如何选择联合索引中的列顺序"><a class="anchor" href="#如何选择联合索引中的列顺序">#</a> 如何选择联合索引中的列顺序</h4><p>建立索引的目的是：希望通过索引进行数据查找，减少随机 IO，增加查询性能，<font color="red">索引能过滤出越少的数据，则从磁盘中读入的数据也就越少</font>。</p><ul><li><p><font color="red">区分度最高的列</font>放在联合索引的最左侧</p><blockquote><p>区分度 = 列中不同值的数量 / 列的总行数</p></blockquote></li><li><p>尽量把<font color="red">字段长度小的列</font>放在联合索引的最左侧</p><blockquote><p>因为字段长度越小，一页能存储的数据量越大，IO 性能也就越好</p></blockquote></li><li><p><font color="red">使用最频繁的列</font>放到联合索引的左侧</p><blockquote><p>这样可以比较少的建立一些索引</p></blockquote></li></ul><h4 id="避免建立冗余索引-重复索引"><a class="anchor" href="#避免建立冗余索引-重复索引">#</a> 避免建立冗余索引、重复索引</h4><blockquote><p>增加了查询优化器生成执行计划的时间</p></blockquote><ul><li>重复索引示例：primary key (id)、index (id)、unique index (id)</li><li>冗余索引示例：index (a,b,c)、index (a,b)、index (a)</li></ul><h4 id="对于频繁的查询优先考虑覆盖索引"><a class="anchor" href="#对于频繁的查询优先考虑覆盖索引">#</a> 对于频繁的查询，优先考虑覆盖索引</h4><blockquote><p>覆盖索引：<font color="red">包含了所有查询字段</font> (where,select,order by,group by 包含的字段) 的索引。</p></blockquote><p>覆盖索引的好处：</p><ul><li><strong><font color="red">避免二次查询（回表）</font></strong>：InnoDB 是以聚集索引的顺序来存储的，对于 InnoDB 来说，二级索引在叶子节点中所保存的是行的主键信息。<font color="red">如果是用二级索引查询数据的话，在查找到相应的主键后，还要通过聚集索引进行二次查询才能获取我们真实所需要的数据</font>。而在覆盖索引中，二级索引的键值中可以获取所有的数据，避免了对主键的二次查询，减少了 IO 操作，提升了查询效率。</li><li><strong>可以把随机 IO 变成顺序 IO 加快查询效率:</strong> 由于覆盖索引是按键值的顺序存储的，对于 IO 密集型的范围查找来说，对比随机从磁盘读取每一行的数据 IO 要少的多。因此利用覆盖索引在访问时也可以把磁盘的随机读取的 IO 转变成索引查找的顺序 IO。</li></ul><h4 id="索引-set-规范"><a class="anchor" href="#索引-set-规范">#</a> 索引 SET 规范</h4><p><strong><font color="red">尽量避免使用外键约束</font></strong></p><ul><li>不建议使用外键约束（foreign key），但<font color="red">一定要在表与表之间的关联键上建立索引</font></li><li>外键可用于保证数据的参照完整性，但<font color="red">建议在业务端实现外键约束</font></li><li><font color="red">外键会影响父表和子表的写操作</font>，从而降低性能</li></ul><h3 id="sql-开发规范"><a class="anchor" href="#sql-开发规范">#</a> SQL 开发规范</h3><h4 id="尽量不在数据库做运算复杂运算需移到业务应用里完成"><a class="anchor" href="#尽量不在数据库做运算复杂运算需移到业务应用里完成">#</a> 尽量不在数据库做运算，复杂运算需移到业务应用里完成</h4><p>避免数据库的负担过重，影响数据库的性能和稳定性。数据库的主要作用是存储和管理数据，而不是处理数据。</p><h4 id="优化对性能影响较大的-sql-语句"><a class="anchor" href="#优化对性能影响较大的-sql-语句">#</a> 优化对性能影响较大的 SQL 语句</h4><p>要找到最需要优化的 SQL 语句。要么是<font color="red">使用最频繁</font>的语句，要么是<font color="red">优化后提高最明显</font>的语句，可以通过查询 MySQL 的 **<font color="red">慢查询日志</font>** 来发现需要进行优化的 SQL 语句。</p><h4 id="充分利用表上已经存在的索引"><a class="anchor" href="#充分利用表上已经存在的索引">#</a> 充分利用表上已经存在的索引</h4><p>避免使用双 % 号的查询条件。如： <code>a like '%123%'</code> ，（如果无前置 %, 只有后置 %，是可以用到列上的索引的）</p><p>一个 SQL 只能利用到复合索引中的一列进行范围查询。如：有 a,b,c 列的联合索引，在查询条件中有 a 列的范围查询，则在 b,c 列上的索引将不会被用到。</p><p>在定义联合索引时，如果 a 列要用到范围查找的话，就要把 a 列放到联合索引的右侧，使用 left join 或 not exists 来优化 not in 操作，因为 not in 也通常会使用索引失效。</p><h4 id="禁止使用-select-查询"><a class="anchor" href="#禁止使用-select-查询">#</a> 禁止使用 SELECT * 查询</h4><ul><li><p><code>SELECT *</code> 会消耗更多的 CPU</p></li><li><p><code>SELECT *</code> 无用字段增加网络带宽资源消耗，增加数据传输时间，尤其是大字段（如 varchar、blob、text）</p></li><li><p><code>SELECT *</code> <font color="red">无法使用 MySQL 优化器覆盖索引的优化</font>（基于 MySQL 优化器的 “覆盖索引” 策略又是速度极快，效率极高，业界极为推荐的查询优化方式）</p></li><li><p><code>SELECT &lt;字段列表&gt;</code> 可减少表结构变更带来的影响</p></li></ul><h4 id="禁止使用不含字段列表的-insert-语句"><a class="anchor" href="#禁止使用不含字段列表的-insert-语句">#</a> 禁止使用不含字段列表的 INSERT 语句</h4><p>如：</p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">insert</span> <span class="token keyword">into</span> t <span class="token keyword">values</span> <span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">,</span><span class="token string">'b'</span><span class="token punctuation">,</span><span class="token string">'c'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>应使用：</p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">insert</span> <span class="token keyword">into</span> t<span class="token punctuation">(</span>c1<span class="token punctuation">,</span>c2<span class="token punctuation">,</span>c3<span class="token punctuation">)</span> <span class="token keyword">values</span> <span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">,</span><span class="token string">'b'</span><span class="token punctuation">,</span><span class="token string">'c'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h4 id="建议使用预编译语句进行数据库操作"><a class="anchor" href="#建议使用预编译语句进行数据库操作">#</a> 建议使用预编译语句进行数据库操作</h4><ul><li><p>预编译语句可以重复使用这些计划，<font color="red">减少 SQL 编译所需要的时间</font>，还可以<font color="red">解决动态 SQL 所带来的 SQL 注入的问题</font></p></li><li><p><font color="red">只传参数</font>，比传递 SQL 语句更高效</p></li><li><p>相同语句可以<font color="red">一次解析，多次使用</font>，提高处理效率</p></li></ul><h4 id="避免数据类型的隐式转换"><a class="anchor" href="#避免数据类型的隐式转换">#</a> 避免数据类型的隐式转换</h4><p>隐式转换<font color="red">会导致索引失效</font>如:</p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">select</span> name<span class="token punctuation">,</span>phone <span class="token keyword">from</span> customer <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token string">'111'</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>详细解读可以看：<span class="exturl" data-url="aHR0cHM6Ly9qYXZhZ3VpZGUuY24vZGF0YWJhc2UvbXlzcWwvaW5kZXgtaW52YWxpZGF0aW9uLWNhdXNlZC1ieS1pbXBsaWNpdC1jb252ZXJzaW9uLmh0bWw=">MySQL 中的隐式转换造成的索引失效</span> 这篇文章。</p><h4 id="避免使用子查询可以把子查询优化为-join-操作"><a class="anchor" href="#避免使用子查询可以把子查询优化为-join-操作">#</a> 避免使用子查询，可以把子查询优化为 join 操作</h4><p>通常子查询在 in 子句中，且子查询中为简单 SQL (不包含 union、group by、order by、limit 从句) 时，才可以把子查询转化为关联查询进行优化。</p><p>子查询性能差的原因：<strong><font color="red">子查询的结果集通常被存储到临时表中，不论是内存临时表还是磁盘临时表都不会存在索引</font></strong>，所以查询性能会受到一定的影响。特别是对于返回结果集比较大的子查询，其对查询性能的影响也就越大。由于子查询会产生大量的临时表也没有索引，所以会消耗过多的 CPU 和 IO 资源，产生大量的慢查询。</p><h4 id="避免使用-join-关联太多的表"><a class="anchor" href="#避免使用-join-关联太多的表">#</a> 避免使用 JOIN 关联太多的表</h4><ul><li><p>对于 MySQL 来说，是存在<font color="red">关联缓存</font>的，缓存的大小可以由 <code>join_buffer_size</code> 参数进行设置。</p></li><li><p>在 MySQL 中，对于同一个 SQL，多关联（join）一个表，就会多分配一个关联缓存，如果在<font color="red">一个 SQL 中关联的表越多，所占用的内存也就越大</font>。</p></li><li><p>如果程序中大量的使用了多表关联的操作，同时 join_buffer_size 设置的也不合理的情况下，就<font color="red">容易造成服务器内存溢出</font>的情况，就会影响到服务器数据库性能的稳定性。</p></li><li><p>同时对于关联操作来说，会产生临时表操作，影响查询效率，<font color="red">MySQL 最多允许关联 61 个表，建议不超过 5 个</font>。</p></li></ul><h4 id="减少同数据库的交互次数"><a class="anchor" href="#减少同数据库的交互次数">#</a> 减少同数据库的交互次数</h4><p>数据库更适合处理批量操作，<font color="red">合并多个相同的操作到一起</font>，可以提高处理效率。</p><h4 id="对应同一列进行-or-判断时使用-in-代替-or"><a class="anchor" href="#对应同一列进行-or-判断时使用-in-代替-or">#</a> 对应同一列进行 or 判断时，使用 in 代替 or</h4><p>in 的值不要超过 500 个，in 操作可以更有效的利用索引，or 大多数情况下很少能利用到索引。</p><h4 id="禁止使用-order-by-rand-进行随机排序"><a class="anchor" href="#禁止使用-order-by-rand-进行随机排序">#</a> 禁止使用 order by rand () 进行随机排序</h4><p>order by rand () 会把表中所有符合条件的数据装载到内存中，然后在内存中对所有数据根据随机生成的值进行排序，并且可能会对每一行都生成一个随机值，如果满足条件的数据集非常大，就会消耗大量的 CPU 和 IO 及内存资源。</p><p>推荐在程序中获取一个随机值，然后从数据库中获取数据的方式。</p><h4 id="where-从句中禁止对列进行函数转换和计算"><a class="anchor" href="#where-从句中禁止对列进行函数转换和计算">#</a> WHERE 从句中禁止对列进行函数转换和计算</h4><p>对列进行函数转换或计算时<font color="red">会导致索引失效</font></p><p>不推荐：</p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">where</span> <span class="token keyword">date</span><span class="token punctuation">(</span>create_time<span class="token punctuation">)</span><span class="token operator">=</span><span class="token string">'20190101'</span></pre></td></tr></table></figure><p>推荐：</p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">where</span> create_time <span class="token operator">>=</span> <span class="token string">'20190101'</span> <span class="token operator">and</span> create_time <span class="token operator">&lt;</span> <span class="token string">'20190102'</span></pre></td></tr></table></figure><h4 id="在明显不会有重复值时使用-union-all-而不是-union"><a class="anchor" href="#在明显不会有重复值时使用-union-all-而不是-union">#</a> 在明显不会有重复值时，使用 UNION ALL 而不是 UNION</h4><ul><li>UNION：把两个结果集的所有数据<font color="red">放到临时表中，再进行去重操作</font></li><li>UNION ALL：<font color="red">不会再对结果集进行去重操作</font></li></ul><h4 id="拆分复杂的大-sql-为多个小-sql"><a class="anchor" href="#拆分复杂的大-sql-为多个小-sql">#</a> 拆分复杂的大 SQL 为多个小 SQL</h4><ul><li>大 SQL 逻辑上比较复杂，需要占用大量 CPU 进行计算的 SQL</li><li>MySQL 中，一个 SQL 只能使用一个 CPU 进行计算</li><li>SQL 拆分后可以通过<font color="red">并行执行</font>来提高处理效率</li></ul><h4 id="程序连接不同的数据库使用不同的账号禁止跨库查询"><a class="anchor" href="#程序连接不同的数据库使用不同的账号禁止跨库查询">#</a> 程序连接不同的数据库使用不同的账号，禁止跨库查询</h4><ul><li>为数据库迁移和分库分表留出余地</li><li>降低业务耦合度</li><li>避免权限过大而产生的安全风险</li></ul><h3 id="操作行为规范"><a class="anchor" href="#操作行为规范">#</a> 操作行为规范</h3><h4 id="超-100-万行的批量写-updatedeleteinsert-操作要分批多次进行操作"><a class="anchor" href="#超-100-万行的批量写-updatedeleteinsert-操作要分批多次进行操作">#</a> 超 100 万行的批量写 (UPDATE,DELETE,INSERT) 操作，要分批多次进行操作</h4><p><strong><font color="red">大批量操作可能会造成严重的主从延迟</font></strong></p><p>主从环境中，大批量操作可能会造成严重的主从延迟，大批量的写操作一般都需要执行一定长的时间，而只有当主库上执行完成后，才会在其他从库上执行，所以会造成主库与从库长时间的延迟情况</p><p><strong><font color="red">binlog 日志为 row 格式时会产生大量的日志</font></strong></p><p>大批量写操作会产生大量日志，特别是对于 row 格式二进制数据而言，由于<font color="red">在 row 格式中会记录每一行数据的修改</font>，我们一次修改的数据越多，产生的日志量也就会越多，日志的传输和恢复所需要的时间也就越长，这也是造成主从延迟的一个原因</p><p><strong><font color="red">避免产生大事务操作</font></strong></p><p>大批量修改数据，一定是在一个事务中进行的，这就<font color="red">会造成表中大批量数据进行锁定，从而导致大量的阻塞</font>，阻塞会对 MySQL 的性能产生非常大的影响。</p><p>特别是<font color="red">长时间的阻塞会占满所有数据库的可用连接</font>，这会使生产环境中的其他应用无法连接到数据库，因此一定要注意大批量写操作要进行分批</p><h4 id="对于大表使用-pt-online-schema-change-修改表结构"><a class="anchor" href="#对于大表使用-pt-online-schema-change-修改表结构">#</a> 对于大表使用 pt-online-schema-change 修改表结构</h4><ul><li>避免大表修改产生的主从延迟</li><li>避免在对表字段进行修改时进行锁表</li></ul><p><font color="red">对大表数据结构的修改一定要谨慎，会造成严重的锁表操作</font>，尤其是生产环境，是不能容忍的。</p><p><code>pt-online-schema-change</code> <font color="red">首先会建立一个与原表结构相同的新表，并且在新表上进行表结构的修改，然后再把原表中的数据复制到新表中，并在原表中增加一些触发器。把原表中新增的数据也复制到新表中，在所有数据复制完成之后，把新表命名成原表，并把原来的表删除掉。</font>把原来一个 DDL 操作，分解成多个小的批次进行。</p><h4 id="禁止为程序使用的账号赋予-super-权限"><a class="anchor" href="#禁止为程序使用的账号赋予-super-权限">#</a> 禁止为程序使用的账号赋予 super 权限</h4><ul><li>当达到最大连接数限制时，还运行 1 个有 super 权限的用户连接</li><li><font color="red">super 权限只能留给 DBA 处理问题的账号使用</font></li></ul><h4 id="对于程序连接数据库账号遵循权限最小原则"><a class="anchor" href="#对于程序连接数据库账号遵循权限最小原则">#</a> 对于程序连接数据库账号，遵循权限最小原则</h4><ul><li>程序使用数据库账号只能在一个 DB 下使用，不准跨库</li><li>程序使用的账号原则上不准有 drop 权限</li></ul><h2 id="sql"><a class="anchor" href="#sql">#</a> SQL</h2><h3 id="sql语法基础"><a class="anchor" href="#sql语法基础">#</a> SQL 语法基础</h3><h4 id="基本概念-2"><a class="anchor" href="#基本概念-2">#</a> 基本概念</h4><h5 id="数据库术语"><a class="anchor" href="#数据库术语">#</a> 数据库术语</h5><ul><li><code>数据库（database）</code> - 保存有组织的数据的容器（通常是一个文件或一组文件）。</li><li><code>数据表（table）</code> - 某种特定类型数据的结构化清单。</li><li><code>模式（schema）</code> - <font color="red">关于数据库和表的布局及特性的信息</font>。模式<font color="red">定义了数据在表中如何存储</font>，包含存储什么样的数据，数据如何分解，各部分信息如何命名等信息。数据库和表都有模式。</li><li><code>列（column）</code> - 表中的一个字段。所有表都是由一个或多个列组成的。</li><li><code>行（row）</code> - 表中的一个记录。</li><li><code>主键（primary key）</code> - 一列（或一组列），其值能够唯一标识表中每一行。</li></ul><h5 id="sql-语法"><a class="anchor" href="#sql-语法">#</a> SQL 语法</h5><p><code>SQL（Structured Query Language)</code> ，标准 SQL 由 ANSI 标准委员会管理，从而称为 ANSI SQL。各个 DBMS 都有自己的实现，如 PL/SQL、Transact-SQL 等。</p><h6 id="sql-语法结构"><a class="anchor" href="#sql-语法结构">#</a> SQL 语法结构</h6><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/cb684d4c75fc430e92aaee226069c7da%7Etplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>SQL 语法结构包括：</p><ul><li><strong><code>子句</code> </strong>- 是语句和查询的组成成分。（在某些情况下，这些都是可选的。）</li><li><strong><code>表达式</code> </strong>- 可以产生任何标量值，或由列和行的数据库表</li><li><strong><code>谓词</code> </strong>- 给需要评估的 SQL 三值逻辑（3VL）（true/false/unknown）或布尔真值指定条件，并限制语句和查询的效果，或改变程序流程。</li><li><strong><code>查询</code> </strong>- 基于特定条件检索数据。这是 SQL 的一个重要组成部分。</li><li><strong><code>语句</code> </strong>- 可以持久地影响纲要和数据，也可以控制数据库事务、程序流程、连接、会话或诊断。</li></ul><h6 id="sql-语法要点"><a class="anchor" href="#sql-语法要点">#</a> SQL 语法要点</h6><ul><li><strong>SQL 语句不区分大小写</strong>，但是数据库表名、列名和值是否区分，依赖于具体的 DBMS 以及配置。例如： <code>SELECT</code> 与 <code>select</code> 、 <code>Select</code> 是相同的。</li><li><strong>多条 SQL 语句必须以分号（ <code>;</code> ）分隔</strong>。</li><li>处理 SQL 语句时，<strong>所有空格都被忽略</strong>。</li></ul><p>SQL 语句可以写成一行，也可以分写为多行。</p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">-- 一行 SQL 语句</span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">UPDATE</span> <span class="token keyword">user</span> <span class="token keyword">SET</span> username<span class="token operator">=</span><span class="token string">'robot'</span><span class="token punctuation">,</span> password<span class="token operator">=</span><span class="token string">'robot'</span> <span class="token keyword">WHERE</span> username <span class="token operator">=</span> <span class="token string">'root'</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token comment">-- 多行 SQL 语句</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">UPDATE</span> <span class="token keyword">user</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">SET</span> username<span class="token operator">=</span><span class="token string">'robot'</span><span class="token punctuation">,</span> password<span class="token operator">=</span><span class="token string">'robot'</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token keyword">WHERE</span> username <span class="token operator">=</span> <span class="token string">'root'</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>SQL 支持三种注释：</p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">## 注释 1</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment">-- 注释 2</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">/* 注释 3 */</span></pre></td></tr></table></figure><h5 id="sql-分类"><a class="anchor" href="#sql-分类">#</a> SQL 分类</h5><h6 id="数据定义语言ddl"><a class="anchor" href="#数据定义语言ddl">#</a> 数据定义语言（DDL）</h6><p>数据定义语言（Data Definition Language，DDL）是 SQL 语言集中负责数据结构定义与数据库对象定义的语言。</p><p>DDL 的主要功能是<strong>定义数据库对象</strong>。</p><p>DDL 的核心指令是 <code>CREATE</code> 、 <code>ALTER</code> 、 <code>DROP</code> 。</p><h6 id="数据操纵语言dml"><a class="anchor" href="#数据操纵语言dml">#</a> 数据操纵语言（DML）</h6><p>数据操纵语言（Data Manipulation Language, DML）是用于数据库操作，对数据库其中的对象和数据运行访问工作的编程语句。</p><p>DML 的主要功能是 访问数据，因此其语法都是以<strong>读写数据库</strong>为主。</p><p>DML 的核心指令是 <code>INSERT</code> 、 <code>DELETE</code> 、 <code>UPDATE</code> 、 <code>SELECT</code> 。这四个指令合称 CRUD (Create, Read, Update, Delete)，即增删改查。</p><h6 id="事务控制语言tcl"><a class="anchor" href="#事务控制语言tcl">#</a> 事务控制语言（TCL）</h6><p>事务控制语言 (Transaction Control Language, TCL) 用于<strong>管理数据库中的事务</strong>。这些用于管理由 DML 语句所做的更改。它还允许将语句分组为逻辑事务。</p><p>TCL 的核心指令是 <code>COMMIT</code> 、 <code>ROLLBACK</code> 。</p><h6 id="数据控制语言dcl"><a class="anchor" href="#数据控制语言dcl">#</a> 数据控制语言（DCL）</h6><p>数据控制语言 (Data Control Language, DCL) 是一种可对数据访问权进行控制的指令，它可以控制特定用户账户对数据表、查看表、预存程序、用户自定义函数等数据库对象的控制权。</p><p>DCL 的核心指令是 <code>GRANT</code> 、 <code>REVOKE</code> 。</p><p>DCL 以<strong>控制用户的访问权限</strong>为主，因此其指令作法并不复杂，可利用 DCL 控制的权限有： <code>CONNECT</code> 、 <code>SELECT</code> 、 <code>INSERT</code> 、 <code>UPDATE</code> 、 <code>DELETE</code> 、 <code>EXECUTE</code> 、 <code>USAGE</code> 、 <code>REFERENCES</code> 。</p><p>根据不同的 DBMS 以及不同的安全性实体，其支持的权限控制也有所不同。</p><p><strong>我们先来介绍 DML 语句用法。 DML 的主要功能是读写数据库实现增删改查。</strong></p><h4 id="增删改查"><a class="anchor" href="#增删改查">#</a> 增删改查</h4><p>增删改查，又称为 CRUD，数据库基本操作中的基本操作。</p><h5 id="插入数据"><a class="anchor" href="#插入数据">#</a> 插入数据</h5><p><code>INSERT INTO</code> 语句用于向表中插入新记录。</p><p><strong>插入完整的行</strong></p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment"># 插入一行</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token keyword">user</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token string">'root'</span><span class="token punctuation">,</span> <span class="token string">'root'</span><span class="token punctuation">,</span> <span class="token string">'xxxx@163.com'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment"># 插入多行</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token keyword">user</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token string">'root'</span><span class="token punctuation">,</span> <span class="token string">'root'</span><span class="token punctuation">,</span> <span class="token string">'xxxx@163.com'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">,</span> <span class="token string">'user1'</span><span class="token punctuation">,</span> <span class="token string">'user1'</span><span class="token punctuation">,</span> <span class="token string">'xxxx@163.com'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">18</span><span class="token punctuation">,</span> <span class="token string">'user2'</span><span class="token punctuation">,</span> <span class="token string">'user2'</span><span class="token punctuation">,</span> <span class="token string">'xxxx@163.com'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p><strong>插入行的一部分</strong></p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token keyword">user</span><span class="token punctuation">(</span>username<span class="token punctuation">,</span> password<span class="token punctuation">,</span> email<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'admin'</span><span class="token punctuation">,</span> <span class="token string">'admin'</span><span class="token punctuation">,</span> <span class="token string">'xxxx@163.com'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p><strong>插入查询出来的数据</strong></p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token keyword">user</span><span class="token punctuation">(</span>username<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">SELECT</span> name</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">FROM</span> account<span class="token punctuation">;</span></pre></td></tr></table></figure><h5 id="更新数据"><a class="anchor" href="#更新数据">#</a> 更新数据</h5><p><code>UPDATE</code> 语句用于更新表中的记录。</p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">UPDATE</span> <span class="token keyword">user</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">SET</span> username<span class="token operator">=</span><span class="token string">'robot'</span><span class="token punctuation">,</span> password<span class="token operator">=</span><span class="token string">'robot'</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">WHERE</span> username <span class="token operator">=</span> <span class="token string">'root'</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h5 id="删除数据"><a class="anchor" href="#删除数据">#</a> 删除数据</h5><ul><li><code>DELETE</code> 语句用于删除表中的记录。</li><li><code>TRUNCATE TABLE</code> 可以清空表，也就是删除所有行。</li></ul><p><strong>删除表中的指定数据</strong></p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">DELETE</span> <span class="token keyword">FROM</span> <span class="token keyword">user</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">WHERE</span> username <span class="token operator">=</span> <span class="token string">'robot'</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p><strong>清空表中的数据</strong></p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">TRUNCATE</span> <span class="token keyword">TABLE</span> <span class="token keyword">user</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h5 id="查询数据"><a class="anchor" href="#查询数据">#</a> 查询数据</h5><p><code>SELECT</code> 语句用于从数据库中查询数据。</p><p><code>DISTINCT</code> 用于返回唯一不同的值。它<font color="red">作用于所有列</font>，也就是说所有列的值都相同才算相同。</p><p><code>LIMIT</code> 限制返回的行数。可以有两个参数，<strong><font color="red">第一个参数为起始行从 0 开始</font></strong>；<font color="red">第二个参数为返回的总行数</font>。</p><ul><li><code>ASC</code> ：升序（默认）</li><li><code>DESC</code> ：降序</li></ul><p><strong>查询单列</strong></p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">SELECT</span> prod_name</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">FROM</span> products<span class="token punctuation">;</span></pre></td></tr></table></figure><p><strong>查询多列</strong></p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">SELECT</span> prod_id<span class="token punctuation">,</span> prod_name<span class="token punctuation">,</span> prod_price</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">FROM</span> products<span class="token punctuation">;</span></pre></td></tr></table></figure><p><strong>查询所有列</strong></p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">SELECT</span> <span class="token operator">*</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">FROM</span> products<span class="token punctuation">;</span></pre></td></tr></table></figure><p><strong>查询不同的值</strong></p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">SELECT</span> <span class="token keyword">DISTINCT</span> vend_id </pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">FROM</span> products<span class="token punctuation">;</span></pre></td></tr></table></figure><p><strong>限制查询结果</strong></p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">-- 返回前 5 行</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> mytable <span class="token keyword">LIMIT</span> <span class="token number">5</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> mytable <span class="token keyword">LIMIT</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment">-- 返回第 3 ~ 5 行</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> mytable <span class="token keyword">LIMIT</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h4 id="排序"><a class="anchor" href="#排序">#</a> 排序</h4><p><code>order by</code> 用于对结果集按照一个列或者多个列进行排序。 <code>默认升序</code> 对记录进行排序，如果需要按照降序对记录进行排序，可以使用 <code>desc</code> 关键字。</p><p><code>order by</code> 对多列排序的时候，先排序的列放前面，后排序的列放后面。并且，<font color="red">不同的列可以有不同的排序规则</font>。</p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> products</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">ORDER</span> <span class="token keyword">BY</span> prod_price <span class="token keyword">DESC</span><span class="token punctuation">,</span> prod_name <span class="token keyword">ASC</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h4 id="分组"><a class="anchor" href="#分组">#</a> 分组</h4><p><strong><code>group by</code> </strong>：</p><ul><li><code>group by</code> 子句将记录分组到汇总行中。</li><li><code>group by</code> 为每个组返回一个记录。</li><li><code>group by</code> 通常还涉及聚合 <code>count</code> ， <code>max</code> ， <code>sum</code> ， <code>avg</code> 等。</li><li><code>group by</code> 可以按一列或多列进行分组。</li><li><code>group by</code> 按分组字段进行排序后， <code>order by</code> 可以以汇总字段来进行排序。</li></ul><p><strong>分组</strong></p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">SELECT</span> cust_name<span class="token punctuation">,</span> <span class="token function">COUNT</span><span class="token punctuation">(</span>cust_address<span class="token punctuation">)</span> <span class="token keyword">AS</span> addr_num</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">FROM</span> Customers <span class="token keyword">GROUP</span> <span class="token keyword">BY</span> cust_name<span class="token punctuation">;</span></pre></td></tr></table></figure><p><strong>分组后排序</strong></p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">SELECT</span> cust_name<span class="token punctuation">,</span> <span class="token function">COUNT</span><span class="token punctuation">(</span>cust_address<span class="token punctuation">)</span> <span class="token keyword">AS</span> addr_num</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">FROM</span> Customers <span class="token keyword">GROUP</span> <span class="token keyword">BY</span> cust_name</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">ORDER</span> <span class="token keyword">BY</span> cust_name <span class="token keyword">DESC</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p><strong><code>having</code> </strong>：</p><ul><li><code>having</code> <font color="red">用于对汇总的 <code>group by</code> 结果进行过滤</font>。</li><li><code>having</code> 一般都是和 <code>group by</code> 连用。</li><li><code>where</code> 和 <code>having</code> 可以在相同的查询中。</li></ul><p><strong>使用 WHERE 和 HAVING 过滤数据</strong></p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">SELECT</span> cust_name<span class="token punctuation">,</span> <span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> num</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">FROM</span> Customers</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">WHERE</span> cust_email <span class="token operator">IS</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">GROUP</span> <span class="token keyword">BY</span> cust_name</pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">HAVING</span> <span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p><strong><code>having</code> vs <code>where</code> </strong>：</p><ul><li><code>where</code> ：<ul><li><font color="red">过滤指定的<u>行</u></font></li><li><font color="red">后面不能加聚合函数</font>（分组函数）</li><li><font color="red">在 <code>group by</code> 前使用</font></li></ul></li><li><code>having</code> ：<ul><li><font color="red">过滤<u>分组</u></font></li><li>一般都是和 <code>group by</code> 连用，<font color="red">不能单独使用</font></li><li><font color="red">在 <code>group by</code> 之后使用</font></li></ul></li></ul><h4 id="子查询"><a class="anchor" href="#子查询">#</a> 子查询</h4><p>子查询是嵌套在较大查询中的 SQL 查询，也称内部查询或内部选择，包含子查询的语句也称为外部查询或外部选择。简单来说，子查询就是指<font color="red">将一个 <code>select</code> 查询（子查询）的结果作为另一个 SQL 语句（主查询）的<u>数据来源</u>或者<u>判断条件</u></font>。</p><p>子查询可以嵌入 <code>SELECT</code> 、 <code>INSERT</code> 、 <code>UPDATE</code> 和 <code>DELETE</code> 语句中，也可以和 <code>=</code> 、 <code>&lt;</code> 、 <code>&gt;</code> 、 <code>IN</code> 、 <code>BETWEEN</code> 、 <code>EXISTS</code> 等运算符一起使用。</p><p>子查询常用在 <code>WHERE</code> 子句和 <code>FROM</code> 子句后边：</p><ul><li><p>当用于 <strong><code>WHERE</code> </strong>子句后边时，根据不同的运算符，子查询可以返回单行单列、多行单列、单行多列数据。子查询就是要<font color="red">返回能够作为 <code>WHERE</code> 子句查询条件的值</font>。</p><blockquote><p>用于 <code>WHERE</code> 子句的子查询的基本语法如下：</p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">select</span> column_name <span class="token punctuation">[</span><span class="token punctuation">,</span> column_name <span class="token punctuation">]</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">from</span>   table1 <span class="token punctuation">[</span><span class="token punctuation">,</span> table2 <span class="token punctuation">]</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">where</span>  column_name operator</pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token punctuation">(</span><span class="token keyword">select</span> column_name <span class="token punctuation">[</span><span class="token punctuation">,</span> column_name <span class="token punctuation">]</span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">from</span> table1 <span class="token punctuation">[</span><span class="token punctuation">,</span> table2 <span class="token punctuation">]</span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token punctuation">[</span><span class="token keyword">where</span><span class="token punctuation">]</span><span class="token punctuation">)</span></pre></td></tr></table></figure><ul><li>子查询需要放在括号 <code>( )</code> 内。</li><li><code>operator</code> 表示用于 where 子句的运算符。</li></ul></blockquote></li><li><p>当用于 <strong><code>FROM</code> </strong>子句后边时，一般返回多行多列数据，相当于<font color="red">返回一张临时表</font>，这样才符合 <code>FROM</code> 后面是表的规则。这种做法能够实现<font color="red">多表联合查询</font>。</p><blockquote><p>用于 <code>FROM</code> 子句的子查询的基本语法如下：</p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">select</span> column_name <span class="token punctuation">[</span><span class="token punctuation">,</span> column_name <span class="token punctuation">]</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">from</span> <span class="token punctuation">(</span><span class="token keyword">select</span> column_name <span class="token punctuation">[</span><span class="token punctuation">,</span> column_name <span class="token punctuation">]</span></pre></td></tr><tr><td data-num="3"></td><td><pre>   <span class="token keyword">from</span> table1 <span class="token punctuation">[</span><span class="token punctuation">,</span> table2 <span class="token punctuation">]</span></pre></td></tr><tr><td data-num="4"></td><td><pre>   <span class="token punctuation">[</span><span class="token keyword">where</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">as</span> temp_table_name</pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">where</span>  condition</pre></td></tr></table></figure><p>用于 <code>FROM</code> 的子查询返回的结果相当于一张临时表，所以<strong>需要使用 <code>AS</code> 关键字为该临时表起一个名字</strong>。</p></blockquote></li></ul><blockquote><p>注意：MYSQL 数据库从 4.1 版本才开始支持子查询，早期版本是不支持的。</p></blockquote><p><strong>子查询的子查询</strong></p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">SELECT</span> cust_name<span class="token punctuation">,</span> cust_contact</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">FROM</span> customers</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">WHERE</span> cust_id <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> cust_id</pre></td></tr><tr><td data-num="4"></td><td><pre>                  <span class="token keyword">FROM</span> orders</pre></td></tr><tr><td data-num="5"></td><td><pre>                  <span class="token keyword">WHERE</span> order_num <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> order_num</pre></td></tr><tr><td data-num="6"></td><td><pre>                                      <span class="token keyword">FROM</span> orderitems</pre></td></tr><tr><td data-num="7"></td><td><pre>                                      <span class="token keyword">WHERE</span> prod_id <span class="token operator">=</span> <span class="token string">'RGAN01'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>内部查询首先在其父查询之前执行，以便可以将内部查询的结果传递给外部查询。执行过程可以参考下图：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/c439da1f5d4e4b00bdfa4316b933d764%7Etplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><h5 id="where"><a class="anchor" href="#where">#</a> WHERE</h5><ul><li><code>WHERE</code> 子句用于过滤记录，即缩小访问数据的范围。</li><li><code>WHERE</code> 后跟一个返回 <code>true</code> 或 <code>false</code> 的条件。</li><li><code>WHERE</code> 可以与 <code>SELECT</code> ， <code>UPDATE</code> 和 <code>DELETE</code> 一起使用。</li><li>可以在 <code>WHERE</code> 子句中使用的操作符。</li></ul><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>=</td><td>等于</td></tr><tr><td>&lt;&gt;</td><td>不等于。注释：在 SQL 的一些版本中，该操作符可被写成！=</td></tr><tr><td>&gt;</td><td>大于</td></tr><tr><td>&lt;</td><td>小于</td></tr><tr><td>&gt;=</td><td>大于等于</td></tr><tr><td>&lt;=</td><td>小于等于</td></tr><tr><td>BETWEEN</td><td>在某个范围内</td></tr><tr><td>LIKE</td><td>搜索某种模式</td></tr><tr><td>IN</td><td>指定针对某个列的多个可能值</td></tr></tbody></table><p><strong><code>SELECT</code> 语句中的 <code>WHERE</code> 子句</strong></p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> Customers</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">WHERE</span> cust_name <span class="token operator">=</span> <span class="token string">'Kids Place'</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p><strong><code>UPDATE</code> 语句中的 <code>WHERE</code> 子句</strong></p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">UPDATE</span> Customers</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">SET</span> cust_name <span class="token operator">=</span> <span class="token string">'Jack Jones'</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">WHERE</span> cust_name <span class="token operator">=</span> <span class="token string">'Kids Place'</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p><strong><code>DELETE</code> 语句中的 <code>WHERE</code> 子句</strong></p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">DELETE</span> <span class="token keyword">FROM</span> Customers</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">WHERE</span> cust_name <span class="token operator">=</span> <span class="token string">'Kids Place'</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h5 id="in-和-between"><a class="anchor" href="#in-和-between">#</a> IN 和 BETWEEN</h5><ul><li><code>IN</code> 操作符在 <code>WHERE</code> 子句中使用，作用是<font color="red">在指定的几个特定值中任选一个值</font>。</li><li><code>BETWEEN</code> 操作符在 <code>WHERE</code> 子句中使用，作用是<font color="red">选取介于某个范围内的值</font>。</li></ul><p><strong>IN 示例</strong></p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">SELECT</span> <span class="token operator">*</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">FROM</span> products</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">WHERE</span> vend_id <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token string">'DLL01'</span><span class="token punctuation">,</span> <span class="token string">'BRS01'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p><strong>BETWEEN 示例</strong></p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">SELECT</span> <span class="token operator">*</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">FROM</span> products</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">WHERE</span> prod_price <span class="token operator">BETWEEN</span> <span class="token number">3</span> <span class="token operator">AND</span> <span class="token number">5</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h5 id="and-or-not"><a class="anchor" href="#and-or-not">#</a> AND、OR、NOT</h5><ul><li><code>AND</code> 、 <code>OR</code> 、 <code>NOT</code> 是用于对过滤条件的逻辑处理指令。</li><li><font color="red"><code>AND</code> 优先级高于 <code>OR</code> </font>，为了明确处理顺序，可以使用 <code>()</code> 。</li><li><code>AND</code> 操作符表示左右条件都要满足。</li><li><code>OR</code> 操作符表示左右条件满足任意一个即可。</li><li><code>NOT</code> 操作符用于否定一个条件。</li></ul><p><strong>AND 示例</strong></p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">SELECT</span> prod_id<span class="token punctuation">,</span> prod_name<span class="token punctuation">,</span> prod_price</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">FROM</span> products</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">WHERE</span> vend_id <span class="token operator">=</span> <span class="token string">'DLL01'</span> <span class="token operator">AND</span> prod_price <span class="token operator">&lt;=</span> <span class="token number">4</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p><strong>OR 示例</strong></p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">SELECT</span> prod_id<span class="token punctuation">,</span> prod_name<span class="token punctuation">,</span> prod_price</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">FROM</span> products</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">WHERE</span> vend_id <span class="token operator">=</span> <span class="token string">'DLL01'</span> <span class="token operator">OR</span> vend_id <span class="token operator">=</span> <span class="token string">'BRS01'</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p><strong>NOT 示例</strong></p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">SELECT</span> <span class="token operator">*</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">FROM</span> products</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">WHERE</span> prod_price <span class="token operator">NOT</span> <span class="token operator">BETWEEN</span> <span class="token number">3</span> <span class="token operator">AND</span> <span class="token number">5</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h5 id="like"><a class="anchor" href="#like">#</a> LIKE</h5><ul><li><code>LIKE</code> 操作符在 <code>WHERE</code> 子句中使用，作用是<font color="red">确定字符串是否匹配模式</font>。</li><li>只有字段是文本值时才使用 <code>LIKE</code> 。</li><li><code>LIKE</code> 支持两个通配符匹配选项： <code>%</code> 和 <code>_</code> 。</li><li>不要滥用通配符，通配符位于开头处匹配会非常慢。</li><li><code>%</code> 表示任何字符<font color="red">出现任意次数</font>。</li><li><code>_</code> 表示任何字符<font color="red">出现一次</font>。</li></ul><p><strong>% 示例</strong></p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">SELECT</span> prod_id<span class="token punctuation">,</span> prod_name<span class="token punctuation">,</span> prod_price</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">FROM</span> products</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">WHERE</span> prod_name <span class="token operator">LIKE</span> <span class="token string">'%bean bag%'</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p><strong>_ 示例</strong></p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">SELECT</span> prod_id<span class="token punctuation">,</span> prod_name<span class="token punctuation">,</span> prod_price</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">FROM</span> products</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">WHERE</span> prod_name <span class="token operator">LIKE</span> <span class="token string">'__ inch teddy bear'</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h4 id="连接"><a class="anchor" href="#连接">#</a> 连接</h4><h5 id="简介-2"><a class="anchor" href="#简介-2">#</a> 简介</h5><p><code>JOIN</code> 是 “连接” 的意思，顾名思义，SQL JOIN 子句用于将两个或者多个表联合起来进行查询。</p><p>连接表时<font color="red">需要在每个表中选择一个字段，并对这些字段的值进行比较，值相同的两条记录将合并为一条</font>。<strong>连接表的本质就是将不同表的记录合并起来，形成一张新表。当然，这张新表只是临时的，它仅存在于本次查询期间</strong>。</p><h5 id="语法-2"><a class="anchor" href="#语法-2">#</a> 语法</h5><p>使用 <code>JOIN</code> 连接两个表的基本语法如下：</p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">select</span> table1<span class="token punctuation">.</span>column1<span class="token punctuation">,</span> table2<span class="token punctuation">.</span>column2<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">from</span> table1 <span class="token keyword">join</span> table2</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">on</span> table1<span class="token punctuation">.</span>common_column1 <span class="token operator">=</span> table2<span class="token punctuation">.</span>common_column2<span class="token punctuation">;</span></pre></td></tr></table></figure><p><code>table1.common_column1 = table2.common_column2</code> 是<font color="red">连接条件</font>，只有满足此条件的记录才会合并为一行。您可以使用多个运算符来连接表，例如 =、&gt;、&lt;、&lt;&gt;、&lt;=、&gt;=、!=、 <code>between</code> 、 <code>like</code> 或者 <code>not</code> ，但是最常见的是使用 =。</p><p><font color="red">当两个表中有同名的字段时，为了帮助数据库引擎区分是哪个表的字段，在书写同名字段名时需要加上表名</font>。当然，如果书写的字段名在两个表中是唯一的，也可以不使用以上格式，只写字段名即可。</p><p>另外，<font color="red">如果两张表的关联字段名相同，也可以使用 <code>USING</code> 子句来代替 <code>ON</code> </font>，举个例子：</p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment"># join....on</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">select</span> c<span class="token punctuation">.</span>cust_name<span class="token punctuation">,</span> o<span class="token punctuation">.</span>order_num</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">from</span> Customers c <span class="token keyword">inner</span> <span class="token keyword">join</span> Orders o</pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">on</span> c<span class="token punctuation">.</span>cust_id <span class="token operator">=</span> o<span class="token punctuation">.</span>cust_id</pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">order</span> <span class="token keyword">by</span> c<span class="token punctuation">.</span>cust_name<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token comment"># 如果两张表的关联字段名相同，也可以使用 USING 子句：join....using ()</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token keyword">select</span> c<span class="token punctuation">.</span>cust_name<span class="token punctuation">,</span> o<span class="token punctuation">.</span>order_num</pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">from</span> Customers c <span class="token keyword">inner</span> <span class="token keyword">join</span> Orders o</pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token keyword">using</span><span class="token punctuation">(</span>cust_id<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token keyword">order</span> <span class="token keyword">by</span> c<span class="token punctuation">.</span>cust_name<span class="token punctuation">;</span></pre></td></tr></table></figure><p><strong><code>ON</code> 和 <code>WHERE</code> 的区别</strong>：</p><ul><li>连接表时，SQL 会根据连接条件生成一张新的临时表。<font color="red"> <code>ON</code> 是连接条件</font>，它决定临时表的生成。</li><li><code>WHERE</code> 是在临时表生成以后，再对临时表中的数据进行过滤，生成最终的结果集，这个时候已经没有 JOIN-ON 了。</li></ul><p>所以总结来说就是：<strong><font color="#B32015">SQL 先根据 ON 生成一张临时表，然后再根据 WHERE 对临时表进行筛选</font></strong>。</p><h5 id="分类-2"><a class="anchor" href="#分类-2">#</a> 分类</h5><p>SQL 允许在 <code>JOIN</code> 左边加上一些修饰性的关键词，从而形成不同类型的连接，如下表所示：</p><table><thead><tr><th>连接类型</th><th>说明</th></tr></thead><tbody><tr><td><code>(INNER) JOIN</code> ：内连接</td><td>（<strong>默认连接方式</strong>）只有当<font color="red">两个表都存在满足条件</font>的记录时才会返回行。</td></tr><tr><td><code>LEFT (OUTER) JOIN</code> ：左 (外) 连接</td><td>以左表为基础，将左表中的所有记录与右表进行连接。即使右表中没有与左表匹配的记录，左连接仍然会 **<font color="red">返回左表中的所有记录，而右表中未匹配的对应列值则为 NULL</font>**.</td></tr><tr><td><code>RIGHT (OUTER) JOIN</code> ：右 (外) 连接</td><td>以右表为基础，将右表中的所有记录与左表进行连接。即使左表中没有与右表匹配的记录，右连接仍然会 **<font color="red">返回右表中的所有记录，而左表中未匹配的对应列值则为 NULL</font>**。</td></tr><tr><td><code>FULL (OUTER) JOIN</code> ：全 (外) 连接</td><td>只要<font color="red">其中有一个表存在满足条件</font>的记录，就返回行。</td></tr><tr><td><code>SELF JOIN</code> ：自连接</td><td><font color="red">将一个表连接到自身</font>，就像该表是两个表一样。为了区分两个表，在 SQL 语句中需要至少重命名一个表。</td></tr><tr><td><code>CROSS JOIN</code> ：交叉连接</td><td>从两个或者多个连接表中返回记录集的<font color="red">笛卡尔积</font>。</td></tr></tbody></table><p>下图展示了 LEFT JOIN、RIGHT JOIN、INNER JOIN、OUTER JOIN 相关的 7 种用法。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/701670942f0f45d3a3a2187cd04a12ad~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p>对于 <code>(INNER) JOIN</code> 来说，还有一种隐式的写法，称为 “<strong>隐式内连接</strong>”，也就是没有 <code>(INNER) JOIN</code> 关键字，使用 <code>WHERE</code> 语句实现内连接的功能</p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment"># 隐式内连接</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">select</span> c<span class="token punctuation">.</span>cust_name<span class="token punctuation">,</span> o<span class="token punctuation">.</span>order_num</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">from</span> Customers c<span class="token punctuation">,</span> Orders o</pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">where</span> c<span class="token punctuation">.</span>cust_id <span class="token operator">=</span> o<span class="token punctuation">.</span>cust_id</pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">order</span> <span class="token keyword">by</span> c<span class="token punctuation">.</span>cust_name<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token comment"># 显式内连接</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token keyword">select</span> c<span class="token punctuation">.</span>cust_name<span class="token punctuation">,</span> o<span class="token punctuation">.</span>order_num</pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">from</span> Customers c <span class="token keyword">inner</span> <span class="token keyword">join</span> Orders o</pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token keyword">using</span><span class="token punctuation">(</span>cust_id<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token keyword">order</span> <span class="token keyword">by</span> c<span class="token punctuation">.</span>cust_name<span class="token punctuation">;</span></pre></td></tr></table></figure><h4 id="组合"><a class="anchor" href="#组合">#</a> 组合</h4><p><code>UNION</code> 运算符<font color="red">将两个或更多查询的结果组合起来，并生成一个结果集</font>，其中包含来自 <code>UNION</code> 中参与查询的提取行。</p><p><code>UNION</code> 基本规则：</p><ul><li>所有查询的<font color="red">列数和列顺序必须相同</font>。</li><li>每个查询中涉及表的<font color="red">列的数据类型必须相同或兼容</font>。</li><li>通常<font color="red">返回的列名取自第一个查询</font>。</li></ul><p>默认地， <code>UNION</code> 操作符选取不同的值。如果允许重复的值，请使用 <code>UNION ALL</code> 。</p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">SELECT</span> column_name<span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token keyword">FROM</span> table1</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">UNION</span> <span class="token keyword">ALL</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">SELECT</span> column_name<span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token keyword">FROM</span> table2<span class="token punctuation">;</span></pre></td></tr></table></figure><p><code>UNION</code> 结果集中的列名总是等于 <code>UNION</code> 中第一个 <code>SELECT</code> 语句中的列名。</p><p><code>JOIN</code> vs <code>UNION</code> ：</p><ul><li><code>JOIN</code> 中连接表的列可能不同，但在 <code>UNION</code> 中，所有查询的列数和列顺序必须相同。</li><li><code>UNION</code> 将查询之后的行放在一起（<font color="red">垂直放置</font>），但 <code>JOIN</code> 将查询之后的列放在一起（水平放置），即它构成一个笛卡尔积。</li></ul><h4 id="函数"><a class="anchor" href="#函数">#</a> 函数</h4><p>不同数据库的函数往往各不相同，因此不可移植。本节主要<font color="red">以 MysSQL 的函数为例</font>。</p><h5 id="文本处理"><a class="anchor" href="#文本处理">#</a> 文本处理</h5><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td><code>LEFT()</code> 、 <code>RIGHT()</code></td><td>左边或者右边的字符</td></tr><tr><td><code>LOWER()</code> 、 <code>UPPER()</code></td><td>转换为小写或者大写</td></tr><tr><td><code>LTRIM()</code> 、 <code>RTRIM()</code></td><td>去除左边或者右边的空格</td></tr><tr><td><code>LENGTH()</code></td><td>长度</td></tr><tr><td><code>SOUNDEX()</code></td><td><font color="red">转换为语音值</font></td></tr></tbody></table><p>其中， <strong><code>SOUNDEX()</code> </strong>可以将一个字符串转换为描述其语音表示的字母数字模式。</p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">SELECT</span> <span class="token operator">*</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">FROM</span> mytable</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">WHERE</span> SOUNDEX<span class="token punctuation">(</span>col1<span class="token punctuation">)</span> <span class="token operator">=</span> SOUNDEX<span class="token punctuation">(</span><span class="token string">'apple'</span><span class="token punctuation">)</span></pre></td></tr></table></figure><h5 id="日期和时间处理"><a class="anchor" href="#日期和时间处理">#</a> 日期和时间处理</h5><ul><li>日期格式： <code>YYYY-MM-DD</code></li><li>时间格式： <code>HH:MM:SS</code></li></ul><table><thead><tr><th>函 数</th><th>说 明</th></tr></thead><tbody><tr><td><code>AddDate()</code></td><td>增加一个日期（天、周等）</td></tr><tr><td><code>AddTime()</code></td><td>增加一个时间（时、分等）</td></tr><tr><td><code>CurDate()</code></td><td>返回当前日期</td></tr><tr><td><code>CurTime()</code></td><td>返回当前时间</td></tr><tr><td><code>Date()</code></td><td>返回日期时间的日期部分</td></tr><tr><td><code>DateDiff()</code></td><td>计算两个日期之差</td></tr><tr><td><code>Date_Add()</code></td><td>高度灵活的日期运算函数</td></tr><tr><td><code>Date_Format()</code></td><td>返回一个格式化的日期或时间串</td></tr><tr><td><code>Day()</code></td><td>返回一个日期的天数部分</td></tr><tr><td><code>DayOfWeek()</code></td><td>对于一个日期，返回对应的星期几</td></tr><tr><td><code>Hour()</code></td><td>返回一个时间的小时部分</td></tr><tr><td><code>Minute()</code></td><td>返回一个时间的分钟部分</td></tr><tr><td><code>Month()</code></td><td>返回一个日期的月份部分</td></tr><tr><td><code>Now()</code></td><td>返回当前日期和时间</td></tr><tr><td><code>Second()</code></td><td>返回一个时间的秒部分</td></tr><tr><td><code>Time()</code></td><td>返回一个日期时间的时间部分</td></tr><tr><td><code>Year()</code></td><td>返回一个日期的年份部分</td></tr></tbody></table><h5 id="数值处理"><a class="anchor" href="#数值处理">#</a> 数值处理</h5><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>SIN()</td><td>正弦</td></tr><tr><td>COS()</td><td>余弦</td></tr><tr><td>TAN()</td><td>正切</td></tr><tr><td>ABS()</td><td>绝对值</td></tr><tr><td>SQRT()</td><td>平方根</td></tr><tr><td>MOD()</td><td>余数</td></tr><tr><td>EXP()</td><td>指数</td></tr><tr><td>PI()</td><td>圆周率</td></tr><tr><td>RAND()</td><td>随机数</td></tr></tbody></table><h5 id="汇总"><a class="anchor" href="#汇总">#</a> 汇总</h5><table><thead><tr><th>函 数</th><th>说 明</th></tr></thead><tbody><tr><td><code>AVG()</code></td><td>返回某列的平均值</td></tr><tr><td><code>COUNT()</code></td><td>返回某列的行数</td></tr><tr><td><code>MAX()</code></td><td>返回某列的最大值</td></tr><tr><td><code>MIN()</code></td><td>返回某列的最小值</td></tr><tr><td><code>SUM()</code></td><td>返回某列值之和</td></tr></tbody></table><p><code>AVG()</code> 会忽略 NULL 行。</p><p>使用 <code>DISTINCT</code> 可以让汇总函数值汇总不同的值。</p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">SELECT</span> <span class="token function">AVG</span><span class="token punctuation">(</span><span class="token keyword">DISTINCT</span> col1<span class="token punctuation">)</span> <span class="token keyword">AS</span> avg_col</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">FROM</span> mytable</pre></td></tr></table></figure><p><strong>接下来，我们来介绍 DDL 语句用法。DDL 的主要功能是定义数据库对象（如：数据库、数据表、视图、索引等）</strong></p><h4 id="数据定义"><a class="anchor" href="#数据定义">#</a> <mark>数据定义</mark></h4><h5 id="数据库database"><a class="anchor" href="#数据库database">#</a> 数据库（DATABASE）</h5><h6 id="创建数据库"><a class="anchor" href="#创建数据库">#</a> 创建数据库</h6><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">CREATE</span> <span class="token keyword">DATABASE</span> test<span class="token punctuation">;</span></pre></td></tr></table></figure><h6 id="删除数据库"><a class="anchor" href="#删除数据库">#</a> 删除数据库</h6><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">DROP</span> <span class="token keyword">DATABASE</span> test<span class="token punctuation">;</span></pre></td></tr></table></figure><h6 id="选择数据库"><a class="anchor" href="#选择数据库">#</a> 选择数据库</h6><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">USE</span> test<span class="token punctuation">;</span></pre></td></tr></table></figure><h5 id="数据表table"><a class="anchor" href="#数据表table">#</a> 数据表（TABLE）</h5><h6 id="创建数据表"><a class="anchor" href="#创建数据表">#</a> 创建数据表</h6><p><strong>普通创建</strong></p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token keyword">user</span> <span class="token punctuation">(</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  id <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token keyword">unsigned</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'Id'</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  username <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">64</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token string">'default'</span> <span class="token keyword">COMMENT</span> <span class="token string">'用户名'</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="4"></td><td><pre>  password <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">64</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token string">'default'</span> <span class="token keyword">COMMENT</span> <span class="token string">'密码'</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="5"></td><td><pre>  email <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">64</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token string">'default'</span> <span class="token keyword">COMMENT</span> <span class="token string">'邮箱'</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">)</span> <span class="token keyword">COMMENT</span><span class="token operator">=</span><span class="token string">'用户表'</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p><strong>根据已有的表创建新表</strong></p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> vip_user <span class="token keyword">AS</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> <span class="token keyword">user</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h6 id="删除数据表"><a class="anchor" href="#删除数据表">#</a> 删除数据表</h6><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">DROP</span> <span class="token keyword">TABLE</span> <span class="token keyword">user</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h6 id="修改数据表"><a class="anchor" href="#修改数据表">#</a> 修改数据表</h6><p><strong>添加列</strong></p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> <span class="token keyword">user</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">ADD</span> age <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p><strong>删除列</strong></p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> <span class="token keyword">user</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">DROP</span> <span class="token keyword">COLUMN</span> age<span class="token punctuation">;</span></pre></td></tr></table></figure><p><strong>修改列</strong></p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> <span class="token identifier"><span class="token punctuation">`</span>user<span class="token punctuation">`</span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">MODIFY</span> <span class="token keyword">COLUMN</span> age <span class="token keyword">tinyint</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p><strong>添加主键</strong></p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> <span class="token keyword">user</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">ADD</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p><strong>删除主键</strong></p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> <span class="token keyword">user</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">DROP</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h5 id="视图view"><a class="anchor" href="#视图view">#</a> 视图（VIEW）</h5><p>定义：</p><ul><li>视图是基于 SQL 语句的结果集的可视化的表。</li><li>视图是<strong>虚拟的表，本身不包含数据</strong>，也就不能对其进行索引操作。对视图的操作和对普通表的操作一样。</li></ul><p>作用：</p><ul><li>简化复杂的 SQL 操作，比如复杂的联结；</li><li>只使用实际表的一部分数据；</li><li><font color="red">通过只给用户访问视图的权限，保证数据的安全性</font>；</li><li>更改数据格式和表示。</li></ul><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/ec4c975296ea4a7097879dac7c353878%7Etplv-k3u1fbpfcp-zoom-1.image" alt="mysql视图"></p><h6 id="创建视图"><a class="anchor" href="#创建视图">#</a> 创建视图</h6><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">CREATE</span> <span class="token keyword">VIEW</span> top_10_user_view <span class="token keyword">AS</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">SELECT</span> id<span class="token punctuation">,</span> username</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">FROM</span> <span class="token keyword">user</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">WHERE</span> id <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h6 id="删除视图"><a class="anchor" href="#删除视图">#</a> 删除视图</h6><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">DROP</span> <span class="token keyword">VIEW</span> top_10_user_view<span class="token punctuation">;</span></pre></td></tr></table></figure><h5 id="索引index"><a class="anchor" href="#索引index">#</a> 索引（INDEX）</h5><p><strong>索引是一种用于快速查询和检索数据的数据结构，其本质可以看成是一种排序好的数据结构。</strong></p><p>索引的作用就<font color="red">相当于书的目录</font>。打个比方：我们在查字典的时候，如果没有目录，那我们就只能一页一页的去找我们需要查的那个字，速度很慢。如果有目录了，我们只需要先去目录里查找字的位置，然后直接翻到那一页就行了。</p><p><strong>优点</strong> ：</p><ul><li>使用索引可以大大<font color="red">加快数据的检索速度</font>（大大减少检索的数据量）, 这也是创建索引的最主要的原因。</li><li>通过创建<font color="red">唯一性索引，可以保证数据库表中每一行数据的唯一性</font>。</li></ul><p><strong>缺点</strong> ：</p><ul><li>创建索引和维护索引需要耗费许多时间。当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低 SQL 执行效率。</li><li>索引需要使用物理文件存储，也会耗费一定空间。</li></ul><p>但是，<strong>使用索引一定能提高查询性能吗？</strong></p><p>大多数情况下，索引查询都是比全表扫描要快的。但是<font color="red">如果数据库的数据量不大，那么使用索引也不一定能够带来很大提升</font>。</p><p>关于索引的详细介绍，请看我写的 <span class="exturl" data-url="aHR0cHM6Ly9qYXZhZ3VpZGUuY24vZGF0YWJhc2UvbXlzcWwvbXlzcWwtaW5kZXguaHRtbA==">MySQL 索引详解 open in new window</span> 这篇文章。</p><h6 id="创建索引"><a class="anchor" href="#创建索引">#</a> 创建索引</h6><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">CREATE</span> <span class="token keyword">INDEX</span> user_index</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">ON</span> <span class="token keyword">user</span> <span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h6 id="添加索引"><a class="anchor" href="#添加索引">#</a> 添加索引</h6><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">ALTER</span> <span class="token keyword">table</span> <span class="token keyword">user</span> <span class="token keyword">ADD</span> <span class="token keyword">INDEX</span> user_index<span class="token punctuation">(</span>id<span class="token punctuation">)</span></pre></td></tr></table></figure><h6 id="创建唯一索引"><a class="anchor" href="#创建唯一索引">#</a> 创建唯一索引</h6><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">CREATE</span> <span class="token keyword">UNIQUE</span> <span class="token keyword">INDEX</span> user_index</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">ON</span> <span class="token keyword">user</span> <span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h6 id="删除索引"><a class="anchor" href="#删除索引">#</a> 删除索引</h6><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> <span class="token keyword">user</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">DROP</span> <span class="token keyword">INDEX</span> user_index<span class="token punctuation">;</span></pre></td></tr></table></figure><h5 id="约束"><a class="anchor" href="#约束">#</a> 约束</h5><p>SQL 约束<strong>用于规定表中的数据规则</strong>。</p><p>如果存在违反约束的数据行为，行为会被约束终止。</p><p>约束可以在创建表时规定（通过 CREATE TABLE 语句），或者在表创建之后规定（通过 ALTER TABLE 语句）。</p><p>约束类型：</p><ul><li><code>NOT NULL</code> - 指示某列不能存储 NULL 值。</li><li><code>UNIQUE</code> - 保证某列的每行必须有唯一的值。</li><li><code>PRIMARY KEY</code> - NOT NULL 和 UNIQUE 的结合。确保某列（或两个列多个列的结合）有唯一标识，有助于更容易更快速地找到表中的一个特定的记录。</li><li><code>FOREIGN KEY</code> - 保证一个表中的数据匹配另一个表中的值的参照完整性。</li><li><code>CHECK</code> - 保证列中的值符合指定的条件。</li><li><code>DEFAULT</code> - 规定没有给列赋值时的默认值。</li></ul><p>创建表时使用约束条件：</p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> Users <span class="token punctuation">(</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  Id <span class="token keyword">INT</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token keyword">UNSIGNED</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span> <span class="token keyword">COMMENT</span> <span class="token string">'自增Id'</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  Username <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">64</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">UNIQUE</span> <span class="token keyword">DEFAULT</span> <span class="token string">'default'</span> <span class="token keyword">COMMENT</span> <span class="token string">'用户名'</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="4"></td><td><pre>  Password <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">64</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token string">'default'</span> <span class="token keyword">COMMENT</span> <span class="token string">'密码'</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="5"></td><td><pre>  Email <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">64</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token string">'default'</span> <span class="token keyword">COMMENT</span> <span class="token string">'邮箱地址'</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="6"></td><td><pre>  Enabled <span class="token keyword">TINYINT</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'是否有效'</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="7"></td><td><pre>  <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span>Id<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token operator">=</span><span class="token number">2</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8mb4 <span class="token keyword">COMMENT</span><span class="token operator">=</span><span class="token string">'用户表'</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p><strong>接下来，我们来介绍 TCL 语句用法。TCL 的主要功能是管理数据库中的事务。</strong></p><h4 id="事务处理"><a class="anchor" href="#事务处理">#</a> 事务处理</h4><p>不能回退 <code>SELECT</code> 语句，回退 <code>SELECT</code> 语句也没意义；也不能回退 <code>CREATE</code> 和 <code>DROP</code> 语句。</p><p><strong>MySQL 默认是隐式提交</strong>，每执行一条语句就把这条语句当成一个事务然后进行提交。当出现 <code>START TRANSACTION</code> 语句时，会关闭隐式提交；当 <code>COMMIT</code> 或 <code>ROLLBACK</code> 语句执行后，事务会自动关闭，重新恢复隐式提交。</p><p>通过 <code>set autocommit=0</code> 可以取消自动提交，直到 <code>set autocommit=1</code> 才会提交；<font color="red"> <code>autocommit</code> 标记是针对每个连接而不是针对服务器的</font>。</p><p>指令：</p><ul><li><code>START TRANSACTION</code> - 指令用于<font color="red">标记事务的起始点</font>。</li><li><code>SAVEPOINT</code> - 指令用于<font color="red">创建保留点</font>。</li><li><code>ROLLBACK TO</code> - 指令用于<font color="red">回滚到指定的保留点</font>；如果没有设置保留点，则回退到 <code>START TRANSACTION</code> 语句处。</li><li><code>COMMIT</code> - <font color="red">提交事务</font>。</li></ul><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">-- 开始事务</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">START</span> <span class="token keyword">TRANSACTION</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment">-- 插入操作 A</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>user<span class="token punctuation">`</span></span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'root1'</span><span class="token punctuation">,</span> <span class="token string">'root1'</span><span class="token punctuation">,</span> <span class="token string">'xxxx@163.com'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token comment">-- 创建保留点 updateA</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">SAVEPOINT</span> updateA<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token comment">-- 插入操作 B</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>user<span class="token punctuation">`</span></span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">'root2'</span><span class="token punctuation">,</span> <span class="token string">'root2'</span><span class="token punctuation">,</span> <span class="token string">'xxxx@163.com'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token comment">-- 回滚到保留点 updateA</span></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token keyword">ROLLBACK</span> <span class="token keyword">TO</span> updateA<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token comment">-- 提交事务，只有操作 A 生效</span></pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token keyword">COMMIT</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p><strong>接下来，我们来介绍 DCL 语句用法。DCL 的主要功能是控制用户的访问权限。</strong></p><h4 id="权限控制"><a class="anchor" href="#权限控制">#</a> 权限控制</h4><p>要授予用户帐户权限，可以用 <code>GRANT</code> 命令。有撤销用户的权限，可以用 <code>REVOKE</code> 命令。这里以 MySQl 为例，介绍权限控制实际应用。</p><p><code>GRANT</code> 授予权限语法：</p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">GRANT</span> privilege<span class="token punctuation">,</span><span class="token punctuation">[</span>privilege<span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">ON</span> privilege_level</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">TO</span> <span class="token keyword">user</span> <span class="token punctuation">[</span>IDENTIFIED <span class="token keyword">BY</span> password<span class="token punctuation">]</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">[</span><span class="token keyword">REQUIRE</span> tsl_option<span class="token punctuation">]</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">[</span><span class="token keyword">WITH</span> <span class="token punctuation">[</span>GRANT_OPTION <span class="token operator">|</span> resource_option<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>简单解释一下：</p><ol><li>在 <code>GRANT</code> 关键字后指定一个或多个权限。如果授予用户多个权限，则每个权限由逗号分隔。</li><li><code>ON privilege_level</code> 确定权限应用级别。MySQL 支持 global（ <code>*.*</code> ），database（ <code>database.*</code> ），table（ <code>database.table</code> ）和列级别。如果使用列权限级别，则必须在每个权限之后指定一个或逗号分隔列的列表。</li><li><code>user</code> 是要授予权限的用户。如果用户已存在，则 <code>GRANT</code> 语句将修改其权限。否则， <code>GRANT</code> 语句将创建一个新用户。可选子句 <code>IDENTIFIED BY</code> 允许您为用户设置新的密码。</li><li><code>REQUIRE tsl_option</code> 指定用户是否必须通过 SSL，X059 等安全连接连接到数据库服务器。</li><li>可选 <code>WITH GRANT OPTION</code> 子句允许您授予其他用户或从其他用户中删除您拥有的权限。此外，您可以使用 <code>WITH</code> 子句分配 MySQL 数据库服务器的资源，例如，设置用户每小时可以使用的连接数或语句数。这在 MySQL 共享托管等共享环境中非常有用。</li></ol><p><code>REVOKE</code> 撤销权限语法：</p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">REVOKE</span>   privilege_type <span class="token punctuation">[</span><span class="token punctuation">(</span>column_list<span class="token punctuation">)</span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="2"></td><td><pre>        <span class="token punctuation">[</span><span class="token punctuation">,</span> priv_type <span class="token punctuation">[</span><span class="token punctuation">(</span>column_list<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">ON</span> <span class="token punctuation">[</span>object_type<span class="token punctuation">]</span> privilege_level</pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">FROM</span> <span class="token keyword">user</span> <span class="token punctuation">[</span><span class="token punctuation">,</span> <span class="token keyword">user</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr></table></figure><p>简单解释一下：</p><ol><li>在 <code>REVOKE</code> 关键字后面指定要从用户撤消的权限列表。您需要用逗号分隔权限。</li><li>指定在 <code>ON</code> 子句中撤销特权的特权级别。</li><li>指定要撤消 <code>FROM</code> 子句中的权限的用户帐户。</li></ol><p><code>GRANT</code> 和 <code>REVOKE</code> 可在几个层次上控制访问权限：</p><ul><li>整个服务器，使用 <code>GRANT ALL</code> 和 <code>REVOKE ALL</code> ；</li><li>整个数据库，使用 <code>ON database.*</code> ；</li><li>特定的表，使用 <code>ON database.table</code> ；</li><li>特定的列；</li><li>特定的存储过程。</li></ul><p>新创建的账户没有任何权限。账户用 <code>username@host</code> 的形式定义， <code>username@%</code> 使用的是默认主机名。MySQL 的账户信息保存在 mysql 这个数据库中。</p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">USE</span> mysql<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">SELECT</span> <span class="token keyword">user</span> <span class="token keyword">FROM</span> <span class="token keyword">user</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>下表说明了可用于 <code>GRANT</code> 和 <code>REVOKE</code> 语句的所有允许权限：</p><table><thead><tr><th><strong>特权</strong></th><th><strong>说明</strong></th><th><strong>级别</strong></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td><strong>全局</strong></td><td>数据库</td><td><strong>表</strong></td><td><strong>列</strong></td><td><strong>程序</strong></td><td><strong>代理</strong></td><td></td><td></td></tr><tr><td>ALL [PRIVILEGES]</td><td>授予除 GRANT OPTION 之外的指定访问级别的所有权限</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>ALTER</td><td>允许用户使用 ALTER TABLE 语句</td><td>X</td><td>X</td><td>X</td><td></td><td></td><td></td></tr><tr><td>ALTER ROUTINE</td><td>允许用户更改或删除存储的例程</td><td>X</td><td>X</td><td></td><td></td><td>X</td><td></td></tr><tr><td>CREATE</td><td>允许用户创建数据库和表</td><td>X</td><td>X</td><td>X</td><td></td><td></td><td></td></tr><tr><td>CREATE ROUTINE</td><td>允许用户创建存储的例程</td><td>X</td><td>X</td><td></td><td></td><td></td><td></td></tr><tr><td>CREATE TABLESPACE</td><td>允许用户创建，更改或删除表空间和日志文件组</td><td>X</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>CREATE TEMPORARY TABLES</td><td>允许用户使用 CREATE TEMPORARY TABLE 创建临时表</td><td>X</td><td>X</td><td></td><td></td><td></td><td></td></tr><tr><td>CREATE USER</td><td>允许用户使用 CREATE USER，DROP USER，RENAME USER 和 REVOKE ALL PRIVILEGES 语句。</td><td>X</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>CREATE VIEW</td><td>允许用户创建或修改视图。</td><td>X</td><td>X</td><td>X</td><td></td><td></td><td></td></tr><tr><td>DELETE</td><td>允许用户使用 DELETE</td><td>X</td><td>X</td><td>X</td><td></td><td></td><td></td></tr><tr><td>DROP</td><td>允许用户删除数据库，表和视图</td><td>X</td><td>X</td><td>X</td><td></td><td></td><td></td></tr><tr><td>EVENT</td><td>启用事件计划程序的事件使用。</td><td>X</td><td>X</td><td></td><td></td><td></td><td></td></tr><tr><td>EXECUTE</td><td>允许用户执行存储的例程</td><td>X</td><td>X</td><td>X</td><td></td><td></td><td></td></tr><tr><td>FILE</td><td>允许用户读取数据库目录中的任何文件。</td><td>X</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>GRANT OPTION</td><td>允许用户拥有授予或撤消其他帐户权限的权限。</td><td>X</td><td>X</td><td>X</td><td></td><td>X</td><td>X</td></tr><tr><td>INDEX</td><td>允许用户创建或删除索引。</td><td>X</td><td>X</td><td>X</td><td></td><td></td><td></td></tr><tr><td>INSERT</td><td>允许用户使用 INSERT 语句</td><td>X</td><td>X</td><td>X</td><td>X</td><td></td><td></td></tr><tr><td>LOCK TABLES</td><td>允许用户对具有 SELECT 权限的表使用 LOCK TABLES</td><td>X</td><td>X</td><td></td><td></td><td></td><td></td></tr><tr><td>PROCESS</td><td>允许用户使用 SHOW PROCESSLIST 语句查看所有进程。</td><td>X</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>PROXY</td><td>启用用户代理。</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>REFERENCES</td><td>允许用户创建外键</td><td>X</td><td>X</td><td>X</td><td>X</td><td></td><td></td></tr><tr><td>RELOAD</td><td>允许用户使用 FLUSH 操作</td><td>X</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>REPLICATION CLIENT</td><td>允许用户查询以查看主服务器或从属服务器的位置</td><td>X</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>REPLICATION SLAVE</td><td>允许用户使用复制从属从主服务器读取二进制日志事件。</td><td>X</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>SELECT</td><td>允许用户使用 SELECT 语句</td><td>X</td><td>X</td><td>X</td><td>X</td><td></td><td></td></tr><tr><td>SHOW DATABASES</td><td>允许用户显示所有数据库</td><td>X</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>SHOW VIEW</td><td>允许用户使用 SHOW CREATE VIEW 语句</td><td>X</td><td>X</td><td>X</td><td></td><td></td><td></td></tr><tr><td>SHUTDOWN</td><td>允许用户使用 mysqladmin shutdown 命令</td><td>X</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>SUPER</td><td>允许用户使用其他管理操作，例如 CHANGE MASTER TO，KILL，PURGE BINARY LOGS，SET GLOBAL 和 mysqladmin 命令</td><td>X</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>TRIGGER</td><td>允许用户使用 TRIGGER 操作。</td><td>X</td><td>X</td><td>X</td><td></td><td></td><td></td></tr><tr><td>UPDATE</td><td>允许用户使用 UPDATE 语句</td><td>X</td><td>X</td><td>X</td><td>X</td><td></td><td></td></tr><tr><td>USAGE</td><td>相当于 “没有特权”</td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><h5 id="创建账户"><a class="anchor" href="#创建账户">#</a> 创建账户</h5><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">CREATE</span> <span class="token keyword">USER</span> myuser IDENTIFIED <span class="token keyword">BY</span> <span class="token string">'mypassword'</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h5 id="修改账户名"><a class="anchor" href="#修改账户名">#</a> 修改账户名</h5><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">UPDATE</span> <span class="token keyword">user</span> <span class="token keyword">SET</span> <span class="token keyword">user</span><span class="token operator">=</span><span class="token string">'newuser'</span> <span class="token keyword">WHERE</span> <span class="token keyword">user</span><span class="token operator">=</span><span class="token string">'myuser'</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>FLUSH <span class="token keyword">PRIVILEGES</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h5 id="删除账户"><a class="anchor" href="#删除账户">#</a> 删除账户</h5><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">DROP</span> <span class="token keyword">USER</span> myuser<span class="token punctuation">;</span></pre></td></tr></table></figure><h5 id="查看权限"><a class="anchor" href="#查看权限">#</a> 查看权限</h5><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">SHOW</span> GRANTS <span class="token keyword">FOR</span> myuser<span class="token punctuation">;</span></pre></td></tr></table></figure><h5 id="授予权限"><a class="anchor" href="#授予权限">#</a> 授予权限</h5><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">GRANT</span> <span class="token keyword">SELECT</span><span class="token punctuation">,</span> <span class="token keyword">INSERT</span> <span class="token keyword">ON</span> <span class="token operator">*</span><span class="token punctuation">.</span><span class="token operator">*</span> <span class="token keyword">TO</span> myuser<span class="token punctuation">;</span></pre></td></tr></table></figure><h5 id="删除权限"><a class="anchor" href="#删除权限">#</a> 删除权限</h5><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">REVOKE</span> <span class="token keyword">SELECT</span><span class="token punctuation">,</span> <span class="token keyword">INSERT</span> <span class="token keyword">ON</span> <span class="token operator">*</span><span class="token punctuation">.</span><span class="token operator">*</span> <span class="token keyword">FROM</span> myuser<span class="token punctuation">;</span></pre></td></tr></table></figure><h5 id="更改密码"><a class="anchor" href="#更改密码">#</a> 更改密码</h5><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">SET</span> PASSWORD <span class="token keyword">FOR</span> myuser <span class="token operator">=</span> <span class="token string">'mypass'</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h4 id="存储过程-2"><a class="anchor" href="#存储过程-2">#</a> 存储过程</h4><p><img data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/60afdc9c9a594f079727ec64a2e698a3~tplv-k3u1fbpfcp-zoom-1.image" alt="mysql存储过程"></p><p>使用存储过程的好处：</p><ul><li>代码封装，保证了一定的安全性；</li><li><font color="red">代码复用</font>；</li><li>由于是<font color="red">预先编译</font>，因此具有很高的性能。</li></ul><p>创建存储过程：</p><ul><li>命令行中创建存储过程需要自定义分隔符，因为命令行是以 <code>;</code> 为结束符，而存储过程中也包含了分号，因此会错误把这部分分号当成是结束符，造成语法错误。</li><li>包含 <code>in</code> 、 <code>out</code> 和 <code>inout</code> 三种参数。</li><li>给变量赋值都需要用 <code>select into</code> 语句。</li><li>每次只能给一个变量赋值，不支持集合的操作。</li></ul><p>需要注意的是：<strong>阿里巴巴《Java 开发手册》强制禁止使用存储过程。因为存储过程难以调试和扩展，更没有移植性。</strong></p><p><img data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/93a5e011ade4450ebfa5d82057532a49~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>至于到底要不要在项目中使用，还是要看项目实际需求，权衡好利弊即可！</p><h5 id="创建存储过程"><a class="anchor" href="#创建存储过程">#</a> 创建存储过程</h5><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">DROP</span> <span class="token keyword">PROCEDURE</span> <span class="token keyword">IF</span> <span class="token keyword">EXISTS</span> <span class="token identifier"><span class="token punctuation">`</span>proc_adder<span class="token punctuation">`</span></span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">DELIMITER</span> <span class="token punctuation">;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">CREATE</span> <span class="token keyword">DEFINER</span><span class="token operator">=</span><span class="token identifier"><span class="token punctuation">`</span>root<span class="token punctuation">`</span></span><span class="token variable">@`localhost`</span> <span class="token keyword">PROCEDURE</span> <span class="token identifier"><span class="token punctuation">`</span>proc_adder<span class="token punctuation">`</span></span><span class="token punctuation">(</span><span class="token operator">IN</span> a <span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token operator">IN</span> b <span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">OUT</span> sum <span class="token keyword">int</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">BEGIN</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">DECLARE</span> c <span class="token keyword">int</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">if</span> a <span class="token operator">is</span> <span class="token boolean">null</span> <span class="token keyword">then</span> <span class="token keyword">set</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">end</span> <span class="token keyword">if</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">if</span> b <span class="token operator">is</span> <span class="token boolean">null</span> <span class="token keyword">then</span> <span class="token keyword">set</span> b <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token keyword">end</span> <span class="token keyword">if</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token keyword">set</span> sum  <span class="token operator">=</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token keyword">END</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token punctuation">;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token keyword">DELIMITER</span> <span class="token punctuation">;</span></pre></td></tr></table></figure><h5 id="使用存储过程"><a class="anchor" href="#使用存储过程">#</a> 使用存储过程</h5><figure class="highlight less"><figcaption data-lang="less"></figcaption><table><tr><td data-num="1"></td><td><pre>set <span class="token variable">@b</span>=5<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>call proc_<span class="token function">adder</span><span class="token punctuation">(</span>2<span class="token punctuation">,</span><span class="token variable">@b</span><span class="token punctuation">,</span><span class="token variable">@s</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>select <span class="token variable">@s</span> as sum<span class="token punctuation">;</span></pre></td></tr></table></figure><h4 id="游标"><a class="anchor" href="#游标">#</a> 游标</h4><p>游标（cursor）是<strong>一个存储在 DBMS 服务器上的数据库查询，它不是一条 <code>SELECT</code> 语句，而是被该语句检索出来的结果集</strong>。</p><p>在存储过程中使用游标可以对一个结果集进行移动遍历。</p><p>游标主要用于交互式应用，其中用户需要滚动屏幕上的数据，并对数据进行浏览或做出更改。</p><p>使用游标的几个明确步骤：</p><ul><li>在使用游标前，必须<font color="red">声明 (定义)</font>它。这个过程实际上没有检索数据， 它只是定义要使用的 <code>SELECT</code> 语句和游标选项。</li><li>一旦声明，就必须<font color="red">打开游标以供使用</font>。这个过程用前面定义的 SELECT 语句把数据实际检索出来。</li><li>对于填有数据的游标，根据需要<font color="red">取出 (检索) 各行</font>。</li><li>在结束游标使用时，必须<font color="red">关闭游标</font>，可能的话，<font color="red">释放游标</font>(有赖于具体的 DBMS)。</li></ul><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">DELIMITER</span> $</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">CREATE</span>  <span class="token keyword">PROCEDURE</span> getTotal<span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">BEGIN</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">DECLARE</span> total <span class="token keyword">INT</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token comment">-- 创建接收游标数据的变量</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">DECLARE</span> sid <span class="token keyword">INT</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">DECLARE</span> sname <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token comment">-- 创建总数变量</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">DECLARE</span> sage <span class="token keyword">INT</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token comment">-- 创建结束标志变量</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token keyword">DECLARE</span> done <span class="token keyword">INT</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token comment">-- 创建游标</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token keyword">DECLARE</span> cur <span class="token keyword">CURSOR</span> <span class="token keyword">FOR</span> <span class="token keyword">SELECT</span> id<span class="token punctuation">,</span>name<span class="token punctuation">,</span>age <span class="token keyword">from</span> cursor_table <span class="token keyword">where</span> age<span class="token operator">></span><span class="token number">30</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token comment">-- 指定游标循环结束时的返回值</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token keyword">DECLARE</span> <span class="token keyword">CONTINUE</span> <span class="token keyword">HANDLER</span> <span class="token keyword">FOR</span> <span class="token operator">NOT</span> FOUND <span class="token keyword">SET</span> done <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token keyword">SET</span> total <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token keyword">OPEN</span> cur<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token keyword">FETCH</span> cur <span class="token keyword">INTO</span> sid<span class="token punctuation">,</span> sname<span class="token punctuation">,</span> sage<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    <span class="token keyword">WHILE</span><span class="token punctuation">(</span><span class="token operator">NOT</span> done<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    <span class="token keyword">DO</span></pre></td></tr><tr><td data-num="21"></td><td><pre>        <span class="token keyword">SET</span> total <span class="token operator">=</span> total <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>        <span class="token keyword">FETCH</span> cur <span class="token keyword">INTO</span> sid<span class="token punctuation">,</span> sname<span class="token punctuation">,</span> sage<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>    <span class="token keyword">END</span> <span class="token keyword">WHILE</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre></pre></td></tr><tr><td data-num="25"></td><td><pre>    <span class="token keyword">CLOSE</span> cur<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>    <span class="token keyword">SELECT</span> total<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre><span class="token keyword">END</span> $</pre></td></tr><tr><td data-num="28"></td><td><pre><span class="token keyword">DELIMITER</span> <span class="token punctuation">;</span></pre></td></tr><tr><td data-num="29"></td><td><pre></pre></td></tr><tr><td data-num="30"></td><td><pre><span class="token comment">-- 调用存储过程</span></pre></td></tr><tr><td data-num="31"></td><td><pre><span class="token keyword">call</span> getTotal<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h4 id="触发器"><a class="anchor" href="#触发器">#</a> 触发器</h4><p>触发器是一种与表操作有关的数据库对象，<font color="red">当触发器所在表上出现指定事件时，将调用该对象</font>，即表的操作事件触发表上的触发器的执行。</p><p>触发器<font color="red">可以用来进行审计跟踪，把修改记录到另外一张表中</font>。</p><p>使用触发器的优点：</p><ul><li>SQL 触发器提供了另一种检查数据完整性的方法。</li><li>SQL 触发器可以捕获数据库层中业务逻辑中的错误。</li><li>SQL 触发器提供了另一种运行计划任务的方法。通过使用 SQL 触发器，您不必等待运行计划任务，因为在对表中的数据进行更改之前或之后会自动调用触发器。</li><li>SQL 触发器对于审计表中数据的更改非常有用。</li></ul><p>使用触发器的缺点：</p><ul><li>SQL 触发器只能提供扩展验证，并且不能替换所有验证。必须在应用程序层中完成一些简单的验证。例如，您可以使用 JavaScript 在客户端验证用户的输入，或者使用服务器端脚本语言（如 JSP，PHP，<span class="exturl" data-url="aHR0cDovL0FTUC5ORVQ=">ASP.NET</span>，Perl）在服务器端验证用户的输入。</li><li>从客户端应用程序调用和执行 SQL 触发器是不可见的，因此很难弄清楚数据库层中发生了什么。</li><li>SQL 触发器可能会增加数据库服务器的开销。</li></ul><p><strong>MySQL 不允许在触发器中使用 CALL 语句 ，也就是不能调用存储过程</strong>。</p><blockquote><p>注意：在 MySQL 中，分号 <code>;</code> 是语句结束的标识符，遇到分号表示该段语句已经结束，MySQL 可以开始执行了。因此，解释器遇到触发器执行动作中的分号后就开始执行，然后会报错，因为没有找到和 BEGIN 匹配的 END。</p><p>这时就会用到 <code>DELIMITER</code> 命令（DELIMITER 是定界符，分隔符的意思）。它是一条命令，不需要语句结束标识，语法为： <code>DELIMITER new_delemiter</code> 。 <code>new_delemiter</code> 可以设为 1 个或多个长度的符号，默认的是分号 <code>;</code> ，我们可以把它修改为其他符号，如 <code>$</code> - <code>DELIMITER $</code> 。在这之后的语句，以分号结束，解释器不会有什么反应，只有遇到了 <code>$</code> ，才认为是语句结束。注意，使用完之后，我们还应该记得把它给修改回来。</p></blockquote><p>在 MySQL 5.7.2 版之前，可以为每个表定义最多六个触发器。</p><ul><li><code>BEFORE INSERT</code> - 在将数据插入表格之前激活。</li><li><code>AFTER INSERT</code> - 将数据插入表格后激活。</li><li><code>BEFORE UPDATE</code> - 在更新表中的数据之前激活。</li><li><code>AFTER UPDATE</code> - 更新表中的数据后激活。</li><li><code>BEFORE DELETE</code> - 在从表中删除数据之前激活。</li><li><code>AFTER DELETE</code> - 从表中删除数据后激活。</li></ul><p>但是，从 MySQL 版本 5.7.2 + 开始，可以为同一触发事件和操作时间定义多个触发器。</p><p><strong><code>NEW</code> 和 <code>OLD</code> </strong>：</p><ul><li>MySQL 中定义了 <code>NEW</code> 和 <code>OLD</code> 关键字，用来<strong>表示触发器的所在表中，触发了触发器的那一行数据</strong>。</li><li>在 <code>INSERT</code> 型触发器中， <code>NEW</code> 用来表示将要（ <code>BEFORE</code> ）或已经（ <code>AFTER</code> ）插入的新数据；</li><li>在 <code>UPDATE</code> 型触发器中， <code>OLD</code> 用来表示将要或已经被修改的原数据， <code>NEW</code> 用来表示将要或已经修改为的新数据；</li><li>在 <code>DELETE</code> 型触发器中， <code>OLD</code> 用来表示将要或已经被删除的原数据；</li><li>使用方法： <code>NEW.columnName</code> （columnName 为相应数据表某一列名）</li></ul><h5 id="创建触发器"><a class="anchor" href="#创建触发器">#</a> 创建触发器</h5><blockquote><p>提示：为了理解触发器的要点，有必要先了解一下创建触发器的指令。</p></blockquote><p><code>CREATE TRIGGER</code> 指令用于创建触发器。</p><p>语法：</p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">CREATE</span> <span class="token keyword">TRIGGER</span> trigger_name</pre></td></tr><tr><td data-num="2"></td><td><pre>trigger_time</pre></td></tr><tr><td data-num="3"></td><td><pre>trigger_event</pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">ON</span> table_name</pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">FOR EACH ROW</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">BEGIN</span></pre></td></tr><tr><td data-num="7"></td><td><pre>  trigger_statements</pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token keyword">END</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>说明：</p><ul><li><code>trigger_name</code> ：触发器名</li><li><code>trigger_time</code> : 触发器的触发时机。取值为 <code>BEFORE</code> 或 <code>AFTER</code> 。</li><li><code>trigger_event</code> : 触发器的监听事件。取值为 <code>INSERT</code> 、 <code>UPDATE</code> 或 <code>DELETE</code> 。</li><li><code>table_name</code> : 触发器的监听目标。指定在哪张表上建立触发器。</li><li><code>FOR EACH ROW</code> : 行级监视，Mysql 固定写法，其他 DBMS 不同。</li><li><code>trigger_statements</code> : 触发器执行动作。是一条或多条 SQL 语句的列表，列表内的每条语句都必须用分号 <code>;</code> 来结尾。</li></ul><p>当触发器的触发条件满足时，将会执行 <code>BEGIN</code> 和 <code>END</code> 之间的触发器执行动作。</p><p>示例：</p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">DELIMITER</span> $</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">CREATE</span> <span class="token keyword">TRIGGER</span> <span class="token identifier"><span class="token punctuation">`</span>trigger_insert_user<span class="token punctuation">`</span></span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">AFTER</span> <span class="token keyword">INSERT</span> <span class="token keyword">ON</span> <span class="token identifier"><span class="token punctuation">`</span>user<span class="token punctuation">`</span></span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">FOR EACH ROW</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">BEGIN</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>user_history<span class="token punctuation">`</span></span><span class="token punctuation">(</span>user_id<span class="token punctuation">,</span> operate_type<span class="token punctuation">,</span> operate_time<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">VALUES</span> <span class="token punctuation">(</span>NEW<span class="token punctuation">.</span>id<span class="token punctuation">,</span> <span class="token string">'add a user'</span><span class="token punctuation">,</span>  <span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token keyword">END</span> $</pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">DELIMITER</span> <span class="token punctuation">;</span></pre></td></tr></table></figure><h5 id="查看触发器"><a class="anchor" href="#查看触发器">#</a> 查看触发器</h5><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">SHOW</span> TRIGGERS<span class="token punctuation">;</span></pre></td></tr></table></figure><h5 id="删除触发器"><a class="anchor" href="#删除触发器">#</a> 删除触发器</h5><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">DROP</span> <span class="token keyword">TRIGGER</span> <span class="token keyword">IF</span> <span class="token keyword">EXISTS</span> trigger_insert_user<span class="token punctuation">;</span></pre></td></tr></table></figure><h3 id="sql优化"><a class="anchor" href="#sql优化">#</a> <mark>🌟SQL 优化</mark></h3><h4 id="慢查询语句优化"><a class="anchor" href="#慢查询语句优化">#</a> <mark>🌟慢查询语句优化</mark></h4><ol><li><font color="red">尽量覆盖索引</font>，避免 select *，减少回表</li><li><font color="red">避免索引失效</font>，例如：联合索引需要满足最左前缀匹配原则、不要使用左模糊匹配、表达式运算、函数计算、隐式类型转换等...</li><li><font color="red">分页查询优化</font>：该方案适用于主键自增的表，可以把 Limit 查询转换成某个位置的查询。select * from tb_sku where id&gt;20000 limit 10;</li><li><font color="red">将字段多的表分解成多个表</font>：有些字段使用频率高，有些低，数据量大时，会由于使用频率低的存在而变慢，可以考虑分开</li><li><font color="red">对于经常联合查询的表，可以考虑建立中间表</font></li><li><font color="red">优化器使用 MRR【Multi-Range Read】</font>：将 ID 或键值读到 buffer 排序，通过<font color="red">把「随机磁盘读」，转化为「顺序磁盘读」，减少磁盘 IO</font>，从而提高了索引查询的性能</li><li><font color="red">读写分离（主库写，从库读）</font></li><li>检查<font color="red">所查字段是否冗余</font></li><li>检查<font color="red">表中数据是否过多</font>，是否应该进行分库分表了</li><li>检查<font color="red">数据库实例所在机器的性能是否太低</font>，是否可以适当增加资源</li></ol><h4 id="插入数据-2"><a class="anchor" href="#插入数据-2">#</a> 插入数据</h4><h5 id="insert"><a class="anchor" href="#insert">#</a> insert</h5><p>如果我们需要一次性往数据库表中插入多条记录，</p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">insert</span> <span class="token keyword">into</span> tb_test <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">'tom'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">insert</span> <span class="token keyword">into</span> tb_test <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token string">'cat'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">insert</span> <span class="token keyword">into</span> tb_test <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token string">'jerry'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr></table></figure><p>可以从以下三个方面进行优化：</p><ol><li><p><font color="red">批量插入</font></p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">Insert</span> <span class="token keyword">into</span> tb_test <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">'Tom'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token string">'Cat'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token string">'Jerry'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure></li><li><p><font color="red">手动控制事务</font>：避免事务的频繁开启与提交</p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">start</span> <span class="token keyword">transaction</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">insert</span> <span class="token keyword">into</span> tb_test <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">'Tom'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token string">'Cat'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token string">'Jerry'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">insert</span> <span class="token keyword">into</span> tb_test <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token string">'Tom'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token string">'Cat'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token string">'Jerry'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">insert</span> <span class="token keyword">into</span> tb_test <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token string">'Tom'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token string">'Cat'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token string">'Jerry'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">commit</span><span class="token punctuation">;</span></pre></td></tr></table></figure></li><li><p><font color="red">主键顺序插入</font>：性能要高于乱序插入</p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre>主键乱序插入 : <span class="token number">8</span> <span class="token number">1</span> <span class="token number">9</span> <span class="token number">21</span> <span class="token number">88</span> <span class="token number">2</span> <span class="token number">4</span> <span class="token number">15</span> <span class="token number">89</span> <span class="token number">5</span> <span class="token number">7</span> <span class="token number">3</span></pre></td></tr><tr><td data-num="2"></td><td><pre>主键顺序插入 : <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span> <span class="token number">5</span> <span class="token number">7</span> <span class="token number">8</span> <span class="token number">9</span> <span class="token number">15</span> <span class="token number">21</span> <span class="token number">88</span> <span class="token number">89</span></pre></td></tr></table></figure></li></ol><h5 id="批量插入"><a class="anchor" href="#批量插入">#</a> 批量插入</h5><p>如果一次性需要插入大批量数据 (比如：几百万的记录)，使用 insert 语句插入性能较低，此时可以使用 MySQL 数据库提供的 <font color="red"><code>load</code> 指令</font>进行插入。</p><blockquote><p>在 load 时，主键顺序插入性能高于乱序插入</p></blockquote><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">-- 客户端连接服务端时，加上参数 -–local-infile</span></pre></td></tr><tr><td data-num="2"></td><td><pre>mysql –<span class="token operator">-</span><span class="token keyword">local</span><span class="token operator">-</span><span class="token keyword">infile</span> <span class="token operator">-</span>u root <span class="token operator">-</span>p</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">-- 设置全局参数 local_infile 为 1，开启从本地加载文件导入数据的开关</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">set</span> <span class="token keyword">global</span> local_infile <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token comment">-- 执行 load 指令将准备好的数据，加载到表结构中</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">load</span> <span class="token keyword">data</span> <span class="token keyword">local</span> <span class="token keyword">infile</span> <span class="token string">'/root/sql1.log'</span> <span class="token keyword">into</span> <span class="token keyword">table</span> tb_user <span class="token keyword">fields</span> <span class="token keyword">terminated</span> <span class="token keyword">by</span> <span class="token string">','</span> <span class="token keyword">lines</span> <span class="token keyword">terminated</span> <span class="token keyword">by</span> <span class="token string">'\n'</span> <span class="token punctuation">;</span></pre></td></tr></table></figure><h4 id="主键优化"><a class="anchor" href="#主键优化">#</a> <mark>🌟主键优化</mark></h4><blockquote><p>想知道为什么主键顺序插入的效率比主键乱序插入的更高，首先得明白主键是如何设计的！</p></blockquote><h5 id="innodb表数据的组织方式"><a class="anchor" href="#innodb表数据的组织方式">#</a> InnoDB 表数据的组织方式</h5><p><font color="red">在 InnoDB 存储引擎中，表数据都是根据<u>主键顺序</u>组织存放的</font>，这种存储方式的表称为<strong>索引组织表 (index organized table IOT)</strong>。</p><p><font color="red">行数据，都是存储在聚集索引的叶子节点上的</font>。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231119103453582.png" alt="image-20231119103453582"></p><p>之前也讲解过 InnoDB 的逻辑结构图：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231119103710336.png" alt="image-20231119103710336"></p><p><font color="red">在 InnoDB 引擎中，row 数据是记录在逻辑结构 page 页中的</font>，而每一个页的大小是固定的，默认 16K。也就意味着，一个页中所存储的行也是有限的，<font color="red">如果插入的 row 数据在该页存储不下，将会存储到下一个页中，页与页之间会通过指针连接</font>。</p><h5 id="页分裂"><a class="anchor" href="#页分裂">#</a> 页分裂</h5><blockquote><p>主键乱序插入时会产生的操作，比较耗费性能！</p></blockquote><p>页可以为空，也可以填充一半，也可以填充 100%。每个页包含了 2-N 行数据 (如果一行数据过大，会行溢出)，<font color="red">页内的行数据根据主键排列</font>。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231119104317288.png" alt="image-20231119104317288"></p><center>按照主键顺序插入</center><p><strong>页分裂</strong>：当行数据是<font color="red">按照主键乱序插入</font>时，<strong><font color="red">由于索引结构的叶子节点需要维护有序</font></strong>，在插入某行数据时，如果<font color="red">当前所有页都满了</font>，会导致<font color="red">某页需要将后一半数据移动到一个新开辟的页中</font>，然后<font color="red">再插入行数据</font>，最后需要<font color="red">重新设置页之间的指针</font>。</p><p>因此，<strong><font color="red">页分裂是一种比较耗费性能的操作，所以尽量按照主键顺序插入！</font></strong></p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231119105153488.png" alt="image-20231119105153488"></p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231119105216568.png" alt="image-20231119105216568"></p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231119105221673.png" alt="image-20231119105221673"></p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231119105227518.png" alt="image-20231119105227518"></p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231119105234837.png" alt="image-20231119105234837"></p><center>按照主键乱序插入</center><h5 id="页合并"><a class="anchor" href="#页合并">#</a> 页合并</h5><p>当删除一条行记录时，并非物理删除，而是将其标记（flaged）为<font color="red">逻辑删除</font>，并且它的空间变得允许被其他行记录声明使用。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231119110526526.png" alt="image-20231119110526526"></p><p><strong><font color="red">当页中删除的记录达到 MERGE_THRESHOLD（默认为页的 50%），InnoDB 会开始寻找最靠近的页看看是否可以将两个页合并，以优化空间使用</font></strong>。</p><blockquote><p>MERGE_THRESHOLD：合并页的阈值，可以自己设置，在创建表或者创建索引时指定。</p></blockquote><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231119110615283.png" alt="image-20231119110615283"></p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231119110628033.png" alt="image-20231119110628033"></p><p>删除数据，并将页合并之后，再次插入新的数据 21，则直接插入 3# 页。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231119110703491.png" alt="image-20231119110703491"></p><h5 id="主键使用原则"><a class="anchor" href="#主键使用原则">#</a> 主键使用原则</h5><ul><li><p><strong>尽量降低主键的长度</strong>：对于一张表，只有一个主键索引，可以有多个二级索引。而二级索引的叶子节点中存放的就是主键，因此<font color="red">如果主键的长度较长，会导致二级索引占用大量磁盘空间，查询时也会耗费较多的磁盘 IO</font>。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231119111458997.png" alt="image-20231119111458997"></p></li><li><p><strong>尽量按照主键顺序插入数据</strong>：能够避免按照主键乱序插入数据时的页分裂操作，提高插入性能！</p></li><li><p><strong>尽量选择使用 AUTO_INCREMENT 自增主键</strong>：不要使用 UUID 做主键，或者其他自然主键，如身份证号。因为它们都是<font color="red">无序</font>的，导致乱序插入，存在页分裂现象。而且它们的<font color="red">长度较长</font>，构建索引需要的空间较大，在查询时会耗费大量的磁盘 IO。</p></li><li><p><strong>尽量避免对主键的修改</strong>：修改主键，还需要修改对应的主键索引、二级索引，代价较大！</p></li></ul><h4 id="order-by-优化"><a class="anchor" href="#order-by-优化">#</a> order by 优化</h4><p>MySQL 有两种排序方式：</p><ul><li><code>Using filesort</code> ：通过表的索引或全表扫描读取满足条件的数据行，然后<font color="red">在 sort buffer（排序缓冲区）中完成排序操作</font>，所有不是通过索引直接返回排序结果的排序都叫 FileSort 排序。</li><li><code>Using index</code> ：<font color="red">通过有序索引顺序扫描直接返回有序数据</font>，<font color="red">不需要额外排序，操作效率高</font>。</li></ul><p>因此在优化排序操作时，<font color="red">尽量优化为 Using index</font>。</p><p>经过测试（黑马 MySQL - 进阶篇），总结一下 order by 优化原则：</p><ul><li><strong>根据排序字段建立合适的索引</strong>：这样才会 Using index 排序</li><li>多字段排序时，也遵循<strong>联合索引的最左前缀匹配法则</strong>；</li><li><strong>尽量使用覆盖索引</strong>：避免 select * ；</li><li>多字段排序，一个升序一个降序，此时需要注意<strong>联合索引在创建时的规则（ASC/DESC）</strong>；</li><li>如果不可避免的出现 filesort，大数据量排序时，可以<strong>适当增大排序缓冲区大小 sort_buffer_size</strong> (默认 256k)，否则会在磁盘空间中排序，效率低！</li></ul><h4 id="group-by-优化"><a class="anchor" href="#group-by-优化">#</a> group by 优化</h4><p>在分组操作中，需要通过以下两点进行优化：</p><ul><li>可以<strong>通过索引来提高效率</strong></li><li>联合索引的使用，也需要<strong>遵循最左前缀法则</strong>的</li></ul><h4 id="limit-优化"><a class="anchor" href="#limit-优化">#</a> limit 优化</h4><p>在数据量比较大时，进行 limit 分页查询存在问题：越往后，分页查询效率越低。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231119121326947.png" alt="image-20231119121326947"></p><p>优化思路：<strong>覆盖索引 + 子查询</strong></p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tb_sku t <span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">select</span> id <span class="token keyword">from</span> tb_sku <span class="token keyword">order</span> <span class="token keyword">by</span> id <span class="token keyword">limit</span> <span class="token number">2000000</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span> a <span class="token keyword">where</span> t<span class="token punctuation">.</span>id <span class="token operator">=</span> a<span class="token punctuation">.</span>id<span class="token punctuation">;</span></pre></td></tr></table></figure><h4 id="count-优化"><a class="anchor" href="#count-优化">#</a> count 优化</h4><p>如果数据量很大，在执行 count 操作时，是非常耗时的。</p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">select</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">from</span> tb_user <span class="token punctuation">;</span></pre></td></tr></table></figure><p>下面对比一下 MyISAM、InnoDB 是如何执行 count 操作的：</p><ul><li><p><font color="cornflowerblue">MyISAM 引擎</font>：<font color="red">把表的总行数存在了磁盘上</font>，因此执行 count (*) 的时候会直接返回这个数，效率很高。但是如果是带条件的 count，MyISAM 也慢。</p></li><li><p><font color="cornflowerblue">InnoDB 引擎</font>：执行 count (*) 的时候，需要<font color="red">把数据一行一行地从引擎里面读出来，然后累积计数</font>。</p><blockquote><p>InnoDB 对 count 的优化思路：<font color="red">自己维护计数</font>（可以借助于 redis 进行，但是如果是带条件的 count 又比较麻烦了）。</p></blockquote></li></ul><p>count () 是一个聚合函数，对于返回的结果集，一行行地判断，如果 count 函数的参数不是 NULL，累计值就加 1，否则不加，最后返回累计值。</p><p>count 用法：count（*）、count（主键）、count（字段）、count（数字）</p><blockquote><p>按照效率排序的话，count (字段) &lt; count (主键 id) &lt; count (1) ≈ count (*)，所以<strong>尽量使用 count (*)</strong></p></blockquote><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231119131552752.png" alt="image-20231119131552752"></p><h4 id="update-优化"><a class="anchor" href="#update-优化">#</a> update 优化</h4><p>执行 Update 语句时，条件一定要根据索引字段进行更新，否则会出现行锁升级为表锁，导致并发性能降低！</p><p>InnoDB 的行锁是针对索引加的锁，不是针对记录加的锁，并且该索引不能失效，否则会从行锁升级为表锁。</p><h4 id="一些优化原则"><a class="anchor" href="#一些优化原则">#</a> 一些优化原则</h4><h5 id="尽量使用覆盖索引避免-select"><a class="anchor" href="#尽量使用覆盖索引避免-select">#</a> 尽量使用覆盖索引，避免 select *</h5><p>** 覆盖索引，即需要查询的字段正好是索引的字段，那么直接根据该索引，就可以查到数据了，而无需回表查询。** 因此，<font color="red">应该尽量使用覆盖索引，减少 <code>select *</code> </font>。</p><h5 id="分页优化"><a class="anchor" href="#分页优化">#</a> 分页优化</h5><h5 id="尽量避免多表做join"><a class="anchor" href="#尽量避免多表做join">#</a> 尽量避免多表做 join</h5><h5 id="建议不要使用外键与级联"><a class="anchor" href="#建议不要使用外键与级联">#</a> 建议不要使用外键与级联</h5><h5 id="选择合适的字段类型"><a class="anchor" href="#选择合适的字段类型">#</a> 选择合适的字段类型</h5><h5 id="尽量用-union-all-代替-union"><a class="anchor" href="#尽量用-union-all-代替-union">#</a> 尽量用 UNION ALL 代替 UNION</h5><h5 id="批量操作"><a class="anchor" href="#批量操作">#</a> 批量操作</h5><h5 id="show-profle-分析-sql-执行性能"><a class="anchor" href="#show-profle-分析-sql-执行性能">#</a> Show Profle 分析 SQL 执行性能</h5><h5 id="正确使用索引"><a class="anchor" href="#正确使用索引">#</a> 正确使用索引</h5><blockquote><p>指路→<a href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8%E5%BB%BA%E8%AE%AE">索引的正确使用建议</a></p></blockquote><h3 id="sql常见面试题"><a class="anchor" href="#sql常见面试题">#</a> SQL 常见面试题</h3></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2023-12-06 20:08:50" itemprop="dateModified" datetime="2023-12-06T20:08:50+08:00">2023-12-06</time> </span><span id="database/mysql/MySQL-JavaGuide/" class="item leancloud_visitors" data-flag-title="MySQL-JavaGuide" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>范特东东东 <i class="ic i-at"><em>@</em></i>水文 & 摄影</li><li class="link"><strong>本文链接：</strong> <a href="http://example.com/database/mysql/MySQL-JavaGuide/" title="MySQL-JavaGuide">http://example.com/database/mysql/MySQL-JavaGuide/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/photography/%E6%97%A5%E8%90%BD%E6%94%B6%E9%9B%86%E8%AE%A1%E5%88%92/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;pic.imgdb.cn&#x2F;item&#x2F;6553a0abc458853aef3aa4f3.jpg" title="日落收集计划"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> 摄影</span><h3>日落收集计划</h3></a></div><div class="item right"><a href="/database/redis/Redis-JavaGuide/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;hjx159&#x2F;picture-bed&#x2F;main&#x2F;img&#x2F;sql-nosql-tushi.png" title="Redis-JavaGuide"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> Redis</span><h3>Redis-JavaGuide</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#mysql"><span class="toc-number">1.</span> <span class="toc-text">MySQL</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">1.1.</span> <span class="toc-text">数据库基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86%E5%91%98"><span class="toc-number">1.1.1.</span> <span class="toc-text">数据库，数据库管理系统，数据库系统，数据库管理员</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%83%E7%BB%84-%E7%A0%81-%E5%80%99%E9%80%89%E7%A0%81-%E4%B8%BB%E7%A0%81-%E5%A4%96%E7%A0%81-%E4%B8%BB%E5%B1%9E%E6%80%A7-%E9%9D%9E%E4%B8%BB%E5%B1%9E%E6%80%A7"><span class="toc-number">1.1.2.</span> <span class="toc-text">元组，码，候选码，主码，外码，主属性，非主属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#er-%E5%9B%BE"><span class="toc-number">1.1.3.</span> <span class="toc-text">ER 图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%89%E5%A4%A7%E8%8C%83%E5%BC%8F"><span class="toc-number">1.1.4.</span> <span class="toc-text">🌟数据库三大范式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8%E5%A4%96%E9%94%AE%E4%B8%8E%E7%BA%A7%E8%81%94"><span class="toc-number">1.1.5.</span> <span class="toc-text">不推荐使用外键与级联</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B"><span class="toc-number">1.1.6.</span> <span class="toc-text">存储过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#drop-delete-%E4%B8%8E-truncate-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.1.7.</span> <span class="toc-text">drop、delete 与 truncate 的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E6%B3%95%E4%B8%8D%E5%90%8C"><span class="toc-number">1.1.7.1.</span> <span class="toc-text">用法不同</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%9E%E4%BA%8E%E4%B8%8D%E5%90%8C%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%AD%E8%A8%80"><span class="toc-number">1.1.7.2.</span> <span class="toc-text">属于不同的数据库语言</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E9%80%9F%E5%BA%A6%E4%B8%8D%E5%90%8C"><span class="toc-number">1.1.7.3.</span> <span class="toc-text">执行速度不同</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E9%80%9A%E5%B8%B8%E5%88%86%E4%B8%BA%E5%93%AA%E5%87%A0%E6%AD%A5"><span class="toc-number">1.1.8.</span> <span class="toc-text">数据库设计通常分为哪几步？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#nosql%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80"><span class="toc-number">1.2.</span> <span class="toc-text">NoSQL（非关系型数据库）基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#nosql-%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.2.1.</span> <span class="toc-text">NoSQL 是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sql%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%92%8C-nosql%E6%95%B0%E6%8D%AE%E5%BA%93-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.2.2.</span> <span class="toc-text">🌟SQL 数据库 和 NoSQL 数据库 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#nosql-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-number">1.2.3.</span> <span class="toc-text">NoSQL 数据库的优势</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#nosql-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%89%E5%93%AA%E4%BA%9B%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.2.4.</span> <span class="toc-text">NoSQL 数据库有哪些类型？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mysql-%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">1.3.</span> <span class="toc-text">MySQL 常见面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#mysql%E5%9F%BA%E7%A1%80"><span class="toc-number">1.3.1.</span> <span class="toc-text">MySQL 基础</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">什么是关系型数据库？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-sql"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">什么是 SQL？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-mysql"><span class="toc-number">1.3.1.3.</span> <span class="toc-text">什么是 MySQL？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mysql-%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E7%82%B9"><span class="toc-number">1.3.1.4.</span> <span class="toc-text">MySQL 有什么优点？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mysql-%E4%B8%AD%E4%B8%BB%E9%94%AE%E5%92%8C-unique-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.3.1.5.</span> <span class="toc-text">MySQL 中主键和 unique 的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mysql%E5%AD%97%E6%AE%B5%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.3.2.</span> <span class="toc-text">MySQL 字段类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E7%B1%BB%E5%9E%8B%E7%9A%84-unsigned-%E5%B1%9E%E6%80%A7%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">整数类型的 UNSIGNED 属性有什么用？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#char-%E5%92%8C-varchar-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">CHAR 和 VARCHAR 的区别是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#varchar100%E5%92%8C-varchar10%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.3.2.3.</span> <span class="toc-text">VARCHAR (100) 和 VARCHAR (10) 的区别是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#decimal-%E5%92%8C-floatdouble-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.3.2.4.</span> <span class="toc-text">DECIMAL 和 FLOAT&#x2F;DOUBLE 的区别是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8-text-%E5%92%8C-blob"><span class="toc-number">1.3.2.5.</span> <span class="toc-text">为什么不推荐使用 TEXT 和 BLOB？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#datetime-%E5%92%8C-timestamp-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.3.2.6.</span> <span class="toc-text">DATETIME 和 TIMESTAMP 的区别是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#null-%E5%92%8C-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.3.2.7.</span> <span class="toc-text">NULL 和 &#39;&#39; 的区别是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#boolean-%E7%B1%BB%E5%9E%8B%E5%A6%82%E4%BD%95%E8%A1%A8%E7%A4%BA"><span class="toc-number">1.3.2.8.</span> <span class="toc-text">Boolean 类型如何表示？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mysql%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84"><span class="toc-number">1.3.3.</span> <span class="toc-text">MySQL 基础架构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-mysql-%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84%E5%88%86%E6%9E%90"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">1、MySQL 基础架构分析</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#11-%E6%9E%B6%E6%9E%84%E6%A6%82%E8%A7%88"><span class="toc-number">1.3.3.1.1.</span> <span class="toc-text">1.1、架构概览</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#12-server-%E5%B1%82%E7%9A%84%E7%BB%84%E4%BB%B6%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.3.3.1.2.</span> <span class="toc-text">1.2、Server 层的组件介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1%E8%BF%9E%E6%8E%A5%E5%99%A8"><span class="toc-number">1.3.3.1.2.1.</span> <span class="toc-text">1）连接器</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98"><span class="toc-number">1.3.3.1.2.2.</span> <span class="toc-text">2）查询缓存</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3%E5%88%86%E6%9E%90%E5%99%A8"><span class="toc-number">1.3.3.1.2.3.</span> <span class="toc-text">3）分析器</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#4%E4%BC%98%E5%8C%96%E5%99%A8"><span class="toc-number">1.3.3.1.2.4.</span> <span class="toc-text">4）优化器</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#5%E6%89%A7%E8%A1%8C%E5%99%A8"><span class="toc-number">1.3.3.1.2.5.</span> <span class="toc-text">5）执行器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-sql-%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90"><span class="toc-number">1.3.3.2.</span> <span class="toc-text">2、SQL 执行过程分析</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#21-dql-%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.3.3.2.1.</span> <span class="toc-text">2.1、DQL 查询语句</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#22-dml-%E6%9B%B4%E6%96%B0%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.3.3.2.2.</span> <span class="toc-text">2.2、DML 更新语句</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%B0%8F%E7%BB%93"><span class="toc-number">1.3.3.3.</span> <span class="toc-text">3、小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mysql%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="toc-number">1.3.4.</span> <span class="toc-text">MySQL 存储引擎</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#mysql-%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-number">1.3.4.1.</span> <span class="toc-text">MySQL 体系结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.3.4.2.</span> <span class="toc-text">存储引擎介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="toc-number">1.3.4.3.</span> <span class="toc-text">常用的存储引擎</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#innodb"><span class="toc-number">1.3.4.3.1.</span> <span class="toc-text">InnoDB</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#myisam"><span class="toc-number">1.3.4.3.2.</span> <span class="toc-text">MyISAM</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#memory"><span class="toc-number">1.3.4.3.3.</span> <span class="toc-text">Memory</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%89%B9%E7%82%B9%E5%AF%B9%E6%AF%94"><span class="toc-number">1.3.4.3.4.</span> <span class="toc-text">特点对比</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E9%80%89%E6%8B%A9"><span class="toc-number">1.3.4.4.</span> <span class="toc-text">存储引擎选择</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">1.3.4.5.</span> <span class="toc-text">面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#mysql-%E6%94%AF%E6%8C%81%E5%93%AA%E4%BA%9B%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E9%BB%98%E8%AE%A4%E4%BD%BF%E7%94%A8%E5%93%AA%E4%B8%AA"><span class="toc-number">1.3.4.5.1.</span> <span class="toc-text">MySQL 支持哪些存储引擎？默认使用哪个？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#mysql-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E6%9E%B6%E6%9E%84%E4%BA%86%E8%A7%A3%E5%90%97"><span class="toc-number">1.3.4.5.2.</span> <span class="toc-text">MySQL 存储引擎架构了解吗？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#myisam-%E5%92%8C-innodb-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">1.3.4.5.3.</span> <span class="toc-text">MyISAM 和 InnoDB 有什么区别？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#myisam-%E5%92%8C-innodb-%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9"><span class="toc-number">1.3.4.5.4.</span> <span class="toc-text">MyISAM 和 InnoDB 如何选择？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#innodb-%E5%BC%95%E6%93%8E"><span class="toc-number">1.3.5.</span> <span class="toc-text">🌟InnoDB 引擎</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">1.3.5.1.</span> <span class="toc-text">逻辑存储结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%B6%E6%9E%84"><span class="toc-number">1.3.5.2.</span> <span class="toc-text">🌟架构</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">1.3.5.2.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84"><span class="toc-number">1.3.5.2.2.</span> <span class="toc-text">内存结构</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#buffer-pool%E7%BC%93%E5%86%B2%E6%B1%A0"><span class="toc-number">1.3.5.2.2.1.</span> <span class="toc-text">Buffer Pool（缓冲池)</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#change-buffer%E6%9B%B4%E6%94%B9%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">1.3.5.2.2.2.</span> <span class="toc-text">Change Buffer（更改缓冲区）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#adaptive-hash-index%E8%87%AA%E9%80%82%E5%BA%94hash%E7%B4%A2%E5%BC%95"><span class="toc-number">1.3.5.2.2.3.</span> <span class="toc-text">Adaptive Hash Index（自适应 hash 索引）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#log-buffer%E6%97%A5%E5%BF%97%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">1.3.5.2.2.4.</span> <span class="toc-text">Log Buffer（日志缓冲区）</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E7%BB%93%E6%9E%84"><span class="toc-number">1.3.5.2.3.</span> <span class="toc-text">磁盘结构</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#system-tablespace%E7%B3%BB%E7%BB%9F%E8%A1%A8%E7%A9%BA%E9%97%B4"><span class="toc-number">1.3.5.2.3.1.</span> <span class="toc-text">System Tablespace (系统表空间)</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#file-per-table-tablespaces%E6%AF%8F%E4%B8%AA%E8%A1%A8%E7%9A%84%E6%96%87%E4%BB%B6%E8%A1%A8%E7%A9%BA%E9%97%B4"><span class="toc-number">1.3.5.2.3.2.</span> <span class="toc-text">File-Per-Table Tablespaces（每个表的文件表空间）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#general-tablespaces%E9%80%9A%E7%94%A8%E8%A1%A8%E7%A9%BA%E9%97%B4"><span class="toc-number">1.3.5.2.3.3.</span> <span class="toc-text">General Tablespaces（通用表空间）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#undo-tablespaces%E6%92%A4%E9%94%80%E8%A1%A8%E7%A9%BA%E9%97%B4"><span class="toc-number">1.3.5.2.3.4.</span> <span class="toc-text">Undo Tablespaces（撤销表空间）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#temporary-tables%E4%B8%B4%E6%97%B6%E8%A1%A8%E7%A9%BA%E9%97%B4"><span class="toc-number">1.3.5.2.3.5.</span> <span class="toc-text">Temporary Tables（临时表空间）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#doublewrite-buffer-files%E5%8F%8C%E5%86%99%E7%BC%93%E5%86%B2%E5%8C%BA%E6%96%87%E4%BB%B6"><span class="toc-number">1.3.5.2.3.6.</span> <span class="toc-text">Doublewrite Buffer Files（双写缓冲区文件）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#redo-log%E9%87%8D%E5%81%9A%E6%97%A5%E5%BF%97"><span class="toc-number">1.3.5.2.3.7.</span> <span class="toc-text">Redo Log（重做日志）</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%8E%E5%8F%B0%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.3.5.2.4.</span> <span class="toc-text">后台线程</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#master-thread%E6%A0%B8%E5%BF%83%E5%90%8E%E5%8F%B0%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.3.5.2.4.1.</span> <span class="toc-text">Master Thread（核心后台线程）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#io-threadio%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.3.5.2.4.2.</span> <span class="toc-text">IO Thread（IO 线程）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#purge-thread%E5%9B%9E%E6%94%B6%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.3.5.2.4.3.</span> <span class="toc-text">Purge Thread（回收线程）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#page-cleaner-thread%E8%84%8F%E9%A1%B5%E5%88%B7%E6%96%B0%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.3.5.2.4.4.</span> <span class="toc-text">Page Cleaner Thread（脏页刷新线程）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E5%8E%9F%E7%90%86"><span class="toc-number">1.3.5.3.</span> <span class="toc-text">🌟事务原理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E5%9F%BA%E7%A1%80"><span class="toc-number">1.3.5.3.1.</span> <span class="toc-text">事务基础</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#redo-log"><span class="toc-number">1.3.5.3.2.</span> <span class="toc-text">redo log</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#undo-log"><span class="toc-number">1.3.5.3.3.</span> <span class="toc-text">undo log</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#innodb-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%BA%8B%E5%8A%A1"><span class="toc-number">1.3.5.3.4.</span> <span class="toc-text">🌟InnoDB 如何实现事务</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9-mvcc-%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">1.3.5.4.</span> <span class="toc-text">🌟对 MVCC 的实现方式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#innodb-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E9%87%87%E7%94%A8-mvcc%E5%BF%AB%E7%85%A7%E8%AF%BB"><span class="toc-number">1.3.5.4.1.</span> <span class="toc-text">🌟InnoDB 为什么要采用 MVCC 快照读 ？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.3.5.4.2.</span> <span class="toc-text">基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%BF%AB%E7%85%A7%E8%AF%BB%E4%B8%80%E8%87%B4%E6%80%A7u%E9%9D%9E%E9%94%81%E5%AE%9A%E8%AF%BBu"><span class="toc-number">1.3.5.4.2.1.</span> <span class="toc-text">快照读（一致性非锁定读）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%BD%93%E5%89%8D%E8%AF%BB%E4%B8%80%E8%87%B4%E6%80%A7u%E9%94%81%E5%AE%9A%E8%AF%BBu"><span class="toc-number">1.3.5.4.2.2.</span> <span class="toc-text">当前读（一致性锁定读）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#mvcc%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6"><span class="toc-number">1.3.5.4.2.3.</span> <span class="toc-text">MVCC（多版本并发控制）</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#innodb-%E5%AF%B9-mvcc-%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">1.3.5.4.3.</span> <span class="toc-text">🌟InnoDB 对 MVCC 的实现方式</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%9A%90%E8%97%8F%E5%AD%97%E6%AE%B5"><span class="toc-number">1.3.5.4.3.1.</span> <span class="toc-text">隐藏字段</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#undo-log-2"><span class="toc-number">1.3.5.4.3.2.</span> <span class="toc-text">undo log</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#read-view"><span class="toc-number">1.3.5.4.3.3.</span> <span class="toc-text">Read View</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%81%E6%80%A7%E7%AE%97%E6%B3%95"><span class="toc-number">1.3.5.4.3.4.</span> <span class="toc-text">数据可见性算法</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#rc-%E5%92%8C-rr-%E4%B8%8B-mvcc-%E7%9A%84%E5%B7%AE%E5%BC%82"><span class="toc-number">1.3.5.4.4.</span> <span class="toc-text">🌟RC 和 RR 下 MVCC 的差异</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#rc-%E4%B8%8B-readview-%E7%9A%84%E7%94%9F%E6%88%90%E6%83%85%E5%86%B5"><span class="toc-number">1.3.5.4.4.1.</span> <span class="toc-text">RC 下 ReadView 的生成情况</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#rr-%E4%B8%8B-readview-%E7%9A%84%E7%94%9F%E6%88%90%E6%83%85%E5%86%B5"><span class="toc-number">1.3.5.4.4.2.</span> <span class="toc-text">RR 下 ReadView 的生成情况</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#mvccnext-key-lock-%E9%98%B2%E6%AD%A2%E5%B9%BB%E8%AF%BB"><span class="toc-number">1.3.5.4.5.</span> <span class="toc-text">🌟MVCC➕Next-key Lock 防止幻读</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mysql%E7%B4%A2%E5%BC%95"><span class="toc-number">1.3.6.</span> <span class="toc-text">🌟MySQL 索引</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86"><span class="toc-number">1.3.6.1.</span> <span class="toc-text">🌟索引原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.3.6.2.</span> <span class="toc-text">索引介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">1.3.6.3.</span> <span class="toc-text">索引的优缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%80%89%E5%9E%8B"><span class="toc-number">1.3.6.4.</span> <span class="toc-text">🌟索引的底层数据结构选型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#hash-%E8%A1%A8"><span class="toc-number">1.3.6.4.1.</span> <span class="toc-text">Hash 表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%A8%E6%96%87%E7%B4%A2%E5%BC%95full-text"><span class="toc-number">1.3.6.4.2.</span> <span class="toc-text">全文索引（Full-text）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91bst"><span class="toc-number">1.3.6.4.3.</span> <span class="toc-text">二叉查找树（BST）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#avl-%E6%A0%91%E8%87%AA%E5%B9%B3%E8%A1%A1%E7%9A%84bst"><span class="toc-number">1.3.6.4.4.</span> <span class="toc-text">AVL 树（自平衡的 BST）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91%E8%87%AA%E5%B9%B3%E8%A1%A1%E7%9A%84bst"><span class="toc-number">1.3.6.4.5.</span> <span class="toc-text">红黑树（自平衡的 BST）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#b%E6%A0%91-b%E6%A0%91"><span class="toc-number">1.3.6.4.6.</span> <span class="toc-text">🌟B 树 &amp; B + 树</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#mysql-%E9%80%89%E6%8B%A9-b-%E6%A0%91%E4%BD%9C%E4%B8%BA%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">1.3.6.4.7.</span> <span class="toc-text">🌟MySQL 选择 B+ 树作为索引结构的原因</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%88%86%E7%B1%BB"><span class="toc-number">1.3.6.5.</span> <span class="toc-text">索引分类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95"><span class="toc-number">1.3.6.5.1.</span> <span class="toc-text">主键索引</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95"><span class="toc-number">1.3.6.5.2.</span> <span class="toc-text">二级索引</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95"><span class="toc-number">1.3.6.5.3.</span> <span class="toc-text">聚集索引</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9D%9E%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95"><span class="toc-number">1.3.6.5.4.</span> <span class="toc-text">非聚集索引</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95%E5%92%8C%E9%9D%9E%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.3.6.5.5.</span> <span class="toc-text">🌟聚集索引和非聚集索引的区别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95"><span class="toc-number">1.3.6.5.6.</span> <span class="toc-text">🌟倒排索引</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95"><span class="toc-number">1.3.6.5.7.</span> <span class="toc-text">🌟覆盖索引</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95"><span class="toc-number">1.3.6.5.8.</span> <span class="toc-text">联合索引</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80%E5%8C%B9%E9%85%8D%E5%8E%9F%E5%88%99"><span class="toc-number">1.3.6.6.</span> <span class="toc-text">🌟最左前缀匹配原则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8"><span class="toc-number">1.3.6.7.</span> <span class="toc-text">索引下推</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88"><span class="toc-number">1.3.6.8.</span> <span class="toc-text">🌟索引失效</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8%E5%BB%BA%E8%AE%AE"><span class="toc-number">1.3.6.9.</span> <span class="toc-text">🌟索引的正确使用建议</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88"><span class="toc-number">1.3.6.9.1.</span> <span class="toc-text">避免索引失效</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%92%88%E5%AF%B9%E6%95%B0%E6%8D%AE%E9%87%8F%E5%A4%A7%E4%B8%94%E6%9F%A5%E8%AF%A2%E9%A2%91%E7%B9%81%E7%9A%84%E8%A1%A8%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95"><span class="toc-number">1.3.6.9.2.</span> <span class="toc-text">针对数据量大，且查询频繁的表建立索引</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%9A%84%E5%AD%97%E6%AE%B5%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95"><span class="toc-number">1.3.6.9.3.</span> <span class="toc-text">选择合适的字段创建索引</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A2%AB%E9%A2%91%E7%B9%81%E6%9B%B4%E6%96%B0%E7%9A%84%E5%AD%97%E6%AE%B5%E5%BA%94%E8%AF%A5%E6%85%8E%E9%87%8D%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95"><span class="toc-number">1.3.6.9.4.</span> <span class="toc-text">被频繁更新的字段应该慎重建立索引</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%99%90%E5%88%B6%E6%AF%8F%E5%BC%A0%E8%A1%A8%E4%B8%8A%E7%9A%84%E7%B4%A2%E5%BC%95%E6%95%B0%E9%87%8F"><span class="toc-number">1.3.6.9.5.</span> <span class="toc-text">限制每张表上的索引数量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B0%BD%E9%87%8F%E8%80%83%E8%99%91%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E8%80%8C%E4%B8%8D%E6%98%AF%E5%8D%95%E5%88%97%E7%B4%A2%E5%BC%95"><span class="toc-number">1.3.6.9.6.</span> <span class="toc-text">尽量考虑联合索引，而不是单列索引</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E9%81%BF%E5%85%8D%E5%86%97%E4%BD%99%E7%B4%A2%E5%BC%95"><span class="toc-number">1.3.6.9.7.</span> <span class="toc-text">注意避免冗余索引</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%92%88%E5%AF%B9%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%AD%97%E6%AE%B5%E4%BD%BF%E7%94%A8%E5%89%8D%E7%BC%80%E7%B4%A2%E5%BC%95%E7%9F%AD%E7%B4%A2%E5%BC%95"><span class="toc-number">1.3.6.9.8.</span> <span class="toc-text">针对字符串类型的字段，使用前缀索引（短索引）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E9%95%BF%E6%9C%9F%E6%9C%AA%E4%BD%BF%E7%94%A8%E7%9A%84%E7%B4%A2%E5%BC%95"><span class="toc-number">1.3.6.9.9.</span> <span class="toc-text">删除长期未使用的索引</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%8D%E8%83%BD%E6%9C%89%E6%95%88%E5%8C%BA%E5%88%86%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%97%E6%AE%B5%E4%B8%8D%E9%80%82%E5%90%88%E5%81%9A%E7%B4%A2%E5%BC%95%E5%88%97"><span class="toc-number">1.3.6.9.10.</span> <span class="toc-text">不能有效区分数据的字段不适合做索引列</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%A9%E7%94%A8-explain-%E5%91%BD%E4%BB%A4%E5%88%86%E6%9E%90-sql-%E6%98%AF%E5%90%A6%E8%B5%B0%E7%B4%A2%E5%BC%95%E6%9F%A5%E8%AF%A2"><span class="toc-number">1.3.6.9.11.</span> <span class="toc-text">利用 EXPLAIN 命令分析 SQL 是否走索引查询</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mysql%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92"><span class="toc-number">1.3.7.</span> <span class="toc-text">MySQL 执行计划</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%84%E4%B8%AA%E5%AD%97%E6%AE%B5"><span class="toc-number">1.3.7.1.</span> <span class="toc-text">各个字段</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#id"><span class="toc-number">1.3.7.1.1.</span> <span class="toc-text">id</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#select_type"><span class="toc-number">1.3.7.1.2.</span> <span class="toc-text">select_type</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#table"><span class="toc-number">1.3.7.1.3.</span> <span class="toc-text">table</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#type%E9%87%8D%E8%A6%81"><span class="toc-number">1.3.7.1.4.</span> <span class="toc-text">type（重要）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#possible_keys"><span class="toc-number">1.3.7.1.5.</span> <span class="toc-text">possible_keys</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#key%E9%87%8D%E8%A6%81"><span class="toc-number">1.3.7.1.6.</span> <span class="toc-text">key（重要）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#key_len"><span class="toc-number">1.3.7.1.7.</span> <span class="toc-text">key_len</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#rows"><span class="toc-number">1.3.7.1.8.</span> <span class="toc-text">rows</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#extra%E9%87%8D%E8%A6%81"><span class="toc-number">1.3.7.1.9.</span> <span class="toc-text">Extra（重要）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#explain%E7%9A%84%E7%BB%93%E6%9E%9C%E6%9C%89%E5%93%AA%E4%BA%9B%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BF%A1%E6%81%AF%E5%8E%BB%E5%91%8A%E8%AF%89%E4%BD%A0%E6%80%8E%E4%B9%88%E4%BC%98%E5%8C%96"><span class="toc-number">1.3.7.2.</span> <span class="toc-text">🌟explain 的结果有哪些？有哪些信息去告诉你怎么优化？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#type-%E5%AD%97%E6%AE%B5"><span class="toc-number">1.3.7.2.1.</span> <span class="toc-text">type 字段</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#extra-%E5%AD%97%E6%AE%B5"><span class="toc-number">1.3.7.2.2.</span> <span class="toc-text">Extra 字段</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mysql%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98"><span class="toc-number">1.3.8.</span> <span class="toc-text">MySQL 查询缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.3.8.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.3.8.2.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mysql%E4%B8%89%E5%A4%A7%E6%97%A5%E5%BF%97"><span class="toc-number">1.3.9.</span> <span class="toc-text">🌟MySQL 三大日志</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">1.3.9.1.</span> <span class="toc-text">🌟简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#redo-log%E9%87%8D%E5%81%9A%E6%97%A5%E5%BF%97-2"><span class="toc-number">1.3.9.2.</span> <span class="toc-text">redo log（重做日志）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%B7%E7%9B%98%E6%97%B6%E6%9C%BA"><span class="toc-number">1.3.9.2.1.</span> <span class="toc-text">刷盘时机</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E7%BB%84"><span class="toc-number">1.3.9.2.2.</span> <span class="toc-text">日志文件组</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">1.3.9.2.3.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#binlog%E5%BD%92%E6%A1%A3%E6%97%A5%E5%BF%97"><span class="toc-number">1.3.9.3.</span> <span class="toc-text">binlog（归档日志）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AE%B0%E5%BD%95%E6%A0%BC%E5%BC%8F"><span class="toc-number">1.3.9.3.1.</span> <span class="toc-text">记录格式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%86%99%E5%85%A5%E6%9C%BA%E5%88%B6"><span class="toc-number">1.3.9.3.2.</span> <span class="toc-text">写入机制</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4"><span class="toc-number">1.3.9.4.</span> <span class="toc-text">🌟两阶段提交</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#undo-log%E5%9B%9E%E6%BB%9A%E6%97%A5%E5%BF%97"><span class="toc-number">1.3.9.5.</span> <span class="toc-text">undo log（回滚日志）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-2"><span class="toc-number">1.3.9.6.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">1.3.9.7.</span> <span class="toc-text">常见面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#mysql-%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E6%97%A5%E5%BF%97%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">1.3.9.7.1.</span> <span class="toc-text">MySQL 中常见的日志有哪些？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8"><span class="toc-number">1.3.9.7.2.</span> <span class="toc-text">慢查询日志有什么用？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#mysql-%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%E4%B8%80%E4%B8%AA%E6%85%A2%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.3.9.7.3.</span> <span class="toc-text">MySQL 如何优化一个慢查询语句？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#binlog-%E4%B8%BB%E8%A6%81%E8%AE%B0%E5%BD%95%E4%BA%86%E4%BB%80%E4%B9%88"><span class="toc-number">1.3.9.7.4.</span> <span class="toc-text">binlog 主要记录了什么？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8Bredo-log%E4%BB%A5%E5%8F%8A%E5%AE%83%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%8C%81%E4%B9%85%E6%80%A7"><span class="toc-number">1.3.9.7.5.</span> <span class="toc-text">介绍一下 redo log，以及它如何保证事务的持久性？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E9%A1%B5%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.3.9.7.6.</span> <span class="toc-text">数据页是什么？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A1%B5%E4%BF%AE%E6%94%B9%E4%B9%8B%E5%90%8E%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%9B%B4%E6%8E%A5%E5%88%B7%E7%9B%98%E5%91%A2"><span class="toc-number">1.3.9.7.7.</span> <span class="toc-text">页修改之后为什么不直接刷盘呢？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#binlog-%E5%92%8C-redolog-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">1.3.9.7.8.</span> <span class="toc-text">binlog 和 redolog 有什么区别？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#undo-log-%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%8E%9F%E5%AD%90%E6%80%A7"><span class="toc-number">1.3.9.7.9.</span> <span class="toc-text">undo log 如何保证事务的原子性？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mysql%E4%BA%8B%E5%8A%A1"><span class="toc-number">1.3.10.</span> <span class="toc-text">🌟MySQL 事务</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1"><span class="toc-number">1.3.10.1.</span> <span class="toc-text">事务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1"><span class="toc-number">1.3.10.2.</span> <span class="toc-text">数据库事务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#acid-%E7%89%B9%E5%BE%81"><span class="toc-number">1.3.10.3.</span> <span class="toc-text">🌟ACID 特征</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E4%B8%AA%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98"><span class="toc-number">1.3.10.4.</span> <span class="toc-text">🌟4 个一致性问题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%84%8F%E8%AF%BBdirty-read"><span class="toc-number">1.3.10.4.1.</span> <span class="toc-text">脏读（Dirty read）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%A2%E5%A4%B1%E4%BF%AE%E6%94%B9lost-to-modify"><span class="toc-number">1.3.10.4.2.</span> <span class="toc-text">丢失修改（Lost to modify）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BBunrepeatable-read"><span class="toc-number">1.3.10.4.3.</span> <span class="toc-text">不可重复读（Unrepeatable read）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B9%BB%E8%AF%BBphantom-read"><span class="toc-number">1.3.10.4.4.</span> <span class="toc-text">幻读（Phantom read）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E5%92%8C%E5%B9%BB%E8%AF%BB%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.3.10.5.</span> <span class="toc-text">不可重复读和幻读的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F%E9%9A%94%E7%A6%BB%E6%80%A7"><span class="toc-number">1.3.10.6.</span> <span class="toc-text">并发事务的控制方式（隔离性）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%94%81"><span class="toc-number">1.3.10.6.1.</span> <span class="toc-text">锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6mvcc"><span class="toc-number">1.3.10.6.2.</span> <span class="toc-text">多版本并发控制（MVCC）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E7%A7%8D%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-number">1.3.10.7.</span> <span class="toc-text">🌟4 种隔离级别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mysql-%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E6%98%AF%E5%9F%BA%E4%BA%8E%E9%94%81%E5%92%8C-mvcc-%E6%9C%BA%E5%88%B6%E5%85%B1%E5%90%8C%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="toc-number">1.3.10.8.</span> <span class="toc-text">MySQL 的隔离级别是基于锁和 MVCC 机制共同实现的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mysqlinnodb%E7%9A%84%E9%BB%98%E8%AE%A4%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E6%98%AF-repeatable-read%E5%8F%AF%E9%87%8D%E8%AF%BB"><span class="toc-number">1.3.10.9.</span> <span class="toc-text">MySQL（InnoDB）的默认隔离级别是 REPEATABLE-READ（可重读）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mysql-%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%B8%8E%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98%E7%9A%84%E6%BC%94%E7%A4%BA"><span class="toc-number">1.3.10.10.</span> <span class="toc-text">MySQL 事务隔离级别与一致性问题的演示</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mysql%E9%94%81"><span class="toc-number">1.3.11.</span> <span class="toc-text">🌟MySQL 锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-2"><span class="toc-number">1.3.11.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E9%94%81"><span class="toc-number">1.3.11.2.</span> <span class="toc-text">全局锁</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-2"><span class="toc-number">1.3.11.2.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95"><span class="toc-number">1.3.11.2.2.</span> <span class="toc-text">语法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%89%B9%E7%82%B9"><span class="toc-number">1.3.11.2.3.</span> <span class="toc-text">特点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%A8%E7%BA%A7%E9%94%81"><span class="toc-number">1.3.11.3.</span> <span class="toc-text">表级锁</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-3"><span class="toc-number">1.3.11.3.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A1%A8%E9%94%81"><span class="toc-number">1.3.11.3.2.</span> <span class="toc-text">表锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%83%E6%95%B0%E6%8D%AE%E9%94%81"><span class="toc-number">1.3.11.3.3.</span> <span class="toc-text">元数据锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%84%8F%E5%90%91%E9%94%81"><span class="toc-number">1.3.11.3.4.</span> <span class="toc-text">意向锁</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-4"><span class="toc-number">1.3.11.3.4.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%86%E7%B1%BB"><span class="toc-number">1.3.11.3.4.2.</span> <span class="toc-text">分类</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%BC%94%E7%A4%BA"><span class="toc-number">1.3.11.3.4.3.</span> <span class="toc-text">演示</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%8C%E7%BA%A7%E9%94%81"><span class="toc-number">1.3.11.4.</span> <span class="toc-text">行级锁</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-5"><span class="toc-number">1.3.11.4.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A1%8C%E9%94%81%E6%BC%94%E7%A4%BA"><span class="toc-number">1.3.11.4.2.</span> <span class="toc-text">行锁演示</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%97%B4%E9%9A%99%E9%94%81%E4%B8%B4%E9%94%AE%E9%94%81%E6%BC%94%E7%A4%BA"><span class="toc-number">1.3.11.4.3.</span> <span class="toc-text">间隙锁 &amp; 临键锁演示</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-3"><span class="toc-number">1.3.11.5.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98-2"><span class="toc-number">1.3.11.6.</span> <span class="toc-text">面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A1%A8%E7%BA%A7%E9%94%81%E5%92%8C%E8%A1%8C%E7%BA%A7%E9%94%81%E4%BA%86%E8%A7%A3%E5%90%97%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">1.3.11.6.1.</span> <span class="toc-text">表级锁和行级锁了解吗？有什么区别？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A1%8C%E7%BA%A7%E9%94%81%E7%9A%84%E4%BD%BF%E7%94%A8%E6%9C%89%E4%BB%80%E4%B9%88%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">1.3.11.6.2.</span> <span class="toc-text">行级锁的使用有什么注意事项？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#innodb-%E6%9C%89%E5%93%AA%E5%87%A0%E7%B1%BB%E8%A1%8C%E7%BA%A7%E9%94%81"><span class="toc-number">1.3.11.6.3.</span> <span class="toc-text">InnoDB 有哪几类行级锁？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E9%94%81%E5%92%8C%E6%8E%92%E4%BB%96%E9%94%81%E5%91%A2"><span class="toc-number">1.3.11.6.4.</span> <span class="toc-text">共享锁和排他锁呢？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%84%8F%E5%90%91%E9%94%81%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8"><span class="toc-number">1.3.11.6.5.</span> <span class="toc-text">意向锁有什么作用？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BF%AB%E7%85%A7%E8%AF%BB%E5%92%8C%E5%BD%93%E5%89%8D%E8%AF%BB%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">1.3.11.6.6.</span> <span class="toc-text">快照读和当前读有什么区别？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-number">1.3.12.</span> <span class="toc-text">MySQL 性能优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%83%BD%E7%94%A8-mysql-%E7%9B%B4%E6%8E%A5%E5%AD%98%E5%82%A8%E6%96%87%E4%BB%B6%E6%AF%94%E5%A6%82%E5%9B%BE%E7%89%87%E5%90%97"><span class="toc-number">1.3.12.1.</span> <span class="toc-text">能用 MySQL 直接存储文件（比如图片）吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mysql-%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8-ip-%E5%9C%B0%E5%9D%80"><span class="toc-number">1.3.12.2.</span> <span class="toc-text">MySQL 如何存储 IP 地址？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84-sql-%E4%BC%98%E5%8C%96%E6%89%8B%E6%AE%B5"><span class="toc-number">1.3.12.3.</span> <span class="toc-text">常见的 SQL 优化手段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%86%E6%9E%90-sql-%E7%9A%84%E6%80%A7%E8%83%BD"><span class="toc-number">1.3.12.4.</span> <span class="toc-text">如何分析 SQL 的性能？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8"><span class="toc-number">1.3.12.5.</span> <span class="toc-text">🌟读写分离、分库分表</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB"><span class="toc-number">1.3.12.5.1.</span> <span class="toc-text">读写分离</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB"><span class="toc-number">1.3.12.5.1.1.</span> <span class="toc-text">什么是读写分离？</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB"><span class="toc-number">1.3.12.5.1.2.</span> <span class="toc-text">如何实现读写分离？</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">1.3.12.5.1.3.</span> <span class="toc-text">🌟主从复制的原理</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E5%BB%B6%E8%BF%9F"><span class="toc-number">1.3.12.5.1.4.</span> <span class="toc-text">如何避免主从同步延迟？</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E5%BB%B6%E8%BF%9F%E7%9A%84%E5%8E%9F%E5%9B%A0%E5%A6%82%E4%BD%95%E5%B0%BD%E9%87%8F%E5%87%8F%E5%B0%91%E5%BB%B6%E8%BF%9F"><span class="toc-number">1.3.12.5.1.5.</span> <span class="toc-text">主从同步延迟的原因？如何尽量减少延迟？</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8"><span class="toc-number">1.3.12.5.2.</span> <span class="toc-text">分库分表</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%86%E5%BA%93"><span class="toc-number">1.3.12.5.2.1.</span> <span class="toc-text">分库</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%86%E8%A1%A8"><span class="toc-number">1.3.12.5.2.2.</span> <span class="toc-text">分表</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E9%9C%80%E8%A6%81%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8"><span class="toc-number">1.3.12.5.2.3.</span> <span class="toc-text">什么情况下需要分库分表？</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E5%88%86%E7%89%87%E7%AE%97%E6%B3%95"><span class="toc-number">1.3.12.5.2.4.</span> <span class="toc-text">常见的分片算法</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E4%BC%9A%E5%B8%A6%E6%9D%A5%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98"><span class="toc-number">1.3.12.5.2.5.</span> <span class="toc-text">分库分表会带来什么问题？</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E6%9C%89%E6%B2%A1%E6%9C%89%E4%BB%80%E4%B9%88%E6%AF%94%E8%BE%83%E6%8E%A8%E8%8D%90%E7%9A%84%E6%96%B9%E6%A1%88"><span class="toc-number">1.3.12.5.2.6.</span> <span class="toc-text">分库分表有没有什么比较推荐的方案？</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E5%90%8E%E6%95%B0%E6%8D%AE%E6%80%8E%E4%B9%88%E8%BF%81%E7%A7%BB%E5%91%A2"><span class="toc-number">1.3.12.5.2.7.</span> <span class="toc-text">分库分表后，数据怎么迁移呢？</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-4"><span class="toc-number">1.3.12.5.3.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mysql-%E9%AB%98%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E8%A7%84%E8%8C%83%E5%BB%BA%E8%AE%AE"><span class="toc-number">1.4.</span> <span class="toc-text">MySQL 高性能优化规范建议</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83"><span class="toc-number">1.4.1.</span> <span class="toc-text">命名规范</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83"><span class="toc-number">1.4.2.</span> <span class="toc-text">基本设计规范</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%80%E6%9C%89%E8%A1%A8%E5%BF%85%E9%A1%BB%E4%BD%BF%E7%94%A8-innodb-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">所有表必须使用 InnoDB 存储引擎</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E8%A1%A8%E7%9A%84%E5%AD%97%E7%AC%A6%E9%9B%86%E7%BB%9F%E4%B8%80%E4%BD%BF%E7%94%A8-utf8"><span class="toc-number">1.4.2.2.</span> <span class="toc-text">数据库和表的字符集统一使用 UTF8</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%80%E6%9C%89%E8%A1%A8%E5%92%8C%E5%AD%97%E6%AE%B5%E9%83%BD%E9%9C%80%E8%A6%81%E6%B7%BB%E5%8A%A0%E6%B3%A8%E9%87%8A"><span class="toc-number">1.4.2.3.</span> <span class="toc-text">所有表和字段都需要添加注释</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%BD%E9%87%8F%E6%8E%A7%E5%88%B6%E5%8D%95%E8%A1%A8%E6%95%B0%E6%8D%AE%E9%87%8F%E7%9A%84%E5%A4%A7%E5%B0%8F%E5%BB%BA%E8%AE%AE%E6%8E%A7%E5%88%B6%E5%9C%A8-500-%E4%B8%87%E4%BB%A5%E5%86%85"><span class="toc-number">1.4.2.4.</span> <span class="toc-text">尽量控制单表数据量的大小，建议控制在 500 万以内</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%A8%E6%85%8E%E4%BD%BF%E7%94%A8-mysql-%E5%88%86%E5%8C%BA%E8%A1%A8"><span class="toc-number">1.4.2.5.</span> <span class="toc-text">谨慎使用 MySQL 分区表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%8F%E5%B8%B8%E4%B8%80%E8%B5%B7%E4%BD%BF%E7%94%A8%E7%9A%84%E5%88%97%E6%94%BE%E5%88%B0%E4%B8%80%E4%B8%AA%E8%A1%A8%E4%B8%AD"><span class="toc-number">1.4.2.6.</span> <span class="toc-text">经常一起使用的列放到一个表中</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A6%81%E6%AD%A2%E5%9C%A8%E8%A1%A8%E4%B8%AD%E5%BB%BA%E7%AB%8B%E9%A2%84%E7%95%99%E5%AD%97%E6%AE%B5"><span class="toc-number">1.4.2.7.</span> <span class="toc-text">禁止在表中建立预留字段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A6%81%E6%AD%A2%E5%9C%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E5%AD%98%E5%82%A8%E6%96%87%E4%BB%B6%E6%AF%94%E5%A6%82%E5%9B%BE%E7%89%87%E8%BF%99%E7%B1%BB%E5%A4%A7%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E6%8D%AE"><span class="toc-number">1.4.2.8.</span> <span class="toc-text">禁止在数据库中存储文件（比如图片）这类大的二进制数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E8%A6%81%E8%A2%AB%E6%95%B0%E6%8D%AE%E5%BA%93%E8%8C%83%E5%BC%8F%E6%89%80%E6%9D%9F%E7%BC%9A"><span class="toc-number">1.4.2.9.</span> <span class="toc-text">不要被数据库范式所束缚</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A6%81%E6%AD%A2%E5%9C%A8%E7%BA%BF%E4%B8%8A%E5%81%9A%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95"><span class="toc-number">1.4.2.10.</span> <span class="toc-text">禁止在线上做数据库压力测试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A6%81%E6%AD%A2%E4%BB%8E%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83-%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83%E7%9B%B4%E6%8E%A5%E8%BF%9E%E6%8E%A5%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">1.4.2.11.</span> <span class="toc-text">禁止从开发环境、测试环境直接连接生产环境数据库</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E6%AE%B5%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83"><span class="toc-number">1.4.3.</span> <span class="toc-text">字段设计规范</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E9%80%89%E6%8B%A9%E7%AC%A6%E5%90%88%E5%AD%98%E5%82%A8%E9%9C%80%E8%A6%81%E7%9A%84%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.4.3.1.</span> <span class="toc-text">优先选择符合存储需要的最小的数据类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8-text-blob-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%9C%80%E5%B8%B8%E8%A7%81%E7%9A%84-text-%E7%B1%BB%E5%9E%8B%E5%8F%AF%E4%BB%A5%E5%AD%98%E5%82%A8-64k-%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="toc-number">1.4.3.2.</span> <span class="toc-text">避免使用 TEXT、BLOB 数据类型，最常见的 TEXT 类型可以存储 64k 的数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8-enum-%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.4.3.3.</span> <span class="toc-text">避免使用 ENUM 类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%BD%E5%8F%AF%E8%83%BD%E6%8A%8A%E6%89%80%E6%9C%89%E5%88%97%E5%AE%9A%E4%B9%89%E4%B8%BA-not-null"><span class="toc-number">1.4.3.4.</span> <span class="toc-text">尽可能把所有列定义为 NOT NULL</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E5%AE%9A%E4%B8%8D%E8%A6%81%E7%94%A8%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%98%E5%82%A8%E6%97%A5%E6%9C%9F"><span class="toc-number">1.4.3.5.</span> <span class="toc-text">一定不要用字符串存储日期</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B4%A2%E5%8A%A1%E7%9B%B8%E5%85%B3%E7%9A%84%E9%87%91%E9%A2%9D%E7%B1%BB%E6%95%B0%E6%8D%AE%E5%BF%85%E9%A1%BB%E4%BD%BF%E7%94%A8-decimal-%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.4.3.6.</span> <span class="toc-text">财务相关的金额类数据必须使用 decimal 类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E8%A1%A8%E4%B8%8D%E8%A6%81%E5%8C%85%E5%90%AB%E8%BF%87%E5%A4%9A%E5%AD%97%E6%AE%B5"><span class="toc-number">1.4.3.7.</span> <span class="toc-text">单表不要包含过多字段</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83"><span class="toc-number">1.4.4.</span> <span class="toc-text">索引设计规范</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%99%90%E5%88%B6%E6%AF%8F%E5%BC%A0%E8%A1%A8%E4%B8%8A%E7%9A%84%E7%B4%A2%E5%BC%95%E6%95%B0%E9%87%8F%E5%BB%BA%E8%AE%AE%E5%8D%95%E5%BC%A0%E8%A1%A8%E7%B4%A2%E5%BC%95%E4%B8%8D%E8%B6%85%E8%BF%87-5-%E4%B8%AA"><span class="toc-number">1.4.4.1.</span> <span class="toc-text">限制每张表上的索引数量，建议单张表索引不超过 5 个</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A6%81%E6%AD%A2%E4%BD%BF%E7%94%A8%E5%85%A8%E6%96%87%E7%B4%A2%E5%BC%95"><span class="toc-number">1.4.4.2.</span> <span class="toc-text">禁止使用全文索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A6%81%E6%AD%A2%E7%BB%99%E8%A1%A8%E4%B8%AD%E7%9A%84%E6%AF%8F%E4%B8%80%E5%88%97%E9%83%BD%E5%BB%BA%E7%AB%8B%E5%8D%95%E7%8B%AC%E7%9A%84%E7%B4%A2%E5%BC%95"><span class="toc-number">1.4.4.3.</span> <span class="toc-text">禁止给表中的每一列都建立单独的索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AF%8F%E4%B8%AA-innodb-%E8%A1%A8%E5%BF%85%E9%A1%BB%E6%9C%89%E4%B8%AA%E4%B8%BB%E9%94%AE"><span class="toc-number">1.4.4.4.</span> <span class="toc-text">每个 InnoDB 表必须有个主键</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%B4%A2%E5%BC%95%E5%88%97%E5%BB%BA%E8%AE%AE"><span class="toc-number">1.4.4.5.</span> <span class="toc-text">常见索引列建议</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E4%B8%AD%E7%9A%84%E5%88%97%E9%A1%BA%E5%BA%8F"><span class="toc-number">1.4.4.6.</span> <span class="toc-text">如何选择联合索引中的列顺序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E5%BB%BA%E7%AB%8B%E5%86%97%E4%BD%99%E7%B4%A2%E5%BC%95-%E9%87%8D%E5%A4%8D%E7%B4%A2%E5%BC%95"><span class="toc-number">1.4.4.7.</span> <span class="toc-text">避免建立冗余索引、重复索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E4%BA%8E%E9%A2%91%E7%B9%81%E7%9A%84%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%85%88%E8%80%83%E8%99%91%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95"><span class="toc-number">1.4.4.8.</span> <span class="toc-text">对于频繁的查询，优先考虑覆盖索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95-set-%E8%A7%84%E8%8C%83"><span class="toc-number">1.4.4.9.</span> <span class="toc-text">索引 SET 规范</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sql-%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83"><span class="toc-number">1.4.5.</span> <span class="toc-text">SQL 开发规范</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%BD%E9%87%8F%E4%B8%8D%E5%9C%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E5%81%9A%E8%BF%90%E7%AE%97%E5%A4%8D%E6%9D%82%E8%BF%90%E7%AE%97%E9%9C%80%E7%A7%BB%E5%88%B0%E4%B8%9A%E5%8A%A1%E5%BA%94%E7%94%A8%E9%87%8C%E5%AE%8C%E6%88%90"><span class="toc-number">1.4.5.1.</span> <span class="toc-text">尽量不在数据库做运算，复杂运算需移到业务应用里完成</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E5%AF%B9%E6%80%A7%E8%83%BD%E5%BD%B1%E5%93%8D%E8%BE%83%E5%A4%A7%E7%9A%84-sql-%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.4.5.2.</span> <span class="toc-text">优化对性能影响较大的 SQL 语句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%85%E5%88%86%E5%88%A9%E7%94%A8%E8%A1%A8%E4%B8%8A%E5%B7%B2%E7%BB%8F%E5%AD%98%E5%9C%A8%E7%9A%84%E7%B4%A2%E5%BC%95"><span class="toc-number">1.4.5.3.</span> <span class="toc-text">充分利用表上已经存在的索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A6%81%E6%AD%A2%E4%BD%BF%E7%94%A8-select-%E6%9F%A5%E8%AF%A2"><span class="toc-number">1.4.5.4.</span> <span class="toc-text">禁止使用 SELECT * 查询</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A6%81%E6%AD%A2%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%90%AB%E5%AD%97%E6%AE%B5%E5%88%97%E8%A1%A8%E7%9A%84-insert-%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.4.5.5.</span> <span class="toc-text">禁止使用不含字段列表的 INSERT 语句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BB%BA%E8%AE%AE%E4%BD%BF%E7%94%A8%E9%A2%84%E7%BC%96%E8%AF%91%E8%AF%AD%E5%8F%A5%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C"><span class="toc-number">1.4.5.6.</span> <span class="toc-text">建议使用预编译语句进行数据库操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.4.5.7.</span> <span class="toc-text">避免数据类型的隐式转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8%E5%AD%90%E6%9F%A5%E8%AF%A2%E5%8F%AF%E4%BB%A5%E6%8A%8A%E5%AD%90%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E4%B8%BA-join-%E6%93%8D%E4%BD%9C"><span class="toc-number">1.4.5.8.</span> <span class="toc-text">避免使用子查询，可以把子查询优化为 join 操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8-join-%E5%85%B3%E8%81%94%E5%A4%AA%E5%A4%9A%E7%9A%84%E8%A1%A8"><span class="toc-number">1.4.5.9.</span> <span class="toc-text">避免使用 JOIN 关联太多的表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%8F%E5%B0%91%E5%90%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%BA%A4%E4%BA%92%E6%AC%A1%E6%95%B0"><span class="toc-number">1.4.5.10.</span> <span class="toc-text">减少同数据库的交互次数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E5%BA%94%E5%90%8C%E4%B8%80%E5%88%97%E8%BF%9B%E8%A1%8C-or-%E5%88%A4%E6%96%AD%E6%97%B6%E4%BD%BF%E7%94%A8-in-%E4%BB%A3%E6%9B%BF-or"><span class="toc-number">1.4.5.11.</span> <span class="toc-text">对应同一列进行 or 判断时，使用 in 代替 or</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A6%81%E6%AD%A2%E4%BD%BF%E7%94%A8-order-by-rand-%E8%BF%9B%E8%A1%8C%E9%9A%8F%E6%9C%BA%E6%8E%92%E5%BA%8F"><span class="toc-number">1.4.5.12.</span> <span class="toc-text">禁止使用 order by rand () 进行随机排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#where-%E4%BB%8E%E5%8F%A5%E4%B8%AD%E7%A6%81%E6%AD%A2%E5%AF%B9%E5%88%97%E8%BF%9B%E8%A1%8C%E5%87%BD%E6%95%B0%E8%BD%AC%E6%8D%A2%E5%92%8C%E8%AE%A1%E7%AE%97"><span class="toc-number">1.4.5.13.</span> <span class="toc-text">WHERE 从句中禁止对列进行函数转换和计算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8%E6%98%8E%E6%98%BE%E4%B8%8D%E4%BC%9A%E6%9C%89%E9%87%8D%E5%A4%8D%E5%80%BC%E6%97%B6%E4%BD%BF%E7%94%A8-union-all-%E8%80%8C%E4%B8%8D%E6%98%AF-union"><span class="toc-number">1.4.5.14.</span> <span class="toc-text">在明显不会有重复值时，使用 UNION ALL 而不是 UNION</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%86%E5%88%86%E5%A4%8D%E6%9D%82%E7%9A%84%E5%A4%A7-sql-%E4%B8%BA%E5%A4%9A%E4%B8%AA%E5%B0%8F-sql"><span class="toc-number">1.4.5.15.</span> <span class="toc-text">拆分复杂的大 SQL 为多个小 SQL</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E8%BF%9E%E6%8E%A5%E4%B8%8D%E5%90%8C%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%90%8C%E7%9A%84%E8%B4%A6%E5%8F%B7%E7%A6%81%E6%AD%A2%E8%B7%A8%E5%BA%93%E6%9F%A5%E8%AF%A2"><span class="toc-number">1.4.5.16.</span> <span class="toc-text">程序连接不同的数据库使用不同的账号，禁止跨库查询</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E8%A1%8C%E4%B8%BA%E8%A7%84%E8%8C%83"><span class="toc-number">1.4.6.</span> <span class="toc-text">操作行为规范</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B6%85-100-%E4%B8%87%E8%A1%8C%E7%9A%84%E6%89%B9%E9%87%8F%E5%86%99-updatedeleteinsert-%E6%93%8D%E4%BD%9C%E8%A6%81%E5%88%86%E6%89%B9%E5%A4%9A%E6%AC%A1%E8%BF%9B%E8%A1%8C%E6%93%8D%E4%BD%9C"><span class="toc-number">1.4.6.1.</span> <span class="toc-text">超 100 万行的批量写 (UPDATE,DELETE,INSERT) 操作，要分批多次进行操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E4%BA%8E%E5%A4%A7%E8%A1%A8%E4%BD%BF%E7%94%A8-pt-online-schema-change-%E4%BF%AE%E6%94%B9%E8%A1%A8%E7%BB%93%E6%9E%84"><span class="toc-number">1.4.6.2.</span> <span class="toc-text">对于大表使用 pt-online-schema-change 修改表结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A6%81%E6%AD%A2%E4%B8%BA%E7%A8%8B%E5%BA%8F%E4%BD%BF%E7%94%A8%E7%9A%84%E8%B4%A6%E5%8F%B7%E8%B5%8B%E4%BA%88-super-%E6%9D%83%E9%99%90"><span class="toc-number">1.4.6.3.</span> <span class="toc-text">禁止为程序使用的账号赋予 super 权限</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E4%BA%8E%E7%A8%8B%E5%BA%8F%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93%E8%B4%A6%E5%8F%B7%E9%81%B5%E5%BE%AA%E6%9D%83%E9%99%90%E6%9C%80%E5%B0%8F%E5%8E%9F%E5%88%99"><span class="toc-number">1.4.6.4.</span> <span class="toc-text">对于程序连接数据库账号，遵循权限最小原则</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sql"><span class="toc-number">1.5.</span> <span class="toc-text">SQL</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#sql%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80"><span class="toc-number">1.5.1.</span> <span class="toc-text">SQL 语法基础</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-2"><span class="toc-number">1.5.1.1.</span> <span class="toc-text">基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%AF%E8%AF%AD"><span class="toc-number">1.5.1.1.1.</span> <span class="toc-text">数据库术语</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#sql-%E8%AF%AD%E6%B3%95"><span class="toc-number">1.5.1.1.2.</span> <span class="toc-text">SQL 语法</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#sql-%E8%AF%AD%E6%B3%95%E7%BB%93%E6%9E%84"><span class="toc-number">1.5.1.1.2.1.</span> <span class="toc-text">SQL 语法结构</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#sql-%E8%AF%AD%E6%B3%95%E8%A6%81%E7%82%B9"><span class="toc-number">1.5.1.1.2.2.</span> <span class="toc-text">SQL 语法要点</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#sql-%E5%88%86%E7%B1%BB"><span class="toc-number">1.5.1.1.3.</span> <span class="toc-text">SQL 分类</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%AE%9A%E4%B9%89%E8%AF%AD%E8%A8%80ddl"><span class="toc-number">1.5.1.1.3.1.</span> <span class="toc-text">数据定义语言（DDL）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%93%8D%E7%BA%B5%E8%AF%AD%E8%A8%80dml"><span class="toc-number">1.5.1.1.3.2.</span> <span class="toc-text">数据操纵语言（DML）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E6%8E%A7%E5%88%B6%E8%AF%AD%E8%A8%80tcl"><span class="toc-number">1.5.1.1.3.3.</span> <span class="toc-text">事务控制语言（TCL）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%8E%A7%E5%88%B6%E8%AF%AD%E8%A8%80dcl"><span class="toc-number">1.5.1.1.3.4.</span> <span class="toc-text">数据控制语言（DCL）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5"><span class="toc-number">1.5.1.2.</span> <span class="toc-text">增删改查</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE"><span class="toc-number">1.5.1.2.1.</span> <span class="toc-text">插入数据</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE"><span class="toc-number">1.5.1.2.2.</span> <span class="toc-text">更新数据</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE"><span class="toc-number">1.5.1.2.3.</span> <span class="toc-text">删除数据</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E6%95%B0%E6%8D%AE"><span class="toc-number">1.5.1.2.4.</span> <span class="toc-text">查询数据</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F"><span class="toc-number">1.5.1.3.</span> <span class="toc-text">排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E7%BB%84"><span class="toc-number">1.5.1.4.</span> <span class="toc-text">分组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%90%E6%9F%A5%E8%AF%A2"><span class="toc-number">1.5.1.5.</span> <span class="toc-text">子查询</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#where"><span class="toc-number">1.5.1.5.1.</span> <span class="toc-text">WHERE</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#in-%E5%92%8C-between"><span class="toc-number">1.5.1.5.2.</span> <span class="toc-text">IN 和 BETWEEN</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#and-or-not"><span class="toc-number">1.5.1.5.3.</span> <span class="toc-text">AND、OR、NOT</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#like"><span class="toc-number">1.5.1.5.4.</span> <span class="toc-text">LIKE</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5"><span class="toc-number">1.5.1.6.</span> <span class="toc-text">连接</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-2"><span class="toc-number">1.5.1.6.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95-2"><span class="toc-number">1.5.1.6.2.</span> <span class="toc-text">语法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%86%E7%B1%BB-2"><span class="toc-number">1.5.1.6.3.</span> <span class="toc-text">分类</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%84%E5%90%88"><span class="toc-number">1.5.1.7.</span> <span class="toc-text">组合</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-number">1.5.1.8.</span> <span class="toc-text">函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86"><span class="toc-number">1.5.1.8.1.</span> <span class="toc-text">文本处理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4%E5%A4%84%E7%90%86"><span class="toc-number">1.5.1.8.2.</span> <span class="toc-text">日期和时间处理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E5%80%BC%E5%A4%84%E7%90%86"><span class="toc-number">1.5.1.8.3.</span> <span class="toc-text">数值处理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B1%87%E6%80%BB"><span class="toc-number">1.5.1.8.4.</span> <span class="toc-text">汇总</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%AE%9A%E4%B9%89"><span class="toc-number">1.5.1.9.</span> <span class="toc-text">数据定义</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93database"><span class="toc-number">1.5.1.9.1.</span> <span class="toc-text">数据库（DATABASE）</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">1.5.1.9.1.1.</span> <span class="toc-text">创建数据库</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">1.5.1.9.1.2.</span> <span class="toc-text">删除数据库</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">1.5.1.9.1.3.</span> <span class="toc-text">选择数据库</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E8%A1%A8table"><span class="toc-number">1.5.1.9.2.</span> <span class="toc-text">数据表（TABLE）</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E8%A1%A8"><span class="toc-number">1.5.1.9.2.1.</span> <span class="toc-text">创建数据表</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE%E8%A1%A8"><span class="toc-number">1.5.1.9.2.2.</span> <span class="toc-text">删除数据表</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E6%95%B0%E6%8D%AE%E8%A1%A8"><span class="toc-number">1.5.1.9.2.3.</span> <span class="toc-text">修改数据表</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%86%E5%9B%BEview"><span class="toc-number">1.5.1.9.3.</span> <span class="toc-text">视图（VIEW）</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E8%A7%86%E5%9B%BE"><span class="toc-number">1.5.1.9.3.1.</span> <span class="toc-text">创建视图</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E8%A7%86%E5%9B%BE"><span class="toc-number">1.5.1.9.3.2.</span> <span class="toc-text">删除视图</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95index"><span class="toc-number">1.5.1.9.4.</span> <span class="toc-text">索引（INDEX）</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95"><span class="toc-number">1.5.1.9.4.1.</span> <span class="toc-text">创建索引</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E7%B4%A2%E5%BC%95"><span class="toc-number">1.5.1.9.4.2.</span> <span class="toc-text">添加索引</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95"><span class="toc-number">1.5.1.9.4.3.</span> <span class="toc-text">创建唯一索引</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E7%B4%A2%E5%BC%95"><span class="toc-number">1.5.1.9.4.4.</span> <span class="toc-text">删除索引</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BA%A6%E6%9D%9F"><span class="toc-number">1.5.1.9.5.</span> <span class="toc-text">约束</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86"><span class="toc-number">1.5.1.10.</span> <span class="toc-text">事务处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6"><span class="toc-number">1.5.1.11.</span> <span class="toc-text">权限控制</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E8%B4%A6%E6%88%B7"><span class="toc-number">1.5.1.11.1.</span> <span class="toc-text">创建账户</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E8%B4%A6%E6%88%B7%E5%90%8D"><span class="toc-number">1.5.1.11.2.</span> <span class="toc-text">修改账户名</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E8%B4%A6%E6%88%B7"><span class="toc-number">1.5.1.11.3.</span> <span class="toc-text">删除账户</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E6%9D%83%E9%99%90"><span class="toc-number">1.5.1.11.4.</span> <span class="toc-text">查看权限</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8E%88%E4%BA%88%E6%9D%83%E9%99%90"><span class="toc-number">1.5.1.11.5.</span> <span class="toc-text">授予权限</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%9D%83%E9%99%90"><span class="toc-number">1.5.1.11.6.</span> <span class="toc-text">删除权限</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9B%B4%E6%94%B9%E5%AF%86%E7%A0%81"><span class="toc-number">1.5.1.11.7.</span> <span class="toc-text">更改密码</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B-2"><span class="toc-number">1.5.1.12.</span> <span class="toc-text">存储过程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B"><span class="toc-number">1.5.1.12.1.</span> <span class="toc-text">创建存储过程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B"><span class="toc-number">1.5.1.12.2.</span> <span class="toc-text">使用存储过程</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B8%B8%E6%A0%87"><span class="toc-number">1.5.1.13.</span> <span class="toc-text">游标</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A6%E5%8F%91%E5%99%A8"><span class="toc-number">1.5.1.14.</span> <span class="toc-text">触发器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E8%A7%A6%E5%8F%91%E5%99%A8"><span class="toc-number">1.5.1.14.1.</span> <span class="toc-text">创建触发器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E8%A7%A6%E5%8F%91%E5%99%A8"><span class="toc-number">1.5.1.14.2.</span> <span class="toc-text">查看触发器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E8%A7%A6%E5%8F%91%E5%99%A8"><span class="toc-number">1.5.1.14.3.</span> <span class="toc-text">删除触发器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sql%E4%BC%98%E5%8C%96"><span class="toc-number">1.5.2.</span> <span class="toc-text">🌟SQL 优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%85%A2%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E4%BC%98%E5%8C%96"><span class="toc-number">1.5.2.1.</span> <span class="toc-text">🌟慢查询语句优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE-2"><span class="toc-number">1.5.2.2.</span> <span class="toc-text">插入数据</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#insert"><span class="toc-number">1.5.2.2.1.</span> <span class="toc-text">insert</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%89%B9%E9%87%8F%E6%8F%92%E5%85%A5"><span class="toc-number">1.5.2.2.2.</span> <span class="toc-text">批量插入</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E9%94%AE%E4%BC%98%E5%8C%96"><span class="toc-number">1.5.2.3.</span> <span class="toc-text">🌟主键优化</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#innodb%E8%A1%A8%E6%95%B0%E6%8D%AE%E7%9A%84%E7%BB%84%E7%BB%87%E6%96%B9%E5%BC%8F"><span class="toc-number">1.5.2.3.1.</span> <span class="toc-text">InnoDB 表数据的组织方式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A1%B5%E5%88%86%E8%A3%82"><span class="toc-number">1.5.2.3.2.</span> <span class="toc-text">页分裂</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A1%B5%E5%90%88%E5%B9%B6"><span class="toc-number">1.5.2.3.3.</span> <span class="toc-text">页合并</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BB%E9%94%AE%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%88%99"><span class="toc-number">1.5.2.3.4.</span> <span class="toc-text">主键使用原则</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#order-by-%E4%BC%98%E5%8C%96"><span class="toc-number">1.5.2.4.</span> <span class="toc-text">order by 优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#group-by-%E4%BC%98%E5%8C%96"><span class="toc-number">1.5.2.5.</span> <span class="toc-text">group by 优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#limit-%E4%BC%98%E5%8C%96"><span class="toc-number">1.5.2.6.</span> <span class="toc-text">limit 优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#count-%E4%BC%98%E5%8C%96"><span class="toc-number">1.5.2.7.</span> <span class="toc-text">count 优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#update-%E4%BC%98%E5%8C%96"><span class="toc-number">1.5.2.8.</span> <span class="toc-text">update 优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E4%BC%98%E5%8C%96%E5%8E%9F%E5%88%99"><span class="toc-number">1.5.2.9.</span> <span class="toc-text">一些优化原则</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B0%BD%E9%87%8F%E4%BD%BF%E7%94%A8%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95%E9%81%BF%E5%85%8D-select"><span class="toc-number">1.5.2.9.1.</span> <span class="toc-text">尽量使用覆盖索引，避免 select *</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%86%E9%A1%B5%E4%BC%98%E5%8C%96"><span class="toc-number">1.5.2.9.2.</span> <span class="toc-text">分页优化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B0%BD%E9%87%8F%E9%81%BF%E5%85%8D%E5%A4%9A%E8%A1%A8%E5%81%9Ajoin"><span class="toc-number">1.5.2.9.3.</span> <span class="toc-text">尽量避免多表做 join</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BB%BA%E8%AE%AE%E4%B8%8D%E8%A6%81%E4%BD%BF%E7%94%A8%E5%A4%96%E9%94%AE%E4%B8%8E%E7%BA%A7%E8%81%94"><span class="toc-number">1.5.2.9.4.</span> <span class="toc-text">建议不要使用外键与级联</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%9A%84%E5%AD%97%E6%AE%B5%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.5.2.9.5.</span> <span class="toc-text">选择合适的字段类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B0%BD%E9%87%8F%E7%94%A8-union-all-%E4%BB%A3%E6%9B%BF-union"><span class="toc-number">1.5.2.9.6.</span> <span class="toc-text">尽量用 UNION ALL 代替 UNION</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%89%B9%E9%87%8F%E6%93%8D%E4%BD%9C"><span class="toc-number">1.5.2.9.7.</span> <span class="toc-text">批量操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#show-profle-%E5%88%86%E6%9E%90-sql-%E6%89%A7%E8%A1%8C%E6%80%A7%E8%83%BD"><span class="toc-number">1.5.2.9.8.</span> <span class="toc-text">Show Profle 分析 SQL 执行性能</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95"><span class="toc-number">1.5.2.9.9.</span> <span class="toc-text">正确使用索引</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sql%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">1.5.3.</span> <span class="toc-text">SQL 常见面试题</span></a></li></ol></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li class="active"><a href="/database/mysql/MySQL-JavaGuide/" rel="bookmark" title="MySQL-JavaGuide">MySQL-JavaGuide</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="范特东东东" data-src="/images/avatar.jpg"><p class="name" itemprop="name">范特东东东</p><div class="description" itemprop="description"></div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">59</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">18</span> <span class="name">分类</span></a></div></nav><div class="social"><span class="exturl item xiaohongshu" data-url="aHR0cHM6Ly93d3cueGlhb2hvbmdzaHUuY29tL3VzZXIvcHJvZmlsZS81ZTAyYzhhZDAwMDAwMDAwMDEwMDFmM2U=" title="https:&#x2F;&#x2F;www.xiaohongshu.com&#x2F;user&#x2F;profile&#x2F;5e02c8ad0000000001001f3e"><i class="ic i-xiaohongshu"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于我</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><span class="exturl" data-url="aHR0cHM6Ly9oangxNTkuZ2l0aHViLmlvL2NhdGVnb3JpZXMvcGhvdG9ncmFwaHkv"><i class="ic i-photography"></i>摄影</span></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/photography/%E6%97%A5%E8%90%BD%E6%94%B6%E9%9B%86%E8%AE%A1%E5%88%92/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/database/redis/Redis-JavaGuide/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/photography/" title="分类于 摄影">摄影</a></div><span><a href="/photography/%E8%88%B9%E5%A4%AB%E8%9C%80%E9%BB%8D/" title="船夫蜀黍">船夫蜀黍</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/java/" title="分类于 Java">Java</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/" title="分类于 Java基础">Java基础</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/java-excise/" title="分类于 Java基础-真题">Java基础-真题</a></div><span><a href="/java/java-se/java-excise/%E7%AC%AC08%E7%AB%A0%EF%BC%9A%E9%9A%8F%E5%A0%82%E5%A4%8D%E4%B9%A0%E4%B8%8E%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%A2%98%EF%BC%88%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E9%AB%98%E7%BA%A7%EF%BC%89/" title="宋红康_第08章：面向对象-高级">宋红康_第08章：面向对象-高级</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/java/" title="分类于 Java">Java</a> <i class="ic i-angle-right"></i> <a href="/categories/java/juc/" title="分类于 JUC">JUC</a></div><span><a href="/java/juc/JUC%E7%AC%94%E8%AE%B0/" title="JUC 笔记">JUC 笔记</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/java/" title="分类于 Java">Java</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/" title="分类于 Java基础">Java基础</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/java-excise/" title="分类于 Java基础-真题">Java基础-真题</a></div><span><a href="/java/java-se/java-excise/%E7%AC%AC04%E7%AB%A0%EF%BC%9A%E9%9A%8F%E5%A0%82%E5%A4%8D%E4%B9%A0%E4%B8%8E%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%A2%98%EF%BC%88IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%89/" title="宋红康_第04章：IDEA安装与使用">宋红康_第04章：IDEA安装与使用</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/docker/" title="分类于 docker">docker</a></div><span><a href="/docker/docker-javaguide/" title="docker-javaguide">docker-javaguide</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/java/" title="分类于 Java">Java</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/" title="分类于 Java基础">Java基础</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/java-knowledge/" title="分类于 Java基础-知识点">Java基础-知识点</a></div><span><a href="/java/java-se/java-knowledge/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E5%AE%8B%E7%BA%A2%E5%BA%B7_%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/" title="宋红康_第01章_Java语言概述">宋红康_第01章_Java语言概述</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/database/" title="分类于 数据库">数据库</a> <i class="ic i-angle-right"></i> <a href="/categories/database/elasticsearch/" title="分类于 Elasticsearch">Elasticsearch</a></div><span><a href="/database/elasticsearch/Elasticsearch-JavaGuide/" title="Elasticsearch-JavaGuide">Elasticsearch-JavaGuide</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/java/" title="分类于 Java">Java</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/" title="分类于 Java基础">Java基础</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/java-knowledge/" title="分类于 Java基础-知识点">Java基础-知识点</a></div><span><a href="/java/java-se/java-knowledge/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E5%AE%8B%E7%BA%A2%E5%BA%B7_%E7%AC%AC09%E7%AB%A0_%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/" title="宋红康_第09章_异常处理">宋红康_第09章_异常处理</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/java/" title="分类于 Java">Java</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/" title="分类于 Java基础">Java基础</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/java-excise/" title="分类于 Java基础-真题">Java基础-真题</a></div><span><a href="/java/java-se/java-excise/%E7%AC%AC18%E7%AB%A0%EF%BC%9A%E9%9A%8F%E5%A0%82%E5%A4%8D%E4%B9%A0%E4%B8%8E%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%A2%98%EF%BC%88JDK8-17%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%89/" title="宋红康_第18章：JDK8-17新特性">宋红康_第18章：JDK8-17新特性</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/java/" title="分类于 Java">Java</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/" title="分类于 Java基础">Java基础</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/java-knowledge/" title="分类于 Java基础-知识点">Java基础-知识点</a></div><span><a href="/java/java-se/java-knowledge/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E5%AE%8B%E7%BA%A2%E5%BA%B7_%E7%AC%AC12%E7%AB%A0_%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/" title="宋红康_第12章_集合框架">宋红康_第12章_集合框架</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">范特东东东 @ fantedong</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">1.8m 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">27:56</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"database/mysql/MySQL-JavaGuide/",favicon:{show:"(●´3｀●)欢迎回来",hide:"(〃＞皿＜)你快回来"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hrmmi -->