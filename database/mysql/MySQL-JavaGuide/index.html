<!-- build time:Fri Nov 17 2023 22:24:07 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="水文 & 摄影" href="http://example.com/rss.xml"><link rel="alternate" type="application/atom+xml" title="水文 & 摄影" href="http://example.com/atom.xml"><link rel="alternate" type="application/json" title="水文 & 摄影" href="http://example.com/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><link rel="canonical" href="http://example.com/database/mysql/MySQL-JavaGuide/"><title>MySQL-JavaGuide - MySQL - 数据库 | fantedong = 水文 & 摄影 = 为了能更好地访问图片，你需要一点魔法</title><meta name="generator" content="Hexo 6.3.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">MySQL-JavaGuide</h1><div class="meta"><span class="item" title="创建时间：2023-11-17 19:50:54"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2023-11-17T19:50:54+08:00">2023-11-17</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>42k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>38 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">fantedong</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><img src="https://oss.javaguide.cn/github/javaguide/csdn/20210327143351823.png"></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/database/" itemprop="item" rel="index" title="分类于 数据库"><span itemprop="name">数据库</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/database/mysql/" itemprop="item" rel="index" title="分类于 MySQL"><span itemprop="name">MySQL</span></a><meta itemprop="position" content="2"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://example.com/database/mysql/MySQL-JavaGuide/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="范特东东东"><meta itemprop="description" content="为了能更好地访问图片，你需要一点魔法, "></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="水文 & 摄影"></span><div class="body md" itemprop="articleBody"><h1 id="mysql"><a class="anchor" href="#mysql">#</a> MySQL</h1><h2 id="mysql常见面试题"><a class="anchor" href="#mysql常见面试题">#</a> MySQL 常见面试题</h2><h3 id="mysql基础"><a class="anchor" href="#mysql基础">#</a> MySQL 基础</h3><h4 id="什么是关系型数据库"><a class="anchor" href="#什么是关系型数据库">#</a> 什么是关系型数据库？</h4><p>顾名思义， <code>关系型数据库（RDBMS，Relational Database Management System）</code> 就是<font color="red">一种建立在<u>关系模型</u>的基础上的数据库</font>。关系模型表明了数据库中所存储的<font color="red">数据之间的联系（一对一、一对多、多对多）</font>。</p><p>关系型数据库中，我们的数据都被存放在了各种表中（比如用户表），表中的每一行就存放着一条数据（比如一个用户的信息）。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/5e3c1a71724a38245aa43b02_99bf70d46cc247be878de9d3a88f0c44.png" alt="关系型数据库表关系"></p><p>大部分关系型数据库都使用 SQL 来操作数据库中的数据。并且，大部分关系型数据库都支持<font color="red">事务的四大特性 (ACID)</font>。</p><p>常见的关系型数据库：MySQL、PostgreSQL、Oracle、SQL Server、SQLite（微信本地的聊天记录的存储就是用的 SQLite） ......。</p><h4 id="什么是-sql"><a class="anchor" href="#什么是-sql">#</a> 什么是 SQL？</h4><p>SQL 是一种 <code>结构化查询语言(Structured Query Language)</code> ，专门用来与数据库打交道，目的是提供一种<font color="red">从数据库中读写数据</font>的简单有效的方法。</p><p>几乎所有的主流关系数据库都支持 SQL ，适用性非常强。并且，一些非关系型数据库也兼容 SQL 或者使用的是类似于 SQL 的查询语言。</p><p>SQL 可以帮助我们：</p><ul><li>新建数据库、数据表、字段；</li><li>在数据库中增加，删除，修改，查询数据；</li><li>新建视图、函数、存储过程；</li><li>对数据库中的数据进行简单的数据分析；</li><li>搭配 Hive，Spark SQL 做大数据；</li><li>搭配 SQLFlow 做机器学习；</li><li>......</li></ul><h4 id="什么是-mysql"><a class="anchor" href="#什么是-mysql">#</a> 什么是 MySQL？</h4><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/20210327143351823.png" alt="img"></p><p><strong>MySQL 是一种关系型数据库，主要用于持久化存储我们的系统中的一些数据比如用户信息。</strong></p><p>由于 MySQL 是开源免费并且比较成熟的数据库，因此，MySQL 被大量使用在各种系统中。任何人都可以在 GPL (General Public License) 的许可下下载并根据个性化的需要对其进行修改。MySQL 的默认端口号是<strong> 3306</strong>。</p><h4 id="mysql-有什么优点"><a class="anchor" href="#mysql-有什么优点">#</a> MySQL 有什么优点？</h4><p>这个问题本质上是在问 MySQL 如此流行的原因。</p><p>MySQL 主要具有下面这些优点：</p><ol><li>成熟稳定，功能完善。</li><li>开源免费。</li><li>文档丰富，既有详细的官方文档，又有非常多优质文章可供参考学习。</li><li>开箱即用，操作简单，维护成本低。</li><li>兼容性好，支持常见的操作系统，支持多种开发语言。</li><li>社区活跃，生态完善。</li><li><strong>事务支持</strong>优秀， InnoDB 存储引擎默认使用 REPEATABLE-READ 并不会有任何性能损失，并且 InnoDB 实现的 REPEATABLE-READ 隔离级别其实是可以解决幻读问题发生的。</li><li>支持<strong>分库分表、读写分离、高可用</strong>。</li></ol><h3 id="mysql字段类型"><a class="anchor" href="#mysql字段类型">#</a> MySQL 字段类型</h3><h4 id="整数类型的-unsigned-属性有什么用"><a class="anchor" href="#整数类型的-unsigned-属性有什么用">#</a> 整数类型的 UNSIGNED 属性有什么用？</h4><p><strong>UNSIGNED 属性来表示不允许负值的无符号整数，因此可以将正整数的上限提高一倍</strong>，因为它不需要存储负数值。</p><p>例如， TINYINT UNSIGNED 类型的取值范围是 0 ~ 255，而普通的 TINYINT 类型的值范围是 -128 ~ 127。INT UNSIGNED 类型的取值范围是 0 ~ 4,294,967,295，而普通的 INT 类型的值范围是 2,147,483,648 ~ 2,147,483,647。</p><p>对于<font color="red">从 0 开始递增的 ID 列</font>，使用 UNSIGNED 属性可以非常适合，因为不允许负值并且可以拥有更大的上限范围，提供了更多的 ID 值可用。</p><h4 id="char-和-varchar-的区别是什么"><a class="anchor" href="#char-和-varchar-的区别是什么">#</a> CHAR 和 VARCHAR 的区别是什么？</h4><p><strong>CHAR 是定长字符串，VARCHAR 是变长字符串。</strong></p><ul><li>CHAR 在存储时会在右边<font color="red">填充空格</font>以达到指定的长度，检索时会<font color="red">去掉空格</font>；VARCHAR 在存储时需要<font color="red">使用 1 或 2 个额外字节记录字符串的长度</font>，检索时不需要处理。</li><li>CHAR 更适合存储<font color="red">长度较短或者长度都差不多</font>的字符串，例如 Bcrypt 算法、MD5 算法加密后的密码、身份证号码。VARCHAR 类型适合存储<font color="red">长度不确定或者差异较大</font>的字符串，例如用户昵称、文章标题等。</li><li>CHAR (M) 和 VARCHAR (M) 的 M 都代表能够保存的字符数的最大值，<font color="red">无论是字母、数字还是中文，每个都只占用一个字符</font>。</li></ul><h4 id="varchar100和-varchar10的区别是什么"><a class="anchor" href="#varchar100和-varchar10的区别是什么">#</a> VARCHAR (100) 和 VARCHAR (10) 的区别是什么？</h4><p>VARCHAR (100) 和 VARCHAR (10) 都是变长类型，表示能存储最多 100 个字符和 10 个字符。因此，<font color="red">VARCHAR (100) 可以满足更大范围的字符存储需求</font>，有更好的业务拓展性。而 VARCHAR (10) 存储超过 10 个字符时，就需要修改表结构才可以。</p><p>虽说 VARCHAR (100) 和 VARCHAR (10) 能存储的字符范围不同，但二者存储相同的字符串，所占用磁盘的存储空间其实是一样的，这也是很多人容易误解的一点。</p><p>不过，<font color="red">VARCHAR (100) 会消耗更多的内存</font>。这是因为 VARCHAR 类型在内存中操作时，<font color="red">通常会分配固定大小的内存块</font>来保存值，即使用字符类型中定义的长度。例如在进行排序的时候，VARCHAR (100) 是按照 100 这个长度来进行的，也就会消耗更多内存。</p><h4 id="decimal-和-floatdouble-的区别是什么"><a class="anchor" href="#decimal-和-floatdouble-的区别是什么">#</a> DECIMAL 和 FLOAT/DOUBLE 的区别是什么？</h4><p><strong>DECIMAL 是定点数，可以存储精确的小数值；FLOAT/DOUBLE 是浮点数，只能存储近似的小数值。</strong></p><p>在 Java 中，MySQL 的 DECIMAL 类型对应的是 Java 类 <code>java.math.BigDecimal</code> 。</p><h4 id="为什么不推荐使用-text-和-blob"><a class="anchor" href="#为什么不推荐使用-text-和-blob">#</a> 为什么不推荐使用 TEXT 和 BLOB？</h4><p>TEXT 类型类似于 CHAR（0-255 字节）和 VARCHAR（0-65,535 字节），但可以存储更长的字符串，即<font color="cornflowerblue">长文本数据</font>，例如博客内容。</p><table><thead><tr><th>类型</th><th>可存储大小</th><th>用途</th></tr></thead><tbody><tr><td>TINYTEXT</td><td>0-255 字节</td><td>一般文本字符串</td></tr><tr><td>TEXT</td><td>0-65,535 字节</td><td>长文本字符串</td></tr><tr><td>MEDIUMTEXT</td><td>0-16,772,150 字节</td><td>较大文本数据</td></tr><tr><td>LONGTEXT</td><td>0-4,294,967,295 字节</td><td>极大文本数据</td></tr></tbody></table><p>BLOB 类型主要用于存储<font color="cornflowerblue">二进制大对象，例如图片、音视频等文件</font>。</p><table><thead><tr><th>类型</th><th>可存储大小</th><th>用途</th></tr></thead><tbody><tr><td>TINYBLOB</td><td>0-255 字节</td><td>短文本二进制字符串</td></tr><tr><td>BLOB</td><td>0-65KB</td><td>二进制字符串</td></tr><tr><td>MEDIUMBLOB</td><td>0-16MB</td><td>二进制形式的长文本数据</td></tr><tr><td>LONGBLOB</td><td>0-4GB</td><td>二进制形式的极大文本数据</td></tr></tbody></table><p>在日常开发中，很少使用 TEXT 类型，但偶尔会用到，而 BLOB 类型则基本不常用。<font color="red">如果预期长度范围可以通过 VARCHAR 来满足，建议避免使用 TEXT</font>。</p><p>数据库规范通常不推荐使用 BLOB 和 TEXT 类型，这两种类型具有一些缺点和限制，例如：</p><ul><li><font color="red">不能有默认值</font></li><li>在使用临时表时<font color="red">无法使用内存临时表，只能在磁盘上创建临时表</font>（《高性能 MySQL》书中有提到）</li><li><font color="red">检索效率较低</font></li><li><font color="red">不能直接创建索引</font>，需要指定前缀长度</li><li><font color="red">会消耗大量的网络和 IO 带宽</font></li><li>可能导致表上的<font color="red"> DML 操作变慢</font></li><li>……</li></ul><h4 id="datetime-和-timestamp-的区别是什么"><a class="anchor" href="#datetime-和-timestamp-的区别是什么">#</a> DATETIME 和 TIMESTAMP 的区别是什么？</h4><p><strong>DATETIME 类型没有时区信息，TIMESTAMP 和时区有关</strong>。</p><p><font color="red">TIMESTAMP 只需要使用 4 个字节的存储空间，但是 DATETIME 需要耗费 8 个字节的存储空间</font>。但是，这样同样造成了一个问题，<font color="red">Timestamp 表示的时间范围更小</font>。</p><ul><li>DATETIME：1000-01-01 00:00:00 ~ 9999-12-31 23:59:59</li><li>Timestamp：1970-01-01 00:00:01 ~ 2037-12-31 23:59:59</li></ul><h4 id="null-和-的区别是什么"><a class="anchor" href="#null-和-的区别是什么">#</a> NULL 和 '' 的区别是什么？</h4><p><code>NULL</code> 跟 <code>''</code> (空字符串) 是两个完全不一样的值，区别如下：</p><ul><li><strong><code>NULL</code> 代表一个不确定的值，但占用空间</strong>。就算是两个 <code>NULL</code> ，它俩也不一定相等。例如， <code>SELECT NULL=NULL</code> 的结果为 false，但是在我们使用 <code>DISTINCT</code> ， <code>GROUP BY</code> ， <code>ORDER BY</code> 时， <code>NULL</code> 又被认为是相等的。</li><li><strong><code>''</code> 是长度为 0 的字符串，不占用空间</strong>。</li><li><font color="red"><code>NULL</code> 会影响聚合函数的结果</font>。例如， <code>SUM</code> 、 <code>AVG</code> 、 <code>MIN</code> 、 <code>MAX</code> 等聚合函数会忽略 <code>NULL</code> 值。 <code>COUNT</code> 的处理方式取决于参数的类型。如果参数是 <code>*</code> ( <code>COUNT(*)</code> )，则会统计所有的记录数，包括 <code>NULL</code> 值；如果参数是某个字段名 ( <code>COUNT(列名)</code> )，则会忽略 <code>NULL</code> 值，只统计非空值的个数。</li><li><font color="red">查询 <code>NULL</code> 值时，必须使用 <code>IS NULL</code> 或 <code>IS NOT NULLl</code> 来判断</font>，而不能使用 =、!=、 &lt;、&gt; 之类的比较运算符。而 <code>''</code> 是可以使用这些比较运算符的。</li></ul><p><strong>因此，MySQL 不建议使用 <code>NULL</code> 作为列默认值。</strong></p><h4 id="boolean-类型如何表示"><a class="anchor" href="#boolean-类型如何表示">#</a> Boolean 类型如何表示？</h4><p>MySQL 中没有专门的布尔类型，而是<strong>用 TINYINT (1) 类型来表示布尔值</strong>。TINYINT (1) 类型可以存储 0 或 1，分别对应 false 或 true。</p><h3 id="mysql基础架构"><a class="anchor" href="#mysql基础架构">#</a> MySQL 基础架构</h3><blockquote><p>配合 <a href="">SQL 语句在 MySQL 中的执行过程</a> 这篇文章来理解 MySQL 基础架构。</p></blockquote><p>一个 SQL 语句在 MySQL 中的执行流程，包括 SQL 的查询在 MySQL 内部会怎么流转，SQL 语句的更新是怎么完成的。</p><p>在分析之前先看看 MySQL 的基础架构，知道了 MySQL 由那些组件组成，以及这些组件的作用是什么，可以帮助我们理解和解决这些问题。</p><h4 id="1-mysql-基础架构分析"><a class="anchor" href="#1-mysql-基础架构分析">#</a> 1、MySQL 基础架构分析</h4><h5 id="11-架构概览"><a class="anchor" href="#11-架构概览">#</a> 1.1、架构概览</h5><p>下图是 MySQL 的一个简要架构图，可以很清晰地看到客户端的一条 SQL 语句在 MySQL 内部是如何执行的。</p><p>从图中可以看出，MySQL 主要由下面几部分构成：</p><ul><li><strong>连接器：</strong><font color="red">连接管理、身份认证和权限</font>相关 (登录 MySQL 的时候)。</li><li>** 查询缓存：** 执行查询语句的时候，会<font color="red">先查询缓存，命中则直接返回</font>（<font color="red">MySQL 8.0 版本后移除</font>，因为这个功能不太实用）。</li><li><strong>分析器：</strong><font color="red">对 SQL 语句进行词法分析、语法分析</font>。说白了就是要先看 SQL 语句要干嘛，再检查 SQL 语句语法是否正确。</li><li><strong>优化器：</strong><font color="red">执行计划生产，索引选择</font>。按照 MySQL 认为<font color="red">最优的方案</font>去执行。</li><li>** 执行器：** 执行语句，然后<font color="red">从存储引擎返回数据</font>。</li><li><strong>插件式存储引擎</strong>：主要负责<font color="red">数据的存储和读取</font>，采用的是 <code>插件式架构</code> ，支持 InnoDB、MyISAM、Memory 等多种存储引擎。</li></ul><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/13526879-3037b144ed09eb88.png" alt="img"></p><center>MySQL 简要架构图</center><p>MySQL 主要分为 Server 层和存储引擎层：</p><ul><li><strong>Server 层</strong>：主要包括<font color="red">连接器、查询缓存、分析器、优化器、执行器</font>等，所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图，函数等，还有一个通用的日志模块 **<font color="red"> binlog 日志模块</font>**。</li><li><strong>存储引擎层</strong>：主要负责<font color="red">数据的存储和读取</font>，采用可以替换的插件式架构，支持 <font color="red">InnoDB、MyISAM、Memory</font> 等多个存储引擎。其中 InnoDB 引擎有自有的日志模块 **<font color="red"> redolog 日志模块</font><strong>。</strong><font color="red">现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5 版本开始就被当做默认存储引擎了</font>**。</li></ul><h5 id="12-server-层的组件介绍"><a class="anchor" href="#12-server-层的组件介绍">#</a> 1.2、Server 层的组件介绍</h5><h6 id="1连接器"><a class="anchor" href="#1连接器">#</a> 1）连接器</h6><p>连接器主要和 **<font color="red">身份认证和权限相关</font>** 的功能相关，就好比一个级别很高的门卫一样。</p><p>主要负责用户登录数据库，进行用户的身份认证，包括校验账户密码，权限等操作。如果用户账户密码已通过，连接器会到权限表中查询该用户的所有权限，之后在这个连接里的权限逻辑判断都<font color="red">仅依赖起始连接成功时读取到的权限数据</font>。也就是说，<font color="red">后续只要这个连接不断开，即使管理员修改了该用户的权限，该用户也是不受影响的</font>。</p><h6 id="2查询缓存"><a class="anchor" href="#2查询缓存">#</a> 2）查询缓存</h6><blockquote><p><strong>从 MySQL8.0 后移除</strong></p></blockquote><p>查询缓存主要 **<font color="red">用来缓存所执行的 SELECT 语句以及该语句的结果集</font>**。</p><p>若连接成功建立，<font color="red">执行查询语句的时候，会先查询缓存</font>。</p><ul><li>MySQL 会先校验这个 SQL 是否执行过，<font color="red">以 Key-Value 的形式缓存在内存中，Key 是查询语句，Value 是结果集</font>。</li><li>如果缓存 key 被命中，就会直接返回给客户端。</li><li>如果缓存 key 没有命中，就会执行后续的操作，<font color="red">完成后也会把结果缓存起来，方便下一次调用</font>。</li></ul><p><strong><font color="red">MySQL 查询不建议使用缓存，因为表更新会清空表上的所有查询缓存，导致查询缓存频繁失效</font></strong>。假如你对一个表更新的话，这个表上的所有的查询缓存都会被清空。对于不经常更新的数据来说，使用缓存还是可以的。</p><p>MySQL 8.0 版本后删除了缓存的功能，官方也是认为该功能在实际的应用场景比较少，所以干脆直接删掉了。</p><h6 id="3分析器"><a class="anchor" href="#3分析器">#</a> 3）分析器</h6><p><font color="red">MySQL 没有命中缓存，那么就会进入分析器</font>。</p><p><strong><font color="red">第一步，词法分析</font></strong>：一条 SQL 语句有多个字符串组成，首先要<font color="red">提取关键字</font>，比如 select，提出查询的表，提出字段名，提出查询条件等等。</p><p><strong><font color="red">第二步，语法分析</font></strong>：主要就是判断你输入的 SQL 是否正确，<font color="red">判断是否符合 MySQL 的语法</font>。</p><p>完成这 2 步之后，MySQL 就准备开始执行了，但是如何执行，怎么执行是最好的结果呢？这个时候就需要优化器上场了。</p><h6 id="4优化器"><a class="anchor" href="#4优化器">#</a> 4）优化器</h6><p>优化器的作用就是 **<font color="red">按照它认为的最优执行方案去执行</font>**，比如多个索引的时候该<font color="red">如何选择索引</font>，多表查询的时候<font color="red">如何选择关联顺序</font>等。</p><p>可以说，经过了优化器之后，这个语句具体该如何执行就已经定下来。</p><h6 id="5执行器"><a class="anchor" href="#5执行器">#</a> 5）执行器</h6><p>当选择了执行方案后，MySQL 就准备开始执行了。首先执行前会校验该用户有没有权限，如果没有权限，就会返回错误信息。<strong><font color="red">如果有权限，就会去调用存储引擎的接口，返回执行结果</font></strong>。</p><h4 id="2-sql-语句分析"><a class="anchor" href="#2-sql-语句分析">#</a> 2、SQL 语句分析</h4><h5 id="21-dql-查询语句"><a class="anchor" href="#21-dql-查询语句">#</a> 2.1、DQL 查询语句</h5><blockquote><p>select</p></blockquote><p>针对 select 语句：</p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tb_student  A <span class="token keyword">where</span> A<span class="token punctuation">.</span>age<span class="token operator">=</span><span class="token string">'18'</span> <span class="token operator">and</span> A<span class="token punctuation">.</span>name<span class="token operator">=</span><span class="token string">' 张三 '</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>结合上面的说明，我们分析下这个语句的执行流程：</p><ol><li><strong>检查该语句是否有权限</strong>：<ul><li>如果没有权限，直接返回错误信息。</li><li>如果有权限，在 MySQL8.0 版本以前，会<strong>查询缓存</strong>，以这条 SQL 语句为 key 在内存中查询是否有结果，有则直接返回，无则执行下一步。</li></ul></li><li><strong>通过分析器对 SQL 语句进行词法分析、语法分析</strong>。<ul><li><font color="red">提取关键元素</font>，比如提取上面这个语句是查询 select，提取需要查询的表名为 tb_student，需要查询所有的列，查询条件是这个表的 id='1'。</li><li><font color="red">判断是否有语法错误</font>，比如关键词是否正确等等，如果检查没问题就执行下一步。</li></ul></li><li><strong>优化器确定执行方案</strong>。上面的 SQL 语句，可以有两种执行方案：a. 先查询学生表中姓名为 “张三” 的学生，然后判断是否年龄是 18。b. 先找出学生中年龄 18 岁的学生，然后再查询姓名为 “张三” 的学生。那么<font color="red">优化器根据优化算法选择执行效率最好的一个方案（优化器认为，有时候不一定最好）</font>。那么确认了执行计划后就准备开始执行了。</li><li>执行语句之前，先进行权限校验，如果没有权限就会返回错误信息。<strong>如果有权限，执行器就会调用存储引擎接口，返回执行结果</strong>。</li></ol><h5 id="22-dml-更新语句"><a class="anchor" href="#22-dml-更新语句">#</a> 2.2、DML 更新语句</h5><blockquote><p>以 update 为例</p></blockquote><p>针对 update 语句：</p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">update</span> tb_student A <span class="token keyword">set</span> A<span class="token punctuation">.</span>age<span class="token operator">=</span><span class="token string">'19'</span> <span class="token keyword">where</span> A<span class="token punctuation">.</span>name<span class="token operator">=</span><span class="token string">' 张三 '</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p><font color="red">这条语句也基本上会沿着上一个查询的流程走，只不过<strong>执行更新的时候肯定要记录日志</strong>，这就会引入日志模块了</font>。</p><p>MySQL 自带的日志模块是 <strong><font color="cornflowerblue">binlog（归档日志）</font></strong>，所有的存储引擎都可以使用。而常用的 InnoDB 引擎还自带了一个日志模块 <strong><font color="cornflowerblue">redo log（重做日志）</font></strong>。</p><p>我们就以 InnoDB 模式下来探讨这个语句的执行流程：</p><ol><li><p><font color="red">先查询到这一条数据</font>（根据 name = 张三），如果有缓存，也是会用到缓存。</p></li><li><p>然后拿到查询的语句，<font color="red">把 age 改为 19</font>，然后<font color="red">调用存储引擎 API 接口，写入这一行数据</font>。InnoDB 引擎把数据保存在内存中，同时 **<font color="red">InnoDB 引擎记录 redo log，此时 redo log 进入 prepare 状态</font>**。然后告诉执行器，执行完成了，随时可以提交。</p></li><li><p><strong><font color="red">执行器收到 InnoDB 引擎的通知后，记录 binlog</font></strong>。然后 **<font color="red">执行器调用引擎接口，提交 redo log 为提交状态</font>**。</p></li><li><p>更新完成。</p></li></ol><hr><p>为什么要用两个日志模块，用一个日志模块不行吗？</p><p>这是因为最开始 MySQL 并没有 InnoDB 引擎（InnoDB 引擎是其他公司以插件形式插入 MySQL 的），MySQL 自带的引擎是 MyISAM。但是我们知道<font color="red"> redo log 是 InnoDB 引擎特有的，其他存储引擎都没有，这就导致会没有 crash-safe 的能力</font>（crash-safe 的能力即使数据库发生异常重启，之前提交的记录都不会丢失），<font color="red">而 binlog 日志只能用来归档</font>。</p><p>并不是说只用一个日志模块不可以，只是 **<font color="red"> InnoDB 引擎就是通过 redo log 来支持事务的</font>**。那么，又会有同学问，我用两个日志模块，但是不要这么复杂行不行，为什么 redo log 要引入 prepare 预提交状态？这里我们用反证法来说明下为什么要这么做？</p><ul><li>先写 redo log 直接提交，然后写 binlog：假设写完 redo log 后，机器挂了，binlog 日志没有被写入，那么机器重启后，这台机器会通过 redo log 恢复数据，但是这个时候 binlog 并没有记录该数据，后续进行机器备份的时候，就会丢失这一条数据，同时主从同步也会丢失这一条数据。</li><li>先写 binlog，然后写 redo log：假设写完了 binlog，机器异常重启了，由于没有 redo log，本机是无法恢复这一条记录的，但是 binlog 又有记录，那么和上面同样的道理，就会产生数据不一致的情况。</li></ul><p><strong><font color="red">redo log 两阶段提交的方式可以保证数据的一致性</font></strong>。写完 binlog 后，然后再提交 redo log 就会防止出现上述的问题，从而保证了数据的一致性。那么问题来了，有没有一个极端的情况呢？<font color="red">假设 redo log 处于 prepare 状态，binlog 也已经写完了，这个时候发生了异常重启会怎么样呢？</font> 这个就要依赖于 MySQL 的处理机制了：</p><ul><li>判断 redo log 是否完整，如果判断是完整的，就立即提交。</li><li>如果 redo log 只是 prepare，但不是 commit 状态，这个时候就会去判断 binlog 是否完整，如果完整就提交 redo log, 不完整就回滚事务。</li></ul><p>这样就解决了数据一致性的问题。</p><h4 id="3-小结"><a class="anchor" href="#3-小结">#</a> 3、小结</h4><ul><li>MySQL 主要分为 <font color="cornflowerblue">Server 层</font>和<font color="cornflowerblue">引擎层</font>，Server 层主要包括<font color="red">连接器、查询缓存、分析器、优化器、执行器</font>，同时还有一个<font color="red">归档日志模块（binlog）</font>，这个日志模块所有执行引擎都可以共用，<font color="red">而重做日志模块（redolog）只有 InnoDB 有</font>。</li><li>Server 层中各组件的功能：<ul><li><strong>连接器</strong>：管理连接、权限验证；</li><li><strong>查询缓存</strong>：命中缓存则直接返回结果；</li><li><strong>分析器</strong>：对 SQL 进行词法分析、语法分析；</li><li><strong>优化器</strong>：执行计划生成、选择索引；</li><li><strong>执行器</strong>：操作引擎、返回结果；</li><li><strong>存储引擎</strong>：存储数据、提供读写接口。</li></ul></li><li>引擎层是插件式的，目前主要包括，<font color="red">MyISAM、InnoDB、Memory</font>等。</li><li><font color="gree">查询语句</font>的执行流程如下：<font color="red">权限校验 ---&gt; 查询缓存（如果命中，直接返回）---&gt; 分析器 ---&gt; 优化器 ---&gt;<strong> 权限校验</strong> ---&gt; 执行器 ---&gt; 引擎</font></li><li><font color="gree">更新语句</font>执行流程如下：<font color="red">分析器 ----&gt; 权限校验 ----&gt; 执行器 ---&gt; 引擎 ---<strong>redo log (prepare 状态)</strong>---&gt;<strong>binlog</strong>---&gt;<strong>redo log (commit 状态)</strong></font></li><li>笼统点的回答，<strong>一条 SQL 的执行过程</strong>：<ol><li>客户端请求 -&gt;</li><li>连接器（验证用户身份，给予权限） -&gt;</li><li>查询缓存（存在缓存则直接返回，不存在则执行后续操作）-&gt;</li><li>分析器（对 SQL 进行词法分析、语法分析） -&gt;</li><li>优化器（选择最优的 SQL 执行方案） -&gt;</li><li>执行器（先检查用户是否有执行权限，有的话才调用引擎接口，执行 SQL）-&gt;</li><li>从引擎层获取数据返回（如果开启查询缓存，则会缓存查询结果）</li></ol></li></ul><h3 id="mysql存储引擎"><a class="anchor" href="#mysql存储引擎">#</a> <mark>MySQL 存储引擎</mark></h3><h4 id="mysql-支持哪些存储引擎默认使用哪个"><a class="anchor" href="#mysql-支持哪些存储引擎默认使用哪个">#</a> MySQL 支持哪些存储引擎？默认使用哪个？</h4><p>MySQL 支持多种存储引擎，你可以通过 <code>show engines</code> 命令来查看 MySQL 支持的所有存储引擎。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20220510105408703.png" alt="查看 MySQL 提供的所有存储引擎"></p><p>从上图我们可以查看出，<strong>MySQL 5.5.5 之后，默认的存储引擎是 InnoDB</strong>。并且，<strong>只有 InnoDB 支持事务、行级锁、外键</strong>。</p><p>MySQL 5.5.5 之前，MyISAM 是 MySQL 的默认存储引擎。5.5.5 版本之后，InnoDB 是 MySQL 的默认存储引擎。</p><h4 id="mysql-存储引擎架构了解吗"><a class="anchor" href="#mysql-存储引擎架构了解吗">#</a> MySQL 存储引擎架构了解吗？</h4><p>MySQL 存储引擎采用的是<strong>插件式架构，支持多种存储引擎</strong>。我们甚至可以为不同的数据库表设置不同的存储引擎以适应不同场景的需要。<strong>存储引擎是基于表的，而不是数据库。</strong></p><h4 id="myisam-和-innodb-有什么区别"><a class="anchor" href="#myisam-和-innodb-有什么区别">#</a> MyISAM 和 InnoDB 有什么区别？</h4><p>MySQL 5.5 之前，MyISAM 引擎是 MySQL 的默认存储引擎，可谓是风光一时。</p><p>虽然，MyISAM 的性能还行，各种特性也还不错（比如全文索引、压缩、空间函数等）。但是，<strong><font color="red">MyISAM 不支持事务和行级锁，而且最大的缺陷就是崩溃后无法安全恢复</font></strong>。</p><p>MySQL 5.5 版本之后，InnoDB 是 MySQL 的默认存储引擎。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231108152443561.png" alt="image-20231108152443561"></p><p>言归正传！咱们下面还是来简单对比一下两者：</p><p><strong>1. 是否支持行级锁</strong></p><p>MyISAM 只有表级锁 ( <code>table-level locking</code> )，而<font color="red"> InnoDB 支持行级锁 ( <code>row-level locking</code> ) 和表级锁，默认为行级锁。</font></p><p>也就说，MyISAM 一锁就是锁住了整张表，这在并发写的情况下是多么滴憨憨啊！这也是为什么 InnoDB 在并发写的时候，性能更牛皮了！</p><p><strong>2. 是否支持事务</strong></p><p>MyISAM 不提供事务支持。</p><p><font color="red">InnoDB 提供事务支持，实现了 SQL 标准定义了四个隔离级别，具有提交 ( <code>commit</code> ) 和回滚 ( <code>rollback</code> ) 事务的能力</font>。</p><p>并且，<font color="red">InnoDB 默认使用的 <code>REPEATABLE-READ</code> （可重复读）隔离级别是可以解决幻读问题发生的（基于 MVCC 和 Next-Key Lock）</font>。</p><p>关于 MySQL 事务的详细介绍，可以看看我写的这篇文章：<span class="exturl" data-url="aHR0cHM6Ly9qYXZhZ3VpZGUuY24vZGF0YWJhc2UvbXlzcWwvdHJhbnNhY3Rpb24taXNvbGF0aW9uLWxldmVsLmh0bWw=">MySQL 事务隔离级别详解</span>。</p><p><strong>3. 是否支持外键</strong></p><p>MyISAM 不支持，而<font color="red"> InnoDB 支持外键</font>。</p><p>外键对于维护数据一致性非常有帮助，但是<font color="red">对性能有一定的损耗</font>。因此，通常情况下，我们是不建议在实际生产项目中使用外键的，在业务代码中进行约束即可！</p><p>阿里的《Java 开发手册》也是明确规定<strong>禁止使用外键</strong>的。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20220510090309427.png" alt="img"></p><p>不过，在代码中进行约束的话，对程序员的能力要求更高，具体是否要采用外键还是要根据你的项目实际情况而定。</p><p>总结：一般我们也是不建议在数据库层面使用外键的，应用层面可以解决。不过，这样<font color="red">会对数据的一致性造成威胁</font>。具体要不要使用外键还是要根据你的项目来决定。</p><p><strong>4. 是否支持数据库异常崩溃后的安全恢复</strong></p><p>MyISAM 不支持，而<font color="red"> InnoDB 支持数据库异常崩溃后的安全恢复</font>。</p><p>使用 InnoDB 的数据库在异常崩溃后，数据库重新启动的时候会保证数据库恢复到崩溃前的状态。这个恢复的过程依赖于 InnoDB 的<strong>重做日志模块 <code>redo log</code> </strong>。</p><p><strong>5. 是否支持 MVCC</strong></p><p><font color="red">MVCC 可以看作是行级锁的一个升级，可以有效减少加锁操作，提高性能</font>。</p><p>MyISAM 不支持，而<font color="red"> InnoDB 支持 MVCC</font>。</p><p>讲真，这个对比有点废话，毕竟 MyISAM 连行级锁都不支持。</p><p><strong>6. 索引实现不一样。</strong></p><p>虽然 MyISAM 引擎和 InnoDB 引擎<font color="red">都是使用 B+Tree 作为索引结构</font>，但是两者的实现方式不太一样。</p><p><font color="red">InnoDB 引擎中，数据、索引都是存放在 .ibd 表空间文件中</font>。相比 MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按 B+Tree 组织的一个索引结构，树的叶节点 data 域保存了完整的数据记录。</p><p><strong>7. 性能有差别。</strong></p><p><font color="red">InnoDB 的性能比 MyISAM 更强大</font>，不管是在读写混合模式下还是只读模式下，随着 CPU 核数的增加，InnoDB 的读写能力呈线性增长。<font color="red">MyISAM 的读写不能并发，它的处理能力跟核数没关系</font>。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/innodb-myisam-performance-comparison.png" alt="InnoDB 和 MyISAM 性能对比"></p><p><strong>总结</strong> ：</p><ul><li><strong>InnoDB 支持事务处理，而 MyISAM 不支持</strong>。</li><li><strong>InnoDB 支持行级锁，而 MyISAM 只支持表级锁</strong>。</li><li><strong>InnoDB 支持外键，而 MyISAM 不支持</strong>。</li><li><font color="red">InnoDB 支持 MVCC</font>，而 MyISAM 不支持。</li><li>虽然 MyISAM 引擎和 InnoDB 引擎都是使用 B+Tree 作为索引结构，但是<font color="red">两者的索引实现方式不太一样</font>。</li><li><font color="red">InnoDB 支持数据库异常崩溃后的安全恢复</font>，而 MyISAM 不支持。</li><li><font color="red">InnoDB 的性能比 MyISAM 更强大</font>。</li></ul><p>最后，再分享一张图片给你，这张图片详细对比了常见的几种 MySQL 存储引擎。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/comparison-of-common-mysql-storage-engines.png" alt="常见的几种 MySQL 存储引擎对比"></p><h4 id="myisam-和-innodb-如何选择"><a class="anchor" href="#myisam-和-innodb-如何选择">#</a> MyISAM 和 InnoDB 如何选择？</h4><p><strong>大多数情况使用的都是 InnoDB 存储引擎</strong>。在某些读密集的情况下，使用 MyISAM 也是合适的。不过，前提是你的项目不介意<font color="red"> MyISAM 不支持事务、崩溃恢复</font>等缺点（可是～我们一般都会介意啊！）。</p><h3 id="mysql索引"><a class="anchor" href="#mysql索引">#</a> <mark>MySQL 索引</mark></h3><h4 id="索引介绍"><a class="anchor" href="#索引介绍">#</a> 索引介绍</h4><p><strong>索引是一种帮助存储引擎快速查询和检索数据的数据结构（有序）。</strong></p><p>索引的底层数据结构存在很多种类型，常见的索引结构有：红黑树、B 树、B + 树、Hash。</p><p><font color="red">在 MySQL 中，Innodb 和 MyIsam，都使用 B + 树 作为索引结构</font>。</p><h4 id="索引的优缺点"><a class="anchor" href="#索引的优缺点">#</a> 索引的优缺点</h4><p><strong>优点</strong>：</p><ul><li>使用索引可以大大<font color="red">加快数据的检索速度</font>（大大减少检索的数据量），这也是创建索引的最主要的原因。</li><li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</li></ul><p><strong>缺点</strong>：</p><ul><li><font color="red">创建和维护索引需要耗费许多时间</font>。当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低 SQL 执行效率。</li><li>索引需要使用物理文件存储，也会耗费一定空间。</li></ul><h4 id="索引的底层数据结构选型"><a class="anchor" href="#索引的底层数据结构选型">#</a> <mark>索引的底层数据结构选型</mark></h4><p>不同存储引擎对索引结构的支持情况：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231117203129938.png" alt="image-20231117203129938"></p><h5 id="hash-表"><a class="anchor" href="#hash-表">#</a> Hash 表</h5><p>哈希表是键值对的集合，通过键 (key) 即可快速取出对应的值 (value)，因此哈希表可以快速检索数据（接近 O（1））。</p><p>通过哈希算法，我们可以快速找到 key 对应的 index，找到了 index 也就找到了对应的 value。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre>hash <span class="token operator">=</span> <span class="token function">hashfunc</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre>index <span class="token operator">=</span> hash <span class="token operator">%</span> array_size</pre></td></tr></table></figure><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/mysql20210513092328171.png" alt="img"></p><p>但是！哈希算法有个 <strong>Hash 冲突</strong> 问题，也就是说多个不同的 key 最后得到的 index 相同。通常情况下，我们常用的解决办法是<strong>链地址法</strong>。链地址法就<font color="red">是将哈希冲的突数据存放在链表中</font>。</p><p>比如 JDK1.8 之前 <code>HashMap</code> 就是通过链地址法来解决哈希冲突的。不过，JDK1.8 以后 <code>HashMap</code> 为了减少链表过长时搜索时间过长引入了红黑树。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/mysql20210513092224836.png" alt="img"></p><p>为了减少 Hash 冲突的发生，一个好的哈希函数应该 “均匀地” 将数据分布在整个可能的哈希值集合中。</p><hr><p>InnoDB 存储引擎不直接支持常规的哈希索引，但存在一种特殊的<strong>自适应哈希索引（Adaptive Hash Index）</strong>，结合了 B+Tree 和哈希索引的特点，以便更好地适应实际应用中的数据访问模式和性能需求。自适应哈希索引的<font color="red">每个哈希桶实际上是一个小型的 B+Tree 结构</font>。这个 B+Tree 结构可以存储多个键值对，而不仅仅是一个键。这有助于减少哈希冲突链的长度，提高了索引的效率。关于 Adaptive Hash Index 的详细介绍，可以查看 <span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvcmE0djFYUjVwelNXYy1xdEdPLWRCZw==">MySQL 各种 “Buffer” 之 Adaptive Hash Index</span> 这篇文章。</p><p>既然哈希表这么快，为什么 MySQL 没有使用其作为索引的数据结构呢？主要是<strong>因为 Hash 索引不支持排序、范围查询</strong>。假如我们要对表中的数据进行排序或者进行范围查询，那 Hash 索引可就不行了。并且，每次 IO 只能取一个。</p><p>试想一种情况:</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token constant">SELECT</span> <span class="token operator">*</span> <span class="token constant">FROM</span> tb1 <span class="token constant">WHERE</span> id <span class="token operator">&lt;</span> <span class="token number">500</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>在这种范围查询中，直接遍历比 500 小的叶子节点就够了。而 Hash 索引是根据 hash 算法来定位的，难不成还要把 1 - 499 的数据，每个都进行一次 hash 计算来定位吗？这就是 Hash 最大的缺点了。</p><h5 id="二叉查找树bst"><a class="anchor" href="#二叉查找树bst">#</a> 二叉查找树（BST）</h5><p>二叉查找树（Binary Search Tree）是一种基于二叉树的数据结构，它具有以下特点：</p><ol><li>左子树所有节点的值均小于根节点的值。</li><li>右子树所有节点的值均大于根节点的值。</li><li>左右子树也分别为二叉查找树。</li></ol><p>二叉查找树的时间复杂度：</p><ul><li>当二叉查找树平衡时，也就是树的每个节点的左右子树深度相差不超过 1 的时候，查询的时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:.01968em">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:.03588em">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，具有比较高的效率。</li><li>然而，当二叉查找树不平衡时，例如在最坏情况下（有序插入节点），树会退化成线性链表（也被称为<font color="red">斜树</font>），导致查询效率急剧下降，时间复杂退化为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mtext>（</mtext><mi>N</mi><mtext>）</mtext></mrow><annotation encoding="application/x-tex">O（N）</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mord cjk_fallback">（</span><span class="mord mathnormal" style="margin-right:.10903em">N</span><span class="mord cjk_fallback">）</span></span></span></span>。</li></ul><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/oblique-tree.png" alt="斜树"></p><center>斜树</center><p>也就是说，<strong>二叉查找树的性能非常依赖于它的平衡程度，这就导致其不适合作为 MySQL 底层索引的数据结构。</strong></p><p>为了解决这个问题，并提高查询效率，人们发明了多种在二叉查找树基础上的改进型数据结构，如平衡二叉树、B-Tree、B+Tree 等。</p><h5 id="avl-树自平衡的bst"><a class="anchor" href="#avl-树自平衡的bst">#</a> AVL 树（自平衡的 BST）</h5><p>AVL 树的特点是<font color="red">保证任何节点的左右子树高度之差不超过 1</font>，因此也被称为高度平衡二叉树。<font color="red">它的查找、插入和删除在平均和最坏情况下的时间复杂度都是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:.01968em">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:.03588em">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></font>。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/avl-tree.png" alt="AVL 树"></p><p>AVL 树采用了<font color="red">旋转操作</font>来保持平衡。主要有四种旋转操作：LL 旋转、RR 旋转、LR 旋转和 RL 旋转。其中 LL 旋转和 RR 旋转分别用于处理左左和右右失衡，而 LR 旋转和 RL 旋转则用于处理左右和右左失衡。</p><p>由于 AVL 树<font color="red">需要频繁地进行旋转操作来保持平衡</font>，因此会有较大的计算开销进而降低了查询性能。并且， 在使用 AVL 树时，每个树节点仅存储一个数据，而每次进行磁盘 IO 时只能读取一个节点的数据，如果需要查询的数据分布在多个节点上，那么就需要进行多次磁盘 IO。 <strong>磁盘 IO 是一项耗时的操作，在设计数据库索引时，我们需要优先考虑如何最大限度地减少磁盘 IO 操作的次数。</strong></p><p>实际应用中，AVL 树使用的并不多。</p><h5 id="红黑树自平衡的bst"><a class="anchor" href="#红黑树自平衡的bst">#</a> 红黑树（自平衡的 BST）</h5><p>与 AVL 树一样，红黑树也是一种自平衡二叉查找树，通过在插入和删除节点时进行<font color="red">颜色变换、旋转操作</font>，使得树始终保持平衡状态，它具有以下特点：</p><ol><li>每个节点非红即黑；</li><li>根节点总是黑色的；</li><li>每个叶子节点都是黑色的空节点（NIL 节点）；</li><li>如果节点是红色的，则它的子节点必须是黑色的（反之不一定）；</li><li>从根节点到叶节点或空子节点的每条路径，必须包含相同数目的黑色节点（即相同的黑色高度）。</li></ol><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/red-black-tree.png" alt="红黑树"></p><p>和 AVL 树不同的是，<strong><font color="red">红黑树并不追求严格的平衡，而是大致的平衡，因此红黑树的查询效率稍有下降</font></strong>。因为红黑树的平衡性相对较弱，可能会导致树的高度较高，这可能会导致一些数据需要进行多次磁盘 IO 操作才能查询到，这也是 MySQL 没有选择红黑树的主要原因。</p><p>也正因如此，<strong><font color="red">红黑树的插入和删除操作效率大大提高了</font></strong><font color="red">，因为红黑树在插入和删除节点时只需进行 O (1) 次数的旋转和变色操作，即可保持基本平衡状态</font>，而不需要像 AVL 树一样进行 O (logn) 次数的旋转操作。</p><p>红黑树的应用还是比较广泛的，<font color="red">TreeMap、TreeSet 以及 JDK1.8 的 HashMap 底层都用到了红黑树</font>。对于数据在内存中的这种情况来说，红黑树的表现是非常优异的。</p><h5 id="b树-b树"><a class="anchor" href="#b树-b树">#</a> B 树 &amp; B + 树</h5><p>B 树全称为<strong>多路平衡查找树</strong> ，B+ 树是 B 树的一种变体，其中 B 是 <code>Balanced</code> （平衡）的意思。</p><p><font color="red">目前大部分数据库系统及文件系统都采用 B-Tree 或其变种 B+Tree 作为<u>索引结构</u></font>。</p><p>B 树与 B + 树的区别：</p><ul><li><font color="red">B 树的所有节点既存放<strong>索引列值（key）<strong>也存放数据（data）</strong></strong></font>；而<font color="red"> B+ 树只有叶子节点存放 key 和 data，其他内节点只存放 key</font>。这样可以大大增加每个内节点存储的 key 值数量，从而降低 B + 树的高度，提高检索效率。</li><li><font color="red">B 树的叶子节点都是独立的</font>；而 <strong><font color="red">B+ 树的每个叶子节点都有一条<u>双向引用链</u>指向与它相邻的叶子节点</font></strong>。</li><li>B 树的检索的过程相当于对范围内的每个节点的 key 做二分查找，可能还没有到达叶子节点，检索就结束了。而 <strong><font color="red">B+ 树的检索效率就很稳定了，任何查找都是从根节点到叶子节点的过程，叶子节点的顺序检索很明显</font></strong>。</li><li>在 B 树中进行范围查询时，首先找到要查找的下限，然后对 B 树进行中序遍历，直到找到查找的上限；而 <strong><font color="red">B+ 树的范围查询，只需要对双向链表进行遍历即可</font></strong>。</li></ul><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/249993-20170525154141810-591706803.png" alt="img"></p><center>B树索引（3阶）</center><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/249993-20170531161139243-491884410.png" alt="img"></p><center>（B+树索引）</center><p>综上，B + 树与 B 树相比，具备 **<font color="red">更高，更稳定的查询效率、更适用于范围查询</font>** 这些优势。</p><hr><p><font color="red">在 MySQL 中，MyISAM 引擎和 InnoDB 引擎都是使用 B+Tree 作为索引结构，但二者的实现方式不太一样</font>。</p><blockquote><p>《Java 工程师修炼之道》：</p><p>MyISAM 引擎中，B+Tree 叶节点的 data 域存放的是数据记录的地址。在索引检索的时候，首先按照 B+Tree 搜索算法搜索索引，如果指定的 Key 存在，则取出其 data 域的值，然后以 data 域的值为地址读取相应的数据记录。这被称为 “<strong>非聚簇索引（非聚集索引）</strong>”。</p><p>InnoDB 引擎中，其数据文件本身就是索引文件。相比 MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按 B+Tree 组织的一个索引结构，树的叶节点 data 域保存了完整的数据记录。这个索引的 key 是数据表的主键，因此 InnoDB 表数据文件本身就是主索引。这被称为 “<strong>聚簇索引（聚集索引）</strong>”，而其余的索引都作为 <strong>辅助索引</strong> ，辅助索引的 data 域存储相应记录主键的值而不是地址，这也是和 MyISAM 不同的地方。在根据主索引搜索时，直接找到 key 所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引。 因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。</p></blockquote><h4 id="索引分类"><a class="anchor" href="#索引分类">#</a> 索引分类</h4><p>按照<font color="gree">数据结构</font>分类：</p><ul><li><strong><font color="cornflowerblue">B + 树索引</font></strong>：MySQL 里<font color="red">默认的</font>索引类型。<font color="red">只有叶子节点存储 value，非叶子节点只有指针和 key</font>。存储引擎 MyISAM 和 InnoDB 实现索引都是使用 B+Tree，但二者实现方式不一样。</li><li><font color="cornflowerblue">hash 索引</font>：类似键值对的形式，一次即可定位。</li><li><font color="cornflowerblue">R 树索引</font>：一般不会使用，<font color="red">仅支持 geometry 数据类型</font>，优势在于范围查找，效率较低，通常使用搜索引擎如 ElasticSearch 代替。</li><li><font color="cornflowerblue">全文索引</font>：<font color="red">对文本的内容进行分词，进行搜索</font>。目前只有 <code>CHAR</code> 、 <code>VARCHAR</code> ， <code>TEXT</code> 列上可以创建全文索引。<font color="red">一般不会使用，效率较低</font>，通常使用搜索引擎如 ElasticSearch 代替。</li></ul><p>按照<font color="gree">底层存储方式</font>划分：</p><ul><li><p><strong><font color="cornflowerblue">聚集索引</font></strong>：聚集索引的<strong>叶子节点存储的是<u>整行记录</u></strong>。<font color="red">可以直接查找到数据，查询速度快。每个表只能有一个聚集索引</font>。例如 <font color="red">InnoDB 引擎中的主键索引</font>。</p><blockquote><p>在 MySQL 中，InnoDB 引擎表的 <code>.ibd</code> 表空间文件包含了该表的索引和数据，因此该表的索引 (B + 树) 的每个非叶子节点存储索引，叶子节点存储索引和索引对应的数据。</p></blockquote></li><li><p><strong><font color="cornflowerblue">非聚集索引</font></strong>：非聚集索引的<strong>叶子节点存储的是<u>索引列的值、指向对应行记录的指针</u></strong>。查询速度相对较慢。<font color="red">MyISAM 引擎，无论主键还是非主键，使用的都是非聚集索引</font>。</p></li></ul><p>按照<font color="gree">应用维度</font>划分：</p><ul><li><font color="cornflowerblue">主键索引</font>：加速查询 + 列值唯一（不可以有 NULL）+ 表中只有一个。</li><li><font color="cornflowerblue">普通索引</font>：仅加速查询。</li><li><font color="cornflowerblue">唯一索引</font>：加速查询 + 列值唯一（可以有 NULL）。</li><li><font color="cornflowerblue">覆盖索引</font>：一个索引包含（或者说覆盖）所有需要查询的字段的值。</li><li><font color="cornflowerblue">联合索引</font>：<font color="red">多列值组成一个索引</font>，专门用于组合搜索，其效率大于索引合并。</li><li><font color="cornflowerblue">全文索引</font>：对文本的内容进行分词，进行搜索。目前只有 <code>CHAR</code> 、 <code>VARCHAR</code> ， <code>TEXT</code> 列上可以创建全文索引。一般不会使用，效率较低，通常使用搜索引擎如 ElasticSearch 代替。</li></ul><p>MySQL 8.x 中实现的<font color="gree">索引新特性</font>：</p><ul><li><font color="cornflowerblue">隐藏索引</font>：也称为不可见索引，不会被优化器使用，但是仍然需要维护，通常会软删除和灰度发布的场景中使用。主键不能设置为隐藏（包括显式设置或隐式设置）。</li><li><font color="cornflowerblue">降序索引</font>：之前的版本就支持通过 desc 来指定索引为降序，但实际上创建的仍然是常规的升序索引。直到 MySQL 8.x 版本才开始真正支持降序索引。另外，在 MySQL 8.x 版本中，不再对 GROUP BY 语句进行隐式排序。</li><li><font color="cornflowerblue">函数索引</font>：从 MySQL 8.0.13 版本开始支持在索引中使用函数或者表达式的值，也就是在索引中可以包含函数或者表达式。</li></ul><h5 id="主键索引"><a class="anchor" href="#主键索引">#</a> 主键索引</h5><p>数据表的<font color="red">主键列</font>使用的就是主键索引。</p><p>一张数据表有只能有一个主键，并且主键不能为 null，不能重复。</p><p>在 MySQL 的 InnoDB 的表中，当没有显示的指定表的主键时，InnoDB 会自动先检查表中是否有唯一索引且不允许存在 null 值的字段，如果有，则选择该字段为默认的主键，否则 InnoDB 将会自动创建一个 6 Byte 的自增主键。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/cluster-index.png" alt="主键索引"></p><center>主键索引</center><h5 id="二级索引"><a class="anchor" href="#二级索引">#</a> 二级索引</h5><p>二级索引（Secondary Index）又称为辅助索引，是一种非聚集索引，因为<strong>二级索引的叶子节点仅仅存储<u>索引列的值、对应行记录的主键 key</u></strong>。也就是说，<font color="red">通过二级索引，可以定位主键的位置，再根据主键索引查找行记录 data，这就是<strong>二次查询（回表）</strong>，因此二级索引的查询速度较慢</font>。</p><p>唯一索引，普通索引，前缀索引、全文索引都属于二级索引：</p><ol><li><font color="cornflowerblue">唯一索引 (Unique Key)</font>：唯一索引也是一种约束。<font color="red">唯一索引的属性列不能出现重复的数据，但是允许数据为 NULL，一张表允许创建多个唯一索引</font>。建立唯一索引的目的大部分时候都是<font color="red">为了该属性列的数据的唯一性，而不是为了查询效率</font>。</li><li><font color="cornflowerblue">普通索引 (Index)</font>：普通索引的唯一作用就是<font color="red">为了快速查询数据</font>，一张表允许创建多个普通索引，并允许数据重复和 NULL。</li><li><font color="cornflowerblue">前缀索引 (Prefix)</font>：前缀索引只适用于字符串类型的数据。前缀索引是<font color="red">对文本的前几个字符创建索引，相比普通索引建立的数据更小</font>，因为只取前几个字符。</li><li><font color="cornflowerblue">全文索引 (Full Text)</font>：全文索引主要是<font color="red">为了检索大文本数据中的关键字信息</font>，是目前搜索引擎数据库使用的一种技术。Mysql 5.6 之前只有 MYISAM 引擎支持全文索引，5.6 之后 InnoDB 也支持了全文索引。</li></ol><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/no-cluster-index.png" alt="二级索引"></p><center>二级索引</center><h5 id="聚集索引"><a class="anchor" href="#聚集索引">#</a> 聚集索引</h5><p>聚集索引（Clustered Index）的<strong>叶子节点存储的是<u>整行记录</u></strong>。<font color="red">可以直接查找到数据，查询速度快。每个表只能有一个聚集索引</font>。例如 <font color="red">InnoDB 引擎中的主键索引</font>。</p><p>在 MySQL 中，<font color="red">InnoDB 引擎的表的 <code>.ibd</code> 表空间文件就包含了该表的索引和数据</font>，对于 InnoDB 引擎表来说，该表的索引 (B + 树) 的每个非叶子节点存储索引，叶子节点存储索引和索引对应的数据。</p><p>优点：</p><ul><li><strong>查询速度非常快</strong>：因为整个 B+ 树本身就是一颗多叉平衡树，叶子节点也都是有序的，定位到索引的节点，就相当于定位到了数据。<font color="red">相比于非聚集索引， 聚集索引少了一次读取数据的 IO 操作</font>。</li><li><strong>对排序查找和范围查找优化</strong>：对于主键的排序查找和范围查找速度非常快。</li></ul><p>缺点：</p><ul><li><strong>依赖于有序的数据</strong>：因为 B+ 树是多路平衡树，如果索引的数据不是有序的，那么就<font color="red">需要在插入时排序</font>，如果数据是整型还好，否则类似于字符串或 UUID 这种又长又难比较的数据，<font color="red">插入或查找的速度肯定比较慢</font>。</li><li><strong>修改更新的代价大</strong>：如果索引列的数据被修改，那么对应的索引也将会被修改，而且聚集索引的叶子节点还存放着数据，修改代价肯定是较大的。所以对于主键索引来说，主键一般都是不可被修改的。</li></ul><h5 id="非聚集索引"><a class="anchor" href="#非聚集索引">#</a> 非聚集索引</h5><p>非聚集索引（Non-Clustered Index）的<strong>叶子节点存储的是<u>索引列的值、指向对应行记录的指针</u></strong>。查询速度相对较慢。二级索引 (辅助索引) 就属于非聚集索引。<font color="red">MyISAM 引擎，无论主键还是非主键，使用的都是非聚集索引</font>。</p><p>非聚集索引的叶子节点并不一定存放数据的指针，因为<font color="red">二级索引的叶子节点就存放的是主键，根据主键再回表查数据</font>。</p><p>优点：</p><ul><li><strong>更新代价比聚集索引要小</strong>：因为非聚集索引的<font color="red">叶子节点是不存放数据的</font></li></ul><p>缺点：</p><ul><li><p><strong>依赖于有序的数据</strong>：跟聚簇索引一样，非聚簇索引也依赖于有序的数据</p></li><li><p><strong><font color="orange">可能会二次查询 (回表查询)</font></strong>: 这应该是非聚簇索引最大的缺点了。<strong><font color="red">当查到非聚集索引对应的指针或主键后，可能还需要根据指针或主键再到数据文件或表中查询</font></strong>。</p><blockquote><p><strong>非聚集索引不一定回表查询。</strong></p><p>试想一种情况，用户准备使用 SQL 查询用户名，而用户名字段正好建立了索引。</p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">SELECT</span> name <span class="token keyword">FROM</span> <span class="token keyword">table</span> <span class="token keyword">WHERE</span> name<span class="token operator">=</span><span class="token string">'guang19'</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>那么这个<font color="red">索引的 key 本身就是要查询的字段</font>，查到对应的 name 直接返回就行了，无需回表查询。</p><p>即使是 MYISAM 也是这样，虽然 MYISAM 的主键索引确实需要回表，因为它的主键索引的叶子节点存放的是指针。但是！<strong>如果 SQL 查的就是主键呢？</strong></p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">SELECT</span> id <span class="token keyword">FROM</span> <span class="token keyword">table</span> <span class="token keyword">WHERE</span> id<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>主键索引本身的 key 就是主键，查到返回就行了。这种情况就称之为<strong>覆盖索引</strong>了。</p></blockquote></li></ul><p>这是 MySQL 的 InnoDB、MyISAM 表的文件截图：</p><blockquote><p><strong>InnoDB、MyISAM、Memory 这三种存储引擎的存储文件内容</strong>：</p><ul><li>无论哪种引擎，<font color="gree">表的结构</font>都存储在 <code>.sdi</code> 文件中</li><li>对于 InnoDB，表的索引和数据都存储在 <code>.ibd 表空间文件</code> 中</li><li>对于 MyISAM，表的索引存储在 <code>.MYI</code> 文件中，表的数据存储在 <code>.MYD</code> 文件中</li><li>对于 Memory，表的索引和数据都存储在 <code>内存</code> 中</li></ul></blockquote><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/mysql20210420165311654.png" alt="MySQL 表的文件"></p><p>聚集索引和非聚集索引:</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/mysql20210420165326946.png" alt="聚簇索引和非聚簇索引"></p><h5 id="覆盖索引"><a class="anchor" href="#覆盖索引">#</a> 覆盖索引</h5><p>如果一个<strong>索引包含（或者说覆盖）所有需要查询的字段的值</strong>，我们就称之为覆盖索引（Covering Index）。我们知道在 InnoDB 存储引擎中，如果不是主键索引，叶子节点存储的是索引列值 + 主键。最终还是要 “回表”，也就是要通过主键再查找一次，这样就会比较慢。<font color="red">而覆盖索引就是把要查询出的列和索引是对应的，不做回表操作！</font></p><p><strong>覆盖索引，即需要查询的字段正好是索引的字段，那么直接根据该索引，就可以查到数据了，而无需回表查询。</strong></p><blockquote><p>如主键索引，如果一条 SQL 需要查询主键，那么正好根据主键索引就可以查到主键。再如普通索引，如果一条 SQL 需要查询 name，name 字段正好有索引，那么直接根据这个索引就可以查到数据，也无需回表。</p></blockquote><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/mysql20210420165341868.png" alt="覆盖索引"></p><h5 id="联合索引"><a class="anchor" href="#联合索引">#</a> 联合索引</h5><p>使用表中的<strong>多个字段创建索引</strong>，就是 联合索引，也叫 组合索引 或 复合索引。</p><p>以 <code>score</code> 和 <code>name</code> 两个字段建立联合索引：</p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> <span class="token identifier"><span class="token punctuation">`</span>cus_order<span class="token punctuation">`</span></span> <span class="token keyword">ADD</span> <span class="token keyword">INDEX</span> id_score_name<span class="token punctuation">(</span>score<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h5 id="最左前缀匹配原则"><a class="anchor" href="#最左前缀匹配原则">#</a> <mark>最左前缀匹配原则</mark></h5><p>最左前缀法则：<strong>对联合索引的查询从其最左列开始，并且不跳过索引中的列</strong>。</p><ul><li><font color="red">如果跳跃了<u>中间的某一列</u>，那么联合索引将会<u>部分失效</u>（后面的字段索引失效）。</font></li><li><strong>如果跳跃了<u>最左列</u>，那么联合索引将会<u>全部失效</u>，转而进行全表扫描！</strong></li></ul><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231117221133910.png" alt="image-20231117221133910"></p><blockquote><p>注意：<strong>联合索引的最左边字段必须在 SQL 的查询条件中存在，但是与 SQL 的查询条件中编写的字段先后顺序无关</strong>。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231117221449634.png" alt="image-20231117221449634"></p><center>因此对于这种情况，联合索引是全部生效的！</center></blockquote><p>所以，<strong>在使用联合索引时，可以将区分度高的字段放在最左边，这也可以过滤更多数据</strong>。</p><p>在联合索引的使用中，如果 SQL 出现范围查询（如 <strong><code>&gt;</code> </strong>、<strong> <code>&lt;</code> </strong>），那么范围查询右侧的列索引会失效！</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231117221945853.png" alt="image-20231117221945853"></p><blockquote><p>但对于 <strong><code>&gt;=</code> </strong>、<strong> <code>&lt;=</code> </strong>、<strong> <code>BETWEEN</code> </strong>、<strong> <code>like</code> </strong>前缀匹配的范围查询，并不会停止匹配。</p></blockquote><h4 id="索引下推"><a class="anchor" href="#索引下推">#</a> 索引下推</h4><p><strong>索引下推（Index Condition Pushdown）</strong> 是 <strong>MySQL 5.6</strong> 版本中提供的一项索引优化功能，可以在非聚簇索引遍历过程中，对索引中包含的字段先做判断，过滤掉不符合条件的记录，减少回表次数。</p><h4 id="索引的正确使用建议"><a class="anchor" href="#索引的正确使用建议">#</a> 索引的正确使用建议</h4><h3 id="mysql查询缓存"><a class="anchor" href="#mysql查询缓存">#</a> MySQL 查询缓存</h3><p>执行查询语句的时候，会先查询缓存。不过，<strong>MySQL 8.0 版本后移除</strong>，因为这个功能不太实用</p><p><code>my.cnf</code> 加入以下配置，重启 MySQL 开启查询缓存</p><figure class="highlight properties"><figcaption data-lang=".properties"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token key attr-name">query_cache_type</span><span class="token punctuation">=</span><span class="token value attr-value">1</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token key attr-name">query_cache_size</span><span class="token punctuation">=</span><span class="token value attr-value">600000</span></pre></td></tr></table></figure><p>MySQL 执行以下命令也可以开启查询缓存</p><figure class="highlight properties"><figcaption data-lang=".properties"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token key attr-name">set</span> <span class="token value attr-value">global  query_cache_type=1;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token key attr-name">set</span> <span class="token value attr-value">global  query_cache_size=600000;</span></pre></td></tr></table></figure><p>如上，<strong>开启查询缓存后在同样的查询条件以及数据情况下，会直接在缓存中返回结果</strong>。这里的查询条件包括查询本身、当前要查询的数据库、客户端协议版本号等一些可能影响结果的信息。</p><p><strong>查询缓存不命中的情况：</strong></p><ol><li>任何两个查询在任何字符上的不同都会导致缓存不命中。</li><li>如果查询中包含任何用户自定义函数、存储函数、用户变量、临时表、MySQL 库中的系统表，其查询结果也不会被缓存。</li><li>缓存建立之后，MySQL 的查询缓存系统会跟踪查询中涉及的每张表，如果这些表（数据或结构）发生变化，那么和这张表相关的所有缓存数据都将失效。</li></ol><p><strong>缓存虽然能够提升数据库的查询性能，但是缓存同时也带来了额外的开销，每次查询后都要做一次缓存操作，失效后还要销毁。</strong> 因此，开启查询缓存要谨慎，尤其对于写密集的应用来说更是如此。如果开启，要注意合理控制缓存空间大小，一般来说其大小设置为几十 MB 比较合适。此外，<strong>还可以通过 <code>sql_cache</code> 和 <code>sql_no_cache</code> 来控制某个查询语句是否需要缓存：</strong></p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">select</span> sql_no_cache <span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">from</span> usr<span class="token punctuation">;</span></pre></td></tr></table></figure><h3 id="mysql日志"><a class="anchor" href="#mysql日志">#</a> MySQL 日志</h3><h4 id="mysql-中常见的日志有哪些"><a class="anchor" href="#mysql-中常见的日志有哪些">#</a> MySQL 中常见的日志有哪些？</h4><p>MySQL 中常见的日志有以下几种：</p><ul><li>二进制日志（ <code>binlog</code> ）：记录了所有修改了数据库结构或数据内容的操作，以便在主从复制时将这些操作同步到从库。二进制日志是<font color="red">逻辑日志</font>，记录的是对<font color="red">数据库结构或数据内容</font>的修改。</li><li>重做日志（ <code>redo log</code> ）：redo log 是 MySQL 的一种日志，<strong>是 InnoDB 存储引擎独有的，它让 MySQL 拥有了崩溃恢复能力</strong>。<font color="red">redo log 只记录该存储引擎中表的修改，而 binlog 是在数据库层面产生的，所有存储引擎对数据库进行修改都会产生 binlog</font>。redo log 是<font color="red">物理日志</font>，记录的是对<font color="red">数据页</font>的修改，而不是对数据的修改。</li><li>回滚日志（undo log）：<strong>是 InnoDB 存储引擎独有的</strong>，记录了所有修改了数据的操作，以便在事务回滚时撤销这些操作。回滚日志是<font color="red">逻辑日志</font>，记录的是对<font color="red">数据</font>的修改，而不是对数据页的修改。</li><li>错误日志（errorlog）：记录了 MySQL 服务器启动、运行过程中出现的错误信息。</li><li>慢查询日志（slow query log）：记录了执行时间超过指定阈值的 SQL 语句。慢查询日志可以用于优化 SQL 语句性能。</li><li>一般查询日志（general log）：记录了 MySQL 服务器接收到的所有 SQL 语句，包括执行时间、执行结果等信息。一般查询日志可以用于调试和安全审计。</li><li>中继日志（relay log）：是 MySQL 主从复制结构中<font color="red">从节点上的日志，用于保存主节点传输过来的数据变更事件，然后将这些事件应用于从节点</font>。</li></ul><h4 id="慢查询日志有什么用"><a class="anchor" href="#慢查询日志有什么用">#</a> 慢查询日志有什么用？</h4><p>用来<font color="red">记录在 MySQL 中响应时间超过阀值的语句</font>，具体指运行时间超过 long_query_time 值的 SQL，则会被记录到慢查询日志中。long_query_time 的默认值为 10，意思是运行 10 秒以上的 SQL 语句。慢查询日志<font color="red">可以帮助开发人员找出哪些语句的执行效率低，以便进行优化</font>。</p><h4 id="binlog-主要记录了什么"><a class="anchor" href="#binlog-主要记录了什么">#</a> binlog 主要记录了什么？</h4><p>binlog 是 MySQL 的二进制日志，主要<font color="red">记录了对 MySQL 数据库进行的所有更改操作，包括插入、更新和删除操作</font>。binlog 可以用于数据恢复、数据同步和数据备份等方面 。</p><h4 id="介绍一下redo-log以及它如何保证事务的持久性"><a class="anchor" href="#介绍一下redo-log以及它如何保证事务的持久性">#</a> 介绍一下 redo log，以及它如何保证事务的持久性？</h4><p>redo log 是 MySQL 的一种日志，<strong>是 InnoDB 存储引擎独有的，它让 MySQL 拥有了崩溃恢复能力</strong>。<font color="red">redo log 只记录该存储引擎中表的修改，而 binlog 是在数据库层面产生的，所有存储引擎对数据库进行修改都会产生 binlog</font>。</p><p>redo log 是 MySQL 数据库用于保证事务的持久性的机制之一。在执行一个事务时，<font color="red">MySQL 会将事务所做出的修改操作先写入 redo log 而不是直接保存到磁盘</font>，也就是 <code>WAL（write ahead log)机制</code> 。这是因为将数据直接写入磁盘的开销较大，而将修改操作写入 redo log 可以大幅减少磁盘 IO 的次数。</p><blockquote><p>WAL（write ahead log）机制的基本思想：</p><p>在修改数据之前，先将修改操作记录到一个日志文件中，然后再将修改操作应用到数据库中。这样，即使在修改数据的过程中出现了故障，也可以通过日志文件来恢复数据 。</p></blockquote><p>当一个事务提交后，<font color="red">MySQL 会从 redo log 中读取相应的修改操作，并将其写入磁盘</font>。<font color="red">只要 redo log 已经持久化（即已经写入磁盘），那么就可以保证故障发生后能够完成数据恢复</font>。如果 MySQL 在执行修改操作时遇到了宕机等问题，在重启后会重新应用 redo log 里未被应用的操作，从而实现事务的持久性。</p><h4 id="数据页是什么"><a class="anchor" href="#数据页是什么">#</a> 数据页是什么？</h4><p>数据页是 InnoDB 存储引擎中的一个重要概念，它<strong>是 InnoDB 存储引擎中的最小存储单位。InnoDB 存储引擎将表空间分为多个大小相等的数据页，每个数据页默认大小为 16KB</strong>。在 InnoDB 存储引擎中，每个表都有一个独立的表空间，表空间由多个数据文件组成。当表中的数据发生变化时，InnoDB 存储引擎会将修改操作记录到 redo log 中，并将修改操作应用到内存中的数据页中。当内存中的数据页被修改后，InnoDB 存储引擎会将修改操作异步刷新到磁盘上的数据文件中，从而保证了数据的持久性。</p><h4 id="页修改之后为什么不直接刷盘呢"><a class="anchor" href="#页修改之后为什么不直接刷盘呢">#</a> 页修改之后为什么不直接刷盘呢？</h4><p>在数据库中，将修改的数据直接刷盘（写入磁盘）可能会产生一些性能开销。这是因为在执行随机磁盘 IO 的过程中，磁盘的寻址时间和磁道切换时间等所需的开销较大，说明磁盘 IO 时需要耗费较长的时间。因此<strong>直接刷盘会导致大量的磁盘 I/O，降低系统的性能</strong>。</p><p>为了避免这种情况，InnoDB 存储引擎采用了一种称为 “ <code>脏页刷盘</code> ” 的机制。<font color="red">在数据库缓存中，如果一个数据页上的数据已经被修改了，但还没有被同步写入磁盘，那么这个数据页就被称为 “ <code>脏页</code> ”</font>。 <code>脏页刷盘</code> 机制是指 InnoDB 存储引擎在<font color="red">将内存中的数据页刷新到磁盘上</font>时，会根据一定的策略来决定哪些数据页需要被刷新到磁盘上，哪些数据页可以暂时不刷新。</p><ul><li><font color="red">当内存中的数据页被修改前，InnoDB 存储引擎会将修改操作记录到 redo log 中，并将修改操作应用到内存中的数据页中</font>。</li><li><font color="red">当内存中的数据页被修改后，InnoDB 存储引擎会将修改操作异步刷新到磁盘上的数据文件中，从而保证了数据的持久性</font>。在这个过程中，InnoDB 存储引擎会根据一定的策略来决定哪些数据页需要被刷新到磁盘上，哪些数据页可以暂时不刷新。这样可以避免大量的磁盘 I/O，提高系统的性能。</li></ul><h4 id="binlog-和-redolog-有什么区别"><a class="anchor" href="#binlog-和-redolog-有什么区别">#</a> binlog 和 redolog 有什么区别？</h4><p>binlog 和 redolog 都是 MySQL 数据库中的日志文件，用于记录数据库的修改操作。它们的主要区别在于：</p><ol><li><p>binlog 是 MySQL 的归档日志，用于<font color="red">记录所有的修改操作，包括数据的增删改操作和表结构的变更操作等</font>。binlog 的作用是<font color="red">用于数据恢复、主从复制和数据同步</font>等场景。</p></li><li><p>redolog 是 InnoDB 存储引擎的事务日志，用于<font color="red">记录事务的修改操作</font>。redolog 的作用是<font color="red">用于保证事务的原子性、一致性和持久性</font>。当一个事务提交时，会将该事务所做的所有修改操作先记录在 redo log 中并刷到磁盘上，然后再将这些修改操作同步到数据库的数据文件中。</p></li></ol><p>区别:</p><ul><li>binlog 是整个<font color="red">数据库实例级别</font>的，记录了对整个数据库实例进行的所有更改操作，而 redolog 是每个<font color="red">InnoDB 存储引擎实例级别</font>的，只记录了在该存储引擎实例中发生的事务更改操作。</li><li>binlog 是对<font color="red">数据库执行的语句级别</font>的日志，redolog 是对<font color="red">事务级别</font>的日志，记录了事务的具体操作信息。</li><li>binlog 通常<font color="red">用于 JDBC 等客户端进行异地灾难恢复</font>，而 redolog<font color="red">用于保证事务的 ACID 属性（原子性、一致性、隔离性和持久性）</font>。</li></ul><p>因为<font color="red"> binlog 记录了所有的修改操作，所以它比 redolog 更加全面，但也更加耗费磁盘空间</font>。而 <font color="red">redolog 只记录了事务的修改操作，所以它比 binlog 更加高效，但也更加局限</font>。</p><h4 id="undo-log-如何保证事务的原子性"><a class="anchor" href="#undo-log-如何保证事务的原子性">#</a> undo log 如何保证事务的原子性？</h4><p>undo log <font color="red">是 InnoDB 存储引擎的</font>回滚日志，<font color="red">用于记录事务的回滚操作</font>。</p><p>当一个事务需要回滚时，InnoDB 存储引擎会根据 undo log 中的信息将数据页恢复到事务开始之前的状态。因此，undo log 可以保证事务的原子性。</p><p>在 InnoDB 存储引擎中，每个事务都有一个对应的 undo log，用于记录该事务所做的修改操作。当事务提交时，InnoDB 存储引擎会将 undo log 中的信息删除，从而释放磁盘空间。如果事务回滚，则 InnoDB 存储引擎会根据 undo log 中的信息将数据页恢复到事务开始之前的状态。这样可以保证事务的原子性。</p><h3 id="mysql事务"><a class="anchor" href="#mysql事务">#</a> MySQL 事务</h3><h4 id="何谓事务"><a class="anchor" href="#何谓事务">#</a> 何谓事务？</h4><p>我们设想一个场景，这个场景中我们需要插入多条相关联的数据到数据库，不幸的是，这个过程可能会遇到下面这些问题：</p><ul><li>数据库中途突然因为某些原因挂掉了。</li><li>客户端突然因为网络原因连接不上数据库了。</li><li>并发访问数据库时，多个线程同时写入数据库，覆盖了彼此的更改。</li><li>......</li></ul><p>上面的任何一个问题都可能会导致数据的不一致性。为了保证数据的一致性，系统必须能够处理这些问题。事务就是我们抽象出来简化这些问题的首选机制。事务的概念起源于数据库，目前，已经成为一个比较广泛的概念。</p><p>何为事务？ 一言蔽之，<strong>事务是逻辑上的一组操作，要么都执行，要么都不执行。</strong></p><p>事务最经典也经常被拿出来说例子就是转账了。假如小明要给小红转账 1000 元，这个转账会涉及到两个关键操作，这两个操作必须都成功或者都失败。</p><ol><li>将小明的余额减少 1000 元</li><li>将小红的余额增加 1000 元。</li></ol><p>事务会把这两个操作就可以看成逻辑上的一个整体，这个整体包含的操作要么都成功，要么都要失败。这样就不会出现小明余额减少而小红的余额却并没有增加的情况。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230424112229682.png" alt="image-20230424112229682"></p><h4 id="何谓数据库事务"><a class="anchor" href="#何谓数据库事务">#</a> 何谓数据库事务？</h4><p>大多数情况下，我们在谈论事务的时候，如果没有特指<strong>分布式事务</strong>，往往指的就是<strong>数据库事务</strong>。</p><p>数据库事务在我们日常开发中接触的最多了。如果你的项目属于单体架构的话，你接触到的往往就是数据库事务了。</p><p><strong>那数据库事务有什么作用呢？</strong></p><p>简单来说，<font color="red">数据库事务可以保证多个对数据库的操作（也就是 SQL 语句）构成一个逻辑上的整体</font>。构成这个逻辑上的整体的这些数据库操作遵循：<strong>要么全部执行成功，要么全部不执行</strong> 。</p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment"># 开启一个事务</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">START</span> <span class="token keyword">TRANSACTION</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment"># 多条 SQL 语句</span></pre></td></tr><tr><td data-num="4"></td><td><pre>SQL1<span class="token punctuation">,</span>SQL2<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token comment">## 提交事务</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">COMMIT</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230424112420132.png" alt="image-20230424112420132"></p><p>另外，关系型数据库（例如： <code>MySQL</code> 、 <code>SQL Server</code> 、 <code>Oracle</code> 等）事务都有 <strong>ACID</strong> 特性：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230424112518237.png" alt="image-20230424112518237"></p><ol><li><strong>原子性</strong>（ <code>Atomicity</code> ） ： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li><li><strong>一致性</strong>（ <code>Consistency</code> ）： 执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；</li><li><strong>隔离性</strong>（ <code>Isolation</code> ）： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</li><li><strong>持久性</strong>（ <code>Durability</code> ）： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li></ol><p>🌈 这里要额外补充一点：<strong>只有保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。也就是说 A、I、D 是手段，C 是目的！</strong> 想必大家也和我一样，被 ACID 这个概念被误导了很久！我也是看周志明老师的公开课<span class="exturl" data-url="aHR0cHM6Ly90aW1lLmdlZWtiYW5nLm9yZy9vcGVuY291cnNlL2ludHJvLzEwMDA2NDIwMQ==">《周志明的软件架构课》open in new window</span> 才搞清楚的（多看好书！！！）。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230424112548870.png" alt="image-20230424112548870"></p><p>另外，DDIA 也就是 <span class="exturl" data-url="aHR0cHM6Ly9ib29rLmRvdWJhbi5jb20vc3ViamVjdC8zMDMyOTUzNi8=">《Designing Data-Intensive Application（数据密集型应用系统设计）》open in new window</span> 的作者在他的这本书中如是说：</p><blockquote><p>Atomicity, isolation, and durability are properties of the database, whereas consis‐ tency (in the ACID sense) is a property of the application. The application may rely on the database’s atomicity and isolation properties in order to achieve consistency, but it’s not up to the database alone.</p><p>翻译过来的意思是：原子性，隔离性和持久性是数据库的属性，而一致性（在 ACID 意义上）是应用程序的属性。应用可能依赖数据库的原子性和隔离属性来实现一致性，但这并不仅取决于数据库。因此，字母 C 不属于 ACID 。</p></blockquote><p>《Designing Data-Intensive Application（数据密集型应用系统设计）》这本书强推一波，值得读很多遍！豆瓣有接近 90% 的人看了这本书之后给了五星好评。另外，中文翻译版本已经在 Github 开源，地址：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Zvbm5nL2RkaWE=">https://github.com/Vonng/ddiaopen in new window</span> 。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/ddia.png" alt="img"></p><h4 id="并发事务带来了哪些问题"><a class="anchor" href="#并发事务带来了哪些问题">#</a> 并发事务带来了哪些问题？</h4><p>在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对同一数据进行操作）。并发虽然是必须的，但可能会导致以下的问题。</p><h5 id="脏读dirty-read"><a class="anchor" href="#脏读dirty-read">#</a> 脏读（Dirty read）</h5><p>一个事务读取数据并且对数据进行了修改，这个修改对其他事务来说是可见的，即使当前事务没有提交。这时另外一个事务读取了这个还未提交的数据，但第一个事务突然回滚，导致数据并没有被提交到数据库，那第二个事务读取到的就是脏数据，这也就是脏读的由来。</p><p>例如：事务 1 读取某表中的数据 A=20，事务 1 修改 A=A-1，事务 2 读取到 A = 19, 事务 1 回滚导致对 A 的修改并为提交到数据库， A 的值还是 20。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230424112618536.png" alt="image-20230424112618536"></p><h5 id="丢失修改lost-to-modify"><a class="anchor" href="#丢失修改lost-to-modify">#</a> 丢失修改（Lost to modify）</h5><p>在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。</p><p>例如：事务 1 读取某表中的数据 A=20，事务 2 也读取 A=20，事务 1 先修改 A=A-1，事务 2 后来也修改 A=A-1，最终结果 A=19，事务 1 的修改被丢失。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230424112636565.png" alt="image-20230424112636565"></p><h5 id="不可重复读unrepeatable-read"><a class="anchor" href="#不可重复读unrepeatable-read">#</a> 不可重复读（Unrepeatable read）</h5><p>指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。</p><p>例如：事务 1 读取某表中的数据 A=20，事务 2 也读取 A=20，事务 1 修改 A=A-1，事务 2 再次读取 A =19，此时读取的结果和第一次读取的结果不同。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230424112650372.png" alt="image-20230424112650372"></p><h5 id="幻读phantom-read"><a class="anchor" href="#幻读phantom-read">#</a> 幻读（Phantom read）</h5><p>幻读与不可重复读类似。它发生在一个事务读取了几行数据，接着另一个并发事务插入了一些数据时。在随后的查询中，第一个事务就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</p><p>例如：事务 2 读取某个范围的数据，事务 1 在这个范围插入了新的数据，事务 2 再次读取这个范围的数据发现相比于第一次读取的结果多了新的数据。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230424112700267.png" alt="image-20230424112700267"></p><h4 id="不可重复读和幻读有什么区别"><a class="anchor" href="#不可重复读和幻读有什么区别">#</a> 不可重复读和幻读有什么区别？</h4><ul><li>不可重复读的重点是内容修改或者记录减少比如多次读取一条记录发现其中某些记录的值被修改；</li><li>幻读的重点在于记录新增比如多次执行同一条查询语句（DQL）时，发现查到的记录增加了。</li></ul><p>幻读其实可以看作是不可重复读的一种特殊情况，单独把区分幻读的原因主要是解决幻读和不可重复读的方案不一样。</p><p>举个例子：执行 <code>delete</code> 和 <code>update</code> 操作的时候，可以直接对记录加锁，保证事务安全。而执行 <code>insert</code> 操作的时候，由于记录锁（Record Lock）只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁（Gap Lock）。也就是说执行 <code>insert</code> 操作的时候需要依赖 Next-Key Lock（Record Lock+Gap Lock） 进行加锁来保证不出现幻读。</p><h4 id="并发事务的控制方式有哪些"><a class="anchor" href="#并发事务的控制方式有哪些">#</a> 并发事务的控制方式有哪些？</h4><p>MySQL 中并发事务的控制方式无非就两种：<strong>锁</strong> 和 <strong>MVCC</strong>。锁可以看作是悲观控制的模式，多版本并发控制（MVCC，Multiversion concurrency control）可以看作是乐观控制的模式。</p><p><strong>锁</strong> 控制方式下会通过锁来显示控制共享资源而不是通过调度手段，MySQL 中主要是通过 <strong>读写锁</strong> 来实现并发控制。</p><ul><li><strong>共享锁（S 锁）</strong> ：又称读锁，事务在读取记录的时候获取共享锁，允许多个事务同时获取（锁兼容）。</li><li><strong>排他锁（X 锁）</strong> ：又称写锁 / 独占锁，事务在修改记录的时候获取排他锁，不允许多个事务同时获取。如果一个记录已经被加了排他锁，那其他事务不能再对这条记录加任何类型的锁（锁不兼容）。</li></ul><p>读写锁可以做到读读并行，但是无法做到写读、写写并行。另外，根据根据锁粒度的不同，又被分为 <strong>表级锁 (table-level locking)</strong> 和 <strong>行级锁 (row-level locking)</strong> 。InnoDB 不光支持表级锁，还支持行级锁，默认为行级锁。行级锁的粒度更小，仅对相关的记录上锁即可（对一行或者多行记录加锁），所以对于并发写入操作来说， InnoDB 的性能更高。不论是表级锁还是行级锁，都存在共享锁（Share Lock，S 锁）和排他锁（Exclusive Lock，X 锁）这两类。</p><p><strong>MVCC</strong> 是多版本并发控制方法，即对一份数据会存储多个版本，通过事务的可见性来保证事务能看到自己应该看到的版本。通常会有一个全局的版本分配器来为每一行数据设置版本号，版本号是唯一的。</p><p>MVCC 在 MySQL 中实现所依赖的手段主要是: <strong>隐藏字段、read view、undo log</strong>。</p><ul><li>undo log : undo log 用于记录某行数据的多个版本的数据。</li><li>read view 和 隐藏字段：用来判断当前版本数据的可见性。</li></ul><p>关于 InnoDB 对 MVCC 的具体实现可以看这篇文章：<span class="exturl" data-url="aHR0cHM6Ly9qYXZhZ3VpZGUuY24vZGF0YWJhc2UvbXlzcWwvaW5ub2RiLWltcGxlbWVudGF0aW9uLW9mLW12Y2MuaHRtbA==">InnoDB 存储引擎对 MVCC 的实现 open in new window</span> 。</p><h4 id="sql-标准定义了哪些事务隔离级别"><a class="anchor" href="#sql-标准定义了哪些事务隔离级别">#</a> SQL 标准定义了哪些事务隔离级别？</h4><p>SQL 标准定义了四个隔离级别：</p><ul><li><strong>READ-UNCOMMITTED (读取未提交)</strong> ： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。</li><li><strong>READ-COMMITTED (读取已提交)</strong> ： 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。</li><li><strong>REPEATABLE-READ (可重复读)</strong> ： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</li><li><strong>SERIALIZABLE (可串行化)</strong> ： 最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。</li></ul><hr><table><thead><tr><th style="text-align:center">隔离级别</th><th style="text-align:center">脏读</th><th style="text-align:center">不可重复读</th><th style="text-align:center">幻读</th></tr></thead><tbody><tr><td style="text-align:center">READ-UNCOMMITTED</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">√</td></tr><tr><td style="text-align:center">READ-COMMITTED</td><td style="text-align:center">×</td><td style="text-align:center">√</td><td style="text-align:center">√</td></tr><tr><td style="text-align:center">REPEATABLE-READ</td><td style="text-align:center">×</td><td style="text-align:center">×</td><td style="text-align:center">√</td></tr><tr><td style="text-align:center">SERIALIZABLE</td><td style="text-align:center">×</td><td style="text-align:center">×</td><td style="text-align:center">×</td></tr></tbody></table><h4 id="mysql-的隔离级别是基于锁实现的吗"><a class="anchor" href="#mysql-的隔离级别是基于锁实现的吗">#</a> MySQL 的隔离级别是基于锁实现的吗？</h4><p>MySQL 的隔离级别基于锁和 MVCC 机制共同实现的。</p><p>SERIALIZABLE 隔离级别是通过锁来实现的，READ-COMMITTED 和 REPEATABLE-READ 隔离级别是基于 MVCC 实现的。不过， SERIALIZABLE 之外的其他隔离级别可能也需要用到锁机制，就比如 REPEATABLE-READ 在当前读情况下需要使用加锁读来保证不会出现幻读。</p><h4 id="mysql-的默认隔离级别是什么"><a class="anchor" href="#mysql-的默认隔离级别是什么">#</a> MySQL 的默认隔离级别是什么？</h4><p>MySQL InnoDB 存储引擎的默认支持的隔离级别是 <strong>REPEATABLE-READ（可重读）</strong>。我们可以通过 <code>SELECT @@tx_isolation;</code> 命令来查看，MySQL 8.0 该命令改为 <code>SELECT @@transaction_isolation;</code></p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre>mysql<span class="token operator">></span> <span class="token keyword">SELECT</span> @<span class="token variable">@tx_isolation</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token operator">+</span><span class="token comment">-----------------+</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token operator">|</span> @<span class="token variable">@tx_isolation</span>  <span class="token operator">|</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token operator">+</span><span class="token comment">-----------------+</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token operator">|</span> <span class="token keyword">REPEATABLE</span><span class="token operator">-</span><span class="token keyword">READ</span> <span class="token operator">|</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token operator">+</span><span class="token comment">-----------------+</span></pre></td></tr></table></figure><p>关于 MySQL 事务隔离级别的详细介绍，可以看看我写的这篇文章：<span class="exturl" data-url="aHR0cHM6Ly9qYXZhZ3VpZGUuY24vZGF0YWJhc2UvbXlzcWwvdHJhbnNhY3Rpb24taXNvbGF0aW9uLWxldmVsLmh0bWw=">MySQL 事务隔离级别详解 open in new window</span>。</p><h2 id="mysql高性能优化规范建议"><a class="anchor" href="#mysql高性能优化规范建议">#</a> MySQL 高性能优化规范建议</h2><h2 id="️重要知识点"><a class="anchor" href="#️重要知识点">#</a> ⭐️重要知识点</h2><h2 id="sql"><a class="anchor" href="#sql">#</a> SQL</h2><h3 id="sql语法基础"><a class="anchor" href="#sql语法基础">#</a> SQL 语法基础</h3><h4 id="基本概念"><a class="anchor" href="#基本概念">#</a> 基本概念</h4><h5 id="数据库术语"><a class="anchor" href="#数据库术语">#</a> 数据库术语</h5><ul><li><code>数据库（database）</code> - 保存有组织的数据的容器（通常是一个文件或一组文件）。</li><li><code>数据表（table）</code> - 某种特定类型数据的结构化清单。</li><li><code>模式（schema）</code> - <font color="red">关于数据库和表的布局及特性的信息</font>。模式<font color="red">定义了数据在表中如何存储</font>，包含存储什么样的数据，数据如何分解，各部分信息如何命名等信息。数据库和表都有模式。</li><li><code>列（column）</code> - 表中的一个字段。所有表都是由一个或多个列组成的。</li><li><code>行（row）</code> - 表中的一个记录。</li><li><code>主键（primary key）</code> - 一列（或一组列），其值能够唯一标识表中每一行。</li></ul><h5 id="sql-语法"><a class="anchor" href="#sql-语法">#</a> SQL 语法</h5><p><code>SQL（Structured Query Language)</code> ，标准 SQL 由 ANSI 标准委员会管理，从而称为 ANSI SQL。各个 DBMS 都有自己的实现，如 PL/SQL、Transact-SQL 等。</p><h6 id="sql-语法结构"><a class="anchor" href="#sql-语法结构">#</a> SQL 语法结构</h6><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/cb684d4c75fc430e92aaee226069c7da%7Etplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>SQL 语法结构包括：</p><ul><li><strong><code>子句</code> </strong>- 是语句和查询的组成成分。（在某些情况下，这些都是可选的。）</li><li><strong><code>表达式</code> </strong>- 可以产生任何标量值，或由列和行的数据库表</li><li><strong><code>谓词</code> </strong>- 给需要评估的 SQL 三值逻辑（3VL）（true/false/unknown）或布尔真值指定条件，并限制语句和查询的效果，或改变程序流程。</li><li><strong><code>查询</code> </strong>- 基于特定条件检索数据。这是 SQL 的一个重要组成部分。</li><li><strong><code>语句</code> </strong>- 可以持久地影响纲要和数据，也可以控制数据库事务、程序流程、连接、会话或诊断。</li></ul><h6 id="sql-语法要点"><a class="anchor" href="#sql-语法要点">#</a> SQL 语法要点</h6><ul><li><strong>SQL 语句不区分大小写</strong>，但是数据库表名、列名和值是否区分，依赖于具体的 DBMS 以及配置。例如： <code>SELECT</code> 与 <code>select</code> 、 <code>Select</code> 是相同的。</li><li><strong>多条 SQL 语句必须以分号（ <code>;</code> ）分隔</strong>。</li><li>处理 SQL 语句时，<strong>所有空格都被忽略</strong>。</li></ul><p>SQL 语句可以写成一行，也可以分写为多行。</p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">-- 一行 SQL 语句</span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">UPDATE</span> <span class="token keyword">user</span> <span class="token keyword">SET</span> username<span class="token operator">=</span><span class="token string">'robot'</span><span class="token punctuation">,</span> password<span class="token operator">=</span><span class="token string">'robot'</span> <span class="token keyword">WHERE</span> username <span class="token operator">=</span> <span class="token string">'root'</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token comment">-- 多行 SQL 语句</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">UPDATE</span> <span class="token keyword">user</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">SET</span> username<span class="token operator">=</span><span class="token string">'robot'</span><span class="token punctuation">,</span> password<span class="token operator">=</span><span class="token string">'robot'</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token keyword">WHERE</span> username <span class="token operator">=</span> <span class="token string">'root'</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>SQL 支持三种注释：</p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">## 注释 1</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment">-- 注释 2</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">/* 注释 3 */</span></pre></td></tr></table></figure><h5 id="sql-分类"><a class="anchor" href="#sql-分类">#</a> SQL 分类</h5><h6 id="数据定义语言ddl"><a class="anchor" href="#数据定义语言ddl">#</a> 数据定义语言（DDL）</h6><p>数据定义语言（Data Definition Language，DDL）是 SQL 语言集中负责数据结构定义与数据库对象定义的语言。</p><p>DDL 的主要功能是<strong>定义数据库对象</strong>。</p><p>DDL 的核心指令是 <code>CREATE</code> 、 <code>ALTER</code> 、 <code>DROP</code> 。</p><h6 id="数据操纵语言dml"><a class="anchor" href="#数据操纵语言dml">#</a> 数据操纵语言（DML）</h6><p>数据操纵语言（Data Manipulation Language, DML）是用于数据库操作，对数据库其中的对象和数据运行访问工作的编程语句。</p><p>DML 的主要功能是 访问数据，因此其语法都是以<strong>读写数据库</strong>为主。</p><p>DML 的核心指令是 <code>INSERT</code> 、 <code>DELETE</code> 、 <code>UPDATE</code> 、 <code>SELECT</code> 。这四个指令合称 CRUD (Create, Read, Update, Delete)，即增删改查。</p><h6 id="事务控制语言tcl"><a class="anchor" href="#事务控制语言tcl">#</a> 事务控制语言（TCL）</h6><p>事务控制语言 (Transaction Control Language, TCL) 用于<strong>管理数据库中的事务</strong>。这些用于管理由 DML 语句所做的更改。它还允许将语句分组为逻辑事务。</p><p>TCL 的核心指令是 <code>COMMIT</code> 、 <code>ROLLBACK</code> 。</p><h6 id="数据控制语言dcl"><a class="anchor" href="#数据控制语言dcl">#</a> 数据控制语言（DCL）</h6><p>数据控制语言 (Data Control Language, DCL) 是一种可对数据访问权进行控制的指令，它可以控制特定用户账户对数据表、查看表、预存程序、用户自定义函数等数据库对象的控制权。</p><p>DCL 的核心指令是 <code>GRANT</code> 、 <code>REVOKE</code> 。</p><p>DCL 以<strong>控制用户的访问权限</strong>为主，因此其指令作法并不复杂，可利用 DCL 控制的权限有： <code>CONNECT</code> 、 <code>SELECT</code> 、 <code>INSERT</code> 、 <code>UPDATE</code> 、 <code>DELETE</code> 、 <code>EXECUTE</code> 、 <code>USAGE</code> 、 <code>REFERENCES</code> 。</p><p>根据不同的 DBMS 以及不同的安全性实体，其支持的权限控制也有所不同。</p><p><strong>我们先来介绍 DML 语句用法。 DML 的主要功能是读写数据库实现增删改查。</strong></p><h4 id="增删改查"><a class="anchor" href="#增删改查">#</a> 增删改查</h4><p>增删改查，又称为 CRUD，数据库基本操作中的基本操作。</p><h5 id="插入数据"><a class="anchor" href="#插入数据">#</a> 插入数据</h5><p><code>INSERT INTO</code> 语句用于向表中插入新记录。</p><p><strong>插入完整的行</strong></p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment"># 插入一行</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token keyword">user</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token string">'root'</span><span class="token punctuation">,</span> <span class="token string">'root'</span><span class="token punctuation">,</span> <span class="token string">'xxxx@163.com'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment"># 插入多行</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token keyword">user</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token string">'root'</span><span class="token punctuation">,</span> <span class="token string">'root'</span><span class="token punctuation">,</span> <span class="token string">'xxxx@163.com'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">,</span> <span class="token string">'user1'</span><span class="token punctuation">,</span> <span class="token string">'user1'</span><span class="token punctuation">,</span> <span class="token string">'xxxx@163.com'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">18</span><span class="token punctuation">,</span> <span class="token string">'user2'</span><span class="token punctuation">,</span> <span class="token string">'user2'</span><span class="token punctuation">,</span> <span class="token string">'xxxx@163.com'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p><strong>插入行的一部分</strong></p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token keyword">user</span><span class="token punctuation">(</span>username<span class="token punctuation">,</span> password<span class="token punctuation">,</span> email<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'admin'</span><span class="token punctuation">,</span> <span class="token string">'admin'</span><span class="token punctuation">,</span> <span class="token string">'xxxx@163.com'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p><strong>插入查询出来的数据</strong></p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token keyword">user</span><span class="token punctuation">(</span>username<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">SELECT</span> name</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">FROM</span> account<span class="token punctuation">;</span></pre></td></tr></table></figure><h5 id="更新数据"><a class="anchor" href="#更新数据">#</a> 更新数据</h5><p><code>UPDATE</code> 语句用于更新表中的记录。</p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">UPDATE</span> <span class="token keyword">user</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">SET</span> username<span class="token operator">=</span><span class="token string">'robot'</span><span class="token punctuation">,</span> password<span class="token operator">=</span><span class="token string">'robot'</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">WHERE</span> username <span class="token operator">=</span> <span class="token string">'root'</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h5 id="删除数据"><a class="anchor" href="#删除数据">#</a> 删除数据</h5><ul><li><code>DELETE</code> 语句用于删除表中的记录。</li><li><code>TRUNCATE TABLE</code> 可以清空表，也就是删除所有行。</li></ul><p><strong>删除表中的指定数据</strong></p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">DELETE</span> <span class="token keyword">FROM</span> <span class="token keyword">user</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">WHERE</span> username <span class="token operator">=</span> <span class="token string">'robot'</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p><strong>清空表中的数据</strong></p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">TRUNCATE</span> <span class="token keyword">TABLE</span> <span class="token keyword">user</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h5 id="查询数据"><a class="anchor" href="#查询数据">#</a> 查询数据</h5><p><code>SELECT</code> 语句用于从数据库中查询数据。</p><p><code>DISTINCT</code> 用于返回唯一不同的值。它<font color="red">作用于所有列</font>，也就是说所有列的值都相同才算相同。</p><p><code>LIMIT</code> 限制返回的行数。可以有两个参数，<strong><font color="red">第一个参数为起始行从 0 开始</font></strong>；<font color="red">第二个参数为返回的总行数</font>。</p><ul><li><code>ASC</code> ：升序（默认）</li><li><code>DESC</code> ：降序</li></ul><p><strong>查询单列</strong></p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">SELECT</span> prod_name</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">FROM</span> products<span class="token punctuation">;</span></pre></td></tr></table></figure><p><strong>查询多列</strong></p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">SELECT</span> prod_id<span class="token punctuation">,</span> prod_name<span class="token punctuation">,</span> prod_price</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">FROM</span> products<span class="token punctuation">;</span></pre></td></tr></table></figure><p><strong>查询所有列</strong></p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">SELECT</span> <span class="token operator">*</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">FROM</span> products<span class="token punctuation">;</span></pre></td></tr></table></figure><p><strong>查询不同的值</strong></p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">SELECT</span> <span class="token keyword">DISTINCT</span> vend_id </pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">FROM</span> products<span class="token punctuation">;</span></pre></td></tr></table></figure><p><strong>限制查询结果</strong></p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">-- 返回前 5 行</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> mytable <span class="token keyword">LIMIT</span> <span class="token number">5</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> mytable <span class="token keyword">LIMIT</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment">-- 返回第 3 ~ 5 行</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> mytable <span class="token keyword">LIMIT</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h4 id="排序"><a class="anchor" href="#排序">#</a> 排序</h4><p><code>order by</code> 用于对结果集按照一个列或者多个列进行排序。 <code>默认升序</code> 对记录进行排序，如果需要按照降序对记录进行排序，可以使用 <code>desc</code> 关键字。</p><p><code>order by</code> 对多列排序的时候，先排序的列放前面，后排序的列放后面。并且，<font color="red">不同的列可以有不同的排序规则</font>。</p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> products</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">ORDER</span> <span class="token keyword">BY</span> prod_price <span class="token keyword">DESC</span><span class="token punctuation">,</span> prod_name <span class="token keyword">ASC</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h4 id="分组"><a class="anchor" href="#分组">#</a> 分组</h4><p><strong><code>group by</code> </strong>：</p><ul><li><code>group by</code> 子句将记录分组到汇总行中。</li><li><code>group by</code> 为每个组返回一个记录。</li><li><code>group by</code> 通常还涉及聚合 <code>count</code> ， <code>max</code> ， <code>sum</code> ， <code>avg</code> 等。</li><li><code>group by</code> 可以按一列或多列进行分组。</li><li><code>group by</code> 按分组字段进行排序后， <code>order by</code> 可以以汇总字段来进行排序。</li></ul><p><strong>分组</strong></p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">SELECT</span> cust_name<span class="token punctuation">,</span> <span class="token function">COUNT</span><span class="token punctuation">(</span>cust_address<span class="token punctuation">)</span> <span class="token keyword">AS</span> addr_num</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">FROM</span> Customers <span class="token keyword">GROUP</span> <span class="token keyword">BY</span> cust_name<span class="token punctuation">;</span></pre></td></tr></table></figure><p><strong>分组后排序</strong></p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">SELECT</span> cust_name<span class="token punctuation">,</span> <span class="token function">COUNT</span><span class="token punctuation">(</span>cust_address<span class="token punctuation">)</span> <span class="token keyword">AS</span> addr_num</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">FROM</span> Customers <span class="token keyword">GROUP</span> <span class="token keyword">BY</span> cust_name</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">ORDER</span> <span class="token keyword">BY</span> cust_name <span class="token keyword">DESC</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p><strong><code>having</code> </strong>：</p><ul><li><code>having</code> <font color="red">用于对汇总的 <code>group by</code> 结果进行过滤</font>。</li><li><code>having</code> 一般都是和 <code>group by</code> 连用。</li><li><code>where</code> 和 <code>having</code> 可以在相同的查询中。</li></ul><p><strong>使用 WHERE 和 HAVING 过滤数据</strong></p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">SELECT</span> cust_name<span class="token punctuation">,</span> <span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> num</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">FROM</span> Customers</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">WHERE</span> cust_email <span class="token operator">IS</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">GROUP</span> <span class="token keyword">BY</span> cust_name</pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">HAVING</span> <span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p><strong><code>having</code> vs <code>where</code> </strong>：</p><ul><li><code>where</code> ：<ul><li><font color="red">过滤指定的<u>行</u></font></li><li><font color="red">后面不能加聚合函数</font>（分组函数）</li><li><font color="red">在 <code>group by</code> 前使用</font></li></ul></li><li><code>having</code> ：<ul><li><font color="red">过滤<u>分组</u></font></li><li>一般都是和 <code>group by</code> 连用，<font color="red">不能单独使用</font></li><li><font color="red">在 <code>group by</code> 之后使用</font></li></ul></li></ul><h4 id="子查询"><a class="anchor" href="#子查询">#</a> 子查询</h4><p>子查询是嵌套在较大查询中的 SQL 查询，也称内部查询或内部选择，包含子查询的语句也称为外部查询或外部选择。简单来说，子查询就是指<font color="red">将一个 <code>select</code> 查询（子查询）的结果作为另一个 SQL 语句（主查询）的<u>数据来源</u>或者<u>判断条件</u></font>。</p><p>子查询可以嵌入 <code>SELECT</code> 、 <code>INSERT</code> 、 <code>UPDATE</code> 和 <code>DELETE</code> 语句中，也可以和 <code>=</code> 、 <code>&lt;</code> 、 <code>&gt;</code> 、 <code>IN</code> 、 <code>BETWEEN</code> 、 <code>EXISTS</code> 等运算符一起使用。</p><p>子查询常用在 <code>WHERE</code> 子句和 <code>FROM</code> 子句后边：</p><ul><li><p>当用于 <strong><code>WHERE</code> </strong>子句后边时，根据不同的运算符，子查询可以返回单行单列、多行单列、单行多列数据。子查询就是要<font color="red">返回能够作为 <code>WHERE</code> 子句查询条件的值</font>。</p><blockquote><p>用于 <code>WHERE</code> 子句的子查询的基本语法如下：</p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">select</span> column_name <span class="token punctuation">[</span><span class="token punctuation">,</span> column_name <span class="token punctuation">]</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">from</span>   table1 <span class="token punctuation">[</span><span class="token punctuation">,</span> table2 <span class="token punctuation">]</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">where</span>  column_name operator</pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token punctuation">(</span><span class="token keyword">select</span> column_name <span class="token punctuation">[</span><span class="token punctuation">,</span> column_name <span class="token punctuation">]</span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">from</span> table1 <span class="token punctuation">[</span><span class="token punctuation">,</span> table2 <span class="token punctuation">]</span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token punctuation">[</span><span class="token keyword">where</span><span class="token punctuation">]</span><span class="token punctuation">)</span></pre></td></tr></table></figure><ul><li>子查询需要放在括号 <code>( )</code> 内。</li><li><code>operator</code> 表示用于 where 子句的运算符。</li></ul></blockquote></li><li><p>当用于 <strong><code>FROM</code> </strong>子句后边时，一般返回多行多列数据，相当于<font color="red">返回一张临时表</font>，这样才符合 <code>FROM</code> 后面是表的规则。这种做法能够实现<font color="red">多表联合查询</font>。</p><blockquote><p>用于 <code>FROM</code> 子句的子查询的基本语法如下：</p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">select</span> column_name <span class="token punctuation">[</span><span class="token punctuation">,</span> column_name <span class="token punctuation">]</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">from</span> <span class="token punctuation">(</span><span class="token keyword">select</span> column_name <span class="token punctuation">[</span><span class="token punctuation">,</span> column_name <span class="token punctuation">]</span></pre></td></tr><tr><td data-num="3"></td><td><pre>   <span class="token keyword">from</span> table1 <span class="token punctuation">[</span><span class="token punctuation">,</span> table2 <span class="token punctuation">]</span></pre></td></tr><tr><td data-num="4"></td><td><pre>   <span class="token punctuation">[</span><span class="token keyword">where</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">as</span> temp_table_name</pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">where</span>  condition</pre></td></tr></table></figure><p>用于 <code>FROM</code> 的子查询返回的结果相当于一张临时表，所以<strong>需要使用 <code>AS</code> 关键字为该临时表起一个名字</strong>。</p></blockquote></li></ul><blockquote><p>注意：MYSQL 数据库从 4.1 版本才开始支持子查询，早期版本是不支持的。</p></blockquote><p><strong>子查询的子查询</strong></p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">SELECT</span> cust_name<span class="token punctuation">,</span> cust_contact</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">FROM</span> customers</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">WHERE</span> cust_id <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> cust_id</pre></td></tr><tr><td data-num="4"></td><td><pre>                  <span class="token keyword">FROM</span> orders</pre></td></tr><tr><td data-num="5"></td><td><pre>                  <span class="token keyword">WHERE</span> order_num <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> order_num</pre></td></tr><tr><td data-num="6"></td><td><pre>                                      <span class="token keyword">FROM</span> orderitems</pre></td></tr><tr><td data-num="7"></td><td><pre>                                      <span class="token keyword">WHERE</span> prod_id <span class="token operator">=</span> <span class="token string">'RGAN01'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>内部查询首先在其父查询之前执行，以便可以将内部查询的结果传递给外部查询。执行过程可以参考下图：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/c439da1f5d4e4b00bdfa4316b933d764%7Etplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><h5 id="where"><a class="anchor" href="#where">#</a> WHERE</h5><ul><li><code>WHERE</code> 子句用于过滤记录，即缩小访问数据的范围。</li><li><code>WHERE</code> 后跟一个返回 <code>true</code> 或 <code>false</code> 的条件。</li><li><code>WHERE</code> 可以与 <code>SELECT</code> ， <code>UPDATE</code> 和 <code>DELETE</code> 一起使用。</li><li>可以在 <code>WHERE</code> 子句中使用的操作符。</li></ul><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>=</td><td>等于</td></tr><tr><td>&lt;&gt;</td><td>不等于。注释：在 SQL 的一些版本中，该操作符可被写成！=</td></tr><tr><td>&gt;</td><td>大于</td></tr><tr><td>&lt;</td><td>小于</td></tr><tr><td>&gt;=</td><td>大于等于</td></tr><tr><td>&lt;=</td><td>小于等于</td></tr><tr><td>BETWEEN</td><td>在某个范围内</td></tr><tr><td>LIKE</td><td>搜索某种模式</td></tr><tr><td>IN</td><td>指定针对某个列的多个可能值</td></tr></tbody></table><p><strong><code>SELECT</code> 语句中的 <code>WHERE</code> 子句</strong></p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> Customers</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">WHERE</span> cust_name <span class="token operator">=</span> <span class="token string">'Kids Place'</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p><strong><code>UPDATE</code> 语句中的 <code>WHERE</code> 子句</strong></p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">UPDATE</span> Customers</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">SET</span> cust_name <span class="token operator">=</span> <span class="token string">'Jack Jones'</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">WHERE</span> cust_name <span class="token operator">=</span> <span class="token string">'Kids Place'</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p><strong><code>DELETE</code> 语句中的 <code>WHERE</code> 子句</strong></p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">DELETE</span> <span class="token keyword">FROM</span> Customers</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">WHERE</span> cust_name <span class="token operator">=</span> <span class="token string">'Kids Place'</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h5 id="in-和-between"><a class="anchor" href="#in-和-between">#</a> IN 和 BETWEEN</h5><ul><li><code>IN</code> 操作符在 <code>WHERE</code> 子句中使用，作用是<font color="red">在指定的几个特定值中任选一个值</font>。</li><li><code>BETWEEN</code> 操作符在 <code>WHERE</code> 子句中使用，作用是<font color="red">选取介于某个范围内的值</font>。</li></ul><p><strong>IN 示例</strong></p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">SELECT</span> <span class="token operator">*</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">FROM</span> products</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">WHERE</span> vend_id <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token string">'DLL01'</span><span class="token punctuation">,</span> <span class="token string">'BRS01'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p><strong>BETWEEN 示例</strong></p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">SELECT</span> <span class="token operator">*</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">FROM</span> products</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">WHERE</span> prod_price <span class="token operator">BETWEEN</span> <span class="token number">3</span> <span class="token operator">AND</span> <span class="token number">5</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h5 id="and-or-not"><a class="anchor" href="#and-or-not">#</a> AND、OR、NOT</h5><ul><li><code>AND</code> 、 <code>OR</code> 、 <code>NOT</code> 是用于对过滤条件的逻辑处理指令。</li><li><font color="red"><code>AND</code> 优先级高于 <code>OR</code> </font>，为了明确处理顺序，可以使用 <code>()</code> 。</li><li><code>AND</code> 操作符表示左右条件都要满足。</li><li><code>OR</code> 操作符表示左右条件满足任意一个即可。</li><li><code>NOT</code> 操作符用于否定一个条件。</li></ul><p><strong>AND 示例</strong></p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">SELECT</span> prod_id<span class="token punctuation">,</span> prod_name<span class="token punctuation">,</span> prod_price</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">FROM</span> products</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">WHERE</span> vend_id <span class="token operator">=</span> <span class="token string">'DLL01'</span> <span class="token operator">AND</span> prod_price <span class="token operator">&lt;=</span> <span class="token number">4</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p><strong>OR 示例</strong></p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">SELECT</span> prod_id<span class="token punctuation">,</span> prod_name<span class="token punctuation">,</span> prod_price</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">FROM</span> products</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">WHERE</span> vend_id <span class="token operator">=</span> <span class="token string">'DLL01'</span> <span class="token operator">OR</span> vend_id <span class="token operator">=</span> <span class="token string">'BRS01'</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p><strong>NOT 示例</strong></p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">SELECT</span> <span class="token operator">*</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">FROM</span> products</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">WHERE</span> prod_price <span class="token operator">NOT</span> <span class="token operator">BETWEEN</span> <span class="token number">3</span> <span class="token operator">AND</span> <span class="token number">5</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h5 id="like"><a class="anchor" href="#like">#</a> LIKE</h5><ul><li><code>LIKE</code> 操作符在 <code>WHERE</code> 子句中使用，作用是<font color="red">确定字符串是否匹配模式</font>。</li><li>只有字段是文本值时才使用 <code>LIKE</code> 。</li><li><code>LIKE</code> 支持两个通配符匹配选项： <code>%</code> 和 <code>_</code> 。</li><li>不要滥用通配符，通配符位于开头处匹配会非常慢。</li><li><code>%</code> 表示任何字符<font color="red">出现任意次数</font>。</li><li><code>_</code> 表示任何字符<font color="red">出现一次</font>。</li></ul><p><strong>% 示例</strong></p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">SELECT</span> prod_id<span class="token punctuation">,</span> prod_name<span class="token punctuation">,</span> prod_price</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">FROM</span> products</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">WHERE</span> prod_name <span class="token operator">LIKE</span> <span class="token string">'%bean bag%'</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p><strong>_ 示例</strong></p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">SELECT</span> prod_id<span class="token punctuation">,</span> prod_name<span class="token punctuation">,</span> prod_price</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">FROM</span> products</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">WHERE</span> prod_name <span class="token operator">LIKE</span> <span class="token string">'__ inch teddy bear'</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h4 id="连接"><a class="anchor" href="#连接">#</a> 连接</h4><p>JOIN 是 “连接” 的意思，顾名思义，SQL JOIN 子句用于将两个或者多个表联合起来进行查询。</p><p>连接表时<font color="red">需要在每个表中选择一个字段，并对这些字段的值进行比较，值相同的两条记录将合并为一条</font>。<strong>连接表的本质就是将不同表的记录合并起来，形成一张新表。当然，这张新表只是临时的，它仅存在于本次查询期间</strong>。</p><p>使用 <code>JOIN</code> 连接两个表的基本语法如下：</p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">select</span> table1<span class="token punctuation">.</span>column1<span class="token punctuation">,</span> table2<span class="token punctuation">.</span>column2<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">from</span> table1</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">join</span> table2</pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">on</span> table1<span class="token punctuation">.</span>common_column1 <span class="token operator">=</span> table2<span class="token punctuation">.</span>common_column2<span class="token punctuation">;</span></pre></td></tr></table></figure><p><code>table1.common_column1 = table2.common_column2</code> 是<font color="red">连接条件</font>，只有满足此条件的记录才会合并为一行。您可以使用多个运算符来连接表，例如 =、&gt;、&lt;、&lt;&gt;、&lt;=、&gt;=、!=、 <code>between</code> 、 <code>like</code> 或者 <code>not</code> ，但是最常见的是使用 =。</p><p><font color="red">当两个表中有同名的字段时，为了帮助数据库引擎区分是哪个表的字段，在书写同名字段名时需要加上表名</font>。当然，如果书写的字段名在两个表中是唯一的，也可以不使用以上格式，只写字段名即可。</p><p>另外，<font color="red">如果两张表的关联字段名相同，也可以使用 <code>USING</code> 子句来代替 <code>ON</code> </font>，举个例子：</p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment"># join....on</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">select</span> c<span class="token punctuation">.</span>cust_name<span class="token punctuation">,</span> o<span class="token punctuation">.</span>order_num</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">from</span> Customers c</pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">inner</span> <span class="token keyword">join</span> Orders o</pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">on</span> c<span class="token punctuation">.</span>cust_id <span class="token operator">=</span> o<span class="token punctuation">.</span>cust_id</pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">order</span> <span class="token keyword">by</span> c<span class="token punctuation">.</span>cust_name<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token comment"># 如果两张表的关联字段名相同，也可以使用 USING 子句：join....using ()</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">select</span> c<span class="token punctuation">.</span>cust_name<span class="token punctuation">,</span> o<span class="token punctuation">.</span>order_num</pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token keyword">from</span> Customers c</pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token keyword">inner</span> <span class="token keyword">join</span> Orders o</pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token keyword">using</span><span class="token punctuation">(</span>cust_id<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token keyword">order</span> <span class="token keyword">by</span> c<span class="token punctuation">.</span>cust_name<span class="token punctuation">;</span></pre></td></tr></table></figure><p><strong><code>ON</code> 和 <code>WHERE</code> 的区别</strong>：</p><ul><li>连接表时，SQL 会根据连接条件生成一张新的临时表。 <code>ON</code> 就是连接条件，它决定临时表的生成。</li><li><code>WHERE</code> 是在临时表生成以后，再对临时表中的数据进行过滤，生成最终的结果集，这个时候已经没有 JOIN-ON 了。</li></ul><p>所以总结来说就是：<strong>SQL 先根据 ON 生成一张临时表，然后再根据 WHERE 对临时表进行筛选</strong>。</p><p>SQL 允许在 <code>JOIN</code> 左边加上一些修饰性的关键词，从而形成不同类型的连接，如下表所示：</p><table><thead><tr><th>连接类型</th><th>说明</th></tr></thead><tbody><tr><td><code>INNER JOIN</code> 内连接</td><td>（<strong>默认连接方式</strong>）只有当<font color="red">两个表都存在满足条件</font>的记录时才会返回行。</td></tr><tr><td><code>LEFT JOIN</code> / LEFT OUTER JOIN 左 (外) 连接</td><td><font color="red">返回左表中的所有行，即使右表中没有满足条件</font>的行也是如此。</td></tr><tr><td><code>RIGHT JOIN</code> / RIGHT OUTER JOIN 右 (外) 连接</td><td><font color="red">返回右表中的所有行，即使左表中没有满足条件</font>的行也是如此。</td></tr><tr><td><code>FULL JOIN</code> / FULL OUTER JOIN 全 (外) 连接</td><td>只要<font color="red">其中有一个表存在满足条件</font>的记录，就返回行。</td></tr><tr><td><code>SELF JOIN</code></td><td><font color="red">将一个表连接到自身</font>，就像该表是两个表一样。为了区分两个表，在 SQL 语句中需要至少重命名一个表。</td></tr><tr><td><code>CROSS JOIN</code></td><td>交叉连接，从两个或者多个连接表中返回记录集的<font color="red">笛卡尔积</font>。</td></tr></tbody></table><p>下图展示了 LEFT JOIN、RIGHT JOIN、INNER JOIN、OUTER JOIN 相关的 7 种用法。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/701670942f0f45d3a3a2187cd04a12ad~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p>如果不加任何修饰词，只写 <code>JOIN</code> ，那么默认为 <code>INNER JOIIN</code></p><p>对于 <code>INNER JOIIN</code> 来说，还有一种隐式的写法，称为 “<strong>隐式内连接</strong>”，也就是没有 <code>INNER JOIIN</code> 关键字，使用 <code>WHERE</code> 语句实现内连接的功能</p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment"># 隐式内连接</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">select</span> c<span class="token punctuation">.</span>cust_name<span class="token punctuation">,</span> o<span class="token punctuation">.</span>order_num</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">from</span> Customers c<span class="token punctuation">,</span> Orders o</pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">where</span> c<span class="token punctuation">.</span>cust_id <span class="token operator">=</span> o<span class="token punctuation">.</span>cust_id</pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">order</span> <span class="token keyword">by</span> c<span class="token punctuation">.</span>cust_name<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token comment"># 显式内连接</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token keyword">select</span> c<span class="token punctuation">.</span>cust_name<span class="token punctuation">,</span> o<span class="token punctuation">.</span>order_num</pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">from</span> Customers c <span class="token keyword">inner</span> <span class="token keyword">join</span> Orders o</pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token keyword">using</span><span class="token punctuation">(</span>cust_id<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token keyword">order</span> <span class="token keyword">by</span> c<span class="token punctuation">.</span>cust_name<span class="token punctuation">;</span></pre></td></tr></table></figure><h4 id="组合"><a class="anchor" href="#组合">#</a> 组合</h4><p><code>UNION</code> 运算符<font color="red">将两个或更多查询的结果组合起来，并生成一个结果集</font>，其中包含来自 <code>UNION</code> 中参与查询的提取行。</p><p><code>UNION</code> 基本规则：</p><ul><li>所有查询的<font color="red">列数和列顺序必须相同</font>。</li><li>每个查询中涉及表的<font color="red">列的数据类型必须相同或兼容</font>。</li><li>通常<font color="red">返回的列名取自第一个查询</font>。</li></ul><p>默认地， <code>UNION</code> 操作符选取不同的值。如果允许重复的值，请使用 <code>UNION ALL</code> 。</p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">SELECT</span> column_name<span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token keyword">FROM</span> table1</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">UNION</span> <span class="token keyword">ALL</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">SELECT</span> column_name<span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token keyword">FROM</span> table2<span class="token punctuation">;</span></pre></td></tr></table></figure><p><code>UNION</code> 结果集中的列名总是等于 <code>UNION</code> 中第一个 <code>SELECT</code> 语句中的列名。</p><p><code>JOIN</code> vs <code>UNION</code> ：</p><ul><li><code>JOIN</code> 中连接表的列可能不同，但在 <code>UNION</code> 中，所有查询的列数和列顺序必须相同。</li><li><code>UNION</code> 将查询之后的行放在一起（<font color="red">垂直放置</font>），但 <code>JOIN</code> 将查询之后的列放在一起（水平放置），即它构成一个笛卡尔积。</li></ul><h4 id="函数"><a class="anchor" href="#函数">#</a> 函数</h4><p>不同数据库的函数往往各不相同，因此不可移植。本节主要<font color="red">以 MysSQL 的函数为例</font>。</p><h5 id="文本处理"><a class="anchor" href="#文本处理">#</a> 文本处理</h5><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td><code>LEFT()</code> 、 <code>RIGHT()</code></td><td>左边或者右边的字符</td></tr><tr><td><code>LOWER()</code> 、 <code>UPPER()</code></td><td>转换为小写或者大写</td></tr><tr><td><code>LTRIM()</code> 、 <code>RTRIM()</code></td><td>去除左边或者右边的空格</td></tr><tr><td><code>LENGTH()</code></td><td>长度</td></tr><tr><td><code>SOUNDEX()</code></td><td><font color="red">转换为语音值</font></td></tr></tbody></table><p>其中， <strong><code>SOUNDEX()</code> </strong>可以将一个字符串转换为描述其语音表示的字母数字模式。</p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">SELECT</span> <span class="token operator">*</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">FROM</span> mytable</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">WHERE</span> SOUNDEX<span class="token punctuation">(</span>col1<span class="token punctuation">)</span> <span class="token operator">=</span> SOUNDEX<span class="token punctuation">(</span><span class="token string">'apple'</span><span class="token punctuation">)</span></pre></td></tr></table></figure><h5 id="日期和时间处理"><a class="anchor" href="#日期和时间处理">#</a> 日期和时间处理</h5><ul><li>日期格式： <code>YYYY-MM-DD</code></li><li>时间格式： <code>HH:MM:SS</code></li></ul><table><thead><tr><th>函 数</th><th>说 明</th></tr></thead><tbody><tr><td><code>AddDate()</code></td><td>增加一个日期（天、周等）</td></tr><tr><td><code>AddTime()</code></td><td>增加一个时间（时、分等）</td></tr><tr><td><code>CurDate()</code></td><td>返回当前日期</td></tr><tr><td><code>CurTime()</code></td><td>返回当前时间</td></tr><tr><td><code>Date()</code></td><td>返回日期时间的日期部分</td></tr><tr><td><code>DateDiff()</code></td><td>计算两个日期之差</td></tr><tr><td><code>Date_Add()</code></td><td>高度灵活的日期运算函数</td></tr><tr><td><code>Date_Format()</code></td><td>返回一个格式化的日期或时间串</td></tr><tr><td><code>Day()</code></td><td>返回一个日期的天数部分</td></tr><tr><td><code>DayOfWeek()</code></td><td>对于一个日期，返回对应的星期几</td></tr><tr><td><code>Hour()</code></td><td>返回一个时间的小时部分</td></tr><tr><td><code>Minute()</code></td><td>返回一个时间的分钟部分</td></tr><tr><td><code>Month()</code></td><td>返回一个日期的月份部分</td></tr><tr><td><code>Now()</code></td><td>返回当前日期和时间</td></tr><tr><td><code>Second()</code></td><td>返回一个时间的秒部分</td></tr><tr><td><code>Time()</code></td><td>返回一个日期时间的时间部分</td></tr><tr><td><code>Year()</code></td><td>返回一个日期的年份部分</td></tr></tbody></table><h5 id="数值处理"><a class="anchor" href="#数值处理">#</a> 数值处理</h5><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>SIN()</td><td>正弦</td></tr><tr><td>COS()</td><td>余弦</td></tr><tr><td>TAN()</td><td>正切</td></tr><tr><td>ABS()</td><td>绝对值</td></tr><tr><td>SQRT()</td><td>平方根</td></tr><tr><td>MOD()</td><td>余数</td></tr><tr><td>EXP()</td><td>指数</td></tr><tr><td>PI()</td><td>圆周率</td></tr><tr><td>RAND()</td><td>随机数</td></tr></tbody></table><h5 id="汇总"><a class="anchor" href="#汇总">#</a> 汇总</h5><table><thead><tr><th>函 数</th><th>说 明</th></tr></thead><tbody><tr><td><code>AVG()</code></td><td>返回某列的平均值</td></tr><tr><td><code>COUNT()</code></td><td>返回某列的行数</td></tr><tr><td><code>MAX()</code></td><td>返回某列的最大值</td></tr><tr><td><code>MIN()</code></td><td>返回某列的最小值</td></tr><tr><td><code>SUM()</code></td><td>返回某列值之和</td></tr></tbody></table><p><code>AVG()</code> 会忽略 NULL 行。</p><p>使用 <code>DISTINCT</code> 可以让汇总函数值汇总不同的值。</p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">SELECT</span> <span class="token function">AVG</span><span class="token punctuation">(</span><span class="token keyword">DISTINCT</span> col1<span class="token punctuation">)</span> <span class="token keyword">AS</span> avg_col</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">FROM</span> mytable</pre></td></tr></table></figure><p><strong>接下来，我们来介绍 DDL 语句用法。DDL 的主要功能是定义数据库对象（如：数据库、数据表、视图、索引等）</strong></p><h4 id="数据定义"><a class="anchor" href="#数据定义">#</a> <mark>数据定义</mark></h4><h5 id="数据库database"><a class="anchor" href="#数据库database">#</a> 数据库（DATABASE）</h5><h6 id="创建数据库"><a class="anchor" href="#创建数据库">#</a> 创建数据库</h6><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">CREATE</span> <span class="token keyword">DATABASE</span> test<span class="token punctuation">;</span></pre></td></tr></table></figure><h6 id="删除数据库"><a class="anchor" href="#删除数据库">#</a> 删除数据库</h6><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">DROP</span> <span class="token keyword">DATABASE</span> test<span class="token punctuation">;</span></pre></td></tr></table></figure><h6 id="选择数据库"><a class="anchor" href="#选择数据库">#</a> 选择数据库</h6><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">USE</span> test<span class="token punctuation">;</span></pre></td></tr></table></figure><h5 id="数据表table"><a class="anchor" href="#数据表table">#</a> 数据表（TABLE）</h5><h6 id="创建数据表"><a class="anchor" href="#创建数据表">#</a> 创建数据表</h6><p><strong>普通创建</strong></p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token keyword">user</span> <span class="token punctuation">(</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  id <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token keyword">unsigned</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'Id'</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  username <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">64</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token string">'default'</span> <span class="token keyword">COMMENT</span> <span class="token string">'用户名'</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="4"></td><td><pre>  password <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">64</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token string">'default'</span> <span class="token keyword">COMMENT</span> <span class="token string">'密码'</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="5"></td><td><pre>  email <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">64</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token string">'default'</span> <span class="token keyword">COMMENT</span> <span class="token string">'邮箱'</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">)</span> <span class="token keyword">COMMENT</span><span class="token operator">=</span><span class="token string">'用户表'</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p><strong>根据已有的表创建新表</strong></p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> vip_user <span class="token keyword">AS</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> <span class="token keyword">user</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h6 id="删除数据表"><a class="anchor" href="#删除数据表">#</a> 删除数据表</h6><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">DROP</span> <span class="token keyword">TABLE</span> <span class="token keyword">user</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h6 id="修改数据表"><a class="anchor" href="#修改数据表">#</a> 修改数据表</h6><p><strong>添加列</strong></p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> <span class="token keyword">user</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">ADD</span> age <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p><strong>删除列</strong></p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> <span class="token keyword">user</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">DROP</span> <span class="token keyword">COLUMN</span> age<span class="token punctuation">;</span></pre></td></tr></table></figure><p><strong>修改列</strong></p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> <span class="token identifier"><span class="token punctuation">`</span>user<span class="token punctuation">`</span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">MODIFY</span> <span class="token keyword">COLUMN</span> age <span class="token keyword">tinyint</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p><strong>添加主键</strong></p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> <span class="token keyword">user</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">ADD</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p><strong>删除主键</strong></p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> <span class="token keyword">user</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">DROP</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h5 id="视图view"><a class="anchor" href="#视图view">#</a> 视图（VIEW）</h5><p>定义：</p><ul><li>视图是基于 SQL 语句的结果集的可视化的表。</li><li>视图是<strong>虚拟的表，本身不包含数据</strong>，也就不能对其进行索引操作。对视图的操作和对普通表的操作一样。</li></ul><p>作用：</p><ul><li>简化复杂的 SQL 操作，比如复杂的联结；</li><li>只使用实际表的一部分数据；</li><li><font color="red">通过只给用户访问视图的权限，保证数据的安全性</font>；</li><li>更改数据格式和表示。</li></ul><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/ec4c975296ea4a7097879dac7c353878%7Etplv-k3u1fbpfcp-zoom-1.image" alt="mysql视图"></p><h6 id="创建视图"><a class="anchor" href="#创建视图">#</a> 创建视图</h6><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">CREATE</span> <span class="token keyword">VIEW</span> top_10_user_view <span class="token keyword">AS</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">SELECT</span> id<span class="token punctuation">,</span> username</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">FROM</span> <span class="token keyword">user</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">WHERE</span> id <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h6 id="删除视图"><a class="anchor" href="#删除视图">#</a> 删除视图</h6><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">DROP</span> <span class="token keyword">VIEW</span> top_10_user_view<span class="token punctuation">;</span></pre></td></tr></table></figure><h5 id="索引index"><a class="anchor" href="#索引index">#</a> 索引（INDEX）</h5><p><strong>索引是一种用于快速查询和检索数据的数据结构，其本质可以看成是一种排序好的数据结构。</strong></p><p>索引的作用就<font color="red">相当于书的目录</font>。打个比方：我们在查字典的时候，如果没有目录，那我们就只能一页一页的去找我们需要查的那个字，速度很慢。如果有目录了，我们只需要先去目录里查找字的位置，然后直接翻到那一页就行了。</p><p><strong>优点</strong> ：</p><ul><li>使用索引可以大大<font color="red">加快数据的检索速度</font>（大大减少检索的数据量）, 这也是创建索引的最主要的原因。</li><li>通过创建<font color="red">唯一性索引，可以保证数据库表中每一行数据的唯一性</font>。</li></ul><p><strong>缺点</strong> ：</p><ul><li>创建索引和维护索引需要耗费许多时间。当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低 SQL 执行效率。</li><li>索引需要使用物理文件存储，也会耗费一定空间。</li></ul><p>但是，<strong>使用索引一定能提高查询性能吗？</strong></p><p>大多数情况下，索引查询都是比全表扫描要快的。但是<font color="red">如果数据库的数据量不大，那么使用索引也不一定能够带来很大提升</font>。</p><p>关于索引的详细介绍，请看我写的 <span class="exturl" data-url="aHR0cHM6Ly9qYXZhZ3VpZGUuY24vZGF0YWJhc2UvbXlzcWwvbXlzcWwtaW5kZXguaHRtbA==">MySQL 索引详解 open in new window</span> 这篇文章。</p><h6 id="创建索引"><a class="anchor" href="#创建索引">#</a> 创建索引</h6><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">CREATE</span> <span class="token keyword">INDEX</span> user_index</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">ON</span> <span class="token keyword">user</span> <span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h6 id="添加索引"><a class="anchor" href="#添加索引">#</a> 添加索引</h6><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">ALTER</span> <span class="token keyword">table</span> <span class="token keyword">user</span> <span class="token keyword">ADD</span> <span class="token keyword">INDEX</span> user_index<span class="token punctuation">(</span>id<span class="token punctuation">)</span></pre></td></tr></table></figure><h6 id="创建唯一索引"><a class="anchor" href="#创建唯一索引">#</a> 创建唯一索引</h6><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">CREATE</span> <span class="token keyword">UNIQUE</span> <span class="token keyword">INDEX</span> user_index</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">ON</span> <span class="token keyword">user</span> <span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h6 id="删除索引"><a class="anchor" href="#删除索引">#</a> 删除索引</h6><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> <span class="token keyword">user</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">DROP</span> <span class="token keyword">INDEX</span> user_index<span class="token punctuation">;</span></pre></td></tr></table></figure><h5 id="约束"><a class="anchor" href="#约束">#</a> 约束</h5><p>SQL 约束<strong>用于规定表中的数据规则</strong>。</p><p>如果存在违反约束的数据行为，行为会被约束终止。</p><p>约束可以在创建表时规定（通过 CREATE TABLE 语句），或者在表创建之后规定（通过 ALTER TABLE 语句）。</p><p>约束类型：</p><ul><li><code>NOT NULL</code> - 指示某列不能存储 NULL 值。</li><li><code>UNIQUE</code> - 保证某列的每行必须有唯一的值。</li><li><code>PRIMARY KEY</code> - NOT NULL 和 UNIQUE 的结合。确保某列（或两个列多个列的结合）有唯一标识，有助于更容易更快速地找到表中的一个特定的记录。</li><li><code>FOREIGN KEY</code> - 保证一个表中的数据匹配另一个表中的值的参照完整性。</li><li><code>CHECK</code> - 保证列中的值符合指定的条件。</li><li><code>DEFAULT</code> - 规定没有给列赋值时的默认值。</li></ul><p>创建表时使用约束条件：</p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> Users <span class="token punctuation">(</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  Id <span class="token keyword">INT</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token keyword">UNSIGNED</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span> <span class="token keyword">COMMENT</span> <span class="token string">'自增Id'</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  Username <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">64</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">UNIQUE</span> <span class="token keyword">DEFAULT</span> <span class="token string">'default'</span> <span class="token keyword">COMMENT</span> <span class="token string">'用户名'</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="4"></td><td><pre>  Password <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">64</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token string">'default'</span> <span class="token keyword">COMMENT</span> <span class="token string">'密码'</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="5"></td><td><pre>  Email <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">64</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token string">'default'</span> <span class="token keyword">COMMENT</span> <span class="token string">'邮箱地址'</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="6"></td><td><pre>  Enabled <span class="token keyword">TINYINT</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'是否有效'</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="7"></td><td><pre>  <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span>Id<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token operator">=</span><span class="token number">2</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8mb4 <span class="token keyword">COMMENT</span><span class="token operator">=</span><span class="token string">'用户表'</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p><strong>接下来，我们来介绍 TCL 语句用法。TCL 的主要功能是管理数据库中的事务。</strong></p><h4 id="事务处理"><a class="anchor" href="#事务处理">#</a> 事务处理</h4><p>不能回退 <code>SELECT</code> 语句，回退 <code>SELECT</code> 语句也没意义；也不能回退 <code>CREATE</code> 和 <code>DROP</code> 语句。</p><p><strong>MySQL 默认是隐式提交</strong>，每执行一条语句就把这条语句当成一个事务然后进行提交。当出现 <code>START TRANSACTION</code> 语句时，会关闭隐式提交；当 <code>COMMIT</code> 或 <code>ROLLBACK</code> 语句执行后，事务会自动关闭，重新恢复隐式提交。</p><p>通过 <code>set autocommit=0</code> 可以取消自动提交，直到 <code>set autocommit=1</code> 才会提交；<font color="red"> <code>autocommit</code> 标记是针对每个连接而不是针对服务器的</font>。</p><p>指令：</p><ul><li><code>START TRANSACTION</code> - 指令用于<font color="red">标记事务的起始点</font>。</li><li><code>SAVEPOINT</code> - 指令用于<font color="red">创建保留点</font>。</li><li><code>ROLLBACK TO</code> - 指令用于<font color="red">回滚到指定的保留点</font>；如果没有设置保留点，则回退到 <code>START TRANSACTION</code> 语句处。</li><li><code>COMMIT</code> - <font color="red">提交事务</font>。</li></ul><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">-- 开始事务</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">START</span> <span class="token keyword">TRANSACTION</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment">-- 插入操作 A</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>user<span class="token punctuation">`</span></span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'root1'</span><span class="token punctuation">,</span> <span class="token string">'root1'</span><span class="token punctuation">,</span> <span class="token string">'xxxx@163.com'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token comment">-- 创建保留点 updateA</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">SAVEPOINT</span> updateA<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token comment">-- 插入操作 B</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>user<span class="token punctuation">`</span></span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">'root2'</span><span class="token punctuation">,</span> <span class="token string">'root2'</span><span class="token punctuation">,</span> <span class="token string">'xxxx@163.com'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token comment">-- 回滚到保留点 updateA</span></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token keyword">ROLLBACK</span> <span class="token keyword">TO</span> updateA<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token comment">-- 提交事务，只有操作 A 生效</span></pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token keyword">COMMIT</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p><strong>接下来，我们来介绍 DCL 语句用法。DCL 的主要功能是控制用户的访问权限。</strong></p><h4 id="权限控制"><a class="anchor" href="#权限控制">#</a> 权限控制</h4><p>要授予用户帐户权限，可以用 <code>GRANT</code> 命令。有撤销用户的权限，可以用 <code>REVOKE</code> 命令。这里以 MySQl 为例，介绍权限控制实际应用。</p><p><code>GRANT</code> 授予权限语法：</p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">GRANT</span> privilege<span class="token punctuation">,</span><span class="token punctuation">[</span>privilege<span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">ON</span> privilege_level</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">TO</span> <span class="token keyword">user</span> <span class="token punctuation">[</span>IDENTIFIED <span class="token keyword">BY</span> password<span class="token punctuation">]</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">[</span><span class="token keyword">REQUIRE</span> tsl_option<span class="token punctuation">]</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">[</span><span class="token keyword">WITH</span> <span class="token punctuation">[</span>GRANT_OPTION <span class="token operator">|</span> resource_option<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>简单解释一下：</p><ol><li>在 <code>GRANT</code> 关键字后指定一个或多个权限。如果授予用户多个权限，则每个权限由逗号分隔。</li><li><code>ON privilege_level</code> 确定权限应用级别。MySQL 支持 global（ <code>*.*</code> ），database（ <code>database.*</code> ），table（ <code>database.table</code> ）和列级别。如果使用列权限级别，则必须在每个权限之后指定一个或逗号分隔列的列表。</li><li><code>user</code> 是要授予权限的用户。如果用户已存在，则 <code>GRANT</code> 语句将修改其权限。否则， <code>GRANT</code> 语句将创建一个新用户。可选子句 <code>IDENTIFIED BY</code> 允许您为用户设置新的密码。</li><li><code>REQUIRE tsl_option</code> 指定用户是否必须通过 SSL，X059 等安全连接连接到数据库服务器。</li><li>可选 <code>WITH GRANT OPTION</code> 子句允许您授予其他用户或从其他用户中删除您拥有的权限。此外，您可以使用 <code>WITH</code> 子句分配 MySQL 数据库服务器的资源，例如，设置用户每小时可以使用的连接数或语句数。这在 MySQL 共享托管等共享环境中非常有用。</li></ol><p><code>REVOKE</code> 撤销权限语法：</p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">REVOKE</span>   privilege_type <span class="token punctuation">[</span><span class="token punctuation">(</span>column_list<span class="token punctuation">)</span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="2"></td><td><pre>        <span class="token punctuation">[</span><span class="token punctuation">,</span> priv_type <span class="token punctuation">[</span><span class="token punctuation">(</span>column_list<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">ON</span> <span class="token punctuation">[</span>object_type<span class="token punctuation">]</span> privilege_level</pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">FROM</span> <span class="token keyword">user</span> <span class="token punctuation">[</span><span class="token punctuation">,</span> <span class="token keyword">user</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr></table></figure><p>简单解释一下：</p><ol><li>在 <code>REVOKE</code> 关键字后面指定要从用户撤消的权限列表。您需要用逗号分隔权限。</li><li>指定在 <code>ON</code> 子句中撤销特权的特权级别。</li><li>指定要撤消 <code>FROM</code> 子句中的权限的用户帐户。</li></ol><p><code>GRANT</code> 和 <code>REVOKE</code> 可在几个层次上控制访问权限：</p><ul><li>整个服务器，使用 <code>GRANT ALL</code> 和 <code>REVOKE ALL</code> ；</li><li>整个数据库，使用 <code>ON database.*</code> ；</li><li>特定的表，使用 <code>ON database.table</code> ；</li><li>特定的列；</li><li>特定的存储过程。</li></ul><p>新创建的账户没有任何权限。账户用 <code>username@host</code> 的形式定义， <code>username@%</code> 使用的是默认主机名。MySQL 的账户信息保存在 mysql 这个数据库中。</p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">USE</span> mysql<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">SELECT</span> <span class="token keyword">user</span> <span class="token keyword">FROM</span> <span class="token keyword">user</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>下表说明了可用于 <code>GRANT</code> 和 <code>REVOKE</code> 语句的所有允许权限：</p><table><thead><tr><th><strong>特权</strong></th><th><strong>说明</strong></th><th><strong>级别</strong></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td><strong>全局</strong></td><td>数据库</td><td><strong>表</strong></td><td><strong>列</strong></td><td><strong>程序</strong></td><td><strong>代理</strong></td><td></td><td></td></tr><tr><td>ALL [PRIVILEGES]</td><td>授予除 GRANT OPTION 之外的指定访问级别的所有权限</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>ALTER</td><td>允许用户使用 ALTER TABLE 语句</td><td>X</td><td>X</td><td>X</td><td></td><td></td><td></td></tr><tr><td>ALTER ROUTINE</td><td>允许用户更改或删除存储的例程</td><td>X</td><td>X</td><td></td><td></td><td>X</td><td></td></tr><tr><td>CREATE</td><td>允许用户创建数据库和表</td><td>X</td><td>X</td><td>X</td><td></td><td></td><td></td></tr><tr><td>CREATE ROUTINE</td><td>允许用户创建存储的例程</td><td>X</td><td>X</td><td></td><td></td><td></td><td></td></tr><tr><td>CREATE TABLESPACE</td><td>允许用户创建，更改或删除表空间和日志文件组</td><td>X</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>CREATE TEMPORARY TABLES</td><td>允许用户使用 CREATE TEMPORARY TABLE 创建临时表</td><td>X</td><td>X</td><td></td><td></td><td></td><td></td></tr><tr><td>CREATE USER</td><td>允许用户使用 CREATE USER，DROP USER，RENAME USER 和 REVOKE ALL PRIVILEGES 语句。</td><td>X</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>CREATE VIEW</td><td>允许用户创建或修改视图。</td><td>X</td><td>X</td><td>X</td><td></td><td></td><td></td></tr><tr><td>DELETE</td><td>允许用户使用 DELETE</td><td>X</td><td>X</td><td>X</td><td></td><td></td><td></td></tr><tr><td>DROP</td><td>允许用户删除数据库，表和视图</td><td>X</td><td>X</td><td>X</td><td></td><td></td><td></td></tr><tr><td>EVENT</td><td>启用事件计划程序的事件使用。</td><td>X</td><td>X</td><td></td><td></td><td></td><td></td></tr><tr><td>EXECUTE</td><td>允许用户执行存储的例程</td><td>X</td><td>X</td><td>X</td><td></td><td></td><td></td></tr><tr><td>FILE</td><td>允许用户读取数据库目录中的任何文件。</td><td>X</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>GRANT OPTION</td><td>允许用户拥有授予或撤消其他帐户权限的权限。</td><td>X</td><td>X</td><td>X</td><td></td><td>X</td><td>X</td></tr><tr><td>INDEX</td><td>允许用户创建或删除索引。</td><td>X</td><td>X</td><td>X</td><td></td><td></td><td></td></tr><tr><td>INSERT</td><td>允许用户使用 INSERT 语句</td><td>X</td><td>X</td><td>X</td><td>X</td><td></td><td></td></tr><tr><td>LOCK TABLES</td><td>允许用户对具有 SELECT 权限的表使用 LOCK TABLES</td><td>X</td><td>X</td><td></td><td></td><td></td><td></td></tr><tr><td>PROCESS</td><td>允许用户使用 SHOW PROCESSLIST 语句查看所有进程。</td><td>X</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>PROXY</td><td>启用用户代理。</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>REFERENCES</td><td>允许用户创建外键</td><td>X</td><td>X</td><td>X</td><td>X</td><td></td><td></td></tr><tr><td>RELOAD</td><td>允许用户使用 FLUSH 操作</td><td>X</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>REPLICATION CLIENT</td><td>允许用户查询以查看主服务器或从属服务器的位置</td><td>X</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>REPLICATION SLAVE</td><td>允许用户使用复制从属从主服务器读取二进制日志事件。</td><td>X</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>SELECT</td><td>允许用户使用 SELECT 语句</td><td>X</td><td>X</td><td>X</td><td>X</td><td></td><td></td></tr><tr><td>SHOW DATABASES</td><td>允许用户显示所有数据库</td><td>X</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>SHOW VIEW</td><td>允许用户使用 SHOW CREATE VIEW 语句</td><td>X</td><td>X</td><td>X</td><td></td><td></td><td></td></tr><tr><td>SHUTDOWN</td><td>允许用户使用 mysqladmin shutdown 命令</td><td>X</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>SUPER</td><td>允许用户使用其他管理操作，例如 CHANGE MASTER TO，KILL，PURGE BINARY LOGS，SET GLOBAL 和 mysqladmin 命令</td><td>X</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>TRIGGER</td><td>允许用户使用 TRIGGER 操作。</td><td>X</td><td>X</td><td>X</td><td></td><td></td><td></td></tr><tr><td>UPDATE</td><td>允许用户使用 UPDATE 语句</td><td>X</td><td>X</td><td>X</td><td>X</td><td></td><td></td></tr><tr><td>USAGE</td><td>相当于 “没有特权”</td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><h5 id="创建账户"><a class="anchor" href="#创建账户">#</a> 创建账户</h5><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">CREATE</span> <span class="token keyword">USER</span> myuser IDENTIFIED <span class="token keyword">BY</span> <span class="token string">'mypassword'</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h5 id="修改账户名"><a class="anchor" href="#修改账户名">#</a> 修改账户名</h5><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">UPDATE</span> <span class="token keyword">user</span> <span class="token keyword">SET</span> <span class="token keyword">user</span><span class="token operator">=</span><span class="token string">'newuser'</span> <span class="token keyword">WHERE</span> <span class="token keyword">user</span><span class="token operator">=</span><span class="token string">'myuser'</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>FLUSH <span class="token keyword">PRIVILEGES</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h5 id="删除账户"><a class="anchor" href="#删除账户">#</a> 删除账户</h5><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">DROP</span> <span class="token keyword">USER</span> myuser<span class="token punctuation">;</span></pre></td></tr></table></figure><h5 id="查看权限"><a class="anchor" href="#查看权限">#</a> 查看权限</h5><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">SHOW</span> GRANTS <span class="token keyword">FOR</span> myuser<span class="token punctuation">;</span></pre></td></tr></table></figure><h5 id="授予权限"><a class="anchor" href="#授予权限">#</a> 授予权限</h5><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">GRANT</span> <span class="token keyword">SELECT</span><span class="token punctuation">,</span> <span class="token keyword">INSERT</span> <span class="token keyword">ON</span> <span class="token operator">*</span><span class="token punctuation">.</span><span class="token operator">*</span> <span class="token keyword">TO</span> myuser<span class="token punctuation">;</span></pre></td></tr></table></figure><h5 id="删除权限"><a class="anchor" href="#删除权限">#</a> 删除权限</h5><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">REVOKE</span> <span class="token keyword">SELECT</span><span class="token punctuation">,</span> <span class="token keyword">INSERT</span> <span class="token keyword">ON</span> <span class="token operator">*</span><span class="token punctuation">.</span><span class="token operator">*</span> <span class="token keyword">FROM</span> myuser<span class="token punctuation">;</span></pre></td></tr></table></figure><h5 id="更改密码"><a class="anchor" href="#更改密码">#</a> 更改密码</h5><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">SET</span> PASSWORD <span class="token keyword">FOR</span> myuser <span class="token operator">=</span> <span class="token string">'mypass'</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h4 id="存储过程"><a class="anchor" href="#存储过程">#</a> 存储过程</h4><p><img data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/60afdc9c9a594f079727ec64a2e698a3~tplv-k3u1fbpfcp-zoom-1.image" alt="mysql存储过程"></p><p>使用存储过程的好处：</p><ul><li>代码封装，保证了一定的安全性；</li><li><font color="red">代码复用</font>；</li><li>由于是<font color="red">预先编译</font>，因此具有很高的性能。</li></ul><p>创建存储过程：</p><ul><li>命令行中创建存储过程需要自定义分隔符，因为命令行是以 <code>;</code> 为结束符，而存储过程中也包含了分号，因此会错误把这部分分号当成是结束符，造成语法错误。</li><li>包含 <code>in</code> 、 <code>out</code> 和 <code>inout</code> 三种参数。</li><li>给变量赋值都需要用 <code>select into</code> 语句。</li><li>每次只能给一个变量赋值，不支持集合的操作。</li></ul><p>需要注意的是：<strong>阿里巴巴《Java 开发手册》强制禁止使用存储过程。因为存储过程难以调试和扩展，更没有移植性。</strong></p><p><img data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/93a5e011ade4450ebfa5d82057532a49~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>至于到底要不要在项目中使用，还是要看项目实际需求，权衡好利弊即可！</p><h5 id="创建存储过程"><a class="anchor" href="#创建存储过程">#</a> 创建存储过程</h5><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">DROP</span> <span class="token keyword">PROCEDURE</span> <span class="token keyword">IF</span> <span class="token keyword">EXISTS</span> <span class="token identifier"><span class="token punctuation">`</span>proc_adder<span class="token punctuation">`</span></span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">DELIMITER</span> <span class="token punctuation">;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">CREATE</span> <span class="token keyword">DEFINER</span><span class="token operator">=</span><span class="token identifier"><span class="token punctuation">`</span>root<span class="token punctuation">`</span></span><span class="token variable">@`localhost`</span> <span class="token keyword">PROCEDURE</span> <span class="token identifier"><span class="token punctuation">`</span>proc_adder<span class="token punctuation">`</span></span><span class="token punctuation">(</span><span class="token operator">IN</span> a <span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token operator">IN</span> b <span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">OUT</span> sum <span class="token keyword">int</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">BEGIN</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">DECLARE</span> c <span class="token keyword">int</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">if</span> a <span class="token operator">is</span> <span class="token boolean">null</span> <span class="token keyword">then</span> <span class="token keyword">set</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">end</span> <span class="token keyword">if</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">if</span> b <span class="token operator">is</span> <span class="token boolean">null</span> <span class="token keyword">then</span> <span class="token keyword">set</span> b <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token keyword">end</span> <span class="token keyword">if</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token keyword">set</span> sum  <span class="token operator">=</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token keyword">END</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token punctuation">;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token keyword">DELIMITER</span> <span class="token punctuation">;</span></pre></td></tr></table></figure><h5 id="使用存储过程"><a class="anchor" href="#使用存储过程">#</a> 使用存储过程</h5><figure class="highlight less"><figcaption data-lang="less"></figcaption><table><tr><td data-num="1"></td><td><pre>set <span class="token variable">@b</span>=5<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>call proc_<span class="token function">adder</span><span class="token punctuation">(</span>2<span class="token punctuation">,</span><span class="token variable">@b</span><span class="token punctuation">,</span><span class="token variable">@s</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>select <span class="token variable">@s</span> as sum<span class="token punctuation">;</span></pre></td></tr></table></figure><h4 id="游标"><a class="anchor" href="#游标">#</a> 游标</h4><p>游标（cursor）是<strong>一个存储在 DBMS 服务器上的数据库查询，它不是一条 <code>SELECT</code> 语句，而是被该语句检索出来的结果集</strong>。</p><p>在存储过程中使用游标可以对一个结果集进行移动遍历。</p><p>游标主要用于交互式应用，其中用户需要滚动屏幕上的数据，并对数据进行浏览或做出更改。</p><p>使用游标的几个明确步骤：</p><ul><li>在使用游标前，必须<font color="red">声明 (定义)</font>它。这个过程实际上没有检索数据， 它只是定义要使用的 <code>SELECT</code> 语句和游标选项。</li><li>一旦声明，就必须<font color="red">打开游标以供使用</font>。这个过程用前面定义的 SELECT 语句把数据实际检索出来。</li><li>对于填有数据的游标，根据需要<font color="red">取出 (检索) 各行</font>。</li><li>在结束游标使用时，必须<font color="red">关闭游标</font>，可能的话，<font color="red">释放游标</font>(有赖于具体的 DBMS)。</li></ul><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">DELIMITER</span> $</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">CREATE</span>  <span class="token keyword">PROCEDURE</span> getTotal<span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">BEGIN</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">DECLARE</span> total <span class="token keyword">INT</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token comment">-- 创建接收游标数据的变量</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">DECLARE</span> sid <span class="token keyword">INT</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">DECLARE</span> sname <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token comment">-- 创建总数变量</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">DECLARE</span> sage <span class="token keyword">INT</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token comment">-- 创建结束标志变量</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token keyword">DECLARE</span> done <span class="token keyword">INT</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token comment">-- 创建游标</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token keyword">DECLARE</span> cur <span class="token keyword">CURSOR</span> <span class="token keyword">FOR</span> <span class="token keyword">SELECT</span> id<span class="token punctuation">,</span>name<span class="token punctuation">,</span>age <span class="token keyword">from</span> cursor_table <span class="token keyword">where</span> age<span class="token operator">></span><span class="token number">30</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token comment">-- 指定游标循环结束时的返回值</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token keyword">DECLARE</span> <span class="token keyword">CONTINUE</span> <span class="token keyword">HANDLER</span> <span class="token keyword">FOR</span> <span class="token operator">NOT</span> FOUND <span class="token keyword">SET</span> done <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token keyword">SET</span> total <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token keyword">OPEN</span> cur<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token keyword">FETCH</span> cur <span class="token keyword">INTO</span> sid<span class="token punctuation">,</span> sname<span class="token punctuation">,</span> sage<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    <span class="token keyword">WHILE</span><span class="token punctuation">(</span><span class="token operator">NOT</span> done<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    <span class="token keyword">DO</span></pre></td></tr><tr><td data-num="21"></td><td><pre>        <span class="token keyword">SET</span> total <span class="token operator">=</span> total <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>        <span class="token keyword">FETCH</span> cur <span class="token keyword">INTO</span> sid<span class="token punctuation">,</span> sname<span class="token punctuation">,</span> sage<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>    <span class="token keyword">END</span> <span class="token keyword">WHILE</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre></pre></td></tr><tr><td data-num="25"></td><td><pre>    <span class="token keyword">CLOSE</span> cur<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>    <span class="token keyword">SELECT</span> total<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre><span class="token keyword">END</span> $</pre></td></tr><tr><td data-num="28"></td><td><pre><span class="token keyword">DELIMITER</span> <span class="token punctuation">;</span></pre></td></tr><tr><td data-num="29"></td><td><pre></pre></td></tr><tr><td data-num="30"></td><td><pre><span class="token comment">-- 调用存储过程</span></pre></td></tr><tr><td data-num="31"></td><td><pre><span class="token keyword">call</span> getTotal<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h4 id="触发器"><a class="anchor" href="#触发器">#</a> 触发器</h4><p>触发器是一种与表操作有关的数据库对象，<font color="red">当触发器所在表上出现指定事件时，将调用该对象</font>，即表的操作事件触发表上的触发器的执行。</p><p>触发器<font color="red">可以用来进行审计跟踪，把修改记录到另外一张表中</font>。</p><p>使用触发器的优点：</p><ul><li>SQL 触发器提供了另一种检查数据完整性的方法。</li><li>SQL 触发器可以捕获数据库层中业务逻辑中的错误。</li><li>SQL 触发器提供了另一种运行计划任务的方法。通过使用 SQL 触发器，您不必等待运行计划任务，因为在对表中的数据进行更改之前或之后会自动调用触发器。</li><li>SQL 触发器对于审计表中数据的更改非常有用。</li></ul><p>使用触发器的缺点：</p><ul><li>SQL 触发器只能提供扩展验证，并且不能替换所有验证。必须在应用程序层中完成一些简单的验证。例如，您可以使用 JavaScript 在客户端验证用户的输入，或者使用服务器端脚本语言（如 JSP，PHP，<span class="exturl" data-url="aHR0cDovL0FTUC5ORVQ=">ASP.NET</span>，Perl）在服务器端验证用户的输入。</li><li>从客户端应用程序调用和执行 SQL 触发器是不可见的，因此很难弄清楚数据库层中发生了什么。</li><li>SQL 触发器可能会增加数据库服务器的开销。</li></ul><p><strong>MySQL 不允许在触发器中使用 CALL 语句 ，也就是不能调用存储过程</strong>。</p><blockquote><p>注意：在 MySQL 中，分号 <code>;</code> 是语句结束的标识符，遇到分号表示该段语句已经结束，MySQL 可以开始执行了。因此，解释器遇到触发器执行动作中的分号后就开始执行，然后会报错，因为没有找到和 BEGIN 匹配的 END。</p><p>这时就会用到 <code>DELIMITER</code> 命令（DELIMITER 是定界符，分隔符的意思）。它是一条命令，不需要语句结束标识，语法为： <code>DELIMITER new_delemiter</code> 。 <code>new_delemiter</code> 可以设为 1 个或多个长度的符号，默认的是分号 <code>;</code> ，我们可以把它修改为其他符号，如 <code>$</code> - <code>DELIMITER $</code> 。在这之后的语句，以分号结束，解释器不会有什么反应，只有遇到了 <code>$</code> ，才认为是语句结束。注意，使用完之后，我们还应该记得把它给修改回来。</p></blockquote><p>在 MySQL 5.7.2 版之前，可以为每个表定义最多六个触发器。</p><ul><li><code>BEFORE INSERT</code> - 在将数据插入表格之前激活。</li><li><code>AFTER INSERT</code> - 将数据插入表格后激活。</li><li><code>BEFORE UPDATE</code> - 在更新表中的数据之前激活。</li><li><code>AFTER UPDATE</code> - 更新表中的数据后激活。</li><li><code>BEFORE DELETE</code> - 在从表中删除数据之前激活。</li><li><code>AFTER DELETE</code> - 从表中删除数据后激活。</li></ul><p>但是，从 MySQL 版本 5.7.2 + 开始，可以为同一触发事件和操作时间定义多个触发器。</p><p><strong><code>NEW</code> 和 <code>OLD</code> </strong>：</p><ul><li>MySQL 中定义了 <code>NEW</code> 和 <code>OLD</code> 关键字，用来<strong>表示触发器的所在表中，触发了触发器的那一行数据</strong>。</li><li>在 <code>INSERT</code> 型触发器中， <code>NEW</code> 用来表示将要（ <code>BEFORE</code> ）或已经（ <code>AFTER</code> ）插入的新数据；</li><li>在 <code>UPDATE</code> 型触发器中， <code>OLD</code> 用来表示将要或已经被修改的原数据， <code>NEW</code> 用来表示将要或已经修改为的新数据；</li><li>在 <code>DELETE</code> 型触发器中， <code>OLD</code> 用来表示将要或已经被删除的原数据；</li><li>使用方法： <code>NEW.columnName</code> （columnName 为相应数据表某一列名）</li></ul><h5 id="创建触发器"><a class="anchor" href="#创建触发器">#</a> 创建触发器</h5><blockquote><p>提示：为了理解触发器的要点，有必要先了解一下创建触发器的指令。</p></blockquote><p><code>CREATE TRIGGER</code> 指令用于创建触发器。</p><p>语法：</p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">CREATE</span> <span class="token keyword">TRIGGER</span> trigger_name</pre></td></tr><tr><td data-num="2"></td><td><pre>trigger_time</pre></td></tr><tr><td data-num="3"></td><td><pre>trigger_event</pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">ON</span> table_name</pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">FOR EACH ROW</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">BEGIN</span></pre></td></tr><tr><td data-num="7"></td><td><pre>  trigger_statements</pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token keyword">END</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>说明：</p><ul><li><code>trigger_name</code> ：触发器名</li><li><code>trigger_time</code> : 触发器的触发时机。取值为 <code>BEFORE</code> 或 <code>AFTER</code> 。</li><li><code>trigger_event</code> : 触发器的监听事件。取值为 <code>INSERT</code> 、 <code>UPDATE</code> 或 <code>DELETE</code> 。</li><li><code>table_name</code> : 触发器的监听目标。指定在哪张表上建立触发器。</li><li><code>FOR EACH ROW</code> : 行级监视，Mysql 固定写法，其他 DBMS 不同。</li><li><code>trigger_statements</code> : 触发器执行动作。是一条或多条 SQL 语句的列表，列表内的每条语句都必须用分号 <code>;</code> 来结尾。</li></ul><p>当触发器的触发条件满足时，将会执行 <code>BEGIN</code> 和 <code>END</code> 之间的触发器执行动作。</p><p>示例：</p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">DELIMITER</span> $</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">CREATE</span> <span class="token keyword">TRIGGER</span> <span class="token identifier"><span class="token punctuation">`</span>trigger_insert_user<span class="token punctuation">`</span></span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">AFTER</span> <span class="token keyword">INSERT</span> <span class="token keyword">ON</span> <span class="token identifier"><span class="token punctuation">`</span>user<span class="token punctuation">`</span></span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">FOR EACH ROW</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">BEGIN</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>user_history<span class="token punctuation">`</span></span><span class="token punctuation">(</span>user_id<span class="token punctuation">,</span> operate_type<span class="token punctuation">,</span> operate_time<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">VALUES</span> <span class="token punctuation">(</span>NEW<span class="token punctuation">.</span>id<span class="token punctuation">,</span> <span class="token string">'add a user'</span><span class="token punctuation">,</span>  <span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token keyword">END</span> $</pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">DELIMITER</span> <span class="token punctuation">;</span></pre></td></tr></table></figure><h5 id="查看触发器"><a class="anchor" href="#查看触发器">#</a> 查看触发器</h5><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">SHOW</span> TRIGGERS<span class="token punctuation">;</span></pre></td></tr></table></figure><h5 id="删除触发器"><a class="anchor" href="#删除触发器">#</a> 删除触发器</h5><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">DROP</span> <span class="token keyword">TRIGGER</span> <span class="token keyword">IF</span> <span class="token keyword">EXISTS</span> trigger_insert_user<span class="token punctuation">;</span></pre></td></tr></table></figure><h3 id="sql常见面试题"><a class="anchor" href="#sql常见面试题">#</a> SQL 常见面试题</h3></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2023-11-17 22:21:39" itemprop="dateModified" datetime="2023-11-17T22:21:39+08:00">2023-11-17</time> </span><span id="database/mysql/MySQL-JavaGuide/" class="item leancloud_visitors" data-flag-title="MySQL-JavaGuide" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>范特东东东 <i class="ic i-at"><em>@</em></i>水文 & 摄影</li><li class="link"><strong>本文链接：</strong> <a href="http://example.com/database/mysql/MySQL-JavaGuide/" title="MySQL-JavaGuide">http://example.com/database/mysql/MySQL-JavaGuide/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/photography/%E6%97%A5%E8%90%BD%E6%94%B6%E9%9B%86%E8%AE%A1%E5%88%92/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;pic.imgdb.cn&#x2F;item&#x2F;6553a0abc458853aef3aa4f3.jpg" title="日落收集计划"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> 摄影</span><h3>日落收集计划</h3></a></div><div class="item right"><a href="/database/redis/Redis-JavaGuide/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;hjx159&#x2F;picture-bed&#x2F;main&#x2F;img&#x2F;sql-nosql-tushi.png" title="Redis-JavaGuide"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> Redis</span><h3>Redis-JavaGuide</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#mysql"><span class="toc-number">1.</span> <span class="toc-text">MySQL</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#mysql%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">1.1.</span> <span class="toc-text">MySQL 常见面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#mysql%E5%9F%BA%E7%A1%80"><span class="toc-number">1.1.1.</span> <span class="toc-text">MySQL 基础</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">什么是关系型数据库？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-sql"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">什么是 SQL？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-mysql"><span class="toc-number">1.1.1.3.</span> <span class="toc-text">什么是 MySQL？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mysql-%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E7%82%B9"><span class="toc-number">1.1.1.4.</span> <span class="toc-text">MySQL 有什么优点？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mysql%E5%AD%97%E6%AE%B5%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.2.</span> <span class="toc-text">MySQL 字段类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E7%B1%BB%E5%9E%8B%E7%9A%84-unsigned-%E5%B1%9E%E6%80%A7%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">整数类型的 UNSIGNED 属性有什么用？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#char-%E5%92%8C-varchar-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">CHAR 和 VARCHAR 的区别是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#varchar100%E5%92%8C-varchar10%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.1.2.3.</span> <span class="toc-text">VARCHAR (100) 和 VARCHAR (10) 的区别是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#decimal-%E5%92%8C-floatdouble-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.1.2.4.</span> <span class="toc-text">DECIMAL 和 FLOAT&#x2F;DOUBLE 的区别是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8-text-%E5%92%8C-blob"><span class="toc-number">1.1.2.5.</span> <span class="toc-text">为什么不推荐使用 TEXT 和 BLOB？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#datetime-%E5%92%8C-timestamp-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.1.2.6.</span> <span class="toc-text">DATETIME 和 TIMESTAMP 的区别是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#null-%E5%92%8C-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.1.2.7.</span> <span class="toc-text">NULL 和 &#39;&#39; 的区别是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#boolean-%E7%B1%BB%E5%9E%8B%E5%A6%82%E4%BD%95%E8%A1%A8%E7%A4%BA"><span class="toc-number">1.1.2.8.</span> <span class="toc-text">Boolean 类型如何表示？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mysql%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84"><span class="toc-number">1.1.3.</span> <span class="toc-text">MySQL 基础架构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-mysql-%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84%E5%88%86%E6%9E%90"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">1、MySQL 基础架构分析</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#11-%E6%9E%B6%E6%9E%84%E6%A6%82%E8%A7%88"><span class="toc-number">1.1.3.1.1.</span> <span class="toc-text">1.1、架构概览</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#12-server-%E5%B1%82%E7%9A%84%E7%BB%84%E4%BB%B6%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.1.3.1.2.</span> <span class="toc-text">1.2、Server 层的组件介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1%E8%BF%9E%E6%8E%A5%E5%99%A8"><span class="toc-number">1.1.3.1.2.1.</span> <span class="toc-text">1）连接器</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98"><span class="toc-number">1.1.3.1.2.2.</span> <span class="toc-text">2）查询缓存</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3%E5%88%86%E6%9E%90%E5%99%A8"><span class="toc-number">1.1.3.1.2.3.</span> <span class="toc-text">3）分析器</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#4%E4%BC%98%E5%8C%96%E5%99%A8"><span class="toc-number">1.1.3.1.2.4.</span> <span class="toc-text">4）优化器</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#5%E6%89%A7%E8%A1%8C%E5%99%A8"><span class="toc-number">1.1.3.1.2.5.</span> <span class="toc-text">5）执行器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-sql-%E8%AF%AD%E5%8F%A5%E5%88%86%E6%9E%90"><span class="toc-number">1.1.3.2.</span> <span class="toc-text">2、SQL 语句分析</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#21-dql-%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.1.3.2.1.</span> <span class="toc-text">2.1、DQL 查询语句</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#22-dml-%E6%9B%B4%E6%96%B0%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.1.3.2.2.</span> <span class="toc-text">2.2、DML 更新语句</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%B0%8F%E7%BB%93"><span class="toc-number">1.1.3.3.</span> <span class="toc-text">3、小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mysql%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="toc-number">1.1.4.</span> <span class="toc-text">MySQL 存储引擎</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#mysql-%E6%94%AF%E6%8C%81%E5%93%AA%E4%BA%9B%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E9%BB%98%E8%AE%A4%E4%BD%BF%E7%94%A8%E5%93%AA%E4%B8%AA"><span class="toc-number">1.1.4.1.</span> <span class="toc-text">MySQL 支持哪些存储引擎？默认使用哪个？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mysql-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E6%9E%B6%E6%9E%84%E4%BA%86%E8%A7%A3%E5%90%97"><span class="toc-number">1.1.4.2.</span> <span class="toc-text">MySQL 存储引擎架构了解吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#myisam-%E5%92%8C-innodb-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">1.1.4.3.</span> <span class="toc-text">MyISAM 和 InnoDB 有什么区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#myisam-%E5%92%8C-innodb-%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9"><span class="toc-number">1.1.4.4.</span> <span class="toc-text">MyISAM 和 InnoDB 如何选择？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mysql%E7%B4%A2%E5%BC%95"><span class="toc-number">1.1.5.</span> <span class="toc-text">MySQL 索引</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.1.5.1.</span> <span class="toc-text">索引介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">1.1.5.2.</span> <span class="toc-text">索引的优缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%80%89%E5%9E%8B"><span class="toc-number">1.1.5.3.</span> <span class="toc-text">索引的底层数据结构选型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#hash-%E8%A1%A8"><span class="toc-number">1.1.5.3.1.</span> <span class="toc-text">Hash 表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91bst"><span class="toc-number">1.1.5.3.2.</span> <span class="toc-text">二叉查找树（BST）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#avl-%E6%A0%91%E8%87%AA%E5%B9%B3%E8%A1%A1%E7%9A%84bst"><span class="toc-number">1.1.5.3.3.</span> <span class="toc-text">AVL 树（自平衡的 BST）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91%E8%87%AA%E5%B9%B3%E8%A1%A1%E7%9A%84bst"><span class="toc-number">1.1.5.3.4.</span> <span class="toc-text">红黑树（自平衡的 BST）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#b%E6%A0%91-b%E6%A0%91"><span class="toc-number">1.1.5.3.5.</span> <span class="toc-text">B 树 &amp; B + 树</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%88%86%E7%B1%BB"><span class="toc-number">1.1.5.4.</span> <span class="toc-text">索引分类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95"><span class="toc-number">1.1.5.4.1.</span> <span class="toc-text">主键索引</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95"><span class="toc-number">1.1.5.4.2.</span> <span class="toc-text">二级索引</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95"><span class="toc-number">1.1.5.4.3.</span> <span class="toc-text">聚集索引</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9D%9E%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95"><span class="toc-number">1.1.5.4.4.</span> <span class="toc-text">非聚集索引</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95"><span class="toc-number">1.1.5.4.5.</span> <span class="toc-text">覆盖索引</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95"><span class="toc-number">1.1.5.4.6.</span> <span class="toc-text">联合索引</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80%E5%8C%B9%E9%85%8D%E5%8E%9F%E5%88%99"><span class="toc-number">1.1.5.4.7.</span> <span class="toc-text">最左前缀匹配原则</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8"><span class="toc-number">1.1.5.5.</span> <span class="toc-text">索引下推</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8%E5%BB%BA%E8%AE%AE"><span class="toc-number">1.1.5.6.</span> <span class="toc-text">索引的正确使用建议</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mysql%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98"><span class="toc-number">1.1.6.</span> <span class="toc-text">MySQL 查询缓存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mysql%E6%97%A5%E5%BF%97"><span class="toc-number">1.1.7.</span> <span class="toc-text">MySQL 日志</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#mysql-%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E6%97%A5%E5%BF%97%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">1.1.7.1.</span> <span class="toc-text">MySQL 中常见的日志有哪些？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8"><span class="toc-number">1.1.7.2.</span> <span class="toc-text">慢查询日志有什么用？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#binlog-%E4%B8%BB%E8%A6%81%E8%AE%B0%E5%BD%95%E4%BA%86%E4%BB%80%E4%B9%88"><span class="toc-number">1.1.7.3.</span> <span class="toc-text">binlog 主要记录了什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8Bredo-log%E4%BB%A5%E5%8F%8A%E5%AE%83%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%8C%81%E4%B9%85%E6%80%A7"><span class="toc-number">1.1.7.4.</span> <span class="toc-text">介绍一下 redo log，以及它如何保证事务的持久性？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E9%A1%B5%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.1.7.5.</span> <span class="toc-text">数据页是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B5%E4%BF%AE%E6%94%B9%E4%B9%8B%E5%90%8E%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%9B%B4%E6%8E%A5%E5%88%B7%E7%9B%98%E5%91%A2"><span class="toc-number">1.1.7.6.</span> <span class="toc-text">页修改之后为什么不直接刷盘呢？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#binlog-%E5%92%8C-redolog-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">1.1.7.7.</span> <span class="toc-text">binlog 和 redolog 有什么区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#undo-log-%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%8E%9F%E5%AD%90%E6%80%A7"><span class="toc-number">1.1.7.8.</span> <span class="toc-text">undo log 如何保证事务的原子性？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mysql%E4%BA%8B%E5%8A%A1"><span class="toc-number">1.1.8.</span> <span class="toc-text">MySQL 事务</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%95%E8%B0%93%E4%BA%8B%E5%8A%A1"><span class="toc-number">1.1.8.1.</span> <span class="toc-text">何谓事务？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%95%E8%B0%93%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1"><span class="toc-number">1.1.8.2.</span> <span class="toc-text">何谓数据库事务？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E4%BA%8B%E5%8A%A1%E5%B8%A6%E6%9D%A5%E4%BA%86%E5%93%AA%E4%BA%9B%E9%97%AE%E9%A2%98"><span class="toc-number">1.1.8.3.</span> <span class="toc-text">并发事务带来了哪些问题？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%84%8F%E8%AF%BBdirty-read"><span class="toc-number">1.1.8.3.1.</span> <span class="toc-text">脏读（Dirty read）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%A2%E5%A4%B1%E4%BF%AE%E6%94%B9lost-to-modify"><span class="toc-number">1.1.8.3.2.</span> <span class="toc-text">丢失修改（Lost to modify）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BBunrepeatable-read"><span class="toc-number">1.1.8.3.3.</span> <span class="toc-text">不可重复读（Unrepeatable read）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B9%BB%E8%AF%BBphantom-read"><span class="toc-number">1.1.8.3.4.</span> <span class="toc-text">幻读（Phantom read）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E5%92%8C%E5%B9%BB%E8%AF%BB%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">1.1.8.4.</span> <span class="toc-text">不可重复读和幻读有什么区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">1.1.8.5.</span> <span class="toc-text">并发事务的控制方式有哪些？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sql-%E6%A0%87%E5%87%86%E5%AE%9A%E4%B9%89%E4%BA%86%E5%93%AA%E4%BA%9B%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-number">1.1.8.6.</span> <span class="toc-text">SQL 标准定义了哪些事务隔离级别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mysql-%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E6%98%AF%E5%9F%BA%E4%BA%8E%E9%94%81%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%90%97"><span class="toc-number">1.1.8.7.</span> <span class="toc-text">MySQL 的隔离级别是基于锁实现的吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mysql-%E7%9A%84%E9%BB%98%E8%AE%A4%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.1.8.8.</span> <span class="toc-text">MySQL 的默认隔离级别是什么？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mysql%E9%AB%98%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E8%A7%84%E8%8C%83%E5%BB%BA%E8%AE%AE"><span class="toc-number">1.2.</span> <span class="toc-text">MySQL 高性能优化规范建议</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%B8%8F%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="toc-number">1.3.</span> <span class="toc-text">⭐️重要知识点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sql"><span class="toc-number">1.4.</span> <span class="toc-text">SQL</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#sql%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80"><span class="toc-number">1.4.1.</span> <span class="toc-text">SQL 语法基础</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%AF%E8%AF%AD"><span class="toc-number">1.4.1.1.1.</span> <span class="toc-text">数据库术语</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#sql-%E8%AF%AD%E6%B3%95"><span class="toc-number">1.4.1.1.2.</span> <span class="toc-text">SQL 语法</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#sql-%E8%AF%AD%E6%B3%95%E7%BB%93%E6%9E%84"><span class="toc-number">1.4.1.1.2.1.</span> <span class="toc-text">SQL 语法结构</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#sql-%E8%AF%AD%E6%B3%95%E8%A6%81%E7%82%B9"><span class="toc-number">1.4.1.1.2.2.</span> <span class="toc-text">SQL 语法要点</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#sql-%E5%88%86%E7%B1%BB"><span class="toc-number">1.4.1.1.3.</span> <span class="toc-text">SQL 分类</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%AE%9A%E4%B9%89%E8%AF%AD%E8%A8%80ddl"><span class="toc-number">1.4.1.1.3.1.</span> <span class="toc-text">数据定义语言（DDL）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%93%8D%E7%BA%B5%E8%AF%AD%E8%A8%80dml"><span class="toc-number">1.4.1.1.3.2.</span> <span class="toc-text">数据操纵语言（DML）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E6%8E%A7%E5%88%B6%E8%AF%AD%E8%A8%80tcl"><span class="toc-number">1.4.1.1.3.3.</span> <span class="toc-text">事务控制语言（TCL）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%8E%A7%E5%88%B6%E8%AF%AD%E8%A8%80dcl"><span class="toc-number">1.4.1.1.3.4.</span> <span class="toc-text">数据控制语言（DCL）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5"><span class="toc-number">1.4.1.2.</span> <span class="toc-text">增删改查</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE"><span class="toc-number">1.4.1.2.1.</span> <span class="toc-text">插入数据</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE"><span class="toc-number">1.4.1.2.2.</span> <span class="toc-text">更新数据</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE"><span class="toc-number">1.4.1.2.3.</span> <span class="toc-text">删除数据</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E6%95%B0%E6%8D%AE"><span class="toc-number">1.4.1.2.4.</span> <span class="toc-text">查询数据</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F"><span class="toc-number">1.4.1.3.</span> <span class="toc-text">排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E7%BB%84"><span class="toc-number">1.4.1.4.</span> <span class="toc-text">分组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%90%E6%9F%A5%E8%AF%A2"><span class="toc-number">1.4.1.5.</span> <span class="toc-text">子查询</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#where"><span class="toc-number">1.4.1.5.1.</span> <span class="toc-text">WHERE</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#in-%E5%92%8C-between"><span class="toc-number">1.4.1.5.2.</span> <span class="toc-text">IN 和 BETWEEN</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#and-or-not"><span class="toc-number">1.4.1.5.3.</span> <span class="toc-text">AND、OR、NOT</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#like"><span class="toc-number">1.4.1.5.4.</span> <span class="toc-text">LIKE</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5"><span class="toc-number">1.4.1.6.</span> <span class="toc-text">连接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%84%E5%90%88"><span class="toc-number">1.4.1.7.</span> <span class="toc-text">组合</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-number">1.4.1.8.</span> <span class="toc-text">函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86"><span class="toc-number">1.4.1.8.1.</span> <span class="toc-text">文本处理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4%E5%A4%84%E7%90%86"><span class="toc-number">1.4.1.8.2.</span> <span class="toc-text">日期和时间处理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E5%80%BC%E5%A4%84%E7%90%86"><span class="toc-number">1.4.1.8.3.</span> <span class="toc-text">数值处理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B1%87%E6%80%BB"><span class="toc-number">1.4.1.8.4.</span> <span class="toc-text">汇总</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%AE%9A%E4%B9%89"><span class="toc-number">1.4.1.9.</span> <span class="toc-text">数据定义</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93database"><span class="toc-number">1.4.1.9.1.</span> <span class="toc-text">数据库（DATABASE）</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">1.4.1.9.1.1.</span> <span class="toc-text">创建数据库</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">1.4.1.9.1.2.</span> <span class="toc-text">删除数据库</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">1.4.1.9.1.3.</span> <span class="toc-text">选择数据库</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E8%A1%A8table"><span class="toc-number">1.4.1.9.2.</span> <span class="toc-text">数据表（TABLE）</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E8%A1%A8"><span class="toc-number">1.4.1.9.2.1.</span> <span class="toc-text">创建数据表</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE%E8%A1%A8"><span class="toc-number">1.4.1.9.2.2.</span> <span class="toc-text">删除数据表</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E6%95%B0%E6%8D%AE%E8%A1%A8"><span class="toc-number">1.4.1.9.2.3.</span> <span class="toc-text">修改数据表</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%86%E5%9B%BEview"><span class="toc-number">1.4.1.9.3.</span> <span class="toc-text">视图（VIEW）</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E8%A7%86%E5%9B%BE"><span class="toc-number">1.4.1.9.3.1.</span> <span class="toc-text">创建视图</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E8%A7%86%E5%9B%BE"><span class="toc-number">1.4.1.9.3.2.</span> <span class="toc-text">删除视图</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95index"><span class="toc-number">1.4.1.9.4.</span> <span class="toc-text">索引（INDEX）</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95"><span class="toc-number">1.4.1.9.4.1.</span> <span class="toc-text">创建索引</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E7%B4%A2%E5%BC%95"><span class="toc-number">1.4.1.9.4.2.</span> <span class="toc-text">添加索引</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95"><span class="toc-number">1.4.1.9.4.3.</span> <span class="toc-text">创建唯一索引</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E7%B4%A2%E5%BC%95"><span class="toc-number">1.4.1.9.4.4.</span> <span class="toc-text">删除索引</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BA%A6%E6%9D%9F"><span class="toc-number">1.4.1.9.5.</span> <span class="toc-text">约束</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86"><span class="toc-number">1.4.1.10.</span> <span class="toc-text">事务处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6"><span class="toc-number">1.4.1.11.</span> <span class="toc-text">权限控制</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E8%B4%A6%E6%88%B7"><span class="toc-number">1.4.1.11.1.</span> <span class="toc-text">创建账户</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E8%B4%A6%E6%88%B7%E5%90%8D"><span class="toc-number">1.4.1.11.2.</span> <span class="toc-text">修改账户名</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E8%B4%A6%E6%88%B7"><span class="toc-number">1.4.1.11.3.</span> <span class="toc-text">删除账户</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E6%9D%83%E9%99%90"><span class="toc-number">1.4.1.11.4.</span> <span class="toc-text">查看权限</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8E%88%E4%BA%88%E6%9D%83%E9%99%90"><span class="toc-number">1.4.1.11.5.</span> <span class="toc-text">授予权限</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%9D%83%E9%99%90"><span class="toc-number">1.4.1.11.6.</span> <span class="toc-text">删除权限</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9B%B4%E6%94%B9%E5%AF%86%E7%A0%81"><span class="toc-number">1.4.1.11.7.</span> <span class="toc-text">更改密码</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B"><span class="toc-number">1.4.1.12.</span> <span class="toc-text">存储过程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B"><span class="toc-number">1.4.1.12.1.</span> <span class="toc-text">创建存储过程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B"><span class="toc-number">1.4.1.12.2.</span> <span class="toc-text">使用存储过程</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B8%B8%E6%A0%87"><span class="toc-number">1.4.1.13.</span> <span class="toc-text">游标</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A6%E5%8F%91%E5%99%A8"><span class="toc-number">1.4.1.14.</span> <span class="toc-text">触发器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E8%A7%A6%E5%8F%91%E5%99%A8"><span class="toc-number">1.4.1.14.1.</span> <span class="toc-text">创建触发器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E8%A7%A6%E5%8F%91%E5%99%A8"><span class="toc-number">1.4.1.14.2.</span> <span class="toc-text">查看触发器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E8%A7%A6%E5%8F%91%E5%99%A8"><span class="toc-number">1.4.1.14.3.</span> <span class="toc-text">删除触发器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sql%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">1.4.2.</span> <span class="toc-text">SQL 常见面试题</span></a></li></ol></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li class="active"><a href="/database/mysql/MySQL-JavaGuide/" rel="bookmark" title="MySQL-JavaGuide">MySQL-JavaGuide</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="范特东东东" data-src="/images/avatar.jpg"><p class="name" itemprop="name">范特东东东</p><div class="description" itemprop="description"></div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">51</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">16</span> <span class="name">分类</span></a></div></nav><div class="social"><span class="exturl item xiaohongshu" data-url="aHR0cHM6Ly93d3cueGlhb2hvbmdzaHUuY29tL3VzZXIvcHJvZmlsZS81ZTAyYzhhZDAwMDAwMDAwMDEwMDFmM2U=" title="https:&#x2F;&#x2F;www.xiaohongshu.com&#x2F;user&#x2F;profile&#x2F;5e02c8ad0000000001001f3e"><i class="ic i-xiaohongshu"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于我</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><span class="exturl" data-url="aHR0cHM6Ly9oangxNTkuZ2l0aHViLmlvL2NhdGVnb3JpZXMvcGhvdG9ncmFwaHkv"><i class="ic i-photography"></i>摄影</span></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/photography/%E6%97%A5%E8%90%BD%E6%94%B6%E9%9B%86%E8%AE%A1%E5%88%92/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/database/redis/Redis-JavaGuide/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/java/" title="分类于 Java">Java</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/" title="分类于 Java基础">Java基础</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/java-knowledge/" title="分类于 Java基础-知识点">Java基础-知识点</a></div><span><a href="/java/java-se/java-knowledge/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E5%AE%8B%E7%BA%A2%E5%BA%B7_%E7%AC%AC13%E7%AB%A0_%E6%B3%9B%E5%9E%8B/" title="宋红康_第13章_泛型(Generic)">宋红康_第13章_泛型(Generic)</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/java/" title="分类于 Java">Java</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/" title="分类于 Java基础">Java基础</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/java-excise/" title="分类于 Java基础-真题">Java基础-真题</a></div><span><a href="/java/java-se/java-excise/%E7%AC%AC05%E7%AB%A0%EF%BC%9A%E9%9A%8F%E5%A0%82%E5%A4%8D%E4%B9%A0%E4%B8%8E%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%A2%98%EF%BC%88%E6%95%B0%E7%BB%84%EF%BC%89/" title="宋红康_第05章：数组">宋红康_第05章：数组</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/photography/" title="分类于 摄影">摄影</a></div><span><a href="/photography/%E8%AF%BE%E4%B8%8A%E6%91%B8%E9%B1%BC/" title="课上摸鱼">课上摸鱼</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/java/" title="分类于 Java">Java</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/" title="分类于 Java基础">Java基础</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/java-knowledge/" title="分类于 Java基础-知识点">Java基础-知识点</a></div><span><a href="/java/java-se/java-knowledge/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E5%AE%8B%E7%BA%A2%E5%BA%B7_%E7%AC%AC18%E7%AB%A0_JDK8-17%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%88%E4%B8%8B%EF%BC%89/" title="宋红康_第18章_JDK8-17新特性（下）">宋红康_第18章_JDK8-17新特性（下）</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/java/" title="分类于 Java">Java</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/" title="分类于 Java基础">Java基础</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/java-excise/" title="分类于 Java基础-真题">Java基础-真题</a></div><span><a href="/java/java-se/java-excise/%E7%AC%AC01%E7%AB%A0%EF%BC%9A%E9%9A%8F%E5%A0%82%E5%A4%8D%E4%B9%A0%E4%B8%8E%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%A2%98%EF%BC%88Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0%EF%BC%89/" title="宋红康_第01章：Java语言概述">宋红康_第01章：Java语言概述</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/database/" title="分类于 数据库">数据库</a> <i class="ic i-angle-right"></i> <a href="/categories/database/elasticsearch/" title="分类于 Elasticsearch">Elasticsearch</a></div><span><a href="/database/elasticsearch/Elasticsearch-JavaGuide/" title="Elasticsearch-JavaGuide">Elasticsearch-JavaGuide</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/photography/" title="分类于 摄影">摄影</a></div><span><a href="/photography/%E6%9C%9D%E9%98%B3%E5%85%AC%E5%9B%AD/" title="朝阳公园">朝阳公园</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/java/" title="分类于 Java">Java</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/" title="分类于 Java基础">Java基础</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/java-knowledge/" title="分类于 Java基础-知识点">Java基础-知识点</a></div><span><a href="/java/java-se/java-knowledge/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E5%AE%8B%E7%BA%A2%E5%BA%B7_%E7%AC%AC15%E7%AB%A0_File%E7%B1%BB%E4%B8%8EIO%E6%B5%81/" title="宋红康_第15章_File类与IO流">宋红康_第15章_File类与IO流</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/java/" title="分类于 Java">Java</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/" title="分类于 Java基础">Java基础</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/java-knowledge/" title="分类于 Java基础-知识点">Java基础-知识点</a></div><span><a href="/java/java-se/java-knowledge/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E5%AE%8B%E7%BA%A2%E5%BA%B7_%E7%AC%AC16%E7%AB%A0_%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" title="宋红康_第16章_网络编程">宋红康_第16章_网络编程</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/database/" title="分类于 数据库">数据库</a> <i class="ic i-angle-right"></i> <a href="/categories/database/redis/" title="分类于 Redis">Redis</a></div><span><a href="/database/redis/Redis-JavaGuide/" title="Redis-JavaGuide">Redis-JavaGuide</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2023</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">范特东东东 @ fantedong</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">1.6m 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">23:30</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"database/mysql/MySQL-JavaGuide/",favicon:{show:"(●´3｀●)欢迎回来",hide:"(〃＞皿＜)你快回来"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hrmmi -->