<!-- build time:Sat Apr 27 2024 21:40:50 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="水文 & 摄影" href="http://example.com/rss.xml"><link rel="alternate" type="application/atom+xml" title="水文 & 摄影" href="http://example.com/atom.xml"><link rel="alternate" type="application/json" title="水文 & 摄影" href="http://example.com/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><link rel="canonical" href="http://example.com/database/elasticsearch/Elasticsearch%20%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/"><title>Elasticsearch 常见面试题总结 - Elasticsearch - 数据库 | fantedong = 水文 & 摄影 = 为了能更好地查看图片，你需要一点魔法</title><meta name="generator" content="Hexo 6.3.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">Elasticsearch 常见面试题总结</h1><div class="meta"><span class="item" title="创建时间：2023-11-17 20:05:10"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2023-11-17T20:05:10+08:00">2023-11-17</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>20k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>18 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">fantedong</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><img src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/1460000037659003"></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/database/" itemprop="item" rel="index" title="分类于 数据库"><span itemprop="name">数据库</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/database/elasticsearch/" itemprop="item" rel="index" title="分类于 Elasticsearch"><span itemprop="name">Elasticsearch</span></a><meta itemprop="position" content="2"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://example.com/database/elasticsearch/Elasticsearch%20%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="范特东东东"><meta itemprop="description" content="为了能更好地查看图片，你需要一点魔法, "></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="水文 & 摄影"></span><div class="body md" itemprop="articleBody"><h1 id="es-基础"><a class="anchor" href="#es-基础">#</a> ES 基础</h1><h2 id="es-是什么"><a class="anchor" href="#es-是什么">#</a> ES 是什么</h2><p>ElasticSearch 是一个开源的<font color="red">分布式、RESTful 搜索和分析引擎</font>，可以用来解决使用数据库进行<strong>模糊搜索</strong>时存在的性能问题，适用于<strong>所有数据类型</strong>，包括文本、数字、地理空间、结构化和非结构化数据。</p><p>ElasticSearch 使用 Java 语言开发，<font color="red">基于 Lucece</font>。ES 早期版本需要 JDK，在 7.X 版本后<font color="red">已经集成了 JDK，已无需第三方依赖</font>。</p><p>Github 地址：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2VsYXN0aWMvZWxhc3RpY3NlYXJjaA==">https://github.com/elastic/elasticsearch</span> 。</p><h2 id="lucene-是什么"><a class="anchor" href="#lucene-是什么">#</a> Lucene 是什么</h2><p>Lucene 是一个 Java 语言编写的高性能、全功能的<strong>文本搜索引擎库</strong>，提供强大的索引和搜索功能，以及拼写检查、高亮显示和高级分析功能。</p><p>如果我们直接基于 Lucene 开发，会非常复杂。并且，<font color="red">Lucene 并没有分布式、高可用的解决方案</font>。像 ElasticSearch 就是基于 Lucene 开发的，<font color="red">ES 封装了许多 Lucene 底层功能</font>，提供了简单易用的 RestFul API 接口和多种语言的客户端，开箱即用，自带分布式以及高可用的解决方案。</p><p>Github 地址：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FwYWNoZS9sdWNlbmU=">https://github.com/apache/lucene</span></p><h2 id="es-能做什么"><a class="anchor" href="#es-能做什么">#</a> ES 能做什么？</h2><p>举几个常见的例子：</p><ul><li><p>实现各种<font color="red">网站的关键词检索功能</font>，比如电商网站的商品检索、维基百科的词条搜索、Github 的项目检索；</p></li><li><p>本地生活类 APP（比如美团），<font color="red">基于定位实现附近美食 / 娱乐的推荐</font>；</p></li><li><p>结合 Elasticsearch、Kibana、Beats 和 Logstash 这些 Elastic Stack 的组件实现一个功能完善的<font color="red">日志系统</font>。</p></li><li><p>使用 Elasticsearch 作为<font color="red">地理信息系统 (GIS) 管理</font>、集成和分析空间信息。</p></li><li><p>......</p></li></ul><p>电商网站检索：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20240325182615229.png" alt="image-20240325182615229"></p><p>ELK 日志采集系统架构（负责日志的搜索)：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20240325182631912.png" alt="image-20240325182631912"></p><h2 id="为什么用-esmysql-不行吗"><a class="anchor" href="#为什么用-esmysql-不行吗">#</a> 为什么用 ES？MySQL 不行吗？</h2><p>Elasticsearch 主要为系统提供<font color="red">搜索功能</font>，MySQL 这类传统关系型数据库主要为系统提供数据存储功能。</p><p>MySQL 虽然也能提供简单的搜索功能，但是搜索并不是它擅长的领域。</p><p>我们可以从下面两个方面来看：</p><p><strong>1) 传统关系型数据库的痛点：</strong></p><ul><li><font color="red">MySQL 在大数据量下查询效率低下，模糊匹配有可能导致全表扫描</font>。</li><li><font color="red">MySQL 全文索引只支持 CHAR，VARCHAR 或者 TEXT 字段类型，不支持分词器</font>。</li></ul><p><strong>2) Elasticsearch 的优势 ：</strong></p><ul><li>支持<font color="red">多种数据类型</font>，非结构化，数值，地理信息。</li><li>简单的 RESTful API，天生的兼容多语言开发。</li><li>提供更<font color="red">丰富的分词器</font>，支持热点词汇查询。</li><li><font color="red">近实时查询</font>，Elasticsearch 每隔 1s 把数据存储至系统缓存中，且使用倒排索引提高检索效率。</li><li>支持<font color="red">相关性搜索</font>，可以根据条件对结果进行打分。</li><li><font color="red">天然分布式存储</font>，使用分片支持更大的数据量。</li></ul><h2 id="es-中的基本概念"><a class="anchor" href="#es-中的基本概念">#</a> ES 中的基本概念</h2><ul><li><p><font color="cornflowerblue">Index（索引）</font> ：作为名词理解的话，索引是 **<font color="red">一类拥有相似特征的文档的集合</font><strong>。比如商品索引、商家索引、订单索引，</strong><font color="red">有点类似于 MySQL 中的表</font>**。作为动词理解的话，索引就是将一份文档保存在一个索引中。</p></li><li><p><font color="cornflowerblue">Document（文档）</font> ：<font color="red"><strong>可搜索的最小单位</strong>，用于存储数据，一般为 JSON 格式</font>。文档<font color="red">由一个或者多个字段 (Field) 组成</font>，字段类型可以是布尔，数值，字符串、二进制、日期等数据类型。</p></li><li><p><font color="cornflowerblue">Type（字段类型）</font> : 每个文档在 ES 中都必须设定它的类型。ES 7.0 之前，一个 Index 可以有多个 Type。6.0 开始，Type 已经被 Deprecated。7.0 开始，一个索引只能创建一个 Type ：_doc。<font color="red">8.0 之后，Type 被完全删除</font>，删除的原因看这里：<span class="exturl" data-url="aHR0cHM6Ly93d3cuZWxhc3RpYy5jby9ndWlkZS9lbi9lbGFzdGljc2VhcmNoL3JlZmVyZW5jZS83LjE3L3JlbW92YWwtb2YtdHlwZXMuaHRtbA==">https://www.elastic.co/guide/en/elasticsearch/reference/7.17/removal-of-types.html</span> 。</p></li><li><p><font color="cornflowerblue">Mapping（映射）</font>：<font color="red">定义字段名称、数据类型、优化信息（比如是否索引)、分词器</font>，<strong><font color="red">有点类似于数据库中的表结构定义</font></strong>。一个 Index 对应一个 Mapping。</p></li><li><p><font color="cornflowerblue">Node（节点）</font> : 相当于<font color="red">一个 ES 实例</font>，多个节点构成一个集群。</p></li><li><p><font color="cornflowerblue">Cluster（集群）</font> ：<font color="red">多个 ES 节点的集合</font>，用于解决单个节点无法处理的搜索需求和数据存储需求。</p></li><li><p><font color="cornflowerblue">Shard（分片）</font>: Index（索引）被分为多个碎片，存储在不同的 Node 节点上的分片中，以提高性能和吞吐量。</p></li><li><p><font color="cornflowerblue">Replica（副本）</font>：<font color="red">Index 副本</font>，每个 Index 有一个或多个副本，以提高拓展功能和吞吐量。</p></li><li><p><font color="cornflowerblue">DSL (查询语言) </font>：<font color="red">基于 JSON 的查询语言</font>，<strong><font color="red">类似于 SQL 语句</font></strong>。</p></li></ul><p>ES 与 MySQL 的概念简单类比：</p><table><thead><tr><th>Elasticsearch</th><th>MySQL</th></tr></thead><tbody><tr><td><center><strong>Index（索引）</strong></center></td><td><center><strong>Table（表）</strong></center></td></tr><tr><td><center>Document（文档）</center></td><td><center>Row（行）</center></td></tr><tr><td><center>Field（字段）</center></td><td><center>Column（列）</center></td></tr><tr><td><center><strong>Mapping（映射）</strong></center></td><td><center><strong>Schema（约束）</strong></center></td></tr><tr><td><center>DSL（查询语言）</center></td><td><center>SQL（查询语言）</center></td></tr></tbody></table><p>数据示例如下：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/20200902105313864.png" alt="img"></p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/bb8dc00fa4d9452db26614db0f5f0875.png" alt="img"></p><h1 id="倒排索引-正排索引"><a class="anchor" href="#倒排索引-正排索引">#</a> 倒排索引 &amp; 正排索引</h1><h2 id="倒排索引是什么"><a class="anchor" href="#倒排索引是什么">#</a> 倒排索引是什么</h2><p><strong><font color="#B32015">倒排索引</font></strong> 也被称作反向索引（inverted index），是用于<font color="red">提高数据检索速度</font>的一种数据结构，空间消耗比较大。倒排索引首先将检索文档进行 **<font color="red">分词</font><strong>得到多个词语 / 词条，然后</strong><font color="red">将词语和文档 ID 建立关联</font>**，从而提高检索效率。</p><blockquote><p>分词就是对一段文本，通过规则或者算法分出多个词，<font color="red">每个词作为搜索的最细粒度</font>，一个个单字或者单词。分词的目的主要是为了搜索，尤其在数据量大的情况下，分词的实现可以快速、高效的筛选出相关性高的文档内容。</p></blockquote><p>如下图所示，<font color="red">倒排索引使用 <strong><font color="cornflowerblue">词语 / 词条（Term）</font></strong> 来作为索引关键字</font>，并同时记录了哪些 <strong><font color="cornflowerblue">文档（Document）</font></strong> 中有这个词语。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20240325192911330.png" alt="image-20240325192911330"></p><ul><li>文档（Document）：用来搜索的数据，其中的每一条数据就是一个文档。例如一个商品信息、商家信息、一页网页的内容。</li><li>词语 / 词条（Term）：对文档数据或用户搜索数据，利用某种算法分词，得到的具备含义的词语就是词条。例如 “数据库索引可以大幅提高查询速度” 这段话被中文分词器 IK Analyzer 细粒度分词后得到 [数据库，索引，可以，大幅，提高，查询，速度]。</li><li><font color="cornflowerblue">词典（Term Dictionary）</font>：Term 的集合。</li></ul><p><font color="red">Lucene 就是基于倒排索引来做的全文检索，并且 ElasticSearch 还对倒排索引做了进一步优化。</font></p><h2 id="倒排索引的创建流程和检索流程"><a class="anchor" href="#倒排索引的创建流程和检索流程">#</a> 倒排索引的创建流程和检索流程</h2><p>这里只是简单介绍一下倒排索引的创建和检索流程，实际应用中，远比下面介绍的复杂，不过大体原理还是一样的。</p><p>倒排索引的创建流程：</p><ol><li><p><font color="red">建立文档列表</font>，每个文档都有一个唯一的文档 ID 与之对应。</p></li><li><p>通过分词器<font color="red">对文档进行分词</font>，生成类似于 &lt;词语，文档 ID&gt; 的一组组数据。</p></li><li><p><strong><font color="red">将词语作为索引的关键字，记录下词语和文档的对应关系</font></strong>，也就是哪些文档中包含了该词语。</p></li></ol><p>这里可以记录更多信息比如词语的位置、词语出现的频率，这样可以方便高亮显示以及对搜索结果进行排序（后文会介绍到）。</p><p><font color="red">Lucene 的倒排索引</font>大致是下面这样的（图源：<span class="exturl" data-url="aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAzNzY1ODk5NyVFRiVCQyU4OSVFRiVCQyU5QQ==">https://segmentfault.com/a/1190000037658997）：</span></p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/1460000037659003" alt="img"></p><p>倒排索引的检索流程：</p><ol><li><p><font color="red">根据分词，查找对应文档 ID</font></p></li><li><p>根据文档 ID 找到文档</p></li></ol><h2 id="倒排索引的组成"><a class="anchor" href="#倒排索引的组成">#</a> 倒排索引的组成</h2><ul><li><font color="cornflowerblue">单词字典（Term Dictionary）</font>：<font color="red">一个存储了所有单词的集合</font>，一般用 B+Tree 或 Hash 拉链法存储，提高查询效率。</li><li><font color="cornflowerblue">倒排列表（Posting List）</font>：<font color="red">每个单词对应一个倒排列表，记录了包含该单词的所有文档</font>。包括以下字段属性：<ul><li>DocID：即<font color="red">文档 id</font></li><li>TF : 单词出现频率，简称<font color="red">词频</font></li><li>Position：单词在文档中出现的<font color="red">位置</font>，用于检索</li><li>Offset：<font color="red">偏移量</font>，记录单词的开始和结束位置，用于高亮显示</li></ul></li></ul><p>倒排列表（Posting List）的例子：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/ebb7e8e66fcf4a2da331ceeea3c8d0b4.png" alt="img"></p><h2 id="正排索引是什么"><a class="anchor" href="#正排索引是什么">#</a> 正排索引是什么</h2><p>与倒排索引相反，正排索引是 **<font color="red">使用文档 ID 作为索引关键字，将文档 ID 和分词建立关联</font>**。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20240325195834207.png" alt="image-20240325195834207"></p><p><font color="red">根据词语查询时，必须<strong>先逐条获取每个文档</strong>，然后判断文档中是否包含所需要的词语，查询效率较低</font>。</p><h2 id="正排索引与倒排索引的区别"><a class="anchor" href="#正排索引与倒排索引的区别">#</a> 正排索引与倒排索引的区别</h2><p>正排索引：</p><ul><li>优点：维护成本低，新增数据的时候，只要在末尾新增一个 ID</li><li>缺点：<font color="red">以 DocID 为索引</font>，查询时需要扫描所有文档，一个一个比较，直至查到关键词，查询效率较低。</li></ul><p>倒排索引：</p><ul><li>优点：<font color="red">以 分词 为索引</font>，建立分词和 DocID 关系，<font color="red">大大提高查询效率</font></li><li>缺点：<strong><font color="red">倒排索引的建立、维护成本高</font></strong>。因为<font color="red">文档的每次更新都意味着倒排索引的重建</font>。还有一些<font color="red">搜索精度的问题</font>，比如搜索 dogs 和 dog 想要相同匹配结果，这时就需要合适的分词器了。</li></ul><h2 id="es-可以针对某些字段不做索引吗"><a class="anchor" href="#es-可以针对某些字段不做索引吗">#</a> ES 可以针对某些字段不做索引吗？</h2><p>答案是可以的。</p><p>文档会被序列化为字段组成的 JSON 格式保存在 ES 中，我们可以针对某些地段不做索引。这样可以节省存储空间，但是，<font color="red">同时也会让字段无法被搜索</font>。</p><h1 id="分词器analyzer"><a class="anchor" href="#分词器analyzer">#</a> 分词器（Analyzer）</h1><h2 id="分词器的作用"><a class="anchor" href="#分词器的作用">#</a> 分词器的作用</h2><p>分词器是搜索引擎的一个核心组件，负责对文档内容进行分词 (在 ES 里面被称为 Analysis)，也就是<font color="red">将一个文档转换成 <strong>单词词典（Term Dictionary）</strong></font>。单词词典是由文档中出现过的所有单词构成的字符串集合。为了满足不同的分词需求，分词器有很多种，<font color="red">不同分词器的分词逻辑不一样</font>。</p><h2 id="常用的分词器"><a class="anchor" href="#常用的分词器">#</a> 常用的分词器</h2><p><font color="cornflowerblue">非中文分词器</font>：</p><ul><li><p><strong>Standard Analyzer</strong>：标准分词器，也是<font color="red">默认分词器</font>， 英文转换成小写，中文只支持单字切分。</p></li><li><p>Simple Analyzer：简单分词器，通过非字母字符来分割文本信息，英文大写转小写，非英文不进行分词。</p></li><li><p>Stop Analyzer ：在 Simple Analyzer 基础上去除 the，a，is 等词，也就是加入了停用词。</p></li><li><p>Whitespace Analyzer : 空格分词器，通过空格来分割文本信息，非英文不进行分词。</p></li></ul><p>上面这些也都是 ES 内置的分词器，详细介绍请看官方文档：<span class="exturl" data-url="aHR0cHM6Ly93d3cuZWxhc3RpYy5jby9ndWlkZS9lbi9lbGFzdGljc2VhcmNoL3JlZmVyZW5jZS9jdXJyZW50L2FuYWx5c2lzLWFuYWx5emVycy5odG1sJUUzJTgwJTgy">https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-analyzers.html。</span></p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20240326162809063.png" alt="image-20240326162809063" style="zoom:67%"><p>这个官方文档为每一个分词器都列举了对应的例子帮助理解，比如 Standard Analyzer 的例子是下面这样的。</p><ul><li><p>输入文本内容： <code>&quot;The 2 QUICK Brown-Foxes jumped over the lazy dog's bone.&quot;</code></p></li><li><p>分词结果： <code>[ the, 2, quick, brown, foxes, jumped, over, the, lazy, dog's, bone ]</code></p></li></ul><p><font color="cornflowerblue">中文分词器</font>：</p><ul><li><p><strong>IK Analyzer（推荐）</strong>：<font color="red">最常用的开源中文分词器</font>，Github 地址：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL21lZGNsL2VsYXN0aWNzZWFyY2gtYW5hbHlzaXMtaWslRUYlQkMlOEMlRTUlOEMlODUlRTYlOEIlQUMlRTQlQjglQTQlRTclQTclOEQlRTUlODglODYlRTglQUYlOEQlRTYlQTglQTElRTUlQkMlOEYlRUYlQkMlOUE=">https://github.com/medcl/elasticsearch-analysis-ik，包括两种分词模式：</span></p><ul><li><p><strong>ik_max_word</strong>：细粒度切分模式，会将文本做最细粒度的拆分，尽可能多的拆分出词语 。</p></li><li><p><strong>ik_smart</strong>：智能模式，会做最粗粒度的拆分，已被分出的词语将不会再次被其它词语占有。</p></li></ul></li><li><p>Ansj ：基于 n-Gram+CRF+HMM 的中文分词的 Java 实现，分词速度达到每秒钟大约 200 万字左右（mac air 下测试），准确率能达到 96% 以上。实现了中文分词、中文姓名识别、用户自定义词典、关键字提取、自动摘要、关键字标记等功能。Github 地址：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL05MUGNoaW5hL2Fuc2pfc2Vn">https://github.com/NLPchina/ansj_seg</span> 。</p></li><li><p>ICU Analyzer：提供 Unicode 支持，更好地支持亚洲语言。</p></li><li><p>THULAC（THU Lexical Analyzer for Chinese）：清华大学推出的一套中文词法分析工具包，具有中文分词和词性标注功能。Github 地址：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RodW5scC9USFVMQUMtUHl0aG9u">https://github.com/thunlp/THULAC-Python</span> 。</p></li><li><p>Jcseg ：基于 mmseg 算法的一个轻量级中文分词器，同时集成了关键字提取，关键短语提取，关键句子提取和文章自动摘要等功能。Gitee 地址：<span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vbGlvbnNvdWwvamNzZWc=">https://gitee.com/lionsoul/jcseg</span> 。</p></li></ul><p>IK Analyzer 分词示例：</p><ul><li><p>输入文本内容： <code>&quot;数据库索引可以大幅提高查询速度&quot;</code></p></li><li><p>分词结果：</p><ul><li><p>细粒度切分模式： <code>[数据库,索引,可以,大幅,提高,查询,速度]</code></p></li><li><p>智能模式： <code>[数据库,数据,索引,可以,大幅,提高,查询,速度]</code></p></li></ul></li></ul><p><font color="cornflowerblue">其他分词器 </font>：</p><ul><li><p>Keyword Analyzer：关键词分词器，输入文本等于输出文本。</p></li><li><p>Fingerprint Analyzer：指纹分析仪分词器，通过创建标记进行检测。</p></li></ul><p>上面这两个也是 ES 内置的分词器。</p><p>Keyword Analyzer 分词示例：</p><ul><li><p>输入文本内容： <code>&quot;The 2 QUICK Brown-Foxes jumped over the lazy dog's bone.&quot;</code></p></li><li><p>分词结果： <code>[ The 2 QUICK Brown-Foxes jumped over the lazy dog's bone. ]</code></p></li></ul><h2 id="分词器的组成"><a class="anchor" href="#分词器的组成">#</a> 分词器的组成</h2><p>分词器由三个组件组成：</p><ul><li><font color="cornflowerblue">字符过滤器（Charater Filters）</font>：处理原始文本，例如去除 HTMl 标签。</li><li><font color="cornflowerblue">分词器（Tokenizer）</font>：按分词器规则切分单词。</li><li><font color="cornflowerblue">单词过滤器（Token Filters）</font>：对切分后的单词加工，包括转小写，切除停用词，添加近义词</li></ul><p>三者顺序：Character Filters —&gt; Tokenizer —&gt; Token Filter</p><p>三者个数：CharFilters（0 个或多个） + Tokenizer (一个) + TokenFilters (0 个或多个)</p><p>下图是默认分词器 Standard Analyzer 的分词流程：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20240326164447436.png" alt="image-20240326164447436"></p><h2 id="es-如何基于拼音来搜索中文内容"><a class="anchor" href="#es-如何基于拼音来搜索中文内容">#</a> ES 如何基于拼音来搜索中文内容？</h2><p>可以使用<strong>拼音分词器</strong>，它用于汉字和拼音之间的转换，集成了 NLP 工具（<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL05MUGNoaW5hL25scC1sYW5nJUVGJUJDJTg5JUVGJUJDJThDR2l0aHVi">https://github.com/NLPchina/nlp-lang），Github</span> 地址：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL21lZGNsL2VsYXN0aWNzZWFyY2gtYW5hbHlzaXMtcGlueWluJUUzJTgwJTgy">https://github.com/medcl/elasticsearch-analysis-pinyin。</span></p><h1 id="es-数据类型"><a class="anchor" href="#es-数据类型">#</a> ES 数据类型</h1><h2 id="es-常见数据类型"><a class="anchor" href="#es-常见数据类型">#</a> ES 常见数据类型</h2><p><strong>常见类型：</strong></p><ul><li><p><font color="red">关键词</font>： <code>keyword</code> 、 <code>constant_keyword</code> ，和 <code>wildcard</code> （通配符）</p></li><li><p>数值型： <code>long</code> , <code>integer</code> , <code>short</code> , <code>byte</code> , <code>double</code> , <code>float</code> , <code>half_float</code> , <code>scaled_float</code></p></li><li><p>布尔型： <code>boolean</code></p></li><li><p>日期型： <code>date</code> , <code>date_nanos</code></p></li><li><p>二进制： <code>binary</code></p></li></ul><p><strong>结构化数据类型：</strong></p><ul><li><p><font color="red">范围型</font>： <code>integer_range</code> , <code>float_range</code> , <code>long_range</code> , <code>double_range</code> , <code>date_range</code></p></li><li><p><font color="red">ip 地址类型</font> ： <code>ip</code></p></li><li><p><font color="red">软件版本</font> ： <code>version</code></p></li></ul><p><strong>文字搜索类型：</strong></p><ul><li><p>非结构化文本 ： <code>text</code></p></li><li><p>包含特殊标记的文本： <code>annotated-text</code></p></li><li><p><font color="red">自动完成建议</font>： <code>completion</code></p></li></ul><p><strong>对象和关系类型：</strong></p><ul><li><p><font color="red">嵌套类型</font>： <code>nested</code> 、 <code>join</code></p></li><li><p><font color="red">对象类型</font>： <code>object</code> 、 <code>flattened</code></p></li></ul><p><strong>空间类型：</strong></p><ul><li><p>地理坐标类型 ： <code>geo_point</code></p></li><li><p>地理形状类型 ： <code>geo_shape</code></p></li></ul><p>Elasticsearch 官方文档中有详细介绍到各个数据类型的使用：<span class="exturl" data-url="aHR0cHM6Ly93d3cuZWxhc3RpYy5jby9ndWlkZS9lbi9lbGFzdGljc2VhcmNoL3JlZmVyZW5jZS9jdXJyZW50L21hcHBpbmctdHlwZXMuaHRtbA==">https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-types.html</span> 。</p><h2 id="keyword-和-text-的区别"><a class="anchor" href="#keyword-和-text-的区别">#</a> keyword 和 text 的区别</h2><ul><li><font color="red"><code>keyword</code> 不走分词器</font>，而 <code>text</code> 会走分词器</li><li><font color="red">使用 <code>keyword</code> 关键字查询效率更高</font>，一般在 <code>fields</code> 中定义 <code>keyword</code> 类型字段</li></ul><figure class="highlight json"><figcaption data-lang="JSON"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token property">"name"</span> <span class="token operator">:</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>          <span class="token property">"type"</span> <span class="token operator">:</span> <span class="token string">"text"</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="3"></td><td><pre>          <span class="token property">"fields"</span> <span class="token operator">:</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>            <span class="token property">"keyword"</span> <span class="token operator">:</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>              <span class="token property">"type"</span> <span class="token operator">:</span> <span class="token string">"keyword"</span></pre></td></tr><tr><td data-num="6"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>          <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h2 id="es-中没有专门的数组类型"><a class="anchor" href="#es-中没有专门的数组类型">#</a> ES 中没有专门的数组类型</h2><p>在 Elasticsearch 中，没有专门的数组数据类型。<font color="red">默认情况下，任何字段都可以包含零个或多个值，但是数组中的所有值必须具有相同的数据类型</font>。</p><h2 id="es-不能在-mapping-中修改字段类型"><a class="anchor" href="#es-不能在-mapping-中修改字段类型">#</a> ES 不能在 Mapping 中修改字段类型</h2><p>前文说了，Elasticsearch 中的 Mapping 类似于数据库中的表结构定义，<strong><font color="red">Mapping 中的字段类型只能增加不能修改，否则只能 <code>reindex</code> 重新索引或者重新进行数据建模并导入数据</font></strong>。</p><h2 id="nested嵌套数据类型"><a class="anchor" href="#nested嵌套数据类型">#</a> Nested（嵌套）数据类型</h2><p>官方文档是这样介绍 Nested 数据类型的：</p><blockquote><p>The <code>nested</code> type is a specialised version of the <span class="exturl" data-url="aHR0cHM6Ly93d3cuZWxhc3RpYy5jby9ndWlkZS9lbi9lbGFzdGljc2VhcmNoL3JlZmVyZW5jZS9jdXJyZW50L29iamVjdC5odG1s">object</span> data type that allows arrays of objects to be indexed in a way that they can be queried independently of each other.</p><p>Nested（嵌套）数据类型是对象数据类型的特殊版本，<font color="red">它允许对象数组以一种可以相互独立查询的方式进行索引</font>。</p></blockquote><p>Nested 数据类型可以<strong>避免数组扁平化处理</strong>，多个数组的字段会做一个笛卡尔积，导致查询出不存在的数据。</p><figure class="highlight json"><figcaption data-lang="JSON"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 会导致查询 John White 也会匹配，将类型改为 nested 问题解决</span></pre></td></tr><tr><td data-num="2"></td><td><pre>PUT my_index/_doc/<span class="token number">1</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>  <span class="token property">"group"</span> <span class="token operator">:</span> <span class="token string">"fans"</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="5"></td><td><pre>  <span class="token property">"user"</span> <span class="token operator">:</span> <span class="token punctuation">[</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>      <span class="token property">"first"</span> <span class="token operator">:</span> <span class="token string">"John"</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="8"></td><td><pre>      <span class="token property">"last"</span> <span class="token operator">:</span>  <span class="token string">"Smith"</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>      <span class="token property">"first"</span> <span class="token operator">:</span> <span class="token string">"Alice"</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="12"></td><td><pre>      <span class="token property">"last"</span> <span class="token operator">:</span>  <span class="token string">"White"</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>  <span class="token punctuation">]</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h2 id="copy_to字段复制"><a class="anchor" href="#copy_to字段复制">#</a> copy_to：字段复制</h2><p>在 Elasticsearch 中， <code>copy_to</code> 是一个字段映射参数，<strong><font color="red">它允许你将文档中一个或多个字段的内容复制到一个单独的字段中</font></strong>。这对于需要在搜索中<font color="red">针对多个字段执行相似的查询或分析操作</font>时非常有用。</p><p>以下是 <code>copy_to</code> 参数的一些关键点：</p><ol><li><p><strong>用法</strong>：在创建或更新索引的映射 (mapping) 时，你可以为一个字段指定 <code>copy_to</code> 参数，用来指定要复制到的目标字段。</p></li><li><p>目标字段：目标字段是你指定的一个或多个字段，用于接收源字段的内容。这个字段可以是一个新字段，也可以是现有的字段。</p></li><li><p>用途： <code>copy_to</code> 主要用于创建索引时将文档的某些信息复制到一个单独的字段中。这在需要对多个字段执行相同的查询或分析时很有用。</p></li><li><p>示例：假设你有一个文档包含标题 (title) 和内容 (content) 两个字段，并且你希望能够对这两个字段进行全文搜索。你可以使用 <code>copy_to</code> 将这两个字段的内容都复制到一个新的字段（例如 <code>combined_text</code> ），然后对 <code>combined_text</code> 执行全文搜索。</p><figure class="highlight json"><figcaption data-lang="JSON"></figcaption><table><tr><td data-num="1"></td><td><pre>PUT my_index</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token property">"mappings"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token property">"properties"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>      <span class="token property">"title"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"text"</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token property">"copy_to"</span><span class="token operator">:</span> <span class="token string">"combined_text"</span></pre></td></tr><tr><td data-num="8"></td><td><pre>      <span class="token punctuation">&#125;</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="9"></td><td><pre>      <span class="token property">"content"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"text"</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token property">"copy_to"</span><span class="token operator">:</span> <span class="token string">"combined_text"</span></pre></td></tr><tr><td data-num="12"></td><td><pre>      <span class="token punctuation">&#125;</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="13"></td><td><pre>      <span class="token property">"combined_text"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"text"</span></pre></td></tr><tr><td data-num="15"></td><td><pre>      <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>在这个示例中，当文档被索引时， <code>title</code> 和 <code>content</code> 字段的内容都会被复制到 <code>combined_text</code> 字段中。然后，你可以对 <code>combined_text</code> 字段执行搜索操作，以获取包含标题和内容的文档。</p></li></ol><p>总之， <code>copy_to</code> 是一个非常实用的 Elasticsearch 映射参数，它使你能够轻松地将文档的内容从多个字段中复制到一个单独的字段，以满足特定的搜索或分析需求。</p><h1 id="映射mapping"><a class="anchor" href="#映射mapping">#</a> 映射（Mapping）</h1><h2 id="mapping-是什么"><a class="anchor" href="#mapping-是什么">#</a> Mapping 是什么</h2><p>Mapping（映射）定义<font color="red">字段名称、数据类型、优化信息（比如是否索引)、分词器</font>，有点类似于数据库中的表结构定义。<font color="red">一个 Index 对应一个 Mapping</font>。</p><p>Mapping 分为动态 Mapping 和显示 Mapping 两种：</p><ul><li><font color="cornflowerblue">动态 Mapping</font>：根据待索引数据，自动建立索引、自动定义映射类型。</li><li><font color="cornflowerblue">显示 Mapping</font>：手动控制字段的存储和索引方式，比如哪些字符串字段应被视为全文字段。</li></ul><figure class="highlight json"><figcaption data-lang="JSON"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 通过显示 Mapping 创建索引</span></pre></td></tr><tr><td data-num="2"></td><td><pre>PUT /my-index<span class="token number">-000001</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>  <span class="token property">"mappings"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token property">"properties"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>      <span class="token property">"age"</span><span class="token operator">:</span>    <span class="token punctuation">&#123;</span> <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"integer"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="7"></td><td><pre>      <span class="token property">"email"</span><span class="token operator">:</span>  <span class="token punctuation">&#123;</span> <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"keyword"</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="8"></td><td><pre>      <span class="token property">"name"</span><span class="token operator">:</span>   <span class="token punctuation">&#123;</span> <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"text"</span>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>动态 Mapping 使用起来比较简单，在初学 Elasticsearch 的时候可以使用。<font color="red">实际项目中，应该尽量手动定义 显示 Mapping 关系</font>。</p><h2 id="为什么插入数据时不需要指定-mapping"><a class="anchor" href="#为什么插入数据时不需要指定-mapping">#</a> 为什么插入数据时不需要指定 Mapping ？</h2><p>因为在写入文档时，如果索引不存在，Elasticsearch 会自动根据数据类型<strong>自动推断 Mapping 信息</strong>（动态 Mapping），但有时候不是很准确。</p><h2 id="mapping-自定义"><a class="anchor" href="#mapping-自定义">#</a> Mapping 自定义</h2><p>如果纯手写的话，工作量太大，还容易写错，所以可以参考以下步骤：</p><ol><li><font color="red">创建临时 Index</font>，插入一些临时数据；</li><li>访问 Mapping API，<font color="red">获取相关 Mapping 定义</font>；</li><li><font color="red">在此基础上进行修改</font>，如添加 keyword，nested 类型；</li><li><font color="red">删除临时 Index</font>。</li></ol><h2 id="动态-mapping-的-4-种属性配置"><a class="anchor" href="#动态-mapping-的-4-种属性配置">#</a> 动态 Mapping 的 4 种属性配置</h2><ul><li><code>dynamic = true</code> : 新字段被添加到 Mapping 中<font color="red">（默认）</font></li><li><code>dynamic = runtime</code> 新字段作为运行时字段添加到 Mapping 中，<font color="red">这些字段未编入索引</font>，并_source 在查询时加载。</li><li><code>dynamic = false</code> ：<font color="red">新字段将被忽略</font>，这些字段不会被索引或可搜索</li><li><code>dynamic = strict</code> ： 如果检测到新字段，则会<font color="red">抛出异常并拒绝文档</font>，<font color="red">新字段必须显式添加到 Mapping 中</font>。</li></ul><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20240326190922620.png" alt="image-20240326190922620"></p><h2 id="动态-mapping-如何防止字段无限增加"><a class="anchor" href="#动态-mapping-如何防止字段无限增加">#</a> 动态 Mapping 如何防止字段无限增加？</h2><blockquote><p>摘自官方文档：<span class="exturl" data-url="aHR0cHM6Ly93d3cuZWxhc3RpYy5jby9ndWlkZS9lbi9lbGFzdGljc2VhcmNoL3JlZmVyZW5jZS9jdXJyZW50L21hcHBpbmctc2V0dGluZ3MtbGltaXQuaHRtbA==">Mapping limit settings</span> 。</p></blockquote><p><font color="red">如果使用了动态映射，插入的每个新文档都可能引入新字段</font>。在索引中定义太多字段会导致<strong>映射爆炸</strong>，从而导致内存不足的错误和难以恢复的情况。使用<strong>映射限制设置</strong>来限制字段映射的数量（手动或动态创建）并防止映射爆炸。</p><ul><li><code>index.mapping.total_fields.limit</code> ：限制了<font color="red">索引中的字段最大数量</font>。字段、对象映射以及字段别名计入此限制，默认值为 <strong>1000</strong>。限制的目的是为了防止映射和搜索变得太大。较高的值会导致性能下降和内存问题，尤其是在负载高或资源很少的集群中。</li><li><code>index.mapping.depth.limit</code> ：<font color="red">字段的最大深度</font>，以内部对象的数量来衡量。如果所有字段都在根对象级别定义，则深度为 1。如果有一个对象映射，则深度为 2 ，默认为 <strong>20</strong>。</li><li><code>index.mapping.nested_fields.limit</code> ： <code>nested</code> 索引中不同映射的最大数量， <code>nested</code> 类型只应在需要相互独立地查询对象数组时使用，默认为 <strong>50</strong>。</li><li><code>index.mapping.nested_objects.limit</code> ：单个文档可以包含的嵌套 JSON 对象（ <code>nested</code> 类型）的最大数量，默认为 <strong>10000</strong>。</li><li><code>index.mapping.field_name_length.limit</code> ：设置字段名称的最大长度，默认为 <code>Long.MAX_VALUE</code> （无限制）。</li><li><code>index.mapping.dimension_fields.limit</code> ：仅供 Elastic 内部使用，索引的最大时间序列维度数；默认为 <strong>16</strong>。</li></ul><h2 id="如何将某个字段设置为不被索引"><a class="anchor" href="#如何将某个字段设置为不被索引">#</a> 如何将某个字段设置为不被索引</h2><p>在 <code>Mapping</code> 中设置属性 <code>index = false</code> ，则<font color="red">该字段不可作为检索条件，但结果中还是包含该字段</font>。</p><p>与此相关的属性还有 <code>index_options</code> 可以<strong>控制倒排索引记录内容</strong>，属性有：</p><ul><li><code>docs</code> : 只包括 docID</li><li><code>freqs</code> : 包括 docID / 词频</li><li><code>options</code> ：默认属性，docID / 词频 / 位置</li><li><code>offsets</code> : docID / 词频 / 位置 / 字符偏移量</li></ul><p>记录内容越多，占用空间越大，但是检索越精确。</p><h1 id="查询语句dsl"><a class="anchor" href="#查询语句dsl">#</a> 查询语句（DSL）</h1><h2 id="查询语句的分类"><a class="anchor" href="#查询语句的分类">#</a> 查询语句的分类</h2><p><strong>1、请求体查询（最常用）</strong></p><p>将相关查询条件放在请求体中。</p><figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre>GET /shirts/_search</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token string">"query"</span><span class="token builtin class-name">:</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token string">"bool"</span><span class="token builtin class-name">:</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>      <span class="token string">"filter"</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token punctuation">&#123;</span> <span class="token string">"term"</span><span class="token builtin class-name">:</span> <span class="token punctuation">&#123;</span> <span class="token string">"color"</span><span class="token builtin class-name">:</span> <span class="token string">"red"</span>   <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>,</pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token punctuation">&#123;</span> <span class="token string">"term"</span><span class="token builtin class-name">:</span> <span class="token punctuation">&#123;</span> <span class="token string">"brand"</span><span class="token builtin class-name">:</span> <span class="token string">"gucci"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>      <span class="token punctuation">]</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>请求体查询又称为 <code>Query DSL (Domain Specific Language)</code> 领域特定语言，包括：</p><ul><li>叶子查询：指定条件、指定字段查询，包括<strong>分词查询</strong>（ <code>term</code> ）和<strong>全文检索</strong>（ <code>match，match_phrase</code> )</li><li>复合查询：可包含叶子查询语句和复合查询，主要包括 <code>bool</code> 和 <code>dis_max</code></li></ul><p><strong>2、请求 URI</strong></p><p>将相关查询条件放在 URI 中，这种方式不常用，了解即可</p><figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre>GET /users/<span class="token punctuation">\</span>_search?q<span class="token operator">=</span><span class="token punctuation">\</span>*<span class="token operator">&amp;</span><span class="token assign-left variable">sort</span><span class="token operator">=</span>age:asc<span class="token operator">&amp;</span>pretty</pre></td></tr></table></figure><p><strong>3、类 SQL 检索</strong></p><figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre>POST /_sql?format<span class="token operator">=</span>txt</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token string">"query"</span><span class="token builtin class-name">:</span> <span class="token string">"SELECT * FROM uint-2020-08-17 ORDER BY itemid DESC LIMIT 5"</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>功能还不完备，不推荐使用。</p><h2 id="分词查询和全文检索的区别"><a class="anchor" href="#分词查询和全文检索的区别">#</a> 分词查询和全文检索的区别</h2><p>分词查询的<font color="red">查询条件不做分词处理</font>，只有当查询条件词和文档中的词精确匹配才会被搜索到，一般用于<strong>非文本字段查询</strong>。</p><figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment"># 查询用户名中含有关键词 “张寒” 的人</span></pre></td></tr><tr><td data-num="2"></td><td><pre>GET users/_search</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>  <span class="token string">"query"</span><span class="token builtin class-name">:</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token string">"term"</span><span class="token builtin class-name">:</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>      <span class="token string">"name"</span><span class="token builtin class-name">:</span> <span class="token string">"张寒"</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>全文检索一般用于<strong>文本字段查询</strong> ，会使用对应分词器，步骤为：</p><ol><li>分词</li><li>词项逐个查询</li><li>汇总多个词项得分</li></ol><h2 id="范围查询"><a class="anchor" href="#范围查询">#</a> 范围查询</h2><p>range 查询用于匹配在某一范围内的数值型、日期类型或者字符串型字段的文档，比如出生日期在 1996-01-01 到 2000-01-01 的人。<font color="red">使用 range 查询只能查询一个字段</font>，不能作用在多个字段上。</p><p>range 查询支持的参数有以下几种：</p><ul><li><code>gt</code> ：大于，查询范围的最小值，也就是下界，但是不包含临界值。</li><li><code>gte</code> ：大于等于，和 <code>gt</code> 的区别在于包含临界值。</li><li><code>lt</code> ：小于，查询范围的最大值，也就是上界，但是不包含临界值。</li><li><code>lte</code> ：小于等于，和 <code>lt</code> 的区别在于包含临界值。</li></ul><figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment"># 查询出生日期在 1996-01-01 到 2000-01-01 的人</span></pre></td></tr><tr><td data-num="2"></td><td><pre>GET users/_search</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>  <span class="token string">"query"</span><span class="token builtin class-name">:</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token string">"range"</span><span class="token builtin class-name">:</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>      <span class="token string">"birthday"</span><span class="token builtin class-name">:</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token string">"gte"</span><span class="token builtin class-name">:</span> <span class="token string">"1996-01-01"</span>,</pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token string">"lte"</span><span class="token builtin class-name">:</span> <span class="token string">"2000-01-01"</span>,</pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token string">"format"</span><span class="token builtin class-name">:</span> <span class="token string">"yyyy-MM-dd"</span></pre></td></tr><tr><td data-num="10"></td><td><pre>      <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h2 id="match-和-match_phrase-的区别"><a class="anchor" href="#match-和-match_phrase-的区别">#</a> Match 和 Match_phrase 的区别</h2><p>二者都是<strong>全文检索</strong>，区别在于：</p><ul><li><code>match</code> 查询多个检索词之间<font color="red">默认是 or 关系</font>，可使用 <code>operator</code> 改为 and 关系</li><li><code>match_phrase</code> 查询多个检索词之间<font color="red">默认是 and 关系</font>，并且词的位置关系影响搜索结果</li></ul><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20240326195036760.png" alt="image-20240326195036760"></p><h2 id="multi-match-几种匹配策略的区别"><a class="anchor" href="#multi-match-几种匹配策略的区别">#</a> Multi match 几种匹配策略的区别</h2><p>Multi match 用于<strong>单条件多字段查询</strong>，有以下几种常用的匹配策略：</p><ul><li><code>best_fields</code> (默认) ：查询结果包含任一查询条件，但最终得分为<strong>最佳匹配字段得分</strong></li><li><code>most_fields</code> ：查询结果包含任一查询条件，但最终得分<strong>合并所有匹配字段得分</strong>，默认查询条件之间是 or 连接</li><li><code>cross_fields</code> ：跨字段匹配，解决了 <code>most_fields</code> 查询词无法使用 <code>and</code> 连接的问题，匹配更加精确， <code>and</code> 相当于整合多个字段为一个字段，但又不像 <code>copy_to</code> 占用存储空间</li></ul><figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment"># 查询域为 title 和 description</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment"># 匹配策略为 most_fields</span></pre></td></tr><tr><td data-num="3"></td><td><pre>GET books/_search</pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>  <span class="token string">"query"</span><span class="token builtin class-name">:</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token string">"multi_match"</span><span class="token builtin class-name">:</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>      <span class="token string">"type"</span><span class="token builtin class-name">:</span> <span class="token string">"most_fields"</span>,</pre></td></tr><tr><td data-num="8"></td><td><pre>      <span class="token string">"query"</span><span class="token builtin class-name">:</span> <span class="token string">"java 编程"</span>,</pre></td></tr><tr><td data-num="9"></td><td><pre>      <span class="token string">"fields"</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span><span class="token string">"title"</span>, <span class="token string">"description"</span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h2 id="bool-查询的-4-种查询子句"><a class="anchor" href="#bool-查询的-4-种查询子句">#</a> bool 查询的 4 种查询子句</h2><p><code>bool</code> 一般用于<strong>多条件多字段查询</strong>，可包含 <code>match</code> ， <code>match_phrase</code> ， <code>term</code> 等简单查询语句，主要有以下 4 种查询子句：</p><ul><li><code>must</code> : 结果必须匹配 <code>must</code> 查询条件，贡献算分</li><li><code>should</code> ：结果应该匹配 <code>should</code> 子句查询的一个或多个，贡献算分</li><li><code>must_not</code> ：结果必须不能匹配该查询条件</li><li><code>filter</code> ：结果必须匹配该过滤条件，<strong>但不计算得分</strong>，可提高查询效率</li></ul><p>比如，你想在北京找一个有房或者有车，身高不低于 150 的女朋友，下面这条语句安排上：</p><figure class="highlight json"><figcaption data-lang="JSON"></figcaption><table><tr><td data-num="1"></td><td><pre>GET /users/_search</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token property">"query"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token property">"bool"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>      <span class="token property">"must"</span><span class="token operator">:</span> <span class="token punctuation">[</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>          <span class="token property">"match"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>            <span class="token property">"gender"</span><span class="token operator">:</span> <span class="token string">"female"</span> <span class="token comment">// 性别必须为女</span></pre></td></tr><tr><td data-num="9"></td><td><pre>          <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>      <span class="token punctuation">]</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="12"></td><td><pre>      <span class="token property">"should"</span><span class="token operator">:</span> <span class="token punctuation">[</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>          <span class="token property">"match"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>            <span class="token property">"hasroom"</span><span class="token operator">:</span> <span class="token string">"true"</span> <span class="token comment">// 有房或者有车</span></pre></td></tr><tr><td data-num="16"></td><td><pre>          <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="18"></td><td><pre>        <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>          <span class="token property">"match"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>            <span class="token property">"hascar"</span><span class="token operator">:</span> <span class="token string">"true"</span></pre></td></tr><tr><td data-num="21"></td><td><pre>          <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>      <span class="token punctuation">]</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="24"></td><td><pre>      <span class="token property">"must_not"</span><span class="token operator">:</span> <span class="token punctuation">[</span></pre></td></tr><tr><td data-num="25"></td><td><pre>        <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>          <span class="token property">"range"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>            <span class="token property">"height"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>              <span class="token property">"gte"</span><span class="token operator">:</span> <span class="token number">150</span> <span class="token comment">// 身高不低于 150</span></pre></td></tr><tr><td data-num="29"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>          <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="31"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>      <span class="token punctuation">]</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="33"></td><td><pre>      <span class="token property">"filter"</span><span class="token operator">:</span> <span class="token punctuation">[</span></pre></td></tr><tr><td data-num="34"></td><td><pre>        <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="35"></td><td><pre>          <span class="token property">"term"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="36"></td><td><pre>            <span class="token property">"address"</span><span class="token operator">:</span> <span class="token string">"北京"</span> <span class="token comment">// 必须北京，不过不算分</span></pre></td></tr><tr><td data-num="37"></td><td><pre>          <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="38"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="39"></td><td><pre>      <span class="token punctuation">]</span></pre></td></tr><tr><td data-num="40"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="41"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="42"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h1 id="数据同步"><a class="anchor" href="#数据同步">#</a> 数据同步</h1><h2 id="es-和-mysql-之间的同步策略"><a class="anchor" href="#es-和-mysql-之间的同步策略">#</a> ES 和 MySQL 之间的同步策略</h2><p>可以分为<strong>全量同步</strong>和<strong>增量同步</strong>。</p><p>全量同步即<font color="red">建好 Elasticsearch 索引后，将 MySQL 所有数据一次性导入</font>。全量同步有很多现成的工具可以用比如 go-mysql-elasticsearch、Datax。</p><blockquote><p><code>go-mysql-elasticsearch</code> 是一项将 MySQL 数据自动同步到 Elasticsearch 的服务，同样支持增量同步。Github 地址：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dvLW15c3FsLW9yZy9nby1teXNxbC1lbGFzdGljc2VhcmNoJUUzJTgwJTgy">https://github.com/go-mysql-org/go-mysql-elasticsearch。</span></p><p><code>DataX</code> 是阿里云 DataWorks 数据集成的开源版本，在阿里巴巴集团内被广泛使用的离线数据同步工具 / 平台。DataX 实现了包括 MySQL、Oracle、OceanBase、SqlServer、Postgre、HDFS、Hive、ADS、HBase、TableStore (OTS)、MaxCompute (ODPS)、Hologres、DRDS 等各种异构数据源之间高效的数据同步功能。Github 地址： <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FsaWJhYmEvRGF0YVglRTMlODAlODI=">https://github.com/alibaba/DataX。</span></p></blockquote><p>另外，除了插件之外，像我们比较熟悉的 <font color="red"><code>Canal</code> 除了支持 binlog 实时增量同步数据库之外，也支持全量同步</font>。</p><p>增量同步即<font color="red">对 MySQL 中新增，修改，删除的数据进行同步</font>:</p><ul><li>同步双写：修改数据时同步到 Elasticsearch。这种方式性能较差、存在丢数据风险且会耦合大量数据同步代码，一般不会使用。</li><li>异步双写：修改数据时，使用 MQ 异步写入 Elasticsearch 提高效率。这种方式引入了新的组件和服务，增加了系统整体复杂性。</li><li>定时器：定时同步数据到 Elasticsearch。这种方式时效性差，通常用于数据实时性不高的场景。</li><li><strong>binlog 同步组件 <code>Canal</code> </strong>(推荐)：使用 Canal 可以做到业务代码完全解耦，API 完全解耦，<font color="red">零代码实现准实时同步</font>，Canal <font color="red">通过解析 MySQL 的 binlog 日志文件进行数据同步</font>。</li></ul><p>关于增量同步的详细介绍，可以看这篇回答： <span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzQ3NjAwNTg5L2Fuc3dlci8yODQzNDg4Njk1">https://www.zhihu.com/question/47600589/answer/2843488695</span> 。</p><h2 id="canal-增量数据同步-elasticsearch-的原理"><a class="anchor" href="#canal-增量数据同步-elasticsearch-的原理">#</a> Canal 增量数据同步 Elasticsearch 的原理</h2><p>这个在 Canal 官方文档中有详细介绍到，原理非常简单：</p><ol><li>Canal 模拟 MySQL Slave 节点与 MySQL Master 节点的交互协议，把自己<font color="red">伪装成一个 MySQL Slave 节点，向 MySQL Master 节点请求 binlog</font>；</li><li>MySQL Master 节点接收到请求之后，<font color="red">根据偏移量，将新的 binlog 发送给 MySQL Slave 节点</font>；</li><li>Canal 接收到 binlog 之后，就可以<font color="red">对这部分日志进行解析，获取主库的结构及数据变更</font>。</li></ol><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20240326201859705.png" alt="image-20240326201859705"></p><h1 id="es-集群"><a class="anchor" href="#es-集群">#</a> ES 集群</h1><h2 id="es-集群是什么"><a class="anchor" href="#es-集群是什么">#</a> ES 集群是什么</h2><p>单台 Elasticsearch 服务器负载能力和存储能力有限，很多时候通过增加服务器配置也没办法满足我们的要求。并且单个 Elasticsearch 节点会存在单点风险，没有做到高可用。为此，我们需要搭建 Elasticsearch 集群。</p><p>Elasticsearch 集群说白了就是多个 Elasticsearch 节点的集合，这些节点共同协作，一起提供服务，这样就可以解决单台 Elasticsearch 服务器无法处理的搜索需求和数据存储需求。出于高可用方面的考虑，<font color="red">集群中节点数量建议 3 个以上，并且其中至少两个节点不是仅投票主节点</font>（后文会介绍到）。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20240326202519138.png" alt="image-20240326202519138"></p><p>Elasticsearch 集群可以很方便地实现横向扩展，我们可以动态添加或者删除 Elasticsearch 节点。<font color="red">当有节点加入集群中或者从集群中移除节点时，集群将会重新平均分布所有的数据</font>。</p><h2 id="es-集群中的节点角色"><a class="anchor" href="#es-集群中的节点角色">#</a> ES 集群中的节点角色</h2><p>Elasticsearch 7.9 之前的版本中的节点类型：数据节点、协调节点、候选主节点、ingest 节点。在 Elasticsearch 7.9 以及之后，节点类型升级为节点角色（Node roles）。</p><p>节点角色主要是<font color="red">为了解决基于节点类型配置复杂和用户体验差的问题</font>。</p><p>Elasticsearch 集群一般是由多个节点共同组成的分布式集群，节点之间互通，彼此配合，共同对外提供搜索和索引服务（节点之间能够将客户端请求转向到合适的节点）。不同的节点会负责不同的角色，有的负责一个，有的可能负责多个。</p><p>在 ES 中我们可以 **<font color="red">通过配置使一个节点有以下一个或多个角色</font>**：</p><ul><li><strong>主节点（Master-eligible node）</strong>：<font color="red">集群层面的管理</font>，例如创建或删除索引、跟踪哪些节点是集群的一部分，以及决定将哪些分片分配给哪些节点。<font color="red">任何不是仅投票主节点的合格主节点都可以通过 主选举过程 被选为主节点</font>。<ul><li><strong>专用备选主节点（Dedicated master-eligible node）</strong>： Elasticsearch 集群中，设置了<font color="red">只能作为主节点的节点</font>。设置专用主节点主要是为了保障集群增大时的稳定性，建议专用主节点个数<font color="red">至少为 3 个</font>。</li><li><strong>仅投票主节点（Voting-only master-eligible node）</strong>: 仅参与主节点选举投票，<font color="red">不会被选为主节点</font>，硬件配置可以较低。</li></ul></li><li><strong>数据节点（data node）</strong>：<font color="red">数据的存储和处理</font>，比如 CRUD、搜索、聚合。</li><li><strong>预处理节点（ingest node）</strong>：执行由<font color="red">预处理管道</font>组成的预处理任务。</li><li><strong>仅协调节点（coordinating only node）</strong>：<font color="red">路由分发请求</font>、<font color="red">聚集搜索或聚合结果</font>。</li><li><strong>远程节点（Remote-eligible node）</strong>：<font color="red">跨集群检索</font>或<font color="red">跨集群复制</font>。</li><li>......</li></ul><p><strong><font color="red">高可用性 (HA) 集群：需要至少三个符合主节点条件的节点，其中至少两个节点不是仅投票主节点</font></strong>。即使其中一个节点发生故障，这样的集群也能够选举出另一个主节点。</p><h2 id="分片shard"><a class="anchor" href="#分片shard">#</a> 分片（Shard）</h2><blockquote><p>类似问题：Elasticsearch 集群中的数据是如何被分配的？</p></blockquote><p><strong>分片（Shard）<strong>是集群数据的容器，</strong><font color="red">Index（索引）被分为多个文档碎片，存储在分片中，而分片又被分配到集群内的各个节点里</font></strong>。当需要查询一个文档时，需要先找到其位于的分片。也就是说，<font color="red">分片是 Elasticsearch 在集群内分发数据的单位</font>。</p><p><font color="red">每个分片都是一个 Lucene 索引实例</font>，您可以将其视作一个独立的搜索引擎，它能够对 Elasticsearch 集群中的数据子集进行索引并处理相关查询。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/231610474b07406f93c9b16857f0855a%7Etplv-k3u1fbpfcp-zoom-in-crop-mark%3A1512%3A0%3A0%3A0.awebp" alt="img"></p><center>ES的整体结构</center><blockquote><ul><li>一个 ES Index 在集群模式下，由多个 Node（节点）组成。每个节点就是 ES 的 Instance (实例)。</li><li>每个节点上会有多个 shard（分片）， P0 P1 是<font color="red">主分片</font>, R0 R1 是<font color="red">副本分片</font>。</li><li>每个分片都是一个 Lucene Index 实例（底层索引文件）。</li><li>Lucene Index 是一个统称，由多个 <font color="red">Segment（段文件，就是倒排索引）</font>组成，存储着 Document 。<font color="red">Commit Point 记录了所有 segments 的信息</font>。</li></ul></blockquote><p><strong>整个 Elasticsearch 集群的核心就是对所有的分片执行以下工作：<font color="red">分布存储，索引，负载，路由</font>。</strong></p><p>当集群规模扩大或者缩小时， Elasticsearch 会自动地在各节点中迁移分片，使得数据仍然均匀分布在集群里。Elasticsearch 在对数据进行再平衡时移动分片的速度取决于分片的大小和数量，以及网络和磁盘性能。</p><p>一个分片可以是 <strong><font color="cornflowerblue">主分片（Primary Shard）</font></strong> 或者 <strong><font color="cornflowerblue">副本分片（Replica Shard）</font></strong>。<font color="red">一个副本分片只是一个主分片的拷贝</font>。副本分片作为硬件故障时保护数据不丢失的冗余备份，并为搜索和返回文档等读操作提供服务。查询吞吐量可以随着副本分片数量的增加而增长，与此同时，使用副本分片还可以处理查询的发并量。</p><p><strong><font color="red">当我们写索引数据的时候，只能写在主分片上，然后再同步到副本分片</font></strong>。</p><p><font color="red">当主分片出现问题的时候，会从可用的副本分片中选举一个新的主分片</font>。在默认情况下，ElasticSearch 会为主分片创建一个副本分片。由于副本分片同样会占用资源，因此，不建议为一个主分片分配过多的副本分片，应该充分结合业务需求来选定副本分片的数量。</p><p><font color="red">从 Elasticsearch 版本 7 开始，每个索引的主分片数量的默认值为 1，默认的副本分片数为 0</font>。在早期版本中，默认值为 5 个主分片。在生产环境中，副本分片数至少为 1。</p><h2 id="查询文档时如何找到对应分片"><a class="anchor" href="#查询文档时如何找到对应分片">#</a> 查询文档时，如何找到对应分片？</h2><p>如何知道一个文档应该存放在哪个分片中呢？这个过程是根据<font color="red">路由公式</font>来决定的:</p><figure class="highlight python"><figcaption data-lang="python"></figcaption><table><tr><td data-num="1"></td><td><pre>shard <span class="token operator">=</span> <span class="token builtin">hash</span><span class="token punctuation">(</span>routing<span class="token punctuation">)</span> <span class="token operator">%</span> number_of_primary_shards</pre></td></tr></table></figure><p><code>routing</code> 是一个可以配置的变量，默认是使用<font color="red">文档的 id</font>。对 <code>routing</code> 取哈希再除以 <code>number_of_primary_shards</code> (索引创建时指定的<font color="red">主分片总数</font>）得到的余数就是对应的分片。</p><p>当一个查询请求到达 <strong>仅协调节点（coordinating only node）</strong> 后，<font color="red">仅协调节点会根据路由公式计算出目标分片，然后再将请求转发到目标分片的主分片节点上</font>。</p><p>上面公式也解释了为什么我们<font color="red"><strong>要在创建索引的时候就确定好主分片的数量，并且不允许改变索引分片数</strong>。因为如果数量变化了，那么所有之前路由的计算值都会无效，文档也再也找不到了</font>。</p><h2 id="自定义路由的好处"><a class="anchor" href="#自定义路由的好处">#</a> 自定义路由的好处</h2><p><font color="red">默认的路由规则会尽量保证数据会均匀地保存到每一个分片上面</font>。这样做的好处是，一旦某个分片出了故障，ES 集群里的任何索引都不会出现一个文档都查不到的情况，所有索引都只会丢失故障分片上面存储的文档而已，这个给修复故障分片争取了时间。</p><p>不过，这种路由规则也有一个弊端，文档均匀分配到多个分片上面了，所以<font color="red">每次查询索引结果都需要向多个分片发送请求，然后再将这些分片返回的结果融合到一起返回到终端</font>。很显然这样一来系统的压力就会增大很多，如果索引数据量不大的情况下，效率会非常差。</p><p><strong><font color="red">如果想让某一类型的文档都被存储到同一分片的话，可以自定义路由规则</font></strong>。所有的文档 API 请求 (get,index,delete,bulk,update) 都接受一个叫做 <code>routing</code> 的路由参数，<font color="red">通过这个参数我们可以自定义文档到数据分片的映射规则</font>。</p><h2 id="如何查看-es-集群的健康状态"><a class="anchor" href="#如何查看-es-集群的健康状态">#</a> 如何查看 ES 集群的健康状态</h2><p>在 <code>Kibana</code> 控制台执行以下命令可以查看集群的健康状态：</p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre>GET <span class="token operator">/</span>_cluster<span class="token operator">/</span>health</pre></td></tr></table></figure><p>正常情况下，返回如下结果。</p><figure class="highlight json"><figcaption data-lang="JSON"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  <span class="token property">"cluster_name"</span> <span class="token operator">:</span> <span class="token string">"es-cn-45xxxxxxxxxxxxk1q"</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token property">"status"</span> <span class="token operator">:</span> <span class="token string">"green"</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="4"></td><td><pre>  <span class="token property">"timed_out"</span> <span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="5"></td><td><pre>  <span class="token property">"number_of_nodes"</span> <span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="6"></td><td><pre>  <span class="token property">"number_of_data_nodes"</span> <span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="7"></td><td><pre>  <span class="token property">"active_primary_shards"</span> <span class="token operator">:</span> <span class="token number">18</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="8"></td><td><pre>  <span class="token property">"active_shards"</span> <span class="token operator">:</span> <span class="token number">36</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="9"></td><td><pre>  <span class="token property">"relocating_shards"</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="10"></td><td><pre>  <span class="token property">"initializing_shards"</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="11"></td><td><pre>  <span class="token property">"unassigned_shards"</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="12"></td><td><pre>  <span class="token property">"delayed_unassigned_shards"</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="13"></td><td><pre>  <span class="token property">"number_of_pending_tasks"</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="14"></td><td><pre>  <span class="token property">"number_of_in_flight_fetch"</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="15"></td><td><pre>  <span class="token property">"task_max_waiting_in_queue_millis"</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="16"></td><td><pre>  <span class="token property">"active_shards_percent_as_number"</span> <span class="token operator">:</span> <span class="token number">100.0</span></pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>接口返回参数解释如下：</p><table><thead><tr><th>指标</th><th>含义</th></tr></thead><tbody><tr><td>cluster_name</td><td>集群的名称</td></tr><tr><td>status</td><td>集群的运行状况，基于其主分片和副本分片的状态。</td></tr><tr><td>timed_out</td><td>如果 false 响应在 timeout 参数指定的时间段内返回（30s 默认情况下）</td></tr><tr><td>number_of_nodes</td><td>集群中的节点数</td></tr><tr><td>number_of_data_nodes</td><td>作为专用数据节点的节点数</td></tr><tr><td>active_primary_shards</td><td>活动主分片的数量</td></tr><tr><td>active_shards</td><td>活动主分片和副本分片的总数</td></tr><tr><td>relocating_shards</td><td>正在重定位的分片的数量</td></tr><tr><td>initializing_shards</td><td>正在初始化的分片数</td></tr><tr><td>unassigned_shards</td><td>未分配的分片数</td></tr><tr><td>delayed_unassigned_shards</td><td>其分配因超时设置而延迟的分片数</td></tr><tr><td>number_of_pending_tasks</td><td>尚未执行的集群级别更改的数量</td></tr><tr><td>number_of_in_flight_fetch</td><td>未完成的访存数量</td></tr><tr><td>task_max_waiting_in_queue_millis</td><td>自最早的初始化任务等待执行以来的时间（以毫秒为单位）</td></tr><tr><td>active_shards_percent_as_number</td><td>群集中活动碎片的比率，以百分比表示</td></tr></tbody></table><h2 id="es-的-3-种健康状态"><a class="anchor" href="#es-的-3-种健康状态">#</a> ES 的 3 种健康状态</h2><p>Elasticsearch 集群健康状态分为三种：</p><ul><li><strong>GREEN</strong>（健康状态）：最健康的状态，集群中的<font color="red">主分片和副本分片都可用</font>。</li><li><strong>YELLOW</strong>（预警状态）：主分片都可用，但<font color="red">存在不可用的副本分片</font>。</li><li><strong>RED</strong>（异常状态）：<font color="red">存在不可用的主分片</font>，搜索结果可能会不完整。</li></ul><h2 id="如何分析-es-集群异常问题"><a class="anchor" href="#如何分析-es-集群异常问题">#</a> 如何分析 ES 集群异常问题</h2><p>1、找到异常索引</p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment"># 查看索引情况，并根据返回状态，找到异常的索引</span></pre></td></tr><tr><td data-num="2"></td><td><pre>GET <span class="token operator">/</span>_cat<span class="token operator">/</span>indices?v<span class="token operator">&amp;</span>health<span class="token operator">=</span>yellow</pre></td></tr><tr><td data-num="3"></td><td><pre>GET <span class="token operator">/</span>_cat<span class="token operator">/</span>indices?v<span class="token operator">&amp;</span>health<span class="token operator">=</span>red</pre></td></tr></table></figure><p>2、查看详细的异常信息</p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre>GET <span class="token operator">/</span>_cluster<span class="token operator">/</span>allocation<span class="token operator">/</span><span class="token keyword">explain</span></pre></td></tr><tr><td data-num="2"></td><td><pre>或者</pre></td></tr><tr><td data-num="3"></td><td><pre>GET <span class="token operator">/</span>_cluster<span class="token operator">/</span>allocation<span class="token operator">/</span><span class="token keyword">explain</span>?pretty</pre></td></tr></table></figure><p>通过异常信息进一步分析问题的原因。</p><h1 id="性能优化"><a class="anchor" href="#性能优化">#</a> 性能优化</h1><h2 id="es-如何选择硬件配置"><a class="anchor" href="#es-如何选择硬件配置">#</a> ES 如何选择硬件配置</h2><ul><li>部署 Elasticsearch 对于机器的 CPU 要求并不高，通常选择 <font color="red">2 核 / 4 核</font> 的就差不多了。</li><li>Elasticsearch 中的很多操作是比较消耗内存的，如果搜索需求比较大的话，建议选择 <font color="red">16GB 以上的内存</font>。具体如何分配内存呢？通常是 <font color="red">50% 给 ES，50% 留给 Lucene</font>。另外，<font color="red">建议禁止 swap</font>。如果不禁止的话，当内存耗尽时，操作系统就会自动把内存中暂时不使用的数据交换到硬盘中，需要使用的时候再从硬盘交换到内存，频繁硬盘操作对性能影响是致命的。</li><li>磁盘的速度相对比较慢，<font color="red">尽量使用固态硬盘（SSD）</font>。</li></ul><h2 id="es-索引优化策略"><a class="anchor" href="#es-索引优化策略">#</a> ES 索引优化策略</h2><ul><li>ES 提供了 <code>Bulk</code> API <font color="red">支持批量操作</font>，当我们有大量的写任务时，可以使用 Bulk 来进行批量写入。不过，使用 Bulk 请求时，每个请求尽量不要超过几十 M，因为太大会导致内存使用过大。</li><li><font color="red">ES Index 的副本数量默认为 3 个</font>，这样可以提高可用性，但会影响写入 Index 的效率。某些业务场景下，可以设置 Index 副本数量为 1 或者 0，提高写入 Index 的效率。</li><li>ES 在写入数据的时候，采用 **<font color="red">延迟写入策略</font>**，<font color="red">默认 1 秒之后将内存中 segment 数据刷新到磁盘中，此时我们才能将数据搜索出来</font>。这就是为什么 Elasticsearch 提供的是<font color="red">近实时搜索</font>功能。某些业务场景下，可以增加刷新时间间隔，比如设置刷新时间间隔为 30s ( <code>index.refresh_interval=30s</code> )，减少 segment 合并压力，提高写入索引的效率。</li><li>加大 <code>index_buffer_size</code> ，这个是 ES <font color="red">活跃分片共享的内存区，官方建议每个分片至少 512MB，且为 JVM 内存的 10%</font>。</li><li>使用 ES 的默认 ID 生成策略或使用数字类型 ID 做为主键。</li><li>合理的配置使用 index 属性， <code>analyzed</code> 和 <code>not_analyzed</code> ，根据业务需求来控制字段是否分词或不分词。只有 <code>groupby</code> 需求的字段，配置时就设置成 <code>not_analyzed</code> ，以提高查询或聚类的效率。</li><li>加大 Flush 设置。 <font color="red">Flush 的目的是把文件缓存在系统中的 segment 持久化到硬盘</font>，当 Translog 的数据量达到 512MB 或者 30 分钟时，会触发一次 Flush，我们可以加大 <code>index.translog.flush_threshold_size</code> ，但必须为操作系统的文件缓存系统留下足够的空间。</li><li>......</li></ul><h2 id="es-查询优化策略"><a class="anchor" href="#es-查询优化策略">#</a> ES 查询优化策略</h2><ul><li>建立 **<font color="red">冷热索引库</font>**（可用固态硬盘存放热库数据，普通硬盘存放冷库数据），<font color="red">热库数据可以提前预热，加载至内存</font>，提高检索效率。</li><li><font color="red">自定义路由规则</font>，让某一类型的文档都被存储到同一分片。</li><li>使用 <code>copy_to</code> 将多个<font color="red">字段整合</font>为一个。</li><li>控制字段的数量，业务中不使用的字段，就不要索引。</li><li>不要返回无用的字段，使用 <code>_source</code> 进行指定。</li><li><font color="red">避免大型文档存储</font>，默认最大长度为 100MB。</li><li><font color="red">使用 <code>keyword</code> 数据类型，该类型不会走分词器</font>，效率大大提高。</li><li><font color="red">开启慢查询配置</font>，定位慢查询。</li><li>ES 查询的时候，使用 filter 查询会使用 <code>query cache</code> ，如果业务场景中的过滤查询比较多，建议将 querycache 设置大一些，以提高查询速度。</li><li><font color="red">避免分页过深</font>。</li><li><font color="red">增加副本分片，提高查询吞吐量</font>，避免使用通配符。</li><li><font color="red">加大堆内存</font>，ES 默认安装后设置的内存是 1GB，可以适当加大但不要超过物理内存的 50%，且最好不要超过 32GB。</li><li>分配一半物理内存给文件系统缓存，以便加载热点数据。</li><li>......</li></ul><h1 id="文章推荐"><a class="anchor" href="#文章推荐">#</a> 文章推荐</h1><ul><li><p><span class="exturl" data-url="aHR0cHM6Ly90ZWNoLm1laXR1YW4uY29tLzIwMjIvMTEvMTcvZWxhc2ljc2VhcmNoLW9wdGltaXphdGlvbi1wcmFjdGljZS1iYXNlZC1vbi1ydW4tbGVuZ3RoLWVuY29kaW5nLmh0bWw=">美团外卖搜索基于 Elasticsearch 的优化实践 - 美团技术团队 - 2022</span></p></li><li><p><span class="exturl" data-url="aHR0cHM6Ly9jbG91ZC50ZW5jZW50LmNvbS9kZXZlbG9wZXIvaW52ZW50b3J5LzE1MzY3L2FydGljbGUvMTgwMzk0Mw==">Elasticsearch 实战系列 - 腾讯大数据 SRE 工程师 - 2022</span></p></li><li><p><span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC83MDczMzMzODczNDkyMzYxMjMw">由浅到深，入门搜索原理 - 掘金 - 2022</span></p></li><li><p><span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC83MTM0ODU1NDI1NzE0ODE1MDEy">ElasticSearch 文档分值 score 计算 &amp; 聚合搜索案例分析 - 政采云技术团队 - 2022</span></p></li><li><p><span class="exturl" data-url="aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAzNzY1ODk5Nw==">Elasticsearch 如何做到快速检索 - 倒排索引的秘密 - 思否 - 2020</span></p></li><li><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vamFqaWFuL3AvMTEyMjM5OTIuaHRtbA==">Elasticsearch 技术分析（九）：全文搜索引擎 Elasticsearch，这篇文章给讲透了！ - 博客园 - 2019</span></p></li></ul><h1 id="参考"><a class="anchor" href="#参考">#</a> 参考</h1><ul><li><p>Elasticsearch 官方文档：<span class="exturl" data-url="aHR0cHM6Ly93d3cuZWxhc3RpYy5jby9ndWlkZS9lbi9lbGFzdGljc2VhcmNoL3JlZmVyZW5jZS9jdXJyZW50L2VsYXN0aWNzZWFyY2gtaW50cm8uaHRtbA==">https://www.elastic.co/guide/en/elasticsearch/reference/current/elasticsearch-intro.html</span></p></li><li><p>Elasticsearch 中文指南：<span class="exturl" data-url="aHR0cHM6Ly9lbmR5bWVjeS5naXRib29rcy5pby9lbGFzdGljc2VhcmNoLWd1aWRlLWNoaW5lc2UvY29udGVudC9pbmRleC5odG1s">https://endymecy.gitbooks.io/elasticsearch-guide-chinese/content/index.html</span></p></li><li><p>Mastering Elasticsearch (中文版)：<span class="exturl" data-url="aHR0cHM6Ly9kb2MueW9ueW91Y2xvdWQuY29tL2RvYy9tYXN0ZXJpbmctZWxhc3RpY3NlYXJjaC9pbmRleC5odG1s">https://doc.yonyoucloud.com/doc/mastering-elasticsearch/index.html</span></p></li><li><p>Elasticsearch Service 相关概念 - 腾讯云：<span class="exturl" data-url="aHR0cHM6Ly9jbG91ZC50ZW5jZW50LmNvbS9kb2N1bWVudC9wcm9kdWN0Lzg0NS8zMjA4Ng==">https://cloud.tencent.com/document/product/845/32086</span></p></li><li><p>Node - Elasticsearch 官方文档：<span class="exturl" data-url="aHR0cHM6Ly93d3cuZWxhc3RpYy5jby9ndWlkZS9lbi9lbGFzdGljc2VhcmNoL3JlZmVyZW5jZS9jdXJyZW50L21vZHVsZXMtbm9kZS5odG1s">https://www.elastic.co/guide/en/elasticsearch/reference/current/modules-node.html</span></p></li><li><p>倒排索引和正排索引：<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vc2Vhc3ByaW5nL3AvMTQxNTg4NTEuaHRtbA==">https://www.cnblogs.com/seaspring/p/14158851.html</span></p></li><li><p>Elasticsearch 有没有数组类型？有哪些坑？：<span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvRkNqcm42MDl2WVUtVVJsaFZmakQ3QQ==">https://mp.weixin.qq.com/s/FCjrn609vYU-URlhVfjD7A</span></p></li><li><p>Elasticsearch 实现基于拼音搜索：<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vaHVhbjE5OTMvcC8xNzA1MzMxNy5odG1s">https://www.cnblogs.com/huan1993/p/17053317.html</span></p></li><li><p>Elasticsearch 查询语句语法详解 ：<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vR2FpbW8vcC8xNjAzNjg1My5odG1s">https://www.cnblogs.com/Gaimo/p/16036853.html</span></p></li><li><p>《Elasticsearch 权威指南》- 集群内的原理：<span class="exturl" data-url="aHR0cHM6Ly93d3cuZWxhc3RpYy5jby9ndWlkZS9jbi9lbGFzdGljc2VhcmNoL2d1aWRlL2N1cnJlbnQvZGlzdHJpYnV0ZWQtY2x1c3Rlci5odG1s">https://www.elastic.co/guide/cn/elasticsearch/guide/current/distributed-cluster.html</span></p></li><li><p>Elasticsearch 分布式路由策略：<span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zODYzNjg3NjM=">https://zhuanlan.zhihu.com/p/386368763</span></p></li><li><p>How to Choose the Correct Number of Shards per Index in Elasticsearch：<span class="exturl" data-url="aHR0cHM6Ly9vcHN0ZXIuY29tL2d1aWRlcy9lbGFzdGljc2VhcmNoL2NhcGFjaXR5LXBsYW5uaW5nL2VsYXN0aWNzZWFyY2gtbnVtYmVyLW9mLXNoYXJkcy8=">https://opster.com/guides/elasticsearch/capacity-planning/elasticsearch-number-of-shards/</span></p></li><li><p>Elasticsearch 集群异常状态（RED、YELLOW）原因分析：<span class="exturl" data-url="aHR0cHM6Ly9jbG91ZC50ZW5jZW50LmNvbS9kZXZlbG9wZXIvYXJ0aWNsZS8xODAzOTQz">https://cloud.tencent.com/developer/article/1803943</span></p></li><li><p>超详细的 Elasticsearch 高性能优化实践 ：<span class="exturl" data-url="aHR0cHM6Ly9jbG91ZC50ZW5jZW50LmNvbS9kZXZlbG9wZXIvYXJ0aWNsZS8xNDM2Nzg3">https://cloud.tencent.com/developer/article/1436787</span></p></li></ul></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2024-03-27 15:03:59" itemprop="dateModified" datetime="2024-03-27T15:03:59+08:00">2024-03-27</time> </span><span id="database/elasticsearch/Elasticsearch 常见面试题总结/" class="item leancloud_visitors" data-flag-title="Elasticsearch 常见面试题总结" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>范特东东东 <i class="ic i-at"><em>@</em></i>水文 & 摄影</li><li class="link"><strong>本文链接：</strong> <a href="http://example.com/database/elasticsearch/Elasticsearch%20%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/" title="Elasticsearch 常见面试题总结">http://example.com/database/elasticsearch/Elasticsearch 常见面试题总结/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/database/redis/Redis-JavaGuide/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;hjx159&#x2F;picture-bed&#x2F;main&#x2F;img&#x2F;sql-nosql-tushi.png" title="Redis-JavaGuide"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> Redis</span><h3>Redis-JavaGuide</h3></a></div><div class="item right"><a href="/database/mongodb/MongoDB-JavaGuide/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;hjx159&#x2F;picture-bed&#x2F;main&#x2F;img&#x2F;sql-nosql-tushi.png" title="MongoDB-JavaGuide"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> MongoDB</span><h3>MongoDB-JavaGuide</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#es-%E5%9F%BA%E7%A1%80"><span class="toc-number">1.</span> <span class="toc-text">ES 基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#es-%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.1.</span> <span class="toc-text">ES 是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lucene-%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.2.</span> <span class="toc-text">Lucene 是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#es-%E8%83%BD%E5%81%9A%E4%BB%80%E4%B9%88"><span class="toc-number">1.3.</span> <span class="toc-text">ES 能做什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8-esmysql-%E4%B8%8D%E8%A1%8C%E5%90%97"><span class="toc-number">1.4.</span> <span class="toc-text">为什么用 ES？MySQL 不行吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#es-%E4%B8%AD%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.5.</span> <span class="toc-text">ES 中的基本概念</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95-%E6%AD%A3%E6%8E%92%E7%B4%A2%E5%BC%95"><span class="toc-number">2.</span> <span class="toc-text">倒排索引 &amp; 正排索引</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">2.1.</span> <span class="toc-text">倒排索引是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%9B%E5%BB%BA%E6%B5%81%E7%A8%8B%E5%92%8C%E6%A3%80%E7%B4%A2%E6%B5%81%E7%A8%8B"><span class="toc-number">2.2.</span> <span class="toc-text">倒排索引的创建流程和检索流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95%E7%9A%84%E7%BB%84%E6%88%90"><span class="toc-number">2.3.</span> <span class="toc-text">倒排索引的组成</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%A3%E6%8E%92%E7%B4%A2%E5%BC%95%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">2.4.</span> <span class="toc-text">正排索引是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%A3%E6%8E%92%E7%B4%A2%E5%BC%95%E4%B8%8E%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.5.</span> <span class="toc-text">正排索引与倒排索引的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#es-%E5%8F%AF%E4%BB%A5%E9%92%88%E5%AF%B9%E6%9F%90%E4%BA%9B%E5%AD%97%E6%AE%B5%E4%B8%8D%E5%81%9A%E7%B4%A2%E5%BC%95%E5%90%97"><span class="toc-number">2.6.</span> <span class="toc-text">ES 可以针对某些字段不做索引吗？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%86%E8%AF%8D%E5%99%A8analyzer"><span class="toc-number">3.</span> <span class="toc-text">分词器（Analyzer）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E8%AF%8D%E5%99%A8%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">3.1.</span> <span class="toc-text">分词器的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E5%88%86%E8%AF%8D%E5%99%A8"><span class="toc-number">3.2.</span> <span class="toc-text">常用的分词器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E8%AF%8D%E5%99%A8%E7%9A%84%E7%BB%84%E6%88%90"><span class="toc-number">3.3.</span> <span class="toc-text">分词器的组成</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#es-%E5%A6%82%E4%BD%95%E5%9F%BA%E4%BA%8E%E6%8B%BC%E9%9F%B3%E6%9D%A5%E6%90%9C%E7%B4%A2%E4%B8%AD%E6%96%87%E5%86%85%E5%AE%B9"><span class="toc-number">3.4.</span> <span class="toc-text">ES 如何基于拼音来搜索中文内容？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#es-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.</span> <span class="toc-text">ES 数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#es-%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.1.</span> <span class="toc-text">ES 常见数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#keyword-%E5%92%8C-text-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.2.</span> <span class="toc-text">keyword 和 text 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#es-%E4%B8%AD%E6%B2%A1%E6%9C%89%E4%B8%93%E9%97%A8%E7%9A%84%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.3.</span> <span class="toc-text">ES 中没有专门的数组类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#es-%E4%B8%8D%E8%83%BD%E5%9C%A8-mapping-%E4%B8%AD%E4%BF%AE%E6%94%B9%E5%AD%97%E6%AE%B5%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.4.</span> <span class="toc-text">ES 不能在 Mapping 中修改字段类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#nested%E5%B5%8C%E5%A5%97%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.5.</span> <span class="toc-text">Nested（嵌套）数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#copy_to%E5%AD%97%E6%AE%B5%E5%A4%8D%E5%88%B6"><span class="toc-number">4.6.</span> <span class="toc-text">copy_to：字段复制</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%98%A0%E5%B0%84mapping"><span class="toc-number">5.</span> <span class="toc-text">映射（Mapping）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#mapping-%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">5.1.</span> <span class="toc-text">Mapping 是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE%E6%97%B6%E4%B8%8D%E9%9C%80%E8%A6%81%E6%8C%87%E5%AE%9A-mapping"><span class="toc-number">5.2.</span> <span class="toc-text">为什么插入数据时不需要指定 Mapping ？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mapping-%E8%87%AA%E5%AE%9A%E4%B9%89"><span class="toc-number">5.3.</span> <span class="toc-text">Mapping 自定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81-mapping-%E7%9A%84-4-%E7%A7%8D%E5%B1%9E%E6%80%A7%E9%85%8D%E7%BD%AE"><span class="toc-number">5.4.</span> <span class="toc-text">动态 Mapping 的 4 种属性配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81-mapping-%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2%E5%AD%97%E6%AE%B5%E6%97%A0%E9%99%90%E5%A2%9E%E5%8A%A0"><span class="toc-number">5.5.</span> <span class="toc-text">动态 Mapping 如何防止字段无限增加？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%B0%86%E6%9F%90%E4%B8%AA%E5%AD%97%E6%AE%B5%E8%AE%BE%E7%BD%AE%E4%B8%BA%E4%B8%8D%E8%A2%AB%E7%B4%A2%E5%BC%95"><span class="toc-number">5.6.</span> <span class="toc-text">如何将某个字段设置为不被索引</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5dsl"><span class="toc-number">6.</span> <span class="toc-text">查询语句（DSL）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">6.1.</span> <span class="toc-text">查询语句的分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E8%AF%8D%E6%9F%A5%E8%AF%A2%E5%92%8C%E5%85%A8%E6%96%87%E6%A3%80%E7%B4%A2%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">6.2.</span> <span class="toc-text">分词查询和全文检索的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8C%83%E5%9B%B4%E6%9F%A5%E8%AF%A2"><span class="toc-number">6.3.</span> <span class="toc-text">范围查询</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#match-%E5%92%8C-match_phrase-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">6.4.</span> <span class="toc-text">Match 和 Match_phrase 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#multi-match-%E5%87%A0%E7%A7%8D%E5%8C%B9%E9%85%8D%E7%AD%96%E7%95%A5%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">6.5.</span> <span class="toc-text">Multi match 几种匹配策略的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bool-%E6%9F%A5%E8%AF%A2%E7%9A%84-4-%E7%A7%8D%E6%9F%A5%E8%AF%A2%E5%AD%90%E5%8F%A5"><span class="toc-number">6.6.</span> <span class="toc-text">bool 查询的 4 种查询子句</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5"><span class="toc-number">7.</span> <span class="toc-text">数据同步</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#es-%E5%92%8C-mysql-%E4%B9%8B%E9%97%B4%E7%9A%84%E5%90%8C%E6%AD%A5%E7%AD%96%E7%95%A5"><span class="toc-number">7.1.</span> <span class="toc-text">ES 和 MySQL 之间的同步策略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#canal-%E5%A2%9E%E9%87%8F%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5-elasticsearch-%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">7.2.</span> <span class="toc-text">Canal 增量数据同步 Elasticsearch 的原理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#es-%E9%9B%86%E7%BE%A4"><span class="toc-number">8.</span> <span class="toc-text">ES 集群</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#es-%E9%9B%86%E7%BE%A4%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">8.1.</span> <span class="toc-text">ES 集群是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#es-%E9%9B%86%E7%BE%A4%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9%E8%A7%92%E8%89%B2"><span class="toc-number">8.2.</span> <span class="toc-text">ES 集群中的节点角色</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E7%89%87shard"><span class="toc-number">8.3.</span> <span class="toc-text">分片（Shard）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E6%96%87%E6%A1%A3%E6%97%B6%E5%A6%82%E4%BD%95%E6%89%BE%E5%88%B0%E5%AF%B9%E5%BA%94%E5%88%86%E7%89%87"><span class="toc-number">8.4.</span> <span class="toc-text">查询文档时，如何找到对应分片？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E8%B7%AF%E7%94%B1%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-number">8.5.</span> <span class="toc-text">自定义路由的好处</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8B-es-%E9%9B%86%E7%BE%A4%E7%9A%84%E5%81%A5%E5%BA%B7%E7%8A%B6%E6%80%81"><span class="toc-number">8.6.</span> <span class="toc-text">如何查看 ES 集群的健康状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#es-%E7%9A%84-3-%E7%A7%8D%E5%81%A5%E5%BA%B7%E7%8A%B6%E6%80%81"><span class="toc-number">8.7.</span> <span class="toc-text">ES 的 3 种健康状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%86%E6%9E%90-es-%E9%9B%86%E7%BE%A4%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98"><span class="toc-number">8.8.</span> <span class="toc-text">如何分析 ES 集群异常问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-number">9.</span> <span class="toc-text">性能优化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#es-%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E7%A1%AC%E4%BB%B6%E9%85%8D%E7%BD%AE"><span class="toc-number">9.1.</span> <span class="toc-text">ES 如何选择硬件配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#es-%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5"><span class="toc-number">9.2.</span> <span class="toc-text">ES 索引优化策略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#es-%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5"><span class="toc-number">9.3.</span> <span class="toc-text">ES 查询优化策略</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%87%E7%AB%A0%E6%8E%A8%E8%8D%90"><span class="toc-number">10.</span> <span class="toc-text">文章推荐</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">11.</span> <span class="toc-text">参考</span></a></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li class="active"><a href="/database/elasticsearch/Elasticsearch%20%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/" rel="bookmark" title="Elasticsearch 常见面试题总结">Elasticsearch 常见面试题总结</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="范特东东东" data-src="/images/avatar.jpg"><p class="name" itemprop="name">范特东东东</p><div class="description" itemprop="description"></div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">65</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">21</span> <span class="name">分类</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hqeDE1OQ==" title="https:&#x2F;&#x2F;github.com&#x2F;hjx159"><i class="ic i-github"></i></span> <span class="exturl item xiaohongshu" data-url="aHR0cHM6Ly93d3cueGlhb2hvbmdzaHUuY29tL3VzZXIvcHJvZmlsZS81ZTAyYzhhZDAwMDAwMDAwMDEwMDFmM2U=" title="https:&#x2F;&#x2F;www.xiaohongshu.com&#x2F;user&#x2F;profile&#x2F;5e02c8ad0000000001001f3e"><i class="ic i-xiaohongshu2"></i></span> <span class="exturl item email" data-url="bWFpbHRvOjgxMjE0MzI4MEBxcS5jb20=" title="mailto:812143280@qq.com"><i class="ic i-envelope"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><a href="/categories/photography/" rel="section"><i class="ic i-photography"></i>摄影</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于我</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/database/redis/Redis-JavaGuide/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/database/mongodb/MongoDB-JavaGuide/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/java/" title="分类于 Java">Java</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/" title="分类于 Java基础">Java基础</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/java-knowledge/" title="分类于 Java基础-知识点">Java基础-知识点</a></div><span><a href="/java/java-se/java-knowledge/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E5%AE%8B%E7%BA%A2%E5%BA%B7_%E7%AC%AC07%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E8%BF%9B%E9%98%B6%EF%BC%89/" title="宋红康_第07章_面向对象编程(进阶)">宋红康_第07章_面向对象编程(进阶)</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/java/" title="分类于 Java">Java</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/" title="分类于 Java基础">Java基础</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/java-knowledge/" title="分类于 Java基础-知识点">Java基础-知识点</a></div><span><a href="/java/java-se/java-knowledge/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E5%AE%8B%E7%BA%A2%E5%BA%B7_%E7%AC%AC13%E7%AB%A0_%E6%B3%9B%E5%9E%8B/" title="宋红康_第13章_泛型(Generic)">宋红康_第13章_泛型(Generic)</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/docker/" title="分类于 docker">docker</a></div><span><a href="/docker/docker-javaguide/" title="docker-javaguide">docker-javaguide</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/database/" title="分类于 数据库">数据库</a> <i class="ic i-angle-right"></i> <a href="/categories/database/mysql/" title="分类于 MySQL">MySQL</a></div><span><a href="/database/mysql/MySQL-JavaGuide/" title="MySQL-JavaGuide">MySQL-JavaGuide</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/java/" title="分类于 Java">Java</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/" title="分类于 Java基础">Java基础</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/java-knowledge/" title="分类于 Java基础-知识点">Java基础-知识点</a></div><span><a href="/java/java-se/java-knowledge/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E5%AE%8B%E7%BA%A2%E5%BA%B7_%E7%AC%AC17%E7%AB%A0_%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/" title="宋红康_第17章_反射机制">宋红康_第17章_反射机制</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/java/" title="分类于 Java">Java</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/" title="分类于 Java基础">Java基础</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/java-knowledge/" title="分类于 Java基础-知识点">Java基础-知识点</a></div><span><a href="/java/java-se/java-knowledge/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E5%AE%8B%E7%BA%A2%E5%BA%B7_%E7%AC%AC11%E7%AB%A0_%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%92%8C%E5%9F%BA%E7%A1%80API/" title="宋红康_第11章_常用类和基础API">宋红康_第11章_常用类和基础API</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/java/" title="分类于 Java">Java</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/" title="分类于 Java基础">Java基础</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/java-excise/" title="分类于 Java基础-真题">Java基础-真题</a></div><span><a href="/java/java-se/java-excise/%E7%AC%AC15%E7%AB%A0%EF%BC%9A%E9%9A%8F%E5%A0%82%E5%A4%8D%E4%B9%A0%E4%B8%8E%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%A2%98%EF%BC%88File%E7%B1%BB%E4%B8%8EIO%E6%B5%81%EF%BC%89/" title="宋红康_第15章：File类与IO流">宋红康_第15章：File类与IO流</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/java/" title="分类于 Java">Java</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/" title="分类于 Java基础">Java基础</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/java-excise/" title="分类于 Java基础-真题">Java基础-真题</a></div><span><a href="/java/java-se/java-excise/%E7%AC%AC10%E7%AB%A0%EF%BC%9A%E9%9A%8F%E5%A0%82%E5%A4%8D%E4%B9%A0%E4%B8%8E%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%A2%98%EF%BC%88%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%89/" title="宋红康_第10章：多线程">宋红康_第10章：多线程</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/distributed-microservices/" title="分类于 分布式微服务">分布式微服务</a></div><span><a href="/distributed-microservices/ShardingSphere/" title="ShardingSphere">ShardingSphere</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/java/" title="分类于 Java">Java</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/" title="分类于 Java基础">Java基础</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/java-knowledge/" title="分类于 Java基础-知识点">Java基础-知识点</a></div><span><a href="/java/java-se/java-knowledge/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E5%AE%8B%E7%BA%A2%E5%BA%B7_%E7%AC%AC14%E7%AB%A0_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/" title="宋红康_第14章_数据结构与集合源码">宋红康_第14章_数据结构与集合源码</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">范特东东东 @ fantedong</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">1.9m 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">28:49</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"database/elasticsearch/Elasticsearch 常见面试题总结/",favicon:{show:"(●´3｀●)欢迎回来",hide:"(〃＞皿＜)你快回来"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hrmmi -->