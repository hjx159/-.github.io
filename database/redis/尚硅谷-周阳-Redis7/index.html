<!-- build time:Sat Mar 02 2024 22:12:18 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="水文 & 摄影" href="http://example.com/rss.xml"><link rel="alternate" type="application/atom+xml" title="水文 & 摄影" href="http://example.com/atom.xml"><link rel="alternate" type="application/json" title="水文 & 摄影" href="http://example.com/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><link rel="canonical" href="http://example.com/database/redis/%E5%B0%9A%E7%A1%85%E8%B0%B7-%E5%91%A8%E9%98%B3-Redis7/"><title>Redis7-尚硅谷-周阳 - Redis - 数据库 | fantedong = 水文 & 摄影 = 为了能更好地查看图片，你需要一点魔法</title><meta name="generator" content="Hexo 6.3.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">Redis7-尚硅谷-周阳</h1><div class="meta"><span class="item" title="创建时间：2023-12-01 16:11:24"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2023-12-01T16:11:24+08:00">2023-12-01</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>60k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>55 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">fantedong</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><img src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/4590329fa2854869612bbee0cd018e9c192a7f0f.jpg"></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/database/" itemprop="item" rel="index" title="分类于 数据库"><span itemprop="name">数据库</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/database/redis/" itemprop="item" rel="index" title="分类于 Redis"><span itemprop="name">Redis</span></a><meta itemprop="position" content="2"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://example.com/database/redis/%E5%B0%9A%E7%A1%85%E8%B0%B7-%E5%91%A8%E9%98%B3-Redis7/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="范特东东东"><meta itemprop="description" content="为了能更好地查看图片，你需要一点魔法, "></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="水文 & 摄影"></span><div class="body md" itemprop="articleBody"><h1 id="入门篇"><a class="anchor" href="#入门篇">#</a> 入门篇</h1><h2 id="1-redis入门概述"><a class="anchor" href="#1-redis入门概述">#</a> 1、Redis 入门概述</h2><h3 id="redis是什么"><a class="anchor" href="#redis是什么">#</a> Redis 是什么</h3><p>Redis： <code>RE</code> mote <code>Di</code> ctionary <code>S</code> erver（远程字典服务器），一种基于<strong> Key-Value</strong> 的<strong>内存</strong>数据库。</p><p>Remote Dictionary Server (远程字典服务) 是完全开源的，使用<font color="red">ANSIC 语言</font>编写遵守 BSD 协议，是一个高性能的<font color="red">Key-Value</font>数据库提供了丰富的数据结构，例如 String、Hash、List、Set、SortedSet 等等。数据是存在<font color="red">内存中的</font>，同时 Redis<font color="red">支持事务、持久化、LUA 脚本、发布 / 订阅、缓存淘汰、流技术等</font>多种功能特性提供了<font color="red">主从模式</font>、<font color="red">Redis Sentinel</font>和<font color="red">Redis Cluster 集群架构</font>方案。</p><h3 id="redis的功能与优势"><a class="anchor" href="#redis的功能与优势">#</a> Redis 的功能与优势</h3><p>Redis 的主流功能与应用如下：</p><ul><li><p><strong><font color="orange">分布式缓存</font></strong>，帮 MySQL 减负</p><blockquote><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230802153755454.png" alt="image-20230802153755454"></p><p>MySQL 与 Redis 的对比：</p><ul><li>MySQL 是关系型数据库，Redis 是<font color="red">key-value</font>数据库（NoSQL 的一种）</li><li>MySQL 主要存储在磁盘，Redis 数据操作主要在<font color="red">内存</font></li><li>Redis 在一些场景中明显优于 MySQL，例如计数器、排行榜等</li><li>Redis 通常用于一些特定场景，需要与 Mysql 一起配合使用，两者并不是相互替换和竞争关系，而是共用和<strong>配合使用</strong></li></ul></blockquote></li><li><p><strong>内存存储</strong>和<strong>持久化</strong>（RDB+AOF）：Redis 支持异步将内存中的数据写到硬盘上，同时不影响继续服务</p></li><li><p><strong>高可用架构搭配</strong>：避免某台 Redis 挂了后，影响系统运行</p><ul><li>单机</li><li>主从</li><li>哨兵</li><li>集群</li></ul></li><li><p>缓存穿透、击穿、雪崩</p></li><li><p><strong>分布式锁</strong>：跨服务器加锁</p></li><li><p><strong>消息队列平台</strong>：Reids<font color="red">提供 list 和 set 操作</font>，这使得 Redis 能作为一个很好的消息队列平台来使用。</p><blockquote><p>通过 Reids 的队列功能做<strong>购买限制</strong>。比如到节假日或者推广期间，进行一些活动，对用户购买行为进行限制，限制今天只能购买几次商品或者一段时间内只能购买一次。</p></blockquote></li><li><p><strong>排行榜</strong> +<strong> 点赞</strong>：Redis 提供的<font color="red">zset 数据类型</font>能够快速实现这些复杂的排行榜。</p></li></ul><p>Redis 的总体功能概览图：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230802154814479.png" alt="image-20230802154814479"></p><p>Redis 的优势：</p><ul><li><strong>读写性能极高</strong></li><li><strong>数据类型丰富</strong>：不仅支持<font color="red">key-value</font>类型的数据，同时还提供<font color="red">list，set，zset，hash</font>等数据结构的存储</li><li><strong>支持数据持久化</strong>：可将内存中的数据存入磁盘中，重启时再加载到内存使用</li><li><strong>支持数据备份</strong>，即 master-slave 模式的数据备份</li></ul><p>小结：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230802155434366.png" alt="image-20230802155434366"></p><h3 id="redis下载"><a class="anchor" href="#redis下载">#</a> Redis 下载</h3><p>英文官网：<span class="exturl" data-url="aHR0cHM6Ly9yZWRpcy5pby8=">https://redis.io/</span></p><p>中文网站：<span class="exturl" data-url="aHR0cDovL3d3dy5yZWRpcy5jbi8=">http://www.redis.cn/</span></p><p>下载网站：<span class="exturl" data-url="aHR0cHM6Ly9kb3dubG9hZC5yZWRpcy5pby9yZWxlYXNlcy8=">https://download.redis.io/releases/</span></p><p>中文文档：<span class="exturl" data-url="aHR0cHM6Ly93d3cucmVkaXMuY29tLmNuL2RvY3VtZW50YXRpb24uaHRtbA==">https://www.redis.com.cn/documentation.html</span></p><p>Redis 源码网站：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3JlZGlzL3JlZGlz">https://github.com/redis/redis</span></p><p>Redis 在线测试：<span class="exturl" data-url="aHR0cHM6Ly90cnkucmVkaXMuaW8v">https://try.redis.io/</span></p><p>Redis 命令参考：<span class="exturl" data-url="aHR0cDovL2RvYy5yZWRpc2ZhbnMuY29tLw==">http://doc.redisfans.com/</span></p><h3 id="redis怎么玩"><a class="anchor" href="#redis怎么玩">#</a> Redis 怎么玩</h3><ul><li>多种数据类型基本操作和配置</li><li>持久化和复制，RDB/AOF</li><li>事务的控制</li><li>复制，集群等</li></ul><h3 id="redis的迭代历史"><a class="anchor" href="#redis的迭代历史">#</a> Redis 的迭代历史</h3><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230802161140294.png" alt="image-20230802161140294"></p><center>Redis重要版本</center><p><font color="red">5.0 版本</font>是直接升级到<font color="red">6.0 版本</font>，对于这个激进的升级，Redis 之父 antirez 表现得很有信心和兴奋，所以第一时间发文来阐述 6.0 的一些重大功能 &quot;Redis 6.0.0 GA is out!&quot;</p><p>随后 Redis 再接再厉，直接王炸<font color="red">Redis7.0</font>---2023 年爆款。2022 年 4 月 27 日 Redis 正式发布了 7.0 更新（其实早在 2022 年 1 月 31 日，Redis 已经预发布了 7.0rc-1，经过社区的考验后，确认没重大 Bug 才会正式发布）</p><p>Redis<strong> 版本的命名规则</strong>：</p><ul><li>版本号第二位如果是奇数，则为非稳定版本。如 2.7、2.9、3.1</li><li>版本号第二位如果是偶数，则为稳定版本。如 2.6、2.8、3.0、3.2</li><li>当前奇数版本就是下一个稳定版本的开发版本。如 2.9 版本是 3.0 版本的开发版本</li></ul><h3 id="redis7的新特性"><a class="anchor" href="#redis7的新特性">#</a> Redis7 的新特性</h3><p>可以从 redis 的 GitHub 的 releases 中查看当前版本的新特性，Redis7 的部分新特性总览：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230802162007264.png" alt="image-20230802162007264"></p><ul><li><p>Redis Functions：Redis 函数，一种新的通过服务端脚本扩展 Redis 的方式，函数与数据本身一起存储。简言之，redis 自己要去<font color="red">抢夺 Lua 脚本的饭碗</font>，但是 Lua 已经稳定且普及，所以 Redis Functions<font color="red">没必要学</font></p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230802162230304.png" alt="image-20230802162230304"></p></li><li><p><strong>Client-eviction</strong>：客户端相关优化，能让更多 client 连接上</p><p><font color="red">限制客户端内存使用</font>，一旦 Redis 连接较多，再加上每个连接的内存占用都比较大的时候，Redis 总连接内存占用可能会达到 maxmemory 的上限，可以增加允许限制所有客户端的总内存使用量配置项，redis.config 中对应的配置项，有两种配置形式：</p><ul><li><font color="red">指定内存大小</font>。例如 maxmemory-clients 1g</li><li><font color="red">基于 maxmemory 的百分比</font>。例如 maxmemory-clients 10%</li></ul><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230802162439869.png" alt="image-20230802162439869" style="zoom:80%"></li><li><p><strong>Multi-part AOF</strong>：多 AOF 文件支持，AOF 文件由一个变成了多个，主要分为两种类型：<font color="red">基本文件 (base files)</font>、<font color="red">增量文件 (incr files)</font>，请注意这些文件名称是复数形式说明每一类文件不仅仅只有一个。在此之外还引入了一个<font color="red">清单文件 (manifest) </font>用于跟踪文件以及文件的创建和应用顺序（恢复）。性能急剧上升，再也不用担心 AOFRW 异步读写时的运维痛点</p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230802163004405.png" alt="image-20230802163004405" style="zoom:80%"></li><li><p><strong>config 命令增强</strong>：对于<font color="red">Config Set 和 Get 命令</font>，支持在一次调用过程中<font color="red">传递多个配置参数</font>。例如，现在我们可以在执行一次 Config Set 命令中更改多个参数： config set maxmemory 10000001 maxmemory-clients 50% port 6399</p></li><li><p><strong>访问安全性增强 ACL V2</strong>：访问控制，在 redis.conf 配置文件中，<font color="red">protected-mode 默认为 yes</font>，只有当你希望你的客户端在没有授权的情况下可以连接到 Redis server 的时候可以将 protected-mode 设置为 no</p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230802163118585.png" alt="image-20230802163118585" style="zoom:80%"></li><li><p><strong>listpack 紧凑列表调整</strong>：listpack 是用来<font color="red">替代 ziplist 的新数据结构</font>，在 7.0 版本已经没有 ziplist 的配置了（6.0 版本仅部分数据类型作为过渡阶段在使用），listpack 已经替换了 ziplist 类似 hash-max-ziplist-entries 的配置</p></li><li><p>RDB 保存时间调整：将持久化文件 RDB 的保存规则发生了改变，尤其是时间记录频度变化</p></li><li><p>命令新增和变动：</p><ul><li>Zset (有序集合) 增加 ZMPOP、BZMPOP、ZINTERCARD 等命令</li><li>Set (集合) 增加 SINTERCARD 命令</li><li>LIST (列表) 增加 LMPOP、BLMPOP ，从提供的键名列表中的第一个非空列表键中弹出一个或多个元素</li></ul></li><li><p><strong>性能资源利用率、安全、等改进</strong>：自身<font color="red">底层部分优化</font>改动，Redis 核心在许多方面进行了重构和改进</p><ul><li><font color="red">主动碎片整理 V2</font>：增强版主动碎片整理，配合 Jemalloc 版本更新，更快更智能，延时更低</li><li><font color="red">HyperLogLog 改进</font>：在 Redis5.0 中，HyperLogLog 算法得到改进，优化了计数统计时的内存使用效率，7 更加优秀</li><li><font color="red">更好的内存统计报告</font></li><li>如果不为了 API 向后兼容，我们将<font color="red">不再使用 slave 一词</font>......(政治正确)</li></ul></li></ul><h2 id="2-redis安装与配置"><a class="anchor" href="#2-redis安装与配置">#</a> 2、Redis 安装与配置</h2><p>Redis 一般在<strong> Linux 环境</strong>上使用，那么就有两种方式：</p><ul><li>购买云服务器</li><li>VMWare 本地虚拟机</li></ul><p>需要确保 Linux 是 64 位的，命令 <code>getconf LONG_BIT</code></p><h3 id="linux环境需要gcc编译环境"><a class="anchor" href="#linux环境需要gcc编译环境">#</a> Linux 环境需要 gcc 编译环境</h3><p>安装 gcc： <code>yum -y install gcc-c++</code></p><p>查看 gcc 版本： <code>gcc -v</code></p><h3 id="redis7安装步骤"><a class="anchor" href="#redis7安装步骤">#</a> Redis7 安装步骤</h3><p>至少 6.0.8 以上，本次使用 Redis7.0</p><p>具体安装流程看脑图。</p><h2 id="3-redis的10种数据类型"><a class="anchor" href="#3-redis的10种数据类型">#</a> <mark>3、Redis 的 10 种数据类型</mark></h2><blockquote><p>前文已声明过 Redis 是基于 Key-Value 的，而<strong> key 类型一般是 String</strong>，这里所介绍的<strong> 10 种数据类型指的是 value 的数据类型</strong>。</p></blockquote><h3 id="10种数据类型value"><a class="anchor" href="#10种数据类型value">#</a> 10 种数据类型 (value)</h3><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230803183405953.png" alt="image-20230803183405953" style="zoom:67%"><ul><li><p><strong>字符串（String）</strong>：60% 的场景，常用</p><ul><li>String 是 redis<font color="red">最基本的类型</font>，一个 key 对应一个 value。</li><li>String 类型是<font color="orange">二进制安全</font>的，意思是 redis 的 String<font color="red">可以包含任何数据</font>，比如<font color="red">jpg 图片</font>或者<font color="red">序列化的对象</font>。</li><li>String 类型是 Redis 最基本的数据类型，一个 redis 中<font color="red">字符串 value 最多可以是 512M</font></li></ul></li><li><p><strong>列表（List）</strong>：</p><ul><li>Redis 列表是简单的<font color="red">字符串列表</font>，<font color="red">按照插入顺序排序</font>。你可以添加一个元素到列表的<font color="red">头部（左边）</font>或者<font color="red">尾部（右边）</font></li><li>它的底层实际是个<font color="orange">双端链表</font>，最多可以包含<font color="red"> 2<sup>32</sup> - 1 </font>个元素 (4294967295, 每个列表超过 40 亿个元素)</li></ul></li><li><p><strong>哈希集（Hash）</strong>：</p><ul><li>Redis hash 是一个 String 类型的<font color="orange"> field（字段） 和 value（值） 的映射表</font>，hash 特别适合用于<font color="red">存储对象</font>。</li><li>Redis 中每个 hash 可以存储<font color="red"> 2<sup>32</sup> - 1 键值对</font>（40 多亿）</li></ul></li><li><p><strong>集合（Set）</strong>：</p><ul><li>Redis 的 Set 是 String 类型的<font color="orange">无序集合</font>。集合成员是唯一的，这就意味着集合中的元素<font color="red">不能重复</font>，集合对象的<font color="red">编码可以是 intset 或者 hashtable</font>。</li><li>Redis 中 Set 集合是<font color="red">通过哈希集实现</font>的，所以添加，删除，查找的复杂度都是 O (1)。</li><li>集合中<font color="red">最大的成员数为 2<sup>32</sup> - 1</font> (4294967295, 每个集合可存储 40 多亿个成员)</li></ul></li><li><p><strong>有序集合（ZSet）</strong>：即上图中的 Sorted Set</p><ul><li>Redis zset 和 set 一样也是 string 类型元素的集合，且<font color="red">不允许重复</font>的成员</li><li>不同的是<font color="orange">每个元素都会关联一个 double 类型的分数</font>，redis 正是通过分数来为集合中的成员进行从小到大的排序。</li><li>zset 的<font color="red">成员是唯一的，但分数 (score) 却可以重复</font>。</li><li>zset 集合是<font color="red">通过哈希集实现</font>的，所以添加，删除，查找的复杂度都是 O (1)。 集合中<font color="red">最大的成员数为 2<sup>32</sup> - 1</font></li></ul></li><li><p><strong>地理空间（GEO）</strong>：即<font color="red">经纬度</font></p><ul><li>Redis GEO 主要用于<font color="orange">存储地理位置信息</font>，并对存储的信息进行操作，包括<ul><li>添加地理位置的坐标。</li><li>获取地理位置的坐标。</li><li>计算两个位置之间的距离。</li><li>根据用户给定的经纬度坐标来获取指定范围内的地理位置集合</li></ul></li></ul></li><li><p><strong>基数统计（HyperLogLog）</strong>：<font color="red">基数指的是不重复的数字</font>，例如统计网站的访问量</p><ul><li>HyperLoglog 是<font color="orange">一种估计集合基数的数据结构</font>，作为<font color="red">一种概率数据结构</font>，HyperLoglog 为有效的空间利用率提供了完美的精度。</li><li>HyperLogLog 实现<font color="red">最多使用 12 KB</font>，并<font color="red">提供 0.81% 的标准错误</font>。</li><li>HyperLogLog 是用来<font color="orange">做基数统计的算法</font>，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，<font color="red">计算基数所需的空间总是固定，且很小</font></li><li>在 Redis 里面，每个 HyperLogLog 键<font color="red">只需要花费 12 KB 内存，就可以计算接近 2<sup>64</sup> 个不同元素的基数</font>。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。</li><li>但是，因为 HyperLogLog <font color="red">只会根据输入元素来计算基数，而不会储存输入元素本身</font>，所以 HyperLogLog <font color="red">不能像集合那样，返回输入的各个元素</font>。</li></ul></li><li><p><strong>位图（bitmap）</strong>：例如每日签到，是否点赞</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230803185955581.png" alt="image-20230803185955581"></p><ul><li>由<font color="orange">0 和 1</font>状态表现二进制位的<font color="orange">bit 数组</font></li></ul></li><li><p><strong>位域（bitfield）</strong>：</p><ul><li>通过 bitfield 命令可以一次性操作多个比特位域 (指的是<font color="orange">连续的多个比特位</font>)，它会执行一系列操作并返回一个响应数组，这个数组中的元素对应参数列表中的相应操作的执行结果。</li><li>说白了就是<font color="red">通过 bitfield 命令我们可以一次性对多个比特位域进行操作</font>。</li></ul></li><li><p><strong>流（Stream）</strong>：Redis 自己的<font color="red">消息（队列）中间件</font>，但还是不如别人的好</p><ul><li>Redis Stream 是 Redis <font color="red">5.0 版本新增加</font>的数据结构。</li><li>Redis Stream 主要<font color="orange">用于消息队列（MQ，Message Queue）</font>，Redis 本身是有一个 Redis 发布订阅 (pub/sub) 来实现消息队列的功能，但它有个缺点就是消息无法持久化，如果出现网络断开、Redis 宕机等，消息就会被丢弃。</li><li>简单来说<font color="red">发布订阅 (pub/sub) 可以分发消息，但无法记录历史消息</font>。</li><li>而 Redis Stream 提供了<font color="red">消息的持久化</font>和<font color="red">主备复制</font>功能，可以让任何客户端访问任何时刻的数据，并且能记住每一个客户端的访问位置，还能<font color="red">保证消息不丢失</font></li></ul></li></ul><h3 id="常见数据类型的操作命令手册"><a class="anchor" href="#常见数据类型的操作命令手册">#</a> 常见数据类型的操作命令手册</h3><p>英文官网：<span class="exturl" data-url="aHR0cHM6Ly9yZWRpcy5pby9jb21tYW5kcy8=">https://redis.io/commands/</span></p><p>中文官网：<span class="exturl" data-url="aHR0cDovL3JlZGlzLmNuL2NvbW1hbmRzLmh0bWw=">http://redis.cn/commands.html</span></p><h3 id="key相关的操作命令"><a class="anchor" href="#key相关的操作命令">#</a> key 相关的操作命令</h3><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230803191631855.png" alt="image-20230803191631855"></p><ul><li><p><strong><code>KEYS *</code> </strong>：查看当前库所有的 key</p></li><li><p><strong><code>EXISTS key</code> </strong>：判断某个 key 是否存在</p></li><li><p><strong><code>TYPE key</code> </strong>：查看某个 key 的<strong> value 的数据类型</strong></p></li><li><p><strong><code>DEL key</code> </strong>：删除某个 key 数据</p></li><li><p><strong><code>UNLINK key</code> </strong>：非阻塞删除某个 key，仅仅将 key 从 keyspace 元数据中删除，真正的删除会在后续异步中操作。</p></li><li><p><strong><code>TTL key</code> </strong>：查看某个 key 还有多少秒过期，-1 表示永不过期，-2 表示已过期</p></li><li><p><strong><code>EXPIRE key 秒钟</code> </strong>：设置某个 key 的过期时间，默认 - 1 表示永不过期。</p><blockquote><p>Redis 的过期时间设置有四种形式：</p><p>・EXPIRE 秒 —— 设置指定的过期时间 (秒)，表示的是时间间隔。</p><p>・PEXPIRE 毫秒 —— 设置指定的过期时间，以毫秒为单位，表示的是时间间隔。</p><p>・EXPIREAT 时间戳 - 秒 —— 设置指定的 Key 过期的 Unix 时间，单位为秒，表示的是时间 / 时刻。</p><p>・PEXPIREAT 时间戳 - 毫秒 —— 设置指定的 Key 到期的 Unix 时间，以毫秒为单位，表示的是时间 / 时刻。</p><p>expire key seconds [NX|XX|GT|LT]</p></blockquote></li><li><p><code>MOVE key dbindex[0-15]</code> ：将当前数据库中的某个 key 剪切到指定的数据库 db 中</p></li><li><p><code>SELECT dbindex</code> ：切换到指定的数据库 [0-15]，默认为 0</p></li><li><p><code>DBSIZE</code> ：查看当前数据库的 key 数量</p></li><li><p><code>FLUSHDB</code> ：清空当前库</p></li><li><p><code>FLUSHALL</code> ：通杀全部库</p></li></ul><h3 id="value数据类型相关的操作命令"><a class="anchor" href="#value数据类型相关的操作命令">#</a> value 数据类型相关的操作命令</h3><blockquote><ul><li><font color="orange">命令是不区分大小写的，但是 key 是区分大小写的</font></li><li>帮助命令： <code>HELP @数据类型</code></li></ul></blockquote><h4 id="字符串string"><a class="anchor" href="#字符串string">#</a> 字符串（String）</h4><blockquote><p>单 key 单 value，最常用</p></blockquote><h5 id="命令概览"><a class="anchor" href="#命令概览">#</a> 命令概览</h5><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230803204957896.png" alt="image-20230803204957896"></p><h5 id="设置获取单个键值"><a class="anchor" href="#设置获取单个键值">#</a> 设置 / 获取单个键值</h5><ul><li><p><strong><code>SET key value</code> </strong>：将键 <code>key</code> 设定为指定的 “字符串” <code>value</code> 值。</p><ul><li>如果 <code>key</code> 已经保存了一个值，那么这个操作会直接覆盖原来的值，并且忽略原始类型。</li><li>当 <code>set</code> 命令执行成功之后，之前设置的过期时间都将失效，除非设置了 <code>KEEPTTL</code> 参数。</li><li>返回值： <code>simple-string-reply</code> ：如果 <code>SET</code> 命令正常执行那么回返回 <code>OK</code> ，否则如果加了 <code>NX</code> 或者 <code>XX</code> 选项，但是没有设置条件。那么会返回 <code>nil</code> 。</li><li>时间复杂度： <code>O(1)</code></li></ul><blockquote><p>完整的命令是： <code>set key value [NX|XX] [GET] [EX seconds|PX milliseconds|EXAT unix-time-seconds|PXAT unix-time-milliseconds|KEEPTTL]</code></p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230804102328872.png" alt="image-20230804102328872"></p><p>如何获得设置指定的 Key 过期的 Unix 时间，单位为秒：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Long</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">1000L</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure></blockquote></li><li><p><strong><code>GET key</code> </strong>：返回 <code>key</code> 的 <code>value</code> 。</p><ul><li>如果 <code>key</code> 不存在，返回特殊值 <code>nil</code> 。</li><li>如果 <code>key</code> 的 <code>value</code> 不是 string，就返回错误，因为 <code>GET</code> 只处理 string 类型的 <code>values</code> 。</li><li>时间复杂度： <code>O(1)</code></li></ul></li></ul><h5 id="设置获取多个键值"><a class="anchor" href="#设置获取多个键值">#</a> 设置 / 获取多个键值</h5><ul><li><p><strong><code>MSET key value [key value ...]</code> </strong>：对应给定的 keys 到他们相应的 values 上。</p><ul><li><code>MSET</code> 会<font color="red">用新的 value 覆盖旧的</font>，就像普通的 <code>SET</code> 命令一样。如果你不想覆盖已经存在的 values，请参看命令 <code>MSETNX</code> 。</li><li><code>MSET</code> 是<font color="red">原子的</font>，所以所有给定的 keys 是一次性 set 的。客户端不可能看到这种一部分 keys 被更新而另外的没有改变的情况。</li><li>返回值： <code>simple-string-reply</code> ：<font color="red">总是 OK</font>，因为 MSET 不会失败。</li><li>时间复杂度： <code>O(N)</code> ，其中 N 是要设置的 key 的数量。</li></ul></li><li><p><strong><code>MGET key [key ...]</code> </strong>：返回所有指定的 <code>key</code> 的 <code>value</code> 。</p><ul><li>对于每个不对应 string 或者不存在的 key，都返回特殊值 <code>nil</code> 。正因为此，<font color="red">这个操作从来不会失败</font>。</li><li>返回值： <code>array-reply</code> : 指定的 key 对应的 values 的 list</li><li>时间复杂度： <code>O(N)</code> ，其中 N 是要查询的 key 的数量。</li></ul></li><li><p><strong><code>MSETNX key value [key value ...]</code> </strong>：对应给定的 keys 到他们相应的 values 上，但是只要有一个 key 已经存在， <code>MSETNX</code> 一个操作都不会执行。</p><ul><li>由于这种特性， <code>MSETNX</code> 可以实现<font color="red">要么所有的操作都成功，要么一个都不执行</font>，这样可以用来设置不同的 key，来表示一个唯一的对象的不同字段。</li><li><code>MSETNX</code> 是<font color="red">原子的</font>，所以所有给定的 keys 是一次性 set 的。客户端不可能看到这种一部分 keys 被更新而另外的没有改变的情况。</li><li>返回值： <code>integer-reply</code> ，只有以下两种值：<ul><li>1 如果所有的 key 被 set</li><li>0 如果没有 key 被 set (至少其中有一个 key 是存在的)</li></ul></li><li>时间复杂度： <code>O(N)</code> ，其中 N 是要设置的 key 的数量。</li></ul></li></ul><h5 id="获取指定区间范围内的值"><a class="anchor" href="#获取指定区间范围内的值">#</a> 获取指定区间范围内的值</h5><ul><li><strong><code>SETRANGE key offset value</code> </strong>：覆盖 <code>key</code> 对应的 string 的一部分，从指定的 <code>offset</code> 处开始，覆盖 <code>value</code> 的长度。<ul><li>如果 <code>offset</code> 比当前 <code>key</code> 对应 string 还要长，那这个 string 后面就<font color="red">补 0</font>以达到 offset。</li><li>不存在的 <code>key</code> 被认为是<font color="red">空字符串</font>，所以这个命令可以确保 key 有一个足够大的字符串，能在 <code>offset</code> 处设置 value。</li><li>模式：正因为有了 <code>SETRANGE</code> 和类似功能的 <code>GETRANGE</code> 命令，你可以把 Redis 的<font color="red">字符串当成线性数组</font>，随机访问只要 O (1) 复杂度。这在很多真实场景应用里非常快和高效。</li><li>返回值： <code>integer-reply</code> ：<font color="red">修改后的字符串长度</font></li><li>时间复杂度： <code>O（1）</code> ，不计算就地复制新字符串所花费的时间。<ul><li>通常，此字符串非常小，因此摊销复杂度为 O（1）。</li><li>否则复杂度为 O（M），M 是 value 参数的长度。</li></ul></li></ul></li><li><strong><code>GETRANGE key start end</code> </strong>：返回 <code>key</code> 对应的字符串 <code>value</code> 的子串，这个子串是由 <code>start</code> 和 <code>end</code> 位移决定的（两者都在 string 内）。<ul><li>可以用<font color="red">负的位移</font>来表示从 string 尾部开始数的下标。所以 - 1 就是最后一个字符，-2 就是倒数第二个，以此类推。</li><li>这个函数处理超出范围的请求时，都把结果限制在 string 内。</li><li>返回值： <code>bulk-reply</code> ，子串</li><li>时间复杂度： <code>O(N)</code> ，其中 N 是字符串长度，复杂度由最终返回长度决定。但由于通过一个字符串创建子字符串是很容易的，它<font color="red">可以被认为是 <code>O(1)</code> </font>。</li></ul></li></ul><h5 id="数值增减"><a class="anchor" href="#数值增减">#</a> 数值增减</h5><blockquote><p>前提：一定要是数字，才能增减！</p></blockquote><ul><li><p><strong><code>INCR key</code> </strong>：对存储在指定 <code>key</code> 的数值执行原子的<font color="red">加 1 操作</font>。</p><ul><li>如果指定的 key 不存在，那么在执行 incr 操作之前，会先将它的值设定为 <code>0</code> 。</li><li>如果指定的 key 中存储的值不是字符串类型（fix：）或者存储的字符串类型不能表示为一个整数，那么执行这个命令时服务器会返回一个错误 (eq:(error) ERR value is not an integer or out of range)。</li><li>返回值： <code>integer-reply</code> ，递增操作后 key 对应的值</li></ul></li><li><p><strong><code>INCRBY key increment</code> </strong>：将 <code>key</code> 对应的数字<font color="red">加 <code>decrement</code> </font>。</p><ul><li>如果 key 不存在，操作之前，key 就会被置为 0。</li><li>如果 key 的 value 类型错误或者是个不能表示成数字的字符串，就返回错误。</li><li>返回值： <code>integer-reply</code> ，增加操作后 key 对应的值</li></ul></li><li><p><strong><code>DECR key</code> </strong>：对 <code>key</code> 对应的数字做<font color="red">减 1 操作</font>。</p><ul><li>如果 key 不存在，那么在操作之前，这个 key 对应的值会被置为 0。</li><li>如果 key 有一个错误类型的 value 或者是一个不能表示成数字的字符串，就返回错误。</li><li>返回值：数字，减小后 key 对应的值</li></ul></li><li><p><strong><code>DECRBY key decrement</code> </strong>：将 <code>key</code> 对应的数字<font color="red">减 <code>decrement</code> </font>。</p><ul><li>如果 key 不存在，操作之前，key 就会被置为 0。</li><li>如果 key 的 value 类型错误或者是个不能表示成数字的字符串，就返回错误。</li><li>返回值：返回一个数字：减少之后的 value 值</li></ul></li></ul><h5 id="获取字符串长度以及内容追加"><a class="anchor" href="#获取字符串长度以及内容追加">#</a> 获取字符串长度以及内容追加</h5><ul><li><strong><code>STRLEN key</code> </strong>：返回 <code>key</code> 的 string 类型 <code>value</code> 的长度。</li><li><strong><code>APPEND key value</code> </strong>：将 <code>value</code> <font color="red">追加</font>到 <code>key</code> 对应的字符串值之后，并<font color="red">返回追加后的长度</font>。</li></ul><h5 id="分布式锁"><a class="anchor" href="#分布式锁">#</a> 分布式锁</h5><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230804110715178.png" alt="image-20230804110715178" style="zoom:67%"><ul><li><p><strong><code>SETEX key seconds value</code> </strong>：设置 <code>key</code> 对应字符串 <code>value</code> ，并且设置 key 在给定的 <code>seconds</code> 时间之后超时过期。这个命令是<font color="red">原子的</font>，等效于执行下面的命令：</p><figure class="highlight txt"><figcaption data-lang="txt"></figcaption><table><tr><td data-num="1"></td><td><pre>SET mykey value</pre></td></tr><tr><td data-num="2"></td><td><pre>EXPIRE mykey seconds</pre></td></tr></table></figure></li><li><p><strong><code>SETNX key value</code> </strong>：</p><ul><li><font color="red">如果 <code>key</code> 不存在</font>，将值设为 <code>value</code> ，这种情况下等同 <code>SET</code> 命令。</li><li>当 <code>key</code> 存在时，什么也不做。 <code>SETNX</code> 是 “<strong>SET</strong> if <strong>N</strong>ot e<strong>X</strong>ists” 的简写。</li><li><strong>可以与 <code>DEL</code> 命令配合使用，对资源加锁</strong></li></ul></li></ul><h5 id="先获取再设置"><a class="anchor" href="#先获取再设置">#</a> 先获取，再设置</h5><ul><li><strong><code>GETSET key value</code> </strong>：等同于 <code>set key value get</code> 命令，<font color="red">返回 key 的旧 value，将 key 的值设置为新 value</font>。</li></ul><h5 id="应用场景"><a class="anchor" href="#应用场景">#</a> 应用场景</h5><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230804111834362.png" alt="image-20230804111834362"></p><ul><li><p>抖音中许多人点赞某个视频，点一下加一次</p></li><li><p>公众号上某篇文章的阅读数，只要点击了 rest 地址，直接可以使用 incr key 命令增加一个数字 1，完成记录数字。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230804111954515.png" alt="image-20230804111954515"></p></li></ul><h4 id="列表list"><a class="anchor" href="#列表list">#</a> 列表（List）</h4><blockquote><p>单 key 多 value，有序有重复</p></blockquote><h5 id="命令概览-2"><a class="anchor" href="#命令概览-2">#</a> 命令概览</h5><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230804112132538.png" alt="image-20230804112132538"></p><h5 id="list的数据结构"><a class="anchor" href="#list的数据结构">#</a> List 的数据结构</h5><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230804112413028.png" alt="image-20230804112413028"></p><p>一个<strong>双端链表</strong>的结构，容量是 2<sup>32</sup>-1 个元素，大概 40 多亿，主要功能有 <code>push</code> / <code>pop</code> 等，一般用在栈、队列、消息队列等场景。</p><p>left、right 都可以插入：</p><ul><li><p>如果键不存在，创建新的链表；</p></li><li><p>如果键已存在，新增内容；</p></li><li><p>如果值全移除，对应的键也就消失了。</p></li></ul><p>它的底层实际是个<strong>双向链表，对两端的操作性能很高，通过索引下标的操作中间的节点性能会较差。</strong></p><h5 id="插入与遍历"><a class="anchor" href="#插入与遍历">#</a> 插入与遍历</h5><ul><li><strong><code>LPUSH key value [value ...]</code> </strong>：将所有的 value 从 key 列表的<strong>左端依次插入</strong>。<ul><li>如果 key 不存在，那么在进行 push 操作前会创建一个空列表。</li><li>如果 key 对应的值不是一个 list 的话，那么会返回一个错误。</li><li>返回值：操作后的 list 长度。</li></ul></li><li><strong><code>RPUSH key value [value ...]</code> </strong>：所有的 value 从 key 列表的<strong>右端依次插入</strong>。</li><li><strong><code>LRANGE key start stop</code> </strong>：遍历 key 列表在<strong>下标 [start,stop] 中的元素，注意右区间是闭合的</strong>。<ul><li>start 和 end 偏移量都是基于 0 的下标，即 list 的第一个元素下标是 0（list 的表头），第二个元素下标是 1，以此类推。</li><li>偏移量也可以是负数，表示偏移量是从 list 尾部开始计数。例如， -1 表示列表的最后一个元素，-2 是倒数第二个，以此类推。</li><li><font color="red">当下标超过 list 范围的时候不会产生 error</font>。<ul><li>如果 start 比 list 的尾部下标大的时候，会返回一个空列表。</li><li>如果 stop 比 list 的实际尾部大的时候，Redis 会当它是最后一个元素的下标。</li></ul></li></ul></li></ul><h5 id="弹出"><a class="anchor" href="#弹出">#</a> 弹出</h5><ul><li><strong><code>LPOP key</code> </strong>：从 key 列表的<strong>左端弹出一个元素</strong>，并返回该元素。</li><li><strong><code>RPOP key</code> </strong>：从 key 列表的<strong>右端弹出一个元素</strong>，并返回该元素。</li></ul><h5 id="根据下标获取元素从左到右"><a class="anchor" href="#根据下标获取元素从左到右">#</a> 根据下标获取元素（从左到右）</h5><ul><li><strong><code>LINDEX key index</code> </strong>：返回 <code>key</code> 列表对应索引 <code>index</code> 处的值。</li></ul><h5 id="获取列表中的元素个数"><a class="anchor" href="#获取列表中的元素个数">#</a> 获取列表中的元素个数</h5><ul><li><strong><code>LLEN key</code></strong></li></ul><h5 id="删除指定数量个指定value的元素"><a class="anchor" href="#删除指定数量个指定value的元素">#</a> 删除指定数量个指定 value 的元素</h5><ul><li><strong><code>LREM key count value</code> </strong>：从存于 <code>key</code> 的列表里<font color="red">移除前 <code>count</code> 次出现的值为 <code>value</code> 的元素</font>。 这个 count 参数通过下面几种方式影响这个操作：<ul><li>count &gt; 0: <font color="red">从头往尾移除</font>值为 value 的元素。</li><li>count &lt; 0: <font color="red">从尾往头移除</font>值为 value 的元素。</li><li>count = 0: <font color="red">移除所有</font>值为 value 的元素。</li></ul></li></ul><h5 id="截取并保存指定下标区间的元素"><a class="anchor" href="#截取并保存指定下标区间的元素">#</a> 截取并保存指定下标区间的元素</h5><ul><li><strong><code>LTRIM key start stop</code> </strong>：修剪 (trim) 一个已存在的 list，这样 list 就会<strong>只保留指定范围 [start,stop] 的指定元素</strong>。</li></ul><h5 id="将元素移至另一个列表"><a class="anchor" href="#将元素移至另一个列表">#</a> 将元素移至另一个列表</h5><ul><li><strong><code>RPOPLPUSH source destination</code> </strong>：<font color="red">原子性</font>地移除存储在 <code>source</code> 的列表的最后一个元素（列表尾部元素）， 并把该元素放入存储在 <code>destination</code> 的列表的第一个元素位置（列表头部）。<ul><li>如果 source 和 destination 是同样的，那么这个操作等同于移除列表最后一个元素并且把该元素放在列表头部， 所以这个命令也可以当作是一个旋转列表的命令。</li><li>返回值：被移除和放入的元素</li><li>模式 1—— 安全的队列：RPOPLPUSH 可以实现，消费者端取到消息的同时把该消息放入一个正在处理中的列表。避免了消息丢失的安全问题。</li><li>模式 2—— 循环列表</li></ul></li></ul><h5 id="设置某下标对应的元素值从左到右"><a class="anchor" href="#设置某下标对应的元素值从左到右">#</a> 设置某下标对应的元素值（从左到右）</h5><ul><li><strong><code>LSET key index value</code> </strong>：设置 <code>index</code> 位置的 list 元素的值为 <code>value</code> 。</li></ul><h5 id="在指定元素的前后插入元素"><a class="anchor" href="#在指定元素的前后插入元素">#</a> 在指定元素的前 / 后插入元素</h5><ul><li><strong><code>LINSERT key BEFORE|AFTER pivot value</code> </strong>：把 <code>value</code> 插入存于 <code>key</code> 的列表中在基准值 <code>pivot</code> 的前面或后面。返回插入后的列表长度，或者当 pivot 不存在时返回 - 1。</li></ul><h5 id="应用场景-2"><a class="anchor" href="#应用场景-2">#</a> 应用场景</h5><ul><li>微信公众号订阅的消息</li></ul><h4 id="哈希集hash"><a class="anchor" href="#哈希集hash">#</a> 哈希集（Hash）</h4><blockquote><p>单 key，但 value 是一个键值对，即<strong>单 key 单键值对</strong>：Map&lt;String,Map&lt;Object,Object&gt;&gt;</p></blockquote><h5 id="命令概览-3"><a class="anchor" href="#命令概览-3">#</a> 命令概览</h5><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230804131019423.png" alt="image-20230804131019423"></p><h5 id="设置-获取-删除"><a class="anchor" href="#设置-获取-删除">#</a> 设置、获取、删除</h5><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230804132747399.png" alt="image-20230804132747399"></p><ul><li><strong><code>HSET key field value</code> </strong>：将 <code>key</code> 指定的哈希集中<font color="red">指定字段 <code>field</code> 的值设置为 <code>value</code> </font>。返回值为：<ul><li>1，如果 field 是一个新字段</li><li>0，如果 field 已存在</li></ul></li><li><strong><code>HGET key field</code> </strong>：获取 <code>key</code> 指定的哈希集中字段 <code>field</code> 所关联的值</li><li><strong><code>HMSET key field value [field value ...]</code> </strong>：将 <code>key</code> 指定的哈希集中<font color="red">所有指定字段 <code>field</code> 的值设置为对应 <code>value</code> </font>。将重写所有在哈希集中存在的字段。</li><li><strong><code>HMGET key field [field ...]</code> </strong>：返回 <code>key</code> 指定的哈希集中<font color="red">所有指定字段 <code>field</code> 的值</font>。</li><li><strong><code>HGETALL key</code> </strong>：返回 <code>key</code> 指定的哈希集中<font color="red">所有的字段和值</font>。<strong>返回值中，每个字段名的下一个是它的值</strong>，所以返回值的<font color="red">长度是哈希集大小的两倍</font>。</li><li><strong><code>HDEL key field [field ...]</code> </strong>：从 key 指定的哈希集中<font color="red">移除各个指定的域</font>，<strong>返回成功移除的域的数量</strong>。</li></ul><h5 id="获取哈希集的字段数量"><a class="anchor" href="#获取哈希集的字段数量">#</a> 获取哈希集的字段数量</h5><ul><li><strong><code>HLEN key</code> </strong>：返回 <code>key</code> 指定的哈希集包含的<strong>字段的数量</strong>。</li></ul><h5 id="判断哈希集中是否存在某个字段"><a class="anchor" href="#判断哈希集中是否存在某个字段">#</a> 判断哈希集中是否存在某个字段</h5><ul><li><strong><code>HEXISTS key field</code> </strong>：返回 <code>key</code> 指定的哈希集中<font color="red">是否存在字段 <code>field</code> </font>。</li></ul><h5 id="获取哈希集中的所有keyvalue"><a class="anchor" href="#获取哈希集中的所有keyvalue">#</a> 获取哈希集中的所有 key/value</h5><ul><li><strong><code>HKEYS key</code> </strong>：返回 <code>key</code> 指定的哈希集中<font color="red">所有字段的名字</font>。</li><li><strong><code>HVALS key</code> </strong>：返回 <code>key</code> 指定的哈希集中<font color="red">所有字段的值</font>。</li></ul><h5 id="增加指定字段的数值"><a class="anchor" href="#增加指定字段的数值">#</a> 增加指定字段的数值</h5><ul><li><strong><code>HINCRBY key field increment</code> </strong>：将 <code>key</code> 指定的哈希集中<font color="red">指定字段 <code>field</code> 的数值增加 <code>increment</code></font></li><li><strong><code>HINCRBYFLOAT key field increment</code> </strong>：将 <code>key</code> 指定的哈希集中<font color="red">指定字段 <code>field</code> 的数值增加 float 类型的  <code>increment</code></font></li></ul><h5 id="只设置哈希集中不存在的字段"><a class="anchor" href="#只设置哈希集中不存在的字段">#</a> 只设置哈希集中不存在的字段</h5><ul><li><strong><code>HSETNX key field value</code> </strong>：只在 <code>key</code> 指定的哈希集中不存在指定的字段 <code>field</code> 时，设置其值为 <code>value</code> 。<ul><li>如果 <code>key</code> 指定的哈希集不存在，会创建一个新的哈希集并与 <code>key</code> 关联。</li><li><strong>如果字段已存在，该操作无效果</strong>。</li></ul></li></ul><h5 id="应用场景-3"><a class="anchor" href="#应用场景-3">#</a> 应用场景</h5><p>京东购物车的早期设计，目前不再采用，当前中小厂可用：</p><ul><li>新增商品 → hset shopcar:uid1024 334488 1</li><li>新增商品 → hset shopcar:uid1024 334477 1</li><li>增加商品数量 → hincrby shopcar:uid1024 334477 1</li><li>商品总数 → hlen shopcar:uid1024</li><li>全部选择 → hgetall shopcar:uid1024</li></ul><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230804143259448.png" alt="image-20230804143259448"></p><h4 id="集合set"><a class="anchor" href="#集合set">#</a> 集合（Set）</h4><blockquote><p>单 key 多 value，且无序无重复</p></blockquote><h5 id="命令概览-4"><a class="anchor" href="#命令概览-4">#</a> 命令概览</h5><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230804143501168.png" alt="image-20230804143501168"></p><h5 id="添加元素"><a class="anchor" href="#添加元素">#</a> 添加元素</h5><ul><li><strong><code>SADD key member [member ...]</code> </strong>：向 <code>key</code> 指定的集合中添加一个或多个指定的 <code>member</code> 元素。<ul><li>指定的一个或者多个元素 member 如果已经在集合 key 中<font color="red">存在则忽略</font></li><li>如果集合 key 不存在，则新建集合 key , 并添加 member 元素到集合 key 中</li><li>返回值：<strong>成功添加到集合中的元素数量（不包括已经存在于集合中的元素）</strong></li></ul></li></ul><h5 id="遍历元素"><a class="anchor" href="#遍历元素">#</a> 遍历元素</h5><ul><li><strong><code>SMEMBERS key</code> </strong>：返回 <code>key</code> 指定的集合中所有元素</li></ul><h5 id="判断集合中是否有某元素"><a class="anchor" href="#判断集合中是否有某元素">#</a> 判断集合中是否有某元素</h5><ul><li><strong><code>SISMEMBER key member</code> </strong>：判断成员 <code>member</code> 是否是集合 <code>key</code> 中的成员，是则返回 1，不是或者集合 key 不存在则返回 0</li></ul><h5 id="删除元素"><a class="anchor" href="#删除元素">#</a> 删除元素</h5><ul><li><strong><code>SREM key member [member ...]</code> </strong>：在 <code>key</code> 集合中<font color="red">移除指定的元素</font>，<strong>返回成功移除的元素个数</strong></li></ul><h5 id="获取集合中的元素数量"><a class="anchor" href="#获取集合中的元素数量">#</a> 获取集合中的元素数量</h5><ul><li><strong><code>SCARD key</code> </strong>：返回 <code>key</code> 集合的元素数量（即集合的基数）</li></ul><h5 id="从集合中随机u展现u指定个数个元素但元素不删除"><a class="anchor" href="#从集合中随机u展现u指定个数个元素但元素不删除">#</a> 从集合中随机<u>展现</u>指定个数个元素，但元素不删除</h5><ul><li><strong><code>SRANDMEMBER key [count]</code> </strong>：<strong>随机<u>返回</u> <code>key</code> 集合中的 <code>count</code> 个元素</strong><ul><li>如果 count 是整数且小于元素的个数，返回含有 count 个不同的元素的数组</li><li>如果 count 是个整数且大于集合中元素的个数时，仅返回整个集合的所有元素</li><li>当 count 是负数，则会返回一个包含 count 的绝对值的个数元素的数组</li><li>如果 count 的绝对值大于元素的个数，则返回的结果集里会出现一个元素出现多次的情况</li></ul></li></ul><h5 id="从集合中随机u弹出u指定个数个元素且元素删除"><a class="anchor" href="#从集合中随机u弹出u指定个数个元素且元素删除">#</a> 从集合中随机<u>弹出</u>指定个数个元素，且元素删除</h5><ul><li><strong><code>SPOP key [count]</code> </strong>：<strong>随机<u>弹出</u> <code>key</code> 集合中的 <code>count</code> 个元素</strong></li></ul><h5 id="将集合中已存在的某个值移动到另一个集合"><a class="anchor" href="#将集合中已存在的某个值移动到另一个集合">#</a> 将集合中已存在的某个值移动到另一个集合</h5><ul><li><strong><code>SMOVE source destination member</code> </strong>：<font color="red">将 <code>member</code> 从 <code>source</code> 集合移动到 <code>destination</code> 集合中</font>。对于其他的客户端，在特定的时间元素将会作为 source 或者 destination 集合的成员出现。<ul><li>如果 source 集合不存在或者不包含指定的元素，这 smove 命令不执行任何操作并且返回 0。</li><li>否则对象将会从 source 集合中移除，并添加到 destination 集合中去，<ul><li>如果 destination 集合已经存在该元素，则 smove 命令仅将该元素从 source 集合中移除.</li></ul></li><li>如果 source 和 destination 不是集合类型，则返回错误.</li></ul></li></ul><h5 id="集合运算"><a class="anchor" href="#集合运算">#</a> <mark>集合运算</mark></h5><blockquote><p>社交软件中一定会大量使用</p></blockquote><p>假设集合 A 的元素为 abc12，集合 B 的元素为 123ax。</p><h6 id="差集运算"><a class="anchor" href="#差集运算">#</a> 差集运算</h6><p><strong>即 A-B，表示属于 A 但不属于 B 的元素构成的集合</strong>。</p><ul><li><strong><code>SDIFF key [key ...]</code> </strong>：返回一个集合与给定集合的差集的元素.</li></ul><h6 id="并集运算"><a class="anchor" href="#并集运算">#</a> 并集运算</h6><p><strong>即 A∪B，表示属于 A 或 B 的元素合并后的集合</strong>。</p><ul><li><strong><code>SUNION key [key ...]</code> </strong>：返回给定的多个集合的并集中的所有成员.</li></ul><h6 id="交集运算"><a class="anchor" href="#交集运算">#</a> 交集运算</h6><p><strong>即 A∩B，表示属于 A 且属于 B 的共同拥有的元素构成的集合</strong>。</p><ul><li><strong><code>SINTER key [key ...]</code> </strong>：返回指定所有的集合的成员的交集.</li><li><strong><code>SINTERCARD numkeys key [key ...] [LIMIT limit]</code> </strong>：类似于 <code>SINTER</code> 命令，但是不返回结果集，<strong>只返回指定 <code>numkeys</code> 个集合的交集结果的基数</strong>，是 Redis7 的新指令。LIMIT 用来限制返回值大小，<ul><li>若返回值小于 limit，则返回该返回值</li><li>若返回值大于 limit，则返回 limit</li></ul></li></ul><h5 id="应用场景-4"><a class="anchor" href="#应用场景-4">#</a> 应用场景</h5><h6 id="微信抽奖小程序"><a class="anchor" href="#微信抽奖小程序">#</a> 微信抽奖小程序</h6><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230804164737598.png" alt="image-20230804164737598"></p><table><thead><tr><th style="text-align:left">步骤</th><th style="text-align:left">Redis 命令</th></tr></thead><tbody><tr><td style="text-align:left">1 用户 ID，立即参与按钮</td><td style="text-align:left">sadd key 用户 ID</td></tr><tr><td style="text-align:left">2 显示已经有多少人参与了，上图 23208 人参加</td><td style="text-align:left">SCARD key</td></tr><tr><td style="text-align:left">3 抽奖 (从 set 中任意选取 N 个中奖人)</td><td style="text-align:left">SRANDMEMBER key 2 // 随机抽奖 2 个人，元素不删除<br>SPOP key 3 // 随机抽奖 3 个人，元素会删除</td></tr></tbody></table><h6 id="微信朋友圈点赞查看同赞朋友"><a class="anchor" href="#微信朋友圈点赞查看同赞朋友">#</a> 微信朋友圈点赞查看同赞朋友</h6><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230804165326659.png" alt="image-20230804165326659"></p><table><thead><tr><th>步骤</th><th>Redis 命令</th></tr></thead><tbody><tr><td>1 新增点赞</td><td><code>sadd</code> pub:msgID 点赞用户 ID1 点赞用户 ID2</td></tr><tr><td>2 取消点赞</td><td><code>srem</code> pub:msgID 点赞用户 ID</td></tr><tr><td>3 展现所有点赞过的用户</td><td><code>SMEMBERS</code> pub:msgID</td></tr><tr><td>4 点赞用户数统计，就是常见的点赞红色数字</td><td><code>scard</code> pub:msgID</td></tr><tr><td>5 判断某个朋友是否对楼主点赞过</td><td><code>SISMEMBER</code> pub:msgID 用户 ID</td></tr></tbody></table><h6 id="qq内推可能认识的人"><a class="anchor" href="#qq内推可能认识的人">#</a> QQ 内推可能认识的人</h6><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230804165609346.png" alt="image-20230804165609346"></p><h4 id="有序集合zsetsorted-set"><a class="anchor" href="#有序集合zsetsorted-set">#</a> 有序集合 Zset（sorted set）</h4><blockquote><p>单 key 多 value，且<font color="red">有序</font>无重复，在每个 value 前加一个<font color="red">score</font>分数值。</p><p>例如：</p><ul><li>set 是 k1-&gt;v1,v2</li><li>Zset 是 k1-&gt;score1 v1, score2 v2</li></ul></blockquote><h5 id="命令概览-5"><a class="anchor" href="#命令概览-5">#</a> 命令概览</h5><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230804170237545.png" alt="image-20230804170237545"></p><h5 id="添加元素-2"><a class="anchor" href="#添加元素-2">#</a> 添加元素</h5><ul><li><strong><code>ZADD key [NX|XX] [CH] [INCR] score member [score member ...]</code> </strong>：将多个分数 / 成员（ <code>score</code> / <code>member</code> ）对添加到键为 <code>key</code> 有序集合（sorted set）里面，以<font color="red">递增</font>的方式排序，<font color="red">返回新添加成员的数量</font>。<ul><li><strong>XX</strong>: 仅仅更新存在的成员，不添加新成员。</li><li><strong>NX</strong>: 不更新存在的成员，只添加新成员。</li><li><strong>CH</strong>: <font color="red">修改返回值为发生变化的成员总数</font>，原始是返回新添加成员的总数 (CH 是 <em>changed</em> 的意思)。更改的元素是<strong>新添加的成员</strong>，已经存在的成员<strong>更新分数</strong>。所以在命令中指定的成员有相同的分数将不被计算在内。</li><li><strong>INCR</strong>: 当 <code>ZADD</code> 指定这个选项时，成员的操作就等同 <code>ZINCRBY</code> 命令，对成员的分数进行<font color="red">递增</font>操作。</li><li>如果指定添加的成员已经是有序集合里面的成员，则会<font color="red">更新</font>成员的分数（scrore），并更新到正确的排序位置。</li><li>时间复杂度：<font color="red">对于每个添加的成员为 <code>O(log(N))</code> </font>，其中 N 指的是有序集合中的元素数量。</li></ul></li></ul><h5 id="遍历元素-2"><a class="anchor" href="#遍历元素-2">#</a> 遍历元素</h5><ul><li><p><strong><code>ZRANGE key start stop [WITHSCORES]</code> </strong>：遍历 <code>key</code> 指定的有序集合中<strong>下标在 [ <code>start</code> , <code>stop</code> ] 间的元素</strong>，<font color="red">返回的元素按分数递增排序</font>。</p><ul><li>如果添加了 <code>WITHSCORES</code> 选项，会将元素的分数与元素一并返回。</li></ul></li><li><p><strong><code>ZREVRANGE key start stop [WITHSCORES]</code> </strong>：与 <code>ZRANGE</code> 类似，只不过元素是<font color="red">按分数递减排序</font>。</p></li><li><p><strong><code>ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]</code> </strong>：遍历 <code>key</code> 指定的有序集合中<strong> score 值在 [ <code>min</code> , <code>max</code> ] 间的元素</strong>，<font color="red">返回的元素按分数递增排序</font>。</p><ul><li><p>具有相同分数的元素按字典序排列</p></li><li><p><code>LIMIT</code> 参数指定返回结果的起始<font color="red">下标 <code>offset</code> 以及数量 <code>count</code></font></p><blockquote><p>注意，如果 <code>offset</code> 太大，定位 <code>offset</code> 就可能遍历整个有序集合，这会增加 O (N) 的复杂度。</p></blockquote></li><li><p><code>min</code> 和 <code>max</code> 可以是 - inf 和 + inf，这样一来，你就可以在不知道有序集的最低和最高 score 值的情况下，使用 <code>ZRANGEBYSCORE</code> 命令。</p></li><li><p><font color="red">默认使用闭区间</font>，也可以通过给参数前增加 <code>(</code> 符号来使用可选的开区间 (小于或大于)</p></li></ul></li></ul><h5 id="获取元素的分数"><a class="anchor" href="#获取元素的分数">#</a> 获取元素的分数</h5><ul><li><strong><code>ZSCORE key member</code> </strong>：返回 <code>key</code> 指定的有序集合中，成员 <code>member</code> 的 score 值。</li></ul><h5 id="获取有序集合的元素数量"><a class="anchor" href="#获取有序集合的元素数量">#</a> 获取有序集合的元素数量</h5><ul><li><strong><code>ZCARD key</code></strong></li></ul><h5 id="删除元素-2"><a class="anchor" href="#删除元素-2">#</a> 删除元素</h5><ul><li><strong><code>ZREM key member [member ...]</code> </strong>：从 <code>key</code> 指定的有序集合中<strong>删除指定的多个成员 <code>member</code> </strong>，返回的是删除的成员个数，<font color="red">不包括不存在的成员</font>。</li></ul><h5 id="增加某个元素的分数"><a class="anchor" href="#增加某个元素的分数">#</a> 增加某个元素的分数</h5><ul><li><strong><code>ZINCRBY key increment member</code> </strong>：为 <code>key</code> 指定的有序集合中的成员 <code>member</code> 的 score 值加上增量 <code>increment</code> 。</li></ul><h5 id="获得指定分数范围内的元素数量"><a class="anchor" href="#获得指定分数范围内的元素数量">#</a> 获得指定分数范围内的元素数量</h5><ul><li><strong><code>ZCOUNT key min max</code> </strong>：返回 <code>key</code> 指定的有序集合中 score 值在 [ <code>min</code> , <code>max</code> ] 之间的成员数量。</li></ul><h5 id="弹出一个或多个元素redis7"><a class="anchor" href="#弹出一个或多个元素redis7">#</a> 弹出一个或多个元素（Redis7）</h5><ul><li><strong><code>ZMPOP numkeys key [key ...] &lt;MIN | MAX&gt; [COUNT count]</code> </strong>：从 <code>numkeys</code> 个有序集合 <code>key</code> 列表中的第一个非空有序集合中，弹出 <code>count</code> 个元素。<ul><li>参数 <code>MIN</code> 表示按照 score 值<font color="red">递增</font>的顺序依次弹出</li><li>参数 <code>MAX</code> 表示按照 score 值<font color="red">递减</font>的顺序依次弹出</li><li>参数 <code>COUNT</code> 表示指定<font color="red">要弹出的元素数量</font>，<font color="red">默认设置为 1</font>。</li></ul></li></ul><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230804193510087.png" alt="image-20230804193510087"></p><h5 id="获取元素的下标值即排名"><a class="anchor" href="#获取元素的下标值即排名">#</a> 获取元素的下标值（即排名）</h5><ul><li><strong><code>ZRANK key member</code> </strong>：<strong>返回有序集 <code>key</code> 中成员 <code>member</code> 的排名</strong>。其中有序集成员<font color="red">按 score 值递增</font>(从小到大) 顺序排列。排名以 0 为底，也就是说，score 值最小的成员排名为 0。</li><li><strong><code>ZREVRANK key member</code> </strong>：与 <code>ZRANK</code> 命令类似，只不过是<font color="red">按照 score 值递减</font>排序。</li></ul><h5 id="应用场景-5"><a class="anchor" href="#应用场景-5">#</a> 应用场景</h5><p>根据商品的销量对商品进行排序显示。</p><p>思路：定义商品销售排行榜 (sorted set 集合)，key 为 goods:sellsort，分数为商品销售数量。</p><table><thead><tr><th>步骤</th><th>Redis 命令</th></tr></thead><tbody><tr><td>商品编号 1001 的销量是 9，商品编号 1002 的销量是 15</td><td><code>zadd</code> goods:sellsort 9 1001 15 1002</td></tr><tr><td>有一个客户又买了 2 件商品 1001，商品编号 1001 销量加 2</td><td><code>zincrby</code> goods:sellsort 2 1001</td></tr><tr><td>求商品销量前 10 名</td><td><code>ZREVRANGE</code> goods:sellsort 0 9 withscores</td></tr></tbody></table><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230804193828825.png" alt="image-20230804193828825"></p><h4 id="位图bitmap"><a class="anchor" href="#位图bitmap">#</a> 位图（bitmap）</h4><blockquote><p>单 key 多 value，其中 value 是由<font color="orange">0 和 1</font>状态表现二进制位的<font color="orange">bit 数组</font></p></blockquote><h5 id="需求"><a class="anchor" href="#需求">#</a> 需求</h5><p>用于<strong>状态统计</strong>，例如：</p><ul><li>用户是否登陆过</li><li>电影、广告是否被点击播放过</li><li>钉钉打卡上下班，签到统计</li></ul><h5 id="数据结构"><a class="anchor" href="#数据结构">#</a> 数据结构</h5><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230804195914474.png" alt="image-20230804195914474"></p><p>说明：</p><ul><li><font color="red">用<strong> String 类型作为底层数据结构</strong>实现的一种统计<strong>二值状态</strong>的数据类型</font></li><li>位图<font color="red">本质是数组</font>，它是<font color="red">基于 String</font>数据类型的<font color="red">按位的操作</font>。该数组由多个二进制位组成，每个二进制位都对应一个偏移量 (我们称之为一个索引)。</li><li>Bitmap 支持的<font color="red">最大位数是 2<sup>32</sup> 位</font>，它可以<font color="red">极大的节约存储空间</font>，使用 512M 内存就可以存储多达 42.9 亿的字节信息 (2<sup>32</sup> = 4294967296)</li></ul><h5 id="常用命令"><a class="anchor" href="#常用命令">#</a> 常用命令</h5><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230804200305770.png" alt="image-20230804200305770"></p><ul><li><p><strong><code>SETBIT key offset value</code> </strong>：设置 <code>key</code> 指定的 bitmap（字符串）在 <code>offset</code> 处的 bit 值为 <code>value</code> 。<strong>返回 offset 处原来的 bit 值</strong>。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230804201300199.png" alt="image-20230804201300199"></p></li><li><p><strong><code>GETBIT key offset</code> </strong>：返回 <code>key</code> 指定的 bitmap（字符串）在 <code>offset</code> 处的 bit 值。</p><ul><li>当 offset 超出了字符串长度的时候，这个字符串就被假定为由 0 比特填充的连续空间。</li></ul><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230804201502414.png" alt="image-20230804201502414"></p></li><li><p><strong><code>STRLEN key</code> </strong>：返回 <code>key</code> 指定的 bitmap (字符串) 的<strong>字节数</strong> (1 字节 = 8bit)，超过 8bit 后再扩容 1 字节。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230804201827460.png" alt="image-20230804201827460"></p></li><li><p><strong><code>BITCOUNT key [start end]</code> </strong>：统计 <code>key</code> 指定的 bitmap (字符串) 中<strong> bit 值为 1 的数量</strong>。可以指定额外的参数 <code>start</code> 和 <code>end</code> 来限制统计范围的下标。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230804202346532.png" alt="image-20230804202346532"></p></li><li><p><strong><code>BITOP operation destkey key [key ...]</code> </strong>：对一个或多个 <code>key</code> 指定的<strong> bitmap (字符串) 之间进行位元操作</strong>，并将结果保存到 <code>destkey</code> 上，其中操作方式 <code>operation</code> 有以下几种：</p><ul><li>AND：BITOP AND destkey srckey1 srckey2 srckey3 ... srckeyN ，对一个或多个 key 求<font color="red">逻辑并</font>，并将结果保存到 destkey 。</li><li>OR：BITOP OR destkey srckey1 srckey2 srckey3 ... srckeyN，对一个或多个 key 求<font color="red">逻辑或</font>，并将结果保存到 destkey 。</li><li>XOR：BITOP XOR destkey srckey1 srckey2 srckey3 ... srckeyN，对一个或多个 key 求<font color="red">逻辑异或</font>，并将结果保存到 destkey 。</li><li>NOT：BITOP NOT destkey srckey，对给定 key 求<font color="red">逻辑非</font>，并将结果保存到 destkey 。</li></ul></li></ul><h5 id="应用场景-6"><a class="anchor" href="#应用场景-6">#</a> 应用场景</h5><ul><li><p>统计全年天天登陆占用多少字节</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230804203608847.png" alt="image-20230804203608847"></p></li><li><p>按照年</p><blockquote><p>按年去存储一个用户的签到情况，365 天只需要 365 / 8 ≈ 46 Byte，1000W 用户量一年也只需要 44 MB 就足够了。</p><p>假如是亿级的系统，</p><p>每天使用 1 个 1 亿位的 Bitmap 约占 12MB 的内存（10^8/8/1024/1024），10 天的 Bitmap 的内存开销约为 120MB，<font color="red">内存压力不算太高</font>。</p><p>此外，在实际使用时，<font color="red">最好对 Bitmap 设置过期时间</font>，让 Redis 自动删除不再需要的签到记录以节省内存开销。</p></blockquote></li></ul><h4 id="基数统计hyperloglog"><a class="anchor" href="#基数统计hyperloglog">#</a> 基数统计（HyperLogLog）</h4><blockquote><p>单 key</p></blockquote><h5 id="需求-2"><a class="anchor" href="#需求-2">#</a> 需求</h5><p><strong>UV</strong>：Unique Visitor，独立访客，一般理解为客户端 IP，通常用于统计网站 / 文章的访问量，<font color="red">需要考虑去重</font>，同时<font color="red">不希望占用太大内存</font>。</p><ul><li>统计用户搜索网站关键词的数量</li><li>统计用户每天搜索不同词条个数</li></ul><h5 id="hyperloglog是什么"><a class="anchor" href="#hyperloglog是什么">#</a> HyperLogLog 是什么</h5><p>一言蔽之：<strong>HyperLogLog 是一种根据条件去重的基数估计算法</strong>。</p><blockquote><p><strong>基数</strong>：是一种数据集，是去重后的真实数量。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230805111729020.png" alt="image-20230805111729020"></p><p><strong>基数统计</strong>：统计一个集合中不重复的元素个数。</p><p><strong>大白话</strong>：去重脱水后的真实数据。</p><p><strong>与 set 的区别</strong>：二者同样能达到去重的目的，区别是：<font color="red">set 需要保存元素数据本身</font>，而<font color="red">HyperLogLog 只含有基数相关信息，不保存元素数据本身</font>，例如只保存网站的访问量，而不保存各个访问者的信息，因此<font color="red">HyperLogLog 占用的内存更小</font></p></blockquote><p>优点：在输入元素的数量或者体积非常非常大时，计算基数<font color="red">所需的空间总是固定的、并且是很小的</font>。但是，因为 HyperLogLog<font color="orange">只会根据输入元素来计算基数，而不会储存输入元素本身</font>，所以 HyperLogLog<font color="red">不能像集合那样，返回输入的各个元素</font>。</p><blockquote><p>在 Redis 里面，<font color="red">每个 HyperLogLog 键只需要花费 12KB 内存，就可以计算接近 2<sup>64</sup> 个不同元素的基数</font>。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。</p></blockquote><p>缺点：<font color="red">有 0.81% 的标准误差</font>。</p><h5 id="命令概览-6"><a class="anchor" href="#命令概览-6">#</a> 命令概览</h5><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230805111923099.png" alt="image-20230805111923099"></p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230805112011715.png" alt="image-20230805112011715"></p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230805111944589.png" alt="image-20230805111944589"></p><ul><li><p><strong><code>PFADD key element [element ...]</code> </strong>：向 <code>key</code> 指定的 HyperLogLog 中 **&quot;添加&quot; 若干指定元素 <code>element</code> **。</p><blockquote><p>这里添加的 element 仅用于计算基数，不会被存储，也无法返回！</p></blockquote></li><li><p><strong><code>PFCOUNT key [key ...]</code> </strong>：</p><ul><li>当参数为一个 key 时：返回存储在 HyperLogLog 结构体的该变量的<strong>近似基数</strong></li><li>当参数为多个 key 时：返回这些 HyperLogLog<strong> 并集的近似基数</strong></li></ul><blockquote><ul><li><p>返回的可见集合基数并不是精确值，而是一个<font color="red">带有 0.81% 标准错误（standard error）的近似值</font>.</p></li><li><p>这个命令的一个副作用是<font color="red">可能会导致 HyperLogLog 内部被更改</font>。出于缓存的目的，它会用 8 字节来记录最近一次计算得到基数，所以 <code>PFCOUNT</code> 命令在技术上是个写命令。</p></li></ul></blockquote></li><li><p><strong><code>PFMERGE destkey sourcekey [sourcekey ...]</code> </strong>：将由 <code>sourcekey</code> 指定的多个 HyperLogLog <strong>合并</strong>为一个由 <code>destkey</code> 指定的 HyperLogLog ，合并后的 HyperLogLog 的基数接近于所有输入 HyperLogLog 的可见集合的并集。</p></li></ul><h5 id="应用场景-7"><a class="anchor" href="#应用场景-7">#</a> 应用场景</h5><p>统计天猫网站首页亿级 UV 的 Redis 统计方案。高级篇见！</p><h4 id="地理空间geo"><a class="anchor" href="#地理空间geo">#</a> 地理空间（GEO）</h4><blockquote><p><strong>本质是有序集合 Zset</strong>，不同的是<font color="orange">将<u>score 值</u>替换为<u>经纬度</u></font></p></blockquote><p>地球上的地理位置是使用二维的<strong>经纬度</strong>表示，经度范围 (-180, 180]，纬度范围 (-90, 90]。核心思想主要分为三步：</p><ul><li>将三维的地球变为二维的坐标</li><li>将二维的坐标转换为一维的点块</li><li>将一维的点块转换为二进制，再通过 base32 编码</li></ul><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230805135151199.png" alt="image-20230805135151199"></p><h5 id="命令概览与实操"><a class="anchor" href="#命令概览与实操">#</a> 命令概览与实操</h5><p>如何获取某个地址的经纬度：<span class="exturl" data-url="aHR0cDovL2FwaS5tYXAuYmFpZHUuY29tL2xic2FwaS9nZXRwb2ludC8=">http://api.map.baidu.com/lbsapi/getpoint/</span></p><ul><li><p><strong><code>GEOADD key longitude latitude member [longitude latitude member ...]</code> </strong>：向 <code>key</code> 指定的 GEO 中<font color="red">添加若干个指定的地理空间位置</font>（经度 <code>longitude</code> 、纬度 <code>latitude</code> 、位置名称 <code>member</code> ）。</p><ul><li>该命令以采用标准格式的参数 x,y，所以<font color="red">经度必须在纬度之前</font>。</li><li>时间复杂度：<strong>每一个元素添加是 <code>O(log(N))</code> ，因为底层是有序集合 Zset</strong>，N 是有序集合 Zset 的元素数量。</li></ul><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230805141104831.png" alt="image-20230805141104831"></p></li><li><p><strong><code>GEOPOS key member [member ...]</code> </strong>：从 <code>key</code> 指定的 GEO 中<font color="red">获取若干个指定了地理位置名称 <code>member</code> 的地理位置的<strong>经纬度</strong></font>。</p><ul><li>返回值：一个数组，每项由两个元素组成：经度、纬度。</li><li>时间复杂度：每一个元素添加是 <code>O(log(N))</code> ，N 是有序集合 Zset 的元素数量。</li></ul><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230805141619345.png" alt="image-20230805141619345"></p></li><li><p><strong><code>GEOHASH key member [member ...]</code> </strong>：从 <code>key</code> 指定的 GEO 中<font color="red">获取若干个指定了地理位置名称 <code>member</code> 的地理位置的<strong> Geohash 表示</strong></font>。</p><ul><li>geohash 算法生成的<font color="red">base32 编码值</font></li><li>返回值：一个数组，每项是一个 geohash</li><li>时间复杂度：每一个元素添加是 <code>O(log(N))</code> ，N 是有序集合 Zset 的元素数量</li></ul><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230805141940907.png" alt="image-20230805141940907"></p></li><li><p><strong><code>GEODIST key member1 member2 [unit]</code> </strong>：返回 <code>key</code> 指定的 GEO 中两个给定位置（ <code>member1</code> 和 <code>member2</code> ）之间的<strong>距离</strong>。</p><ul><li>其中参数 <code>unit</code> 可取以下四个值：<ul><li><strong>m</strong> 表示单位为米，<font color="red">默认单位</font></li><li><strong>km</strong> 表示单位为千米</li><li><strong>mi</strong> 表示单位为英里</li><li><strong>ft</strong> 表示单位为英尺</li></ul></li><li>在计算距离时会假设地球为完美的球形，在极限情况下， 这一假设<font color="red">最大会造成 0.5% 的误差</font>。</li></ul><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230805142341845.png" alt="image-20230805142341845"></p></li><li><p><strong><code>GEORADIUS key longitude latitude radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count]</code> </strong>：<strong>以给定的经纬度 ( <code>longitude</code> 和 <code>latitude</code> ) 为中心，返回 <code>key</code> 指定的 GEO 中，与中心的距离不超过给定最大距离 <code>radius</code> 的所有位置元素</strong>。</p><ul><li><p><code>WITHCOORD</code> : 将位置元素的<font color="red">经度和纬度</font>也一并返回</p></li><li><p><code>WITHDIST</code> : 在返回位置元素的同时，将位置元素<font color="red">与中心之间的距离</font>也一并返回。距离的单位和用户给定的范围单位保持一致</p></li><li><p><code>WITHHASH</code> : <font color="red">以 52 位有符号整数的形式</font>，返回位置元素<font color="red">经过原始 geohash 编码的有序集合分值</font>。这个选项<font color="red">主要用于底层应用或者调试</font>，实际中的作用并不大</p></li><li><p><code>COUNT</code> ：<font color="red">限定返回的记录数</font></p></li><li><p>命令<font color="red">默认返回未排序</font>的位置元素。通过以下两个参数， 用户可以指定被返回位置元素的排序方式：</p><ul><li><code>ASC</code> : 根据中心的位置， 按照从近到远的方式返回位置元素。</li><li><code>DESC</code> : 根据中心的位置， 按照从远到近的方式返回位置元素。</li></ul></li><li><p>时间复杂度：<strong>O（N+log（M））</strong>，其中 N 是由中心和半径限定的圆形区域的边界框内的元素数量，M 是索引内的项目数量。</p></li><li><p>返回值：</p><ul><li><p>在没有给定任何 <code>WITH</code> 选项的情况下，命令只会返回一个像 [“New York”,”Milan”,”Paris”] 这样的<font color="red">线性（linear）名称列表</font>。</p></li><li><p>在指定了 <code>WITHCOORD</code> 、 <code>WITHDIST</code> 、 <code>WITHHASH</code> 等选项的情况下，命令返回一<font color="red">个二层嵌套数组</font>，内层的每个子数组就表示一个元素。</p><blockquote><p>在返回嵌套数组时，子数组的<font color="red">第一个元素总是位置元素的名字</font>。至于额外的信息，则会作为子数组的后续元素，按照以下顺序被返回：</p><ol><li>以浮点数格式返回的中心<font color="red">与位置元素之间的距离</font>，单位与用户指定范围时的单位一致</li><li><font color="red">geohash 整数</font></li><li>由两个元素组成的坐标，分别为<font color="red">经度和纬度</font></li></ol></blockquote></li></ul></li></ul><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230805143142149.png" alt="image-20230805143142149"></p></li><li><p><strong><code>GEORADIUSBYMEMBER key member radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count]</code> </strong>：与 <code>GEORADIUS</code> 命令类似，只不过这里<strong>指定的是中心的位置名称 <code>member</code> </strong>，而不是它的经纬度。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230805143329626.png" alt="image-20230805143329626"></p></li></ul><blockquote><p><strong>注意</strong>：</p><ul><li><p>从 Redis 版本 6.2.0 开始，<strong> <code>GEORADIUS</code> 命令被视为已弃用</strong>。在迁移或编写新代码时，它可以<font color="red">由 <code>GEOSEARCH</code> 命令和带有 BYRADIUS 参数的 <code>GEOSEARCHSTORE</code> 命令替换</font>。</p></li><li><p>从 Redis 版本 6.2.0 开始，<strong> <code>GEORADIUSBYMEMBER</code> 命令被视为已弃用</strong>。在迁移或编写新代码时，它可以<font color="red">由带有 BYRADIUS 和 FROMMEMBER 参数的 <code>GEOSEARCH</code> 命令和 <code>GEOSEARCHSTORE</code> 命令替换</font>。</p></li></ul></blockquote><h5 id="应用场景-8"><a class="anchor" href="#应用场景-8">#</a> 应用场景</h5><ul><li>美团地图位置附近的酒店推送</li><li>高德地图附近的核酸检查点</li></ul><p>具体见高级篇！</p><h4 id="流stream"><a class="anchor" href="#流stream">#</a> 流（Stream）</h4><blockquote><p>与 Java 中的 Stream 是两码事，几乎没有任何关系！</p><p>自成一脉，<strong>类型就是 Stream！</strong></p></blockquote><h5 id="是什么"><a class="anchor" href="#是什么">#</a> 是什么</h5><p><font color="red">Redis5.0 之前的痛点</font>：<u>Redis</u>消息队列的 2 种方案：</p><ul><li><p><font color="cornflowerblue">List 实现消息队列</font></p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230805154343768.png" alt="image-20230805154343768"></p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230805154402852.png" alt="image-20230805154402852"></p><ul><li>点对点的模式</li><li>缺点：<strong>对于一对多的情况力不从心</strong></li><li>常用来做<font color="red">异步队列</font>使用，将需要延后处理的任务结构体序列化成字符串塞进 Redis 的列表，另一个线程从这个列表中轮询数据进行处理</li></ul></li><li><p><font color="cornflowerblue">Pub/Sub（发布 / 订阅）</font></p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230805181258770.png" alt="image-20230805181258770"></p><ul><li>缺点 1：<strong>消息无法持久化</strong>，如果出现网络断开、Redis 宕机等，消息就会被丢弃。</li><li>缺点 2：<strong>没有 Ack 机制来保证数据的可靠性</strong>，假设一个消费者都没有，那消息就直接被丢弃了。</li></ul></li></ul><p>综上，Redis5.0 版本新增了一个更强大的数据结构 Stream。</p><p>一言蔽之：<strong>Redis Steam 就是 Redis 版本的 MQ 消息中间件 + 阻塞队列</strong>。</p><h5 id="能干嘛"><a class="anchor" href="#能干嘛">#</a> 能干嘛</h5><p>Redis Stream 的功能概览如下：</p><ul><li>实现消息队列</li><li>支持消息的持久化</li><li>支持自动生成全局唯一 ID</li><li>支持 ack 确认消息的模式</li><li>支持消费组模式</li></ul><p>让消息队列更加的稳定和可靠。</p><h5 id="底层结构和原理"><a class="anchor" href="#底层结构和原理">#</a> 底层结构和原理</h5><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230805155540984.png" alt="image-20230805155540984"></p><p>一个消息链表，将所有加入的消息都串起来，每个消息都有一个唯一的 ID 和对应的内容。具体角色如下：</p><table><thead><tr><th>序号</th><th>角色名</th><th>定义</th></tr></thead><tbody><tr><td>1</td><td><strong>Message Content</strong></td><td>消息内容</td></tr><tr><td>2</td><td><strong>Consumer group</strong></td><td>消费组，通过 <code>XGROUP CREATE</code> 命令创建，同一个消费组可以有多个消费者</td></tr><tr><td>3</td><td><strong>Last_delivered_id</strong></td><td>游标，<font color="red">每个消费组会有个游标</font> last_delivered_id，<font color="red">任意一个消费者</font>读取了消息都会使游标 last_delivered_id 往前移动。</td></tr><tr><td>4</td><td><strong>Consumer</strong></td><td>消费者，消费组中的消费者</td></tr><tr><td>5</td><td><strong>Pending_ids</strong></td><td>消费者会有一个状态变量，用于<font color="red">记录被当前消费已读取但未 ack 的消息 Id</font>，如果客户端没有 ack，这个变量里面的消息 ID 会越来越多，一旦某个消息被 ack 它就开始减少。<br>这个 pending_ids 变量在 Redis 官方被称之为 <strong>待处理条目列表 PEL (Pending Entries List)</strong>，记录了当前已经被客户端读取的消息，但是还没有 ack (Acknowledge character：确认字符），它用来确保客户端至少消费了消息一次，而不会在网络传输的中途丢失了没处理</td></tr></tbody></table><h5 id="命令的理论与实操"><a class="anchor" href="#命令的理论与实操">#</a> 命令的理论与实操</h5><h6 id="队列相关命令即生产者角度"><a class="anchor" href="#队列相关命令即生产者角度">#</a> 队列相关命令（即生产者角度）</h6><table><thead><tr><th>指令名称</th><th>指令作用</th></tr></thead><tbody><tr><td>XADD</td><td>添加消息到队列末尾</td></tr><tr><td>XRANGE</td><td>获取消息列表 (可以指定范围)，忽略删除的消息</td></tr><tr><td>XREVRANGE</td><td>反向获取消息列表，ID 从大到小</td></tr><tr><td>XTRIM</td><td>限制 Stream 的长度，如果已经超长会进行截取</td></tr><tr><td>XDEL</td><td>删除消息</td></tr><tr><td>XLEN</td><td>获取 Stream 中的消息长度</td></tr><tr><td>XREAD</td><td>获取消息 (阻塞 / 非阻塞)，返回大于指定 ID 的消息</td></tr></tbody></table><ul><li><p><strong><code>XADD key [NOMKSTREAM] [&lt;MAXLEN | MINID&gt; [= | ~] threshold [LIMIT count]] &lt;* | id&gt; field value [field value ...]</code> </strong>：向 <code>key</code> 指定的 Stream 队列中添加若干条消息内容（ <code>field</code> 和 <code>value</code> ）</p><ul><li>Redis 对 MessageID 有强制要求，必须是<font color="red">时间戳 - 自增 ID</font>这样的方式，且同一时间戳下的后续 ID 不能小于前一个</li><li>Redis 在增加 Message 条目时会检查当前 MessageID 与上一条目的 MessageID，自动纠正错误的情况，<strong>一定要保证后面的 MessageID 比前面大</strong>，一个流中信息条目的 ID 必须是单调增的，这是流的基础</li><li><code>*</code> 号表示服务器<font color="red">自动生成 MessageID</font>(类似 mysql 里面主键 auto_increment)</li><li>返回值：<strong>添加的 Message 条目的 MessageID</strong>。</li></ul><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230805162458455.png" alt="image-20230805162458455"></p></li><li><p><strong><code>XRANGE key start end [COUNT count]</code> </strong>：返回 <code>key</code> 指定的 Stream 队列中与 ** 给定 ID 范围 [ <code>start</code> , <code>end</code> ]** 匹配的消息条目。</p><ul><li><code>start</code> 表示最小 ID，- 代表最小值</li><li><code>end</code> 表示最大 ID，+ 代表最大值</li><li><code>count</code> 表示能获取的最大消息数</li></ul><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230805164434264.png" alt="image-20230805164434264"></p></li><li><p><strong><code>XREVRANGE key end start [COUNT count]</code> </strong>：与 <code>XRANGE</code> 命令相反，以相反的顺序返回消息条目。需要<strong>先指定最大 ID <code>end</code> ，再指定最小 ID <code>start</code> </strong>。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230805165347529.png" alt="image-20230805165347529"></p></li><li><p><strong><code>XDEL key ID [ID ...]</code> </strong>：从 <code>key</code> 指定的 Stream 队列中<strong>逻辑删除</strong>指定 <code>ID</code> 的消息条目。</p><ul><li>当你从 Stream 中删除一个条目的时候，条目并没有<em>真正</em>被驱逐，<strong>只是被标记为删除</strong>。</li></ul><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230805165654765.png" alt="image-20230805165654765"></p></li><li><p><strong><code>XLEN key</code> </strong>：返回 <code>key</code> 指定的 Stream 队列中的消息条目数。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230805165759795.png" alt="image-20230805165759795"></p></li><li><p><strong><code>XTRIM key &lt;MAXLEN | MINID&gt; [= | ~] threshold [LIMIT count]</code> </strong>：<strong>通过删除较旧的消息条目（ID 较低的）来修剪 <code>key</code> 指定的 Stream 队列</strong>。可以使用以下策略之一来修剪流：</p><ul><li><p><code>MAXLEN</code> ：只要 Stream 队列的长度超过指定的阈值 <code>threshold</code> （值为正整数），就会<font color="red">逐出 ID 较低的旧消息条目</font>。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230805170543749.png" alt="image-20230805170543749"></p></li><li><p><code>MINID</code> ：驱逐 ID 低于阈值 <code>threshold</code> （值为 MessageID）的消息条目。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230805170619213.png" alt="image-20230805170619213"></p></li></ul></li><li><p><strong><code>XREAD [COUNT count] [BLOCK milliseconds] STREAMS key [key ...] ID [ID ...]</code> </strong>：从一个或者多个 <code>key</code> 指定的 Stream 队列中读取消息条目，仅返回 ID 大于调用者报告的最后接收 ID 的消息条目。参数 <code>count</code> 表示最多读取的消息数目。参数 <code>[BLOCK milliseconds]</code> 表示是否以阻塞的方式读取消息，<font color="red">默认不阻塞</font>：</p><ul><li><p><font color="cornflowerblue">非阻塞使用</font>：即不提供 <code>BLOCK</code> 参数，此时命令是同步的，会返回 Stream 队列中的一系列消息条目</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230805171740158.png" alt="image-20230805171740158"></p><blockquote><ul><li><p>**$** 代表特殊 ID，<font color="red">表示当前 Stream 已经存储的最大的 ID</font>作为最后一个 ID，当前 Stream 中不存在大于当前最大 ID 的消息，因此此时返回 nil</p></li><li><p><strong>0-0</strong> 代表<font color="red">从最小的 ID 开始</font>获取 Stream 中的消息，当不指定 count，将会返回 Stream 中的所有消息，注意也可以使用 0（00/000 也都是可以的……）</p></li></ul></blockquote></li><li><p><font color="cornflowerblue">阻塞使用</font>：提供 <code>BLOCK</code> 参数，如果 milliseconds 设置为 0，表示永远阻塞</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230805172251635.png" alt="image-20230805172251635"></p></li></ul></li></ul><p>小结：Stream 的基础方法，使用 <code>xadd</code> 存入消息和 <code>xread</code> 循环阻塞读取消息的方式可以实现<strong>简易版的消息队列</strong>，交互流程如下：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230805172400243.png" alt="image-20230805172400243"></p><p>对比 List 结构实现 Redis 消息队列：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230805172428816.png" alt="image-20230805172428816"></p><h6 id="消费组相关命令即消费者角度"><a class="anchor" href="#消费组相关命令即消费者角度">#</a> 消费组相关命令（即消费者角度）</h6><table><thead><tr><th>指令名称</th><th>指令作用</th></tr></thead><tbody><tr><td>XGROUP CREATE</td><td>创建消费组</td></tr><tr><td>XGROUP SETID</td><td>设置消费组最后递送消息的 ID</td></tr><tr><td>XGROUP DESTROY</td><td>完全销毁消费组</td></tr><tr><td>XGROUP DELCONSUMER</td><td>移除给定的消费者</td></tr><tr><td>XREADGROUP GROUP</td><td>读取消费者组中的消息</td></tr><tr><td>XACK</td><td>将消息标记为 ack，即 “已处理”</td></tr><tr><td>XPENDING</td><td>打印待处理消息的详细信息</td></tr><tr><td>XCLAIM</td><td>转移消息的归属权（长期未被处理 / 无法处理的消息，转交给其他消费者组进行处理)</td></tr><tr><td>XINFO</td><td>打印 Stream\Consumer\Group 的详细信息</td></tr><tr><td>XINFO GROUPS</td><td>打印消费者组的详细信息</td></tr><tr><td>XINFO STREAM</td><td>打印 Stream 的详细信息</td></tr></tbody></table><ul><li><p><strong><code>XGROUP [CREATE key groupname id-or-$] [SETID key id-or-$] [DESTROY key groupname] [DELCONSUMER key groupname consumername]</code> </strong>：用于<strong>管理 <code>key</code> 指定的 Stream 队列上所关联的消费组</strong>，可以：</p><ul><li><p><code>CREATE</code> ：在 <code>key</code> 指定的 Stream 队列上<strong>创建一个新消费组</strong></p><ul><li>设置消费组名为 <code>groupname</code></li><li>指定从消息 <code>id</code> 开始从头到尾读取（消费）</li><li>或者 <code>$</code> 表示从尾部开始反向读取（消费）</li></ul><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230805174041986.png" alt="image-20230805174041986"></p></li><li><p><code>SETID</code> ：针对 <code>key</code> 指定的 Stream 队列，<strong>设置消费组最后递送的消息 <code>id</code> </strong>，同理也能取 <code>$</code></p></li><li><p><code>DESTROY</code> ：从 <code>key</code> 指定的 Stream 队列上<strong>销毁一个名为 <code>groupname</code> 的消费组</strong></p></li><li><p><code>DELCONSUMER</code> ：针对 <code>key</code> 指定的 Stream 队列，<strong>从组名为 <code>groupname</code> 的消费组中移除名为 <code>consumername</code> 的消费者</strong>。</p></li></ul></li><li><p><strong><code>XREADGROUP GROUP groupname consumername [COUNT count] [BLOCK milliseconds] STREAMS key [key ...] ID [ID ...]</code> </strong>：是 <code>XREAD</code> 命令的特殊版本，支持消费者组。针对 <code>key</code> 指定的 Stream 队列，可以<strong>让消费组 <code>groupname</code> 的不同消费者 <code>consumername</code> 来读取 Stream 的不同部分</strong>。</p><ul><li><p>同一个消费组中的消费者<font color="red">共享同一个游标</font>，因此：</p><ul><li><p><strong>同一个消费组中的消费者不能消费同一条消息</strong>。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230805175640453.png" alt="image-20230805175640453"></p></li><li><p><strong>不同消费组中的消费者可以消费同一条消息</strong>。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230805180522655.png" alt="image-20230805180522655"></p></li></ul></li><li><p>参数 <code>COUNT</code> 限制当前消费者能够读取的消息数量，默认为 +∞</p></li><li><p>参数 <code>BLOCK</code> 表示是否阻塞读取消息</p></li><li><p><code>ID</code> 表示从哪条消息 id 开始读取，其中<font color="red"> <code>&gt;</code> 表示从第一条尚未被消费的消息开始读取</font></p></li></ul><blockquote><p>消费组的目的：</p><p>​ 让组内的多个消费者共同分担读取消息。所以，我们通常会让每个消费者读取部分消息，从而实现消息读取负载在多个消费者间是均衡分布的。（<strong>负载均衡</strong>）</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230805180648195.png" alt="image-20230805180648195"></p></blockquote></li></ul><p><strong>重点问题：ACK 机制</strong></p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230805180956093.png" alt="image-20230805180956093"></p><blockquote><p>问题：</p><p>​ 基于 Stream 实现的消息队列，如何保证消费者在发生故障或宕机再次重启后，仍然可以读取未处理完的消息？</p><p>方案：</p><ul><li>Streams 会自动使用内部队列（也称为<strong>待处理条目列表 PEL (Pending Entries List)</strong>）留存每个消费组里每个消费者读取的消息保底措施，直到消费者使用 <code>XACK</code> 命令通知 Streams “消息已经处理完成”。</li><li>消费确认机制增加了消息的可靠性，一般在业务处理完成之后，需要执行 XACK 命令确认消息已经被消费完成。</li></ul></blockquote><ul><li><p><strong><code>XPENDING key groupname [start end count] [consumername]</code> </strong>：查询 <code>key</code> 指定的 Stream 队列上，组名为 <code>groupname</code> 的<u>消费组</u>内<strong>已读取但未确认的情况</strong></p><p><img data-src="C:%5CUsers%5Chuawei%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20230805182227981.png" alt="image-20230805182227981"></p><blockquote><p>返回值是<strong>概要信息</strong>：</p><ol><li><p>该消费者组的待处理消息的数量</p></li><li><p>待处理消息的最小 ID</p></li><li><p>待处理消息的最大 ID</p></li><li><p>对于消费者组中每一个至少有一条待处理消息的消费者，</p><ol><li>他的名称</li><li>他的待处理消息数量</li></ol></li></ol></blockquote><ul><li><p>若指定消费者名 <code>consumername</code> ，也可以查看<u>某个消费者</u>的已读取但未确认的情况</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230805182430081.png" alt="image-20230805182430081"></p><blockquote><p>返回值是<strong>详细信息</strong>：</p><ol><li>消息的 ID</li><li>获取并仍然要确认消息的消费者名称，我们称之为消息的当前<em>所有者</em></li><li>自上次将此消息传递给该消费者以来，经过的毫秒数</li><li>该消息被传递的次数</li></ol></blockquote></li></ul></li><li><p><strong><code>XACK key groupname ID [ID ...]</code> </strong>：从 <code>key</code> 指定的 Stream 队列中的消费者组 <code>groupname</code> 的待处理条目列表（简称 PEL）中删除若干条指定了 <code>ID</code> 的消息，即确认消息。返回成功确认的消息数。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230805184337097.png" alt="image-20230805184337097"></p></li><li><p><strong><code>XINFO [CONSUMERS key groupname] key key [HELP]</code> </strong>：打印关于 Stream 和关联的消费组的不同的信息。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230805184502786.png" alt="image-20230805184502786"></p></li></ul><h6 id="四个特殊符号"><a class="anchor" href="#四个特殊符号">#</a> 四个特殊符号</h6><table><thead><tr><th>符号</th><th>作用</th></tr></thead><tbody><tr><td>- +</td><td>最小和最大可能出现的 Id</td></tr><tr><td>$</td><td>表示只消费新的消息，当前流中最大的 id，可用于将要到来的信息</td></tr><tr><td>&gt;</td><td>用于 <code>XREADGROUP</code> 命令，表示迄今还没有发送给组中使用者的信息，会更新消费者组的最后 ID</td></tr><tr><td>*</td><td>用于 <code>XADD</code> 命令中，让系统自动生成 Id</td></tr></tbody></table><h5 id="使用建议"><a class="anchor" href="#使用建议">#</a> 使用建议</h5><p><strong>Redis Stream 不能 100% 替代 Kafka、RabbitMQ 来使用，生产案例少，慎用！</strong></p><h4 id="位域bitfield"><a class="anchor" href="#位域bitfield">#</a> 位域（Bitfield）</h4><blockquote><p>了解即可</p></blockquote><p>定义：将一个 Redis 字符串看作是<font color="red">一个由二进制位组成的数组</font>，并能对变长位宽和任意没有字节对齐的指定整型位域进行寻址和修改。</p><p>作用：</p><ul><li>位域修改</li><li>溢出控制</li></ul><p>基本语法：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230805185443067.png" alt="image-20230805185443067"></p><h2 id="4-redis持久化persistence"><a class="anchor" href="#4-redis持久化persistence">#</a> 4、Redis 持久化（persistence）</h2><blockquote><p>Redis 持久化：Redis 是如何将数据从内存<strong>写入磁盘</strong>的？</p><p>Redis 为什么需要持久化？因为 Redis 运行过程中数据是缓存在内存中的，一旦发生意外导致宕机，数据将会消失，Redis 就会形同虚设。</p><p>Redis 持久化的三种实现方式：</p><ul><li>RDB（Redis DataBase）</li><li>AOF（Append Only File）</li><li>RDB + AOF</li></ul></blockquote><h3 id="持化双雄"><a class="anchor" href="#持化双雄">#</a> 持化双雄</h3><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230806003810720.png" alt="image-20230806003810720"> <img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230806003858469.png" alt="image-20230806003858469"><h4 id="rdbredis-database"><a class="anchor" href="#rdbredis-database">#</a> RDB（ <code>R</code> edis <code>D</code> ata <code>B</code> ase）</h4><h5 id="简介"><a class="anchor" href="#简介">#</a> 简介</h5><p>RDB 持久化：<strong>以<u>指定的时间间隔</u>执行数据集的时间点快照</strong>，将内存中的数据集以<font color="red">全量快照</font>的形式写入磁盘保存的文件是<font color="red">dump.rdb</font>，恢复时将磁盘中的快照文件读回内存中。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230806005245328.png" alt="image-20230806005245328"></p><h5 id="触发rdb快照的时间间隔"><a class="anchor" href="#触发rdb快照的时间间隔">#</a> 触发 RDB 快照的时间间隔</h5><p>对于自动触发快照的时间间隔，在配置文件 <code>redis.conf</code> 中的 SNAPSHOTTING 下配置 <code>save</code> 参数，来触发 RDB 持久化条件。比如 “save m n”: 表示每隔 m 秒检测一次数据集，如果检测出超过 n 次变化时，自动触发 RDB 持久化条件，执行快照。</p><blockquote><p>注意，这里说的是<strong>每隔 m 秒检测一次，<font color="red">对变化的计数是累加的</font>，只要在某次检测中发现变化数累加值达到 n 次，就会触发 RDB 持久化。<font color="red">而不是要求 n 次变化都集中发生在某个 m 秒内！</font></strong></p></blockquote><ul><li><p><strong><font color="cornflowerblue">Redis6.0.16 及之前</font></strong>：</p><ul><li>save 900 1：每隔 900s (15min) 检测一次，如果有超过 1 个 key 发生了变化，就写一份新的 RDB 文件</li><li>save 300 10：每隔 300s (5min) 检测一次，如果有超过 10 个 key 发生了变化，就写一份新的 RDB 文件</li><li>save 60 10000：每隔 60s (1min) 检测一次，如果有超过 10000 个 key 发生了变化，就写一份新的 RDB 文件</li></ul><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230806010837837.png" alt="image-20230806010837837"></p></li><li><p><strong><font color="cornflowerblue">Redis6.0.16 以后至 Redis7 至今</font></strong>：</p><ul><li>每隔 3600s（1hour）检测一次，如果有超过 1 处变化，就写一份新的 RDB 文件</li><li>每隔 300s（5min）检测一次，如果有超过 100 处变化，就写一份新的 RDB 文件</li><li>每隔 60s（1min）检测一次，如果有超过 10000 处变化，就写一份新的 RDB 文件</li></ul><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230806010819707.png" alt="image-20230806010819707"></p></li></ul><h5 id="rdb快照的触发方式"><a class="anchor" href="#rdb快照的触发方式">#</a> RDB 快照的触发方式</h5><h6 id="自动触发"><a class="anchor" href="#自动触发">#</a> 自动触发</h6><center><font color="cornflowerblue">修改配置信息</font></center><ul><li><p>修改时间间隔与变化数：通过修改配置文件 <code>redis.conf</code> 中的 SNAPSHOTTING 下的 <code>save</code> 参数</p></li><li><p>修改 dump.rdb 文件的保存路径 **（Redis 每次启动都会读取磁盘中该目录下的 dump.rdb 文件（文件名需要与配置文件中保持一致）来初始化内存中的 Redis 数据库）**：通过修改配置文件 <code>redis.conf</code> 中的 SNAPSHOTTING 下的 <code>dir</code> 参数</p><blockquote><p>通过 Redis 命令 <code>CONFIG GET dir</code> 可以查看 dir 参数的取值：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230806113359010.png" alt="image-20230806113359010"></p></blockquote></li><li><p>修改 dump.rdb 文件的名称：通过修改配置文件 <code>redis.conf</code> 中的 SNAPSHOTTING 下的 <code>dbfilename</code> 参数</p></li></ul><center><font color="cornflowerblue">触发备份的2个案例</font></center><ul><li><p>每隔 5 秒检测一次，检测到 2 处变化，执行备份：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230806113923793.png" alt="image-20230806113923793"></p></li><li><p>每隔 5 秒检测一次，先设置 k3，只检测到 1 处变化，无备份动作。再过一段时间（可以超过 5 秒！）设置 k4，检测出第 2 处变化，执行备份：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230806114111595.png" alt="image-20230806114111595"></p></li></ul><center><font color="cornflowerblue">如何恢复数据</font></center><ol><li><p>根据配置文件 <code>redis.conf</code> ，将备份文件（dump.rdb）移至保存路径下</p><blockquote><p>这里<font color="red">备份文件的名称、保存路径</font>一定要与配置文件 <code>redis.conf</code> 中的设置保持一致！</p></blockquote></li><li><p>让 Redis 读取指定的配置文件 <code>redis.conf</code> ，并启动 Redis 服务</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230806114837995.png" alt="image-20230806114837995"></p></li></ol><blockquote><p>执行 <code>flushdb</code> / <code>flushall</code> 命令会<strong>产生一个空的 dump.rdb 文件</strong>，执行 <code>shutdown</code> 会<strong>产生一个退出时的 dump.rdb 文件</strong>，且会<strong>覆盖同路径下的同名备份文件</strong>！<font color="red">等到下次 Redis 服务启动时，读取的就是这个空的 / 上次 shutdown 时的 dump.rdb 文件</font>。</p><p><img data-src="C:%5CUsers%5Chuawei%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20230806115618721.png" alt="image-20230806115618721"></p><p>因此，<strong>不可以把备份文件 dump.rdb 和生产 redis 服务器放在同一台机器，必须分开存储，<font color="red">分机隔离</font>，以防生产机物理损坏后备份文件也挂了</strong>。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230806115554369.png" alt="image-20230806115554369"></p></blockquote><h6 id="手动触发"><a class="anchor" href="#手动触发">#</a> 手动触发</h6><p>在默认情况下（即自动触发），Redis 将数据库快照保存在名字为 dump.rdb 的二进制文件中。你可以对 Redis 的配置文件 <code>redis.conf</code> 进行设置，让它在 “每 N 秒检测一次，当数据集有 M 个改动时” 这一条件被满足时，自动保存一次快照。</p><p>也可以<strong>通过调用 <code>SAVE</code> 或者 <code>BGSAVE</code> 命令，手动让 Redis 保存数据库的快照</strong>。</p><p>快照保存的工作方式：</p><ul><li><p>Redis 调用<font color="red">forks</font>. 同时拥有父进程和子进程。</p><blockquote><p>在 Linux 程序中，fork () 会产生一个和父进程完全相同的子进程，但子进程在此后多会 exec 系统调用，出于效率考虑，尽量避免膨胀。</p></blockquote></li><li><p>子进程将数据集写入到一个临时 RDB 文件中。</p></li><li><p>当子进程完成对新 RDB 文件的写入时，Redis 用新 RDB 文件替换原来的 RDB 文件，并删除旧的 RDB 文件。</p></li></ul><p>这种工作方式使得 Redis 可以从<font color="red">写时复制（copy-on-write）</font>机制中获益。</p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230806122757973.png" alt="image-20230806122757973" style="zoom:50%"><center><font color="cornflowerblue">SAVE命令</font></center><blockquote><p>** 线上严禁使用！** 因为在主程序中执行 SAVE 命令时，<strong>会阻塞</strong>当前 redis 服务器，Redis 不能处理其他命令，缓存功能就缺失了，直到持久化工作完成。</p></blockquote><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230806123508579.png" alt="image-20230806123508579"></p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230806123541045.png" alt="image-20230806123541045"></p><center><font color="cornflowerblue">BGSAVE命令（默认）</font></center><blockquote><p>Redis 会在后台异步进行快照操作，<strong>不阻塞</strong>当前 Redis 服务器，还可以同时响应客户端请求。</p></blockquote><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230806145215893.png" alt="image-20230806145215893"></p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230806145228038.png" alt="image-20230806145228038"></p><center><font color="cornflowerblue">LASTSAVE命令：获取最近一次快照的时间</font></center><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230806145339310.png" alt="image-20230806145339310"></p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230806145349994.png" alt="image-20230806145349994"></p><h5 id="rdb的优缺点"><a class="anchor" href="#rdb的优缺点">#</a> RDB 的优缺点</h5><p>RDB 持久化的优点：</p><ul><li>适合<font color="red">大规模</font>的数据恢复</li><li>按照业务，<font color="red">定时备份</font></li><li>对数据完整性和一致性要求不高</li><li>dump.rdb 文件在内存中的<font color="red">加载速度</font>要比 AOF 快得多</li></ul><p>RDB 持久化的缺点：</p><ul><li>一定间隔时间做一次备份，所以如果 Redis 意外 down 掉的话，就会丢失从当前至最近一次快照期间的数据，<strong><font color="red">快照之间的数据会丢失</font></strong></li><li>内存数据的全量同步，如果数据量太大会导致<font color="red">I/O 严重影响服务器性能</font></li><li>RDB 依赖于主进程的 fork，在更大的数据集中，这可能会导致<font color="red">服务请求的瞬间延迟</font></li><li>fork 的时候内存中的数据被克降了一份，<font color="red">大致 2 倍的数据膨胀性</font>，需要考虑</li></ul><p>快照之间的数据丢失案例：</p><ol><li><p>正常录入数据</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230806151059638.png" alt="image-20230806151059638"></p></li><li><p>kill -9 故意模拟意外宕机</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230806151113184.png" alt="image-20230806151113184"></p></li><li><p>Redis 重启，查看数据发现丢失</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230806151151946.png" alt="image-20230806151151946"></p></li></ol><h5 id="如何检查-恢复dumprdb文件"><a class="anchor" href="#如何检查-恢复dumprdb文件">#</a> 如何检查、恢复 dump.rdb 文件</h5><blockquote><p>当 dump.rdb 文件破损时，需要恢复它，可以使用 <code>redis-check-rdb</code> 命令进行修复。</p></blockquote><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230806151515656.png" alt="image-20230806151515656"></p><h5 id="触发rdb快照的情况"><a class="anchor" href="#触发rdb快照的情况">#</a> 触发 RDB 快照的情况</h5><ul><li><p>配置文件 <code>redis.conf</code> 中默认的快照配置</p></li><li><p>手动 <code>save</code> / <code>bgsave</code> 命令</p></li><li><p>执行 <code>flushall</code> / <code>flushdb</code> 命令会产生<strong>空的</strong> <code>dump.rdb</code> 文件</p></li><li><p>执行 <code>shutdown</code> 命令，且没有设置开启 AOF 持久化</p></li><li><p>主从复制时，主节点自动触发</p></li></ul><h5 id="如何禁用rdb快照"><a class="anchor" href="#如何禁用rdb快照">#</a> 如何禁用 RDB 快照</h5><p>两种方式：</p><ul><li><p>命令： <code>res-cli config set save &quot;&quot;</code></p></li><li><p>修改配置文件：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230806152126685.png" alt="image-20230806152126685"></p></li></ul><h5 id="rdb快照的配置优化项"><a class="anchor" href="#rdb快照的配置优化项">#</a> RDB 快照的配置优化项</h5><blockquote><p>即配置文件 <code>redis.conf</code> 中的 SNAPSHOTTING 模块</p></blockquote><ul><li><p>save &lt;seconds&gt; &lt;changes&gt;：触发快照的<font color="red">时间间隔、变化数</font></p></li><li><p>dbfilename：rdb 文件的<font color="red">名称</font></p></li><li><p>dir：rdb 文件的<font color="red">保存路径</font></p></li><li><p>stop-writes-on-bgsave-error：当子进程执行快照保存出现错误时，<font color="red">是否让主进程停止接收新的写请求</font>，默认为 yes。</p><blockquote><p>如果不在乎数据不一致或者有其他手段发现和控制这种不一致，也可以设置为 no。此时在快照写入失败时，也能确保 Redis 继续接受新的写请求</p></blockquote></li><li><p>rdbcompression：对于存储到磁盘中的快照，可以设置<font color="red">是否采用 LZF 算法进行压缩存储</font>，默认为 yes。</p></li><li><p>rdbchecksum：<font color="red">是否采用 CRC64 算法对快照文件进行数据校验</font>，默认为 yes。</p></li><li><p>rdb-del-sync-files：看不懂，默认情况下 no，禁用。</p></li></ul><h5 id="rdb小结"><a class="anchor" href="#rdb小结">#</a> RDB 小结</h5><img data-src="C:\Users\huawei\AppData\Roaming\Typora\typora-user-images\image-20230806153628002.png" alt="image-20230806153628002" style="zoom:67%"><h4 id="aofappend-only-file"><a class="anchor" href="#aofappend-only-file">#</a> AOF（ <code>A</code> ppend <code>O</code> nly <code>F</code> ile）</h4><h5 id="简介-2"><a class="anchor" href="#简介-2">#</a> 简介</h5><p>AOF 持久化：<strong>以日志文件的形式来记录 Redis 执行过的每个写操作指令</strong>，只许追加记录，不可改写记录。Redis 启动之初会读取该日志文件重新构建数据，换言之，Redis 重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。</p><p>默认情况下，Redis 是没有开启 AOF 的，开启 AOF 功能需要在配置文件 <code>redis.conf</code> 中设置配置: <code>appendonly yes</code> 。</p><p>动机：对于 RDB 持久化的快照，如果 Redis 因为某些原因而造成故障停机，那么服务器<font color="red">将丢失最近写入、且仍未保存到快照中的那些数据</font>。 因此，Redis 增加了一种完全耐久的持久化方式：AOF 持久化。</p><p>AOF 持久化所保存的文件： <code>appendonly.aof</code> 文件。</p><h5 id="aof持久化的工作流程"><a class="anchor" href="#aof持久化的工作流程">#</a> AOF 持久化的工作流程</h5><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230806195559645.png" alt="image-20230806195559645"></p><ol><li><p>Client 作为命令的来源，会有多个源头以及源源不断的<font color="red">请求写命令</font>。</p></li><li><p>在这些命令到达 Redis Server 以后并不是直接写入 AOF 文件，会将其这些命令<font color="red">先放入 AOF 缓存</font>中进行保存。</p><blockquote><p>这里的 AOF 缓冲区实际上是内存中的一片区域，存在的目的是当这些<font color="red">命令达到一定量以后再写入磁盘</font>，避免频繁的磁盘 IO 操作。</p></blockquote></li><li><p>AOF 缓冲会根据<strong> AOF 缓冲区同步文件的三种写回策略</strong><font color="red">将命令写入磁盘上的 AOF 文件</font>。</p></li><li><p>随着写入 AOF 内容的增加为避免文件膨胀，会根据规则<font color="red">进行命令的合并 (又称<strong> AOF 重写</strong>)</font>，从而起到 AOF 文件压缩的目的。</p></li><li><p>当 Redis Server 服务器重启的时候<font color="red">Redis 会从 AOF 文件载入数据</font>。</p></li></ol><h5 id="aof缓冲区的三种写回策略"><a class="anchor" href="#aof缓冲区的三种写回策略">#</a> AOF 缓冲区的三种写回策略</h5><p>AOF 缓冲区需要将它保存的写命令写入磁盘上的 AOF 文件，可以修改配置文件上的 <code>参数appendfsync</code> ，有三种策略：</p><ul><li><code>always</code> ：<font color="red">同步写回</font>，每个写命令执行完立刻同步地将日志写入磁盘上的 AOF 文件</li><li><code>everysec</code> ：<font color="red">每秒写回</font>，每个写命令执行完，只是先把日志写到 AOF 文件的内存缓冲区，每隔 1 秒把缓冲区中的内容写入磁盘</li><li><code>no</code> ：<font color="red">操作系统控制的写回</font>，每个写命令执行完，只是先把日志写到 AOF 文件的内存缓冲区，由操作系统决定何时将缓冲区内容写回磁盘</li></ul><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230806200107294.png" alt="image-20230806200107294"></p><h5 id="案例演示和说明"><a class="anchor" href="#案例演示和说明">#</a> 案例演示和说明</h5><h6 id="配置文件说明6-vs-7"><a class="anchor" href="#配置文件说明6-vs-7">#</a> <mark>配置文件说明（6 vs 7）</mark></h6><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230806200804696.png" alt="image-20230806200804696"></p><center><font color="cornflowerblue">如何开启AOF</font></center><p>将配置文件 <code>redis.conf</code> 中 APPEND ONLY MODE 模块下的 <code>参数appendonly</code> 设置为 yes，即打开 AOF 持久化支持。</p><center><font color="cornflowerblue">使用默认的写回策略：everysec</font></center><p>将配置文件 <code>redis.conf</code> 中 APPEND ONLY MODE 模块下的 <code>参数appendfsync</code> 设置为 everysec</p><center><font color="cornflowerblue">AOF文件的保存路径</font></center><p>Redis6：AOF 保存文件的位置<font color="red">和 RDB 保存文件的位置一样</font>，都是通过配置文件 redis.conf 的 <code>参数dir</code> 配置</p><blockquote><p>dir/dump.rdb</p></blockquote><p>Redis7：在 <code>参数dir</code> 的基础上，再通过配置文件 redis.conf 中 APPEND ONLY MODE 模块下的 <code>参数appenddirname</code> ，二者拼接成为 AOF 文件的保存路径</p><blockquote><p>dir/appenddirname/appendonly.aof</p></blockquote><center><font color="cornflowerblue">AOF文件的名称</font></center><p>Redis6：有且仅有 <code>appendonly.aof</code> 一个 AOF 文件</p><p>Redis7：采用了 <strong>multi part AOF 机制</strong>，将原来的<font color="red">单个 AOF 文件拆分成多个 AOF 文件</font>，<font color="red">文件名前缀都是 <code>appendonly.aof</code> </font>，分为<font color="red">三种类型</font>：</p><ul><li><p><font color="gree">BASE AOF</font>：基础 AOF，它一般由子进程 **<font color="red">通过重写产生</font>**，该文件最多只有一个。</p></li><li><p><font color="gree">INCR AOF</font>：增量 AOF，它一般会在 **<font color="red">AOFRW 开始执行时被创建</font>**，该文件可能存在多个。</p><blockquote><p><font color="red">记录写命令</font>的主力军！</p></blockquote></li><li><p>HISTORY AOF：历史 AOF，它由 BASE AOF 和 INCR AOF 变化而来。每次<font color="red">AOFRW 成功完成时</font>，本次 AOFRW 之前对应的 BASE AOF 和 INCR AOF 都将变为 HISTORY AOF，之后<font color="red">会被 Redis 自动删除</font>。</p></li></ul><blockquote><p>为了管理这些 AOF 文件，<font color="red">引入了一个<font color="gree">manifest (清单）文件</font>来跟踪、管理这些 AOF</font>。同时，为了便于 AOF 备份和拷贝，我们<font color="red">将所有的 AOF 文件和 manifest 文件放入一个单独的文件目录中</font>，目录名由参数 appenddirname 配置 (Redis 7.0 新增配置项) 决定。</p></blockquote><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230806210712843.png" alt="image-20230806210712843"></p><h6 id="正常恢复aof文件"><a class="anchor" href="#正常恢复aof文件">#</a> 正常恢复 AOF 文件</h6><p>首先开启 AOF，然后执行写操作，生成 AOF 文件到指定的目录中</p><p><img data-src="C:%5CUsers%5Chuawei%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20230806220336112.png" alt="image-20230806220336112"></p><p>Redis 重启并重新加载，结果符合预期，具体过程见脑图。</p><blockquote><p><code>flushdb</code> 命令也会被增量 AOF 记录，因此 Redis 重启后也会加载并执行清空库操作。</p></blockquote><h6 id="异常恢复aof文件"><a class="anchor" href="#异常恢复aof文件">#</a> 异常恢复 AOF 文件</h6><blockquote><p>何为异常：在高并发情况下，可能上一秒刚写入一半，突然 Redis 挂了，导致 AOF 文件有缺陷、错误，那么如何恢复 AOF 文件呢？</p></blockquote><p>首先故意乱写正常的增量 AOF 文件，模拟网络闪断文件写 error</p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230806222044975.png" alt="image-20230806222044975" style="zoom:80%"><p>然后尝试重启 Redis 加载 AOF 文件，发现怎样都启动不了</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230806222108149.png" alt="image-20230806222108149"></p><p>执行异常修复命令 <code>redis-check-aof --fix</code> 来修复增量 AOF 文件</p><blockquote><p><strong>只能修复增量 AOF 文件！</strong></p></blockquote><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230806222145406.png" alt="image-20230806222145406"></p><p>重启 Redis，成功加载 AOF 文件</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230806222228890.png" alt="image-20230806222228890"></p><h5 id="aof的优缺点"><a class="anchor" href="#aof的优缺点">#</a> AOF 的优缺点</h5><p>AOF 有以下优点：</p><ul><li><p>更好地保护数据不丢失</p><blockquote><p>使用 AOF Redis 更加持久∶您可以有<font color="red">不同的 fsync 策略</font>: 根本不 fsync、每秒 fsync、每次查询时 fsync。使用每秒 fsync 的默认策略，写入性能仍然很棒。fsync 是使用后台线程执行的，当没有 fsync 正在进行时，主线程将努力执行写入，因此您<font color="red">只能丢失一秒钟的写入</font>。</p></blockquote></li><li><p>易修复</p><blockquote><p>AOF 日志是一个仅附加日志，因此不会出现寻道问题，也不会在断电时出现损坏问题。即使由于某种原因（磁盘已满或其他原因）日志以写一半的命令结尾， <code>redis-check-aof</code> 工具也能够轻松修复它。</p></blockquote></li><li><p>得益于 AOF 的重写机制，能够自我压缩</p><blockquote><p>当 AOF 变得太大时，Redis 能够在后台自动重写 AOF。重写是完全安全的，因为当 Redis 继续附加到旧文件时，会使用创建当前数据集所需的最少操作集生成一个全新的文件，一旦第二个文件准备就绪，Redis 就会切换两者并开始附加到新的那一个。</p></blockquote></li><li><p>性能高</p></li><li><p>文件内容易理解</p><blockquote><p>AOF 以易于理解和解析的格式依次包含所有操作的日志。您甚至可以轻松导出 AOF 文件。</p></blockquote></li><li><p>可做紧急恢复</p><blockquote><p>即使您不小心使用该 <code>FLUSHALL</code> 命令刷新了所有内容，只要在此期间没有执行日志重写，您仍然可以通过停止服务器、<font color="red">删除最新命令</font>并重新启动 Redis 来保存您的数据集。</p></blockquote></li></ul><p>AOF 有以下缺点：</p><ul><li>对于相同的数据集而言，aof 文件要<font color="red">远大于 rdb 文件</font>，<font color="red">恢复速度慢于 rdb</font></li><li>aof<font color="red">运行效率要慢于 rdb</font>，每秒同步策略效率较好，不同步效率和 rdb 相同</li></ul><h5 id="aof重写机制"><a class="anchor" href="#aof重写机制">#</a> <mark>AOF 重写机制</mark></h5><h6 id="简介-3"><a class="anchor" href="#简介-3">#</a> 简介</h6><p><font color="orange">AOF 重写机制</font>：启动 AOF 文件的内容压缩，合并其中的命令，只保留可以恢复数据的最小指令集。</p><blockquote><p><strong><font color="red">重写完成后</font></strong>：</p><ul><li>重写结果被保存到一个新的 BASE AOF 文件中，文件名上的标号加 1。</li><li>同时，新建一个空的 INCR AOF 文件，文件名上的标号加 1，旧的被删除</li></ul></blockquote><p>AOF 重写机制有<font color="red">两种触发方式</font>：</p><ul><li><p><font color="cornflowerblue">自动触发</font>：当 INCR AOF 文件<font color="red">同时满足</font>以下两个条件时，Redis 就会<font color="red">自动</font>启动重写机制，只保留可以恢复数据的最小指令集</p><blockquote><p>INCR AOF 文件负责记录从 AOF 缓冲区写回的写命令</p></blockquote><ul><li>当 INCR AOF 文件的大小超过上一次重写结果（即 BASE AOF 文件）大小 1 倍（可以通过配置 <code>auto-aof-rewrite-percentage</code> 修改）</li><li>当 INCR AOF 文件的大小超过 64MB（可以通过配置 <code>auto-aof-rewrite-min-size</code> 修改）</li></ul></li><li><p><font color="cornflowerblue">手动触发</font>：可以手动使用命令 <code>bgrewriteaof</code> 来重写。</p></li></ul><h6 id="案例演示和说明-2"><a class="anchor" href="#案例演示和说明-2">#</a> 案例演示和说明</h6><p>具体过程见脑图，这里只演示 AOF 重写后的效果：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230807004504357.png" alt="image-20230807004504357"></p><center>自动重写</center><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230807004613263.png" alt="image-20230807004613263"></p><center>手动重写</center><p>结论：</p><ul><li>AOF 文件重写并不是对原文件进行重新整理，而是<font color="red">直接读取服务器现有的键值对，然后用一条命令去代替之前记录这个键值对的多条命令</font>，生成一个新的文件后去替换原来的 AOF 文件。</li><li>AOF 文件重写触发机制：通过 redis.conf 配置文件中的 <code>auto-aof-rewrite-percentage</code> : 默认值为 100，以及 <code>auto-aof-rewrite·min-size</code> : 64mb 配置，也就是说默认 Redis 会记录上次重写时的 AOF 大小，默认配置是当 AOF 文件大小是上次 rewrite 后大小的一倍<strong>且</strong>文件大于 64M 时触发。</li></ul><h6 id="重写原理"><a class="anchor" href="#重写原理">#</a> 重写原理</h6><ol><li><p>在重写开始前，redis 会创建一个 “重写子进程”，这个子进程会读取现有的 AOF 文件，并将其包含的指令进行分析压缩并写入到一个临时文件中。</p></li><li><p>与此同时，主进程会将新接收到的写指令一边累积到内存缓冲区中，一边继续写入到原有的 AOF 文件中，这样做是保证原有的 AOF 文件的可用性，避免在重写过程中出现意外。</p></li><li><p>当 “重写子进程” 完成重写工作后，它会给父进程发一个信号，父进程收到信号后就会将内存中缓存的写指令追加到新 AOF 文件中</p></li><li><p>当追加结束后，redis 就会用新 AOF 文件来代替旧 AOF 文件，之后再有新的写指令，就都会追加到新的 AOF 文件中</p></li><li><p>重写 aof 文件的操作，并没有读取旧的 aof 文件，而是将整个内存中的数据库内容用命令的方式重写了一个新的 aof 文件，这点和快照有点类似</p></li></ol><h5 id="aof的配置优化项"><a class="anchor" href="#aof的配置优化项">#</a> AOF 的配置优化项</h5><p>模块 APPEND ONLY MODE：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230807005317244.png" alt="image-20230807005317244"></p><h5 id="aof小结"><a class="anchor" href="#aof小结">#</a> AOF 小结</h5><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230807005534144.png" alt="image-20230807005534144"></p><h3 id="rdb-aof混合持久化"><a class="anchor" href="#rdb-aof混合持久化">#</a> RDB-AOF 混合持久化</h3><h4 id="简介-4"><a class="anchor" href="#简介-4">#</a> 简介</h4><p>Redis<strong> 默认仅使用 RDB 持久化，禁用 AOF 持久化</strong>。但是，当我们<strong>手动启用 AOF 持久化后，AOF 的优先级高于 RDB</strong>！对应的数据恢复顺序和加载流程如下图：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230807010014261.png" alt="image-20230807010014261"></p><h4 id="到底采用哪种持久化方式"><a class="anchor" href="#到底采用哪种持久化方式">#</a> 到底采用哪种持久化方式？</h4><p>二者各自的特点如下：</p><ul><li>RDB 持久化：（定时一锅端）能够在指定的时间间隔能对你的数据进行快照存储</li><li>AOF 持久化：（实时记录写命令）记录每次对服务器写的操作，当服务器重启的时候会重新执行这些命令来恢复原始的数据，命令以 redis 协议追加保存每次写的操作到文件末尾。</li></ul><p>同时开启时的情况：</p><ul><li>当 redis 重启的时候会<font color="red">优先载入 AOF 文件</font>来恢复原始的数据，因为在通常情况下 AOF 文件保存的数据集要比 RDB 文件保存的数据集<font color="red">更完整</font></li><li>RDB 的数据不实时，同时使用两者时服务器重启也只会找 AOF 文件。<font color="red">但是作者建议不要只使用 AOF</font>，因为 RDB 更适合用于备份数据库 (AOF 在不断变化不好备份)，<font color="red">留着 rdb 以防万一</font></li></ul><p>综上，<strong><font color="orange">推荐方式：RDB+AOF 混合方式</font></strong>，既能快速加载又能避免丢失过多的数据。配置方式：</p><ol><li>默认开启混合方式，对应配置文件中的 <code>aof-use-rdb-preamble</code> ，默认为 yes</li><li><font color="red">开启 AOF 持久化</font>，对应配置文件中的 <code>appendonly</code> 设置为 yes，默认为 no</li></ol><blockquote><p>此时，RDB 镜像做<font color="red">全量</font>持久化，AOF 做<font color="red">增量</font>持久化：</p><ul><li>先使用 RDB 进行快照存储</li><li>然后使用 AOF 持久化记录所有的写操作</li><li>当重写策略满足或手动触发重写的时候，将最新的数据存储为新的 RDB 记录。</li><li>这样的话，重启服务的时候会从 RDB 和 AOF 两部分恢复数据，既保证了数据完整性，又提高了恢复数据的性能。简单来说：混合持久化方式产生的文件一部分是 RDB 格式，一部分是 AOF 格式。<strong>----》<font color="red">AOF 包括了 RDB 头部 + AOF 混写</font></strong></li></ul><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230807011820642.png" alt="image-20230807011820642"></p></blockquote><h3 id="纯缓存模式"><a class="anchor" href="#纯缓存模式">#</a> 纯缓存模式</h3><blockquote><p>Redis 作为基于 key-value 的内存数据库，<strong>Redis 最主要的功能是用作缓存</strong>，而 Redis 持久化会消耗 Redis 的性能，因此可以<strong>同时关闭 RDB+AOF</strong>。</p></blockquote><p><strong><font color="cornflowerblue">禁用 RDB</font></strong>：</p><blockquote><p>此时仍然可以手动使用命令 <code>SAVE</code> 和 <code>BGSAVE</code> 生成 rdb 文件</p></blockquote><ul><li><p>命令： <code>res-cli config set save &quot;&quot;</code></p></li><li><p>修改配置文件：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230807012414863.png" alt="image-20230807012414863"></p></li></ul><p><strong><font color="cornflowerblue">禁用 AOF</font></strong>：</p><blockquote><p>此时仍然可以手动使用命令 <code>BGREWRITEAOF</code> 生成 aof 文件</p></blockquote><ul><li>命令： <code>res-cli config set appendonly no</code></li><li>修改配置文件：将 <code>redis.conf</code> 中 APPEND ONLY MODE 模块下的 <code>参数appendonly</code> 设置为 no</li></ul><h2 id="5-redis事务transactions"><a class="anchor" href="#5-redis事务transactions">#</a> 5、Redis 事务（Transactions）</h2><blockquote><p><strong>数据库事务</strong>：由一系列数据库操作组成的一个完整的逻辑过程，不可拆分。</p><blockquote><p>例如银行转帐，从原账户扣除金额，以及向目标账户添加金额，这两个数据库操作的总和，构成一个完整的逻辑过程，不可拆分。</p></blockquote><p>具有<strong> ACID</strong> 特性：</p><ul><li>原子性（ <code>a</code> tomicity）<ul><li>一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。</li><li>事务在执行过程中发生错误，会被恢复（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。</li></ul></li><li>一致性（ <code>c</code> onsistency）<ul><li>在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。</li></ul></li><li>隔离性（ <code>i</code> solation）<ul><li>数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以<font color="red">防止多个事务并发执行时由于交叉执行而导致数据的不一致</font>。</li><li>事务隔离分为不同级别，包括：<ul><li>读未提交（Read uncommitted）</li><li>读已提交（read committed）</li><li>可重复读（repeatable read）</li><li>序列化（Serializable）</li></ul></li></ul></li><li>持久性（ <code>d</code> urability）<ul><li>事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</li></ul></li></ul></blockquote><h3 id="redis事务是什么"><a class="anchor" href="#redis事务是什么">#</a> Redis 事务是什么？</h3><p>Redis 事务允许<strong>在一个队列中，一次性、按顺序、排他地，执行多个命令</strong>，本质是一组命令的集合。一个事务中的所有命令都会序列化，<font color="red">按顺序地串行化执行，而不会被其它命令插入，不许加塞</font>。</p><p>Redis 事务以命令 <code>MULTI</code> 、 <code>EXEC</code> 、 <code>DISCARD</code> 和 <code>WATCH</code> 为中心，提供两个重要保证：</p><ul><li>事务中的所有命令都是<font color="red">按顺序序列化、执行</font>的。由另一个客户端发送的请求将永远不会在 Redis 事务的执行过程中提供服务。这保证了命令作为单个独立操作执行。</li><li><font color="red"><code>EXEC</code> 命令触发事务中所有命令的执行</font>，因此，如果客户端在调用 <code>EXEC</code> 命令之前在事务上下文中失去了与服务器的连接，则不会执行任何操作，相反，如果调用了 <code>EXEC</code> 命令，则会执行所有操作。当使用 AOF 时，Redis 确保使用单个 write（2）系统调用将事务写入磁盘。但是，如果 Redis 服务器崩溃或被系统管理员以某种艰难的方式终止，则可能只注册了部分操作。Redis 将在重新启动时检测到这种情况，并将退出并返回错误。使用 <code>redis check aof</code> 工具，可以修复将删除部分事务的 AOF 文件，以便服务器可以重新启动。</li></ul><p>从版本 2.2 开始，Redis 允许以<font color="red">乐观锁</font>的形式为上述两种操作提供额外的保证，其方式与 <code>check-and-set</code> （CAS）操作非常相似。稍后将对此进行记录。</p><h3 id="redis事务-vs-数据库事务"><a class="anchor" href="#redis事务-vs-数据库事务">#</a> Redis 事务 vs 数据库事务</h3><ol><li><p><strong>单独的隔离操作</strong>：Redis 的事务仅仅是保证事务里的操作会被连续独占的执行，redis 命令执行是单线程架构，<font color="red">在执行完事务内所有指令前是不可能再去同时执行其他客户端的请求</font>的</p></li><li><p><strong>没有隔离级别的概念</strong>：因为<font color="red">事务提交前任何指令都不会被实际执行</font>，也就不存在 “事务内的查询要看到事务里的更新，在事务外查询不能看到” 这种问题了</p><blockquote><p>因此不存在 “三大读问题”：不可重复读、脏读、幻读</p></blockquote></li><li><p><strong>不保证原子性</strong>：Redis 的事务 **<font color="red">不保证原子性</font>**，也就是不保证所有指令同时成功或同时失败，只有决定是否开始执行全部指令的能力，<font color="red">没有回滚能力</font></p></li><li><p><strong>排它性</strong>：Redis 会保证一个事务内的命令依次执行，而<font color="red">不会被其它命令插入</font></p></li></ol><h3 id="案例说明"><a class="anchor" href="#案例说明">#</a> 案例说明</h3><h4 id="常用命令-2"><a class="anchor" href="#常用命令-2">#</a> 常用命令</h4><table><thead><tr><th>命令</th><th>描述</th><th>返回值</th></tr></thead><tbody><tr><td><code>MULTI</code></td><td><font color="red">标记一个事务块的开始</font>。随后的一系列指令将在执行 <code>EXEC</code> 时作为一个原子执行。</td><td>OK</td></tr><tr><td><code>EXEC</code></td><td><font color="red">执行事务块中所有在排队等待的指令</font>，并将链接状态恢复到正常。<br>当使用 <code>WATCH</code> 时，只有当被监视的键没有被修改，且允许检查设定机制时， <code>EXEC</code> 会被执行。</td><td>每个元素与原子事务中的指令一一对应。<br>使用 <code>WATCH</code> 时，如果被终止， <code>EXEC</code> 则返回一个空的应答集合。</td></tr><tr><td><code>WATCH key [key ...]</code></td><td><font color="red">监视若干个 key</font>，如果在事务执行前这些 key 发生改动，那么事务将被打断。在事务中有条件的执行（<font color="red">乐观锁</font>）。</td><td>OK</td></tr><tr><td><code>UNWATCH</code></td><td><font color="red">释放所有被 <code>WATCH</code> 命令监视的 key</font><br>如果执行 <code>EXEC</code> 或者 <code>DISCARD</code> ， 则不需要手动执行该命令。</td><td>OK</td></tr><tr><td><code>DISCARD</code></td><td><font color="red">取消事务，放弃执行事务块中的所有指令</font>。<br>同时，<font color="red">释放所有被 <code>WATCH</code> 命令监视的 key</font>。</td><td>OK</td></tr></tbody></table><h4 id="redis事务中的错误"><a class="anchor" href="#redis事务中的错误">#</a> Redis 事务中的错误</h4><p>在 Redis 事务处理过程中，可能会遇到<font color="red">两种命令错误</font>：</p><ul><li><strong>命令可能无法排队</strong>，因此在调用 <code>EXEC</code> 之前可能会出现错误。例如，该命令可能在<font color="red">语法上错误</font>（参数数量错误、命令名称错误…），或者可能存在一些关键条件，如<font color="red">内存不足</font>（如果使用 maxmemory 指令将服务器配置为具有内存限制）。</li><li><strong>调用 <code>EXEC</code> 后，命令可能会失败</strong>。例如，因为我们<font color="red">对具有错误值的键执行了操作</font>（如对字符串值调用列表操作）。</li></ul><p>从 Redis 2.6.5 开始，服务器将在命令累积过程中<font color="red">检测到错误</font>。然后，它将<font color="red">拒绝执行在 <code>EXEC</code> 期间返回错误的事务，从而丢弃该事务</font>。</p><p>对于 Redis 事务中遇到的错误，有<font color="red">两种处理方式</font>，具体见 case3 和 case4。</p><h4 id="case1正常执行"><a class="anchor" href="#case1正常执行">#</a> case1：正常执行</h4><blockquote><p><code>MULTI</code> + 一系列 Redis 命令 + <code>EXEC</code></p></blockquote><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230807133026046.png" alt="image-20230807133026046"></p><h4 id="case2放弃事务"><a class="anchor" href="#case2放弃事务">#</a> case2：放弃事务</h4><blockquote><p><code>MULTI</code> + 一系列 Redis 命令 + <code>DISCARD</code></p></blockquote><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230807115127428.png" alt="image-20230807115127428"></p><h4 id="case3全体连坐"><a class="anchor" href="#case3全体连坐">#</a> case3：全体连坐</h4><blockquote><p>情况（<strong>编译时异常</strong>）：<font color="red">在 <code>EXEC</code> 命令执行前</font>，由于<u>语法错误</u>或者<u>内存不足</u>等原因，导致事务块中<font color="red">某条命令无法加入队列</font>。</p><p>解决方式：<strong><font color="red">EXECABORT</font></strong>，取消执行事务块中队列里的所有命令。</p></blockquote><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230807120332653.png" alt="image-20230807120332653"></p><h4 id="case4冤头债主"><a class="anchor" href="#case4冤头债主">#</a> case4：冤头债主</h4><blockquote><p>情况（<strong>运行时异常</strong>）：<font color="red">在 <code>EXEC</code> 命令执行后</font>，事务块中<font color="red">某条命令执行失败</font>。例如，因为我们<u>对具有错误值的键执行了操作</u>（如对字符串值调用列表操作）。</p><p>解决方式：<strong><font color="red">即使事务内一个命令失败，队列中的所有其他命令都会被执行</font></strong>。</p><p>补充：<font color="red">Redis 不提供事务回滚的功能</font>，在事务执行出错后，<font color="red">开发者必须自行恢复数据库状态</font>。</p></blockquote><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230807132520648.png" alt="image-20230807132520648"></p><h4 id="case5watch监控"><a class="anchor" href="#case5watch监控">#</a> case5：watch 监控</h4><blockquote><p><font color="cornflowerblue">悲观锁（Pessimistic Lock）</font>：顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以<strong>每次访问数据的时候都会上锁</strong>，这样别人想拿这个数据就会 block 直到它拿到锁。</p><p><font color="cornflowerblue">乐观锁（Optimistic Lock）</font>： 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以<strong>不会上锁，但是在更新数据时会判断一下在此期间别人有没有去更新这个数据</strong>。</p><blockquote><p>乐观锁策略：只有当 **<u>提交版本</u> 大于 <u>记录当前版本</u>**，才能执行数据更新。</p></blockquote><p><font color="cornflowerblue">CAS（Check-And-Set）</font></p></blockquote><h5 id="watch"><a class="anchor" href="#watch">#</a> watch</h5><p><code>watch</code> 命令是一种<strong>乐观锁</strong>的实现，Redis 在<font color="red">修改时会检测数据是否被更改，如果更改了，则执行失败</font>。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230807131835629.png" alt="image-20230807131835629"></p><blockquote><p>第一个窗口蓝色框第 5 步执行结果返回为 nil，也就是相当于是失败。</p></blockquote><p><code>WATCH</code> 命令用于为 Redis 事务提供一种<strong> CAS（check-and-set）行为</strong>。<br>被 <code>WATCH</code> 的 key 用来检测 key 的变化。如果在执行 <code>EXEC</code> 命令之前至少修改了一个被监视的 key，则整个事务将中止， <code>EXEC</code> 将返回一个 Null 回复以通知事务失败。</p><h5 id="unwatch"><a class="anchor" href="#unwatch">#</a> unwatch</h5><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230807132443762.png" alt="image-20230807132443762"></p><h5 id="小结"><a class="anchor" href="#小结">#</a> 小结</h5><ul><li><font color="red"><code>EXEC</code> 命令执行后</font>，会释放所有被 <code>WATCH</code> 命令监视的 key</li><li><font color="red">当客户端连接丢失的时候 (比如退出链接)</font>，会释放所有被 <code>WATCH</code> 命令监视的 key</li></ul><h3 id="总结"><a class="anchor" href="#总结">#</a> 总结</h3><p>Redis 事务分为三部分：</p><ul><li><strong>开启</strong>：以 <code>MULTI</code> 开始一个事务</li><li><strong>入队</strong>：将多个命令入队到事务中，接到这些命令并不会立即执行，而是放到等待执行的事务队列里面</li><li><strong>执行</strong>：由 <code>EXEC</code> 命令触发执行事务</li></ul><h2 id="6-redis管道pipeline"><a class="anchor" href="#6-redis管道pipeline">#</a> 6、Redis 管道（pipeline）</h2><blockquote><p>Redis 管道与 Redis 事务之间的关系，类似于雷锋与雷峰塔的关系，Java 与 JavaScript 的关系，看上去相似，但实际没有任何关系！</p></blockquote><h3 id="面试题"><a class="anchor" href="#面试题">#</a> 面试题</h3><p><strong>如何优化命令频繁往返造成的性能瓶颈？</strong></p><p>问题由来：</p><p>Redis 是一种基于<font color="red">客户端 - 服务端模型</font>以及请求 / 响应协议的 TCP 服务。一个请求会遵循以下步骤：</p><ol><li><p><font color="red">客户端向服务端发送命令</font>(分四步：发送命令→命令排队→命令执行→返回结果)，并监听 Socket 返回，通常<font color="red">以阻塞模式等待服务端响应</font>。</p></li><li><p><font color="red">服务端处理命令，并将结果返回给客户端</font>。</p></li></ol><p>上述两步的总耗时称为：<strong>Round Trip Time（即 RTT, 数据包往返于两端的时间)</strong>。</p><blockquote><p>如果同时需要执行大量的命令，那么就<font color="red">要等待上一条命令应答后再执行</font>，这中间不仅仅多了 RTT（Round Time Trip），而且还频繁调用系统 IO，发送网络请求，同时需要 redis 调用多次 read () 和 write () 系统方法，系统方法会将数据从用户态转移到内核态，这样就会对进程上下文有比较大的影响了，<font color="red">性能不太好</font>o(╥﹏╥)o</p></blockquote><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230807140057973.png" alt="image-20230807140057973"></p><h3 id="简介-5"><a class="anchor" href="#简介-5">#</a> 简介</h3><blockquote><p>通过<font color="red">批处理 Redis 命令</font>来<font color="red">优化往返时间 RTT</font></p></blockquote><p><strong>Redis 管道 (pipeline)</strong>：为了优化 RTT 往返时间，可以<font color="orange">一次性打包发送多条命令</font>给服务端，而<font color="red">无需等待对每个命令的响应</font>。服务端依次处理完完毕后，<font color="red">通过一条响应一次性将结果返回</font>，通过减少客户端与 redis 的通信次数来实现降低往返延时时间。pipeline 的<font color="orange">实现原理是队列</font>，先进先出特性就保证数据的顺序性。</p><blockquote><p>是<strong>一种批处理命令的变种优化措施</strong>，类似 Redis 原生的批命令（例如 mget 和 mset）。</p></blockquote><h3 id="案例"><a class="anchor" href="#案例">#</a> 案例</h3><ol><li>将欲执行的命令全部写到一个 txt 文件中</li><li>将 txt 文件的内容传递给 Redis 的 pipe 参数</li></ol><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230807140935362.png" alt="image-20230807140935362"></p><h3 id="总结-2"><a class="anchor" href="#总结-2">#</a> 总结</h3><h4 id="管道-vs-原生批量命令"><a class="anchor" href="#管道-vs-原生批量命令">#</a> 管道 vs 原生批量命令</h4><table><thead><tr><th>原生批量命令</th><th>管道</th></tr></thead><tbody><tr><td>原子性</td><td><font color="red">非原子性</font></td></tr><tr><td>一次只能执行一种命令</td><td>支持批量执行不同命令</td></tr><tr><td>服务端实现</td><td>服务端与客户端共同完成</td></tr></tbody></table><h4 id="管道-vs-事务"><a class="anchor" href="#管道-vs-事务">#</a> 管道 vs 事务</h4><table><thead><tr><th>事务</th><th>管道</th></tr></thead><tbody><tr><td><font color="red">不保证原子性</font></td><td>非原子性</td></tr><tr><td>逐条发送命令</td><td>一次性发送多条命令</td></tr><tr><td>会阻塞其他命令的执行</td><td><font color="red">非阻塞</font></td></tr></tbody></table><h4 id="使用管道的注意事项"><a class="anchor" href="#使用管道的注意事项">#</a> 使用管道的注意事项</h4><ul><li><p>pipeline 缓冲的指令只是会依次执行，<font color="red">不保证原子性，如果执行中指令发生异常，将会继续执行后续的指令</font></p><blockquote><p>与 Redis 事务发生命令的运行时异常类似，冤头债主，不会连坐</p></blockquote></li><li><p>使用 pipeline 组装的<font color="red">命令个数不能太多</font>（例如 10k），不然数据量过大客户端阻塞的时间可能过久，同时<font color="red">服务端此时也被迫回复一个队列答复，占用很多内存</font></p></li></ul><h2 id="7-redis发布订阅pubsub"><a class="anchor" href="#7-redis发布订阅pubsub">#</a> 7、Redis 发布订阅（pub/sub）</h2><blockquote><p>这是 Redis 的第一代消息中间件，第二代是 Stream，然而<strong>一般使用的都是更加成熟的第三方消息中间件</strong>。</p><p><strong>了解即可</strong>，实际工作中用的很少，一般都是将 Redis 用作<strong>分布式缓存</strong>。</p></blockquote><h3 id="简介-6"><a class="anchor" href="#简介-6">#</a> 简介</h3><p>Redis 发布订阅（pub/sub）是一种消息通信模式：<font color="red">发送者 (PUBLISH) 发送消息，订阅者 (SUBSCRIBE) 接收消息</font>，可以实现进程间的消息传递。</p><p>一言蔽之：Redis 可以通过发布订阅实现消息的引导和分流，实现消息中间件 MQ 的功能。但是<font color="red">不推荐使用</font>该功能，专业的事情交给专业的中间件处理，redis 就做好分布式缓存功能。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230807173639960.png" alt="image-20230807173639960"></p><center>Redis客户端可以订阅任意数量的频道，类似微信关注多个公众号</center><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230807173711847.png" alt="image-20230807173711847"></p><center>当有新消息通过PUBLISH命令发送给频道时</center><p>小结：发布 / 订阅其实是<strong>一个轻量的队列</strong>，只不过<strong>数据不会被持久化</strong>，一般<strong>用来处理实时性较高的异步消息</strong>。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230807173943443.png" alt="image-20230807173943443"></p><h3 id="常用命令-3"><a class="anchor" href="#常用命令-3">#</a> 常用命令</h3><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230807174014734.png" alt="image-20230807174014734"><h3 id="缺点"><a class="anchor" href="#缺点">#</a> 缺点</h3><ul><li><p>发布的消息在 Redis 系统中<strong>不能持久化</strong>，因此，必须先执行订阅，再等待消息发布。如果先发布了消息，那么该消息由于没有订阅者，消息将被直接丢弃</p></li><li><p>消息只管发送对于发布者而言消息是即发即失的，不管接收，也<strong>没有 ACK 机制</strong>，无法保证消息的消费成功。</p></li><li><p>以上的缺点导致<strong> Redis 的 Pub/Sub 模式就像个小玩具</strong>，在生产环境中几乎无用武之地。</p><blockquote><p>为此 Redis5.0 版本新增了 Stream 数据结构，不但支持多播，还支持数据持久化，相比 Pub/Sub 更加的强大，但是也不推荐使用。</p></blockquote></li></ul><h2 id="8-redis主从复制replica"><a class="anchor" href="#8-redis主从复制replica">#</a> 8、Redis 主从复制（replica）</h2><blockquote><p>承上启下的一章，前文都是在单机场景下，从此开始介绍 Redis 多台机器的场景，即<strong>通过主从复制支持多可用性和故障切换</strong>。</p></blockquote><h3 id="简介-7"><a class="anchor" href="#简介-7">#</a> 简介</h3><p>Redis 数据库的主从复制，其中<strong> master 数据库以写为主，slave 数据库以读为主</strong>。</p><blockquote><p>当 master 数据库上的数据变化时，会自动将新的数据以<font color="red">异步</font>的方式同步到其他 slave 数据库上。</p></blockquote><p>Redis 主从复制（replica）的功能如下：</p><ul><li><strong>读写分离</strong></li><li><strong>容灾恢复</strong></li><li><strong>数据备份</strong></li><li><strong>水平扩容支撑高并发</strong></li></ul><p>配置方法：<strong>配从不配主</strong></p><ul><li><p>master 如果配置了 <code>requirepass</code> 参数，需要密码登陆</p></li><li><p>那么 slave 就要配置 <code>masterauth</code> 来设置校验密码，否则 master 会拒绝 slave 的访问请求</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230807183910365.png" alt="image-20230807183910365"></p></li></ul><h3 id="基本命令"><a class="anchor" href="#基本命令">#</a> 基本命令</h3><ul><li><p><strong><code>INFO replication</code> </strong>：以一种易于理解和阅读的格式，返回关于当前 Redis 服务器的<strong>直接主 / 从</strong>复制信息</p></li><li><p><strong><code>REPLICAOF masterIp masterPort</code> </strong>：在线修改当前 Redis 服务器的主 / 从复制设置（自动配置）</p><blockquote><p>一般写入进 redis.conf 配置文件内</p></blockquote></li><li><p><strong><code>SLAVEOF masterIp masterPort</code> </strong>：将当前 Redis 服务器转变为指定服务器的从属服务器（手动配置）</p><ul><li>每次与 master 断开之后，都需要<font color="red">重新连接</font>，除非你配置进 redis.conf 文件</li><li>在运行期间修改 slave 节点的信息，如果该数据库已经是某个主数据库的从数据库，那么会停止和原主数据库的同步关系转而和新的主数据库同步，<font color="red">改换门庭</font></li></ul></li><li><p><strong><code>SLAVEOF NO ONE</code> </strong>：将使得这个从属服务器关闭复制功能，并从从属服务器<font color="red">转回主服务器，自立为王</font>，同时原来同步所得的数据集不会被丢弃。</p></li></ul><h3 id="案例演示"><a class="anchor" href="#案例演示">#</a> 案例演示</h3><h4 id="架构说明"><a class="anchor" href="#架构说明">#</a> 架构说明</h4><p>一主二从，一个 master，两个 slave，示意图如下：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230807185141276.png" alt="image-20230807185141276"></p><p>拷贝多份配置文件，分别命名为：</p><ul><li>redis6379.conf</li><li>redis6380.conf</li><li>redis6381.conf</li></ul><h4 id="口诀"><a class="anchor" href="#口诀">#</a> <mark>口诀</mark></h4><blockquote><p>面试重点</p></blockquote><p>前提：三边网络互相 ping 通，同时注意防火墙配置。</p><p>三大命令：</p><ul><li>主从复制： <code>REPLICAOF masterIp masterPort</code> ，配从不配主</li><li>改换门庭： <code>SLAVEOF masterIp masterPort</code></li><li>自立为王： <code>SLAVEOF NO ONE</code></li></ul><h4 id="修改配置文件的操作细节"><a class="anchor" href="#修改配置文件的操作细节">#</a> 修改配置文件的操作细节</h4><p>以 redis6379.conf 为例，步骤如下：</p><ol><li><p>要求 Redis 后台运行，不要弹出命令行窗口： <code>daemonize yes</code></p></li><li><p>取消 IP 的绑定，否则影响远程 IP 连接，注释掉 <code>bind 127.0.0.1</code></p></li><li><p>关闭保护模式，否则影响远程访问 / 连接： <code>protected-mode no</code></p></li><li><p>指定端口： <code>port 6379</code></p></li><li><p>指定当前工作目录， <code>dir /myredis</code></p></li><li><p>设置 pid（进程 id）文件的路径和名字： <code>pidfile /var/run/redis_6379.pid</code></p></li><li><p>设置 log 文件的路径和名字： <code>logfile &quot;/myredis/6379.log&quot;</code></p></li><li><p><font color="red">设置 Redis 服务器的密码</font>： <code>requirepass 111111</code></p><blockquote><p>master、slave 均配置</p></blockquote></li><li><p>设置 rdb 文件的名称： <code>dbfilename dump6379.rdb</code></p></li><li><p>若开启 AOF，还需设置 aof 文件的名字：appendfilename 。这里不开启了。</p></li><li><p><font color="red">slaveslave 设置所访问的 mastermaster 的 IP 和端口： <code>replicaof masterIp 6379</code> ，并设置通行密码 <code>masterauth &quot;111111&quot;</code></font></p><blockquote><p>slave 需要配置</p></blockquote></li></ol><h4 id="常用的3招"><a class="anchor" href="#常用的3招">#</a> 常用的 3 招</h4><h5 id="一主二从"><a class="anchor" href="#一主二从">#</a> 一主二从</h5><blockquote><p>1 个 master，2 个 slave</p></blockquote><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230807201752116.png" alt="image-20230807201752116"></p><h6 id="方案1配置文件固定写死"><a class="anchor" href="#方案1配置文件固定写死">#</a> 方案 1：配置文件固定写死</h6><ol><li><p>配从（6380 和 6381）不配主</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230807193239828.png" alt="image-20230807193239828"></p></li><li><p>依次启动 master 和两台 slave</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230807193418057.png" alt="image-20230807193418057"></p></li><li><p>查看主从关系</p><ol><li><p>通过日志文件：通过 <code>vim 6379.log</code> 查看 master 日志，通过 <code>vim 6380/6381.log</code> 查看 slave 日志</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230807193701621.png" alt="image-20230807193701621"></p><center>master日志</center><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230807193733743.png" alt="image-20230807193733743"></p><center>slave日志</center></li><li><p>通过命令： <code>info relication</code></p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230807193843707.png" alt="image-20230807193843707"></p><center>master的主从复制信息</center><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230807193915854.png" alt="image-20230807193915854"></p><center>slave的主从复制信息</center></li></ol></li></ol><h6 id="主从复制问题演示"><a class="anchor" href="#主从复制问题演示">#</a> 主从复制问题演示</h6><ul><li><p>问题 1：<strong>slave 不能执行写命令！</strong></p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230807194936720.png" alt="image-20230807194936720"></p></li><li><p>问题 2：slave 切入点问题。当某台 slave shutdown 并重启后，<strong>slave 对 master 首次进行全量复制，然后进行增量复制</strong>。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230807194924560.png" alt="image-20230807194924560"></p></li><li><p>问题 3：master shutdown 后，slave 原地待命，数据仍可以正常使用，<strong>slave 等待 master 重启归来</strong>！</p></li><li><p>问题 4：shutdown 后的<strong> master 重启归来，主从关系还在！slave 还能顺利复制！</strong></p></li></ul><h6 id="方案2命令操作手动指定"><a class="anchor" href="#方案2命令操作手动指定">#</a> 方案 2：命令操作手动指定</h6><ol><li><p>slave 停机并去掉配置项，清空主从关系。此时 3 机都是 master，互不从属。</p></li><li><p>在预设的 2 个 slave 上执行命令 <code>SLAVEOF masterIp masterHost</code> 指定 master</p></li></ol><p>这种情况下，<strong>若 slave shutdown 并重启，主从关系就不存在了（因为没有设置配置文件）！</strong></p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230807200155294.png" alt="image-20230807200155294"></p><h6 id="配置-vs-命令"><a class="anchor" href="#配置-vs-命令">#</a> 配置 vs 命令</h6><p><strong>配置（即方案 1）持久稳定，命令（即方案 2）临时生效</strong>。</p><h5 id="薪火相传"><a class="anchor" href="#薪火相传">#</a> 薪火相传</h5><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230807202217260.png" alt="image-20230807202217260"></p><p>要点：</p><ul><li>slave（6380）也可以作为 master（6379），接收其他 slave（6381）的连接和同步请求，可以<strong>有效减轻主 master 的写压力</strong>。</li><li>改变 master 的命令： <code>SLAVEOF newMasterIp newMasterPort</code></li><li><strong>slave（6380）仍然无法执行写命令！</strong></li><li>slave（6381）中途变更转向，master 从 6379 变为 6380，<strong>会清除之前 master（6379）的数据，重新建立拷贝新的 master（6380）的数据</strong>。</li></ul><h5 id="自立为王"><a class="anchor" href="#自立为王">#</a> 自立为王</h5><blockquote><p>slave 转成 master</p></blockquote><p>命令 <code>SLAVEOF NO ONE</code> ：<strong>停止与其他数据库的同步，清空数据，转成主数据库</strong>。</p><h3 id="主从复制的原理-工作流程"><a class="anchor" href="#主从复制的原理-工作流程">#</a> <mark>主从复制的原理、工作流程</mark></h3><blockquote><p>面试重点</p></blockquote><ol><li><p><strong><font color="black">slave 首次连接，请求完全同步</font></strong>：slave<font color="red">首次连接</font>master 后会发送一个 <code>sync</code> 命令，<font color="red">请求完全同步（全量复制）</font></p><blockquote><p>执行一次完全同步（<font color="red">全量复制</font>），slave 自身原有数据会被<font color="red">覆盖清除</font></p></blockquote></li><li><p><strong><font color="black">master 保存快照、缓存写命令，响应给 slave 进行初始化</font></strong>：</p><ul><li>master 节点收到 <code>sync</code> 命令后会开始在后台<font color="red">保存快照</font>(即 RDB 持久化，主从复制时会触发 RDB)，同时<font color="red">缓存所有接收到的写命令</font>，master 节点执行 RDB 持久化完后，<font color="red">master 将 rdb 快照文件和所有缓存的写命令发送到所有 slave</font>，以完成一次完全同步</li><li>而 slave 服务在接收到数据库文件数据后，将其<font color="red">存盘并加载到内存中</font>，从而<font color="red">完成复制初始化</font></li></ul></li><li><p><strong><font color="black">心跳持续，保持通信</font></strong>：master 向 slave 发出 PING 包的周期，默认是 10 秒。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230807205137957.png" alt="image-20230807205137957"></p></li><li><p><strong><font color="black">进入平稳，增量复制</font></strong>：master 继续将新的所有收集到的写命令自动依次传给 slave，完成同步</p></li><li><p><strong><font color="b">slave 下线，重连续传</font></strong>：假设某台 slave 宕机并重启了，master 会检查 backlog 里面的 <code>offset</code> ，master 和 slave 都会保存一个复制的 <code>offset</code> 和一个 masterId， <code>offset</code> 是保存在 backlog 中的。<font color="red">master 只会把已经复制的 <code>offset</code> 后面的数据复制给 slave</font>，类似<strong>断点续传</strong>。</p></li></ol><h3 id="主从复制的缺点"><a class="anchor" href="#主从复制的缺点">#</a> <mark>主从复制的缺点</mark></h3><blockquote><p>面试重点</p></blockquote><ul><li><p><strong>复制延时，信号衰减</strong></p><blockquote><p>由于所有的写操作都是先在 Master 上操作，然后同步更新到 Slave 上，所以从 Master 同步到 Slave 机器有一定的延迟，当<font color="red">系统很繁忙</font>的时候，延迟问题会更加严重，<font color="red">Slave 机器数量的增加</font>也会使这个问题更加严重。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230807210259342.png" alt="image-20230807210259342"></p></blockquote></li><li><p><font color="red">**master 挂了咋办？** 默认情况下，不会从 slave 中重选一个 master，岂不是群龙无首？系统会陷入半瘫痪状态（只能读取，不能写入）</font>那客户端的写命令如何执行啊？</p><blockquote><p>期待有一种高可用的备份、恢复机制，能够从剩下的 slave 中选出一个 master！（<strong><font color="red">无人值守安装：哨兵！</font></strong>）</p></blockquote></li></ul><h2 id="9-redis哨兵sentinel"><a class="anchor" href="#9-redis哨兵sentinel">#</a> 9、Redis 哨兵（sentinel）</h2><blockquote><p>Redis 为了支持高可用，有 2 套机制：</p><ul><li>主从复制（replica）+ 哨兵（sentinel）</li><li>集群（cluster）</li></ul></blockquote><h3 id="简介-8"><a class="anchor" href="#简介-8">#</a> 简介</h3><p>哨兵（sentinel）巡查监控后台 master 是否故障，如果故障了根据 **<font color="orange">投票数</font>** 自动将某一个 slave 转换为新 master，继续对外服务。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230808215652689.png" alt="image-20230808215652689"></p><p>哨兵的作用：</p><ul><li><p><strong>主从监控</strong>：哨兵能监控主从 Redis 库是否正常运行</p></li><li><p><strong>故障转移</strong>：如果 master 异常，哨兵会将根据投票数将某个 slave 转为新的 master，即主从切换</p></li><li><p><strong>消息通知</strong>：哨兵可将故障转移的结果发送给客户端</p></li><li><p><strong>配置中心</strong>：客户端通过连接哨兵来获得当前 Redis 服务的 master 地址</p></li></ul><h3 id="案例演示-2"><a class="anchor" href="#案例演示-2">#</a> 案例演示</h3><h4 id="架构说明-2"><a class="anchor" href="#架构说明-2">#</a> 架构说明</h4><p>3 个哨兵：自动监控和维护集群，不存放数据</p><blockquote><p>哨兵必须要配置集群，且数量最好是奇数，方便投票。</p></blockquote><p>3 个 Redis 库（1 主 2 从）：用于数据读取和存放</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230808002037403.png" alt="image-20230808002037403"></p><h4 id="哨兵配置文件sentinelconf"><a class="anchor" href="#哨兵配置文件sentinelconf">#</a> 哨兵配置文件 ( <code>sentinel.conf</code> )</h4><blockquote><p>默认在 /opt/redis-7.0.0 目录下</p></blockquote><p>重点参数说明：</p><ul><li><p><code>bind</code> ：服务监听地址，用于客户端连接，默认为本机地址</p></li><li><p><code>daemonize</code> ：是否以后台 daemon（后台进程）方式运行，设为 yes</p></li><li><p><code>protected-mode</code> ：是否开启安全保护模式，设为 no，否则影响远程访问 / 连接</p></li><li><p><code>port</code> ：端口，默认是 26379</p></li><li><p><code>logfile</code> ：日志文件路径</p></li><li><p><code>pidfile</code> ：pid 文件路径</p></li><li><p><code>dir</code> ：工作目录</p></li><li><p><strong><code>sentinel monitor &lt;master-name&gt; &lt;master-ip&gt; &lt;master-port&gt; &lt;quorum&gt;</code> </strong>：设置哨兵要监控的 master</p><ul><li><p><code>quorum</code> ：<strong>确认<font color="cornflowerblue">客观下线</font>的最少哨兵数量</strong>，同意故障迁移的法定<strong>投票数</strong>。</p><blockquote><p>sentinel 通过<strong>定时向 master 发出 PING 包</strong>来确认 master 是否挂掉。</p><p>但网络是不可靠的，有时某个 sentinel 可能因为<strong>网络拥堵</strong>没收到 master 的响应，从而<strong>误以为 master 已挂掉</strong>。因此需要多个 sentinel 都一致任务 master 已挂，才可进行主从切换、故障转移，保证了公平性和高可用。</p></blockquote></li></ul></li><li><p><code>sentinel auth-pass &lt;master-name&gt; &lt;password&gt;</code> ：设置连接 master 服务器的密码</p></li><li><p><strong><code>sentinel down-after-milliseconds &lt;master-name&gt; &lt;milliseconds&gt;</code> </strong>：指定如果 master 在多少毫秒之后没有应答 sentinel，sentinel 则主观上认为 master 下线（<strong><font color="cornflowerblue">主观下线</font></strong>）</p></li><li><p><code>sentinel parallel-syncs &lt;master-name&gt; &lt;nums&gt;</code> ：表示允许并行同步的 slave 个数，当 master 挂了后，哨兵会选出新的 master，此时，剩余的 slave 会向新的 master 发起同步数据</p></li><li><p><code>sentinel failover-timeout &lt;master-name&gt; &lt;milliseconds&gt;</code> ：故障转移的超时时间，进行故障转移时，如果超过设置的毫秒，表示故障转移失败</p></li><li><p><code>sentinel notification-script &lt;master-name&gt; &lt;script-path&gt;</code> ：配置当某一事件发生时所需要执行的脚本</p></li><li><p><code>sentinel client-reconfig-script &lt;master-name&gt; &lt;script-path&gt;</code> ：客户端重新配置 master 参数脚本</p></li></ul><h4 id="本次案例中sentinelconf的通用配置"><a class="anchor" href="#本次案例中sentinelconf的通用配置">#</a> 本次案例中 sentinel.conf 的通用配置</h4><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230808105627695.png" alt="image-20230808105627695"></p><p>由于机器硬件关系，我们的 3 个哨兵都同时配置进 192.168.111.169 同一台机器，即<font color="red">3 个哨兵和 master 在一台机器上</font>。</p><p>配置这 3 个哨兵的配置文件：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230808104641977.png" alt="image-20230808104641977"></p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230808104655030.png" alt="image-20230808104655030"></p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230808104707250.png" alt="image-20230808104707250"></p><p>master 配置文件说明：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230808104812771.png" alt="image-20230808104812771"></p><h4 id="先测试正常的主从复制一主二从"><a class="anchor" href="#先测试正常的主从复制一主二从">#</a> 先测试正常的主从复制（一主二从）</h4><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230807201752116.png" alt="image-20230807201752116"></p><ol><li>169 机器上新建 redis6379.conf 配置文件，由于 6379 后续可能会变成从机，需要设置访问新主机的密码， 请设置 masterauth 项访问密码为 111111，不然后续可能报错 master_link_status:down</li><li>172 机器上新建 redis6380.conf 配置文件，设置好 <code>replicaof \&lt;masterip&gt; \&lt;masterport&gt;</code> ，以及 masterauth 项访问密码为 111111</li><li>173 机器上新建 redis6381.conf 配置文件，设置好 <code>replicaof \&lt;masterip&gt; \&lt;masterport&gt;</code> ，以及 masterauth 项访问密码为 111111</li><li>启动 3 台机器实例：<ol><li><code>redis-cli -a 111111 -p 6379</code></li><li><code>redis-cli -a 111111 -p 6380</code></li><li><code>redis-cli -a 111111 -p 6381</code></li></ol></li><li>测试</li></ol><h4 id="哨兵来了"><a class="anchor" href="#哨兵来了">#</a> 哨兵来了！</h4><blockquote><p>sentinel 之间通过 master 来获取：</p><ul><li>slave 信息</li><li>其他 sentinel 信息</li></ul><p>从而实现通信。</p></blockquote><ol><li><p>在 master（6379）这台机器上<font color="red">启动 3 个 sentinel</font>（26379/26380/26381），完成监控</p><ol><li><code>redis-sentinel sentinel26379.conf --sentinel</code></li><li><code>redis-sentinel sentinel26380.conf --sentinel</code></li><li><code>redis-sentinel sentinel26381.conf --sentinel</code></li></ol><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230808110202022.png" alt="image-20230808110202022"></p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230808110255818.png" alt="image-20230808110255818"></p></li><li><p>查看哨兵的日志文件 <code>sentinel26379.log</code> ，可以看到<font color="red">当前 sentinel 的信息</font>、<font color="red">所监控 master 以及 slave 的信息</font>、<font color="red">其他 sentinel 的信息</font>：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230808111127304.png" alt="image-20230808111127304"></p></li><li><p>再测试一次主从复制，木有问题</p></li></ol><h4 id="master挂了"><a class="anchor" href="#master挂了">#</a> master 挂了！</h4><p>通过命令 <code>SHUTDOWN</code> 手动关闭 6379 服务器，模拟 master 挂掉。</p><p>思考以下问题：</p><ul><li><p>问题 1：<font color="red">两台 slave 上的数据还 OK！</font></p></li><li><p>问题 2：** 会从这两台 slave 上选出新的 master！** 具体信息可查看 sentinel 的 log 文件。</p><blockquote><p>在此过程中，哨兵配置文件 <code>sentinel.conf</code> 中会自动生成内容信息</p></blockquote></li><li><p>问题 3：<strong>down 机的旧 master 重启归来，也只能拜认新 master，作它的 slave！</strong></p></li></ul><p>在 master6379 宕机后，会出现两种错误：</p><ul><li><p>Error：Server closed the connection</p></li><li><p>Error：Broken pipe</p><blockquote><p><strong>broken pipe</strong>：pipe 是管道的意思，管道里面是数据流，通常是从文件或网络套接字读取的数据。<font color="red">当该管道从另一端突然关闭时，会发生数据突然中断</font>，即是 broken，对于 socket 来说，可能是网络被拔出或另一端的进程崩溃。</p><p><strong>如何解决</strong>：当该异常产生的时候，<font color="red">对于服务端来说，并没有多少影响</font>。因为可能是某个客户端突然中止了进程导致了该错误。</p><p><strong>总结</strong>：这个异常是<font color="red">客户端读取超时</font>关闭了连接，这时候服务器端再向客户端已经断开的连接写数据时就发生了 broken pipe 异常！</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230808113740061.png" alt="image-20230808113740061"></p></blockquote></li></ul><p>针对本次案例，分析谁是 master：</p><ol><li>6381 被选为新 master，上位成功</li><li>以前的 6379 从 master 降级变成了 slave</li><li>6380 还是 slave，只不过换了个新老大 6381 (6379 变 6381)，6380 还是 slave</li></ol><h4 id="对比新老master的配置文件"><a class="anchor" href="#对比新老master的配置文件">#</a> 对比新老 master 的配置文件</h4><p>旧 master <code>redis6379.conf</code> 中会自动生成以下内容，让 6379 去做 6381 的 slave：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230808115231877.png" alt="image-20230808115231877"></p><p>新 master <code>redis6381.conf</code> 中：</p><ul><li>自动删掉 <code>replicaof</code> 参数的配置</li><li>自动生成以下内容：</li></ul><p>结论：</p><ul><li>conf 文件的内容会被 sentinel 动态更改</li><li>Master-Slave 切换后，master_redis.conf、slave_redis.conf 和 sentinel.conf 的内容都会发生改变，即<font color="red">master_redis.conf 中会多一行 slaveof 的配置</font>，<font color="red">sentinel.conf 的监控目标会随之调换</font></li></ul><h4 id="其他备注"><a class="anchor" href="#其他备注">#</a> 其他备注</h4><ul><li>生产都是不同机房不同服务器，<strong>很少出现哨兵全挂掉的情况</strong></li><li><strong>可以同时监控多个 master</strong>，一行一个</li></ul><h3 id="哨兵运行流程-选举原理"><a class="anchor" href="#哨兵运行流程-选举原理">#</a> <mark>哨兵运行流程、选举原理</mark></h3><blockquote><p>面试重点</p></blockquote><p>当一个主从配置中的 master 失效之后，sentinel 可以从 slave 中选举出一个新的 master，用于接替原 master 的工作。</p><p>主从配置中的<font color="red">其他 redis 服务器自动指向新的 master 同步数据</font>。</p><p>一般<font color="red">建议 sentinel 采取奇数台</font>，一是防止某一台 sentinel 无法连接到 master 导致误切换，二是利于投票选举。</p><p>故障切换的流程：</p><ol><li><p>3 个 sentinel 监控一 master 二 slave，正常运行中</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230808161905591.png" alt="image-20230808161905591"></p></li><li><p><strong><font color="cornflowerblue">SDown 主观下线（Subjectively Down）</font></strong>：指的是<font color="red">单个 Sentinel 实例</font>对 master 服务器做出的下线判断（有可能是接收不到订阅，之间的网络不通等等原因）。如果 master 服务器在 [ <code>sentinel down-after-milliseconds</code> ] 给定的毫秒数之内没有回应 PING 命令或者返回一个错误消息，那么这个 Sentinel 会主观的 (<font color="red">单方面的</font>) 认为这个 master 不可以用了。</p><blockquote><p>sentinel 配置文件中的 <code>sentinel down-after-milliseconds &lt;masterName&gt; &lt;timeout&gt;</code> 设置了判断主观下线的时间长度，表示 master 被当前 sentinel 实例认定为失效的间隔时间。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230808162539926.png" alt="image-20230808162539926"></p></blockquote></li><li><p><strong><font color="cornflowerblue">ODown 客观下线（Objectively Down）</font></strong>：需要一定数量的 sentinel，<font color="red">多个哨兵达成一致意见</font>才能认为一个 master 客观上已经宕掉。</p><blockquote><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230808162827271.png" alt="image-20230808162827271"></p><ul><li><code>master-name</code> 是对某个 master+slave 组合的一个区分标识 (一套 sentinel 可以监听多组 master+slave 这样的组合)</li><li><strong><code>quorum</code> 这个参数是进行客观下线的一个依据</strong>，即法定人数 / 法定票数。意思是至少有 quorum 个 sentinel 认为这个 master 有故障才会对这个 master 进行下线以及故障转移。因为有的时候，某个 sentinel 节点可能因为自身网络原因导致无法连接 master，而此时 master 并没有出现故障，所以这就需要多个 sentinel 都一致认为该 master 有问题，才可以进行下一步操作，这就保证了公平性和高可用。</li></ul></blockquote></li><li><p>从哨兵中选出<strong>兵王</strong>：当 master 被判断 ODown 以后，各个 sentinel 节点会进行协商，先通过<font color="orange">Raft 算法</font>选举出一个兵王，<font color="red">由它进行 failover (故障迁移)</font>。</p><blockquote><p>监视该主节点的所有哨兵都有可能被选为领导者，选举使用的算法是 Raft 算法，其基本思路是 **<font color="red">先到先得</font>**：即在一轮选举中，哨兵 A 向 B 发送成为领导者的申请，如果 B 没有同意过其他哨兵，则会同意 A 成为领导者。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230808164314705.png" alt="image-20230808164314705"></p></blockquote><p>从三个 sentinel 实例的 log 文件中可以看见兵王的诞生过程以及兵王执行故障迁移的过程：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230808163922904.png" alt="image-20230808163922904"></p><center>sentinel26379.log</center><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230808163958440.png" alt="image-20230808163958440"></p><center><font color="red">sentinel26380.log</font></center><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230808164037410.png" alt="image-20230808164037410"></p><center>sentinel26381.log</center></li><li><p><strong><font color="orange">兵王开始故障切换，选举新的 master</font></strong>：</p><ol><li><p><strong>新主登基</strong>：**<font color="orange">新 master 选举算法</font>** 如下：</p><ol><li><p><font color="gree">优先级高</font>：所有 slave 中，根据 redis.conf 配置文件中的优先级 <code>slave-priority</code> 或者 <code>replica-priority</code> ，选择优先级最高的 slave 作为新 master。</p><blockquote><p>数字越小优先级越高</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230808170206385.png" alt="image-20230808170206385"></p></blockquote></li><li><p><font color="gree">复制偏移大</font>：所有 slave 中，根据复制偏移位置 <code>offset</code> ，该值最大的 slave 作为新 master。</p></li><li><p><font color="gree">Run ID 小</font>：所有 slave 中，选择 Run ID 最小的 slave 作为新 master，是按照字典顺序，ASCII 码。</p></li></ol><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230808165640759.png" alt="image-20230808165640759"></p></li><li><p><strong>群臣俯首</strong>：一朝天子一朝臣，换个码头重新拜</p><ol><li>Sentinel leader 会对选举出的 slave 执行 <code>SLAVEOF NO ONE</code> 命令，将其提拔为新 master</li><li>Sentinel leader 向其余 slave 发送 <code>SLAVEOF</code> 命令，使它们成为新 master 的 slave</li></ol></li><li><p><strong>旧主拜服</strong>：老 master 回来也认怂</p><ol><li>老 master 成为新 master 的 slave</li><li>Sentinel leader 会让老 master 降级为 slave，并恢复正常工作</li></ol></li></ol><p>总结：上述 failover（故障迁移）均由 sentinel 独自完成，无需人工干预，因此称之为<strong>无人值守安装</strong>！</p></li></ol><h3 id="哨兵使用建议"><a class="anchor" href="#哨兵使用建议">#</a> 哨兵使用建议</h3><ol><li><p><strong>哨兵的数量应为多个且奇数</strong>。哨兵本身应该集群，保证高可用。</p></li><li><p><strong>各个哨兵的配置应一致</strong>。</p></li><li><p>如果哨兵部署在 Docker 等容器里面，尤其要<font color="red">注意端口的正确映射</font>。</p></li><li><p><code>主从复制 + 哨兵</code> 机制<strong>并不能确保数据零丢失</strong>。因为从 master 挂掉到选举出新 master 的这段时间内，无法执行写命令！</p><blockquote><p>引出<strong>集群</strong></p></blockquote></li></ol><h2 id="10-redis集群cluster"><a class="anchor" href="#10-redis集群cluster">#</a> <mark>10、Redis 集群（cluster）</mark></h2><blockquote><p>我尼玛又白雪，<strong>集群才是 yyds！</strong></p></blockquote><h3 id="简介-9"><a class="anchor" href="#简介-9">#</a> 简介</h3><p><strong><font color="red">由于数据量过大</font></strong>，<font color="red">单个 Master 复制集</font>难以承担，因此需要对多个复制集进行集群，形成<font color="red">水平扩展</font>每个复制集<font color="red">只负责存储整个数据集的一部分</font>，这就是 Redis 的集群。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230808220609079.png" alt="image-20230808220609079"></p><p>总之，Redis 集群是<font color="red">一个提供在多个 Redis 节点间共享数据的程序集</font>。其功能总结如下：</p><ul><li><strong>支持多个 Master</strong>，每个 Master 又可以挂载多个 Slave。<ul><li>读写分离</li><li>支持数据的高可用</li><li>支持海量数据的读写存储操作</li></ul></li><li><strong>自带 failover（故障转移）机制</strong>，内置了高可用的支持，<font color="red">无需再去使用哨兵功能</font>。</li><li><strong>客户端只需连接集群中的任意一个可用 Master 节点即可</strong>，不需要连接集群中的所有 Master 节点。</li><li><strong>槽位 slot</strong> 负责分配到各个物理服务节点，由对应的集群来负责<strong>维护 Redis 节点、插槽、数据之间的关系</strong>。</li></ul><h3 id="集群算法-分片-槽位slot"><a class="anchor" href="#集群算法-分片-槽位slot">#</a> 集群算法、分片、槽位 slot</h3><h4 id="官网介绍"><a class="anchor" href="#官网介绍">#</a> 官网介绍</h4><p>Redis 集群的 key 空间被划分为<strong> 16384 个插槽 slot</strong>，有效地设置了 16384 个 master 节点的集群大小上限（然而，<strong>master 节点的最大数量建议为 1000</strong>）。</p><blockquote><p>插槽，也称哈希槽</p></blockquote><p>集群中的<font color="red">每个 master 节点处理 16384 个哈希槽的子集</font>。当没有正在进行的集群重新配置时（即哈希槽从一个节点移动到另一个节点），集群是稳定的。当集群稳定时，单个哈希槽将由单个节点提供服务（但是，服务节点可以有一个或多个副本，在网络分裂或故障的情况下，这些副本将替换它，并且可以用于扩展读取过时数据的读取操作）。</p><p>用于将 key 映射到哈希槽的基本算法如下（请阅读下一段以了解此规则的哈希标记异常）：</p><pre><code>HASH_SLOT = CRC16(key) mod 16384
</code></pre><h4 id="插槽"><a class="anchor" href="#插槽">#</a> 插槽</h4><p>Redis 集群没有使用一致性哈希算法，而是引入了 <code>hash槽</code> 的概念。<br>Redis 集群有 16384 个哈希槽，<strong>每个 key 通过 <code>CRC16</code> 校验后，再对 16384 取模来决定放置哪个槽</strong>。集群的<strong>每个 Redis 节点负责一部分 hash 槽</strong>。</p><p>举个例子，比如当前集群有 3 个节点，那么：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230809002715513.png" alt="image-20230809002715513"></p><h4 id="数据分片"><a class="anchor" href="#数据分片">#</a> 数据分片</h4><p><code>数据分片</code> ：Redis 集群中会<font color="red">将存储的数据分散到多台 redis 机器上</font>。每个 Redis 实例都被认为是整个数据的一个分片。</p><p><font color="gree">如何找到给定 key 的分片？</font></p><ol><li>对 key 进行<font color="red">CRC16(key)</font>算法处理，并通过对总分片数量<font color="red">取模</font>。</li><li>然后，使用<font color="red"><strong>确定性哈希函数</strong></font>，这意味着 **<font color="red">给定的 key 将始终映射到同一个分片</font>**，我们可以推断将来读取特定 key 的位置。</li></ol><h4 id="分片插槽的优点"><a class="anchor" href="#分片插槽的优点">#</a> 分片 + 插槽的优点</h4><ul><li><p><strong>方便 Redis 节点的扩容和缩容</strong>。</p><blockquote><ul><li>添加 Redis 节点：比如我想新添加个节点 D，我需要从节点 A，B，C 中移动部分槽到 D 上。</li><li>删除 Redis 节点：如果我想移除节点 A，需要将 A 中的槽移到 B 和 C 节点上，然后将没有任何槽的 A 节点从集群中移除即可。</li><li>由于从一个节点将哈希槽移动到另一个节点并不会停止服务，所以<strong>无论添加删除节点，或者改变某个节点的哈希槽的数量都<font color="red">不会造成集群不可用的状态</font></strong>。</li></ul></blockquote></li><li><p><strong>方便数据的分派和查找</strong>。</p></li></ul><h4 id="槽位映射的3种方案"><a class="anchor" href="#槽位映射的3种方案">#</a> 槽位映射的 3 种方案</h4><h5 id="哈希取余分区"><a class="anchor" href="#哈希取余分区">#</a> 哈希取余分区</h5><blockquote><p>小厂</p></blockquote><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230809004525207.png" alt="image-20230809004525207"></p><p>假设有 N 台机器构成一个集群，用户每次对 key 的读写操作都是根据公式：</p><pre><code>hash(key) % N
</code></pre><p>计算出哈希值，用来决定数据映射到哪一个节点上。</p><p><font color="gree">优点</font>：</p><ul><li>简单有效。只需要预估好数据规模，规划好节点，就能保证一段时间的数据支撑。</li><li>负载均衡。使用 Hash 算法让固定的一部分请求落到同一台服务器上，这样<font color="red">每台服务器固定处理一部分请求</font>（并维护这些请求的信息）。</li></ul><p><font color="gree">缺点</font>：</p><ul><li><strong>Redis 节点的扩容 / 缩容麻烦</strong>。如果需要弹性扩容或故障停机，导致节点有变动，映射关系需要重新进行计算。原来的取模公式就会发生变化： <code>Hash(key)/3</code> 会变成 <code>Hash(key) /?</code> 。此时地址经过取余运算的结果将发生很大变化，<font color="red">根据公式获取的服务器也会变得不可控</font>。</li><li>某个 Redis 机器宕机了，由于台数数量变化，会导致 hash 取余全部数据重新洗牌。</li></ul><h5 id="一致性哈希算法分区"><a class="anchor" href="#一致性哈希算法分区">#</a> 一致性哈希算法分区</h5><blockquote><p>一致性：意味着取余的分母是固定的。</p></blockquote><p><font color="gree">设计目标</font>：为了解决<font color="red">分布式缓存数据变动和映射问题</font>，某个机器宕机了，分母数量改变了，自然取余数不 OK 了。目的是<font color="red">当 Redis 服务器个数发生变动时，尽量减少客户端到服务器的映射关系的影响</font>。</p><p><strong><font color="gree">3 大步骤</font></strong>：</p><ol><li><p><strong>构建一致性哈希环</strong>：</p><p>一致性哈希算法必然有个 hash 函数用于产生 hash 值，这个算法的所有可能哈希值会构成一个<font color="red">全量集</font>，这个集合可以成为一个 **<font color="red">hash 空间 [0,2<sup>32</sup>-1]</font><strong>，这个是一个线性空间，但是在算法中，我们通过适当的逻辑控制将它</strong><font color="red">首尾相连 (0 = 2<sup>32</sup>)</font>**, 这样让它形成了一个<font color="red">逻辑上的环形空间</font>。</p><p>它也是按照使用取模的方法，<font color="red">前面介绍的是对 Redis 节点的数量进行取模</font>。而 **<font color="orange">一致性 Hash 算法是对 2<sup>32</sup> 取模</font>**。</p><p>简单来说，一致性 Hash 算法将整个哈希值空间组织成一个虚拟的圆环，如假设某哈希函数的值空间为 [0,2<sup>32</sup>-1]（即哈希值是一个 32 位无符号整形），整个哈希环如下图：整个空间按顺时针方向组织，圆环的正上方的点代表 0，0 点右侧的第一个点代表 1，以此类推，2、3、4、…… 直到 2<sup>32</sup>-1，也就是说<font color="red">0 点左侧的第一个点代表 2<sup>32</sup>-1</font>， 0 和 2<sup>32</sup>-1 在零点中方向重合，我们把这个 **<font color="red">由 2<sup>32</sup> 个点组成</font>** 的圆环称为 <code>Hash环</code> 。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230809010605612.png" alt="image-20230809010605612"></p></li><li><p><strong>Redis 服务器节点 IP 映射</strong>：</p><p>将集群中各个 Redis 节点的 IP 映射到环上的某一个位置。</p><p>将各个 Redis 服务器的 IP 或主机名作为关键字使用 Hash 进行哈希，这样每台机器就能确定其在哈希环上的位置。假如 4 个 Redis 节点 NodeA、NodeB、NodeC、NodeD，经过<font color="red">IP 地址的哈希函数计算 hash (ip)</font>，使用 IP 地址哈希后在环空间的位置如下：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230809114247849.png" alt="image-20230809114247849"></p></li><li><p><strong>落 key 规则</strong>：</p><p>当我们需要存储一个键值对时，<font color="red">首先计算 key 的 hash 值，hash (key)</font>，确定此数据在环上的位置，从此位置沿环 **<font color="red">顺时针</font>**“行走”，<font color="red">第一台遇到的 Redis 服务器</font>就是其应该定位到的服务器，并将该键值对存储在该节点上。</p><p>如我们有 Object A、Object B、Object C、Object D 四个数据对象，经过哈希计算后，在环空间上的位置如下：根据一致性 Hash 算法，Object A 会被定为到 Node A 上，Object B 被定为到 Node B 上，Object C 被定为到 Node C 上，Object D 被定为到 Node D 上。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230809114625589.png" alt="image-20230809114625589"></p></li></ol><p><font color="gree">优点</font>：</p><ul><li><p><strong>容错性</strong></p><blockquote><p>假设 Node C 宕机，可以看到此时对象 A、B、D 不会受到影响。一般的，在一致性 Hash 算法中，如果一台服务器不可用，则受影响的数据仅仅是此服务器到其环空间中前一台服务器（即沿着逆时针方向行走遇到的第一台服务器）之间数据，其它不会受到影响。<font color="red">简单说，就是 C 挂了，受到影响的只是 B、C 之间的数据，且这些数据会转移到 D 进行存储</font>。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230809115305990.png" alt="image-20230809115305990"></p></blockquote></li><li><p><strong>扩展性</strong></p><blockquote><p>随着数据量的增加，需要增加一台节点 NodeX，位置在 A 和 B 之间，<font color="red">那受到影响的也就是 A 到 X 之间的数据，重新把 A 到 X 的数据录入到 X 上即可，不会导致 hash 取余全部数据重新洗牌</font>。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230809120153493.png" alt="image-20230809120153493"></p></blockquote></li></ul><p><font color="gree">缺点</font>：<strong>数据倾斜</strong>问题</p><blockquote><p>在<strong> Redis 服务节点太少时</strong>，容易因为<font color="red">节点分布不均匀</font>而造成<strong>数据倾斜</strong>（被缓存的数据对象大部分集中缓存在某一台服务器上）问题。</p><p>例如系统中只有两台服务器：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230809120432504.png" alt="image-20230809120432504"></p></blockquote><p><font color="gree">小结</font>：</p><ul><li>设计目标：在 Redis 节点的数目发生改变时，尽可能地减少数据的迁移</li><li>设计思路：将所有的 Redis 节点排列在首尾相接的 Hash 环上，每个 key 在计算 Hash 后会<font color="red">顺时针</font>找到临近的 Redis 节点存放。而当有 Redis 节点加入或退出时仅影响该节点在 Hash 环上<font color="red">顺时针相邻的后续节点</font>。</li><li>优点：加入和删除节点只影响哈希环中顺时针方向的相邻的节点，对其他节点无影响。</li><li>缺点：数据的分布和节点的位置有关，因为这些节点不是均匀的分布在哈希环上的，所以数据在进行存储时达不到均匀分布的效果。</li></ul><h5 id="哈希槽分区"><a class="anchor" href="#哈希槽分区">#</a> 哈希槽分区 (√)</h5><blockquote><p>大厂</p></blockquote><p><font color="gree">为什么出现</font>：因为一致性哈希算法具有数据倾斜的问题。</p><p><font color="gree">哈希槽是什么</font>：哈希槽实质是<font color="red">一个数组</font>，<font color="red">哈希槽空间为 [0,2<sup>14</sup>-1]</font>。</p><blockquote><p>2<sup>14</sup>=16384</p></blockquote><p><font color="gree">能干嘛</font>：</p><p><strong>解决数据分配不均匀的问题</strong>，在数据和节点之间又加入了一层，把这层称为 <code>哈希槽（slot）</code> ，用于<font color="red">管理数据和节点之间的关系</font>，现在就相当于节点上放的是槽，槽里放的是数据。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230809130342790.png" alt="image-20230809130342790"></p><p>槽解决的是粒度问题，相当于<font color="red">把粒度变大了，这样便于数据移动</font>。</p><p>哈希解决的是映射问题，<font color="red">使用 key 的哈希值来计算所在的槽，便于数据分配</font>。</p><p><font color="gree">哈希槽的个数</font>：</p><p><strong>一个集群只能有 16384 个哈希槽</strong>，编号 0-16383（0-2<sup>14</sup>-1）。<font color="red">这些槽会分配给集群中的所有 master 节点</font>，分配策略没有要求。</p><p>集群会<font color="red">记录 Redis 节点和槽的对应关系</font>，解决了节点和槽的关系后，接下来就需要<font color="red">对 key 求哈希值，然后对 16384 取模</font>，余数是几 key 就落入对应的槽里。 <code>HASH_SLOT = CRC16(key) mod 16384</code> 。<font color="red">以槽为单位移动数据</font>，因为槽的数目是固定的，处理起来比较容易，这样数据移动问题就解决了。</p><p><font color="gree">哈希槽计算</font>：</p><p>Redis 集群中内置了 16384 个哈希槽，redis 会根据节点数量大致均等的将哈希槽映射到不同的节点。当需要在 Redis 集群中放置一个 key-value 时，redis 先对 key 使用 crc16 算法算出一个结果然后用结果对 16384 求余数 [ <code>CRC16(key) % 16384</code> ]，这样每个 key 都会对应一个编号在 0-16383 之间的哈希槽，也就是映射到某个节点上。</p><p>如下代码，key 之 A 、B 在 Node2， key 之 C 落在 Node3 上：</p><p><img data-src="C:%5CUsers%5Chuawei%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20230809131108267.png" alt="image-20230809131108267"></p><h4 id="经典面试题为什么redis集群的最大哈希槽数目是16384个"><a class="anchor" href="#经典面试题为什么redis集群的最大哈希槽数目是16384个">#</a> <mark>经典面试题：为什么 Redis 集群的最大哈希槽数目是 16384 个？</mark></h4><blockquote><p><font color="red"><strong>CRC16 算法产生的哈希值有 16bit</strong>，即 2<sup>16</sup>=65536 个值，为什么 Redis 集群的算法只采用 2<sup>14</sup>=16384 个哈希槽？</font>在进行 mode 运算时，为什么是 <code>HASH_SLOT = CRC16(key) mod 16384</code> 而不是 <code>HASH_SLOT = CRC16(key) mod 65536</code> ？</p></blockquote><p><font color="gree">作者的回复</font>：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230809132510614.png" alt="image-20230809132510614"></p><p><font color="gree">消息头 clusterMsg 的结构</font>：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230809132604570.png" alt="image-20230809132604570"></p><p><strong><font color="gree">标准回答</font></strong>：</p><ul><li><p><font color="red">如果槽位为 65536，发送心跳信息的消息头达 8k，<strong>发送的心跳包过于庞大</strong>。</font></p><blockquote><p>在消息头中最占空间的是 <code>myslots[CLUSTER_SLOTS/8]</code> :</p><ul><li>当槽位为 65536 时，这块的大小是: 65536÷8÷1024=<font color="red">8kb</font></li><li>当槽位为 16384 时，这块的大小是: 16384÷8÷1024=<font color="red">2kb</font></li></ul><p>因为每秒钟 redis 节点需要发送一定数量的 ping 消息作为心跳包，如果槽位为 65536，这个<font color="red">ping 消息的消息头太大了，浪费带宽</font>。</p></blockquote></li><li><p><font color="red">对于基本不可能超过 1000 个 master 节点数量的 redis 集群而言，<strong>16384 个槽位就已经够用了</strong>。</font></p><blockquote><p>集群的节点越多，心跳包的消息体内携带的数据越多。如果节点过 1000 个，也会导致网络拥堵。因此 redis 作者不建议 redis cluster 节点数量超过 1000 个。那么，<font color="red">对于节点数在 1000 以内的 redis cluster 集群，16384 个槽位够用了</font>。没有必要拓展到 65536 个。</p></blockquote></li><li><p><font color="red">槽位越小，节点少的情况下，<strong>压缩比高，容易传输</strong></font></p><blockquote><p>Redis 的 master 节点的配置信息中它所负责的哈希槽是通过一张 bitmap 的形式来保存的，在传输过程中会对 bitmap 进行压缩，但是<font color="red">如果 bitmap 的填充率 slots / N 很高的话 (N 表示节点数)，bitmap 的压缩率就很低</font>。如果节点数很少，而哈希槽数量很多的话，bitmap 的压缩率就很低。</p></blockquote></li></ul><h4 id="redis集群不保证强一致性"><a class="anchor" href="#redis集群不保证强一致性">#</a> Redis 集群不保证强一致性</h4><p><strong>Redis 集群不保证强一致性</strong>，这意味着在特定的条件下，Redis 集群<font color="red">可能会丢掉一些被系统收到的写入请求命令</font>。</p><p>Redis 集群使用<font color="red">节点之间的异步复制</font>，最后一次故障切换隐式合并功能。这意味着<font color="red">最后一次选择的主数据会完全替换所有其他副本</font>。在分区期间，<font color="red">总是有一个可能丢失写入的时间窗口</font>。然而，在连接到大多数主数据的客户端的情况下，这些窗口非常不同，以及与少数 master 有联系的客户。</p><h3 id="案例演示-3"><a class="anchor" href="#案例演示-3">#</a> 案例演示</h3><h4 id="3主3从redis集群配置"><a class="anchor" href="#3主3从redis集群配置">#</a> 3 主 3 从 redis 集群配置</h4><p>在 3 台虚拟机上新建 6 个独立的 Redis 实例服务，每台机器上一主一从，<font color="gree">设计图</font>如下：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/IMG_8445(20230809-135635).JPEG" alt="IMG_8445(20230809-135635)"></p><p>配置这 6 个 Redis 实例的<font color="gree">conf 文件</font>，下面以 6381 为例：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230809135942477.png" alt="image-20230809135942477"></p><p><font color="gree">启动</font>6 台 Redis 实例，以 6381 为例： <code>redis-server /myredis/cluster/redisCluster6381.conf</code> 。</p><p>构建 6 个 Redis 实例的<font color="gree">集群关系</font>，命令如下：</p><p><font color="red">redis-cli -a 111111<br><strong>--cluster create</strong> -<strong>-cluster-replicas 1</strong><br>192.168.111.175:6381 192.168.111.175:6382<br>192.168.111.172:6383 192.168.111.172:6384<br>192.168.111.174:6385 192.168.111.174:6386</font></p><blockquote><p><code>--cluster-replicas 1</code> 表示为每个 master 创建一个 slave 节点，<strong><font color="red">主从的实际分配是随机的！</font></strong></p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230809141622996.png" alt="image-20230809141622996"></p></blockquote><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230809141121945.png" alt="image-20230809141121945"></p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230809141157047.png" alt="image-20230809141157047"></p><p>启动 6381，查看 6381 的<font color="gree">主从复制信息</font> <code>info replication</code> ：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230809141652111.png" alt="image-20230809141652111"></p><p>查看 6381 的<font color="gree">集群信息</font> <code>cluster info</code> ：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230809141857437.png" alt="image-20230809141857437"></p><p>再查看集群的<font color="gree">节点信息</font> <code>cluster nodes</code> ：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230809141717499.png" alt="image-20230809141717499"></p><blockquote><p>slave 后跟着 master 信息，而 master 后没有 slave 信息。</p><p>目前的主从关系：</p><p>6381 的 slave 是 6384，6383 的 slave 是 6386，6385 的 slave 是 6382。</p></blockquote><h4 id="3主3从redis集群读写"><a class="anchor" href="#3主3从redis集群读写">#</a> 3 主 3 从 redis 集群读写</h4><p><code>redis-cli -a 111111 -p 6381</code> 启动 master 6381，并新增 2 个 key：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230809143452632.png" alt="image-20230809143452632"></p><blockquote><p>在设置 k1 时遇到报错，提示 k1 对应的哈希槽是 12706，应该存到 master 6385 上。因此，<strong><font color="red">要注意槽位的范围区间，需要将 key 路由到正确的槽位上</font></strong>。</p></blockquote><p><font color="gree">解决方法</font>：** 启动 Redis 实例时添加 <code>-c</code> 参数，表示以集群模式运行，防止路由失效。** 即 <code>redis-cli -a 111111 -p 6381 -c</code> 。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230809144237468.png" alt="image-20230809144237468"></p><blockquote><p>此时 key 会<font color="red">自动重定向</font>到对应 Redis 实例的哈希槽上。</p></blockquote><p><font color="gree">查看某个 key 对应的槽位置</font>： <code>CLUSTER KEYSLOT key</code> 。</p><h4 id="主从容错切换迁移failover"><a class="anchor" href="#主从容错切换迁移failover">#</a> 主从容错切换迁移 (failover)</h4><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230809144752893.png" alt="image-20230809144752893"></p><ol><li><p>假如 master 6381 宕机，其对应的 slave 6384 会上位成为新的 master</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230809145659230.png" alt="image-20230809145659230"></p></li><li><p>当 6381 重启恢复，自动成为 master 6384 的 slave</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230809145905827.png" alt="image-20230809145905827"></p></li></ol><h4 id="手动切换主从调整节点从属关系"><a class="anchor" href="#手动切换主从调整节点从属关系">#</a> 手动切换主从 / 调整节点从属关系</h4><p>上面一换后 6381、6384 主从对调了，和原始设计图不一样了，该如何恢复原来的主从关系？</p><p><strong>重启 6381，执行命令 <code>CLUSTER FAILOVER</code> ，自动调整 6381 的主从关系</strong>。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230809150634974.png" alt="image-20230809150634974"></p><h4 id="主从扩容"><a class="anchor" href="#主从扩容">#</a> 主从扩容</h4><blockquote><p>三主三从 -&gt; 四主四从</p><ol><li>新 master 加入集群</li><li>重新分配槽号（reshard）</li><li>为新 master 分配 slave</li></ol></blockquote><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230809151024511.png" alt="image-20230809151024511"></p><p>思考问题：</p><ul><li>如何将新机加入原有集群中？</li><li>新机的槽位如何分配？<strong>重新洗牌！</strong></li></ul><ol><li><p>配置 2 台新机的 redis.conf 文件，以 6387 为例：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230809151526914.png" alt="image-20230809151526914"></p></li><li><p>启动 2 台新机，此时它们都是 master：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230809151554375.png" alt="image-20230809151554375"></p></li><li><p>将新增的 6387（空槽号）作为<font color="gree">master 节点加入原有集群</font>，执行命令：</p><p><font color="orange">redis-cli -a 111111<br>--cluster <strong>add-node</strong><br>192.168.111.174:6387<br>192.168.111.175:6381</font></p><blockquote><ul><li><p>6387 就是将要作为<font color="red">master 新增节点</font></p></li><li><p>6381 就是原来集群节点里面的<font color="red">领路人</font>，相当于 6387 拜拜 6381 的码头从而找到组织加入集群</p></li></ul></blockquote><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230809152412183.png" alt="image-20230809152412183"></p></li><li><p>检查集群情况，执行命令：</p><p><font color="orange">redis-cli -a 111111<br>--cluster <strong>check</strong><br>192.168.111.175:6381</font></p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230809152820379.png" alt="image-20230809152820379"></p><blockquote><p>此时新加入的 6387 节点还没分配哈希槽</p></blockquote></li><li><p><font color="gree">重新分配槽号</font>，执行命令：</p><p><font color="orange">redis-cli -a 密码<br>--cluster <strong>reshard</strong><br>192.168.111.175:6381</font></p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230809153203484.png" alt="image-20230809153203484"></p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230809153429470.png" alt="image-20230809153429470"></p></li><li><p>再次检查集群情况，执行命令：</p><p><font color="orange">redis-cli -a 111111<br>--cluster <strong>check</strong><br>192.168.111.175:6381</font></p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230809153519681.png" alt="image-20230809153519681"></p><blockquote><p>此时槽号重新分派完成！但是为什么 6387 是 3 个新的区间，以前的还是连续？</p><p><strong>重新分配的成本太高，所以之前的 Redis 节点各自匀出来一部分给新节点</strong>。从 6381/6383/6385 三个旧节点分别匀出 1364 个坑位给新节点 6387。</p></blockquote></li><li><p>为 master 6387<font color="gree">分配 slave</font> 6388，执行命令：</p><p><font color="orange">redis-cli -a 密码<br>--cluster <strong>add-node</strong><br>ip: 新 slave 端口 ip: 新 master 端口<br><strong>--cluster-slave</strong> <strong>--cluster-master-id</strong> <strong>新 master 节点 ID</strong></font></p><blockquote><p>redis-cli -a 111111<br>--cluster add-node<br>192.168.111.174:6388 192.168.111.174:6387<br>--cluster-slave --cluster-master-id 4feb6a7ee0ed2b39ff86474cf4189ab2a554a40f</p></blockquote><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230809154138459.png" alt="image-20230809154138459"></p></li><li><p>第三次检查集群情况：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230809154202088.png" alt="image-20230809154202088"></p></li></ol><p>至此，完成 Redis 集群中的主从扩容：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230809154357068.png" alt="image-20230809154357068"></p><h4 id="主从缩容"><a class="anchor" href="#主从缩容">#</a> 主从缩容</h4><blockquote><p>四主四从 -&gt; 三主三从</p></blockquote><p>目的：让 6387、6388 下线</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230809160221198.png" alt="image-20230809160221198"></p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230809155155205.png" alt="image-20230809155155205"></p><ol><li><p>检查集群情况，获取 slave 6388 的节点 ID：</p><p><font color="orange">redis-cli -a 密码<br>--cluster <strong>check</strong><br>192.168.111.174:6388</font></p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230809155313502.png" alt="image-20230809155313502"></p></li><li><p>从集群中<font color="gree">将 slave 6388 删除</font>：</p><p><font color="orange">redis-cli -a 111111<br>--cluster <strong>del-node</strong><br>192.168.111.174:6388<br>218e7b8b4f81be54ff173e4776b4f4faaf7c13da</font></p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230809155525228.png" alt="image-20230809155525228"></p></li><li><p>检查集群情况，发现 slave 6388 被成功删除：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230809155602447.png" alt="image-20230809155602447"></p></li><li><p><font color="gree">将 master 6387 的槽号清空</font>，本例中将其<font color="gree">重新分派</font>给 master 6381：</p><p><font color="orange">redis-cli -a 111111<br>--cluster <strong>reshard</strong><br>192.168.111.175:6381</font></p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230809155839782.png" alt="image-20230809155839782"></p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230809155856778.png" alt="image-20230809155856778"></p></li><li><p>检查集群情况：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230809155927823.png" alt="image-20230809155927823"></p><blockquote><p>发现：</p><ul><li>master 6387 的 4096 个槽位都指给了 master 6381（变成了 8192 个槽位）</li><li><strong>master 6387 变成了 master 6381 的 slave</strong></li></ul></blockquote></li><li><p>删除 6387：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230809160629562.png" alt="image-20230809160629562"></p></li><li><p>检查集群情况：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230809160704133.png" alt="image-20230809160704133"></p><blockquote><p>此时 6387/6388 已从集群中移除</p></blockquote></li><li><p>此时，若再想在 6387 上写数据，会报错：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230809160827236.png" alt="image-20230809160827236"></p></li></ol><h3 id="通识占位符"><a class="anchor" href="#通识占位符">#</a> 通识占位符</h3><p>痛点：不在同一个 slot 槽位下的<font color="red">批操作命令（多键操作）</font>支持不好。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230809161249034.png" alt="image-20230809161249034"></p><p><strong>可以通过 <code>通识占位符&#123;&#125;</code> 来定义同一个 slot 槽位的概念</strong>，使 key 中<font color="red">{} 内相同内容</font>的键值对<font color="red">放到一个 slot 槽位</font>去，对照下图类似 k1、k2、k3 都映射为 x，自然槽位一样：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230809161554065.png" alt="image-20230809161554065"></p><h3 id="crc16算法分析"><a class="anchor" href="#crc16算法分析">#</a> CRC16 算法分析</h3><p>Redis 集群有 16384 个哈希槽，每个 key 通过 CRC16 校验后对 16384 取模来决定放置哪个槽。集群的每个节点负责一部分 hash 槽。</p><p>下面浅析 CRC16 算法的源码，源码文件是 <code>cluster.c</code> ：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230809161758328.png" alt="image-20230809161758328"></p><h3 id="集群中的常用配置与命令"><a class="anchor" href="#集群中的常用配置与命令">#</a> 集群中的常用配置与命令</h3><ul><li><p>配置参数 <code>cluster-require-full-coverage</code> ：<strong>集群是否完整时才能对外提供服务</strong>，默认为 yes。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230809162230541.png" alt="image-20230809162230541"></p><blockquote><p>现在集群架构是 3 主 3 从，由 3 个 master 平分 16384 个 slot，每个 master 的小集群负责 1/3 的 slot，对应一部分数据。</p><p>通常情况，如果这 3 个小集群中，任何一个（1 主 1 从）挂了，你这个集群对外可提供的数据只有 2/3 了，整个集群是不完整的，redis 默认在这种情况下，是不会对外提供服务的。</p></blockquote></li><li><p>命令 <code>CLUSTER COUNTKEYSINSLOT slotindex</code> ：<strong>查看第 <code>slotindex</code> 号槽位上的 key 数量</strong>，空则返回 0。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230809162506376.png" alt="image-20230809162506376"></p></li><li><p>命令 <code>CLUSTER KEYSLOT key</code> ：<strong>查看 <code>key</code> 应该存放的槽位号</strong>。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230809162815558.png" alt="image-20230809162815558"></p></li></ul><h2 id="11-springboot集成redis"><a class="anchor" href="#11-springboot集成redis">#</a> 11、SpringBoot 集成 Redis</h2><blockquote><p>前面都是通过<font color="red">命令</font>与 Redis 交互，实际生产中更多是通过<font color="red">Java 程序</font>来操作 Redis。</p></blockquote><h3 id="整体概述"><a class="anchor" href="#整体概述">#</a> 整体概述</h3><blockquote><p>对比 Jedis、lettuce、RedisTemplate</p></blockquote><p>Java 连接 MySQL 的驱动中间件是 JDBC，那么 Java 连接 Redis 所需要的驱动中间件有哪些呢？</p><ul><li>Jedis：一代目，老牌，线程池不安全</li><li>lettuce：二代目，对 Jedis 的优化</li><li><strong>RedisTemplate</strong>：三代目，对 lettuce 进行封装</li></ul><h3 id="本地java连接redis的常见问题"><a class="anchor" href="#本地java连接redis的常见问题">#</a> 本地 Java 连接 Redis 的常见问题</h3><p>以下问题可能会导致 Java 程序无法远程连接 Redis：</p><ul><li>redis.conf 中的 bind 配置请注释掉</li><li>redis.conf 中的保护模式设置为 no</li><li>Linux 系统的防火墙设置</li><li>redis 服务器的 IP 地址和密码是否正确</li><li>忘记写访问 redis 的服务端口号和 auth 密码</li><li>无脑粘贴脑图笔记......o (...T) o</li></ul><h3 id="集成jedis"><a class="anchor" href="#集成jedis">#</a> 集成 Jedis</h3><p><code>Jedis Client</code> 是 Redis 官网推荐的一个面向 java 客户端，库文件实现了对各类 API 进行封装调用。</p><p>集成 Jedis 的步骤如下：</p><blockquote><p>约定＞配置＞编码</p></blockquote><ol><li><p>创建 Module</p></li><li><p>修改 POM</p></li><li><p>写 YML</p></li><li><p>主启动</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>atguigu<span class="token punctuation">.</span>redis7</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span></span><span class="token class-name">SpringApplication</span></span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span></span><span class="token class-name">SpringBootApplication</span></span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token comment">/**</span></pre></td></tr><tr><td data-num="7"></td><td><pre> * @auther zzyy</pre></td></tr><tr><td data-num="8"></td><td><pre> * @create 2022-11-17 16:36</pre></td></tr><tr><td data-num="9"></td><td><pre> */</pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token annotation punctuation">@SpringBootApplication</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Redis7Study7777</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token class-name">SpringApplication</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token class-name">Redis7Study7777</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure></li><li><p>业务类</p><ol><li>通过指定 ip 和 port 获得 connection 对象</li><li>指定访问服务器的密码</li><li>得到 Jedis 客户端后，即可访问 redis</li></ol><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token annotation punctuation">@Slf4j</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">JedisDemo</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token class-name">Jedis</span> jedis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Jedis</span><span class="token punctuation">(</span><span class="token string">"192.168.111.185"</span><span class="token punctuation">,</span><span class="token number">6379</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre>        jedis<span class="token punctuation">.</span><span class="token function">auth</span><span class="token punctuation">(</span><span class="token string">"111111"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"redis conn status:&#123;&#125;"</span><span class="token punctuation">,</span><span class="token string">"连接成功"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"redis ping retvalue:&#123;&#125;"</span><span class="token punctuation">,</span>jedis<span class="token punctuation">.</span><span class="token function">ping</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre></pre></td></tr><tr><td data-num="13"></td><td><pre>        jedis<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"k1"</span><span class="token punctuation">,</span><span class="token string">"jedis"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"k1 value:&#123;&#125;"</span><span class="token punctuation">,</span>jedis<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"k1"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure></li></ol><h3 id="集成lettuce"><a class="anchor" href="#集成lettuce">#</a> 集成 lettuce</h3><blockquote><p>我来人间一趟，本想光芒万丈，奈何 springboot 太强，刚出生就被团灭！</p></blockquote><p>Lettuce 是一个 Redis 的 Java 驱动包，翻译为生菜。</p><p>lettuce 与 Jedis 的区别：</p><ul><li><p>Jedis 连接 Redis 时，<font color="red">每个线程都要创建 Jedis 实例，开销大</font></p></li><li><p><font color="red">Jedis 是线程不安全的</font>，一个线程通过 Jedis 实例更改 Redis 服务器中的数据之后，会影响另一个线程</p></li><li><p><strong>Lettuce 底层使用的是 Netty</strong>，当有多个线程都需要连接 Redis 服务器的时候，可以保证<font color="red">只创建一个 Lettuce 连接</font>，使<font color="red">所有的线程共享</font>这一个 Lettuce 连接，这样可以减少创建关闭一个 Lettuce 连接时候的开销。</p></li><li><p>这种方式也是<font color="red">线程安全</font>的，不会出现一个线程通过 Lettuce 更改 Redis 服务器中的数据之后而影响另一个线程的情况。</p></li><li><p>因此，<font color="red">在 SpringBoot2.0 之后默认都是使用的 Lettuce</font></p></li></ul><p>案例：</p><ol><li><p>修改 POM</p></li><li><p>写业务类</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>atguigu<span class="token punctuation">.</span>redis7<span class="token punctuation">.</span>test</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">import</span> <span class="token import"><span class="token namespace">io<span class="token punctuation">.</span>lettuce<span class="token punctuation">.</span>core<span class="token punctuation">.</span></span><span class="token class-name">RedisClient</span></span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">import</span> <span class="token import"><span class="token namespace">io<span class="token punctuation">.</span>lettuce<span class="token punctuation">.</span>core<span class="token punctuation">.</span></span><span class="token class-name">RedisFuture</span></span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">import</span> <span class="token import"><span class="token namespace">io<span class="token punctuation">.</span>lettuce<span class="token punctuation">.</span>core<span class="token punctuation">.</span></span><span class="token class-name">RedisURI</span></span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">import</span> <span class="token import"><span class="token namespace">io<span class="token punctuation">.</span>lettuce<span class="token punctuation">.</span>core<span class="token punctuation">.</span></span><span class="token class-name">SortArgs</span></span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">import</span> <span class="token import"><span class="token namespace">io<span class="token punctuation">.</span>lettuce<span class="token punctuation">.</span>core<span class="token punctuation">.</span>api<span class="token punctuation">.</span></span><span class="token class-name">StatefulRedisConnection</span></span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token keyword">import</span> <span class="token import"><span class="token namespace">io<span class="token punctuation">.</span>lettuce<span class="token punctuation">.</span>core<span class="token punctuation">.</span>api<span class="token punctuation">.</span>async<span class="token punctuation">.</span></span><span class="token class-name">RedisAsyncCommands</span></span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">import</span> <span class="token import"><span class="token namespace">io<span class="token punctuation">.</span>lettuce<span class="token punctuation">.</span>core<span class="token punctuation">.</span>api<span class="token punctuation">.</span>sync<span class="token punctuation">.</span></span><span class="token class-name">RedisCommands</span></span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token keyword">import</span> <span class="token import"><span class="token namespace">lombok<span class="token punctuation">.</span>extern<span class="token punctuation">.</span>slf4j<span class="token punctuation">.</span></span><span class="token class-name">Slf4j</span></span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">HashMap</span></span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">List</span></span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Map</span></span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Set</span></span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token class-name">ExecutionException</span></span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token comment">/**</span></pre></td></tr><tr><td data-num="19"></td><td><pre> * @auther zzyy</pre></td></tr><tr><td data-num="20"></td><td><pre> * @create 2022-11-17 17:05</pre></td></tr><tr><td data-num="21"></td><td><pre> */</pre></td></tr><tr><td data-num="22"></td><td><pre><span class="token annotation punctuation">@Slf4j</span></pre></td></tr><tr><td data-num="23"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LettuceDemo</span></pre></td></tr><tr><td data-num="24"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="26"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>        <span class="token comment">// 使用构建器（链式编程） RedisURI.builder</span></pre></td></tr><tr><td data-num="28"></td><td><pre>        <span class="token class-name">RedisURI</span> uri <span class="token operator">=</span> <span class="token class-name">RedisURI</span><span class="token punctuation">.</span><span class="token function">builder</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="29"></td><td><pre>                <span class="token punctuation">.</span><span class="token function">redis</span><span class="token punctuation">(</span><span class="token string">"192.168.111.181"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="30"></td><td><pre>                <span class="token punctuation">.</span><span class="token function">withPort</span><span class="token punctuation">(</span><span class="token number">6379</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="31"></td><td><pre>                <span class="token punctuation">.</span><span class="token function">withAuthentication</span><span class="token punctuation">(</span><span class="token string">"default"</span><span class="token punctuation">,</span><span class="token string">"111111"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="32"></td><td><pre>                <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="33"></td><td><pre>        <span class="token comment">// 创建连接客户端</span></pre></td></tr><tr><td data-num="34"></td><td><pre>        <span class="token class-name">RedisClient</span> client <span class="token operator">=</span> <span class="token class-name">RedisClient</span><span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>uri<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="35"></td><td><pre>        <span class="token class-name">StatefulRedisConnection</span> conn <span class="token operator">=</span> client<span class="token punctuation">.</span><span class="token function">connect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="36"></td><td><pre>        <span class="token comment">// 操作命令 api</span></pre></td></tr><tr><td data-num="37"></td><td><pre>        <span class="token class-name">RedisCommands</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span><span class="token class-name">String</span><span class="token punctuation">></span></span> commands <span class="token operator">=</span> conn<span class="token punctuation">.</span><span class="token function">sync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="38"></td><td><pre></pre></td></tr><tr><td data-num="39"></td><td><pre>        <span class="token comment">//keys</span></pre></td></tr><tr><td data-num="40"></td><td><pre>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> list <span class="token operator">=</span> commands<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span><span class="token string">"*"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="41"></td><td><pre>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token class-name">String</span> s <span class="token operator">:</span> list<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="42"></td><td><pre>            log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"key:&#123;&#125;"</span><span class="token punctuation">,</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="43"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="44"></td><td><pre>        <span class="token comment">//String</span></pre></td></tr><tr><td data-num="45"></td><td><pre>    commands<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"k1"</span><span class="token punctuation">,</span><span class="token string">"1111"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="46"></td><td><pre>    <span class="token class-name">String</span> s1 <span class="token operator">=</span> commands<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"k1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="47"></td><td><pre>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"String s ==="</span><span class="token operator">+</span>s1<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="48"></td><td><pre></pre></td></tr><tr><td data-num="49"></td><td><pre>        <span class="token comment">//list</span></pre></td></tr><tr><td data-num="50"></td><td><pre>    commands<span class="token punctuation">.</span><span class="token function">lpush</span><span class="token punctuation">(</span><span class="token string">"myList2"</span><span class="token punctuation">,</span> <span class="token string">"v1"</span><span class="token punctuation">,</span><span class="token string">"v2"</span><span class="token punctuation">,</span><span class="token string">"v3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="51"></td><td><pre>    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> list2 <span class="token operator">=</span> commands<span class="token punctuation">.</span><span class="token function">lrange</span><span class="token punctuation">(</span><span class="token string">"myList2"</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="52"></td><td><pre>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token class-name">String</span> s <span class="token operator">:</span> list2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="53"></td><td><pre>     <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"list ssss==="</span><span class="token operator">+</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="54"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="55"></td><td><pre>    <span class="token comment">//set</span></pre></td></tr><tr><td data-num="56"></td><td><pre>    commands<span class="token punctuation">.</span><span class="token function">sadd</span><span class="token punctuation">(</span><span class="token string">"mySet2"</span><span class="token punctuation">,</span> <span class="token string">"v1"</span><span class="token punctuation">,</span><span class="token string">"v2"</span><span class="token punctuation">,</span><span class="token string">"v3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="57"></td><td><pre>    <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> set <span class="token operator">=</span> commands<span class="token punctuation">.</span><span class="token function">smembers</span><span class="token punctuation">(</span><span class="token string">"mySet2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="58"></td><td><pre>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token class-name">String</span> s <span class="token operator">:</span> set<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="59"></td><td><pre>     <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"set ssss==="</span><span class="token operator">+</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="60"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="61"></td><td><pre>    <span class="token comment">//hash</span></pre></td></tr><tr><td data-num="62"></td><td><pre>    <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span><span class="token class-name">String</span><span class="token punctuation">></span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="63"></td><td><pre>        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"k1"</span><span class="token punctuation">,</span><span class="token string">"138xxxxxxxx"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="64"></td><td><pre>        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"k2"</span><span class="token punctuation">,</span><span class="token string">"atguigu"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="65"></td><td><pre>        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"k3"</span><span class="token punctuation">,</span><span class="token string">"zzyybs@126.com"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 课后有问题请给我发邮件</span></pre></td></tr><tr><td data-num="66"></td><td><pre></pre></td></tr><tr><td data-num="67"></td><td><pre>    commands<span class="token punctuation">.</span><span class="token function">hmset</span><span class="token punctuation">(</span><span class="token string">"myHash2"</span><span class="token punctuation">,</span> map<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="68"></td><td><pre>    <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span><span class="token class-name">String</span><span class="token punctuation">></span></span> retMap <span class="token operator">=</span> commands<span class="token punctuation">.</span><span class="token function">hgetall</span><span class="token punctuation">(</span><span class="token string">"myHash2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="69"></td><td><pre>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token class-name">String</span> k <span class="token operator">:</span> retMap<span class="token punctuation">.</span><span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="70"></td><td><pre>     <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"hash  k="</span><span class="token operator">+</span>k<span class="token operator">+</span><span class="token string">" , v=="</span><span class="token operator">+</span>retMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="71"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="72"></td><td><pre></pre></td></tr><tr><td data-num="73"></td><td><pre>    <span class="token comment">//zset</span></pre></td></tr><tr><td data-num="74"></td><td><pre>    commands<span class="token punctuation">.</span><span class="token function">zadd</span><span class="token punctuation">(</span><span class="token string">"myZset2"</span><span class="token punctuation">,</span> <span class="token number">100.0</span><span class="token punctuation">,</span><span class="token string">"s1"</span><span class="token punctuation">,</span><span class="token number">110.0</span><span class="token punctuation">,</span><span class="token string">"s2"</span><span class="token punctuation">,</span><span class="token number">90.0</span><span class="token punctuation">,</span><span class="token string">"s3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="75"></td><td><pre>    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> list3 <span class="token operator">=</span> commands<span class="token punctuation">.</span><span class="token function">zrange</span><span class="token punctuation">(</span><span class="token string">"myZset2"</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="76"></td><td><pre>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token class-name">String</span> s <span class="token operator">:</span> list3<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="77"></td><td><pre>     <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"zset ssss==="</span><span class="token operator">+</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="78"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="79"></td><td><pre></pre></td></tr><tr><td data-num="80"></td><td><pre>    <span class="token comment">//sort</span></pre></td></tr><tr><td data-num="81"></td><td><pre>    <span class="token class-name">SortArgs</span> sortArgs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SortArgs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="82"></td><td><pre>    sortArgs<span class="token punctuation">.</span><span class="token function">alpha</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="83"></td><td><pre>    sortArgs<span class="token punctuation">.</span><span class="token function">desc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="84"></td><td><pre></pre></td></tr><tr><td data-num="85"></td><td><pre>    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> list4 <span class="token operator">=</span> commands<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token string">"myList2"</span><span class="token punctuation">,</span>sortArgs<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="86"></td><td><pre>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token class-name">String</span> s <span class="token operator">:</span> list4<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="87"></td><td><pre>     <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"sort ssss==="</span><span class="token operator">+</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="88"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="89"></td><td><pre></pre></td></tr><tr><td data-num="90"></td><td><pre>        <span class="token comment">// 关闭</span></pre></td></tr><tr><td data-num="91"></td><td><pre>        conn<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="92"></td><td><pre>        client<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="93"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="94"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure></li></ol><h3 id="集成redistemplate推荐"><a class="anchor" href="#集成redistemplate推荐">#</a> <mark>集成 RedisTemplate（推荐）</mark></h3><h4 id="连接单机"><a class="anchor" href="#连接单机">#</a> 连接单机</h4><h5 id="boot整合redis基础演示"><a class="anchor" href="#boot整合redis基础演示">#</a> boot 整合 Redis 基础演示</h5><ol><li><p>创建 Module</p></li><li><p>修改 POM： <code>spring-boot-starter-data-redis</code> 包（依赖于 lettuce 包）和 <code>commons-pool2</code> 包</p></li><li><p>写 YML</p><figure class="highlight yaml"><figcaption data-lang="YAML"></figcaption><table><tr><td data-num="1"></td><td><pre>==============redis单机==================</pre></td></tr><tr><td data-num="2"></td><td><pre>spring.redis.database=0</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment"># 修改为自己真实 IP</span></pre></td></tr><tr><td data-num="4"></td><td><pre>spring.redis.host=192.168.111.185</pre></td></tr><tr><td data-num="5"></td><td><pre>spring.redis.port=6379</pre></td></tr><tr><td data-num="6"></td><td><pre>spring.redis.password=111111</pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token comment"># lettuce 连接池</span></pre></td></tr><tr><td data-num="8"></td><td><pre>spring.redis.lettuce.pool.max<span class="token punctuation">-</span>active=8</pre></td></tr><tr><td data-num="9"></td><td><pre>spring.redis.lettuce.pool.max<span class="token punctuation">-</span>wait=<span class="token punctuation">-</span>1ms</pre></td></tr><tr><td data-num="10"></td><td><pre>spring.redis.lettuce.pool.max<span class="token punctuation">-</span>idle=8</pre></td></tr><tr><td data-num="11"></td><td><pre>spring.redis.lettuce.pool.min<span class="token punctuation">-</span>idle=0</pre></td></tr></table></figure></li><li><p>主启动</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token annotation punctuation">@SpringBootApplication</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Redis7Study7777</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token class-name">SpringApplication</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token class-name">Redis7Study7777</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure></li><li><p>业务类</p><ol><li><p>配置类</p><ol><li>RedisConfig</li><li>SwaggerConfig</li></ol></li><li><p>service</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token annotation punctuation">@Service</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token annotation punctuation">@Slf4j</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">OrderService</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> <span class="token constant">ORDER_KEY</span> <span class="token operator">=</span> <span class="token string">"order:"</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token annotation punctuation">@Resource</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">private</span> <span class="token class-name">RedisTemplate</span> redisTemplate<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addOrder</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token keyword">int</span> keyId <span class="token operator">=</span> <span class="token class-name">ThreadLocalRandom</span><span class="token punctuation">.</span><span class="token function">current</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token class-name">String</span> orderNo <span class="token operator">=</span> <span class="token constant">UUID</span><span class="token punctuation">.</span><span class="token function">randomUUID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token constant">ORDER_KEY</span><span class="token operator">+</span>keyId<span class="token punctuation">,</span><span class="token string">"京东订单"</span><span class="token operator">+</span> orderNo<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"=====>编号"</span><span class="token operator">+</span>keyId<span class="token operator">+</span><span class="token string">"的订单流水生成:&#123;&#125;"</span><span class="token punctuation">,</span>orderNo<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="17"></td><td><pre></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getOrderById</span><span class="token punctuation">(</span><span class="token class-name">Integer</span> id<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span>redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token constant">ORDER_KEY</span> <span class="token operator">+</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="22"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure></li><li><p>controller</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token annotation punctuation">@Api</span><span class="token punctuation">(</span>tags <span class="token operator">=</span> <span class="token string">"订单接口"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token annotation punctuation">@RestController</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token annotation punctuation">@Slf4j</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">OrderController</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token annotation punctuation">@Resource</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">private</span> <span class="token class-name">OrderService</span> orderService<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token annotation punctuation">@ApiOperation</span><span class="token punctuation">(</span><span class="token string">"新增订单"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"/order/add"</span><span class="token punctuation">,</span>method <span class="token operator">=</span> <span class="token class-name">RequestMethod</span><span class="token punctuation">.</span><span class="token constant">POST</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addOrder</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        orderService<span class="token punctuation">.</span><span class="token function">addOrder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre></pre></td></tr><tr><td data-num="16"></td><td><pre></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token annotation punctuation">@ApiOperation</span><span class="token punctuation">(</span><span class="token string">"按orderId查订单信息"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"/order/&#123;id&#125;"</span><span class="token punctuation">,</span> method <span class="token operator">=</span> <span class="token class-name">RequestMethod</span><span class="token punctuation">.</span><span class="token constant">GET</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">findUserById</span><span class="token punctuation">(</span><span class="token annotation punctuation">@PathVariable</span> <span class="token class-name">Integer</span> id<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>        <span class="token keyword">return</span> orderService<span class="token punctuation">.</span><span class="token function">getOrderById</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="23"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure></li></ol></li><li><p>测试</p><ol><li><p>swagger</p></li><li><p><font color="red">序列化问题</font>：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230809211944574.png" alt="image-20230809211944574"></p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230809212145565.png" alt="image-20230809212145565"></p><blockquote><p><img data-src="C:%5CUsers%5Chuawei%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20230809212339643.png" alt="image-20230809212339643"></p><p><strong>解决方案 1</strong>：将 <code>RedisTemplate</code> 对象替换为 <code>StringRedisTemplate</code> 对象。此时除了 Redis 命令行中仍然显示中文乱码外，在 swagger、服务器中的返回值都没有乱码的问题了。</p><p><strong><font color="red">解决方案 2-1</font></strong>：<strong>启动 Redis 时添加参数 <code>--raw</code> 解决 Redis 服务器端显示乱码</strong>。</p><p><strong><font color="red">解决方案 2-2</font></strong>：看下源码 <code>RedisTemplate</code> # <code>afterPropertiesSet()</code> 发现在默认情况下，RedisTemplate 使用的数据列化方式是 <code>JdkSerializationRedisSerializer</code> ，也就是导致乱码的罪魁祸首！解决方法就是 **<font color="orange">编写 RedisConfig 配置类，指定序列化器</font>**！</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token annotation punctuation">@Configuration</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RedisConfig</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token comment">/**</span></pre></td></tr><tr><td data-num="5"></td><td><pre>     * redis 序列化的工具配置类，下面这个请一定开启配置</pre></td></tr><tr><td data-num="6"></td><td><pre>     * 127.0.0.1:6379> keys *</pre></td></tr><tr><td data-num="7"></td><td><pre>     * 1) "ord:102"  序列化过</pre></td></tr><tr><td data-num="8"></td><td><pre>     * 2) "\xac\xed\x00\x05t\x00\aord:102"   野生，没有序列化过</pre></td></tr><tr><td data-num="9"></td><td><pre>     * this.redisTemplate.opsForValue (); // 提供了操作 string 类型的所有方法</pre></td></tr><tr><td data-num="10"></td><td><pre>     * this.redisTemplate.opsForList (); // 提供了操作 list 类型的所有方法</pre></td></tr><tr><td data-num="11"></td><td><pre>     * this.redisTemplate.opsForSet (); // 提供了操作 set 的所有方法</pre></td></tr><tr><td data-num="12"></td><td><pre>     * this.redisTemplate.opsForHash (); // 提供了操作 hash 表的所有方法</pre></td></tr><tr><td data-num="13"></td><td><pre>     * this.redisTemplate.opsForZSet (); // 提供了操作 zset 的所有方法</pre></td></tr><tr><td data-num="14"></td><td><pre>     * @param lettuceConnectionFactory</pre></td></tr><tr><td data-num="15"></td><td><pre>     * @return</pre></td></tr><tr><td data-num="16"></td><td><pre>     */</pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token annotation punctuation">@Bean</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">RedisTemplate</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">></span></span> <span class="token function">redisTemplate</span><span class="token punctuation">(</span><span class="token class-name">LettuceConnectionFactory</span> lettuceConnectionFactory<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>        <span class="token class-name">RedisTemplate</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span><span class="token class-name">Object</span><span class="token punctuation">></span></span> redisTemplate <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RedisTemplate</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre></pre></td></tr><tr><td data-num="22"></td><td><pre>        redisTemplate<span class="token punctuation">.</span><span class="token function">setConnectionFactory</span><span class="token punctuation">(</span>lettuceConnectionFactory<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>        <span class="token comment">// 设置 key 序列化方式 string</span></pre></td></tr><tr><td data-num="24"></td><td><pre>        redisTemplate<span class="token punctuation">.</span><span class="token function">setKeySerializer</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">StringRedisSerializer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>        <span class="token comment">// 设置 value 的序列化方式 json，使用 GenericJackson2JsonRedisSerializer 替换默认序列化</span></pre></td></tr><tr><td data-num="26"></td><td><pre>        redisTemplate<span class="token punctuation">.</span><span class="token function">setValueSerializer</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">GenericJackson2JsonRedisSerializer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre></pre></td></tr><tr><td data-num="28"></td><td><pre>        redisTemplate<span class="token punctuation">.</span><span class="token function">setHashKeySerializer</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">StringRedisSerializer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>        redisTemplate<span class="token punctuation">.</span><span class="token function">setHashValueSerializer</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">GenericJackson2JsonRedisSerializer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="30"></td><td><pre></pre></td></tr><tr><td data-num="31"></td><td><pre>        redisTemplate<span class="token punctuation">.</span><span class="token function">afterPropertiesSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="32"></td><td><pre></pre></td></tr><tr><td data-num="33"></td><td><pre>        <span class="token keyword">return</span> redisTemplate<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="34"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="35"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure></blockquote></li></ol></li></ol><h5 id="调用其他命令api家庭作业"><a class="anchor" href="#调用其他命令api家庭作业">#</a> 调用其他命令 api（家庭作业）</h5><h4 id="连接集群"><a class="anchor" href="#连接集群">#</a> 连接集群</h4><h5 id="步骤演示"><a class="anchor" href="#步骤演示">#</a> 步骤演示</h5><ol><li><p>启动 Redis 集群的 6 台实例（三主三从）</p></li><li><p>改写 YML</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre># <span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">=</span>redis集群<span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">=</span></pre></td></tr><tr><td data-num="2"></td><td><pre>spring<span class="token punctuation">.</span>redis<span class="token punctuation">.</span>password<span class="token operator">=</span><span class="token number">111111</span></pre></td></tr><tr><td data-num="3"></td><td><pre># 获取失败 最大重定向次数</pre></td></tr><tr><td data-num="4"></td><td><pre>spring<span class="token punctuation">.</span>redis<span class="token punctuation">.</span>cluster<span class="token punctuation">.</span>max<span class="token operator">-</span>redirects<span class="token operator">=</span><span class="token number">3</span></pre></td></tr><tr><td data-num="5"></td><td><pre>spring<span class="token punctuation">.</span>redis<span class="token punctuation">.</span>lettuce<span class="token punctuation">.</span>pool<span class="token punctuation">.</span>max<span class="token operator">-</span>active<span class="token operator">=</span><span class="token number">8</span></pre></td></tr><tr><td data-num="6"></td><td><pre>spring<span class="token punctuation">.</span>redis<span class="token punctuation">.</span>lettuce<span class="token punctuation">.</span>pool<span class="token punctuation">.</span>max<span class="token operator">-</span>wait<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span>ms</pre></td></tr><tr><td data-num="7"></td><td><pre>spring<span class="token punctuation">.</span>redis<span class="token punctuation">.</span>lettuce<span class="token punctuation">.</span>pool<span class="token punctuation">.</span>max<span class="token operator">-</span>idle<span class="token operator">=</span><span class="token number">8</span></pre></td></tr><tr><td data-num="8"></td><td><pre>spring<span class="token punctuation">.</span>redis<span class="token punctuation">.</span>lettuce<span class="token punctuation">.</span>pool<span class="token punctuation">.</span>min<span class="token operator">-</span>idle<span class="token operator">=</span><span class="token number">0</span></pre></td></tr><tr><td data-num="9"></td><td><pre>spring<span class="token punctuation">.</span>redis<span class="token punctuation">.</span>cluster<span class="token punctuation">.</span>nodes<span class="token operator">=</span><span class="token number">192.168</span><span class="token number">.111</span><span class="token number">.175</span><span class="token operator">:</span><span class="token number">6381</span><span class="token punctuation">,</span><span class="token number">192.168</span><span class="token number">.111</span><span class="token number">.175</span><span class="token operator">:</span><span class="token number">6382</span><span class="token punctuation">,</span><span class="token number">192.168</span><span class="token number">.111</span><span class="token number">.172</span><span class="token operator">:</span><span class="token number">6383</span><span class="token punctuation">,</span><span class="token number">192.168</span><span class="token number">.111</span><span class="token number">.172</span><span class="token operator">:</span><span class="token number">6384</span><span class="token punctuation">,</span><span class="token number">192.168</span><span class="token number">.111</span><span class="token number">.174</span><span class="token operator">:</span><span class="token number">6385</span><span class="token punctuation">,</span><span class="token number">192.168</span><span class="token number">.111</span><span class="token number">.174</span><span class="token operator">:</span><span class="token number">6386</span></pre></td></tr></table></figure></li><li><p>通过微服务访问 redis 集群：一切 ok</p></li></ol><h5 id="故障转移时的经典问题"><a class="anchor" href="#故障转移时的经典问题">#</a> 故障转移时的经典问题</h5><ol><li><p>人为模拟 master 6381 机器意外宕机，手动 shutdown</p></li><li><p>对 redis 集群命令方式，手动验证各种读写命令，slave 6384 成功上位</p></li><li><p><font color="red"><u>Redis 侧的集群</u>能自动感知并完成主从切换</font>，对应的 slave 6384 会被选举为新的 master</p></li><li><p><strong><u>微服务客户端</u>再次读写访问，发现连接不上 master 6381！</strong><font color="red">SpringBoot 客户端没有动态感知到 Redis 集群的最新集群信息</font>。当 master 宕机主从切换成功，redis 手动 OK，但是有 **<font color="red">2 个经典故障</font>**：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230809214444224.png" alt="image-20230809214444224"></p><blockquote><p>报错：命令超时 1 分钟！</p></blockquote><p><img data-src="C:%5CUsers%5Chuawei%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20230809214514675.png" alt="image-20230809214514675"></p><blockquote><p>报错：无法连接 6381！</p></blockquote><p><font color="gree">根本原因</font>：<font color="red">SpringBoot 2.X 版本，Redis 默认的连接池采用 Lettuce。当 Redis 集群节点发生变化后，Letture 默认是不会刷新节点拓扑</font>。</p><p><strong><font color="gree">解决方案</font>：<font color="orange">刷新节点集群拓扑动态感应</font>。</strong><font color="red">修改 YML 中的两个配置项即可</font>！</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230809214957793.png" alt="image-20230809214957793"></p></li><li><p><strong>修改 YML</strong>：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre># <span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span>redis集群<span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span></pre></td></tr><tr><td data-num="2"></td><td><pre>spring<span class="token punctuation">.</span>redis<span class="token punctuation">.</span>password<span class="token operator">=</span><span class="token number">111111</span></pre></td></tr><tr><td data-num="3"></td><td><pre># 获取失败 最大重定向次数</pre></td></tr><tr><td data-num="4"></td><td><pre>spring<span class="token punctuation">.</span>redis<span class="token punctuation">.</span>cluster<span class="token punctuation">.</span>max<span class="token operator">-</span>redirects<span class="token operator">=</span><span class="token number">3</span></pre></td></tr><tr><td data-num="5"></td><td><pre>spring<span class="token punctuation">.</span>redis<span class="token punctuation">.</span>lettuce<span class="token punctuation">.</span>pool<span class="token punctuation">.</span>max<span class="token operator">-</span>active<span class="token operator">=</span><span class="token number">8</span></pre></td></tr><tr><td data-num="6"></td><td><pre>spring<span class="token punctuation">.</span>redis<span class="token punctuation">.</span>lettuce<span class="token punctuation">.</span>pool<span class="token punctuation">.</span>max<span class="token operator">-</span>wait<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span>ms</pre></td></tr><tr><td data-num="7"></td><td><pre>spring<span class="token punctuation">.</span>redis<span class="token punctuation">.</span>lettuce<span class="token punctuation">.</span>pool<span class="token punctuation">.</span>max<span class="token operator">-</span>idle<span class="token operator">=</span><span class="token number">8</span></pre></td></tr><tr><td data-num="8"></td><td><pre>spring<span class="token punctuation">.</span>redis<span class="token punctuation">.</span>lettuce<span class="token punctuation">.</span>pool<span class="token punctuation">.</span>min<span class="token operator">-</span>idle<span class="token operator">=</span><span class="token number">0</span></pre></td></tr><tr><td data-num="9"></td><td><pre># 支持集群拓扑动态感应刷新<span class="token punctuation">,</span>自适应拓扑刷新是否使用所有可用的更新，默认<span class="token boolean">false</span>关闭</pre></td></tr><tr><td data-num="10"></td><td><pre>spring<span class="token punctuation">.</span>redis<span class="token punctuation">.</span>lettuce<span class="token punctuation">.</span>cluster<span class="token punctuation">.</span>refresh<span class="token punctuation">.</span>adaptive<span class="token operator">=</span><span class="token boolean">true</span></pre></td></tr><tr><td data-num="11"></td><td><pre># 定时刷新</pre></td></tr><tr><td data-num="12"></td><td><pre>spring<span class="token punctuation">.</span>redis<span class="token punctuation">.</span>lettuce<span class="token punctuation">.</span>cluster<span class="token punctuation">.</span>refresh<span class="token punctuation">.</span>period<span class="token operator">=</span><span class="token number">2000</span></pre></td></tr><tr><td data-num="13"></td><td><pre>spring<span class="token punctuation">.</span>redis<span class="token punctuation">.</span>cluster<span class="token punctuation">.</span>nodes<span class="token operator">=</span><span class="token number">192.168</span><span class="token number">.111</span><span class="token number">.175</span><span class="token operator">:</span><span class="token number">6381</span><span class="token punctuation">,</span><span class="token number">192.168</span><span class="token number">.111</span><span class="token number">.175</span><span class="token operator">:</span><span class="token number">6382</span><span class="token punctuation">,</span><span class="token number">192.168</span><span class="token number">.111</span><span class="token number">.172</span><span class="token operator">:</span><span class="token number">6383</span><span class="token punctuation">,</span><span class="token number">192.168</span><span class="token number">.111</span><span class="token number">.172</span><span class="token operator">:</span><span class="token number">6384</span><span class="token punctuation">,</span><span class="token number">192.168</span><span class="token number">.111</span><span class="token number">.174</span><span class="token operator">:</span><span class="token number">6385</span><span class="token punctuation">,</span><span class="token number">192.168</span><span class="token number">.111</span><span class="token number">.174</span><span class="token operator">:</span><span class="token number">6386</span></pre></td></tr></table></figure></li></ol><h1 id="高级篇"><a class="anchor" href="#高级篇">#</a> 高级篇</h1><blockquote><p>前置技术要求：微服务（boot、cloud）+ docker + Nginx + JUC + Jmeter</p></blockquote><h2 id="1-redis的单线程与多线程入门篇"><a class="anchor" href="#1-redis的单线程与多线程入门篇">#</a> 1、Redis 的单线程与多线程 (入门篇)</h2><h2 id="2-bigkey"><a class="anchor" href="#2-bigkey">#</a> 2、BigKey</h2><h2 id="3-缓存双写一致性之更新策略探讨"><a class="anchor" href="#3-缓存双写一致性之更新策略探讨">#</a> 3、缓存双写一致性之更新策略探讨</h2><h2 id="4-redis与mysql数据双写一致性工程落地案例"><a class="anchor" href="#4-redis与mysql数据双写一致性工程落地案例">#</a> 4、Redis 与 MySQL 数据双写一致性工程落地案例</h2><h2 id="5-案例落地实战bitmaphyperlogloggeo"><a class="anchor" href="#5-案例落地实战bitmaphyperlogloggeo">#</a> 5、案例落地实战 bitmap/HyperLogLog/GEO</h2><h2 id="6-布隆过滤器bloomfilter"><a class="anchor" href="#6-布隆过滤器bloomfilter">#</a> 6、布隆过滤器 BloomFilter</h2><h2 id="7-缓存预热缓存雪崩缓存击穿缓存穿透"><a class="anchor" href="#7-缓存预热缓存雪崩缓存击穿缓存穿透">#</a> 7、缓存预热 + 缓存雪崩 + 缓存击穿 + 缓存穿透</h2><h2 id="8-手写redis分布式锁"><a class="anchor" href="#8-手写redis分布式锁">#</a> 8、手写 Redis 分布式锁</h2><h2 id="9-redlock算法和底层源码分析"><a class="anchor" href="#9-redlock算法和底层源码分析">#</a> 9、Redlock 算法和底层源码分析</h2><h2 id="10-redis经典五大类型源码及底层实现"><a class="anchor" href="#10-redis经典五大类型源码及底层实现">#</a> 10、Redis 经典五大类型源码及底层实现</h2><h2 id="11-redis为什么快高性能设计之epoll和io多路复用深度解析"><a class="anchor" href="#11-redis为什么快高性能设计之epoll和io多路复用深度解析">#</a> 11、Redis 为什么快？高性能设计之 epoll 和 IO 多路复用深度解析</h2><h2 id="12-终章の总结"><a class="anchor" href="#12-终章の总结">#</a> 12、终章の总结</h2></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2023-12-01 16:11:05" itemprop="dateModified" datetime="2023-12-01T16:11:05+08:00">2023-12-01</time> </span><span id="database/redis/尚硅谷-周阳-Redis7/" class="item leancloud_visitors" data-flag-title="Redis7-尚硅谷-周阳" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>范特东东东 <i class="ic i-at"><em>@</em></i>水文 & 摄影</li><li class="link"><strong>本文链接：</strong> <a href="http://example.com/database/redis/%E5%B0%9A%E7%A1%85%E8%B0%B7-%E5%91%A8%E9%98%B3-Redis7/" title="Redis7-尚硅谷-周阳">http://example.com/database/redis/尚硅谷-周阳-Redis7/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/database/mongodb/MongoDB-JavaGuide/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;hjx159&#x2F;picture-bed&#x2F;main&#x2F;img&#x2F;sql-nosql-tushi.png" title="MongoDB-JavaGuide"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> MongoDB</span><h3>MongoDB-JavaGuide</h3></a></div><div class="item right"><a href="/photography/%E4%B8%AD%E6%B3%95%E5%A4%A7%E5%AD%A6%E6%97%A7%E5%9D%80&%E5%8C%97%E6%B5%B7%E5%85%AC%E5%9B%AD/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;pic.imgdb.cn&#x2F;item&#x2F;656f2723c458853aef5c1279.jpg" title="京秋的胶片味"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> 摄影</span><h3>京秋的胶片味</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%A5%E9%97%A8%E7%AF%87"><span class="toc-number">1.</span> <span class="toc-text">入门篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-redis%E5%85%A5%E9%97%A8%E6%A6%82%E8%BF%B0"><span class="toc-number">1.1.</span> <span class="toc-text">1、Redis 入门概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#redis%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.1.1.</span> <span class="toc-text">Redis 是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redis%E7%9A%84%E5%8A%9F%E8%83%BD%E4%B8%8E%E4%BC%98%E5%8A%BF"><span class="toc-number">1.1.2.</span> <span class="toc-text">Redis 的功能与优势</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redis%E4%B8%8B%E8%BD%BD"><span class="toc-number">1.1.3.</span> <span class="toc-text">Redis 下载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redis%E6%80%8E%E4%B9%88%E7%8E%A9"><span class="toc-number">1.1.4.</span> <span class="toc-text">Redis 怎么玩</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redis%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%8E%86%E5%8F%B2"><span class="toc-number">1.1.5.</span> <span class="toc-text">Redis 的迭代历史</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redis7%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-number">1.1.6.</span> <span class="toc-text">Redis7 的新特性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-redis%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE"><span class="toc-number">1.2.</span> <span class="toc-text">2、Redis 安装与配置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#linux%E7%8E%AF%E5%A2%83%E9%9C%80%E8%A6%81gcc%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83"><span class="toc-number">1.2.1.</span> <span class="toc-text">Linux 环境需要 gcc 编译环境</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redis7%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4"><span class="toc-number">1.2.2.</span> <span class="toc-text">Redis7 安装步骤</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-redis%E7%9A%8410%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.3.</span> <span class="toc-text">3、Redis 的 10 种数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8Bvalue"><span class="toc-number">1.3.1.</span> <span class="toc-text">10 种数据类型 (value)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4%E6%89%8B%E5%86%8C"><span class="toc-number">1.3.2.</span> <span class="toc-text">常见数据类型的操作命令手册</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#key%E7%9B%B8%E5%85%B3%E7%9A%84%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4"><span class="toc-number">1.3.3.</span> <span class="toc-text">key 相关的操作命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#value%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9B%B8%E5%85%B3%E7%9A%84%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4"><span class="toc-number">1.3.4.</span> <span class="toc-text">value 数据类型相关的操作命令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2string"><span class="toc-number">1.3.4.1.</span> <span class="toc-text">字符串（String）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E6%A6%82%E8%A7%88"><span class="toc-number">1.3.4.1.1.</span> <span class="toc-text">命令概览</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E8%8E%B7%E5%8F%96%E5%8D%95%E4%B8%AA%E9%94%AE%E5%80%BC"><span class="toc-number">1.3.4.1.2.</span> <span class="toc-text">设置 &#x2F; 获取单个键值</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E8%8E%B7%E5%8F%96%E5%A4%9A%E4%B8%AA%E9%94%AE%E5%80%BC"><span class="toc-number">1.3.4.1.3.</span> <span class="toc-text">设置 &#x2F; 获取多个键值</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E6%8C%87%E5%AE%9A%E5%8C%BA%E9%97%B4%E8%8C%83%E5%9B%B4%E5%86%85%E7%9A%84%E5%80%BC"><span class="toc-number">1.3.4.1.4.</span> <span class="toc-text">获取指定区间范围内的值</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E5%80%BC%E5%A2%9E%E5%87%8F"><span class="toc-number">1.3.4.1.5.</span> <span class="toc-text">数值增减</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%95%BF%E5%BA%A6%E4%BB%A5%E5%8F%8A%E5%86%85%E5%AE%B9%E8%BF%BD%E5%8A%A0"><span class="toc-number">1.3.4.1.6.</span> <span class="toc-text">获取字符串长度以及内容追加</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">1.3.4.1.7.</span> <span class="toc-text">分布式锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%88%E8%8E%B7%E5%8F%96%E5%86%8D%E8%AE%BE%E7%BD%AE"><span class="toc-number">1.3.4.1.8.</span> <span class="toc-text">先获取，再设置</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.3.4.1.9.</span> <span class="toc-text">应用场景</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%97%E8%A1%A8list"><span class="toc-number">1.3.4.2.</span> <span class="toc-text">列表（List）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E6%A6%82%E8%A7%88-2"><span class="toc-number">1.3.4.2.1.</span> <span class="toc-text">命令概览</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#list%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.3.4.2.2.</span> <span class="toc-text">List 的数据结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E4%B8%8E%E9%81%8D%E5%8E%86"><span class="toc-number">1.3.4.2.3.</span> <span class="toc-text">插入与遍历</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%B9%E5%87%BA"><span class="toc-number">1.3.4.2.4.</span> <span class="toc-text">弹出</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%B9%E6%8D%AE%E4%B8%8B%E6%A0%87%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0%E4%BB%8E%E5%B7%A6%E5%88%B0%E5%8F%B3"><span class="toc-number">1.3.4.2.5.</span> <span class="toc-text">根据下标获取元素（从左到右）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%88%97%E8%A1%A8%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0%E4%B8%AA%E6%95%B0"><span class="toc-number">1.3.4.2.6.</span> <span class="toc-text">获取列表中的元素个数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%8C%87%E5%AE%9A%E6%95%B0%E9%87%8F%E4%B8%AA%E6%8C%87%E5%AE%9Avalue%E7%9A%84%E5%85%83%E7%B4%A0"><span class="toc-number">1.3.4.2.7.</span> <span class="toc-text">删除指定数量个指定 value 的元素</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%88%AA%E5%8F%96%E5%B9%B6%E4%BF%9D%E5%AD%98%E6%8C%87%E5%AE%9A%E4%B8%8B%E6%A0%87%E5%8C%BA%E9%97%B4%E7%9A%84%E5%85%83%E7%B4%A0"><span class="toc-number">1.3.4.2.8.</span> <span class="toc-text">截取并保存指定下标区间的元素</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B0%86%E5%85%83%E7%B4%A0%E7%A7%BB%E8%87%B3%E5%8F%A6%E4%B8%80%E4%B8%AA%E5%88%97%E8%A1%A8"><span class="toc-number">1.3.4.2.9.</span> <span class="toc-text">将元素移至另一个列表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E6%9F%90%E4%B8%8B%E6%A0%87%E5%AF%B9%E5%BA%94%E7%9A%84%E5%85%83%E7%B4%A0%E5%80%BC%E4%BB%8E%E5%B7%A6%E5%88%B0%E5%8F%B3"><span class="toc-number">1.3.4.2.10.</span> <span class="toc-text">设置某下标对应的元素值（从左到右）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9C%A8%E6%8C%87%E5%AE%9A%E5%85%83%E7%B4%A0%E7%9A%84%E5%89%8D%E5%90%8E%E6%8F%92%E5%85%A5%E5%85%83%E7%B4%A0"><span class="toc-number">1.3.4.2.11.</span> <span class="toc-text">在指定元素的前 &#x2F; 后插入元素</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-2"><span class="toc-number">1.3.4.2.12.</span> <span class="toc-text">应用场景</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E9%9B%86hash"><span class="toc-number">1.3.4.3.</span> <span class="toc-text">哈希集（Hash）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E6%A6%82%E8%A7%88-3"><span class="toc-number">1.3.4.3.1.</span> <span class="toc-text">命令概览</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE-%E8%8E%B7%E5%8F%96-%E5%88%A0%E9%99%A4"><span class="toc-number">1.3.4.3.2.</span> <span class="toc-text">设置、获取、删除</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%93%88%E5%B8%8C%E9%9B%86%E7%9A%84%E5%AD%97%E6%AE%B5%E6%95%B0%E9%87%8F"><span class="toc-number">1.3.4.3.3.</span> <span class="toc-text">获取哈希集的字段数量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E5%93%88%E5%B8%8C%E9%9B%86%E4%B8%AD%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E6%9F%90%E4%B8%AA%E5%AD%97%E6%AE%B5"><span class="toc-number">1.3.4.3.4.</span> <span class="toc-text">判断哈希集中是否存在某个字段</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%93%88%E5%B8%8C%E9%9B%86%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89keyvalue"><span class="toc-number">1.3.4.3.5.</span> <span class="toc-text">获取哈希集中的所有 key&#x2F;value</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A2%9E%E5%8A%A0%E6%8C%87%E5%AE%9A%E5%AD%97%E6%AE%B5%E7%9A%84%E6%95%B0%E5%80%BC"><span class="toc-number">1.3.4.3.6.</span> <span class="toc-text">增加指定字段的数值</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%AA%E8%AE%BE%E7%BD%AE%E5%93%88%E5%B8%8C%E9%9B%86%E4%B8%AD%E4%B8%8D%E5%AD%98%E5%9C%A8%E7%9A%84%E5%AD%97%E6%AE%B5"><span class="toc-number">1.3.4.3.7.</span> <span class="toc-text">只设置哈希集中不存在的字段</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-3"><span class="toc-number">1.3.4.3.8.</span> <span class="toc-text">应用场景</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9B%86%E5%90%88set"><span class="toc-number">1.3.4.4.</span> <span class="toc-text">集合（Set）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E6%A6%82%E8%A7%88-4"><span class="toc-number">1.3.4.4.1.</span> <span class="toc-text">命令概览</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0"><span class="toc-number">1.3.4.4.2.</span> <span class="toc-text">添加元素</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E5%85%83%E7%B4%A0"><span class="toc-number">1.3.4.4.3.</span> <span class="toc-text">遍历元素</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E9%9B%86%E5%90%88%E4%B8%AD%E6%98%AF%E5%90%A6%E6%9C%89%E6%9F%90%E5%85%83%E7%B4%A0"><span class="toc-number">1.3.4.4.4.</span> <span class="toc-text">判断集合中是否有某元素</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0"><span class="toc-number">1.3.4.4.5.</span> <span class="toc-text">删除元素</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E9%9B%86%E5%90%88%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0%E6%95%B0%E9%87%8F"><span class="toc-number">1.3.4.4.6.</span> <span class="toc-text">获取集合中的元素数量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%8E%E9%9B%86%E5%90%88%E4%B8%AD%E9%9A%8F%E6%9C%BAu%E5%B1%95%E7%8E%B0u%E6%8C%87%E5%AE%9A%E4%B8%AA%E6%95%B0%E4%B8%AA%E5%85%83%E7%B4%A0%E4%BD%86%E5%85%83%E7%B4%A0%E4%B8%8D%E5%88%A0%E9%99%A4"><span class="toc-number">1.3.4.4.7.</span> <span class="toc-text">从集合中随机展现指定个数个元素，但元素不删除</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%8E%E9%9B%86%E5%90%88%E4%B8%AD%E9%9A%8F%E6%9C%BAu%E5%BC%B9%E5%87%BAu%E6%8C%87%E5%AE%9A%E4%B8%AA%E6%95%B0%E4%B8%AA%E5%85%83%E7%B4%A0%E4%B8%94%E5%85%83%E7%B4%A0%E5%88%A0%E9%99%A4"><span class="toc-number">1.3.4.4.8.</span> <span class="toc-text">从集合中随机弹出指定个数个元素，且元素删除</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B0%86%E9%9B%86%E5%90%88%E4%B8%AD%E5%B7%B2%E5%AD%98%E5%9C%A8%E7%9A%84%E6%9F%90%E4%B8%AA%E5%80%BC%E7%A7%BB%E5%8A%A8%E5%88%B0%E5%8F%A6%E4%B8%80%E4%B8%AA%E9%9B%86%E5%90%88"><span class="toc-number">1.3.4.4.9.</span> <span class="toc-text">将集合中已存在的某个值移动到另一个集合</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E8%BF%90%E7%AE%97"><span class="toc-number">1.3.4.4.10.</span> <span class="toc-text">集合运算</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%B7%AE%E9%9B%86%E8%BF%90%E7%AE%97"><span class="toc-number">1.3.4.4.10.1.</span> <span class="toc-text">差集运算</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%B9%B6%E9%9B%86%E8%BF%90%E7%AE%97"><span class="toc-number">1.3.4.4.10.2.</span> <span class="toc-text">并集运算</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BA%A4%E9%9B%86%E8%BF%90%E7%AE%97"><span class="toc-number">1.3.4.4.10.3.</span> <span class="toc-text">交集运算</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-4"><span class="toc-number">1.3.4.4.11.</span> <span class="toc-text">应用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%BE%AE%E4%BF%A1%E6%8A%BD%E5%A5%96%E5%B0%8F%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.3.4.4.11.1.</span> <span class="toc-text">微信抽奖小程序</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%BE%AE%E4%BF%A1%E6%9C%8B%E5%8F%8B%E5%9C%88%E7%82%B9%E8%B5%9E%E6%9F%A5%E7%9C%8B%E5%90%8C%E8%B5%9E%E6%9C%8B%E5%8F%8B"><span class="toc-number">1.3.4.4.11.2.</span> <span class="toc-text">微信朋友圈点赞查看同赞朋友</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#qq%E5%86%85%E6%8E%A8%E5%8F%AF%E8%83%BD%E8%AE%A4%E8%AF%86%E7%9A%84%E4%BA%BA"><span class="toc-number">1.3.4.4.11.3.</span> <span class="toc-text">QQ 内推可能认识的人</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88zsetsorted-set"><span class="toc-number">1.3.4.5.</span> <span class="toc-text">有序集合 Zset（sorted set）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E6%A6%82%E8%A7%88-5"><span class="toc-number">1.3.4.5.1.</span> <span class="toc-text">命令概览</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0-2"><span class="toc-number">1.3.4.5.2.</span> <span class="toc-text">添加元素</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E5%85%83%E7%B4%A0-2"><span class="toc-number">1.3.4.5.3.</span> <span class="toc-text">遍历元素</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0%E7%9A%84%E5%88%86%E6%95%B0"><span class="toc-number">1.3.4.5.4.</span> <span class="toc-text">获取元素的分数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88%E7%9A%84%E5%85%83%E7%B4%A0%E6%95%B0%E9%87%8F"><span class="toc-number">1.3.4.5.5.</span> <span class="toc-text">获取有序集合的元素数量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0-2"><span class="toc-number">1.3.4.5.6.</span> <span class="toc-text">删除元素</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A2%9E%E5%8A%A0%E6%9F%90%E4%B8%AA%E5%85%83%E7%B4%A0%E7%9A%84%E5%88%86%E6%95%B0"><span class="toc-number">1.3.4.5.7.</span> <span class="toc-text">增加某个元素的分数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%8E%B7%E5%BE%97%E6%8C%87%E5%AE%9A%E5%88%86%E6%95%B0%E8%8C%83%E5%9B%B4%E5%86%85%E7%9A%84%E5%85%83%E7%B4%A0%E6%95%B0%E9%87%8F"><span class="toc-number">1.3.4.5.8.</span> <span class="toc-text">获得指定分数范围内的元素数量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%B9%E5%87%BA%E4%B8%80%E4%B8%AA%E6%88%96%E5%A4%9A%E4%B8%AA%E5%85%83%E7%B4%A0redis7"><span class="toc-number">1.3.4.5.9.</span> <span class="toc-text">弹出一个或多个元素（Redis7）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0%E7%9A%84%E4%B8%8B%E6%A0%87%E5%80%BC%E5%8D%B3%E6%8E%92%E5%90%8D"><span class="toc-number">1.3.4.5.10.</span> <span class="toc-text">获取元素的下标值（即排名）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-5"><span class="toc-number">1.3.4.5.11.</span> <span class="toc-text">应用场景</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%8D%E5%9B%BEbitmap"><span class="toc-number">1.3.4.6.</span> <span class="toc-text">位图（bitmap）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9C%80%E6%B1%82"><span class="toc-number">1.3.4.6.1.</span> <span class="toc-text">需求</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.3.4.6.2.</span> <span class="toc-text">数据结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">1.3.4.6.3.</span> <span class="toc-text">常用命令</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-6"><span class="toc-number">1.3.4.6.4.</span> <span class="toc-text">应用场景</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%95%B0%E7%BB%9F%E8%AE%A1hyperloglog"><span class="toc-number">1.3.4.7.</span> <span class="toc-text">基数统计（HyperLogLog）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9C%80%E6%B1%82-2"><span class="toc-number">1.3.4.7.1.</span> <span class="toc-text">需求</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#hyperloglog%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.3.4.7.2.</span> <span class="toc-text">HyperLogLog 是什么</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E6%A6%82%E8%A7%88-6"><span class="toc-number">1.3.4.7.3.</span> <span class="toc-text">命令概览</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-7"><span class="toc-number">1.3.4.7.4.</span> <span class="toc-text">应用场景</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%B0%E7%90%86%E7%A9%BA%E9%97%B4geo"><span class="toc-number">1.3.4.8.</span> <span class="toc-text">地理空间（GEO）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E6%A6%82%E8%A7%88%E4%B8%8E%E5%AE%9E%E6%93%8D"><span class="toc-number">1.3.4.8.1.</span> <span class="toc-text">命令概览与实操</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-8"><span class="toc-number">1.3.4.8.2.</span> <span class="toc-text">应用场景</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%81stream"><span class="toc-number">1.3.4.9.</span> <span class="toc-text">流（Stream）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.3.4.9.1.</span> <span class="toc-text">是什么</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%83%BD%E5%B9%B2%E5%98%9B"><span class="toc-number">1.3.4.9.2.</span> <span class="toc-text">能干嘛</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84%E5%92%8C%E5%8E%9F%E7%90%86"><span class="toc-number">1.3.4.9.3.</span> <span class="toc-text">底层结构和原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E7%9A%84%E7%90%86%E8%AE%BA%E4%B8%8E%E5%AE%9E%E6%93%8D"><span class="toc-number">1.3.4.9.4.</span> <span class="toc-text">命令的理论与实操</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%98%9F%E5%88%97%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4%E5%8D%B3%E7%94%9F%E4%BA%A7%E8%80%85%E8%A7%92%E5%BA%A6"><span class="toc-number">1.3.4.9.4.1.</span> <span class="toc-text">队列相关命令（即生产者角度）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%B6%88%E8%B4%B9%E7%BB%84%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4%E5%8D%B3%E6%B6%88%E8%B4%B9%E8%80%85%E8%A7%92%E5%BA%A6"><span class="toc-number">1.3.4.9.4.2.</span> <span class="toc-text">消费组相关命令（即消费者角度）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%9B%9B%E4%B8%AA%E7%89%B9%E6%AE%8A%E7%AC%A6%E5%8F%B7"><span class="toc-number">1.3.4.9.4.3.</span> <span class="toc-text">四个特殊符号</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%BB%BA%E8%AE%AE"><span class="toc-number">1.3.4.9.5.</span> <span class="toc-text">使用建议</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%8D%E5%9F%9Fbitfield"><span class="toc-number">1.3.4.10.</span> <span class="toc-text">位域（Bitfield）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-redis%E6%8C%81%E4%B9%85%E5%8C%96persistence"><span class="toc-number">1.4.</span> <span class="toc-text">4、Redis 持久化（persistence）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%81%E5%8C%96%E5%8F%8C%E9%9B%84"><span class="toc-number">1.4.1.</span> <span class="toc-text">持化双雄</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#rdbredis-database"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">RDB（ R edis D ata B ase）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">1.4.1.1.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%A6%E5%8F%91rdb%E5%BF%AB%E7%85%A7%E7%9A%84%E6%97%B6%E9%97%B4%E9%97%B4%E9%9A%94"><span class="toc-number">1.4.1.1.2.</span> <span class="toc-text">触发 RDB 快照的时间间隔</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#rdb%E5%BF%AB%E7%85%A7%E7%9A%84%E8%A7%A6%E5%8F%91%E6%96%B9%E5%BC%8F"><span class="toc-number">1.4.1.1.3.</span> <span class="toc-text">RDB 快照的触发方式</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E8%A7%A6%E5%8F%91"><span class="toc-number">1.4.1.1.3.1.</span> <span class="toc-text">自动触发</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%89%8B%E5%8A%A8%E8%A7%A6%E5%8F%91"><span class="toc-number">1.4.1.1.3.2.</span> <span class="toc-text">手动触发</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#rdb%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">1.4.1.1.4.</span> <span class="toc-text">RDB 的优缺点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%A3%80%E6%9F%A5-%E6%81%A2%E5%A4%8Ddumprdb%E6%96%87%E4%BB%B6"><span class="toc-number">1.4.1.1.5.</span> <span class="toc-text">如何检查、恢复 dump.rdb 文件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%A6%E5%8F%91rdb%E5%BF%AB%E7%85%A7%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-number">1.4.1.1.6.</span> <span class="toc-text">触发 RDB 快照的情况</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%A6%81%E7%94%A8rdb%E5%BF%AB%E7%85%A7"><span class="toc-number">1.4.1.1.7.</span> <span class="toc-text">如何禁用 RDB 快照</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#rdb%E5%BF%AB%E7%85%A7%E7%9A%84%E9%85%8D%E7%BD%AE%E4%BC%98%E5%8C%96%E9%A1%B9"><span class="toc-number">1.4.1.1.8.</span> <span class="toc-text">RDB 快照的配置优化项</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#rdb%E5%B0%8F%E7%BB%93"><span class="toc-number">1.4.1.1.9.</span> <span class="toc-text">RDB 小结</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#aofappend-only-file"><span class="toc-number">1.4.1.2.</span> <span class="toc-text">AOF（ A ppend O nly F ile）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-2"><span class="toc-number">1.4.1.2.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#aof%E6%8C%81%E4%B9%85%E5%8C%96%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-number">1.4.1.2.2.</span> <span class="toc-text">AOF 持久化的工作流程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#aof%E7%BC%93%E5%86%B2%E5%8C%BA%E7%9A%84%E4%B8%89%E7%A7%8D%E5%86%99%E5%9B%9E%E7%AD%96%E7%95%A5"><span class="toc-number">1.4.1.2.3.</span> <span class="toc-text">AOF 缓冲区的三种写回策略</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%E6%BC%94%E7%A4%BA%E5%92%8C%E8%AF%B4%E6%98%8E"><span class="toc-number">1.4.1.2.4.</span> <span class="toc-text">案例演示和说明</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%B4%E6%98%8E6-vs-7"><span class="toc-number">1.4.1.2.4.1.</span> <span class="toc-text">配置文件说明（6 vs 7）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%AD%A3%E5%B8%B8%E6%81%A2%E5%A4%8Daof%E6%96%87%E4%BB%B6"><span class="toc-number">1.4.1.2.4.2.</span> <span class="toc-text">正常恢复 AOF 文件</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E6%81%A2%E5%A4%8Daof%E6%96%87%E4%BB%B6"><span class="toc-number">1.4.1.2.4.3.</span> <span class="toc-text">异常恢复 AOF 文件</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#aof%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">1.4.1.2.5.</span> <span class="toc-text">AOF 的优缺点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#aof%E9%87%8D%E5%86%99%E6%9C%BA%E5%88%B6"><span class="toc-number">1.4.1.2.6.</span> <span class="toc-text">AOF 重写机制</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-3"><span class="toc-number">1.4.1.2.6.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%E6%BC%94%E7%A4%BA%E5%92%8C%E8%AF%B4%E6%98%8E-2"><span class="toc-number">1.4.1.2.6.2.</span> <span class="toc-text">案例演示和说明</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%87%8D%E5%86%99%E5%8E%9F%E7%90%86"><span class="toc-number">1.4.1.2.6.3.</span> <span class="toc-text">重写原理</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#aof%E7%9A%84%E9%85%8D%E7%BD%AE%E4%BC%98%E5%8C%96%E9%A1%B9"><span class="toc-number">1.4.1.2.7.</span> <span class="toc-text">AOF 的配置优化项</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#aof%E5%B0%8F%E7%BB%93"><span class="toc-number">1.4.1.2.8.</span> <span class="toc-text">AOF 小结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rdb-aof%E6%B7%B7%E5%90%88%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">1.4.2.</span> <span class="toc-text">RDB-AOF 混合持久化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-4"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%B0%E5%BA%95%E9%87%87%E7%94%A8%E5%93%AA%E7%A7%8D%E6%8C%81%E4%B9%85%E5%8C%96%E6%96%B9%E5%BC%8F"><span class="toc-number">1.4.2.2.</span> <span class="toc-text">到底采用哪种持久化方式？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%AF%E7%BC%93%E5%AD%98%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.4.3.</span> <span class="toc-text">纯缓存模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-redis%E4%BA%8B%E5%8A%A1transactions"><span class="toc-number">1.5.</span> <span class="toc-text">5、Redis 事务（Transactions）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#redis%E4%BA%8B%E5%8A%A1%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.5.1.</span> <span class="toc-text">Redis 事务是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redis%E4%BA%8B%E5%8A%A1-vs-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1"><span class="toc-number">1.5.2.</span> <span class="toc-text">Redis 事务 vs 数据库事务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%E8%AF%B4%E6%98%8E"><span class="toc-number">1.5.3.</span> <span class="toc-text">案例说明</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-2"><span class="toc-number">1.5.3.1.</span> <span class="toc-text">常用命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#redis%E4%BA%8B%E5%8A%A1%E4%B8%AD%E7%9A%84%E9%94%99%E8%AF%AF"><span class="toc-number">1.5.3.2.</span> <span class="toc-text">Redis 事务中的错误</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#case1%E6%AD%A3%E5%B8%B8%E6%89%A7%E8%A1%8C"><span class="toc-number">1.5.3.3.</span> <span class="toc-text">case1：正常执行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#case2%E6%94%BE%E5%BC%83%E4%BA%8B%E5%8A%A1"><span class="toc-number">1.5.3.4.</span> <span class="toc-text">case2：放弃事务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#case3%E5%85%A8%E4%BD%93%E8%BF%9E%E5%9D%90"><span class="toc-number">1.5.3.5.</span> <span class="toc-text">case3：全体连坐</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#case4%E5%86%A4%E5%A4%B4%E5%80%BA%E4%B8%BB"><span class="toc-number">1.5.3.6.</span> <span class="toc-text">case4：冤头债主</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#case5watch%E7%9B%91%E6%8E%A7"><span class="toc-number">1.5.3.7.</span> <span class="toc-text">case5：watch 监控</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#watch"><span class="toc-number">1.5.3.7.1.</span> <span class="toc-text">watch</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#unwatch"><span class="toc-number">1.5.3.7.2.</span> <span class="toc-text">unwatch</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">1.5.3.7.3.</span> <span class="toc-text">小结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.5.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-redis%E7%AE%A1%E9%81%93pipeline"><span class="toc-number">1.6.</span> <span class="toc-text">6、Redis 管道（pipeline）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">1.6.1.</span> <span class="toc-text">面试题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-5"><span class="toc-number">1.6.2.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B"><span class="toc-number">1.6.3.</span> <span class="toc-text">案例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-2"><span class="toc-number">1.6.4.</span> <span class="toc-text">总结</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%A1%E9%81%93-vs-%E5%8E%9F%E7%94%9F%E6%89%B9%E9%87%8F%E5%91%BD%E4%BB%A4"><span class="toc-number">1.6.4.1.</span> <span class="toc-text">管道 vs 原生批量命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%A1%E9%81%93-vs-%E4%BA%8B%E5%8A%A1"><span class="toc-number">1.6.4.2.</span> <span class="toc-text">管道 vs 事务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%AE%A1%E9%81%93%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">1.6.4.3.</span> <span class="toc-text">使用管道的注意事项</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-redis%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85pubsub"><span class="toc-number">1.7.</span> <span class="toc-text">7、Redis 发布订阅（pub&#x2F;sub）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-6"><span class="toc-number">1.7.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-3"><span class="toc-number">1.7.2.</span> <span class="toc-text">常用命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9"><span class="toc-number">1.7.3.</span> <span class="toc-text">缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6replica"><span class="toc-number">1.8.</span> <span class="toc-text">8、Redis 主从复制（replica）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-7"><span class="toc-number">1.8.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4"><span class="toc-number">1.8.2.</span> <span class="toc-text">基本命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%E6%BC%94%E7%A4%BA"><span class="toc-number">1.8.3.</span> <span class="toc-text">案例演示</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%B6%E6%9E%84%E8%AF%B4%E6%98%8E"><span class="toc-number">1.8.3.1.</span> <span class="toc-text">架构说明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%A3%E8%AF%80"><span class="toc-number">1.8.3.2.</span> <span class="toc-text">口诀</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84%E6%93%8D%E4%BD%9C%E7%BB%86%E8%8A%82"><span class="toc-number">1.8.3.3.</span> <span class="toc-text">修改配置文件的操作细节</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%843%E6%8B%9B"><span class="toc-number">1.8.3.4.</span> <span class="toc-text">常用的 3 招</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80%E4%B8%BB%E4%BA%8C%E4%BB%8E"><span class="toc-number">1.8.3.4.1.</span> <span class="toc-text">一主二从</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%96%B9%E6%A1%881%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%9B%BA%E5%AE%9A%E5%86%99%E6%AD%BB"><span class="toc-number">1.8.3.4.1.1.</span> <span class="toc-text">方案 1：配置文件固定写死</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E9%97%AE%E9%A2%98%E6%BC%94%E7%A4%BA"><span class="toc-number">1.8.3.4.1.2.</span> <span class="toc-text">主从复制问题演示</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%96%B9%E6%A1%882%E5%91%BD%E4%BB%A4%E6%93%8D%E4%BD%9C%E6%89%8B%E5%8A%A8%E6%8C%87%E5%AE%9A"><span class="toc-number">1.8.3.4.1.3.</span> <span class="toc-text">方案 2：命令操作手动指定</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE-vs-%E5%91%BD%E4%BB%A4"><span class="toc-number">1.8.3.4.1.4.</span> <span class="toc-text">配置 vs 命令</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%96%AA%E7%81%AB%E7%9B%B8%E4%BC%A0"><span class="toc-number">1.8.3.4.2.</span> <span class="toc-text">薪火相传</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%87%AA%E7%AB%8B%E4%B8%BA%E7%8E%8B"><span class="toc-number">1.8.3.4.3.</span> <span class="toc-text">自立为王</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%9A%84%E5%8E%9F%E7%90%86-%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-number">1.8.4.</span> <span class="toc-text">主从复制的原理、工作流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-number">1.8.5.</span> <span class="toc-text">主从复制的缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-redis%E5%93%A8%E5%85%B5sentinel"><span class="toc-number">1.9.</span> <span class="toc-text">9、Redis 哨兵（sentinel）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-8"><span class="toc-number">1.9.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%E6%BC%94%E7%A4%BA-2"><span class="toc-number">1.9.2.</span> <span class="toc-text">案例演示</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%B6%E6%9E%84%E8%AF%B4%E6%98%8E-2"><span class="toc-number">1.9.2.1.</span> <span class="toc-text">架构说明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%A8%E5%85%B5%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6sentinelconf"><span class="toc-number">1.9.2.2.</span> <span class="toc-text">哨兵配置文件 ( sentinel.conf )</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%AC%E6%AC%A1%E6%A1%88%E4%BE%8B%E4%B8%ADsentinelconf%E7%9A%84%E9%80%9A%E7%94%A8%E9%85%8D%E7%BD%AE"><span class="toc-number">1.9.2.3.</span> <span class="toc-text">本次案例中 sentinel.conf 的通用配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%88%E6%B5%8B%E8%AF%95%E6%AD%A3%E5%B8%B8%E7%9A%84%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E4%B8%80%E4%B8%BB%E4%BA%8C%E4%BB%8E"><span class="toc-number">1.9.2.4.</span> <span class="toc-text">先测试正常的主从复制（一主二从）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%A8%E5%85%B5%E6%9D%A5%E4%BA%86"><span class="toc-number">1.9.2.5.</span> <span class="toc-text">哨兵来了！</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#master%E6%8C%82%E4%BA%86"><span class="toc-number">1.9.2.6.</span> <span class="toc-text">master 挂了！</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E6%AF%94%E6%96%B0%E8%80%81master%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">1.9.2.7.</span> <span class="toc-text">对比新老 master 的配置文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E5%A4%87%E6%B3%A8"><span class="toc-number">1.9.2.8.</span> <span class="toc-text">其他备注</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%A8%E5%85%B5%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B-%E9%80%89%E4%B8%BE%E5%8E%9F%E7%90%86"><span class="toc-number">1.9.3.</span> <span class="toc-text">哨兵运行流程、选举原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%A8%E5%85%B5%E4%BD%BF%E7%94%A8%E5%BB%BA%E8%AE%AE"><span class="toc-number">1.9.4.</span> <span class="toc-text">哨兵使用建议</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-redis%E9%9B%86%E7%BE%A4cluster"><span class="toc-number">1.10.</span> <span class="toc-text">10、Redis 集群（cluster）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-9"><span class="toc-number">1.10.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E7%AE%97%E6%B3%95-%E5%88%86%E7%89%87-%E6%A7%BD%E4%BD%8Dslot"><span class="toc-number">1.10.2.</span> <span class="toc-text">集群算法、分片、槽位 slot</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%98%E7%BD%91%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.10.2.1.</span> <span class="toc-text">官网介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%92%E6%A7%BD"><span class="toc-number">1.10.2.2.</span> <span class="toc-text">插槽</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%88%86%E7%89%87"><span class="toc-number">1.10.2.3.</span> <span class="toc-text">数据分片</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E7%89%87%E6%8F%92%E6%A7%BD%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-number">1.10.2.4.</span> <span class="toc-text">分片 + 插槽的优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A7%BD%E4%BD%8D%E6%98%A0%E5%B0%84%E7%9A%843%E7%A7%8D%E6%96%B9%E6%A1%88"><span class="toc-number">1.10.2.5.</span> <span class="toc-text">槽位映射的 3 种方案</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E5%8F%96%E4%BD%99%E5%88%86%E5%8C%BA"><span class="toc-number">1.10.2.5.1.</span> <span class="toc-text">哈希取余分区</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E5%88%86%E5%8C%BA"><span class="toc-number">1.10.2.5.2.</span> <span class="toc-text">一致性哈希算法分区</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E6%A7%BD%E5%88%86%E5%8C%BA"><span class="toc-number">1.10.2.5.3.</span> <span class="toc-text">哈希槽分区 (√)</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B8%BA%E4%BB%80%E4%B9%88redis%E9%9B%86%E7%BE%A4%E7%9A%84%E6%9C%80%E5%A4%A7%E5%93%88%E5%B8%8C%E6%A7%BD%E6%95%B0%E7%9B%AE%E6%98%AF16384%E4%B8%AA"><span class="toc-number">1.10.2.6.</span> <span class="toc-text">经典面试题：为什么 Redis 集群的最大哈希槽数目是 16384 个？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#redis%E9%9B%86%E7%BE%A4%E4%B8%8D%E4%BF%9D%E8%AF%81%E5%BC%BA%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-number">1.10.2.7.</span> <span class="toc-text">Redis 集群不保证强一致性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%E6%BC%94%E7%A4%BA-3"><span class="toc-number">1.10.3.</span> <span class="toc-text">案例演示</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E4%B8%BB3%E4%BB%8Eredis%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AE"><span class="toc-number">1.10.3.1.</span> <span class="toc-text">3 主 3 从 redis 集群配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E4%B8%BB3%E4%BB%8Eredis%E9%9B%86%E7%BE%A4%E8%AF%BB%E5%86%99"><span class="toc-number">1.10.3.2.</span> <span class="toc-text">3 主 3 从 redis 集群读写</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E5%AE%B9%E9%94%99%E5%88%87%E6%8D%A2%E8%BF%81%E7%A7%BBfailover"><span class="toc-number">1.10.3.3.</span> <span class="toc-text">主从容错切换迁移 (failover)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%8B%E5%8A%A8%E5%88%87%E6%8D%A2%E4%B8%BB%E4%BB%8E%E8%B0%83%E6%95%B4%E8%8A%82%E7%82%B9%E4%BB%8E%E5%B1%9E%E5%85%B3%E7%B3%BB"><span class="toc-number">1.10.3.4.</span> <span class="toc-text">手动切换主从 &#x2F; 调整节点从属关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E6%89%A9%E5%AE%B9"><span class="toc-number">1.10.3.5.</span> <span class="toc-text">主从扩容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E7%BC%A9%E5%AE%B9"><span class="toc-number">1.10.3.6.</span> <span class="toc-text">主从缩容</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%AF%86%E5%8D%A0%E4%BD%8D%E7%AC%A6"><span class="toc-number">1.10.4.</span> <span class="toc-text">通识占位符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#crc16%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90"><span class="toc-number">1.10.5.</span> <span class="toc-text">CRC16 算法分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE%E4%B8%8E%E5%91%BD%E4%BB%A4"><span class="toc-number">1.10.6.</span> <span class="toc-text">集群中的常用配置与命令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-springboot%E9%9B%86%E6%88%90redis"><span class="toc-number">1.11.</span> <span class="toc-text">11、SpringBoot 集成 Redis</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B4%E4%BD%93%E6%A6%82%E8%BF%B0"><span class="toc-number">1.11.1.</span> <span class="toc-text">整体概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0java%E8%BF%9E%E6%8E%A5redis%E7%9A%84%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98"><span class="toc-number">1.11.2.</span> <span class="toc-text">本地 Java 连接 Redis 的常见问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E6%88%90jedis"><span class="toc-number">1.11.3.</span> <span class="toc-text">集成 Jedis</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E6%88%90lettuce"><span class="toc-number">1.11.4.</span> <span class="toc-text">集成 lettuce</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E6%88%90redistemplate%E6%8E%A8%E8%8D%90"><span class="toc-number">1.11.5.</span> <span class="toc-text">集成 RedisTemplate（推荐）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E5%8D%95%E6%9C%BA"><span class="toc-number">1.11.5.1.</span> <span class="toc-text">连接单机</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#boot%E6%95%B4%E5%90%88redis%E5%9F%BA%E7%A1%80%E6%BC%94%E7%A4%BA"><span class="toc-number">1.11.5.1.1.</span> <span class="toc-text">boot 整合 Redis 基础演示</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E5%85%B6%E4%BB%96%E5%91%BD%E4%BB%A4api%E5%AE%B6%E5%BA%AD%E4%BD%9C%E4%B8%9A"><span class="toc-number">1.11.5.1.2.</span> <span class="toc-text">调用其他命令 api（家庭作业）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E9%9B%86%E7%BE%A4"><span class="toc-number">1.11.5.2.</span> <span class="toc-text">连接集群</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4%E6%BC%94%E7%A4%BA"><span class="toc-number">1.11.5.2.1.</span> <span class="toc-text">步骤演示</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB%E6%97%B6%E7%9A%84%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98"><span class="toc-number">1.11.5.2.2.</span> <span class="toc-text">故障转移时的经典问题</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7%E7%AF%87"><span class="toc-number">2.</span> <span class="toc-text">高级篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-redis%E7%9A%84%E5%8D%95%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%85%A5%E9%97%A8%E7%AF%87"><span class="toc-number">2.1.</span> <span class="toc-text">1、Redis 的单线程与多线程 (入门篇)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-bigkey"><span class="toc-number">2.2.</span> <span class="toc-text">2、BigKey</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E7%BC%93%E5%AD%98%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4%E6%80%A7%E4%B9%8B%E6%9B%B4%E6%96%B0%E7%AD%96%E7%95%A5%E6%8E%A2%E8%AE%A8"><span class="toc-number">2.3.</span> <span class="toc-text">3、缓存双写一致性之更新策略探讨</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-redis%E4%B8%8Emysql%E6%95%B0%E6%8D%AE%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4%E6%80%A7%E5%B7%A5%E7%A8%8B%E8%90%BD%E5%9C%B0%E6%A1%88%E4%BE%8B"><span class="toc-number">2.4.</span> <span class="toc-text">4、Redis 与 MySQL 数据双写一致性工程落地案例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E6%A1%88%E4%BE%8B%E8%90%BD%E5%9C%B0%E5%AE%9E%E6%88%98bitmaphyperlogloggeo"><span class="toc-number">2.5.</span> <span class="toc-text">5、案例落地实战 bitmap&#x2F;HyperLogLog&#x2F;GEO</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8bloomfilter"><span class="toc-number">2.6.</span> <span class="toc-text">6、布隆过滤器 BloomFilter</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E7%BC%93%E5%AD%98%E9%A2%84%E7%83%AD%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="toc-number">2.7.</span> <span class="toc-text">7、缓存预热 + 缓存雪崩 + 缓存击穿 + 缓存穿透</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E6%89%8B%E5%86%99redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">2.8.</span> <span class="toc-text">8、手写 Redis 分布式锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-redlock%E7%AE%97%E6%B3%95%E5%92%8C%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">2.9.</span> <span class="toc-text">9、Redlock 算法和底层源码分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-redis%E7%BB%8F%E5%85%B8%E4%BA%94%E5%A4%A7%E7%B1%BB%E5%9E%8B%E6%BA%90%E7%A0%81%E5%8F%8A%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.10.</span> <span class="toc-text">10、Redis 经典五大类型源码及底层实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-redis%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BF%AB%E9%AB%98%E6%80%A7%E8%83%BD%E8%AE%BE%E8%AE%A1%E4%B9%8Bepoll%E5%92%8Cio%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90"><span class="toc-number">2.11.</span> <span class="toc-text">11、Redis 为什么快？高性能设计之 epoll 和 IO 多路复用深度解析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-%E7%BB%88%E7%AB%A0%E3%81%AE%E6%80%BB%E7%BB%93"><span class="toc-number">2.12.</span> <span class="toc-text">12、终章の总结</span></a></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/database/redis/Redis-JavaGuide/" rel="bookmark" title="Redis-JavaGuide">Redis-JavaGuide</a></li><li class="active"><a href="/database/redis/%E5%B0%9A%E7%A1%85%E8%B0%B7-%E5%91%A8%E9%98%B3-Redis7/" rel="bookmark" title="Redis7-尚硅谷-周阳">Redis7-尚硅谷-周阳</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="范特东东东" data-src="/images/avatar.jpg"><p class="name" itemprop="name">范特东东东</p><div class="description" itemprop="description"></div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">61</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">19</span> <span class="name">分类</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hqeDE1OQ==" title="https:&#x2F;&#x2F;github.com&#x2F;hjx159"><i class="ic i-github"></i></span> <span class="exturl item xiaohongshu" data-url="aHR0cHM6Ly93d3cueGlhb2hvbmdzaHUuY29tL3VzZXIvcHJvZmlsZS81ZTAyYzhhZDAwMDAwMDAwMDEwMDFmM2U=" title="https:&#x2F;&#x2F;www.xiaohongshu.com&#x2F;user&#x2F;profile&#x2F;5e02c8ad0000000001001f3e"><i class="ic i-xiaohongshu2"></i></span> <span class="exturl item email" data-url="bWFpbHRvOjgxMjE0MzI4MEBxcS5jb20=" title="mailto:812143280@qq.com"><i class="ic i-envelope"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><a href="/categories/photography/" rel="section"><i class="ic i-photography"></i>摄影</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于我</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/database/mongodb/MongoDB-JavaGuide/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/photography/%E4%B8%AD%E6%B3%95%E5%A4%A7%E5%AD%A6%E6%97%A7%E5%9D%80&%E5%8C%97%E6%B5%B7%E5%85%AC%E5%9B%AD/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/java/" title="分类于 Java">Java</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/" title="分类于 Java基础">Java基础</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/java-knowledge/" title="分类于 Java基础-知识点">Java基础-知识点</a></div><span><a href="/java/java-se/java-knowledge/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E5%AE%8B%E7%BA%A2%E5%BA%B7_%E7%AC%AC09%E7%AB%A0_%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/" title="宋红康_第09章_异常处理">宋红康_第09章_异常处理</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/java/" title="分类于 Java">Java</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/" title="分类于 Java基础">Java基础</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/java-excise/" title="分类于 Java基础-真题">Java基础-真题</a></div><span><a href="/java/java-se/java-excise/%E7%AC%AC03%E7%AB%A0%EF%BC%9A%E9%9A%8F%E5%A0%82%E5%A4%8D%E4%B9%A0%E4%B8%8E%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%A2%98%EF%BC%88%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5%EF%BC%89/" title="宋红康_第03章：流程控制语句">宋红康_第03章：流程控制语句</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/java/" title="分类于 Java">Java</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/" title="分类于 Java基础">Java基础</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/java-excise/" title="分类于 Java基础-真题">Java基础-真题</a></div><span><a href="/java/java-se/java-excise/%E7%AC%AC13%E7%AB%A0%EF%BC%9A%E9%9A%8F%E5%A0%82%E5%A4%8D%E4%B9%A0%E4%B8%8E%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%A2%98%EF%BC%88%E6%B3%9B%E5%9E%8B%EF%BC%89/" title="宋红康_第13章：泛型">宋红康_第13章：泛型</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/distributed-microservices/" title="分类于 分布式微服务">分布式微服务</a></div><span><a href="/distributed-microservices/API%E7%BD%91%E5%85%B3&SpringCloud%20Gateway/" title="API网关 &amp; SpringCloud Gateway">API网关 & SpringCloud Gateway</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/java/" title="分类于 Java">Java</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/" title="分类于 Java基础">Java基础</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/java-knowledge/" title="分类于 Java基础-知识点">Java基础-知识点</a></div><span><a href="/java/java-se/java-knowledge/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E5%AE%8B%E7%BA%A2%E5%BA%B7_%E7%AC%AC11%E7%AB%A0_%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%92%8C%E5%9F%BA%E7%A1%80API/" title="宋红康_第11章_常用类和基础API">宋红康_第11章_常用类和基础API</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/java/" title="分类于 Java">Java</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/" title="分类于 Java基础">Java基础</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/java-knowledge/" title="分类于 Java基础-知识点">Java基础-知识点</a></div><span><a href="/java/java-se/java-knowledge/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E5%AE%8B%E7%BA%A2%E5%BA%B7_%E7%AC%AC05%E7%AB%A0_%E6%95%B0%E7%BB%84/" title="宋红康_第05章_数组">宋红康_第05章_数组</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/java/" title="分类于 Java">Java</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/" title="分类于 Java基础">Java基础</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/java-knowledge/" title="分类于 Java基础-知识点">Java基础-知识点</a></div><span><a href="/java/java-se/java-knowledge/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E5%AE%8B%E7%BA%A2%E5%BA%B7_%E7%AC%AC18%E7%AB%A0_JDK8-17%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%88%E4%B8%8A%EF%BC%89/" title="宋红康_第18章_JDK8-17新特性（上）">宋红康_第18章_JDK8-17新特性（上）</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/java/" title="分类于 Java">Java</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/" title="分类于 Java基础">Java基础</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/java-knowledge/" title="分类于 Java基础-知识点">Java基础-知识点</a></div><span><a href="/java/java-se/java-knowledge/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E5%AE%8B%E7%BA%A2%E5%BA%B7_%E7%AC%AC02%E7%AB%A0_%E5%8F%98%E9%87%8F%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6/" title="宋红康_第02章_变量与运算符">宋红康_第02章_变量与运算符</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/java/" title="分类于 Java">Java</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/" title="分类于 Java基础">Java基础</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/java-knowledge/" title="分类于 Java基础-知识点">Java基础-知识点</a></div><span><a href="/java/java-se/java-knowledge/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E5%AE%8B%E7%BA%A2%E5%BA%B7_%E7%AC%AC03%E7%AB%A0_%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/" title="宋红康_第03章_流程控制语句">宋红康_第03章_流程控制语句</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/photography/" title="分类于 摄影">摄影</a></div><span><a href="/photography/%E8%93%9D%E4%B8%8E%E9%BB%84/" title="蓝与黄">蓝与黄</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">范特东东东 @ fantedong</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">1.9m 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">28:35</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"database/redis/尚硅谷-周阳-Redis7/",favicon:{show:"(●´3｀●)欢迎回来",hide:"(〃＞皿＜)你快回来"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hrmmi -->