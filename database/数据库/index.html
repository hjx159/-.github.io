<!-- build time:Sun Nov 12 2023 12:23:26 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="水文 & 摄影" href="http://example.com/rss.xml"><link rel="alternate" type="application/atom+xml" title="水文 & 摄影" href="http://example.com/atom.xml"><link rel="alternate" type="application/json" title="水文 & 摄影" href="http://example.com/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><link rel="canonical" href="http://example.com/database/%E6%95%B0%E6%8D%AE%E5%BA%93/"><title>数据库总结 - 数据库 | phantasy = 水文 & 摄影 = 为了更好地访问，你可能需要一点魔法</title><meta name="generator" content="Hexo 6.3.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">数据库总结</h1><div class="meta"><span class="item" title="创建时间：2023-11-11 11:58:49"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2023-11-11T11:58:49+08:00">2023-11-11</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>50k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>46 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">phantasy</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><img src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/sql-nosql-tushi.png"></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/database/" itemprop="item" rel="index" title="分类于 数据库"><span itemprop="name">数据库</span></a><meta itemprop="position" content="1"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://example.com/database/%E6%95%B0%E6%8D%AE%E5%BA%93/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="范特东东东"><meta itemprop="description" content="为了更好地访问，你可能需要一点魔法, "></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="水文 & 摄影"></span><div class="body md" itemprop="articleBody"><h1 id="基础"><a class="anchor" href="#基础">#</a> 基础</h1><h2 id="数据库基础"><a class="anchor" href="#数据库基础">#</a> 数据库基础</h2><h3 id="什么是数据库-数据库管理系统-数据库系统-数据库管理员"><a class="anchor" href="#什么是数据库-数据库管理系统-数据库系统-数据库管理员">#</a> 什么是数据库，数据库管理系统，数据库系统，数据库管理员？</h3><ul><li><strong>数据库</strong>：数据库 (DataBase 简称 <code>DB</code> ) 就是信息的集合或者说数据库是由数据库管理系统管理的<font color="red">数据的集合</font>。</li><li><strong>数据库管理系统</strong>：数据库管理系统 (Database Management System 简称 <code>DBMS</code> ) 是一种<font color="red">操纵和管理数据库</font>的大型软件，通常用于建立、使用和维护数据库。</li><li><strong>数据库管理员</strong>：数据库管理员 (Database Administrator, 简称 <code>DBA</code> ) 负责<font color="red">全面管理和控制数据库系统</font>。</li><li><strong>数据库系统</strong>：数据库系统 (Data Base System，简称 <code>DBS</code> ) 通常<font color="red">由软件、数据库和数据管理员 (DBA) 组成</font>。</li></ul><h3 id="什么是元组-码-候选码-主码-外码-主属性-非主属性"><a class="anchor" href="#什么是元组-码-候选码-主码-外码-主属性-非主属性">#</a> 什么是元组，码，候选码，主码，外码，主属性，非主属性？</h3><ul><li><strong>元组</strong> ： 元组（ <code>tuple</code> ）是关系数据库中的基本概念，关系是一张表，表中的每行（即数据库中的<font color="red">每条记录</font>）就是一个元组，每列就是一个属性。 在二维表里，元组也称为行。</li><li><strong>码</strong> ：码就是<font color="red">能唯一标识实体的属性</font>，对应表中的列。</li><li><strong>候选码</strong> ：若关系中的某一属性或属性组的值<font color="red">能唯一的标识一个元组，而其任何、子集都不能再标识</font>，则称该属性组为候选码。例如：在学生实体中，“学号” 是能唯一的区分学生实体的，同时又假设 “姓名”、“班级” 的属性组合足以区分学生实体，那么 {学号} 和 {姓名，班级} 都是候选码。</li><li><strong>主码</strong>：主码也叫 <code>主键</code> 。主码是<font color="red">从候选码中选出来的</font>。 一个实体集中<font color="red">只能有一个主码</font>，但可以有多个候选码。</li><li><strong>外码</strong>：外码也叫 <code>外键</code> 。如果一个关系中的一个属性<font color="red">是另外一个关系中的主码</font>则这个属性为外码。</li><li><strong>主属性</strong> ：<font color="red">候选码中出现过的属性</font>称为主属性。比如关系 —— 工人（工号，身份证号，姓名，性别，部门）. 显然工号和身份证号都能够唯一标示这个关系，所以都是候选码。工号、身份证号这两个属性就是主属性。如果主码是一个属性组，那么属性组中的属性都是主属性。</li><li><strong>非主属性：</strong> <font color="red">不包含在任何一个候选码中的属性</font>称为非主属性。比如在关系 —— 学生（学号，姓名，年龄，性别，班级）中，主码是 “学号”，那么其他的 “姓名”、“年龄”、“性别”、“班级” 就都可以称为非主属性。</li></ul><h3 id="什么是-er-图"><a class="anchor" href="#什么是-er-图">#</a> 什么是 ER 图？</h3><p><strong>ER 图</strong> 全称是 <code>Entity Relationship Diagram（实体联系图）</code> ，提供了表示实体类型、属性和联系的方法。</p><p>ER 图由下面 3 个要素组成：</p><ul><li><strong>实体</strong> ：通常是<font color="red">现实世界的业务对象</font>，当然使用一些逻辑对象也可以。比如对于一个校园管理系统，会涉及学生、教师、课程、班级等等实体。在 ER 图中，实体使用<font color="red">矩形框</font>表示。</li><li><strong>属性</strong> ：即某个实体拥有的属性，属性<font color="red">用来描述组成实体的要素</font>，对于产品设计来说可以理解为字段。在 ER 图中，属性使用<font color="red">椭圆形</font>表示。</li><li><strong>联系</strong> ：即<font color="red">实体与实体之间的关系</font>，这个关系不仅有业务关联关系，还能通过数字表示实体之间的数量对照关系。例如，一个班级会有多个学生就是一种实体间的联系。</li></ul><p>下图是一个学生选课的 ER 图，每个学生可以选若干门课程，同一门课程也可以被若干人选择，所以它们之间的关系是多对多（M: N）。另外，还有其他两种实体之间的关系是：1 对 1（1:1）、1 对多（1: N）。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/c745c87f6eda9a439e0eea52012c7f4a.png" alt="学生与课程之间联系的E-R图"></p><h3 id="数据库范式了解吗"><a class="anchor" href="#数据库范式了解吗">#</a> 数据库范式了解吗？</h3><p>数据库范式有 3 种：</p><ul><li>1NF (第一范式)： <code>属性不可再分</code> 。</li><li>2NF (第二范式)：1NF 的基础之上， <code>消除了非主属性对于码的部分函数依赖</code> 。</li><li>3NF (第三范式)：3NF 在 2NF 的基础之上， <code>消除了非主属性对于码的传递函数依赖</code> 。</li></ul><h4 id="1nf第一范式"><a class="anchor" href="#1nf第一范式">#</a> 1NF (第一范式)</h4><p><font color="red">属性（对应于表中的字段）不能再被分割为多个其他的属性了</font>，也就是这个字段只能是一个值，不能再分为多个其他的字段了。<strong>1NF 是所有关系型数据库的最基本要求</strong> ，也就是说关系型数据库中创建的表一定满足第一范式。</p><h4 id="2nf第二范式"><a class="anchor" href="#2nf第二范式">#</a> 2NF (第二范式)</h4><p>2NF 在 1NF 的基础之上，<font color="red">消除了非主属性对于码的<u>部分函数依赖</u></font>。如下图所示，展示了第一范式到第二范式的过渡。第二范式在第一范式的基础上增加了一个列，这个列称为主键，非主属性都依赖于主键。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/bd1d31be3779342427fc9e462bf7f05c.png" alt="第二范式"></p><p>一些重要的概念：</p><ul><li><strong>函数依赖（functional dependency）</strong> ：若在一张表中，<font color="red">在属性（或属性组）X 的值确定的情况下，必定能确定属性 Y 的值</font>，那么就可以说 Y 函数依赖于 X，写作 <code>X → Y</code> 。</li><li><strong>部分函数依赖（partial functional dependency）</strong> ：<font color="red">如果 X→Y，并且存在 X 的一个真子集 X0，使得 X0→Y</font>，则称 Y 对 X 部分函数依赖。比如学生基本信息表 R 中（学号，身份证号，姓名）当然学号属性取值是唯一的，在 R 关系中，（学号，身份证号）-&gt;（姓名），（学号）-&gt;（姓名），（身份证号）-&gt;（姓名）；所以姓名部分函数依赖与（学号，身份证号）；</li><li><strong>完全函数依赖 (Full functional dependency)</strong> ：在一个关系中，<font color="red">若某个非主属性数据项依赖于全部关键字</font>称之为完全函数依赖。比如学生基本信息表 R（学号，班级，姓名）假设不同的班级学号有相同的，班级内学号不能相同，在 R 关系中，（学号，班级）-&gt;（姓名），但是（学号）-&gt;(姓名) 不成立，（班级）-&gt;(姓名) 不成立，所以姓名完全函数依赖与（学号，班级）；</li><li><strong>传递函数依赖 (transitive functional dependency) ** ： <font color="red">在关系模式 R (U) 中，设 X，Y，Z 是 U 的不同的属性子集，如果 X 确定 Y、Y 确定 Z，且有 X 不包含 Y，Y 不确定 X，（X∪Y）∩Z = 空集合，则称 Z 传递函数依赖于 X</font>。传递函数依赖</strong><font color="red">会导致数据冗余和异常</font>**。传递函数依赖的 Y 和 Z 子集往往同属于某一个事物，因此可将其合并放到一个表中。比如在关系 R (学号，姓名，系名，系主任) 中，学号 → 系名，系名 → 系主任，所以存在非主属性系主任对于学号的传递函数依赖。。</li></ul><h4 id="3nf第三范式"><a class="anchor" href="#3nf第三范式">#</a> 3NF (第三范式)</h4><p>3NF 在 2NF 的基础之上，<font color="red">消除了非主属性对于码的<u>传递函数依赖</u></font>。符合 3NF 要求的数据库设计，<font color="red"><strong>基本上解决了数据冗余过大，插入异常，修改异常，删除异常的问题</strong></font>。比如在关系 R (学号，姓名，系名，系主任) 中，学号 → 系名，系名 → 系主任，所以存在非主属性系主任对于学号的传递函数依赖，所以该表的设计，不符合 3NF 的要求。</p><h3 id="主键和外键有什么区别"><a class="anchor" href="#主键和外键有什么区别">#</a> 主键和外键有什么区别？</h3><ul><li><strong>主键 (主码)</strong> ：<ul><li>主键用于<font color="red">唯一标识一个元组</font></li><li><font color="red">不能有重复</font>，<font color="red">不允许为空</font></li><li><font color="red">一个表只能有一个</font>主键</li></ul></li><li><strong>外键 (外码)</strong> ：<ul><li>外键用来<font color="red">和其他表建立联系</font>用，外键<font color="red">是另一表的主键</font></li><li>外键是<font color="red">可以有重复的</font>，<font color="red">可以是空值</font></li><li><font color="red">一个表可以有多个</font>外键</li></ul></li></ul><h3 id="为什么不推荐使用外键与级联"><a class="anchor" href="#为什么不推荐使用外键与级联">#</a> 为什么不推荐使用外键与级联？</h3><p>对于外键和级联，阿里巴巴开发手册这样说到：</p><blockquote><p>【强制】不得使用外键与级联，一切外键概念必须在应用层解决。</p><p>说明：以学生和成绩的关系为例，学生表中的 student_id 是主键，那么成绩表中的 student_id 则为外键。如果更新学生表中的 student_id，同时触发成绩表中的 student_id 更新，即为级联更新。</p><ul><li><font color="red">外键与级联更新适用于单机低并发，不适合分布式、高并发集群</font></li><li><font color="red">级联更新是强阻塞，存在数据库更新风暴的风险</font></li><li><font color="red">外键影响数据库的插入速度</font></li></ul></blockquote><p>为什么不要用外键呢？大部分人可能会这样回答：</p><ol><li><strong>增加了复杂性：</strong><ol><li>每次做<font color="red"> DELETE 或者 UPDATE 都必须考虑外键约束</font>，会导致开发的时候很痛苦，测试数据极为不方便；</li><li><font color="red">外键的主从关系是固定的</font>，假如那天需求有变化，数据库中的这个字段根本不需要和其他表有关联的话就会增加很多麻烦。</li></ol></li><li><strong>对分库分表不友好</strong> ：因为分库分表下<font color="red">外键是无法生效的</font>。</li><li>......</li></ol><p>我个人觉得上面这种回答不是特别的全面，只是说了外键存在的一个常见的问题。实际上，我们知道外键也是有很多好处的，比如：</p><ol><li><strong>保证了数据的一致性和完整性</strong>；</li><li><strong>级联操作方便，减轻了程序代码量</strong>；</li><li>......</li></ol><p>所以说，不要一股脑的就抛弃了外键这个概念，既然它存在就有它存在的道理，<font color="red">如果系统<u>不涉及分库分表</u>，<u>并发量不是很高</u>的情况还是可以考虑使用外键的</font>。</p><h3 id="什么是存储过程"><a class="anchor" href="#什么是存储过程">#</a> 什么是存储过程？</h3><p>我们可以把存储过程看成是 <code>一些 SQL 语句的集合，中间加了点逻辑控制语句</code> 。存储过程在业务比较复杂的时候是非常实用的，比如很多时候我们完成一个操作可能需要写一大串 SQL 语句，这时候我们就可以写有一个存储过程，这样也方便了我们下一次的调用。<font color="red">存储过程一旦调试完成通过后就能稳定运行</font>，另外，<font color="red">使用存储过程比单纯 SQL 语句执行要快，因为存储过程是预编译过的</font>。</p><p>存储过程在互联网公司应用不多，因为<font color="red">存储过程难以调试和扩展，而且没有移植性，还会消耗数据库资源</font>。</p><p>阿里巴巴 Java 开发手册里要求<strong>禁止使用存储过程</strong>。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/0fa082bc4d4f919065767476a41b2156.png" alt="阿里巴巴Java开发手册: 禁止存储过程"></p><h3 id="drop-delete-与-truncate-区别"><a class="anchor" href="#drop-delete-与-truncate-区别">#</a> drop、delete 与 truncate 区别？</h3><h4 id="用法不同"><a class="anchor" href="#用法不同">#</a> 用法不同</h4><ul><li><code>drop</code> (丢弃数据): <code>drop table 表名</code> ，直接将表都删除掉，在<strong>删除表</strong>的时候使用。</li><li><code>truncate</code> (清空数据) : <code>truncate table 表名</code> ，只删除表中的数据，<font color="red">再插入数据的时候自增长 id 又从 1 开始</font>，在<strong>清空表</strong>中数据的时候使用。</li><li><code>delete</code> （删除数据） : <code>delete from 表名 where 列名=值</code> ，<strong>删除某一行</strong>的数据，如果不加 <code>where</code> 子句和 <code>truncate table 表名</code> 作用类似。</li></ul><p>注意：<strong> <code>truncate</code> 和 <code>delete</code> 只删除数据不删除表的结构 (定义)，执行 <code>drop</code> 语句，此表的结构也会删除，也就是执行 <code>drop</code> 之后对应的表不复存在。</strong></p><h4 id="属于不同的数据库语言"><a class="anchor" href="#属于不同的数据库语言">#</a> 属于不同的数据库语言</h4><ul><li><p><code>truncate</code> 和 <code>drop</code> 属于 **DDL (数据定义语言)** 语句，操作立即生效，原数据不放到 rollback segment 中，<font color="red">不能回滚</font>，操作不触发 trigger。</p></li><li><p>而 <code>delete</code> 语句是 **DML (数据库操作语言)** 语句，这个操作会放到 rollback segement 中，<font color="red">可以回滚</font>，事务提交之后才生效。</p></li></ul><p><strong>DML 语句和 DDL 语句区别：</strong></p><ul><li>DML 是数据库操作语言（Data Manipulation Language）的缩写，是指<font color="red">对数据库中表记录的操作</font>，主要包括表记录的插入、更新、删除和查询，是开发人员日常使用最频繁的操作。</li><li>DDL （Data Definition Language）是数据定义语言的缩写，简单来说，就是<font color="red">对数据库内部的对象进行创建、删除、修改</font>的操作语言。</li><li>二者最大区别：<font color="red"> DML 只是对表内部数据的操作，而不涉及到表的定义、结构的修改</font>，更不会涉及到其他对象。DDL 语句更多的被数据库管理员（DBA）所使用，一般的开发人员很少使用。</li></ul><p>另外，由于 <code>select</code> 不会对表进行破坏，所以有的地方也会把 <code>select</code> 单独区分开叫做数据库查询语言 DQL（Data Query Language）。</p><h4 id="执行速度不同"><a class="anchor" href="#执行速度不同">#</a> 执行速度不同</h4><p>一般来说： <code>drop</code> &gt; <code>truncate</code> &gt; <code>delete</code> （这个我没有设计测试过）。</p><ul><li><code>delete</code> 命令执行的时候<font color="red">会产生数据库的 <code>binlog</code> 日志，而日志记录是需要消耗时间的</font>，但是也有个<font color="red">好处是方便数据回滚恢复</font>。</li><li><code>truncate</code> 命令执行的时候<font color="red">不会产生数据库日志</font>，因此比 <code>delete</code> 要快。除此之外，还<font color="red">会把表的自增值重置和索引恢复到初始大小等</font>。</li><li><code>drop</code> 命令会<font color="red">把表占用的空间全部释放掉</font>。</li></ul><p>Tips：你应该更多地关注在使用场景上，而不是执行效率。</p><h3 id="数据库设计通常分为哪几步"><a class="anchor" href="#数据库设计通常分为哪几步">#</a> 数据库设计通常分为哪几步？</h3><ol><li><strong>需求分析</strong>：分析用户的需求，包括数据、功能和性能需求。</li><li><strong>概念结构设计</strong>：主要采用 E-R 模型进行设计，包括画 <code>E-R 图</code> 。</li><li><strong>逻辑结构设计</strong>：通过将 E-R 图转换成 <code>表</code> ，实现从 E-R 模型到关系模型的转换。</li><li><strong>物理结构设计</strong>：主要是为所设计的数据库<font color="red">选择合适的存储结构和存取路径</font>。</li><li><strong>数据库实施</strong>：包括编程、测试和试运行</li><li><strong>数据库的运行和维护</strong>：系统的运行与数据库的日常维护。</li></ol><h2 id="nosql基础"><a class="anchor" href="#nosql基础">#</a> NoSQL 基础</h2><h3 id="nosql-是什么"><a class="anchor" href="#nosql-是什么">#</a> NoSQL 是什么？</h3><p><code>NoSQL（Not Only SQL）非关系型的数据库</code> ，主要针对的是<font color="red">键值、文档、图形类型</font>数据存储。并且，NoSQL 数据库<font color="red">天生支持分布式，数据冗余和数据分片</font>等特性，<font color="red">旨在提供可扩展、高可用、高性能的数据存储解决方案</font>。</p><p>一个常见的误解是 NoSQL 数据库或非关系型数据库不能很好地存储关系型数据。<font color="red">NoSQL 数据库可以存储关系型数据</font>— 它们与关系型数据库的存储方式不同。</p><p>NoSQL 数据库代表：HBase 、Cassandra、MongoDB、Redis。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/sql-nosql-tushi.png" alt="img"></p><h3 id="sql-和-nosql-有什么区别"><a class="anchor" href="#sql-和-nosql-有什么区别">#</a> SQL 和 NoSQL 有什么区别？</h3><table><thead><tr><th style="text-align:left"></th><th>SQL 数据库</th><th>NoSQL 数据库</th></tr></thead><tbody><tr><td style="text-align:left">数据存储模型</td><td><font color="red">结构化存储</font>，具有固定行和列的表格</td><td><font color="red">非结构化存储</font>。文档：JSON 文档，键值：键值对，宽列：包含行和动态列的表，图：节点和边</td></tr><tr><td style="text-align:left">发展历程</td><td>开发于 1970 年代，重点是<font color="red">减少数据重复</font></td><td>开发于 2000 年代后期，重点是<font color="red">提升可扩展性</font>，<font color="red">减少大规模数据的存储成本</font></td></tr><tr><td style="text-align:left">例子</td><td><code>Oracle</code> 、 <code>MySQL</code> 、Microsoft SQL Server 、PostgreSQL</td><td>文档： <code>MongoDB</code> 、CouchDB，键值： <code>Redis</code> 、DynamoDB，宽列：Cassandra 、 <code>HBase</code> ，图表： <code>Neo4j</code> 、 Amazon Neptune、Giraph</td></tr><tr><td style="text-align:left">ACID 属性</td><td>提供<font color="red">原子性、一致性、隔离性、持久性</font>(ACID) 属性</td><td><font color="red">通常不支持 ACID 事务</font>，为了可扩展、高性能进行了权衡，少部分支持比如 MongoDB 。不过，MongoDB 对 ACID 事务 的支持和 MySQL 还是有所区别的。</td></tr><tr><td style="text-align:left">性能</td><td>性能通常取决于磁盘子系统。要获得最佳性能，通常需要<font color="red">优化查询、索引、表结构</font>。</td><td>性能通常由底层硬件集群大小、网络延迟以及调用应用程序来决定。</td></tr><tr><td style="text-align:left">扩展</td><td><font color="red">垂直</font>（使用性能更强大的服务器进行扩展）、读写分离、分库分表</td><td><font color="red">横向</font>（增加服务器的方式横向扩展，通常是基于分片机制）</td></tr><tr><td style="text-align:left">用途</td><td>普通企业级的项目的数据存储</td><td>用途广泛比如图数据库支持分析和遍历连接数据之间的关系、键值数据库可以处理大量数据扩展和极高的状态变化</td></tr><tr><td style="text-align:left">查询语法</td><td><font color="red">结构化查询语言 (SQL)</font></td><td>数据访问语法可能<font color="red">因数据库而异</font></td></tr></tbody></table><h3 id="nosql-数据库有什么优势"><a class="anchor" href="#nosql-数据库有什么优势">#</a> NoSQL 数据库有什么优势？</h3><p>NoSQL 数据库非常适合许多现代应用程序，例如移动、Web 和游戏等应用程序，它们需要灵活、可扩展、高性能和功能强大的数据库以提供卓越的用户体验。</p><ul><li><strong>灵活性：</strong> NoSQL 数据库通常提供灵活的架构，以实现更快速、更多的迭代开发。<font color="red">灵活的数据模型</font>使 NoSQL 数据库成为<font color="red">半结构化和非结构化数据</font>的理想之选。</li><li><strong>可扩展性：</strong> NoSQL 数据库通常被设计为<font color="red">通过使用分布式硬件集群来横向扩展</font>，而不是通过添加昂贵和强大的服务器来纵向扩展。</li><li><strong>高性能：</strong> NoSQL 数据库<font color="red">针对特定的数据模型和访问模式进行了优化</font>，这与尝试使用关系数据库完成类似功能相比可实现更高的性能。</li><li><strong>强大的功能：</strong> NoSQL 数据库提供功能<font color="red">强大的 API 和数据类型</font>，专门针对其各自的数据模型而构建。</li></ul><h3 id="nosql-数据库有哪些类型"><a class="anchor" href="#nosql-数据库有哪些类型">#</a> NoSQL 数据库有哪些类型？</h3><p>NoSQL 数据库主要可以分为下面四种类型：</p><ul><li><strong>键值</strong> ：键值数据库是一种较简单的数据库，其中每个项目都包含键和值。这是极为灵活的 NoSQL 数据库类型，因为应用可以完全控制 value 字段中存储的内容，没有任何限制。 <code>Redis</code> 和 DynanoDB 是两款非常流行的键值数据库。</li><li><strong>文档</strong> ：文档数据库中的数据被存储在类似于 <code>JSON</code> （JavaScript 对象表示法）对象的文档中，非常清晰直观。每个文档包含成对的字段和值。这些值通常可以是各种类型，包括字符串、数字、布尔值、数组或对象等，并且它们的<font color="red">结构通常与开发者在代码中使用的对象保持一致</font>。 <code>MongoDB</code> 就是一款非常流行的文档数据库。</li><li><strong>图形</strong> ：图形数据库旨在轻松构建和运行与高度连接的数据集一起使用的应用程序。图形数据库的典型使用案例包括社交网络、推荐引擎、欺诈检测和知识图形。 <code>Neo4j</code> 和 Giraph 是两款非常流行的图形数据库。</li><li><strong>宽列</strong> ：宽列存储数据库<font color="red">非常适合需要存储大量的数据</font>。Cassandra 和 <code>HBase</code> 是两款非常流行的宽列存储数据库。</li></ul><p>下面这张图片来源于 <span class="exturl" data-url="aHR0cHM6Ly9sZWFybi5taWNyb3NvZnQuY29tL2VuLXVzL2RvdG5ldC9hcmNoaXRlY3R1cmUvY2xvdWQtbmF0aXZlL3JlbGF0aW9uYWwtdnMtbm9zcWwtZGF0YQ==">微软的官方文档 | 关系数据与 NoSQL 数据 open in new window</span>。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/types-of-nosql-datastores.png" alt="NoSQL 数据模型"></p><h2 id="字符集详解"><a class="anchor" href="#字符集详解">#</a> 字符集详解</h2><p>MySQL 字符编码集中有两套 UTF-8 编码实现：<strong> <code>utf8</code> </strong>和 <strong><code>utf8mb4</code> </strong>。</p><p>如果使用 <strong><code>utf8</code> </strong>的话，存储 emoji 符号和一些比较复杂的汉字、繁体字就会出错。</p><p>为什么会这样呢？这篇文章可以从源头给你解答。</p><h3 id="何为字符集"><a class="anchor" href="#何为字符集">#</a> 何为字符集？</h3><p>字符是各种文字和符号的统称，包括各个国家文字、标点符号、表情、数字等等。 <strong>字符集</strong> 就是一系列字符的集合。字符集的种类较多，每个字符集可以表示的字符范围通常不同，就比如说有些字符集是无法表示汉字的。</p><p><strong>计算机只能存储二进制的数据，那英文、汉字、表情等字符应该如何存储呢？</strong></p><p>我们要将这些字符和二进制的数据一一对应起来，比如说字符 “a” 对应 “01100001”，反之，“01100001” 对应 “a”。我们将字符对应二进制数据的过程称为 &quot;<strong> 字符编码</strong> &quot;，反之，二进制数据解析成字符的过程称为 “<strong>字符解码</strong>”。</p><h3 id="有哪些常见的字符集"><a class="anchor" href="#有哪些常见的字符集">#</a> 有哪些常见的字符集？</h3><p>常见的字符集有 ASCII、GB2312、GBK、UTF-8......。</p><p>不同的字符集的主要区别在于：</p><ul><li>可以表示的<font color="red">字符范围</font></li><li><font color="red">编码方式</font></li></ul><h4 id="ascii"><a class="anchor" href="#ascii">#</a> ASCII</h4><p><strong>ASCII</strong> (<strong>A</strong>merican <strong>S</strong>tandard <strong>C</strong>ode for <strong>I</strong>nformation <strong>I</strong>nterchange，美国信息交换标准代码) 是一套主要<font color="red">用于现代美国英语的字符集</font>（这也是 ASCII 字符集的局限性所在）。</p><p><strong>为什么 ASCII 字符集没有考虑到中文等其他字符呢？</strong> 因为计算机是美国人发明的，当时，计算机的发展还处于比较雏形的时代，还未在其他国家大规模使用。因此，美国发布 ASCII 字符集的时候没有考虑兼容其他国家的语言。</p><p>ASCII 字符集至今为止共定义了 128 个字符，其中有 33 个控制字符（比如回车、删除）无法显示。</p><p>一个 ASCII 码长度是<font color="red">一个字节</font>也就是 8 个 bit，比如 “a” 对应的 ASCII 码是 “01100001”。不过，<font color="red">最高位是 0 仅仅作为校验位</font>，其余 7 位使用 0 和 1 进行组合，所以，ASCII 字符集<font color="red">可以定义 128（2^7）个字符</font>。</p><p>由于，ASCII 码可以表示的字符实在是太少了。后来，人们对其进行了扩展得到了 <strong>ASCII 扩展字符集</strong> 。ASCII 扩展字符集使用 8 位（bits）表示一个字符，所以，ASCII 扩展字符集可以定义 256（2^8）个字符。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/c1c6375d08ca268690cef2b13591a5b4.png" alt="ASCII字符编码"></p><h4 id="gb2312"><a class="anchor" href="#gb2312">#</a> GB2312</h4><p>我们上面说了，ASCII 字符集是一种现代美国英语适用的字符集。因此，很多国家都捣鼓了一个适合自己国家语言的字符集。</p><p>GB2312 字符集是一种对汉字比较友好的字符集，共收录<font color="red"> 6700 多个汉字</font>，基本涵盖了绝大部分常用汉字。不过，GB2312 字符集<font color="red">不支持绝大部分的生僻字和繁体字</font>。</p><p>对于<font color="red">英语字符，1 字节编码</font>即可。对于<font color="red">非英字符，2 字节编码</font>。</p><h4 id="gbk"><a class="anchor" href="#gbk">#</a> GBK</h4><p>GBK 字符集可以看作是 GB2312 字符集的扩展，兼容 GB2312 字符集，共收录了<font color="red"> 20000 多个汉字</font>。</p><p>GBK 中 K 是汉语拼音 Kuo Zhan（扩展）中的 “Kuo” 的首字母。</p><h4 id="gb18030"><a class="anchor" href="#gb18030">#</a> GB18030</h4><p>GB18030 完全兼容 GB2312 和 GBK 字符集，纳入中国国内<font color="red">少数民族的文字</font>，且收录了<font color="red">日韩汉字</font>，是目前为止最全面的汉字字符集，共收录<font color="red">汉字 70000 多个</font>。</p><h4 id="big5"><a class="anchor" href="#big5">#</a> BIG5</h4><p>BIG5 主要针对的是<font color="red">繁体中文</font>，收录了 13000 多个汉字。</p><h4 id="unicode-utf-8编码"><a class="anchor" href="#unicode-utf-8编码">#</a> Unicode &amp; <mark>UTF-8 编码</mark></h4><p>为了更加适合本国语言，诞生了很多种字符集。</p><p>我们上面也说了不同的字符集可以表示的字符范围以及编码规则存在差异。这就导致了一个非常严重的问题：<strong>使用错误的编码方式查看一个包含字符的文件就会产生乱码现象。</strong></p><p>就比如说你使用 UTF-8 编码方式打开 GB2312 编码格式的文件就会出现乱码。示例：“牛” 这个汉字 GB2312 编码后的十六进制数值为 “C5A3”，而 “C5A3” 用 UTF-8 解码之后得到的却是 “ţ”。</p><p>你可以通过这个网站在线进行编码和解码：<span class="exturl" data-url="aHR0cHM6Ly93d3cuaGFvbWVpbGkubmV0L0hhblppL1ppRnVCaWFuTWFaaHVhbkh1YW4=">https://www.haomeili.net/HanZi/ZiFuBianMaZhuanHuan</span></p><p><img data-src="https://oss.javaguide.cn/github/javaguide/csdn/836c49b117ee4408871b0020b74c991d.png" alt="img"></p><p>这样我们就搞懂了乱码的本质： <strong>编码和解码时用了不同或者不兼容的字符集</strong> 。</p><p><img data-src="https://oss.javaguide.cn/javaguide/a8808cbabeea49caa3af27d314fa3c02-1.jpg" alt="img"></p><p>为了解决这个问题，人们就想：“如果我们能够有一种字符集将世界上所有的字符都纳入其中就好了！”。</p><p>然后，<strong>Unicode</strong> 带着这个使命诞生了。</p><p>Unicode 字符集中包含了世界上几乎所有已知的字符。不过，Unicode 字符集并没有规定如何存储这些字符（也就是如何使用二进制数据表示这些字符）。</p><p>然后，就有了 <strong>UTF-8</strong>（<strong>8</strong>-bit <strong>U</strong>nicode <strong>T</strong>ransformation <strong>F</strong>ormat）。类似的还有 UTF-16、 UTF-32。</p><p>UTF-8 使用<font color="red"> 1 到 4 个字节</font>为每个字符编码， UTF-16 使用 2 或 4 个字节为每个字符编码，UTF-32 固定位 4 个字节为每个字符编码。</p><p>UTF-8 可以<font color="red">根据不同的符号自动选择编码的长短</font>，像英文字符只需要 1 个字节就够了，这一点 ASCII 字符集一样 。因此，对于英语字符，UTF-8 编码和 ASCII 码是相同的。</p><p>UTF-32 的规则最简单，不过缺陷也比较明显，对于英文字母这类字符消耗的空间是 UTF-8 的 4 倍之多。</p><p><strong>UTF-8</strong> 是目前<font color="red">使用最广</font>的一种字符编码。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/1280px-Utf8webgrowth.svg.png" alt="img"></p><h3 id="mysql-字符集"><a class="anchor" href="#mysql-字符集">#</a> MySQL 字符集</h3><p>MySQL 支持很多种字符编码的方式，比如 UTF-8、GB2312、GBK、BIG5。</p><p>你可以通过 <code>SHOW CHARSET</code> 命令来查看。</p><p><img data-src="https://oss.javaguide.cn/javaguide/image-20211008164229671.png" alt="img"></p><p>通常情况下，我们<font color="red">建议使用 UTF-8 作为默认的字符编码方式</font>。</p><p>不过，这里有一个小坑。</p><p>MySQL 字符编码集中有两套 UTF-8 编码实现：</p><ul><li><strong><code>utf8</code> </strong>： <code>utf8</code> 编码只支持 <code>1-3</code> 个字节 。 在 <code>utf8</code> 编码中，中文是占 3 个字节，其他数字、英文、符号占一个字节。但 emoji 符号占 4 个字节，一些较复杂的文字、繁体字也是 4 个字节。</li><li><strong><code>utf8mb4</code> </strong>： **UTF-8 的完整实现，正版！** 支持 <code>最多使用 4 个字节</code> 表示字符，因此，可以用来存储 emoji 符号。</li></ul><p><strong>为什么有两套 UTF-8 编码实现呢？</strong> 原因如下：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20211008164542347.png" alt="img"></p><p>因此，如果你需要存储 <code>emoji</code> 类型的数据或者一些比较复杂的文字、繁体字到 MySQL 数据库的话，数据库的编码一定要指定为 <code>utf8mb4</code> 而不是 <code>utf8</code> ，要不然存储的时候就会报错了。</p><p>演示一下吧！（环境：MySQL 5.7+）</p><p>建表语句如下，我们指定数据库 CHARSET 为 <code>utf8</code> 。</p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token identifier"><span class="token punctuation">`</span>user<span class="token punctuation">`</span></span> <span class="token punctuation">(</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  <span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">66</span><span class="token punctuation">)</span> <span class="token keyword">CHARACTER</span> <span class="token keyword">SET</span> utf8mb4 <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token identifier"><span class="token punctuation">`</span>name<span class="token punctuation">`</span></span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">33</span><span class="token punctuation">)</span> <span class="token keyword">CHARACTER</span> <span class="token keyword">SET</span> utf8mb4 <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="4"></td><td><pre>  <span class="token identifier"><span class="token punctuation">`</span>phone<span class="token punctuation">`</span></span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">33</span><span class="token punctuation">)</span> <span class="token keyword">CHARACTER</span> <span class="token keyword">SET</span> utf8mb4 <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="5"></td><td><pre>  <span class="token identifier"><span class="token punctuation">`</span>password<span class="token punctuation">`</span></span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span> <span class="token keyword">CHARACTER</span> <span class="token keyword">SET</span> utf8mb4 <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8<span class="token punctuation">;</span></pre></td></tr></table></figure><p>当我们执行下面的 insert 语句插入数据到数据库时，果然报错！</p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>user<span class="token punctuation">`</span></span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span><span class="token punctuation">,</span> <span class="token identifier"><span class="token punctuation">`</span>name<span class="token punctuation">`</span></span><span class="token punctuation">,</span> <span class="token identifier"><span class="token punctuation">`</span>phone<span class="token punctuation">`</span></span><span class="token punctuation">,</span> <span class="token identifier"><span class="token punctuation">`</span>password<span class="token punctuation">`</span></span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">VALUES</span></pre></td></tr><tr><td data-num="3"></td><td><pre>	<span class="token punctuation">(</span><span class="token string">'A00003'</span><span class="token punctuation">,</span> <span class="token string">'guide哥😘😘😘'</span><span class="token punctuation">,</span> <span class="token string">'181631312312'</span><span class="token punctuation">,</span> <span class="token string">'123456'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>报错信息如下：</p><figure class="highlight text"><figcaption data-lang="text"></figcaption><table><tr><td data-num="1"></td><td><pre>Incorrect string value: '\xF0\x9F\x98\x98\xF0\x9F...' for column 'name' at row 1</pre></td></tr></table></figure><h2 id="sql"><a class="anchor" href="#sql">#</a> SQL</h2><h3 id="sql语法基础"><a class="anchor" href="#sql语法基础">#</a> SQL 语法基础</h3><h4 id="基本概念"><a class="anchor" href="#基本概念">#</a> 基本概念</h4><h5 id="数据库术语"><a class="anchor" href="#数据库术语">#</a> 数据库术语</h5><ul><li><code>数据库（database）</code> - 保存有组织的数据的容器（通常是一个文件或一组文件）。</li><li><code>数据表（table）</code> - 某种特定类型数据的结构化清单。</li><li><code>模式（schema）</code> - <font color="red">关于数据库和表的布局及特性的信息</font>。模式<font color="red">定义了数据在表中如何存储</font>，包含存储什么样的数据，数据如何分解，各部分信息如何命名等信息。数据库和表都有模式。</li><li><code>列（column）</code> - 表中的一个字段。所有表都是由一个或多个列组成的。</li><li><code>行（row）</code> - 表中的一个记录。</li><li><code>主键（primary key）</code> - 一列（或一组列），其值能够唯一标识表中每一行。</li></ul><h5 id="sql-语法"><a class="anchor" href="#sql-语法">#</a> SQL 语法</h5><p><code>SQL（Structured Query Language)</code> ，标准 SQL 由 ANSI 标准委员会管理，从而称为 ANSI SQL。各个 DBMS 都有自己的实现，如 PL/SQL、Transact-SQL 等。</p><h6 id="sql-语法结构"><a class="anchor" href="#sql-语法结构">#</a> SQL 语法结构</h6><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/cb684d4c75fc430e92aaee226069c7da%7Etplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>SQL 语法结构包括：</p><ul><li><strong><code>子句</code> </strong>- 是语句和查询的组成成分。（在某些情况下，这些都是可选的。）</li><li><strong><code>表达式</code> </strong>- 可以产生任何标量值，或由列和行的数据库表</li><li><strong><code>谓词</code> </strong>- 给需要评估的 SQL 三值逻辑（3VL）（true/false/unknown）或布尔真值指定条件，并限制语句和查询的效果，或改变程序流程。</li><li><strong><code>查询</code> </strong>- 基于特定条件检索数据。这是 SQL 的一个重要组成部分。</li><li><strong><code>语句</code> </strong>- 可以持久地影响纲要和数据，也可以控制数据库事务、程序流程、连接、会话或诊断。</li></ul><h6 id="sql-语法要点"><a class="anchor" href="#sql-语法要点">#</a> SQL 语法要点</h6><ul><li><strong>SQL 语句不区分大小写</strong>，但是数据库表名、列名和值是否区分，依赖于具体的 DBMS 以及配置。例如： <code>SELECT</code> 与 <code>select</code> 、 <code>Select</code> 是相同的。</li><li><strong>多条 SQL 语句必须以分号（ <code>;</code> ）分隔</strong>。</li><li>处理 SQL 语句时，<strong>所有空格都被忽略</strong>。</li></ul><p>SQL 语句可以写成一行，也可以分写为多行。</p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">-- 一行 SQL 语句</span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">UPDATE</span> <span class="token keyword">user</span> <span class="token keyword">SET</span> username<span class="token operator">=</span><span class="token string">'robot'</span><span class="token punctuation">,</span> password<span class="token operator">=</span><span class="token string">'robot'</span> <span class="token keyword">WHERE</span> username <span class="token operator">=</span> <span class="token string">'root'</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token comment">-- 多行 SQL 语句</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">UPDATE</span> <span class="token keyword">user</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">SET</span> username<span class="token operator">=</span><span class="token string">'robot'</span><span class="token punctuation">,</span> password<span class="token operator">=</span><span class="token string">'robot'</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token keyword">WHERE</span> username <span class="token operator">=</span> <span class="token string">'root'</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>SQL 支持三种注释：</p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">## 注释 1</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment">-- 注释 2</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">/* 注释 3 */</span></pre></td></tr></table></figure><h5 id="sql-分类"><a class="anchor" href="#sql-分类">#</a> SQL 分类</h5><h6 id="数据定义语言ddl"><a class="anchor" href="#数据定义语言ddl">#</a> 数据定义语言（DDL）</h6><p>数据定义语言（Data Definition Language，DDL）是 SQL 语言集中负责数据结构定义与数据库对象定义的语言。</p><p>DDL 的主要功能是<strong>定义数据库对象</strong>。</p><p>DDL 的核心指令是 <code>CREATE</code> 、 <code>ALTER</code> 、 <code>DROP</code> 。</p><h6 id="数据操纵语言dml"><a class="anchor" href="#数据操纵语言dml">#</a> 数据操纵语言（DML）</h6><p>数据操纵语言（Data Manipulation Language, DML）是用于数据库操作，对数据库其中的对象和数据运行访问工作的编程语句。</p><p>DML 的主要功能是 访问数据，因此其语法都是以<strong>读写数据库</strong>为主。</p><p>DML 的核心指令是 <code>INSERT</code> 、 <code>DELETE</code> 、 <code>UPDATE</code> 、 <code>SELECT</code> 。这四个指令合称 CRUD (Create, Read, Update, Delete)，即增删改查。</p><h6 id="事务控制语言tcl"><a class="anchor" href="#事务控制语言tcl">#</a> 事务控制语言（TCL）</h6><p>事务控制语言 (Transaction Control Language, TCL) 用于<strong>管理数据库中的事务</strong>。这些用于管理由 DML 语句所做的更改。它还允许将语句分组为逻辑事务。</p><p>TCL 的核心指令是 <code>COMMIT</code> 、 <code>ROLLBACK</code> 。</p><h6 id="数据控制语言dcl"><a class="anchor" href="#数据控制语言dcl">#</a> 数据控制语言（DCL）</h6><p>数据控制语言 (Data Control Language, DCL) 是一种可对数据访问权进行控制的指令，它可以控制特定用户账户对数据表、查看表、预存程序、用户自定义函数等数据库对象的控制权。</p><p>DCL 的核心指令是 <code>GRANT</code> 、 <code>REVOKE</code> 。</p><p>DCL 以<strong>控制用户的访问权限</strong>为主，因此其指令作法并不复杂，可利用 DCL 控制的权限有： <code>CONNECT</code> 、 <code>SELECT</code> 、 <code>INSERT</code> 、 <code>UPDATE</code> 、 <code>DELETE</code> 、 <code>EXECUTE</code> 、 <code>USAGE</code> 、 <code>REFERENCES</code> 。</p><p>根据不同的 DBMS 以及不同的安全性实体，其支持的权限控制也有所不同。</p><p><strong>我们先来介绍 DML 语句用法。 DML 的主要功能是读写数据库实现增删改查。</strong></p><h4 id="增删改查"><a class="anchor" href="#增删改查">#</a> 增删改查</h4><p>增删改查，又称为 CRUD，数据库基本操作中的基本操作。</p><h5 id="插入数据"><a class="anchor" href="#插入数据">#</a> 插入数据</h5><p><code>INSERT INTO</code> 语句用于向表中插入新记录。</p><p><strong>插入完整的行</strong></p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment"># 插入一行</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token keyword">user</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token string">'root'</span><span class="token punctuation">,</span> <span class="token string">'root'</span><span class="token punctuation">,</span> <span class="token string">'xxxx@163.com'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment"># 插入多行</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token keyword">user</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token string">'root'</span><span class="token punctuation">,</span> <span class="token string">'root'</span><span class="token punctuation">,</span> <span class="token string">'xxxx@163.com'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">,</span> <span class="token string">'user1'</span><span class="token punctuation">,</span> <span class="token string">'user1'</span><span class="token punctuation">,</span> <span class="token string">'xxxx@163.com'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">18</span><span class="token punctuation">,</span> <span class="token string">'user2'</span><span class="token punctuation">,</span> <span class="token string">'user2'</span><span class="token punctuation">,</span> <span class="token string">'xxxx@163.com'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p><strong>插入行的一部分</strong></p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token keyword">user</span><span class="token punctuation">(</span>username<span class="token punctuation">,</span> password<span class="token punctuation">,</span> email<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'admin'</span><span class="token punctuation">,</span> <span class="token string">'admin'</span><span class="token punctuation">,</span> <span class="token string">'xxxx@163.com'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p><strong>插入查询出来的数据</strong></p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token keyword">user</span><span class="token punctuation">(</span>username<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">SELECT</span> name</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">FROM</span> account<span class="token punctuation">;</span></pre></td></tr></table></figure><h5 id="更新数据"><a class="anchor" href="#更新数据">#</a> 更新数据</h5><p><code>UPDATE</code> 语句用于更新表中的记录。</p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">UPDATE</span> <span class="token keyword">user</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">SET</span> username<span class="token operator">=</span><span class="token string">'robot'</span><span class="token punctuation">,</span> password<span class="token operator">=</span><span class="token string">'robot'</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">WHERE</span> username <span class="token operator">=</span> <span class="token string">'root'</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h5 id="删除数据"><a class="anchor" href="#删除数据">#</a> 删除数据</h5><ul><li><code>DELETE</code> 语句用于删除表中的记录。</li><li><code>TRUNCATE TABLE</code> 可以清空表，也就是删除所有行。</li></ul><p><strong>删除表中的指定数据</strong></p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">DELETE</span> <span class="token keyword">FROM</span> <span class="token keyword">user</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">WHERE</span> username <span class="token operator">=</span> <span class="token string">'robot'</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p><strong>清空表中的数据</strong></p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">TRUNCATE</span> <span class="token keyword">TABLE</span> <span class="token keyword">user</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h5 id="查询数据"><a class="anchor" href="#查询数据">#</a> 查询数据</h5><p><code>SELECT</code> 语句用于从数据库中查询数据。</p><p><code>DISTINCT</code> 用于返回唯一不同的值。它<font color="red">作用于所有列</font>，也就是说所有列的值都相同才算相同。</p><p><code>LIMIT</code> 限制返回的行数。可以有两个参数，<strong><font color="red">第一个参数为起始行从 0 开始</font></strong>；<font color="red">第二个参数为返回的总行数</font>。</p><ul><li><code>ASC</code> ：升序（默认）</li><li><code>DESC</code> ：降序</li></ul><p><strong>查询单列</strong></p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">SELECT</span> prod_name</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">FROM</span> products<span class="token punctuation">;</span></pre></td></tr></table></figure><p><strong>查询多列</strong></p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">SELECT</span> prod_id<span class="token punctuation">,</span> prod_name<span class="token punctuation">,</span> prod_price</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">FROM</span> products<span class="token punctuation">;</span></pre></td></tr></table></figure><p><strong>查询所有列</strong></p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">SELECT</span> <span class="token operator">*</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">FROM</span> products<span class="token punctuation">;</span></pre></td></tr></table></figure><p><strong>查询不同的值</strong></p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">SELECT</span> <span class="token keyword">DISTINCT</span> vend_id </pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">FROM</span> products<span class="token punctuation">;</span></pre></td></tr></table></figure><p><strong>限制查询结果</strong></p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">-- 返回前 5 行</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> mytable <span class="token keyword">LIMIT</span> <span class="token number">5</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> mytable <span class="token keyword">LIMIT</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment">-- 返回第 3 ~ 5 行</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> mytable <span class="token keyword">LIMIT</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h4 id="排序"><a class="anchor" href="#排序">#</a> 排序</h4><p><code>order by</code> 用于对结果集按照一个列或者多个列进行排序。 <code>默认升序</code> 对记录进行排序，如果需要按照降序对记录进行排序，可以使用 <code>desc</code> 关键字。</p><p><code>order by</code> 对多列排序的时候，先排序的列放前面，后排序的列放后面。并且，<font color="red">不同的列可以有不同的排序规则</font>。</p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> products</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">ORDER</span> <span class="token keyword">BY</span> prod_price <span class="token keyword">DESC</span><span class="token punctuation">,</span> prod_name <span class="token keyword">ASC</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h4 id="分组"><a class="anchor" href="#分组">#</a> 分组</h4><p><strong><code>group by</code> </strong>：</p><ul><li><code>group by</code> 子句将记录分组到汇总行中。</li><li><code>group by</code> 为每个组返回一个记录。</li><li><code>group by</code> 通常还涉及聚合 <code>count</code> ， <code>max</code> ， <code>sum</code> ， <code>avg</code> 等。</li><li><code>group by</code> 可以按一列或多列进行分组。</li><li><code>group by</code> 按分组字段进行排序后， <code>order by</code> 可以以汇总字段来进行排序。</li></ul><p><strong>分组</strong></p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">SELECT</span> cust_name<span class="token punctuation">,</span> <span class="token function">COUNT</span><span class="token punctuation">(</span>cust_address<span class="token punctuation">)</span> <span class="token keyword">AS</span> addr_num</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">FROM</span> Customers <span class="token keyword">GROUP</span> <span class="token keyword">BY</span> cust_name<span class="token punctuation">;</span></pre></td></tr></table></figure><p><strong>分组后排序</strong></p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">SELECT</span> cust_name<span class="token punctuation">,</span> <span class="token function">COUNT</span><span class="token punctuation">(</span>cust_address<span class="token punctuation">)</span> <span class="token keyword">AS</span> addr_num</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">FROM</span> Customers <span class="token keyword">GROUP</span> <span class="token keyword">BY</span> cust_name</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">ORDER</span> <span class="token keyword">BY</span> cust_name <span class="token keyword">DESC</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p><strong><code>having</code> </strong>：</p><ul><li><code>having</code> <font color="red">用于对汇总的 <code>group by</code> 结果进行过滤</font>。</li><li><code>having</code> 一般都是和 <code>group by</code> 连用。</li><li><code>where</code> 和 <code>having</code> 可以在相同的查询中。</li></ul><p><strong>使用 WHERE 和 HAVING 过滤数据</strong></p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">SELECT</span> cust_name<span class="token punctuation">,</span> <span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> num</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">FROM</span> Customers</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">WHERE</span> cust_email <span class="token operator">IS</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">GROUP</span> <span class="token keyword">BY</span> cust_name</pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">HAVING</span> <span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p><strong><code>having</code> vs <code>where</code> </strong>：</p><ul><li><code>where</code> ：<ul><li><font color="red">过滤指定的<u>行</u></font></li><li><font color="red">后面不能加聚合函数</font>（分组函数）</li><li><font color="red">在 <code>group by</code> 前使用</font></li></ul></li><li><code>having</code> ：<ul><li><font color="red">过滤<u>分组</u></font></li><li>一般都是和 <code>group by</code> 连用，<font color="red">不能单独使用</font></li><li><font color="red">在 <code>group by</code> 之后使用</font></li></ul></li></ul><h4 id="子查询"><a class="anchor" href="#子查询">#</a> 子查询</h4><p>子查询是嵌套在较大查询中的 SQL 查询，也称内部查询或内部选择，包含子查询的语句也称为外部查询或外部选择。简单来说，子查询就是指<font color="red">将一个 <code>select</code> 查询（子查询）的结果作为另一个 SQL 语句（主查询）的<u>数据来源</u>或者<u>判断条件</u></font>。</p><p>子查询可以嵌入 <code>SELECT</code> 、 <code>INSERT</code> 、 <code>UPDATE</code> 和 <code>DELETE</code> 语句中，也可以和 <code>=</code> 、 <code>&lt;</code> 、 <code>&gt;</code> 、 <code>IN</code> 、 <code>BETWEEN</code> 、 <code>EXISTS</code> 等运算符一起使用。</p><p>子查询常用在 <code>WHERE</code> 子句和 <code>FROM</code> 子句后边：</p><ul><li><p>当用于 <strong><code>WHERE</code> </strong>子句后边时，根据不同的运算符，子查询可以返回单行单列、多行单列、单行多列数据。子查询就是要<font color="red">返回能够作为 <code>WHERE</code> 子句查询条件的值</font>。</p><blockquote><p>用于 <code>WHERE</code> 子句的子查询的基本语法如下：</p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">select</span> column_name <span class="token punctuation">[</span><span class="token punctuation">,</span> column_name <span class="token punctuation">]</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">from</span>   table1 <span class="token punctuation">[</span><span class="token punctuation">,</span> table2 <span class="token punctuation">]</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">where</span>  column_name operator</pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token punctuation">(</span><span class="token keyword">select</span> column_name <span class="token punctuation">[</span><span class="token punctuation">,</span> column_name <span class="token punctuation">]</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">from</span> table1 <span class="token punctuation">[</span><span class="token punctuation">,</span> table2 <span class="token punctuation">]</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token punctuation">[</span><span class="token keyword">where</span><span class="token punctuation">]</span><span class="token punctuation">)</span></pre></td></tr></table></figure><ul><li>子查询需要放在括号 <code>( )</code> 内。</li><li><code>operator</code> 表示用于 where 子句的运算符。</li></ul></blockquote></li><li><p>当用于 <strong><code>FROM</code> </strong>子句后边时，一般返回多行多列数据，相当于<font color="red">返回一张临时表</font>，这样才符合 <code>FROM</code> 后面是表的规则。这种做法能够实现<font color="red">多表联合查询</font>。</p><blockquote><p>用于 <code>FROM</code> 子句的子查询的基本语法如下：</p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">select</span> column_name <span class="token punctuation">[</span><span class="token punctuation">,</span> column_name <span class="token punctuation">]</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">from</span> <span class="token punctuation">(</span><span class="token keyword">select</span> column_name <span class="token punctuation">[</span><span class="token punctuation">,</span> column_name <span class="token punctuation">]</span></pre></td></tr><tr><td data-num="3"></td><td><pre>      <span class="token keyword">from</span> table1 <span class="token punctuation">[</span><span class="token punctuation">,</span> table2 <span class="token punctuation">]</span></pre></td></tr><tr><td data-num="4"></td><td><pre>      <span class="token punctuation">[</span><span class="token keyword">where</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">as</span> temp_table_name</pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">where</span>  condition</pre></td></tr></table></figure><p>用于 <code>FROM</code> 的子查询返回的结果相当于一张临时表，所以<strong>需要使用 <code>AS</code> 关键字为该临时表起一个名字</strong>。</p></blockquote></li></ul><blockquote><p>注意：MYSQL 数据库从 4.1 版本才开始支持子查询，早期版本是不支持的。</p></blockquote><p><strong>子查询的子查询</strong></p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">SELECT</span> cust_name<span class="token punctuation">,</span> cust_contact</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">FROM</span> customers</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">WHERE</span> cust_id <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> cust_id</pre></td></tr><tr><td data-num="4"></td><td><pre>                  <span class="token keyword">FROM</span> orders</pre></td></tr><tr><td data-num="5"></td><td><pre>                  <span class="token keyword">WHERE</span> order_num <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> order_num</pre></td></tr><tr><td data-num="6"></td><td><pre>                                      <span class="token keyword">FROM</span> orderitems</pre></td></tr><tr><td data-num="7"></td><td><pre>                                      <span class="token keyword">WHERE</span> prod_id <span class="token operator">=</span> <span class="token string">'RGAN01'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>内部查询首先在其父查询之前执行，以便可以将内部查询的结果传递给外部查询。执行过程可以参考下图：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/c439da1f5d4e4b00bdfa4316b933d764%7Etplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><h5 id="where"><a class="anchor" href="#where">#</a> WHERE</h5><ul><li><code>WHERE</code> 子句用于过滤记录，即缩小访问数据的范围。</li><li><code>WHERE</code> 后跟一个返回 <code>true</code> 或 <code>false</code> 的条件。</li><li><code>WHERE</code> 可以与 <code>SELECT</code> ， <code>UPDATE</code> 和 <code>DELETE</code> 一起使用。</li><li>可以在 <code>WHERE</code> 子句中使用的操作符。</li></ul><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>=</td><td>等于</td></tr><tr><td>&lt;&gt;</td><td>不等于。注释：在 SQL 的一些版本中，该操作符可被写成！=</td></tr><tr><td>&gt;</td><td>大于</td></tr><tr><td>&lt;</td><td>小于</td></tr><tr><td>&gt;=</td><td>大于等于</td></tr><tr><td>&lt;=</td><td>小于等于</td></tr><tr><td>BETWEEN</td><td>在某个范围内</td></tr><tr><td>LIKE</td><td>搜索某种模式</td></tr><tr><td>IN</td><td>指定针对某个列的多个可能值</td></tr></tbody></table><p><strong><code>SELECT</code> 语句中的 <code>WHERE</code> 子句</strong></p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> Customers</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">WHERE</span> cust_name <span class="token operator">=</span> <span class="token string">'Kids Place'</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p><strong><code>UPDATE</code> 语句中的 <code>WHERE</code> 子句</strong></p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">UPDATE</span> Customers</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">SET</span> cust_name <span class="token operator">=</span> <span class="token string">'Jack Jones'</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">WHERE</span> cust_name <span class="token operator">=</span> <span class="token string">'Kids Place'</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p><strong><code>DELETE</code> 语句中的 <code>WHERE</code> 子句</strong></p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">DELETE</span> <span class="token keyword">FROM</span> Customers</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">WHERE</span> cust_name <span class="token operator">=</span> <span class="token string">'Kids Place'</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h5 id="in-和-between"><a class="anchor" href="#in-和-between">#</a> IN 和 BETWEEN</h5><ul><li><code>IN</code> 操作符在 <code>WHERE</code> 子句中使用，作用是<font color="red">在指定的几个特定值中任选一个值</font>。</li><li><code>BETWEEN</code> 操作符在 <code>WHERE</code> 子句中使用，作用是<font color="red">选取介于某个范围内的值</font>。</li></ul><p><strong>IN 示例</strong></p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">SELECT</span> <span class="token operator">*</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">FROM</span> products</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">WHERE</span> vend_id <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token string">'DLL01'</span><span class="token punctuation">,</span> <span class="token string">'BRS01'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p><strong>BETWEEN 示例</strong></p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">SELECT</span> <span class="token operator">*</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">FROM</span> products</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">WHERE</span> prod_price <span class="token operator">BETWEEN</span> <span class="token number">3</span> <span class="token operator">AND</span> <span class="token number">5</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h5 id="and-or-not"><a class="anchor" href="#and-or-not">#</a> AND、OR、NOT</h5><ul><li><code>AND</code> 、 <code>OR</code> 、 <code>NOT</code> 是用于对过滤条件的逻辑处理指令。</li><li><font color="red"><code>AND</code> 优先级高于 <code>OR</code> </font>，为了明确处理顺序，可以使用 <code>()</code> 。</li><li><code>AND</code> 操作符表示左右条件都要满足。</li><li><code>OR</code> 操作符表示左右条件满足任意一个即可。</li><li><code>NOT</code> 操作符用于否定一个条件。</li></ul><p><strong>AND 示例</strong></p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">SELECT</span> prod_id<span class="token punctuation">,</span> prod_name<span class="token punctuation">,</span> prod_price</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">FROM</span> products</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">WHERE</span> vend_id <span class="token operator">=</span> <span class="token string">'DLL01'</span> <span class="token operator">AND</span> prod_price <span class="token operator">&lt;=</span> <span class="token number">4</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p><strong>OR 示例</strong></p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">SELECT</span> prod_id<span class="token punctuation">,</span> prod_name<span class="token punctuation">,</span> prod_price</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">FROM</span> products</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">WHERE</span> vend_id <span class="token operator">=</span> <span class="token string">'DLL01'</span> <span class="token operator">OR</span> vend_id <span class="token operator">=</span> <span class="token string">'BRS01'</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p><strong>NOT 示例</strong></p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">SELECT</span> <span class="token operator">*</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">FROM</span> products</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">WHERE</span> prod_price <span class="token operator">NOT</span> <span class="token operator">BETWEEN</span> <span class="token number">3</span> <span class="token operator">AND</span> <span class="token number">5</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h5 id="like"><a class="anchor" href="#like">#</a> LIKE</h5><ul><li><code>LIKE</code> 操作符在 <code>WHERE</code> 子句中使用，作用是<font color="red">确定字符串是否匹配模式</font>。</li><li>只有字段是文本值时才使用 <code>LIKE</code> 。</li><li><code>LIKE</code> 支持两个通配符匹配选项： <code>%</code> 和 <code>_</code> 。</li><li>不要滥用通配符，通配符位于开头处匹配会非常慢。</li><li><code>%</code> 表示任何字符<font color="red">出现任意次数</font>。</li><li><code>_</code> 表示任何字符<font color="red">出现一次</font>。</li></ul><p><strong>% 示例</strong></p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">SELECT</span> prod_id<span class="token punctuation">,</span> prod_name<span class="token punctuation">,</span> prod_price</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">FROM</span> products</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">WHERE</span> prod_name <span class="token operator">LIKE</span> <span class="token string">'%bean bag%'</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p><strong>_ 示例</strong></p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">SELECT</span> prod_id<span class="token punctuation">,</span> prod_name<span class="token punctuation">,</span> prod_price</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">FROM</span> products</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">WHERE</span> prod_name <span class="token operator">LIKE</span> <span class="token string">'__ inch teddy bear'</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h4 id="连接"><a class="anchor" href="#连接">#</a> 连接</h4><p>JOIN 是 “连接” 的意思，顾名思义，SQL JOIN 子句用于将两个或者多个表联合起来进行查询。</p><p>连接表时<font color="red">需要在每个表中选择一个字段，并对这些字段的值进行比较，值相同的两条记录将合并为一条</font>。<strong>连接表的本质就是将不同表的记录合并起来，形成一张新表。当然，这张新表只是临时的，它仅存在于本次查询期间</strong>。</p><p>使用 <code>JOIN</code> 连接两个表的基本语法如下：</p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">select</span> table1<span class="token punctuation">.</span>column1<span class="token punctuation">,</span> table2<span class="token punctuation">.</span>column2<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">from</span> table1</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">join</span> table2</pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">on</span> table1<span class="token punctuation">.</span>common_column1 <span class="token operator">=</span> table2<span class="token punctuation">.</span>common_column2<span class="token punctuation">;</span></pre></td></tr></table></figure><p><code>table1.common_column1 = table2.common_column2</code> 是<font color="red">连接条件</font>，只有满足此条件的记录才会合并为一行。您可以使用多个运算符来连接表，例如 =、&gt;、&lt;、&lt;&gt;、&lt;=、&gt;=、!=、 <code>between</code> 、 <code>like</code> 或者 <code>not</code> ，但是最常见的是使用 =。</p><p><font color="red">当两个表中有同名的字段时，为了帮助数据库引擎区分是哪个表的字段，在书写同名字段名时需要加上表名</font>。当然，如果书写的字段名在两个表中是唯一的，也可以不使用以上格式，只写字段名即可。</p><p>另外，<font color="red">如果两张表的关联字段名相同，也可以使用 <code>USING</code> 子句来代替 <code>ON</code> </font>，举个例子：</p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment"># join....on</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">select</span> c<span class="token punctuation">.</span>cust_name<span class="token punctuation">,</span> o<span class="token punctuation">.</span>order_num</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">from</span> Customers c</pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">inner</span> <span class="token keyword">join</span> Orders o</pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">on</span> c<span class="token punctuation">.</span>cust_id <span class="token operator">=</span> o<span class="token punctuation">.</span>cust_id</pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">order</span> <span class="token keyword">by</span> c<span class="token punctuation">.</span>cust_name<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token comment"># 如果两张表的关联字段名相同，也可以使用 USING 子句：join....using ()</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">select</span> c<span class="token punctuation">.</span>cust_name<span class="token punctuation">,</span> o<span class="token punctuation">.</span>order_num</pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token keyword">from</span> Customers c</pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token keyword">inner</span> <span class="token keyword">join</span> Orders o</pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token keyword">using</span><span class="token punctuation">(</span>cust_id<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token keyword">order</span> <span class="token keyword">by</span> c<span class="token punctuation">.</span>cust_name<span class="token punctuation">;</span></pre></td></tr></table></figure><p><strong><code>ON</code> 和 <code>WHERE</code> 的区别</strong>：</p><ul><li>连接表时，SQL 会根据连接条件生成一张新的临时表。 <code>ON</code> 就是连接条件，它决定临时表的生成。</li><li><code>WHERE</code> 是在临时表生成以后，再对临时表中的数据进行过滤，生成最终的结果集，这个时候已经没有 JOIN-ON 了。</li></ul><p>所以总结来说就是：<strong>SQL 先根据 ON 生成一张临时表，然后再根据 WHERE 对临时表进行筛选</strong>。</p><p>SQL 允许在 <code>JOIN</code> 左边加上一些修饰性的关键词，从而形成不同类型的连接，如下表所示：</p><table><thead><tr><th>连接类型</th><th>说明</th></tr></thead><tbody><tr><td><code>INNER JOIN</code> 内连接</td><td>（<strong>默认连接方式</strong>）只有当<font color="red">两个表都存在满足条件</font>的记录时才会返回行。</td></tr><tr><td><code>LEFT JOIN</code> / LEFT OUTER JOIN 左 (外) 连接</td><td><font color="red">返回左表中的所有行，即使右表中没有满足条件</font>的行也是如此。</td></tr><tr><td><code>RIGHT JOIN</code> / RIGHT OUTER JOIN 右 (外) 连接</td><td><font color="red">返回右表中的所有行，即使左表中没有满足条件</font>的行也是如此。</td></tr><tr><td><code>FULL JOIN</code> / FULL OUTER JOIN 全 (外) 连接</td><td>只要<font color="red">其中有一个表存在满足条件</font>的记录，就返回行。</td></tr><tr><td><code>SELF JOIN</code></td><td><font color="red">将一个表连接到自身</font>，就像该表是两个表一样。为了区分两个表，在 SQL 语句中需要至少重命名一个表。</td></tr><tr><td><code>CROSS JOIN</code></td><td>交叉连接，从两个或者多个连接表中返回记录集的<font color="red">笛卡尔积</font>。</td></tr></tbody></table><p>下图展示了 LEFT JOIN、RIGHT JOIN、INNER JOIN、OUTER JOIN 相关的 7 种用法。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/701670942f0f45d3a3a2187cd04a12ad~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p>如果不加任何修饰词，只写 <code>JOIN</code> ，那么默认为 <code>INNER JOIIN</code></p><p>对于 <code>INNER JOIIN</code> 来说，还有一种隐式的写法，称为 “<strong>隐式内连接</strong>”，也就是没有 <code>INNER JOIIN</code> 关键字，使用 <code>WHERE</code> 语句实现内连接的功能</p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment"># 隐式内连接</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">select</span> c<span class="token punctuation">.</span>cust_name<span class="token punctuation">,</span> o<span class="token punctuation">.</span>order_num</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">from</span> Customers c<span class="token punctuation">,</span> Orders o</pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">where</span> c<span class="token punctuation">.</span>cust_id <span class="token operator">=</span> o<span class="token punctuation">.</span>cust_id</pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">order</span> <span class="token keyword">by</span> c<span class="token punctuation">.</span>cust_name<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token comment"># 显式内连接</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token keyword">select</span> c<span class="token punctuation">.</span>cust_name<span class="token punctuation">,</span> o<span class="token punctuation">.</span>order_num</pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">from</span> Customers c <span class="token keyword">inner</span> <span class="token keyword">join</span> Orders o</pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token keyword">using</span><span class="token punctuation">(</span>cust_id<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token keyword">order</span> <span class="token keyword">by</span> c<span class="token punctuation">.</span>cust_name<span class="token punctuation">;</span></pre></td></tr></table></figure><h4 id="组合"><a class="anchor" href="#组合">#</a> 组合</h4><p><code>UNION</code> 运算符<font color="red">将两个或更多查询的结果组合起来，并生成一个结果集</font>，其中包含来自 <code>UNION</code> 中参与查询的提取行。</p><p><code>UNION</code> 基本规则：</p><ul><li>所有查询的<font color="red">列数和列顺序必须相同</font>。</li><li>每个查询中涉及表的<font color="red">列的数据类型必须相同或兼容</font>。</li><li>通常<font color="red">返回的列名取自第一个查询</font>。</li></ul><p>默认地， <code>UNION</code> 操作符选取不同的值。如果允许重复的值，请使用 <code>UNION ALL</code> 。</p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">SELECT</span> column_name<span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token keyword">FROM</span> table1</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">UNION</span> <span class="token keyword">ALL</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">SELECT</span> column_name<span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token keyword">FROM</span> table2<span class="token punctuation">;</span></pre></td></tr></table></figure><p><code>UNION</code> 结果集中的列名总是等于 <code>UNION</code> 中第一个 <code>SELECT</code> 语句中的列名。</p><p><code>JOIN</code> vs <code>UNION</code> ：</p><ul><li><code>JOIN</code> 中连接表的列可能不同，但在 <code>UNION</code> 中，所有查询的列数和列顺序必须相同。</li><li><code>UNION</code> 将查询之后的行放在一起（<font color="red">垂直放置</font>），但 <code>JOIN</code> 将查询之后的列放在一起（水平放置），即它构成一个笛卡尔积。</li></ul><h4 id="函数"><a class="anchor" href="#函数">#</a> 函数</h4><p>不同数据库的函数往往各不相同，因此不可移植。本节主要<font color="red">以 MysSQL 的函数为例</font>。</p><h5 id="文本处理"><a class="anchor" href="#文本处理">#</a> 文本处理</h5><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td><code>LEFT()</code> 、 <code>RIGHT()</code></td><td>左边或者右边的字符</td></tr><tr><td><code>LOWER()</code> 、 <code>UPPER()</code></td><td>转换为小写或者大写</td></tr><tr><td><code>LTRIM()</code> 、 <code>RTRIM()</code></td><td>去除左边或者右边的空格</td></tr><tr><td><code>LENGTH()</code></td><td>长度</td></tr><tr><td><code>SOUNDEX()</code></td><td><font color="red">转换为语音值</font></td></tr></tbody></table><p>其中， <strong><code>SOUNDEX()</code> </strong>可以将一个字符串转换为描述其语音表示的字母数字模式。</p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">SELECT</span> <span class="token operator">*</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">FROM</span> mytable</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">WHERE</span> SOUNDEX<span class="token punctuation">(</span>col1<span class="token punctuation">)</span> <span class="token operator">=</span> SOUNDEX<span class="token punctuation">(</span><span class="token string">'apple'</span><span class="token punctuation">)</span></pre></td></tr></table></figure><h5 id="日期和时间处理"><a class="anchor" href="#日期和时间处理">#</a> 日期和时间处理</h5><ul><li>日期格式： <code>YYYY-MM-DD</code></li><li>时间格式： <code>HH:MM:SS</code></li></ul><table><thead><tr><th>函 数</th><th>说 明</th></tr></thead><tbody><tr><td><code>AddDate()</code></td><td>增加一个日期（天、周等）</td></tr><tr><td><code>AddTime()</code></td><td>增加一个时间（时、分等）</td></tr><tr><td><code>CurDate()</code></td><td>返回当前日期</td></tr><tr><td><code>CurTime()</code></td><td>返回当前时间</td></tr><tr><td><code>Date()</code></td><td>返回日期时间的日期部分</td></tr><tr><td><code>DateDiff()</code></td><td>计算两个日期之差</td></tr><tr><td><code>Date_Add()</code></td><td>高度灵活的日期运算函数</td></tr><tr><td><code>Date_Format()</code></td><td>返回一个格式化的日期或时间串</td></tr><tr><td><code>Day()</code></td><td>返回一个日期的天数部分</td></tr><tr><td><code>DayOfWeek()</code></td><td>对于一个日期，返回对应的星期几</td></tr><tr><td><code>Hour()</code></td><td>返回一个时间的小时部分</td></tr><tr><td><code>Minute()</code></td><td>返回一个时间的分钟部分</td></tr><tr><td><code>Month()</code></td><td>返回一个日期的月份部分</td></tr><tr><td><code>Now()</code></td><td>返回当前日期和时间</td></tr><tr><td><code>Second()</code></td><td>返回一个时间的秒部分</td></tr><tr><td><code>Time()</code></td><td>返回一个日期时间的时间部分</td></tr><tr><td><code>Year()</code></td><td>返回一个日期的年份部分</td></tr></tbody></table><h5 id="数值处理"><a class="anchor" href="#数值处理">#</a> 数值处理</h5><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>SIN()</td><td>正弦</td></tr><tr><td>COS()</td><td>余弦</td></tr><tr><td>TAN()</td><td>正切</td></tr><tr><td>ABS()</td><td>绝对值</td></tr><tr><td>SQRT()</td><td>平方根</td></tr><tr><td>MOD()</td><td>余数</td></tr><tr><td>EXP()</td><td>指数</td></tr><tr><td>PI()</td><td>圆周率</td></tr><tr><td>RAND()</td><td>随机数</td></tr></tbody></table><h5 id="汇总"><a class="anchor" href="#汇总">#</a> 汇总</h5><table><thead><tr><th>函 数</th><th>说 明</th></tr></thead><tbody><tr><td><code>AVG()</code></td><td>返回某列的平均值</td></tr><tr><td><code>COUNT()</code></td><td>返回某列的行数</td></tr><tr><td><code>MAX()</code></td><td>返回某列的最大值</td></tr><tr><td><code>MIN()</code></td><td>返回某列的最小值</td></tr><tr><td><code>SUM()</code></td><td>返回某列值之和</td></tr></tbody></table><p><code>AVG()</code> 会忽略 NULL 行。</p><p>使用 <code>DISTINCT</code> 可以让汇总函数值汇总不同的值。</p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">SELECT</span> <span class="token function">AVG</span><span class="token punctuation">(</span><span class="token keyword">DISTINCT</span> col1<span class="token punctuation">)</span> <span class="token keyword">AS</span> avg_col</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">FROM</span> mytable</pre></td></tr></table></figure><p><strong>接下来，我们来介绍 DDL 语句用法。DDL 的主要功能是定义数据库对象（如：数据库、数据表、视图、索引等）</strong></p><h4 id="数据定义"><a class="anchor" href="#数据定义">#</a> <mark>数据定义</mark></h4><h5 id="数据库database"><a class="anchor" href="#数据库database">#</a> 数据库（DATABASE）</h5><h6 id="创建数据库"><a class="anchor" href="#创建数据库">#</a> 创建数据库</h6><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">CREATE</span> <span class="token keyword">DATABASE</span> test<span class="token punctuation">;</span></pre></td></tr></table></figure><h6 id="删除数据库"><a class="anchor" href="#删除数据库">#</a> 删除数据库</h6><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">DROP</span> <span class="token keyword">DATABASE</span> test<span class="token punctuation">;</span></pre></td></tr></table></figure><h6 id="选择数据库"><a class="anchor" href="#选择数据库">#</a> 选择数据库</h6><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">USE</span> test<span class="token punctuation">;</span></pre></td></tr></table></figure><h5 id="数据表table"><a class="anchor" href="#数据表table">#</a> 数据表（TABLE）</h5><h6 id="创建数据表"><a class="anchor" href="#创建数据表">#</a> 创建数据表</h6><p><strong>普通创建</strong></p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token keyword">user</span> <span class="token punctuation">(</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  id <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token keyword">unsigned</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'Id'</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  username <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">64</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token string">'default'</span> <span class="token keyword">COMMENT</span> <span class="token string">'用户名'</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="4"></td><td><pre>  password <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">64</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token string">'default'</span> <span class="token keyword">COMMENT</span> <span class="token string">'密码'</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="5"></td><td><pre>  email <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">64</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token string">'default'</span> <span class="token keyword">COMMENT</span> <span class="token string">'邮箱'</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">)</span> <span class="token keyword">COMMENT</span><span class="token operator">=</span><span class="token string">'用户表'</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p><strong>根据已有的表创建新表</strong></p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> vip_user <span class="token keyword">AS</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> <span class="token keyword">user</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h6 id="删除数据表"><a class="anchor" href="#删除数据表">#</a> 删除数据表</h6><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">DROP</span> <span class="token keyword">TABLE</span> <span class="token keyword">user</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h6 id="修改数据表"><a class="anchor" href="#修改数据表">#</a> 修改数据表</h6><p><strong>添加列</strong></p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> <span class="token keyword">user</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">ADD</span> age <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p><strong>删除列</strong></p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> <span class="token keyword">user</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">DROP</span> <span class="token keyword">COLUMN</span> age<span class="token punctuation">;</span></pre></td></tr></table></figure><p><strong>修改列</strong></p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> <span class="token identifier"><span class="token punctuation">`</span>user<span class="token punctuation">`</span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">MODIFY</span> <span class="token keyword">COLUMN</span> age <span class="token keyword">tinyint</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p><strong>添加主键</strong></p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> <span class="token keyword">user</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">ADD</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p><strong>删除主键</strong></p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> <span class="token keyword">user</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">DROP</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h5 id="视图view"><a class="anchor" href="#视图view">#</a> 视图（VIEW）</h5><p>定义：</p><ul><li>视图是基于 SQL 语句的结果集的可视化的表。</li><li>视图是<strong>虚拟的表，本身不包含数据</strong>，也就不能对其进行索引操作。对视图的操作和对普通表的操作一样。</li></ul><p>作用：</p><ul><li>简化复杂的 SQL 操作，比如复杂的联结；</li><li>只使用实际表的一部分数据；</li><li><font color="red">通过只给用户访问视图的权限，保证数据的安全性</font>；</li><li>更改数据格式和表示。</li></ul><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/ec4c975296ea4a7097879dac7c353878%7Etplv-k3u1fbpfcp-zoom-1.image" alt="mysql视图"></p><h6 id="创建视图"><a class="anchor" href="#创建视图">#</a> 创建视图</h6><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">CREATE</span> <span class="token keyword">VIEW</span> top_10_user_view <span class="token keyword">AS</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">SELECT</span> id<span class="token punctuation">,</span> username</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">FROM</span> <span class="token keyword">user</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">WHERE</span> id <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h6 id="删除视图"><a class="anchor" href="#删除视图">#</a> 删除视图</h6><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">DROP</span> <span class="token keyword">VIEW</span> top_10_user_view<span class="token punctuation">;</span></pre></td></tr></table></figure><h5 id="索引index"><a class="anchor" href="#索引index">#</a> 索引（INDEX）</h5><p><strong>索引是一种用于快速查询和检索数据的数据结构，其本质可以看成是一种排序好的数据结构。</strong></p><p>索引的作用就<font color="red">相当于书的目录</font>。打个比方：我们在查字典的时候，如果没有目录，那我们就只能一页一页的去找我们需要查的那个字，速度很慢。如果有目录了，我们只需要先去目录里查找字的位置，然后直接翻到那一页就行了。</p><p><strong>优点</strong> ：</p><ul><li>使用索引可以大大<font color="red">加快数据的检索速度</font>（大大减少检索的数据量）, 这也是创建索引的最主要的原因。</li><li>通过创建<font color="red">唯一性索引，可以保证数据库表中每一行数据的唯一性</font>。</li></ul><p><strong>缺点</strong> ：</p><ul><li>创建索引和维护索引需要耗费许多时间。当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低 SQL 执行效率。</li><li>索引需要使用物理文件存储，也会耗费一定空间。</li></ul><p>但是，<strong>使用索引一定能提高查询性能吗？</strong></p><p>大多数情况下，索引查询都是比全表扫描要快的。但是<font color="red">如果数据库的数据量不大，那么使用索引也不一定能够带来很大提升</font>。</p><p>关于索引的详细介绍，请看我写的 <span class="exturl" data-url="aHR0cHM6Ly9qYXZhZ3VpZGUuY24vZGF0YWJhc2UvbXlzcWwvbXlzcWwtaW5kZXguaHRtbA==">MySQL 索引详解 open in new window</span> 这篇文章。</p><h6 id="创建索引"><a class="anchor" href="#创建索引">#</a> 创建索引</h6><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">CREATE</span> <span class="token keyword">INDEX</span> user_index</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">ON</span> <span class="token keyword">user</span> <span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h6 id="添加索引"><a class="anchor" href="#添加索引">#</a> 添加索引</h6><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">ALTER</span> <span class="token keyword">table</span> <span class="token keyword">user</span> <span class="token keyword">ADD</span> <span class="token keyword">INDEX</span> user_index<span class="token punctuation">(</span>id<span class="token punctuation">)</span></pre></td></tr></table></figure><h6 id="创建唯一索引"><a class="anchor" href="#创建唯一索引">#</a> 创建唯一索引</h6><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">CREATE</span> <span class="token keyword">UNIQUE</span> <span class="token keyword">INDEX</span> user_index</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">ON</span> <span class="token keyword">user</span> <span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h6 id="删除索引"><a class="anchor" href="#删除索引">#</a> 删除索引</h6><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> <span class="token keyword">user</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">DROP</span> <span class="token keyword">INDEX</span> user_index<span class="token punctuation">;</span></pre></td></tr></table></figure><h5 id="约束"><a class="anchor" href="#约束">#</a> 约束</h5><p>SQL 约束<strong>用于规定表中的数据规则</strong>。</p><p>如果存在违反约束的数据行为，行为会被约束终止。</p><p>约束可以在创建表时规定（通过 CREATE TABLE 语句），或者在表创建之后规定（通过 ALTER TABLE 语句）。</p><p>约束类型：</p><ul><li><code>NOT NULL</code> - 指示某列不能存储 NULL 值。</li><li><code>UNIQUE</code> - 保证某列的每行必须有唯一的值。</li><li><code>PRIMARY KEY</code> - NOT NULL 和 UNIQUE 的结合。确保某列（或两个列多个列的结合）有唯一标识，有助于更容易更快速地找到表中的一个特定的记录。</li><li><code>FOREIGN KEY</code> - 保证一个表中的数据匹配另一个表中的值的参照完整性。</li><li><code>CHECK</code> - 保证列中的值符合指定的条件。</li><li><code>DEFAULT</code> - 规定没有给列赋值时的默认值。</li></ul><p>创建表时使用约束条件：</p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> Users <span class="token punctuation">(</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  Id <span class="token keyword">INT</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token keyword">UNSIGNED</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span> <span class="token keyword">COMMENT</span> <span class="token string">'自增Id'</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  Username <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">64</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">UNIQUE</span> <span class="token keyword">DEFAULT</span> <span class="token string">'default'</span> <span class="token keyword">COMMENT</span> <span class="token string">'用户名'</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="4"></td><td><pre>  Password <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">64</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token string">'default'</span> <span class="token keyword">COMMENT</span> <span class="token string">'密码'</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="5"></td><td><pre>  Email <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">64</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token string">'default'</span> <span class="token keyword">COMMENT</span> <span class="token string">'邮箱地址'</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="6"></td><td><pre>  Enabled <span class="token keyword">TINYINT</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'是否有效'</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="7"></td><td><pre>  <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span>Id<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token operator">=</span><span class="token number">2</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8mb4 <span class="token keyword">COMMENT</span><span class="token operator">=</span><span class="token string">'用户表'</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p><strong>接下来，我们来介绍 TCL 语句用法。TCL 的主要功能是管理数据库中的事务。</strong></p><h4 id="事务处理"><a class="anchor" href="#事务处理">#</a> 事务处理</h4><p>不能回退 <code>SELECT</code> 语句，回退 <code>SELECT</code> 语句也没意义；也不能回退 <code>CREATE</code> 和 <code>DROP</code> 语句。</p><p><strong>MySQL 默认是隐式提交</strong>，每执行一条语句就把这条语句当成一个事务然后进行提交。当出现 <code>START TRANSACTION</code> 语句时，会关闭隐式提交；当 <code>COMMIT</code> 或 <code>ROLLBACK</code> 语句执行后，事务会自动关闭，重新恢复隐式提交。</p><p>通过 <code>set autocommit=0</code> 可以取消自动提交，直到 <code>set autocommit=1</code> 才会提交；<font color="red"> <code>autocommit</code> 标记是针对每个连接而不是针对服务器的</font>。</p><p>指令：</p><ul><li><code>START TRANSACTION</code> - 指令用于<font color="red">标记事务的起始点</font>。</li><li><code>SAVEPOINT</code> - 指令用于<font color="red">创建保留点</font>。</li><li><code>ROLLBACK TO</code> - 指令用于<font color="red">回滚到指定的保留点</font>；如果没有设置保留点，则回退到 <code>START TRANSACTION</code> 语句处。</li><li><code>COMMIT</code> - <font color="red">提交事务</font>。</li></ul><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">-- 开始事务</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">START</span> <span class="token keyword">TRANSACTION</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment">-- 插入操作 A</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>user<span class="token punctuation">`</span></span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'root1'</span><span class="token punctuation">,</span> <span class="token string">'root1'</span><span class="token punctuation">,</span> <span class="token string">'xxxx@163.com'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token comment">-- 创建保留点 updateA</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">SAVEPOINT</span> updateA<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token comment">-- 插入操作 B</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>user<span class="token punctuation">`</span></span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">'root2'</span><span class="token punctuation">,</span> <span class="token string">'root2'</span><span class="token punctuation">,</span> <span class="token string">'xxxx@163.com'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token comment">-- 回滚到保留点 updateA</span></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token keyword">ROLLBACK</span> <span class="token keyword">TO</span> updateA<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token comment">-- 提交事务，只有操作 A 生效</span></pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token keyword">COMMIT</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p><strong>接下来，我们来介绍 DCL 语句用法。DCL 的主要功能是控制用户的访问权限。</strong></p><h4 id="权限控制"><a class="anchor" href="#权限控制">#</a> 权限控制</h4><p>要授予用户帐户权限，可以用 <code>GRANT</code> 命令。有撤销用户的权限，可以用 <code>REVOKE</code> 命令。这里以 MySQl 为例，介绍权限控制实际应用。</p><p><code>GRANT</code> 授予权限语法：</p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">GRANT</span> privilege<span class="token punctuation">,</span><span class="token punctuation">[</span>privilege<span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">ON</span> privilege_level</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">TO</span> <span class="token keyword">user</span> <span class="token punctuation">[</span>IDENTIFIED <span class="token keyword">BY</span> password<span class="token punctuation">]</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">[</span><span class="token keyword">REQUIRE</span> tsl_option<span class="token punctuation">]</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">[</span><span class="token keyword">WITH</span> <span class="token punctuation">[</span>GRANT_OPTION <span class="token operator">|</span> resource_option<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>简单解释一下：</p><ol><li>在 <code>GRANT</code> 关键字后指定一个或多个权限。如果授予用户多个权限，则每个权限由逗号分隔。</li><li><code>ON privilege_level</code> 确定权限应用级别。MySQL 支持 global（ <code>*.*</code> ），database（ <code>database.*</code> ），table（ <code>database.table</code> ）和列级别。如果使用列权限级别，则必须在每个权限之后指定一个或逗号分隔列的列表。</li><li><code>user</code> 是要授予权限的用户。如果用户已存在，则 <code>GRANT</code> 语句将修改其权限。否则， <code>GRANT</code> 语句将创建一个新用户。可选子句 <code>IDENTIFIED BY</code> 允许您为用户设置新的密码。</li><li><code>REQUIRE tsl_option</code> 指定用户是否必须通过 SSL，X059 等安全连接连接到数据库服务器。</li><li>可选 <code>WITH GRANT OPTION</code> 子句允许您授予其他用户或从其他用户中删除您拥有的权限。此外，您可以使用 <code>WITH</code> 子句分配 MySQL 数据库服务器的资源，例如，设置用户每小时可以使用的连接数或语句数。这在 MySQL 共享托管等共享环境中非常有用。</li></ol><p><code>REVOKE</code> 撤销权限语法：</p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">REVOKE</span>   privilege_type <span class="token punctuation">[</span><span class="token punctuation">(</span>column_list<span class="token punctuation">)</span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="2"></td><td><pre>        <span class="token punctuation">[</span><span class="token punctuation">,</span> priv_type <span class="token punctuation">[</span><span class="token punctuation">(</span>column_list<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">ON</span> <span class="token punctuation">[</span>object_type<span class="token punctuation">]</span> privilege_level</pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">FROM</span> <span class="token keyword">user</span> <span class="token punctuation">[</span><span class="token punctuation">,</span> <span class="token keyword">user</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr></table></figure><p>简单解释一下：</p><ol><li>在 <code>REVOKE</code> 关键字后面指定要从用户撤消的权限列表。您需要用逗号分隔权限。</li><li>指定在 <code>ON</code> 子句中撤销特权的特权级别。</li><li>指定要撤消 <code>FROM</code> 子句中的权限的用户帐户。</li></ol><p><code>GRANT</code> 和 <code>REVOKE</code> 可在几个层次上控制访问权限：</p><ul><li>整个服务器，使用 <code>GRANT ALL</code> 和 <code>REVOKE ALL</code> ；</li><li>整个数据库，使用 <code>ON database.*</code> ；</li><li>特定的表，使用 <code>ON database.table</code> ；</li><li>特定的列；</li><li>特定的存储过程。</li></ul><p>新创建的账户没有任何权限。账户用 <code>username@host</code> 的形式定义， <code>username@%</code> 使用的是默认主机名。MySQL 的账户信息保存在 mysql 这个数据库中。</p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">USE</span> mysql<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">SELECT</span> <span class="token keyword">user</span> <span class="token keyword">FROM</span> <span class="token keyword">user</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>下表说明了可用于 <code>GRANT</code> 和 <code>REVOKE</code> 语句的所有允许权限：</p><table><thead><tr><th><strong>特权</strong></th><th><strong>说明</strong></th><th><strong>级别</strong></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td><strong>全局</strong></td><td>数据库</td><td><strong>表</strong></td><td><strong>列</strong></td><td><strong>程序</strong></td><td><strong>代理</strong></td><td></td><td></td></tr><tr><td>ALL [PRIVILEGES]</td><td>授予除 GRANT OPTION 之外的指定访问级别的所有权限</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>ALTER</td><td>允许用户使用 ALTER TABLE 语句</td><td>X</td><td>X</td><td>X</td><td></td><td></td><td></td></tr><tr><td>ALTER ROUTINE</td><td>允许用户更改或删除存储的例程</td><td>X</td><td>X</td><td></td><td></td><td>X</td><td></td></tr><tr><td>CREATE</td><td>允许用户创建数据库和表</td><td>X</td><td>X</td><td>X</td><td></td><td></td><td></td></tr><tr><td>CREATE ROUTINE</td><td>允许用户创建存储的例程</td><td>X</td><td>X</td><td></td><td></td><td></td><td></td></tr><tr><td>CREATE TABLESPACE</td><td>允许用户创建，更改或删除表空间和日志文件组</td><td>X</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>CREATE TEMPORARY TABLES</td><td>允许用户使用 CREATE TEMPORARY TABLE 创建临时表</td><td>X</td><td>X</td><td></td><td></td><td></td><td></td></tr><tr><td>CREATE USER</td><td>允许用户使用 CREATE USER，DROP USER，RENAME USER 和 REVOKE ALL PRIVILEGES 语句。</td><td>X</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>CREATE VIEW</td><td>允许用户创建或修改视图。</td><td>X</td><td>X</td><td>X</td><td></td><td></td><td></td></tr><tr><td>DELETE</td><td>允许用户使用 DELETE</td><td>X</td><td>X</td><td>X</td><td></td><td></td><td></td></tr><tr><td>DROP</td><td>允许用户删除数据库，表和视图</td><td>X</td><td>X</td><td>X</td><td></td><td></td><td></td></tr><tr><td>EVENT</td><td>启用事件计划程序的事件使用。</td><td>X</td><td>X</td><td></td><td></td><td></td><td></td></tr><tr><td>EXECUTE</td><td>允许用户执行存储的例程</td><td>X</td><td>X</td><td>X</td><td></td><td></td><td></td></tr><tr><td>FILE</td><td>允许用户读取数据库目录中的任何文件。</td><td>X</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>GRANT OPTION</td><td>允许用户拥有授予或撤消其他帐户权限的权限。</td><td>X</td><td>X</td><td>X</td><td></td><td>X</td><td>X</td></tr><tr><td>INDEX</td><td>允许用户创建或删除索引。</td><td>X</td><td>X</td><td>X</td><td></td><td></td><td></td></tr><tr><td>INSERT</td><td>允许用户使用 INSERT 语句</td><td>X</td><td>X</td><td>X</td><td>X</td><td></td><td></td></tr><tr><td>LOCK TABLES</td><td>允许用户对具有 SELECT 权限的表使用 LOCK TABLES</td><td>X</td><td>X</td><td></td><td></td><td></td><td></td></tr><tr><td>PROCESS</td><td>允许用户使用 SHOW PROCESSLIST 语句查看所有进程。</td><td>X</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>PROXY</td><td>启用用户代理。</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>REFERENCES</td><td>允许用户创建外键</td><td>X</td><td>X</td><td>X</td><td>X</td><td></td><td></td></tr><tr><td>RELOAD</td><td>允许用户使用 FLUSH 操作</td><td>X</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>REPLICATION CLIENT</td><td>允许用户查询以查看主服务器或从属服务器的位置</td><td>X</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>REPLICATION SLAVE</td><td>允许用户使用复制从属从主服务器读取二进制日志事件。</td><td>X</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>SELECT</td><td>允许用户使用 SELECT 语句</td><td>X</td><td>X</td><td>X</td><td>X</td><td></td><td></td></tr><tr><td>SHOW DATABASES</td><td>允许用户显示所有数据库</td><td>X</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>SHOW VIEW</td><td>允许用户使用 SHOW CREATE VIEW 语句</td><td>X</td><td>X</td><td>X</td><td></td><td></td><td></td></tr><tr><td>SHUTDOWN</td><td>允许用户使用 mysqladmin shutdown 命令</td><td>X</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>SUPER</td><td>允许用户使用其他管理操作，例如 CHANGE MASTER TO，KILL，PURGE BINARY LOGS，SET GLOBAL 和 mysqladmin 命令</td><td>X</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>TRIGGER</td><td>允许用户使用 TRIGGER 操作。</td><td>X</td><td>X</td><td>X</td><td></td><td></td><td></td></tr><tr><td>UPDATE</td><td>允许用户使用 UPDATE 语句</td><td>X</td><td>X</td><td>X</td><td>X</td><td></td><td></td></tr><tr><td>USAGE</td><td>相当于 “没有特权”</td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><h5 id="创建账户"><a class="anchor" href="#创建账户">#</a> 创建账户</h5><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">CREATE</span> <span class="token keyword">USER</span> myuser IDENTIFIED <span class="token keyword">BY</span> <span class="token string">'mypassword'</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h5 id="修改账户名"><a class="anchor" href="#修改账户名">#</a> 修改账户名</h5><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">UPDATE</span> <span class="token keyword">user</span> <span class="token keyword">SET</span> <span class="token keyword">user</span><span class="token operator">=</span><span class="token string">'newuser'</span> <span class="token keyword">WHERE</span> <span class="token keyword">user</span><span class="token operator">=</span><span class="token string">'myuser'</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>FLUSH <span class="token keyword">PRIVILEGES</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h5 id="删除账户"><a class="anchor" href="#删除账户">#</a> 删除账户</h5><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">DROP</span> <span class="token keyword">USER</span> myuser<span class="token punctuation">;</span></pre></td></tr></table></figure><h5 id="查看权限"><a class="anchor" href="#查看权限">#</a> 查看权限</h5><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">SHOW</span> GRANTS <span class="token keyword">FOR</span> myuser<span class="token punctuation">;</span></pre></td></tr></table></figure><h5 id="授予权限"><a class="anchor" href="#授予权限">#</a> 授予权限</h5><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">GRANT</span> <span class="token keyword">SELECT</span><span class="token punctuation">,</span> <span class="token keyword">INSERT</span> <span class="token keyword">ON</span> <span class="token operator">*</span><span class="token punctuation">.</span><span class="token operator">*</span> <span class="token keyword">TO</span> myuser<span class="token punctuation">;</span></pre></td></tr></table></figure><h5 id="删除权限"><a class="anchor" href="#删除权限">#</a> 删除权限</h5><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">REVOKE</span> <span class="token keyword">SELECT</span><span class="token punctuation">,</span> <span class="token keyword">INSERT</span> <span class="token keyword">ON</span> <span class="token operator">*</span><span class="token punctuation">.</span><span class="token operator">*</span> <span class="token keyword">FROM</span> myuser<span class="token punctuation">;</span></pre></td></tr></table></figure><h5 id="更改密码"><a class="anchor" href="#更改密码">#</a> 更改密码</h5><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">SET</span> PASSWORD <span class="token keyword">FOR</span> myuser <span class="token operator">=</span> <span class="token string">'mypass'</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h4 id="存储过程"><a class="anchor" href="#存储过程">#</a> 存储过程</h4><p><img data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/60afdc9c9a594f079727ec64a2e698a3~tplv-k3u1fbpfcp-zoom-1.image" alt="mysql存储过程"></p><p>使用存储过程的好处：</p><ul><li>代码封装，保证了一定的安全性；</li><li><font color="red">代码复用</font>；</li><li>由于是<font color="red">预先编译</font>，因此具有很高的性能。</li></ul><p>创建存储过程：</p><ul><li>命令行中创建存储过程需要自定义分隔符，因为命令行是以 <code>;</code> 为结束符，而存储过程中也包含了分号，因此会错误把这部分分号当成是结束符，造成语法错误。</li><li>包含 <code>in</code> 、 <code>out</code> 和 <code>inout</code> 三种参数。</li><li>给变量赋值都需要用 <code>select into</code> 语句。</li><li>每次只能给一个变量赋值，不支持集合的操作。</li></ul><p>需要注意的是：<strong>阿里巴巴《Java 开发手册》强制禁止使用存储过程。因为存储过程难以调试和扩展，更没有移植性。</strong></p><p><img data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/93a5e011ade4450ebfa5d82057532a49~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>至于到底要不要在项目中使用，还是要看项目实际需求，权衡好利弊即可！</p><h5 id="创建存储过程"><a class="anchor" href="#创建存储过程">#</a> 创建存储过程</h5><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">DROP</span> <span class="token keyword">PROCEDURE</span> <span class="token keyword">IF</span> <span class="token keyword">EXISTS</span> <span class="token identifier"><span class="token punctuation">`</span>proc_adder<span class="token punctuation">`</span></span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">DELIMITER</span> <span class="token punctuation">;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">CREATE</span> <span class="token keyword">DEFINER</span><span class="token operator">=</span><span class="token identifier"><span class="token punctuation">`</span>root<span class="token punctuation">`</span></span><span class="token variable">@`localhost`</span> <span class="token keyword">PROCEDURE</span> <span class="token identifier"><span class="token punctuation">`</span>proc_adder<span class="token punctuation">`</span></span><span class="token punctuation">(</span><span class="token operator">IN</span> a <span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token operator">IN</span> b <span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">OUT</span> sum <span class="token keyword">int</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">BEGIN</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">DECLARE</span> c <span class="token keyword">int</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">if</span> a <span class="token operator">is</span> <span class="token boolean">null</span> <span class="token keyword">then</span> <span class="token keyword">set</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">end</span> <span class="token keyword">if</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">if</span> b <span class="token operator">is</span> <span class="token boolean">null</span> <span class="token keyword">then</span> <span class="token keyword">set</span> b <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token keyword">end</span> <span class="token keyword">if</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token keyword">set</span> sum  <span class="token operator">=</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token keyword">END</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token punctuation">;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token keyword">DELIMITER</span> <span class="token punctuation">;</span></pre></td></tr></table></figure><h5 id="使用存储过程"><a class="anchor" href="#使用存储过程">#</a> 使用存储过程</h5><figure class="highlight less"><figcaption data-lang="less"></figcaption><table><tr><td data-num="1"></td><td><pre>set <span class="token variable">@b</span>=5<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>call proc_<span class="token function">adder</span><span class="token punctuation">(</span>2<span class="token punctuation">,</span><span class="token variable">@b</span><span class="token punctuation">,</span><span class="token variable">@s</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>select <span class="token variable">@s</span> as sum<span class="token punctuation">;</span></pre></td></tr></table></figure><h4 id="游标"><a class="anchor" href="#游标">#</a> 游标</h4><p>游标（cursor）是<strong>一个存储在 DBMS 服务器上的数据库查询，它不是一条 <code>SELECT</code> 语句，而是被该语句检索出来的结果集</strong>。</p><p>在存储过程中使用游标可以对一个结果集进行移动遍历。</p><p>游标主要用于交互式应用，其中用户需要滚动屏幕上的数据，并对数据进行浏览或做出更改。</p><p>使用游标的几个明确步骤：</p><ul><li>在使用游标前，必须<font color="red">声明 (定义)</font>它。这个过程实际上没有检索数据， 它只是定义要使用的 <code>SELECT</code> 语句和游标选项。</li><li>一旦声明，就必须<font color="red">打开游标以供使用</font>。这个过程用前面定义的 SELECT 语句把数据实际检索出来。</li><li>对于填有数据的游标，根据需要<font color="red">取出 (检索) 各行</font>。</li><li>在结束游标使用时，必须<font color="red">关闭游标</font>，可能的话，<font color="red">释放游标</font>(有赖于具体的 DBMS)。</li></ul><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">DELIMITER</span> $</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">CREATE</span>  <span class="token keyword">PROCEDURE</span> getTotal<span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">BEGIN</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">DECLARE</span> total <span class="token keyword">INT</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token comment">-- 创建接收游标数据的变量</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">DECLARE</span> sid <span class="token keyword">INT</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">DECLARE</span> sname <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token comment">-- 创建总数变量</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">DECLARE</span> sage <span class="token keyword">INT</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token comment">-- 创建结束标志变量</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token keyword">DECLARE</span> done <span class="token keyword">INT</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token comment">-- 创建游标</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token keyword">DECLARE</span> cur <span class="token keyword">CURSOR</span> <span class="token keyword">FOR</span> <span class="token keyword">SELECT</span> id<span class="token punctuation">,</span>name<span class="token punctuation">,</span>age <span class="token keyword">from</span> cursor_table <span class="token keyword">where</span> age<span class="token operator">></span><span class="token number">30</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token comment">-- 指定游标循环结束时的返回值</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token keyword">DECLARE</span> <span class="token keyword">CONTINUE</span> <span class="token keyword">HANDLER</span> <span class="token keyword">FOR</span> <span class="token operator">NOT</span> FOUND <span class="token keyword">SET</span> done <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token keyword">SET</span> total <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token keyword">OPEN</span> cur<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token keyword">FETCH</span> cur <span class="token keyword">INTO</span> sid<span class="token punctuation">,</span> sname<span class="token punctuation">,</span> sage<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    <span class="token keyword">WHILE</span><span class="token punctuation">(</span><span class="token operator">NOT</span> done<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    <span class="token keyword">DO</span></pre></td></tr><tr><td data-num="21"></td><td><pre>        <span class="token keyword">SET</span> total <span class="token operator">=</span> total <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>        <span class="token keyword">FETCH</span> cur <span class="token keyword">INTO</span> sid<span class="token punctuation">,</span> sname<span class="token punctuation">,</span> sage<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>    <span class="token keyword">END</span> <span class="token keyword">WHILE</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre></pre></td></tr><tr><td data-num="25"></td><td><pre>    <span class="token keyword">CLOSE</span> cur<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>    <span class="token keyword">SELECT</span> total<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre><span class="token keyword">END</span> $</pre></td></tr><tr><td data-num="28"></td><td><pre><span class="token keyword">DELIMITER</span> <span class="token punctuation">;</span></pre></td></tr><tr><td data-num="29"></td><td><pre></pre></td></tr><tr><td data-num="30"></td><td><pre><span class="token comment">-- 调用存储过程</span></pre></td></tr><tr><td data-num="31"></td><td><pre><span class="token keyword">call</span> getTotal<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h4 id="触发器"><a class="anchor" href="#触发器">#</a> 触发器</h4><p>触发器是一种与表操作有关的数据库对象，<font color="red">当触发器所在表上出现指定事件时，将调用该对象</font>，即表的操作事件触发表上的触发器的执行。</p><p>触发器<font color="red">可以用来进行审计跟踪，把修改记录到另外一张表中</font>。</p><p>使用触发器的优点：</p><ul><li>SQL 触发器提供了另一种检查数据完整性的方法。</li><li>SQL 触发器可以捕获数据库层中业务逻辑中的错误。</li><li>SQL 触发器提供了另一种运行计划任务的方法。通过使用 SQL 触发器，您不必等待运行计划任务，因为在对表中的数据进行更改之前或之后会自动调用触发器。</li><li>SQL 触发器对于审计表中数据的更改非常有用。</li></ul><p>使用触发器的缺点：</p><ul><li>SQL 触发器只能提供扩展验证，并且不能替换所有验证。必须在应用程序层中完成一些简单的验证。例如，您可以使用 JavaScript 在客户端验证用户的输入，或者使用服务器端脚本语言（如 JSP，PHP，<span class="exturl" data-url="aHR0cDovL0FTUC5ORVQ=">ASP.NET</span>，Perl）在服务器端验证用户的输入。</li><li>从客户端应用程序调用和执行 SQL 触发器是不可见的，因此很难弄清楚数据库层中发生了什么。</li><li>SQL 触发器可能会增加数据库服务器的开销。</li></ul><p><strong>MySQL 不允许在触发器中使用 CALL 语句 ，也就是不能调用存储过程</strong>。</p><blockquote><p>注意：在 MySQL 中，分号 <code>;</code> 是语句结束的标识符，遇到分号表示该段语句已经结束，MySQL 可以开始执行了。因此，解释器遇到触发器执行动作中的分号后就开始执行，然后会报错，因为没有找到和 BEGIN 匹配的 END。</p><p>这时就会用到 <code>DELIMITER</code> 命令（DELIMITER 是定界符，分隔符的意思）。它是一条命令，不需要语句结束标识，语法为： <code>DELIMITER new_delemiter</code> 。 <code>new_delemiter</code> 可以设为 1 个或多个长度的符号，默认的是分号 <code>;</code> ，我们可以把它修改为其他符号，如 <code>$</code> - <code>DELIMITER $</code> 。在这之后的语句，以分号结束，解释器不会有什么反应，只有遇到了 <code>$</code> ，才认为是语句结束。注意，使用完之后，我们还应该记得把它给修改回来。</p></blockquote><p>在 MySQL 5.7.2 版之前，可以为每个表定义最多六个触发器。</p><ul><li><code>BEFORE INSERT</code> - 在将数据插入表格之前激活。</li><li><code>AFTER INSERT</code> - 将数据插入表格后激活。</li><li><code>BEFORE UPDATE</code> - 在更新表中的数据之前激活。</li><li><code>AFTER UPDATE</code> - 更新表中的数据后激活。</li><li><code>BEFORE DELETE</code> - 在从表中删除数据之前激活。</li><li><code>AFTER DELETE</code> - 从表中删除数据后激活。</li></ul><p>但是，从 MySQL 版本 5.7.2 + 开始，可以为同一触发事件和操作时间定义多个触发器。</p><p><strong><code>NEW</code> 和 <code>OLD</code> </strong>：</p><ul><li>MySQL 中定义了 <code>NEW</code> 和 <code>OLD</code> 关键字，用来<strong>表示触发器的所在表中，触发了触发器的那一行数据</strong>。</li><li>在 <code>INSERT</code> 型触发器中， <code>NEW</code> 用来表示将要（ <code>BEFORE</code> ）或已经（ <code>AFTER</code> ）插入的新数据；</li><li>在 <code>UPDATE</code> 型触发器中， <code>OLD</code> 用来表示将要或已经被修改的原数据， <code>NEW</code> 用来表示将要或已经修改为的新数据；</li><li>在 <code>DELETE</code> 型触发器中， <code>OLD</code> 用来表示将要或已经被删除的原数据；</li><li>使用方法： <code>NEW.columnName</code> （columnName 为相应数据表某一列名）</li></ul><h5 id="创建触发器"><a class="anchor" href="#创建触发器">#</a> 创建触发器</h5><blockquote><p>提示：为了理解触发器的要点，有必要先了解一下创建触发器的指令。</p></blockquote><p><code>CREATE TRIGGER</code> 指令用于创建触发器。</p><p>语法：</p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">CREATE</span> <span class="token keyword">TRIGGER</span> trigger_name</pre></td></tr><tr><td data-num="2"></td><td><pre>trigger_time</pre></td></tr><tr><td data-num="3"></td><td><pre>trigger_event</pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">ON</span> table_name</pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">FOR EACH ROW</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">BEGIN</span></pre></td></tr><tr><td data-num="7"></td><td><pre>  trigger_statements</pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token keyword">END</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>说明：</p><ul><li><code>trigger_name</code> ：触发器名</li><li><code>trigger_time</code> : 触发器的触发时机。取值为 <code>BEFORE</code> 或 <code>AFTER</code> 。</li><li><code>trigger_event</code> : 触发器的监听事件。取值为 <code>INSERT</code> 、 <code>UPDATE</code> 或 <code>DELETE</code> 。</li><li><code>table_name</code> : 触发器的监听目标。指定在哪张表上建立触发器。</li><li><code>FOR EACH ROW</code> : 行级监视，Mysql 固定写法，其他 DBMS 不同。</li><li><code>trigger_statements</code> : 触发器执行动作。是一条或多条 SQL 语句的列表，列表内的每条语句都必须用分号 <code>;</code> 来结尾。</li></ul><p>当触发器的触发条件满足时，将会执行 <code>BEGIN</code> 和 <code>END</code> 之间的触发器执行动作。</p><p>示例：</p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">DELIMITER</span> $</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">CREATE</span> <span class="token keyword">TRIGGER</span> <span class="token identifier"><span class="token punctuation">`</span>trigger_insert_user<span class="token punctuation">`</span></span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">AFTER</span> <span class="token keyword">INSERT</span> <span class="token keyword">ON</span> <span class="token identifier"><span class="token punctuation">`</span>user<span class="token punctuation">`</span></span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">FOR EACH ROW</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">BEGIN</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>user_history<span class="token punctuation">`</span></span><span class="token punctuation">(</span>user_id<span class="token punctuation">,</span> operate_type<span class="token punctuation">,</span> operate_time<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">VALUES</span> <span class="token punctuation">(</span>NEW<span class="token punctuation">.</span>id<span class="token punctuation">,</span> <span class="token string">'add a user'</span><span class="token punctuation">,</span>  <span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token keyword">END</span> $</pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">DELIMITER</span> <span class="token punctuation">;</span></pre></td></tr></table></figure><h5 id="查看触发器"><a class="anchor" href="#查看触发器">#</a> 查看触发器</h5><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">SHOW</span> TRIGGERS<span class="token punctuation">;</span></pre></td></tr></table></figure><h5 id="删除触发器"><a class="anchor" href="#删除触发器">#</a> 删除触发器</h5><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">DROP</span> <span class="token keyword">TRIGGER</span> <span class="token keyword">IF</span> <span class="token keyword">EXISTS</span> trigger_insert_user<span class="token punctuation">;</span></pre></td></tr></table></figure><h3 id="sql常见面试题"><a class="anchor" href="#sql常见面试题">#</a> SQL 常见面试题</h3><h1 id="mysql"><a class="anchor" href="#mysql">#</a> MySQL</h1><h2 id="mysql常见面试题"><a class="anchor" href="#mysql常见面试题">#</a> MySQL 常见面试题</h2><h3 id="mysql基础"><a class="anchor" href="#mysql基础">#</a> MySQL 基础</h3><h4 id="什么是关系型数据库"><a class="anchor" href="#什么是关系型数据库">#</a> 什么是关系型数据库？</h4><p>顾名思义， <code>关系型数据库（RDBMS，Relational Database Management System）</code> 就是<font color="red">一种建立在<u>关系模型</u>的基础上的数据库</font>。关系模型表明了数据库中所存储的<font color="red">数据之间的联系（一对一、一对多、多对多）</font>。</p><p>关系型数据库中，我们的数据都被存放在了各种表中（比如用户表），表中的每一行就存放着一条数据（比如一个用户的信息）。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/5e3c1a71724a38245aa43b02_99bf70d46cc247be878de9d3a88f0c44.png" alt="关系型数据库表关系"></p><p>大部分关系型数据库都使用 SQL 来操作数据库中的数据。并且，大部分关系型数据库都支持<font color="red">事务的四大特性 (ACID)</font>。</p><p>常见的关系型数据库：MySQL、PostgreSQL、Oracle、SQL Server、SQLite（微信本地的聊天记录的存储就是用的 SQLite） ......。</p><h4 id="什么是-sql"><a class="anchor" href="#什么是-sql">#</a> 什么是 SQL？</h4><p>SQL 是一种 <code>结构化查询语言(Structured Query Language)</code> ，专门用来与数据库打交道，目的是提供一种<font color="red">从数据库中读写数据</font>的简单有效的方法。</p><p>几乎所有的主流关系数据库都支持 SQL ，适用性非常强。并且，一些非关系型数据库也兼容 SQL 或者使用的是类似于 SQL 的查询语言。</p><p>SQL 可以帮助我们：</p><ul><li>新建数据库、数据表、字段；</li><li>在数据库中增加，删除，修改，查询数据；</li><li>新建视图、函数、存储过程；</li><li>对数据库中的数据进行简单的数据分析；</li><li>搭配 Hive，Spark SQL 做大数据；</li><li>搭配 SQLFlow 做机器学习；</li><li>......</li></ul><h4 id="什么是-mysql"><a class="anchor" href="#什么是-mysql">#</a> 什么是 MySQL？</h4><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/20210327143351823.png" alt="img"></p><p><strong>MySQL 是一种关系型数据库，主要用于持久化存储我们的系统中的一些数据比如用户信息。</strong></p><p>由于 MySQL 是开源免费并且比较成熟的数据库，因此，MySQL 被大量使用在各种系统中。任何人都可以在 GPL (General Public License) 的许可下下载并根据个性化的需要对其进行修改。MySQL 的默认端口号是<strong> 3306</strong>。</p><h4 id="mysql-有什么优点"><a class="anchor" href="#mysql-有什么优点">#</a> MySQL 有什么优点？</h4><p>这个问题本质上是在问 MySQL 如此流行的原因。</p><p>MySQL 主要具有下面这些优点：</p><ol><li>成熟稳定，功能完善。</li><li>开源免费。</li><li>文档丰富，既有详细的官方文档，又有非常多优质文章可供参考学习。</li><li>开箱即用，操作简单，维护成本低。</li><li>兼容性好，支持常见的操作系统，支持多种开发语言。</li><li>社区活跃，生态完善。</li><li><strong>事务支持</strong>优秀， InnoDB 存储引擎默认使用 REPEATABLE-READ 并不会有任何性能损失，并且 InnoDB 实现的 REPEATABLE-READ 隔离级别其实是可以解决幻读问题发生的。</li><li>支持<strong>分库分表、读写分离、高可用</strong>。</li></ol><h3 id="mysql字段类型"><a class="anchor" href="#mysql字段类型">#</a> MySQL 字段类型</h3><h4 id="整数类型的-unsigned-属性有什么用"><a class="anchor" href="#整数类型的-unsigned-属性有什么用">#</a> 整数类型的 UNSIGNED 属性有什么用？</h4><p><strong>UNSIGNED 属性来表示不允许负值的无符号整数，因此可以将正整数的上限提高一倍</strong>，因为它不需要存储负数值。</p><p>例如， TINYINT UNSIGNED 类型的取值范围是 0 ~ 255，而普通的 TINYINT 类型的值范围是 -128 ~ 127。INT UNSIGNED 类型的取值范围是 0 ~ 4,294,967,295，而普通的 INT 类型的值范围是 2,147,483,648 ~ 2,147,483,647。</p><p>对于<font color="red">从 0 开始递增的 ID 列</font>，使用 UNSIGNED 属性可以非常适合，因为不允许负值并且可以拥有更大的上限范围，提供了更多的 ID 值可用。</p><h4 id="char-和-varchar-的区别是什么"><a class="anchor" href="#char-和-varchar-的区别是什么">#</a> CHAR 和 VARCHAR 的区别是什么？</h4><p><strong>CHAR 是定长字符串，VARCHAR 是变长字符串。</strong></p><ul><li>CHAR 在存储时会在右边<font color="red">填充空格</font>以达到指定的长度，检索时会<font color="red">去掉空格</font>；VARCHAR 在存储时需要<font color="red">使用 1 或 2 个额外字节记录字符串的长度</font>，检索时不需要处理。</li><li>CHAR 更适合存储<font color="red">长度较短或者长度都差不多</font>的字符串，例如 Bcrypt 算法、MD5 算法加密后的密码、身份证号码。VARCHAR 类型适合存储<font color="red">长度不确定或者差异较大</font>的字符串，例如用户昵称、文章标题等。</li><li>CHAR (M) 和 VARCHAR (M) 的 M 都代表能够保存的字符数的最大值，<font color="red">无论是字母、数字还是中文，每个都只占用一个字符</font>。</li></ul><h4 id="varchar100和-varchar10的区别是什么"><a class="anchor" href="#varchar100和-varchar10的区别是什么">#</a> VARCHAR (100) 和 VARCHAR (10) 的区别是什么？</h4><p>VARCHAR (100) 和 VARCHAR (10) 都是变长类型，表示能存储最多 100 个字符和 10 个字符。因此，<font color="red">VARCHAR (100) 可以满足更大范围的字符存储需求</font>，有更好的业务拓展性。而 VARCHAR (10) 存储超过 10 个字符时，就需要修改表结构才可以。</p><p>虽说 VARCHAR (100) 和 VARCHAR (10) 能存储的字符范围不同，但二者存储相同的字符串，所占用磁盘的存储空间其实是一样的，这也是很多人容易误解的一点。</p><p>不过，<font color="red">VARCHAR (100) 会消耗更多的内存</font>。这是因为 VARCHAR 类型在内存中操作时，<font color="red">通常会分配固定大小的内存块</font>来保存值，即使用字符类型中定义的长度。例如在进行排序的时候，VARCHAR (100) 是按照 100 这个长度来进行的，也就会消耗更多内存。</p><h4 id="decimal-和-floatdouble-的区别是什么"><a class="anchor" href="#decimal-和-floatdouble-的区别是什么">#</a> DECIMAL 和 FLOAT/DOUBLE 的区别是什么？</h4><p><strong>DECIMAL 是定点数，可以存储精确的小数值；FLOAT/DOUBLE 是浮点数，只能存储近似的小数值。</strong></p><p>在 Java 中，MySQL 的 DECIMAL 类型对应的是 Java 类 <code>java.math.BigDecimal</code> 。</p><h4 id="为什么不推荐使用-text-和-blob"><a class="anchor" href="#为什么不推荐使用-text-和-blob">#</a> 为什么不推荐使用 TEXT 和 BLOB？</h4><p>TEXT 类型类似于 CHAR（0-255 字节）和 VARCHAR（0-65,535 字节），但可以存储更长的字符串，即<font color="cornflowerblue">长文本数据</font>，例如博客内容。</p><table><thead><tr><th>类型</th><th>可存储大小</th><th>用途</th></tr></thead><tbody><tr><td>TINYTEXT</td><td>0-255 字节</td><td>一般文本字符串</td></tr><tr><td>TEXT</td><td>0-65,535 字节</td><td>长文本字符串</td></tr><tr><td>MEDIUMTEXT</td><td>0-16,772,150 字节</td><td>较大文本数据</td></tr><tr><td>LONGTEXT</td><td>0-4,294,967,295 字节</td><td>极大文本数据</td></tr></tbody></table><p>BLOB 类型主要用于存储<font color="cornflowerblue">二进制大对象，例如图片、音视频等文件</font>。</p><table><thead><tr><th>类型</th><th>可存储大小</th><th>用途</th></tr></thead><tbody><tr><td>TINYBLOB</td><td>0-255 字节</td><td>短文本二进制字符串</td></tr><tr><td>BLOB</td><td>0-65KB</td><td>二进制字符串</td></tr><tr><td>MEDIUMBLOB</td><td>0-16MB</td><td>二进制形式的长文本数据</td></tr><tr><td>LONGBLOB</td><td>0-4GB</td><td>二进制形式的极大文本数据</td></tr></tbody></table><p>在日常开发中，很少使用 TEXT 类型，但偶尔会用到，而 BLOB 类型则基本不常用。<font color="red">如果预期长度范围可以通过 VARCHAR 来满足，建议避免使用 TEXT</font>。</p><p>数据库规范通常不推荐使用 BLOB 和 TEXT 类型，这两种类型具有一些缺点和限制，例如：</p><ul><li><font color="red">不能有默认值</font></li><li>在使用临时表时<font color="red">无法使用内存临时表，只能在磁盘上创建临时表</font>（《高性能 MySQL》书中有提到）</li><li><font color="red">检索效率较低</font></li><li><font color="red">不能直接创建索引</font>，需要指定前缀长度</li><li><font color="red">会消耗大量的网络和 IO 带宽</font></li><li>可能导致表上的<font color="red"> DML 操作变慢</font></li><li>……</li></ul><h4 id="datetime-和-timestamp-的区别是什么"><a class="anchor" href="#datetime-和-timestamp-的区别是什么">#</a> DATETIME 和 TIMESTAMP 的区别是什么？</h4><p><strong>DATETIME 类型没有时区信息，TIMESTAMP 和时区有关</strong>。</p><p><font color="red">TIMESTAMP 只需要使用 4 个字节的存储空间，但是 DATETIME 需要耗费 8 个字节的存储空间</font>。但是，这样同样造成了一个问题，<font color="red">Timestamp 表示的时间范围更小</font>。</p><ul><li>DATETIME：1000-01-01 00:00:00 ~ 9999-12-31 23:59:59</li><li>Timestamp：1970-01-01 00:00:01 ~ 2037-12-31 23:59:59</li></ul><h4 id="null-和-的区别是什么"><a class="anchor" href="#null-和-的区别是什么">#</a> NULL 和 '' 的区别是什么？</h4><p><code>NULL</code> 跟 <code>''</code> (空字符串) 是两个完全不一样的值，区别如下：</p><ul><li><strong><code>NULL</code> 代表一个不确定的值，但占用空间</strong>。就算是两个 <code>NULL</code> ，它俩也不一定相等。例如， <code>SELECT NULL=NULL</code> 的结果为 false，但是在我们使用 <code>DISTINCT</code> ， <code>GROUP BY</code> ， <code>ORDER BY</code> 时， <code>NULL</code> 又被认为是相等的。</li><li><strong><code>''</code> 是长度为 0 的字符串，不占用空间</strong>。</li><li><font color="red"><code>NULL</code> 会影响聚合函数的结果</font>。例如， <code>SUM</code> 、 <code>AVG</code> 、 <code>MIN</code> 、 <code>MAX</code> 等聚合函数会忽略 <code>NULL</code> 值。 <code>COUNT</code> 的处理方式取决于参数的类型。如果参数是 <code>*</code> ( <code>COUNT(*)</code> )，则会统计所有的记录数，包括 <code>NULL</code> 值；如果参数是某个字段名 ( <code>COUNT(列名)</code> )，则会忽略 <code>NULL</code> 值，只统计非空值的个数。</li><li><font color="red">查询 <code>NULL</code> 值时，必须使用 <code>IS NULL</code> 或 <code>IS NOT NULLl</code> 来判断</font>，而不能使用 =、!=、 &lt;、&gt; 之类的比较运算符。而 <code>''</code> 是可以使用这些比较运算符的。</li></ul><p><strong>因此，MySQL 不建议使用 <code>NULL</code> 作为列默认值。</strong></p><h4 id="boolean-类型如何表示"><a class="anchor" href="#boolean-类型如何表示">#</a> Boolean 类型如何表示？</h4><p>MySQL 中没有专门的布尔类型，而是<strong>用 TINYINT (1) 类型来表示布尔值</strong>。TINYINT (1) 类型可以存储 0 或 1，分别对应 false 或 true。</p><h3 id="mysql基础架构"><a class="anchor" href="#mysql基础架构">#</a> MySQL 基础架构</h3><blockquote><p>配合 <a href="">SQL 语句在 MySQL 中的执行过程</a> 这篇文章来理解 MySQL 基础架构。</p></blockquote><p>一个 SQL 语句在 MySQL 中的执行流程，包括 SQL 的查询在 MySQL 内部会怎么流转，SQL 语句的更新是怎么完成的。</p><p>在分析之前先看看 MySQL 的基础架构，知道了 MySQL 由那些组件组成，以及这些组件的作用是什么，可以帮助我们理解和解决这些问题。</p><h4 id="1-mysql-基础架构分析"><a class="anchor" href="#1-mysql-基础架构分析">#</a> 1、MySQL 基础架构分析</h4><h5 id="11-架构概览"><a class="anchor" href="#11-架构概览">#</a> 1.1、架构概览</h5><p>下图是 MySQL 的一个简要架构图，可以很清晰地看到客户端的一条 SQL 语句在 MySQL 内部是如何执行的。</p><p>从图中可以看出，MySQL 主要由下面几部分构成：</p><ul><li><strong>连接器：</strong><font color="red">连接管理、身份认证和权限</font>相关 (登录 MySQL 的时候)。</li><li>** 查询缓存：** 执行查询语句的时候，会<font color="red">先查询缓存，命中则直接返回</font>（<font color="red">MySQL 8.0 版本后移除</font>，因为这个功能不太实用）。</li><li><strong>分析器：</strong><font color="red">对 SQL 语句进行词法分析、语法分析</font>。说白了就是要先看 SQL 语句要干嘛，再检查 SQL 语句语法是否正确。</li><li><strong>优化器：</strong><font color="red">执行计划生产，索引选择</font>。按照 MySQL 认为<font color="red">最优的方案</font>去执行。</li><li>** 执行器：** 执行语句，然后<font color="red">从存储引擎返回数据</font>。</li><li><strong>插件式存储引擎</strong>：主要负责<font color="red">数据的存储和读取</font>，采用的是 <code>插件式架构</code> ，支持 InnoDB、MyISAM、Memory 等多种存储引擎。</li></ul><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/13526879-3037b144ed09eb88.png" alt="img"></p><center>MySQL 简要架构图</center><p>MySQL 主要分为 Server 层和存储引擎层：</p><ul><li><strong>Server 层</strong>：主要包括<font color="red">连接器、查询缓存、分析器、优化器、执行器</font>等，所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图，函数等，还有一个通用的日志模块 **<font color="red"> binlog 日志模块</font>**。</li><li><strong>存储引擎层</strong>：主要负责<font color="red">数据的存储和读取</font>，采用可以替换的插件式架构，支持 <font color="red">InnoDB、MyISAM、Memory</font> 等多个存储引擎。其中 InnoDB 引擎有自有的日志模块 **<font color="red"> redolog 日志模块</font><strong>。</strong><font color="red">现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5 版本开始就被当做默认存储引擎了</font>**。</li></ul><h5 id="12-server-层的组件介绍"><a class="anchor" href="#12-server-层的组件介绍">#</a> 1.2、Server 层的组件介绍</h5><h6 id="1连接器"><a class="anchor" href="#1连接器">#</a> 1）连接器</h6><p>连接器主要和 **<font color="red">身份认证和权限相关</font>** 的功能相关，就好比一个级别很高的门卫一样。</p><p>主要负责用户登录数据库，进行用户的身份认证，包括校验账户密码，权限等操作。如果用户账户密码已通过，连接器会到权限表中查询该用户的所有权限，之后在这个连接里的权限逻辑判断都<font color="red">仅依赖起始连接成功时读取到的权限数据</font>。也就是说，<font color="red">后续只要这个连接不断开，即使管理员修改了该用户的权限，该用户也是不受影响的</font>。</p><h6 id="2查询缓存"><a class="anchor" href="#2查询缓存">#</a> 2）查询缓存</h6><blockquote><p><strong>从 MySQL8.0 后移除</strong></p></blockquote><p>查询缓存主要 **<font color="red">用来缓存所执行的 SELECT 语句以及该语句的结果集</font>**。</p><p>若连接成功建立，<font color="red">执行查询语句的时候，会先查询缓存</font>。</p><ul><li>MySQL 会先校验这个 SQL 是否执行过，<font color="red">以 Key-Value 的形式缓存在内存中，Key 是查询语句，Value 是结果集</font>。</li><li>如果缓存 key 被命中，就会直接返回给客户端。</li><li>如果缓存 key 没有命中，就会执行后续的操作，<font color="red">完成后也会把结果缓存起来，方便下一次调用</font>。</li></ul><p><strong><font color="red">MySQL 查询不建议使用缓存，因为表更新会清空表上的所有查询缓存，导致查询缓存频繁失效</font></strong>。假如你对一个表更新的话，这个表上的所有的查询缓存都会被清空。对于不经常更新的数据来说，使用缓存还是可以的。</p><p>MySQL 8.0 版本后删除了缓存的功能，官方也是认为该功能在实际的应用场景比较少，所以干脆直接删掉了。</p><h6 id="3分析器"><a class="anchor" href="#3分析器">#</a> 3）分析器</h6><p><font color="red">MySQL 没有命中缓存，那么就会进入分析器</font>。</p><p><strong><font color="red">第一步，词法分析</font></strong>：一条 SQL 语句有多个字符串组成，首先要<font color="red">提取关键字</font>，比如 select，提出查询的表，提出字段名，提出查询条件等等。</p><p><strong><font color="red">第二步，语法分析</font></strong>：主要就是判断你输入的 SQL 是否正确，<font color="red">判断是否符合 MySQL 的语法</font>。</p><p>完成这 2 步之后，MySQL 就准备开始执行了，但是如何执行，怎么执行是最好的结果呢？这个时候就需要优化器上场了。</p><h6 id="4优化器"><a class="anchor" href="#4优化器">#</a> 4）优化器</h6><p>优化器的作用就是 **<font color="red">按照它认为的最优执行方案去执行</font>**，比如多个索引的时候该<font color="red">如何选择索引</font>，多表查询的时候<font color="red">如何选择关联顺序</font>等。</p><p>可以说，经过了优化器之后，这个语句具体该如何执行就已经定下来。</p><h6 id="5执行器"><a class="anchor" href="#5执行器">#</a> 5）执行器</h6><p>当选择了执行方案后，MySQL 就准备开始执行了。首先执行前会校验该用户有没有权限，如果没有权限，就会返回错误信息。<strong><font color="red">如果有权限，就会去调用存储引擎的接口，返回执行结果</font></strong>。</p><h4 id="2-sql-语句分析"><a class="anchor" href="#2-sql-语句分析">#</a> 2、SQL 语句分析</h4><h5 id="21-dql-查询语句"><a class="anchor" href="#21-dql-查询语句">#</a> 2.1、DQL 查询语句</h5><blockquote><p>select</p></blockquote><p>针对 select 语句：</p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tb_student  A <span class="token keyword">where</span> A<span class="token punctuation">.</span>age<span class="token operator">=</span><span class="token string">'18'</span> <span class="token operator">and</span> A<span class="token punctuation">.</span>name<span class="token operator">=</span><span class="token string">' 张三 '</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>结合上面的说明，我们分析下这个语句的执行流程：</p><ol><li><strong>检查该语句是否有权限</strong>：<ul><li>如果没有权限，直接返回错误信息。</li><li>如果有权限，在 MySQL8.0 版本以前，会<strong>查询缓存</strong>，以这条 SQL 语句为 key 在内存中查询是否有结果，有则直接返回，无则执行下一步。</li></ul></li><li><strong>通过分析器对 SQL 语句进行词法分析、语法分析</strong>。<ul><li><font color="red">提取关键元素</font>，比如提取上面这个语句是查询 select，提取需要查询的表名为 tb_student，需要查询所有的列，查询条件是这个表的 id='1'。</li><li><font color="red">判断是否有语法错误</font>，比如关键词是否正确等等，如果检查没问题就执行下一步。</li></ul></li><li><strong>优化器确定执行方案</strong>。上面的 SQL 语句，可以有两种执行方案：a. 先查询学生表中姓名为 “张三” 的学生，然后判断是否年龄是 18。b. 先找出学生中年龄 18 岁的学生，然后再查询姓名为 “张三” 的学生。那么<font color="red">优化器根据优化算法选择执行效率最好的一个方案（优化器认为，有时候不一定最好）</font>。那么确认了执行计划后就准备开始执行了。</li><li>执行语句之前，先进行权限校验，如果没有权限就会返回错误信息。<strong>如果有权限，执行器就会调用存储引擎接口，返回执行结果</strong>。</li></ol><h5 id="22-dml-更新语句"><a class="anchor" href="#22-dml-更新语句">#</a> 2.2、DML 更新语句</h5><blockquote><p>以 update 为例</p></blockquote><p>针对 update 语句：</p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">update</span> tb_student A <span class="token keyword">set</span> A<span class="token punctuation">.</span>age<span class="token operator">=</span><span class="token string">'19'</span> <span class="token keyword">where</span> A<span class="token punctuation">.</span>name<span class="token operator">=</span><span class="token string">' 张三 '</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p><font color="red">这条语句也基本上会沿着上一个查询的流程走，只不过<strong>执行更新的时候肯定要记录日志</strong>，这就会引入日志模块了</font>。</p><p>MySQL 自带的日志模块是 <strong><font color="cornflowerblue">binlog（归档日志）</font></strong>，所有的存储引擎都可以使用。而常用的 InnoDB 引擎还自带了一个日志模块 <strong><font color="cornflowerblue">redo log（重做日志）</font></strong>。</p><p>我们就以 InnoDB 模式下来探讨这个语句的执行流程：</p><ol><li><p><font color="red">先查询到这一条数据</font>（根据 name = 张三），如果有缓存，也是会用到缓存。</p></li><li><p>然后拿到查询的语句，<font color="red">把 age 改为 19</font>，然后<font color="red">调用存储引擎 API 接口，写入这一行数据</font>。InnoDB 引擎把数据保存在内存中，同时 **<font color="red">InnoDB 引擎记录 redo log，此时 redo log 进入 prepare 状态</font>**。然后告诉执行器，执行完成了，随时可以提交。</p></li><li><p><strong><font color="red">执行器收到 InnoDB 引擎的通知后，记录 binlog</font></strong>。然后 **<font color="red">执行器调用引擎接口，提交 redo log 为提交状态</font>**。</p></li><li><p>更新完成。</p></li></ol><hr><p>为什么要用两个日志模块，用一个日志模块不行吗？</p><p>这是因为最开始 MySQL 并没有 InnoDB 引擎（InnoDB 引擎是其他公司以插件形式插入 MySQL 的），MySQL 自带的引擎是 MyISAM。但是我们知道<font color="red"> redo log 是 InnoDB 引擎特有的，其他存储引擎都没有，这就导致会没有 crash-safe 的能力</font>（crash-safe 的能力即使数据库发生异常重启，之前提交的记录都不会丢失），<font color="red">而 binlog 日志只能用来归档</font>。</p><p>并不是说只用一个日志模块不可以，只是 **<font color="red"> InnoDB 引擎就是通过 redo log 来支持事务的</font>**。那么，又会有同学问，我用两个日志模块，但是不要这么复杂行不行，为什么 redo log 要引入 prepare 预提交状态？这里我们用反证法来说明下为什么要这么做？</p><ul><li>先写 redo log 直接提交，然后写 binlog：假设写完 redo log 后，机器挂了，binlog 日志没有被写入，那么机器重启后，这台机器会通过 redo log 恢复数据，但是这个时候 binlog 并没有记录该数据，后续进行机器备份的时候，就会丢失这一条数据，同时主从同步也会丢失这一条数据。</li><li>先写 binlog，然后写 redo log：假设写完了 binlog，机器异常重启了，由于没有 redo log，本机是无法恢复这一条记录的，但是 binlog 又有记录，那么和上面同样的道理，就会产生数据不一致的情况。</li></ul><p><strong><font color="red">redo log 两阶段提交的方式可以保证数据的一致性</font></strong>。写完 binlog 后，然后再提交 redo log 就会防止出现上述的问题，从而保证了数据的一致性。那么问题来了，有没有一个极端的情况呢？<font color="red">假设 redo log 处于 prepare 状态，binlog 也已经写完了，这个时候发生了异常重启会怎么样呢？</font> 这个就要依赖于 MySQL 的处理机制了：</p><ul><li>判断 redo log 是否完整，如果判断是完整的，就立即提交。</li><li>如果 redo log 只是 prepare，但不是 commit 状态，这个时候就会去判断 binlog 是否完整，如果完整就提交 redo log, 不完整就回滚事务。</li></ul><p>这样就解决了数据一致性的问题。</p><h4 id="3-小结"><a class="anchor" href="#3-小结">#</a> 3、小结</h4><ul><li>MySQL 主要分为 <font color="cornflowerblue">Server 层</font>和<font color="cornflowerblue">引擎层</font>，Server 层主要包括<font color="red">连接器、查询缓存、分析器、优化器、执行器</font>，同时还有一个<font color="red">归档日志模块（binlog）</font>，这个日志模块所有执行引擎都可以共用，<font color="red">而重做日志模块（redolog）只有 InnoDB 有</font>。</li><li>Server 层中各组件的功能：<ul><li><strong>连接器</strong>：管理连接、权限验证；</li><li><strong>查询缓存</strong>：命中缓存则直接返回结果；</li><li><strong>分析器</strong>：对 SQL 进行词法分析、语法分析；</li><li><strong>优化器</strong>：执行计划生成、选择索引；</li><li><strong>执行器</strong>：操作引擎、返回结果；</li><li><strong>存储引擎</strong>：存储数据、提供读写接口。</li></ul></li><li>引擎层是插件式的，目前主要包括，<font color="red">MyISAM、InnoDB、Memory</font>等。</li><li><font color="gree">查询语句</font>的执行流程如下：<font color="red">权限校验 ---&gt; 查询缓存（如果命中，直接返回）---&gt; 分析器 ---&gt; 优化器 ---&gt;<strong> 权限校验</strong> ---&gt; 执行器 ---&gt; 引擎</font></li><li><font color="gree">更新语句</font>执行流程如下：<font color="red">分析器 ----&gt; 权限校验 ----&gt; 执行器 ---&gt; 引擎 ---<strong>redo log (prepare 状态)</strong>---&gt;<strong>binlog</strong>---&gt;<strong>redo log (commit 状态)</strong></font></li><li>笼统点的回答，<strong>一条 SQL 的执行过程</strong>：<ol><li>客户端请求 -&gt;</li><li>连接器（验证用户身份，给予权限） -&gt;</li><li>查询缓存（存在缓存则直接返回，不存在则执行后续操作）-&gt;</li><li>分析器（对 SQL 进行词法分析、语法分析） -&gt;</li><li>优化器（选择最优的 SQL 执行方案） -&gt;</li><li>执行器（先检查用户是否有执行权限，有的话才调用引擎接口，执行 SQL）-&gt;</li><li>从引擎层获取数据返回（如果开启查询缓存，则会缓存查询结果）</li></ol></li></ul><h3 id="mysql存储引擎"><a class="anchor" href="#mysql存储引擎">#</a> <mark>MySQL 存储引擎</mark></h3><h4 id="mysql-支持哪些存储引擎默认使用哪个"><a class="anchor" href="#mysql-支持哪些存储引擎默认使用哪个">#</a> MySQL 支持哪些存储引擎？默认使用哪个？</h4><p>MySQL 支持多种存储引擎，你可以通过 <code>show engines</code> 命令来查看 MySQL 支持的所有存储引擎。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20220510105408703.png" alt="查看 MySQL 提供的所有存储引擎"></p><p>从上图我们可以查看出，<strong>MySQL 5.5.5 之后，默认的存储引擎是 InnoDB</strong>。并且，<strong>只有 InnoDB 支持事务、行级锁、外键</strong>。</p><p>MySQL 5.5.5 之前，MyISAM 是 MySQL 的默认存储引擎。5.5.5 版本之后，InnoDB 是 MySQL 的默认存储引擎。</p><h4 id="mysql-存储引擎架构了解吗"><a class="anchor" href="#mysql-存储引擎架构了解吗">#</a> MySQL 存储引擎架构了解吗？</h4><p>MySQL 存储引擎采用的是<strong>插件式架构，支持多种存储引擎</strong>。我们甚至可以为不同的数据库表设置不同的存储引擎以适应不同场景的需要。<strong>存储引擎是基于表的，而不是数据库。</strong></p><h4 id="myisam-和-innodb-有什么区别"><a class="anchor" href="#myisam-和-innodb-有什么区别">#</a> MyISAM 和 InnoDB 有什么区别？</h4><p>MySQL 5.5 之前，MyISAM 引擎是 MySQL 的默认存储引擎，可谓是风光一时。</p><p>虽然，MyISAM 的性能还行，各种特性也还不错（比如全文索引、压缩、空间函数等）。但是，<strong><font color="red">MyISAM 不支持事务和行级锁，而且最大的缺陷就是崩溃后无法安全恢复</font></strong>。</p><p>MySQL 5.5 版本之后，InnoDB 是 MySQL 的默认存储引擎。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231108152443561.png" alt="image-20231108152443561"></p><p>言归正传！咱们下面还是来简单对比一下两者：</p><p><strong>1. 是否支持行级锁</strong></p><p>MyISAM 只有表级锁 ( <code>table-level locking</code> )，而<font color="red"> InnoDB 支持行级锁 ( <code>row-level locking</code> ) 和表级锁，默认为行级锁。</font></p><p>也就说，MyISAM 一锁就是锁住了整张表，这在并发写的情况下是多么滴憨憨啊！这也是为什么 InnoDB 在并发写的时候，性能更牛皮了！</p><p><strong>2. 是否支持事务</strong></p><p>MyISAM 不提供事务支持。</p><p><font color="red">InnoDB 提供事务支持，实现了 SQL 标准定义了四个隔离级别，具有提交 ( <code>commit</code> ) 和回滚 ( <code>rollback</code> ) 事务的能力</font>。</p><p>并且，<font color="red">InnoDB 默认使用的 <code>REPEATABLE-READ</code> （可重复读）隔离级别是可以解决幻读问题发生的（基于 MVCC 和 Next-Key Lock）</font>。</p><p>关于 MySQL 事务的详细介绍，可以看看我写的这篇文章：<span class="exturl" data-url="aHR0cHM6Ly9qYXZhZ3VpZGUuY24vZGF0YWJhc2UvbXlzcWwvdHJhbnNhY3Rpb24taXNvbGF0aW9uLWxldmVsLmh0bWw=">MySQL 事务隔离级别详解</span>。</p><p><strong>3. 是否支持外键</strong></p><p>MyISAM 不支持，而<font color="red"> InnoDB 支持外键</font>。</p><p>外键对于维护数据一致性非常有帮助，但是<font color="red">对性能有一定的损耗</font>。因此，通常情况下，我们是不建议在实际生产项目中使用外键的，在业务代码中进行约束即可！</p><p>阿里的《Java 开发手册》也是明确规定<strong>禁止使用外键</strong>的。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20220510090309427.png" alt="img"></p><p>不过，在代码中进行约束的话，对程序员的能力要求更高，具体是否要采用外键还是要根据你的项目实际情况而定。</p><p>总结：一般我们也是不建议在数据库层面使用外键的，应用层面可以解决。不过，这样<font color="red">会对数据的一致性造成威胁</font>。具体要不要使用外键还是要根据你的项目来决定。</p><p><strong>4. 是否支持数据库异常崩溃后的安全恢复</strong></p><p>MyISAM 不支持，而<font color="red"> InnoDB 支持数据库异常崩溃后的安全恢复</font>。</p><p>使用 InnoDB 的数据库在异常崩溃后，数据库重新启动的时候会保证数据库恢复到崩溃前的状态。这个恢复的过程依赖于 InnoDB 的<strong>重做日志模块 <code>redo log</code> </strong>。</p><p><strong>5. 是否支持 MVCC</strong></p><p><font color="red">MVCC 可以看作是行级锁的一个升级，可以有效减少加锁操作，提高性能</font>。</p><p>MyISAM 不支持，而<font color="red"> InnoDB 支持 MVCC</font>。</p><p>讲真，这个对比有点废话，毕竟 MyISAM 连行级锁都不支持。</p><p><strong>6. 索引实现不一样。</strong></p><p>虽然 MyISAM 引擎和 InnoDB 引擎<font color="red">都是使用 B+Tree 作为索引结构</font>，但是两者的实现方式不太一样。</p><p><font color="red">InnoDB 引擎中，数据、索引都是存放在 .ibd 表空间文件中</font>。相比 MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按 B+Tree 组织的一个索引结构，树的叶节点 data 域保存了完整的数据记录。</p><p><strong>7. 性能有差别。</strong></p><p><font color="red">InnoDB 的性能比 MyISAM 更强大</font>，不管是在读写混合模式下还是只读模式下，随着 CPU 核数的增加，InnoDB 的读写能力呈线性增长。<font color="red">MyISAM 的读写不能并发，它的处理能力跟核数没关系</font>。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/innodb-myisam-performance-comparison.png" alt="InnoDB 和 MyISAM 性能对比"></p><p><strong>总结</strong> ：</p><ul><li><strong>InnoDB 支持事务处理，而 MyISAM 不支持</strong>。</li><li><strong>InnoDB 支持行级锁，而 MyISAM 只支持表级锁</strong>。</li><li><strong>InnoDB 支持外键，而 MyISAM 不支持</strong>。</li><li><font color="red">InnoDB 支持 MVCC</font>，而 MyISAM 不支持。</li><li>虽然 MyISAM 引擎和 InnoDB 引擎都是使用 B+Tree 作为索引结构，但是<font color="red">两者的索引实现方式不太一样</font>。</li><li><font color="red">InnoDB 支持数据库异常崩溃后的安全恢复</font>，而 MyISAM 不支持。</li><li><font color="red">InnoDB 的性能比 MyISAM 更强大</font>。</li></ul><p>最后，再分享一张图片给你，这张图片详细对比了常见的几种 MySQL 存储引擎。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/comparison-of-common-mysql-storage-engines.png" alt="常见的几种 MySQL 存储引擎对比"></p><h4 id="myisam-和-innodb-如何选择"><a class="anchor" href="#myisam-和-innodb-如何选择">#</a> MyISAM 和 InnoDB 如何选择？</h4><p><strong>大多数情况使用的都是 InnoDB 存储引擎</strong>。在某些读密集的情况下，使用 MyISAM 也是合适的。不过，前提是你的项目不介意<font color="red"> MyISAM 不支持事务、崩溃恢复</font>等缺点（可是～我们一般都会介意啊！）。</p><h3 id="mysql索引"><a class="anchor" href="#mysql索引">#</a> <mark>MySQL 索引</mark></h3><h4 id="索引介绍"><a class="anchor" href="#索引介绍">#</a> 索引介绍</h4><p><strong>索引是一种帮助存储引擎快速查询和检索数据的数据结构（有序）。</strong></p><p>索引的底层数据结构存在很多种类型，常见的索引结构有：红黑树、B 树、B + 树、Hash。</p><p><font color="red">在 MySQL 中，Innodb 和 MyIsam，都使用 B + 树 作为索引结构</font>。</p><h4 id="索引的优缺点"><a class="anchor" href="#索引的优缺点">#</a> 索引的优缺点</h4><p><strong>优点</strong>：</p><ul><li>使用索引可以大大<font color="red">加快数据的检索速度</font>（大大减少检索的数据量），这也是创建索引的最主要的原因。</li><li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</li></ul><p><strong>缺点</strong>：</p><ul><li><font color="red">创建和维护索引需要耗费许多时间</font>。当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低 SQL 执行效率。</li><li>索引需要使用物理文件存储，也会耗费一定空间。</li></ul><h4 id="索引的底层数据结构选型"><a class="anchor" href="#索引的底层数据结构选型">#</a> 索引的底层数据结构选型</h4><h5 id="hash-表"><a class="anchor" href="#hash-表">#</a> Hash 表</h5><p>哈希表是键值对的集合，通过键 (key) 即可快速取出对应的值 (value)，因此哈希表可以快速检索数据（接近 O（1））。</p><p>通过哈希算法，我们可以快速找到 key 对应的 index，找到了 index 也就找到了对应的 value。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre>hash <span class="token operator">=</span> <span class="token function">hashfunc</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre>index <span class="token operator">=</span> hash <span class="token operator">%</span> array_size</pre></td></tr></table></figure><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/mysql20210513092328171.png" alt="img"></p><p>但是！哈希算法有个 <strong>Hash 冲突</strong> 问题，也就是说多个不同的 key 最后得到的 index 相同。通常情况下，我们常用的解决办法是<strong>链地址法</strong>。链地址法就是将哈希冲突数据存放在链表中。就比如 JDK1.8 之前 <code>HashMap</code> 就是通过链地址法来解决哈希冲突的。不过，JDK1.8 以后 <code>HashMap</code> 为了减少链表过长时搜索时间过长引入了红黑树。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/mysql20210513092224836.png" alt="img"></p><p>为了减少 Hash 冲突的发生，一个好的哈希函数应该 “均匀地” 将数据分布在整个可能的哈希值集合中。</p><p>InnoDB 存储引擎不直接支持常规的哈希索引，但存在一种特殊的<strong>自适应哈希索引（Adaptive Hash Index）</strong>，结合了 B+Tree 和哈希索引的特点，以便更好地适应实际应用中的数据访问模式和性能需求。自适应哈希索引的每个哈希桶实际上是一个小型的 B+Tree 结构。这个 B+Tree 结构可以存储多个键值对，而不仅仅是一个键。这有助于减少哈希冲突链的长度，提高了索引的效率。关于 Adaptive Hash Index 的详细介绍，可以查看 <span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvcmE0djFYUjVwelNXYy1xdEdPLWRCZw==">MySQL 各种 “Buffer” 之 Adaptive Hash Index</span> 这篇文章。</p><p>既然哈希表这么快，为什么 MySQL 没有使用其作为索引的数据结构呢？主要是<strong>因为 Hash 索引不支持排序、范围查询</strong>。假如我们要对表中的数据进行排序或者进行范围查询，那 Hash 索引可就不行了。并且，每次 IO 只能取一个。</p><p>试想一种情况:</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token constant">SELECT</span> <span class="token operator">*</span> <span class="token constant">FROM</span> tb1 <span class="token constant">WHERE</span> id <span class="token operator">&lt;</span> <span class="token number">500</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>在这种范围查询中，直接遍历比 500 小的叶子节点就够了。而 Hash 索引是根据 hash 算法来定位的，难不成还要把 1 - 499 的数据，每个都进行一次 hash 计算来定位吗？这就是 Hash 最大的缺点了。</p><h5 id="二叉查找树bst"><a class="anchor" href="#二叉查找树bst">#</a> 二叉查找树（BST）</h5><p>二叉查找树（Binary Search Tree）是一种基于二叉树的数据结构，它具有以下特点：</p><ol><li>左子树所有节点的值均小于根节点的值。</li><li>右子树所有节点的值均大于根节点的值。</li><li>左右子树也分别为二叉查找树。</li></ol><p>二叉查找树的时间复杂度：</p><ul><li>当二叉查找树平衡时，也就是树的每个节点的左右子树深度相差不超过 1 的时候，查询的时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:.01968em">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:.03588em">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，具有比较高的效率。</li><li>然而，当二叉查找树不平衡时，例如在最坏情况下（有序插入节点），树会退化成线性链表（也被称为斜树），导致查询效率急剧下降，时间复杂退化为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mtext>（</mtext><mi>N</mi><mtext>）</mtext></mrow><annotation encoding="application/x-tex">O（N）</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mord cjk_fallback">（</span><span class="mord mathnormal" style="margin-right:.10903em">N</span><span class="mord cjk_fallback">）</span></span></span></span>。</li></ul><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/oblique-tree.png" alt="斜树"></p><center>斜树</center><p>也就是说，<strong>二叉查找树的性能非常依赖于它的平衡程度，这就导致其不适合作为 MySQL 底层索引的数据结构。</strong></p><p>为了解决这个问题，并提高查询效率，人们发明了多种在二叉查找树基础上的改进型数据结构，如平衡二叉树、B-Tree、B+Tree 等。</p><h5 id="avl-树自平衡的bst"><a class="anchor" href="#avl-树自平衡的bst">#</a> AVL 树（自平衡的 BST）</h5><p>AVL 树的特点是<font color="red">保证任何节点的左右子树高度之差不超过 1</font>，因此也被称为高度平衡二叉树。<font color="red">它的查找、插入和删除在平均和最坏情况下的时间复杂度都是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:.01968em">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:.03588em">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></font>。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/avl-tree.png" alt="AVL 树"></p><p>AVL 树采用了<font color="red">旋转操作</font>来保持平衡。主要有四种旋转操作：LL 旋转、RR 旋转、LR 旋转和 RL 旋转。其中 LL 旋转和 RR 旋转分别用于处理左左和右右失衡，而 LR 旋转和 RL 旋转则用于处理左右和右左失衡。</p><p>由于 AVL 树<font color="red">需要频繁地进行旋转操作来保持平衡</font>，因此会有较大的计算开销进而降低了查询性能。并且， 在使用 AVL 树时，每个树节点仅存储一个数据，而每次进行磁盘 IO 时只能读取一个节点的数据，如果需要查询的数据分布在多个节点上，那么就需要进行多次磁盘 IO。 <strong>磁盘 IO 是一项耗时的操作，在设计数据库索引时，我们需要优先考虑如何最大限度地减少磁盘 IO 操作的次数。</strong></p><p>实际应用中，AVL 树使用的并不多。</p><h5 id="红黑树自平衡的bst"><a class="anchor" href="#红黑树自平衡的bst">#</a> 红黑树（自平衡的 BST）</h5><p>与 AVL 树一样，红黑树也是一种自平衡二叉查找树，通过在插入和删除节点时进行<font color="red">颜色变换、旋转操作</font>，使得树始终保持平衡状态，它具有以下特点：</p><ol><li>每个节点非红即黑；</li><li>根节点总是黑色的；</li><li>每个叶子节点都是黑色的空节点（NIL 节点）；</li><li>如果节点是红色的，则它的子节点必须是黑色的（反之不一定）；</li><li>从根节点到叶节点或空子节点的每条路径，必须包含相同数目的黑色节点（即相同的黑色高度）。</li></ol><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/red-black-tree.png" alt="红黑树"></p><p>和 AVL 树不同的是，<strong><font color="red">红黑树并不追求严格的平衡，而是大致的平衡，因此红黑树的查询效率稍有下降</font></strong>。因为红黑树的平衡性相对较弱，可能会导致树的高度较高，这可能会导致一些数据需要进行多次磁盘 IO 操作才能查询到，这也是 MySQL 没有选择红黑树的主要原因。也正因如此，<strong><font color="red">红黑树的插入和删除操作效率大大提高了</font></strong>，因为红黑树在插入和删除节点时只需进行 O (1) 次数的旋转和变色操作，即可保持基本平衡状态，而不需要像 AVL 树一样进行 O (logn) 次数的旋转操作。</p><p>红黑树的应用还是比较广泛的，TreeMap、TreeSet 以及 JDK1.8 的 HashMap 底层都用到了红黑树。对于数据在内存中的这种情况来说，红黑树的表现是非常优异的。</p><h5 id="b树-b树"><a class="anchor" href="#b树-b树">#</a> B 树 &amp; B + 树</h5><p>B 树也称 B - 树，全称为<strong>多路平衡查找树</strong> ，B+ 树是 B 树的一种变体。B 是 <code>Balanced</code> （平衡）的意思。</p><p><font color="red">目前大部分数据库系统及文件系统都采用 B-Tree 或其变种 B+Tree 作为<u>索引结构</u></font>。</p><p>B 树与 B + 树的区别：</p><ul><li><font color="red">B 树的所有节点既存放键（key）也存放数据（data）</font>；而 **<font color="red"> B+ 树只有叶子节点存放 key 和 data，其他内节点只存放 key</font>**。这样可以大大增加每个节点存储的 key 值数量，从而降低 B + 树的高度，提高检索效率。</li><li><font color="red">B 树的叶子节点都是独立的</font>；而 <strong><font color="red">B+ 树的叶子节点有一条<u>双向引用链</u>指向与它相邻的叶子节点</font></strong>。</li><li>B 树的检索的过程相当于对范围内的每个节点的 key 做二分查找，可能还没有到达叶子节点，检索就结束了。而 <strong><font color="red">B+ 树的检索效率就很稳定了，任何查找都是从根节点到叶子节点的过程，叶子节点的顺序检索很明显</font></strong>。</li><li>在 B 树中进行范围查询时，首先找到要查找的下限，然后对 B 树进行中序遍历，直到找到查找的上限；而 <strong><font color="red">B+ 树的范围查询，只需要对链表进行遍历即可</font></strong>。</li></ul><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/249993-20170525154141810-591706803.png" alt="img"></p><center>B树索引（3阶）</center><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/249993-20170531161139243-491884410.png" alt="img"></p><center>（B+树索引）</center><p>综上，B + 树与 B 树相比，具备<font color="red">更少的 IO 次数、更稳定的查询效率、更适于范围查询</font>这些优势。</p><hr><p><font color="red">在 MySQL 中，MyISAM 引擎和 InnoDB 引擎都是使用 B+Tree 作为索引结构，但二者的实现方式不太一样</font>。</p><blockquote><p>《Java 工程师修炼之道》：</p><p>MyISAM 引擎中，B+Tree 叶节点的 data 域存放的是数据记录的地址。在索引检索的时候，首先按照 B+Tree 搜索算法搜索索引，如果指定的 Key 存在，则取出其 data 域的值，然后以 data 域的值为地址读取相应的数据记录。这被称为 “<strong>非聚簇索引（非聚集索引）</strong>”。</p><p>InnoDB 引擎中，其数据文件本身就是索引文件。相比 MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按 B+Tree 组织的一个索引结构，树的叶节点 data 域保存了完整的数据记录。这个索引的 key 是数据表的主键，因此 InnoDB 表数据文件本身就是主索引。这被称为 “<strong>聚簇索引（聚集索引）</strong>”，而其余的索引都作为 <strong>辅助索引</strong> ，辅助索引的 data 域存储相应记录主键的值而不是地址，这也是和 MyISAM 不同的地方。在根据主索引搜索时，直接找到 key 所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引。 因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。</p></blockquote><h4 id="索引分类"><a class="anchor" href="#索引分类">#</a> 索引分类</h4><p>按照<font color="gree">数据结构</font>分类：</p><ul><li><font color="cornflowerblue">B + 树索引</font>：MySQL 里<font color="red">默认的</font>索引类型。<font color="red">只有叶子节点存储 value，非叶子节点只有指针和 key</font>。存储引擎 MyISAM 和 InnoDB 实现索引都是使用 B+Tree，但二者实现方式不一样。</li><li><font color="cornflowerblue">hash 索引</font>：类似键值对的形式，一次即可定位。</li><li><font color="cornflowerblue">R 树索引</font>：一般不会使用，<font color="red">仅支持 geometry 数据类型</font>，优势在于范围查找，效率较低，通常使用搜索引擎如 ElasticSearch 代替。</li><li><font color="cornflowerblue">全文索引</font>：对文本的内容进行分词，进行搜索。目前只有 <code>CHAR</code> 、 <code>VARCHAR</code> ， <code>TEXT</code> 列上可以创建全文索引。一般不会使用，效率较低，通常使用搜索引擎如 ElasticSearch 代替。</li></ul><p>按照<font color="gree">底层存储方式</font>划分：</p><ul><li><font color="cornflowerblue">聚集索引</font>：<font color="red">索引结构、数据一起存放</font>的索引，InnoDB 中的<font color="red">主键索引</font>就属于聚簇索引。</li><li><font color="cornflowerblue">非聚集索引</font>：<font color="red">索引结构、数据分开存放</font>的索引，<font color="red">二级索引 (辅助索引)</font>就属于非聚簇索引。MySQL 的 MyISAM 引擎，不管主键还是非主键，使用的都是非聚簇索引。</li></ul><p>按照<font color="gree">应用维度</font>划分：</p><ul><li><font color="cornflowerblue">主键索引</font>：加速查询 + 列值唯一（不可以有 NULL）+ 表中只有一个。</li><li><font color="cornflowerblue">普通索引</font>：仅加速查询。</li><li><font color="cornflowerblue">唯一索引</font>：加速查询 + 列值唯一（可以有 NULL）。</li><li><font color="cornflowerblue">覆盖索引</font>：一个索引包含（或者说覆盖）所有需要查询的字段的值。</li><li><font color="cornflowerblue">联合索引</font>：<font color="red">多列值组成一个索引</font>，专门用于组合搜索，其效率大于索引合并。</li><li><font color="cornflowerblue">全文索引</font>：<font color="red">对文本的内容进行分词，进行搜索</font>。目前只有 <code>CHAR</code> 、 <code>VARCHAR</code> ， <code>TEXT</code> 列上可以创建全文索引。一般不会使用，效率较低，通常使用搜索引擎如 ElasticSearch 代替。</li></ul><p>MySQL 8.x 中实现的<font color="gree">索引新特性</font>：</p><ul><li><font color="cornflowerblue">隐藏索引</font>：也称为不可见索引，不会被优化器使用，但是仍然需要维护，通常会软删除和灰度发布的场景中使用。主键不能设置为隐藏（包括显式设置或隐式设置）。</li><li><font color="cornflowerblue">降序索引</font>：之前的版本就支持通过 desc 来指定索引为降序，但实际上创建的仍然是常规的升序索引。直到 MySQL 8.x 版本才开始真正支持降序索引。另外，在 MySQL 8.x 版本中，不再对 GROUP BY 语句进行隐式排序。</li><li><font color="cornflowerblue">函数索引</font>：从 MySQL 8.0.13 版本开始支持在索引中使用函数或者表达式的值，也就是在索引中可以包含函数或者表达式。</li></ul><h5 id="主键索引"><a class="anchor" href="#主键索引">#</a> 主键索引</h5><p>数据表的<font color="red">主键列</font>使用的就是主键索引。</p><p>一张数据表有只能有一个主键，并且主键不能为 null，不能重复。</p><p>在 MySQL 的 InnoDB 的表中，当没有显示的指定表的主键时，InnoDB 会自动先检查表中是否有唯一索引且不允许存在 null 值的字段，如果有，则选择该字段为默认的主键，否则 InnoDB 将会自动创建一个 6Byte 的自增主键。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/cluster-index.png" alt="主键索引"></p><center>主键索引</center><h5 id="二级索引"><a class="anchor" href="#二级索引">#</a> 二级索引</h5><p>二级索引（Secondary Index）又称为辅助索引，是因为<strong>二级索引的叶子节点仅仅存储主键</strong>。也就是说，通过二级索引，可以定位主键的位置。</p><p>唯一索引，普通索引，前缀索引等索引属于二级索引：</p><ol><li><font color="cornflowerblue">唯一索引 (Unique Key)</font>：唯一索引也是一种约束。<font color="red">唯一索引的属性列不能出现重复的数据，但是允许数据为 NULL，一张表允许创建多个唯一索引</font>。建立唯一索引的目的大部分时候都是<font color="red">为了该属性列的数据的唯一性，而不是为了查询效率</font>。</li><li><font color="cornflowerblue">普通索引 (Index)</font>：普通索引的唯一作用就是<font color="red">为了快速查询数据</font>，一张表允许创建多个普通索引，并允许数据重复和 NULL。</li><li><font color="cornflowerblue">前缀索引 (Prefix)</font>：前缀索引只适用于字符串类型的数据。前缀索引是<font color="red">对文本的前几个字符创建索引，相比普通索引建立的数据更小</font>，因为只取前几个字符。</li><li><font color="cornflowerblue">全文索引 (Full Text)</font>：全文索引主要是<font color="red">为了检索大文本数据中的关键字信息</font>，是目前搜索引擎数据库使用的一种技术。Mysql 5.6 之前只有 MYISAM 引擎支持全文索引，5.6 之后 InnoDB 也支持了全文索引。</li></ol><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/no-cluster-index.png" alt="二级索引"></p><center>二级索引</center><h5 id="聚集索引"><a class="anchor" href="#聚集索引">#</a> 聚集索引</h5><p><strong>聚集索引（Clustered Index）即索引结构和数据一起存放的索引</strong>，并不是一种单独的索引类型。InnoDB 中的主键索引就属于聚集索引。</p><p>在 MySQL 中，<font color="red">InnoDB 引擎的表的 <code>.ibd</code> 表空间文件就包含了该表的索引和数据</font>，对于 InnoDB 引擎表来说，该表的索引 (B + 树) 的每个非叶子节点存储索引，叶子节点存储索引和索引对应的数据。</p><p>优点：</p><ul><li><strong>查询速度非常快</strong>：因为整个 B+ 树本身就是一颗多叉平衡树，叶子节点也都是有序的，定位到索引的节点，就相当于定位到了数据。相比于非聚集索引， 聚集索引少了一次读取数据的 IO 操作。</li><li><strong>对排序查找和范围查找优化</strong>：对于主键的排序查找和范围查找速度非常快。</li></ul><p>缺点：</p><ul><li><strong>依赖于有序的数据</strong>：因为 B+ 树是多路平衡树，如果索引的数据不是有序的，那么就需要在插入时排序，如果数据是整型还好，否则类似于字符串或 UUID 这种又长又难比较的数据，插入或查找的速度肯定比较慢。</li><li><strong>更新代价大</strong>：如果对索引列的数据被修改时，那么对应的索引也将会被修改，而且聚集索引的叶子节点还存放着数据，修改代价肯定是较大的，所以对于主键索引来说，主键一般都是不可被修改的。</li></ul><h5 id="非聚集索引"><a class="anchor" href="#非聚集索引">#</a> 非聚集索引</h5><p><strong>非聚集索引 (Non-Clustered Index) 即索引结构和数据分开存放的索引</strong>，并不是一种单独的索引类型。二级索引 (辅助索引) 就属于非聚集索引。MySQL 的 MyISAM 引擎，不管主键还是非主键，使用的都是非聚簇索引。</p><p>非聚集索引的叶子节点并不一定存放数据的指针，因为<font color="red">二级索引的叶子节点就存放的是主键，根据主键再回表查数据</font>。</p><p>优点：</p><ul><li><strong>更新代价比聚集索引要小</strong>：因为非聚集索引的叶子节点是不存放数据的</li></ul><p>缺点：</p><ul><li><p><strong>依赖于有序的数据</strong>：跟聚簇索引一样，非聚簇索引也依赖于有序的数据</p></li><li><p><strong><font color="orange">可能会二次查询 (回表查询)</font></strong>: 这应该是非聚簇索引最大的缺点了。<strong><font color="red">当查到索引对应的指针或主键后，可能还需要根据指针或主键再到数据文件或表中查询</font></strong>。</p><blockquote><p><strong>非聚簇索引不一定回表查询。</strong></p><p>试想一种情况，用户准备使用 SQL 查询用户名，而用户名字段正好建立了索引。</p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">SELECT</span> name <span class="token keyword">FROM</span> <span class="token keyword">table</span> <span class="token keyword">WHERE</span> name<span class="token operator">=</span><span class="token string">'guang19'</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>那么这个<font color="red">索引的 key 本身就是要查询的字段</font>，查到对应的 name 直接返回就行了，无需回表查询。</p><p>即使是 MYISAM 也是这样，虽然 MYISAM 的主键索引确实需要回表，因为它的主键索引的叶子节点存放的是指针。但是！<strong>如果 SQL 查的就是主键呢？</strong></p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">SELECT</span> id <span class="token keyword">FROM</span> <span class="token keyword">table</span> <span class="token keyword">WHERE</span> id<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>主键索引本身的 key 就是主键，查到返回就行了。这种情况就称之为<strong>覆盖索引</strong>了。</p></blockquote></li></ul><p>这是 MySQL 的表的文件截图:</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/mysql20210420165311654.png" alt="MySQL 表的文件"></p><p>聚簇索引和非聚簇索引:</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/mysql20210420165326946.png" alt="聚簇索引和非聚簇索引"></p><h5 id="覆盖索引"><a class="anchor" href="#覆盖索引">#</a> 覆盖索引</h5><h5 id="联合索引"><a class="anchor" href="#联合索引">#</a> 联合索引</h5><h5 id="最左前缀匹配原则"><a class="anchor" href="#最左前缀匹配原则">#</a> 最左前缀匹配原则</h5><h4 id="索引下推"><a class="anchor" href="#索引下推">#</a> 索引下推</h4><h4 id="索引的正确使用建议"><a class="anchor" href="#索引的正确使用建议">#</a> 索引的正确使用建议</h4><h3 id="mysql查询缓存"><a class="anchor" href="#mysql查询缓存">#</a> MySQL 查询缓存</h3><p>执行查询语句的时候，会先查询缓存。不过，<strong>MySQL 8.0 版本后移除</strong>，因为这个功能不太实用</p><p><code>my.cnf</code> 加入以下配置，重启 MySQL 开启查询缓存</p><figure class="highlight properties"><figcaption data-lang=".properties"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token key attr-name">query_cache_type</span><span class="token punctuation">=</span><span class="token value attr-value">1</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token key attr-name">query_cache_size</span><span class="token punctuation">=</span><span class="token value attr-value">600000</span></pre></td></tr></table></figure><p>MySQL 执行以下命令也可以开启查询缓存</p><figure class="highlight properties"><figcaption data-lang=".properties"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token key attr-name">set</span> <span class="token value attr-value">global  query_cache_type=1;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token key attr-name">set</span> <span class="token value attr-value">global  query_cache_size=600000;</span></pre></td></tr></table></figure><p>如上，<strong>开启查询缓存后在同样的查询条件以及数据情况下，会直接在缓存中返回结果</strong>。这里的查询条件包括查询本身、当前要查询的数据库、客户端协议版本号等一些可能影响结果的信息。</p><p><strong>查询缓存不命中的情况：</strong></p><ol><li>任何两个查询在任何字符上的不同都会导致缓存不命中。</li><li>如果查询中包含任何用户自定义函数、存储函数、用户变量、临时表、MySQL 库中的系统表，其查询结果也不会被缓存。</li><li>缓存建立之后，MySQL 的查询缓存系统会跟踪查询中涉及的每张表，如果这些表（数据或结构）发生变化，那么和这张表相关的所有缓存数据都将失效。</li></ol><p><strong>缓存虽然能够提升数据库的查询性能，但是缓存同时也带来了额外的开销，每次查询后都要做一次缓存操作，失效后还要销毁。</strong> 因此，开启查询缓存要谨慎，尤其对于写密集的应用来说更是如此。如果开启，要注意合理控制缓存空间大小，一般来说其大小设置为几十 MB 比较合适。此外，<strong>还可以通过 <code>sql_cache</code> 和 <code>sql_no_cache</code> 来控制某个查询语句是否需要缓存：</strong></p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">select</span> sql_no_cache <span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">from</span> usr<span class="token punctuation">;</span></pre></td></tr></table></figure><h3 id="mysql日志"><a class="anchor" href="#mysql日志">#</a> MySQL 日志</h3><h4 id="mysql-中常见的日志有哪些"><a class="anchor" href="#mysql-中常见的日志有哪些">#</a> MySQL 中常见的日志有哪些？</h4><p>MySQL 中常见的日志有以下几种：</p><ul><li>二进制日志（ <code>binlog</code> ）：记录了所有修改了数据库结构或数据内容的操作，以便在主从复制时将这些操作同步到从库。二进制日志是<font color="red">逻辑日志</font>，记录的是对<font color="red">数据库结构或数据内容</font>的修改。</li><li>重做日志（ <code>redo log</code> ）：redo log 是 MySQL 的一种日志，<strong>是 InnoDB 存储引擎独有的，它让 MySQL 拥有了崩溃恢复能力</strong>。<font color="red">redo log 只记录该存储引擎中表的修改，而 binlog 是在数据库层面产生的，所有存储引擎对数据库进行修改都会产生 binlog</font>。redo log 是<font color="red">物理日志</font>，记录的是对<font color="red">数据页</font>的修改，而不是对数据的修改。</li><li>回滚日志（undo log）：<strong>是 InnoDB 存储引擎独有的</strong>，记录了所有修改了数据的操作，以便在事务回滚时撤销这些操作。回滚日志是<font color="red">逻辑日志</font>，记录的是对<font color="red">数据</font>的修改，而不是对数据页的修改。</li><li>错误日志（errorlog）：记录了 MySQL 服务器启动、运行过程中出现的错误信息。</li><li>慢查询日志（slow query log）：记录了执行时间超过指定阈值的 SQL 语句。慢查询日志可以用于优化 SQL 语句性能。</li><li>一般查询日志（general log）：记录了 MySQL 服务器接收到的所有 SQL 语句，包括执行时间、执行结果等信息。一般查询日志可以用于调试和安全审计。</li><li>中继日志（relay log）：是 MySQL 主从复制结构中<font color="red">从节点上的日志，用于保存主节点传输过来的数据变更事件，然后将这些事件应用于从节点</font>。</li></ul><h4 id="慢查询日志有什么用"><a class="anchor" href="#慢查询日志有什么用">#</a> 慢查询日志有什么用？</h4><p>用来<font color="red">记录在 MySQL 中响应时间超过阀值的语句</font>，具体指运行时间超过 long_query_time 值的 SQL，则会被记录到慢查询日志中。long_query_time 的默认值为 10，意思是运行 10 秒以上的 SQL 语句。慢查询日志<font color="red">可以帮助开发人员找出哪些语句的执行效率低，以便进行优化</font>。</p><h4 id="binlog-主要记录了什么"><a class="anchor" href="#binlog-主要记录了什么">#</a> binlog 主要记录了什么？</h4><p>binlog 是 MySQL 的二进制日志，主要<font color="red">记录了对 MySQL 数据库进行的所有更改操作，包括插入、更新和删除操作</font>。binlog 可以用于数据恢复、数据同步和数据备份等方面 。</p><h4 id="介绍一下redo-log以及它如何保证事务的持久性"><a class="anchor" href="#介绍一下redo-log以及它如何保证事务的持久性">#</a> 介绍一下 redo log，以及它如何保证事务的持久性？</h4><p>redo log 是 MySQL 的一种日志，<strong>是 InnoDB 存储引擎独有的，它让 MySQL 拥有了崩溃恢复能力</strong>。<font color="red">redo log 只记录该存储引擎中表的修改，而 binlog 是在数据库层面产生的，所有存储引擎对数据库进行修改都会产生 binlog</font>。</p><p>redo log 是 MySQL 数据库用于保证事务的持久性的机制之一。在执行一个事务时，<font color="red">MySQL 会将事务所做出的修改操作先写入 redo log 而不是直接保存到磁盘</font>，也就是 <code>WAL（write ahead log)机制</code> 。这是因为将数据直接写入磁盘的开销较大，而将修改操作写入 redo log 可以大幅减少磁盘 IO 的次数。</p><blockquote><p>WAL（write ahead log）机制的基本思想：</p><p>在修改数据之前，先将修改操作记录到一个日志文件中，然后再将修改操作应用到数据库中。这样，即使在修改数据的过程中出现了故障，也可以通过日志文件来恢复数据 。</p></blockquote><p>当一个事务提交后，<font color="red">MySQL 会从 redo log 中读取相应的修改操作，并将其写入磁盘</font>。<font color="red">只要 redo log 已经持久化（即已经写入磁盘），那么就可以保证故障发生后能够完成数据恢复</font>。如果 MySQL 在执行修改操作时遇到了宕机等问题，在重启后会重新应用 redo log 里未被应用的操作，从而实现事务的持久性。</p><h4 id="数据页是什么"><a class="anchor" href="#数据页是什么">#</a> 数据页是什么？</h4><p>数据页是 InnoDB 存储引擎中的一个重要概念，它<strong>是 InnoDB 存储引擎中的最小存储单位。InnoDB 存储引擎将表空间分为多个大小相等的数据页，每个数据页默认大小为 16KB</strong>。在 InnoDB 存储引擎中，每个表都有一个独立的表空间，表空间由多个数据文件组成。当表中的数据发生变化时，InnoDB 存储引擎会将修改操作记录到 redo log 中，并将修改操作应用到内存中的数据页中。当内存中的数据页被修改后，InnoDB 存储引擎会将修改操作异步刷新到磁盘上的数据文件中，从而保证了数据的持久性。</p><h4 id="页修改之后为什么不直接刷盘呢"><a class="anchor" href="#页修改之后为什么不直接刷盘呢">#</a> 页修改之后为什么不直接刷盘呢？</h4><p>在数据库中，将修改的数据直接刷盘（写入磁盘）可能会产生一些性能开销。这是因为在执行随机磁盘 IO 的过程中，磁盘的寻址时间和磁道切换时间等所需的开销较大，说明磁盘 IO 时需要耗费较长的时间。因此<strong>直接刷盘会导致大量的磁盘 I/O，降低系统的性能</strong>。</p><p>为了避免这种情况，InnoDB 存储引擎采用了一种称为 “ <code>脏页刷盘</code> ” 的机制。<font color="red">在数据库缓存中，如果一个数据页上的数据已经被修改了，但还没有被同步写入磁盘，那么这个数据页就被称为 “ <code>脏页</code> ”</font>。 <code>脏页刷盘</code> 机制是指 InnoDB 存储引擎在<font color="red">将内存中的数据页刷新到磁盘上</font>时，会根据一定的策略来决定哪些数据页需要被刷新到磁盘上，哪些数据页可以暂时不刷新。</p><ul><li><font color="red">当内存中的数据页被修改前，InnoDB 存储引擎会将修改操作记录到 redo log 中，并将修改操作应用到内存中的数据页中</font>。</li><li><font color="red">当内存中的数据页被修改后，InnoDB 存储引擎会将修改操作异步刷新到磁盘上的数据文件中，从而保证了数据的持久性</font>。在这个过程中，InnoDB 存储引擎会根据一定的策略来决定哪些数据页需要被刷新到磁盘上，哪些数据页可以暂时不刷新。这样可以避免大量的磁盘 I/O，提高系统的性能。</li></ul><h4 id="binlog-和-redolog-有什么区别"><a class="anchor" href="#binlog-和-redolog-有什么区别">#</a> binlog 和 redolog 有什么区别？</h4><p>binlog 和 redolog 都是 MySQL 数据库中的日志文件，用于记录数据库的修改操作。它们的主要区别在于：</p><ol><li><p>binlog 是 MySQL 的归档日志，用于<font color="red">记录所有的修改操作，包括数据的增删改操作和表结构的变更操作等</font>。binlog 的作用是<font color="red">用于数据恢复、主从复制和数据同步</font>等场景。</p></li><li><p>redolog 是 InnoDB 存储引擎的事务日志，用于<font color="red">记录事务的修改操作</font>。redolog 的作用是<font color="red">用于保证事务的原子性、一致性和持久性</font>。当一个事务提交时，会将该事务所做的所有修改操作先记录在 redo log 中并刷到磁盘上，然后再将这些修改操作同步到数据库的数据文件中。</p></li></ol><p>区别:</p><ul><li>binlog 是整个<font color="red">数据库实例级别</font>的，记录了对整个数据库实例进行的所有更改操作，而 redolog 是每个<font color="red">InnoDB 存储引擎实例级别</font>的，只记录了在该存储引擎实例中发生的事务更改操作。</li><li>binlog 是对<font color="red">数据库执行的语句级别</font>的日志，redolog 是对<font color="red">事务级别</font>的日志，记录了事务的具体操作信息。</li><li>binlog 通常<font color="red">用于 JDBC 等客户端进行异地灾难恢复</font>，而 redolog<font color="red">用于保证事务的 ACID 属性（原子性、一致性、隔离性和持久性）</font>。</li></ul><p>因为<font color="red"> binlog 记录了所有的修改操作，所以它比 redolog 更加全面，但也更加耗费磁盘空间</font>。而 <font color="red">redolog 只记录了事务的修改操作，所以它比 binlog 更加高效，但也更加局限</font>。</p><h4 id="undo-log-如何保证事务的原子性"><a class="anchor" href="#undo-log-如何保证事务的原子性">#</a> undo log 如何保证事务的原子性？</h4><p>undo log <font color="red">是 InnoDB 存储引擎的</font>回滚日志，<font color="red">用于记录事务的回滚操作</font>。</p><p>当一个事务需要回滚时，InnoDB 存储引擎会根据 undo log 中的信息将数据页恢复到事务开始之前的状态。因此，undo log 可以保证事务的原子性。</p><p>在 InnoDB 存储引擎中，每个事务都有一个对应的 undo log，用于记录该事务所做的修改操作。当事务提交时，InnoDB 存储引擎会将 undo log 中的信息删除，从而释放磁盘空间。如果事务回滚，则 InnoDB 存储引擎会根据 undo log 中的信息将数据页恢复到事务开始之前的状态。这样可以保证事务的原子性。</p><h3 id="mysql事务"><a class="anchor" href="#mysql事务">#</a> MySQL 事务</h3><h4 id="何谓事务"><a class="anchor" href="#何谓事务">#</a> 何谓事务？</h4><p>我们设想一个场景，这个场景中我们需要插入多条相关联的数据到数据库，不幸的是，这个过程可能会遇到下面这些问题：</p><ul><li>数据库中途突然因为某些原因挂掉了。</li><li>客户端突然因为网络原因连接不上数据库了。</li><li>并发访问数据库时，多个线程同时写入数据库，覆盖了彼此的更改。</li><li>......</li></ul><p>上面的任何一个问题都可能会导致数据的不一致性。为了保证数据的一致性，系统必须能够处理这些问题。事务就是我们抽象出来简化这些问题的首选机制。事务的概念起源于数据库，目前，已经成为一个比较广泛的概念。</p><p>何为事务？ 一言蔽之，<strong>事务是逻辑上的一组操作，要么都执行，要么都不执行。</strong></p><p>事务最经典也经常被拿出来说例子就是转账了。假如小明要给小红转账 1000 元，这个转账会涉及到两个关键操作，这两个操作必须都成功或者都失败。</p><ol><li>将小明的余额减少 1000 元</li><li>将小红的余额增加 1000 元。</li></ol><p>事务会把这两个操作就可以看成逻辑上的一个整体，这个整体包含的操作要么都成功，要么都要失败。这样就不会出现小明余额减少而小红的余额却并没有增加的情况。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230424112229682.png" alt="image-20230424112229682"></p><h4 id="何谓数据库事务"><a class="anchor" href="#何谓数据库事务">#</a> 何谓数据库事务？</h4><p>大多数情况下，我们在谈论事务的时候，如果没有特指<strong>分布式事务</strong>，往往指的就是<strong>数据库事务</strong>。</p><p>数据库事务在我们日常开发中接触的最多了。如果你的项目属于单体架构的话，你接触到的往往就是数据库事务了。</p><p><strong>那数据库事务有什么作用呢？</strong></p><p>简单来说，<font color="red">数据库事务可以保证多个对数据库的操作（也就是 SQL 语句）构成一个逻辑上的整体</font>。构成这个逻辑上的整体的这些数据库操作遵循：<strong>要么全部执行成功，要么全部不执行</strong> 。</p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment"># 开启一个事务</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">START</span> <span class="token keyword">TRANSACTION</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment"># 多条 SQL 语句</span></pre></td></tr><tr><td data-num="4"></td><td><pre>SQL1<span class="token punctuation">,</span>SQL2<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token comment">## 提交事务</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">COMMIT</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230424112420132.png" alt="image-20230424112420132"></p><p>另外，关系型数据库（例如： <code>MySQL</code> 、 <code>SQL Server</code> 、 <code>Oracle</code> 等）事务都有 <strong>ACID</strong> 特性：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230424112518237.png" alt="image-20230424112518237"></p><ol><li><strong>原子性</strong>（ <code>Atomicity</code> ） ： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li><li><strong>一致性</strong>（ <code>Consistency</code> ）： 执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；</li><li><strong>隔离性</strong>（ <code>Isolation</code> ）： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</li><li><strong>持久性</strong>（ <code>Durability</code> ）： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li></ol><p>🌈 这里要额外补充一点：<strong>只有保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。也就是说 A、I、D 是手段，C 是目的！</strong> 想必大家也和我一样，被 ACID 这个概念被误导了很久！我也是看周志明老师的公开课<span class="exturl" data-url="aHR0cHM6Ly90aW1lLmdlZWtiYW5nLm9yZy9vcGVuY291cnNlL2ludHJvLzEwMDA2NDIwMQ==">《周志明的软件架构课》open in new window</span> 才搞清楚的（多看好书！！！）。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230424112548870.png" alt="image-20230424112548870"></p><p>另外，DDIA 也就是 <span class="exturl" data-url="aHR0cHM6Ly9ib29rLmRvdWJhbi5jb20vc3ViamVjdC8zMDMyOTUzNi8=">《Designing Data-Intensive Application（数据密集型应用系统设计）》open in new window</span> 的作者在他的这本书中如是说：</p><blockquote><p>Atomicity, isolation, and durability are properties of the database, whereas consis‐ tency (in the ACID sense) is a property of the application. The application may rely on the database’s atomicity and isolation properties in order to achieve consistency, but it’s not up to the database alone.</p><p>翻译过来的意思是：原子性，隔离性和持久性是数据库的属性，而一致性（在 ACID 意义上）是应用程序的属性。应用可能依赖数据库的原子性和隔离属性来实现一致性，但这并不仅取决于数据库。因此，字母 C 不属于 ACID 。</p></blockquote><p>《Designing Data-Intensive Application（数据密集型应用系统设计）》这本书强推一波，值得读很多遍！豆瓣有接近 90% 的人看了这本书之后给了五星好评。另外，中文翻译版本已经在 Github 开源，地址：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Zvbm5nL2RkaWE=">https://github.com/Vonng/ddiaopen in new window</span> 。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/ddia.png" alt="img"></p><h4 id="并发事务带来了哪些问题"><a class="anchor" href="#并发事务带来了哪些问题">#</a> 并发事务带来了哪些问题？</h4><p>在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对同一数据进行操作）。并发虽然是必须的，但可能会导致以下的问题。</p><h5 id="脏读dirty-read"><a class="anchor" href="#脏读dirty-read">#</a> 脏读（Dirty read）</h5><p>一个事务读取数据并且对数据进行了修改，这个修改对其他事务来说是可见的，即使当前事务没有提交。这时另外一个事务读取了这个还未提交的数据，但第一个事务突然回滚，导致数据并没有被提交到数据库，那第二个事务读取到的就是脏数据，这也就是脏读的由来。</p><p>例如：事务 1 读取某表中的数据 A=20，事务 1 修改 A=A-1，事务 2 读取到 A = 19, 事务 1 回滚导致对 A 的修改并为提交到数据库， A 的值还是 20。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230424112618536.png" alt="image-20230424112618536"></p><h5 id="丢失修改lost-to-modify"><a class="anchor" href="#丢失修改lost-to-modify">#</a> 丢失修改（Lost to modify）</h5><p>在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。</p><p>例如：事务 1 读取某表中的数据 A=20，事务 2 也读取 A=20，事务 1 先修改 A=A-1，事务 2 后来也修改 A=A-1，最终结果 A=19，事务 1 的修改被丢失。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230424112636565.png" alt="image-20230424112636565"></p><h5 id="不可重复读unrepeatable-read"><a class="anchor" href="#不可重复读unrepeatable-read">#</a> 不可重复读（Unrepeatable read）</h5><p>指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。</p><p>例如：事务 1 读取某表中的数据 A=20，事务 2 也读取 A=20，事务 1 修改 A=A-1，事务 2 再次读取 A =19，此时读取的结果和第一次读取的结果不同。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230424112650372.png" alt="image-20230424112650372"></p><h5 id="幻读phantom-read"><a class="anchor" href="#幻读phantom-read">#</a> 幻读（Phantom read）</h5><p>幻读与不可重复读类似。它发生在一个事务读取了几行数据，接着另一个并发事务插入了一些数据时。在随后的查询中，第一个事务就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</p><p>例如：事务 2 读取某个范围的数据，事务 1 在这个范围插入了新的数据，事务 2 再次读取这个范围的数据发现相比于第一次读取的结果多了新的数据。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230424112700267.png" alt="image-20230424112700267"></p><h4 id="不可重复读和幻读有什么区别"><a class="anchor" href="#不可重复读和幻读有什么区别">#</a> 不可重复读和幻读有什么区别？</h4><ul><li>不可重复读的重点是内容修改或者记录减少比如多次读取一条记录发现其中某些记录的值被修改；</li><li>幻读的重点在于记录新增比如多次执行同一条查询语句（DQL）时，发现查到的记录增加了。</li></ul><p>幻读其实可以看作是不可重复读的一种特殊情况，单独把区分幻读的原因主要是解决幻读和不可重复读的方案不一样。</p><p>举个例子：执行 <code>delete</code> 和 <code>update</code> 操作的时候，可以直接对记录加锁，保证事务安全。而执行 <code>insert</code> 操作的时候，由于记录锁（Record Lock）只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁（Gap Lock）。也就是说执行 <code>insert</code> 操作的时候需要依赖 Next-Key Lock（Record Lock+Gap Lock） 进行加锁来保证不出现幻读。</p><h4 id="并发事务的控制方式有哪些"><a class="anchor" href="#并发事务的控制方式有哪些">#</a> 并发事务的控制方式有哪些？</h4><p>MySQL 中并发事务的控制方式无非就两种：<strong>锁</strong> 和 <strong>MVCC</strong>。锁可以看作是悲观控制的模式，多版本并发控制（MVCC，Multiversion concurrency control）可以看作是乐观控制的模式。</p><p><strong>锁</strong> 控制方式下会通过锁来显示控制共享资源而不是通过调度手段，MySQL 中主要是通过 <strong>读写锁</strong> 来实现并发控制。</p><ul><li><strong>共享锁（S 锁）</strong> ：又称读锁，事务在读取记录的时候获取共享锁，允许多个事务同时获取（锁兼容）。</li><li><strong>排他锁（X 锁）</strong> ：又称写锁 / 独占锁，事务在修改记录的时候获取排他锁，不允许多个事务同时获取。如果一个记录已经被加了排他锁，那其他事务不能再对这条记录加任何类型的锁（锁不兼容）。</li></ul><p>读写锁可以做到读读并行，但是无法做到写读、写写并行。另外，根据根据锁粒度的不同，又被分为 <strong>表级锁 (table-level locking)</strong> 和 <strong>行级锁 (row-level locking)</strong> 。InnoDB 不光支持表级锁，还支持行级锁，默认为行级锁。行级锁的粒度更小，仅对相关的记录上锁即可（对一行或者多行记录加锁），所以对于并发写入操作来说， InnoDB 的性能更高。不论是表级锁还是行级锁，都存在共享锁（Share Lock，S 锁）和排他锁（Exclusive Lock，X 锁）这两类。</p><p><strong>MVCC</strong> 是多版本并发控制方法，即对一份数据会存储多个版本，通过事务的可见性来保证事务能看到自己应该看到的版本。通常会有一个全局的版本分配器来为每一行数据设置版本号，版本号是唯一的。</p><p>MVCC 在 MySQL 中实现所依赖的手段主要是: <strong>隐藏字段、read view、undo log</strong>。</p><ul><li>undo log : undo log 用于记录某行数据的多个版本的数据。</li><li>read view 和 隐藏字段：用来判断当前版本数据的可见性。</li></ul><p>关于 InnoDB 对 MVCC 的具体实现可以看这篇文章：<span class="exturl" data-url="aHR0cHM6Ly9qYXZhZ3VpZGUuY24vZGF0YWJhc2UvbXlzcWwvaW5ub2RiLWltcGxlbWVudGF0aW9uLW9mLW12Y2MuaHRtbA==">InnoDB 存储引擎对 MVCC 的实现 open in new window</span> 。</p><h4 id="sql-标准定义了哪些事务隔离级别"><a class="anchor" href="#sql-标准定义了哪些事务隔离级别">#</a> SQL 标准定义了哪些事务隔离级别？</h4><p>SQL 标准定义了四个隔离级别：</p><ul><li><strong>READ-UNCOMMITTED (读取未提交)</strong> ： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。</li><li><strong>READ-COMMITTED (读取已提交)</strong> ： 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。</li><li><strong>REPEATABLE-READ (可重复读)</strong> ： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</li><li><strong>SERIALIZABLE (可串行化)</strong> ： 最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。</li></ul><hr><table><thead><tr><th style="text-align:center">隔离级别</th><th style="text-align:center">脏读</th><th style="text-align:center">不可重复读</th><th style="text-align:center">幻读</th></tr></thead><tbody><tr><td style="text-align:center">READ-UNCOMMITTED</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">√</td></tr><tr><td style="text-align:center">READ-COMMITTED</td><td style="text-align:center">×</td><td style="text-align:center">√</td><td style="text-align:center">√</td></tr><tr><td style="text-align:center">REPEATABLE-READ</td><td style="text-align:center">×</td><td style="text-align:center">×</td><td style="text-align:center">√</td></tr><tr><td style="text-align:center">SERIALIZABLE</td><td style="text-align:center">×</td><td style="text-align:center">×</td><td style="text-align:center">×</td></tr></tbody></table><h4 id="mysql-的隔离级别是基于锁实现的吗"><a class="anchor" href="#mysql-的隔离级别是基于锁实现的吗">#</a> MySQL 的隔离级别是基于锁实现的吗？</h4><p>MySQL 的隔离级别基于锁和 MVCC 机制共同实现的。</p><p>SERIALIZABLE 隔离级别是通过锁来实现的，READ-COMMITTED 和 REPEATABLE-READ 隔离级别是基于 MVCC 实现的。不过， SERIALIZABLE 之外的其他隔离级别可能也需要用到锁机制，就比如 REPEATABLE-READ 在当前读情况下需要使用加锁读来保证不会出现幻读。</p><h4 id="mysql-的默认隔离级别是什么"><a class="anchor" href="#mysql-的默认隔离级别是什么">#</a> MySQL 的默认隔离级别是什么？</h4><p>MySQL InnoDB 存储引擎的默认支持的隔离级别是 <strong>REPEATABLE-READ（可重读）</strong>。我们可以通过 <code>SELECT @@tx_isolation;</code> 命令来查看，MySQL 8.0 该命令改为 <code>SELECT @@transaction_isolation;</code></p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre>mysql<span class="token operator">></span> <span class="token keyword">SELECT</span> @<span class="token variable">@tx_isolation</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token operator">+</span><span class="token comment">-----------------+</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token operator">|</span> @<span class="token variable">@tx_isolation</span>  <span class="token operator">|</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token operator">+</span><span class="token comment">-----------------+</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token operator">|</span> <span class="token keyword">REPEATABLE</span><span class="token operator">-</span><span class="token keyword">READ</span> <span class="token operator">|</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token operator">+</span><span class="token comment">-----------------+</span></pre></td></tr></table></figure><p>关于 MySQL 事务隔离级别的详细介绍，可以看看我写的这篇文章：<span class="exturl" data-url="aHR0cHM6Ly9qYXZhZ3VpZGUuY24vZGF0YWJhc2UvbXlzcWwvdHJhbnNhY3Rpb24taXNvbGF0aW9uLWxldmVsLmh0bWw=">MySQL 事务隔离级别详解 open in new window</span>。</p><h2 id="mysql高性能优化规范建议"><a class="anchor" href="#mysql高性能优化规范建议">#</a> MySQL 高性能优化规范建议</h2><h2 id="️重要知识点"><a class="anchor" href="#️重要知识点">#</a> ⭐️重要知识点</h2><h1 id="redis"><a class="anchor" href="#redis">#</a> Redis</h1><h2 id="缓存基础常见面试题"><a class="anchor" href="#缓存基础常见面试题">#</a> 缓存基础常见面试题</h2><h2 id="redis常见面试题上"><a class="anchor" href="#redis常见面试题上">#</a> Redis 常见面试题（上）</h2><h2 id="redis常见面试题下"><a class="anchor" href="#redis常见面试题下">#</a> Redis 常见面试题（下）</h2><h2 id="️重要知识点-2"><a class="anchor" href="#️重要知识点-2">#</a> ⭐️重要知识点</h2><h1 id="elasticsearch"><a class="anchor" href="#elasticsearch">#</a> Elasticsearch</h1><h1 id="mongodb"><a class="anchor" href="#mongodb">#</a> MongoDB</h1><h2 id="mongodb常见面试题上"><a class="anchor" href="#mongodb常见面试题上">#</a> MongoDB 常见面试题（上）</h2><h2 id="mongodb常见面试题下"><a class="anchor" href="#mongodb常见面试题下">#</a> MongoDB 常见面试题（下）</h2></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2023-11-11 23:55:57" itemprop="dateModified" datetime="2023-11-11T23:55:57+08:00">2023-11-11</time> </span><span id="database/数据库/" class="item leancloud_visitors" data-flag-title="数据库总结" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>范特东东东 <i class="ic i-at"><em>@</em></i>水文 & 摄影</li><li class="link"><strong>本文链接：</strong> <a href="http://example.com/database/%E6%95%B0%E6%8D%AE%E5%BA%93/" title="数据库总结">http://example.com/database/数据库/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/java/jvm/JVM%E7%AC%94%E8%AE%B0/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;hjx159&#x2F;picture-bed&#x2F;main&#x2F;img&#x2F;68747470733a2f2f7365617a65616e2e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f696d672f4a6176612f4a564d2d4a617661382545352538362538352545352541442539382545372542422539332545362539452538342545352539422542452e706e67" title="JVM笔记"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> JVM</span><h3>JVM笔记</h3></a></div><div class="item right"><a href="/framework/spring/spring6/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;hjx159&#x2F;picture-bed&#x2F;main&#x2F;img&#x2F;2097896352.png" title="尚硅谷 Spring6"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> Spring</span><h3>尚硅谷 Spring6</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80"><span class="toc-number">1.</span> <span class="toc-text">基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80"><span class="toc-number">1.1.</span> <span class="toc-text">数据库基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E6%8D%AE%E5%BA%93-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86%E5%91%98"><span class="toc-number">1.1.1.</span> <span class="toc-text">什么是数据库，数据库管理系统，数据库系统，数据库管理员？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%85%83%E7%BB%84-%E7%A0%81-%E5%80%99%E9%80%89%E7%A0%81-%E4%B8%BB%E7%A0%81-%E5%A4%96%E7%A0%81-%E4%B8%BB%E5%B1%9E%E6%80%A7-%E9%9D%9E%E4%B8%BB%E5%B1%9E%E6%80%A7"><span class="toc-number">1.1.2.</span> <span class="toc-text">什么是元组，码，候选码，主码，外码，主属性，非主属性？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-er-%E5%9B%BE"><span class="toc-number">1.1.3.</span> <span class="toc-text">什么是 ER 图？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E8%8C%83%E5%BC%8F%E4%BA%86%E8%A7%A3%E5%90%97"><span class="toc-number">1.1.4.</span> <span class="toc-text">数据库范式了解吗？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1nf%E7%AC%AC%E4%B8%80%E8%8C%83%E5%BC%8F"><span class="toc-number">1.1.4.1.</span> <span class="toc-text">1NF (第一范式)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2nf%E7%AC%AC%E4%BA%8C%E8%8C%83%E5%BC%8F"><span class="toc-number">1.1.4.2.</span> <span class="toc-text">2NF (第二范式)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3nf%E7%AC%AC%E4%B8%89%E8%8C%83%E5%BC%8F"><span class="toc-number">1.1.4.3.</span> <span class="toc-text">3NF (第三范式)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E9%94%AE%E5%92%8C%E5%A4%96%E9%94%AE%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">1.1.5.</span> <span class="toc-text">主键和外键有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8%E5%A4%96%E9%94%AE%E4%B8%8E%E7%BA%A7%E8%81%94"><span class="toc-number">1.1.6.</span> <span class="toc-text">为什么不推荐使用外键与级联？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B"><span class="toc-number">1.1.7.</span> <span class="toc-text">什么是存储过程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#drop-delete-%E4%B8%8E-truncate-%E5%8C%BA%E5%88%AB"><span class="toc-number">1.1.8.</span> <span class="toc-text">drop、delete 与 truncate 区别？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E6%B3%95%E4%B8%8D%E5%90%8C"><span class="toc-number">1.1.8.1.</span> <span class="toc-text">用法不同</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%9E%E4%BA%8E%E4%B8%8D%E5%90%8C%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%AD%E8%A8%80"><span class="toc-number">1.1.8.2.</span> <span class="toc-text">属于不同的数据库语言</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E9%80%9F%E5%BA%A6%E4%B8%8D%E5%90%8C"><span class="toc-number">1.1.8.3.</span> <span class="toc-text">执行速度不同</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E9%80%9A%E5%B8%B8%E5%88%86%E4%B8%BA%E5%93%AA%E5%87%A0%E6%AD%A5"><span class="toc-number">1.1.9.</span> <span class="toc-text">数据库设计通常分为哪几步？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#nosql%E5%9F%BA%E7%A1%80"><span class="toc-number">1.2.</span> <span class="toc-text">NoSQL 基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#nosql-%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.2.1.</span> <span class="toc-text">NoSQL 是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sql-%E5%92%8C-nosql-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">1.2.2.</span> <span class="toc-text">SQL 和 NoSQL 有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#nosql-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E5%8A%BF"><span class="toc-number">1.2.3.</span> <span class="toc-text">NoSQL 数据库有什么优势？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#nosql-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%89%E5%93%AA%E4%BA%9B%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.2.4.</span> <span class="toc-text">NoSQL 数据库有哪些类型？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E9%9B%86%E8%AF%A6%E8%A7%A3"><span class="toc-number">1.3.</span> <span class="toc-text">字符集详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%95%E4%B8%BA%E5%AD%97%E7%AC%A6%E9%9B%86"><span class="toc-number">1.3.1.</span> <span class="toc-text">何为字符集？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9A%84%E5%AD%97%E7%AC%A6%E9%9B%86"><span class="toc-number">1.3.2.</span> <span class="toc-text">有哪些常见的字符集？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ascii"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">ASCII</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#gb2312"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">GB2312</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#gbk"><span class="toc-number">1.3.2.3.</span> <span class="toc-text">GBK</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#gb18030"><span class="toc-number">1.3.2.4.</span> <span class="toc-text">GB18030</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#big5"><span class="toc-number">1.3.2.5.</span> <span class="toc-text">BIG5</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#unicode-utf-8%E7%BC%96%E7%A0%81"><span class="toc-number">1.3.2.6.</span> <span class="toc-text">Unicode &amp; UTF-8 编码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mysql-%E5%AD%97%E7%AC%A6%E9%9B%86"><span class="toc-number">1.3.3.</span> <span class="toc-text">MySQL 字符集</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sql"><span class="toc-number">1.4.</span> <span class="toc-text">SQL</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#sql%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80"><span class="toc-number">1.4.1.</span> <span class="toc-text">SQL 语法基础</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%AF%E8%AF%AD"><span class="toc-number">1.4.1.1.1.</span> <span class="toc-text">数据库术语</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#sql-%E8%AF%AD%E6%B3%95"><span class="toc-number">1.4.1.1.2.</span> <span class="toc-text">SQL 语法</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#sql-%E8%AF%AD%E6%B3%95%E7%BB%93%E6%9E%84"><span class="toc-number">1.4.1.1.2.1.</span> <span class="toc-text">SQL 语法结构</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#sql-%E8%AF%AD%E6%B3%95%E8%A6%81%E7%82%B9"><span class="toc-number">1.4.1.1.2.2.</span> <span class="toc-text">SQL 语法要点</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#sql-%E5%88%86%E7%B1%BB"><span class="toc-number">1.4.1.1.3.</span> <span class="toc-text">SQL 分类</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%AE%9A%E4%B9%89%E8%AF%AD%E8%A8%80ddl"><span class="toc-number">1.4.1.1.3.1.</span> <span class="toc-text">数据定义语言（DDL）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%93%8D%E7%BA%B5%E8%AF%AD%E8%A8%80dml"><span class="toc-number">1.4.1.1.3.2.</span> <span class="toc-text">数据操纵语言（DML）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E6%8E%A7%E5%88%B6%E8%AF%AD%E8%A8%80tcl"><span class="toc-number">1.4.1.1.3.3.</span> <span class="toc-text">事务控制语言（TCL）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%8E%A7%E5%88%B6%E8%AF%AD%E8%A8%80dcl"><span class="toc-number">1.4.1.1.3.4.</span> <span class="toc-text">数据控制语言（DCL）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5"><span class="toc-number">1.4.1.2.</span> <span class="toc-text">增删改查</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE"><span class="toc-number">1.4.1.2.1.</span> <span class="toc-text">插入数据</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE"><span class="toc-number">1.4.1.2.2.</span> <span class="toc-text">更新数据</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE"><span class="toc-number">1.4.1.2.3.</span> <span class="toc-text">删除数据</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E6%95%B0%E6%8D%AE"><span class="toc-number">1.4.1.2.4.</span> <span class="toc-text">查询数据</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F"><span class="toc-number">1.4.1.3.</span> <span class="toc-text">排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E7%BB%84"><span class="toc-number">1.4.1.4.</span> <span class="toc-text">分组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%90%E6%9F%A5%E8%AF%A2"><span class="toc-number">1.4.1.5.</span> <span class="toc-text">子查询</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#where"><span class="toc-number">1.4.1.5.1.</span> <span class="toc-text">WHERE</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#in-%E5%92%8C-between"><span class="toc-number">1.4.1.5.2.</span> <span class="toc-text">IN 和 BETWEEN</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#and-or-not"><span class="toc-number">1.4.1.5.3.</span> <span class="toc-text">AND、OR、NOT</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#like"><span class="toc-number">1.4.1.5.4.</span> <span class="toc-text">LIKE</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5"><span class="toc-number">1.4.1.6.</span> <span class="toc-text">连接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%84%E5%90%88"><span class="toc-number">1.4.1.7.</span> <span class="toc-text">组合</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-number">1.4.1.8.</span> <span class="toc-text">函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86"><span class="toc-number">1.4.1.8.1.</span> <span class="toc-text">文本处理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4%E5%A4%84%E7%90%86"><span class="toc-number">1.4.1.8.2.</span> <span class="toc-text">日期和时间处理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E5%80%BC%E5%A4%84%E7%90%86"><span class="toc-number">1.4.1.8.3.</span> <span class="toc-text">数值处理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B1%87%E6%80%BB"><span class="toc-number">1.4.1.8.4.</span> <span class="toc-text">汇总</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%AE%9A%E4%B9%89"><span class="toc-number">1.4.1.9.</span> <span class="toc-text">数据定义</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93database"><span class="toc-number">1.4.1.9.1.</span> <span class="toc-text">数据库（DATABASE）</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">1.4.1.9.1.1.</span> <span class="toc-text">创建数据库</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">1.4.1.9.1.2.</span> <span class="toc-text">删除数据库</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">1.4.1.9.1.3.</span> <span class="toc-text">选择数据库</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E8%A1%A8table"><span class="toc-number">1.4.1.9.2.</span> <span class="toc-text">数据表（TABLE）</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E8%A1%A8"><span class="toc-number">1.4.1.9.2.1.</span> <span class="toc-text">创建数据表</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE%E8%A1%A8"><span class="toc-number">1.4.1.9.2.2.</span> <span class="toc-text">删除数据表</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E6%95%B0%E6%8D%AE%E8%A1%A8"><span class="toc-number">1.4.1.9.2.3.</span> <span class="toc-text">修改数据表</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%86%E5%9B%BEview"><span class="toc-number">1.4.1.9.3.</span> <span class="toc-text">视图（VIEW）</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E8%A7%86%E5%9B%BE"><span class="toc-number">1.4.1.9.3.1.</span> <span class="toc-text">创建视图</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E8%A7%86%E5%9B%BE"><span class="toc-number">1.4.1.9.3.2.</span> <span class="toc-text">删除视图</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95index"><span class="toc-number">1.4.1.9.4.</span> <span class="toc-text">索引（INDEX）</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95"><span class="toc-number">1.4.1.9.4.1.</span> <span class="toc-text">创建索引</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E7%B4%A2%E5%BC%95"><span class="toc-number">1.4.1.9.4.2.</span> <span class="toc-text">添加索引</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95"><span class="toc-number">1.4.1.9.4.3.</span> <span class="toc-text">创建唯一索引</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E7%B4%A2%E5%BC%95"><span class="toc-number">1.4.1.9.4.4.</span> <span class="toc-text">删除索引</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BA%A6%E6%9D%9F"><span class="toc-number">1.4.1.9.5.</span> <span class="toc-text">约束</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86"><span class="toc-number">1.4.1.10.</span> <span class="toc-text">事务处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6"><span class="toc-number">1.4.1.11.</span> <span class="toc-text">权限控制</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E8%B4%A6%E6%88%B7"><span class="toc-number">1.4.1.11.1.</span> <span class="toc-text">创建账户</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E8%B4%A6%E6%88%B7%E5%90%8D"><span class="toc-number">1.4.1.11.2.</span> <span class="toc-text">修改账户名</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E8%B4%A6%E6%88%B7"><span class="toc-number">1.4.1.11.3.</span> <span class="toc-text">删除账户</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E6%9D%83%E9%99%90"><span class="toc-number">1.4.1.11.4.</span> <span class="toc-text">查看权限</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8E%88%E4%BA%88%E6%9D%83%E9%99%90"><span class="toc-number">1.4.1.11.5.</span> <span class="toc-text">授予权限</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%9D%83%E9%99%90"><span class="toc-number">1.4.1.11.6.</span> <span class="toc-text">删除权限</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9B%B4%E6%94%B9%E5%AF%86%E7%A0%81"><span class="toc-number">1.4.1.11.7.</span> <span class="toc-text">更改密码</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B"><span class="toc-number">1.4.1.12.</span> <span class="toc-text">存储过程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B"><span class="toc-number">1.4.1.12.1.</span> <span class="toc-text">创建存储过程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B"><span class="toc-number">1.4.1.12.2.</span> <span class="toc-text">使用存储过程</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B8%B8%E6%A0%87"><span class="toc-number">1.4.1.13.</span> <span class="toc-text">游标</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A6%E5%8F%91%E5%99%A8"><span class="toc-number">1.4.1.14.</span> <span class="toc-text">触发器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E8%A7%A6%E5%8F%91%E5%99%A8"><span class="toc-number">1.4.1.14.1.</span> <span class="toc-text">创建触发器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E8%A7%A6%E5%8F%91%E5%99%A8"><span class="toc-number">1.4.1.14.2.</span> <span class="toc-text">查看触发器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E8%A7%A6%E5%8F%91%E5%99%A8"><span class="toc-number">1.4.1.14.3.</span> <span class="toc-text">删除触发器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sql%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">1.4.2.</span> <span class="toc-text">SQL 常见面试题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#mysql"><span class="toc-number">2.</span> <span class="toc-text">MySQL</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#mysql%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">2.1.</span> <span class="toc-text">MySQL 常见面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#mysql%E5%9F%BA%E7%A1%80"><span class="toc-number">2.1.1.</span> <span class="toc-text">MySQL 基础</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">2.1.1.1.</span> <span class="toc-text">什么是关系型数据库？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-sql"><span class="toc-number">2.1.1.2.</span> <span class="toc-text">什么是 SQL？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-mysql"><span class="toc-number">2.1.1.3.</span> <span class="toc-text">什么是 MySQL？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mysql-%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E7%82%B9"><span class="toc-number">2.1.1.4.</span> <span class="toc-text">MySQL 有什么优点？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mysql%E5%AD%97%E6%AE%B5%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.1.2.</span> <span class="toc-text">MySQL 字段类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E7%B1%BB%E5%9E%8B%E7%9A%84-unsigned-%E5%B1%9E%E6%80%A7%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8"><span class="toc-number">2.1.2.1.</span> <span class="toc-text">整数类型的 UNSIGNED 属性有什么用？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#char-%E5%92%8C-varchar-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">2.1.2.2.</span> <span class="toc-text">CHAR 和 VARCHAR 的区别是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#varchar100%E5%92%8C-varchar10%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">2.1.2.3.</span> <span class="toc-text">VARCHAR (100) 和 VARCHAR (10) 的区别是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#decimal-%E5%92%8C-floatdouble-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">2.1.2.4.</span> <span class="toc-text">DECIMAL 和 FLOAT&#x2F;DOUBLE 的区别是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8-text-%E5%92%8C-blob"><span class="toc-number">2.1.2.5.</span> <span class="toc-text">为什么不推荐使用 TEXT 和 BLOB？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#datetime-%E5%92%8C-timestamp-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">2.1.2.6.</span> <span class="toc-text">DATETIME 和 TIMESTAMP 的区别是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#null-%E5%92%8C-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">2.1.2.7.</span> <span class="toc-text">NULL 和 &#39;&#39; 的区别是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#boolean-%E7%B1%BB%E5%9E%8B%E5%A6%82%E4%BD%95%E8%A1%A8%E7%A4%BA"><span class="toc-number">2.1.2.8.</span> <span class="toc-text">Boolean 类型如何表示？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mysql%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84"><span class="toc-number">2.1.3.</span> <span class="toc-text">MySQL 基础架构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-mysql-%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84%E5%88%86%E6%9E%90"><span class="toc-number">2.1.3.1.</span> <span class="toc-text">1、MySQL 基础架构分析</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#11-%E6%9E%B6%E6%9E%84%E6%A6%82%E8%A7%88"><span class="toc-number">2.1.3.1.1.</span> <span class="toc-text">1.1、架构概览</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#12-server-%E5%B1%82%E7%9A%84%E7%BB%84%E4%BB%B6%E4%BB%8B%E7%BB%8D"><span class="toc-number">2.1.3.1.2.</span> <span class="toc-text">1.2、Server 层的组件介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1%E8%BF%9E%E6%8E%A5%E5%99%A8"><span class="toc-number">2.1.3.1.2.1.</span> <span class="toc-text">1）连接器</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98"><span class="toc-number">2.1.3.1.2.2.</span> <span class="toc-text">2）查询缓存</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3%E5%88%86%E6%9E%90%E5%99%A8"><span class="toc-number">2.1.3.1.2.3.</span> <span class="toc-text">3）分析器</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#4%E4%BC%98%E5%8C%96%E5%99%A8"><span class="toc-number">2.1.3.1.2.4.</span> <span class="toc-text">4）优化器</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#5%E6%89%A7%E8%A1%8C%E5%99%A8"><span class="toc-number">2.1.3.1.2.5.</span> <span class="toc-text">5）执行器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-sql-%E8%AF%AD%E5%8F%A5%E5%88%86%E6%9E%90"><span class="toc-number">2.1.3.2.</span> <span class="toc-text">2、SQL 语句分析</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#21-dql-%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5"><span class="toc-number">2.1.3.2.1.</span> <span class="toc-text">2.1、DQL 查询语句</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#22-dml-%E6%9B%B4%E6%96%B0%E8%AF%AD%E5%8F%A5"><span class="toc-number">2.1.3.2.2.</span> <span class="toc-text">2.2、DML 更新语句</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%B0%8F%E7%BB%93"><span class="toc-number">2.1.3.3.</span> <span class="toc-text">3、小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mysql%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="toc-number">2.1.4.</span> <span class="toc-text">MySQL 存储引擎</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#mysql-%E6%94%AF%E6%8C%81%E5%93%AA%E4%BA%9B%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E9%BB%98%E8%AE%A4%E4%BD%BF%E7%94%A8%E5%93%AA%E4%B8%AA"><span class="toc-number">2.1.4.1.</span> <span class="toc-text">MySQL 支持哪些存储引擎？默认使用哪个？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mysql-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E6%9E%B6%E6%9E%84%E4%BA%86%E8%A7%A3%E5%90%97"><span class="toc-number">2.1.4.2.</span> <span class="toc-text">MySQL 存储引擎架构了解吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#myisam-%E5%92%8C-innodb-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">2.1.4.3.</span> <span class="toc-text">MyISAM 和 InnoDB 有什么区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#myisam-%E5%92%8C-innodb-%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9"><span class="toc-number">2.1.4.4.</span> <span class="toc-text">MyISAM 和 InnoDB 如何选择？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mysql%E7%B4%A2%E5%BC%95"><span class="toc-number">2.1.5.</span> <span class="toc-text">MySQL 索引</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E4%BB%8B%E7%BB%8D"><span class="toc-number">2.1.5.1.</span> <span class="toc-text">索引介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">2.1.5.2.</span> <span class="toc-text">索引的优缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%80%89%E5%9E%8B"><span class="toc-number">2.1.5.3.</span> <span class="toc-text">索引的底层数据结构选型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#hash-%E8%A1%A8"><span class="toc-number">2.1.5.3.1.</span> <span class="toc-text">Hash 表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91bst"><span class="toc-number">2.1.5.3.2.</span> <span class="toc-text">二叉查找树（BST）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#avl-%E6%A0%91%E8%87%AA%E5%B9%B3%E8%A1%A1%E7%9A%84bst"><span class="toc-number">2.1.5.3.3.</span> <span class="toc-text">AVL 树（自平衡的 BST）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91%E8%87%AA%E5%B9%B3%E8%A1%A1%E7%9A%84bst"><span class="toc-number">2.1.5.3.4.</span> <span class="toc-text">红黑树（自平衡的 BST）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#b%E6%A0%91-b%E6%A0%91"><span class="toc-number">2.1.5.3.5.</span> <span class="toc-text">B 树 &amp; B + 树</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%88%86%E7%B1%BB"><span class="toc-number">2.1.5.4.</span> <span class="toc-text">索引分类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95"><span class="toc-number">2.1.5.4.1.</span> <span class="toc-text">主键索引</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95"><span class="toc-number">2.1.5.4.2.</span> <span class="toc-text">二级索引</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95"><span class="toc-number">2.1.5.4.3.</span> <span class="toc-text">聚集索引</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9D%9E%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95"><span class="toc-number">2.1.5.4.4.</span> <span class="toc-text">非聚集索引</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95"><span class="toc-number">2.1.5.4.5.</span> <span class="toc-text">覆盖索引</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95"><span class="toc-number">2.1.5.4.6.</span> <span class="toc-text">联合索引</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80%E5%8C%B9%E9%85%8D%E5%8E%9F%E5%88%99"><span class="toc-number">2.1.5.4.7.</span> <span class="toc-text">最左前缀匹配原则</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8"><span class="toc-number">2.1.5.5.</span> <span class="toc-text">索引下推</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8%E5%BB%BA%E8%AE%AE"><span class="toc-number">2.1.5.6.</span> <span class="toc-text">索引的正确使用建议</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mysql%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98"><span class="toc-number">2.1.6.</span> <span class="toc-text">MySQL 查询缓存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mysql%E6%97%A5%E5%BF%97"><span class="toc-number">2.1.7.</span> <span class="toc-text">MySQL 日志</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#mysql-%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E6%97%A5%E5%BF%97%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">2.1.7.1.</span> <span class="toc-text">MySQL 中常见的日志有哪些？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8"><span class="toc-number">2.1.7.2.</span> <span class="toc-text">慢查询日志有什么用？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#binlog-%E4%B8%BB%E8%A6%81%E8%AE%B0%E5%BD%95%E4%BA%86%E4%BB%80%E4%B9%88"><span class="toc-number">2.1.7.3.</span> <span class="toc-text">binlog 主要记录了什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8Bredo-log%E4%BB%A5%E5%8F%8A%E5%AE%83%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%8C%81%E4%B9%85%E6%80%A7"><span class="toc-number">2.1.7.4.</span> <span class="toc-text">介绍一下 redo log，以及它如何保证事务的持久性？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E9%A1%B5%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">2.1.7.5.</span> <span class="toc-text">数据页是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B5%E4%BF%AE%E6%94%B9%E4%B9%8B%E5%90%8E%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%9B%B4%E6%8E%A5%E5%88%B7%E7%9B%98%E5%91%A2"><span class="toc-number">2.1.7.6.</span> <span class="toc-text">页修改之后为什么不直接刷盘呢？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#binlog-%E5%92%8C-redolog-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">2.1.7.7.</span> <span class="toc-text">binlog 和 redolog 有什么区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#undo-log-%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%8E%9F%E5%AD%90%E6%80%A7"><span class="toc-number">2.1.7.8.</span> <span class="toc-text">undo log 如何保证事务的原子性？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mysql%E4%BA%8B%E5%8A%A1"><span class="toc-number">2.1.8.</span> <span class="toc-text">MySQL 事务</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%95%E8%B0%93%E4%BA%8B%E5%8A%A1"><span class="toc-number">2.1.8.1.</span> <span class="toc-text">何谓事务？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%95%E8%B0%93%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1"><span class="toc-number">2.1.8.2.</span> <span class="toc-text">何谓数据库事务？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E4%BA%8B%E5%8A%A1%E5%B8%A6%E6%9D%A5%E4%BA%86%E5%93%AA%E4%BA%9B%E9%97%AE%E9%A2%98"><span class="toc-number">2.1.8.3.</span> <span class="toc-text">并发事务带来了哪些问题？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%84%8F%E8%AF%BBdirty-read"><span class="toc-number">2.1.8.3.1.</span> <span class="toc-text">脏读（Dirty read）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%A2%E5%A4%B1%E4%BF%AE%E6%94%B9lost-to-modify"><span class="toc-number">2.1.8.3.2.</span> <span class="toc-text">丢失修改（Lost to modify）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BBunrepeatable-read"><span class="toc-number">2.1.8.3.3.</span> <span class="toc-text">不可重复读（Unrepeatable read）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B9%BB%E8%AF%BBphantom-read"><span class="toc-number">2.1.8.3.4.</span> <span class="toc-text">幻读（Phantom read）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E5%92%8C%E5%B9%BB%E8%AF%BB%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">2.1.8.4.</span> <span class="toc-text">不可重复读和幻读有什么区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">2.1.8.5.</span> <span class="toc-text">并发事务的控制方式有哪些？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sql-%E6%A0%87%E5%87%86%E5%AE%9A%E4%B9%89%E4%BA%86%E5%93%AA%E4%BA%9B%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-number">2.1.8.6.</span> <span class="toc-text">SQL 标准定义了哪些事务隔离级别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mysql-%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E6%98%AF%E5%9F%BA%E4%BA%8E%E9%94%81%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%90%97"><span class="toc-number">2.1.8.7.</span> <span class="toc-text">MySQL 的隔离级别是基于锁实现的吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mysql-%E7%9A%84%E9%BB%98%E8%AE%A4%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">2.1.8.8.</span> <span class="toc-text">MySQL 的默认隔离级别是什么？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mysql%E9%AB%98%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E8%A7%84%E8%8C%83%E5%BB%BA%E8%AE%AE"><span class="toc-number">2.2.</span> <span class="toc-text">MySQL 高性能优化规范建议</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%B8%8F%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="toc-number">2.3.</span> <span class="toc-text">⭐️重要知识点</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#redis"><span class="toc-number">3.</span> <span class="toc-text">Redis</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">3.1.</span> <span class="toc-text">缓存基础常见面试题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#redis%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B8%8A"><span class="toc-number">3.2.</span> <span class="toc-text">Redis 常见面试题（上）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#redis%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B8%8B"><span class="toc-number">3.3.</span> <span class="toc-text">Redis 常见面试题（下）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%B8%8F%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9-2"><span class="toc-number">3.4.</span> <span class="toc-text">⭐️重要知识点</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#elasticsearch"><span class="toc-number">4.</span> <span class="toc-text">Elasticsearch</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#mongodb"><span class="toc-number">5.</span> <span class="toc-text">MongoDB</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#mongodb%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B8%8A"><span class="toc-number">5.1.</span> <span class="toc-text">MongoDB 常见面试题（上）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mongodb%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B8%8B"><span class="toc-number">5.2.</span> <span class="toc-text">MongoDB 常见面试题（下）</span></a></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li class="active"><a href="/database/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="bookmark" title="数据库总结">数据库总结</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="范特东东东" data-src="/images/avatar.jpg"><p class="name" itemprop="name">范特东东东</p><div class="description" itemprop="description"></div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">42</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">13</span> <span class="name">分类</span></a></div></nav><div class="social"></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于我</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><span class="exturl" data-url="aHR0cHM6Ly9oangxNTkuZ2l0aHViLmlvL2NhdGVnb3JpZXMvcGhvdG9ncmFwaHkv"><i class="ic i-photography"></i>摄影</span></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/java/jvm/JVM%E7%AC%94%E8%AE%B0/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/framework/spring/spring6/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/java/" title="分类于 Java">Java</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/" title="分类于 Java基础">Java基础</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/java-excise/" title="分类于 Java基础-真题">Java基础-真题</a></div><span><a href="/java/java-se/java-excise/%E7%AC%AC18%E7%AB%A0%EF%BC%9A%E9%9A%8F%E5%A0%82%E5%A4%8D%E4%B9%A0%E4%B8%8E%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%A2%98%EF%BC%88JDK8-17%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%89/" title="宋红康_第18章：JDK8-17新特性">宋红康_第18章：JDK8-17新特性</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/java/" title="分类于 Java">Java</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/" title="分类于 Java基础">Java基础</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/java-knowledge/" title="分类于 Java基础-知识点">Java基础-知识点</a></div><span><a href="/java/java-se/java-knowledge/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E5%AE%8B%E7%BA%A2%E5%BA%B7_%E7%AC%AC02%E7%AB%A0_%E5%8F%98%E9%87%8F%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6/" title="宋红康_第02章_变量与运算符">宋红康_第02章_变量与运算符</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/framework/" title="分类于 常用框架">常用框架</a> <i class="ic i-angle-right"></i> <a href="/categories/framework/spring/" title="分类于 Spring">Spring</a></div><span><a href="/framework/spring/spring6/" title="尚硅谷 Spring6">尚硅谷 Spring6</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/database/" title="分类于 数据库">数据库</a></div><span><a href="/database/%E6%95%B0%E6%8D%AE%E5%BA%93/" title="数据库总结">数据库总结</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/java/" title="分类于 Java">Java</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/" title="分类于 Java基础">Java基础</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/java-excise/" title="分类于 Java基础-真题">Java基础-真题</a></div><span><a href="/java/java-se/java-excise/%E7%AC%AC15%E7%AB%A0%EF%BC%9A%E9%9A%8F%E5%A0%82%E5%A4%8D%E4%B9%A0%E4%B8%8E%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%A2%98%EF%BC%88File%E7%B1%BB%E4%B8%8EIO%E6%B5%81%EF%BC%89/" title="宋红康_第15章：File类与IO流">宋红康_第15章：File类与IO流</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/java/" title="分类于 Java">Java</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/" title="分类于 Java基础">Java基础</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/java-knowledge/" title="分类于 Java基础-知识点">Java基础-知识点</a></div><span><a href="/java/java-se/java-knowledge/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E5%AE%8B%E7%BA%A2%E5%BA%B7_%E7%AC%AC03%E7%AB%A0_%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/" title="宋红康_第03章_流程控制语句">宋红康_第03章_流程控制语句</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/java/" title="分类于 Java">Java</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/" title="分类于 Java基础">Java基础</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/java-knowledge/" title="分类于 Java基础-知识点">Java基础-知识点</a></div><span><a href="/java/java-se/java-knowledge/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E5%AE%8B%E7%BA%A2%E5%BA%B7_%E7%AC%AC07%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E8%BF%9B%E9%98%B6%EF%BC%89/" title="宋红康_第07章_面向对象编程(进阶)">宋红康_第07章_面向对象编程(进阶)</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/java/" title="分类于 Java">Java</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/" title="分类于 Java基础">Java基础</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/java-knowledge/" title="分类于 Java基础-知识点">Java基础-知识点</a></div><span><a href="/java/java-se/java-knowledge/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E5%AE%8B%E7%BA%A2%E5%BA%B7_%E7%AC%AC18%E7%AB%A0_JDK8-17%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%88%E4%B8%8B%EF%BC%89/" title="宋红康_第18章_JDK8-17新特性（下）">宋红康_第18章_JDK8-17新特性（下）</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/java/" title="分类于 Java">Java</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/" title="分类于 Java基础">Java基础</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/java-knowledge/" title="分类于 Java基础-知识点">Java基础-知识点</a></div><span><a href="/java/java-se/java-knowledge/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E5%AE%8B%E7%BA%A2%E5%BA%B7_%E7%AC%AC12%E7%AB%A0_%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/" title="宋红康_第12章_集合框架">宋红康_第12章_集合框架</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/java/" title="分类于 Java">Java</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/" title="分类于 Java基础">Java基础</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/java-knowledge/" title="分类于 Java基础-知识点">Java基础-知识点</a></div><span><a href="/java/java-se/java-knowledge/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E5%AE%8B%E7%BA%A2%E5%BA%B7_%E7%AC%AC14%E7%AB%A0_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/" title="宋红康_第14章_数据结构与集合源码">宋红康_第14章_数据结构与集合源码</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2023</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">范特东东东 @ phantasy</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">1.5m 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">23:29</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"database/数据库/",favicon:{show:"(●´3｀●)欢迎回来",hide:"(〃＞皿＜)你快回来"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hrmmi -->