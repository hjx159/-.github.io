<!-- build time:Wed Nov 15 2023 20:58:43 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="水文 & 摄影" href="http://example.com/rss.xml"><link rel="alternate" type="application/atom+xml" title="水文 & 摄影" href="http://example.com/atom.xml"><link rel="alternate" type="application/json" title="水文 & 摄影" href="http://example.com/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><link rel="canonical" href="http://example.com/java/java-se/java-excise/%E7%AC%AC14%E7%AB%A0%EF%BC%9A%E9%9A%8F%E5%A0%82%E5%A4%8D%E4%B9%A0%E4%B8%8E%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%A2%98%EF%BC%88%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%EF%BC%89/"><title>宋红康_第14章：数据结构与集合源码 - Java基础-真题 - Java基础 - Java | phantasy = 水文 & 摄影 = 为了能更好地访问图片，你需要一点魔法</title><meta name="generator" content="Hexo 6.3.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">宋红康_第14章：数据结构与集合源码</h1><div class="meta"><span class="item" title="创建时间：2023-11-12 11:06:50"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2023-11-12T11:06:50+08:00">2023-11-12</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>13k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>12 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">phantasy</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><img src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20220514190904009-1661448231966.png"></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/java/" itemprop="item" rel="index" title="分类于 Java"><span itemprop="name">Java</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/java/java-se/" itemprop="item" rel="index" title="分类于 Java基础"><span itemprop="name">Java基础</span></a><meta itemprop="position" content="2"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/java/java-se/java-excise/" itemprop="item" rel="index" title="分类于 Java基础-真题"><span itemprop="name">Java基础-真题</span></a><meta itemprop="position" content="3"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://example.com/java/java-se/java-excise/%E7%AC%AC14%E7%AB%A0%EF%BC%9A%E9%9A%8F%E5%A0%82%E5%A4%8D%E4%B9%A0%E4%B8%8E%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%A2%98%EF%BC%88%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%EF%BC%89/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="范特东东东"><meta itemprop="description" content="为了能更好地访问图片，你需要一点魔法, "></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="水文 & 摄影"></span><div class="body md" itemprop="articleBody"><h1 id="第14章随堂复习与企业真题数据结构与集合源码"><a class="anchor" href="#第14章随堂复习与企业真题数据结构与集合源码">#</a> 第 14 章：随堂复习与企业真题（数据结构与集合源码）</h1><hr><h2 id="一-随堂复习"><a class="anchor" href="#一-随堂复习">#</a> 一、随堂复习</h2><h3 id="1-数据结构"><a class="anchor" href="#1-数据结构">#</a> 1. 数据结构</h3><ul><li><p>数据结构的研究对象：</p><ul><li>① 数据间的 <code>逻辑关系</code> （集合关系、一对一、一对多、多对多）</li><li>② 数据的 <code>存储结构</code> （或物理结构）<ul><li>角度一：顺序结构、链式结构、索引结构、哈希结构</li><li>角度二： <code>线性表</code> （一维数组、链表、栈、队列）、 <code>树</code> （二叉树、B + 树）、 <code>图</code> （多对多）、 <code>哈希表</code> （HashMap、HashSet)</li></ul></li><li>③ 相关运算</li></ul></li><li><p>树（了解）</p></li><li><p>相关数据结构的核心 <code>Node的设计</code> （单向链表、双向链表、二叉树、栈、队列）（理解）</p></li></ul><h3 id="2-list接口下的实现类的源码剖析"><a class="anchor" href="#2-list接口下的实现类的源码剖析">#</a> 2. List 接口下的实现类的源码剖析</h3><table><thead><tr><th style="text-align:center">List 接口的实现类</th><th style="text-align:center"><em>ArrayList</em></th><th style="text-align:center"><s>Vector</s></th><th style="text-align:center">LinkedList</th></tr></thead><tbody><tr><td style="text-align:center">地位</td><td style="text-align:center">新版的动态数组</td><td style="text-align:center">旧版的动态数组</td><td style="text-align:center">链表</td></tr><tr><td style="text-align:center">底层实现</td><td style="text-align:center">Object 数组，但可以扩容</td><td style="text-align:center">Object 数组</td><td style="text-align:center"><font color="red">双向链表</font></td></tr><tr><td style="text-align:center">默认的初始容量</td><td style="text-align:center">JDK6.0 及之前是 10；JDK8.0 之后是 <code>0</code> ，之后在添加第一个元素时，再创建长度为 10 的数组</td><td style="text-align:center"><code>10</code></td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">扩容机制</td><td style="text-align:center">默认扩容为原来的 <code>1.5倍</code></td><td style="text-align:center">默认扩容增加为原来的 <code>2倍</code></td><td style="text-align:center">不需要扩容</td></tr><tr><td style="text-align:center">特点</td><td style="text-align:center">线程不安全、效率高</td><td style="text-align:center"><font color="red">线程安全</font>、效率低</td><td style="text-align:center">线程不安全</td></tr><tr><td style="text-align:center">使用场景</td><td style="text-align:center"><font color="red">频繁追加、查找数据</font></td><td style="text-align:center">避免使用</td><td style="text-align:center"><font color="red">频繁插入、删除数据</font></td></tr><tr><td style="text-align:center">说明</td><td style="text-align:center">对于频繁访问列表中的某一个元素，只需要在列表末尾进行添加和删除元素操作的情况下</td><td style="text-align:center"></td><td style="text-align:center">元素是通过指针相互连接的，在插入 / 删除元素时，只需要改动前后元素的指针即可</td></tr></tbody></table><p>【面试题】ArrayList、Vector、LinkedList 的三者的对比？</p><ul><li><p>层次 1：</p><ul><li>Collection 接口的子接口 List: 存储有序的、可重复的数据 (&quot;动态&quot; 数组)<ul><li>ArrayList: 主要实现类；线程不安全的、效率高；底层使用 Object [] 数组存储；添加数据、查找数据时，效率较高；在插入、删除数据时，效率较低</li><li>LinkedList: 底层使用双向链表的方式进行存储；在对集合中的数据进行频繁的删除、插入操作时，建议使用此类在插入、删除数据时，效率较高；在添加数据、查找数据时，效率较低；</li><li>Vector: 古老实现类；线程安全的、效率低；底层使用 Object [] 数组存储</li></ul></li></ul></li><li><p>层次 2：查看相关 api 的源码（见笔记，略）</p></li></ul><h3 id="3-map接口下的实现类的源码剖析"><a class="anchor" href="#3-map接口下的实现类的源码剖析">#</a> 3. Map 接口下的实现类的源码剖析</h3><ul><li><strong>（掌握）HashMap 的底层源码的剖析</strong></li><li>（熟悉）LinkedHashMap 的底层源码的剖析</li><li>（了解）HashSet、LinkedHashSet 的底层源码的剖析</li></ul><h2 id="二-企业真题"><a class="anchor" href="#二-企业真题">#</a> 二、企业真题</h2><h3 id="21-数据结构相关"><a class="anchor" href="#21-数据结构相关">#</a> 2.1 数据结构相关</h3><h4 id="1-链表和数组有什么区别腾"><a class="anchor" href="#1-链表和数组有什么区别腾">#</a> 1. 链表和数组有什么区别？（腾 *）</h4><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">数组</th><th style="text-align:center">链表</th></tr></thead><tbody><tr><td style="text-align:center">存储方式</td><td style="text-align:center">连续</td><td style="text-align:center">分散</td></tr><tr><td style="text-align:center">内存分配方式</td><td style="text-align:center">静态分配</td><td style="text-align:center">动态分配</td></tr><tr><td style="text-align:center">访问元素</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td></tr><tr><td style="text-align:center">插入 / 删除元素</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td></tr></tbody></table><h4 id="2-栈是如何运行的西信息技术"><a class="anchor" href="#2-栈是如何运行的西信息技术">#</a> 2. 栈是如何运行的？(西 * 信息技术)</h4><p>栈特点是 <code>先进后出（FILO）</code> ，数据只能在 <code>栈顶</code> 进行压入（push）和弹出（pop）操作。</p><p>栈是种抽象数据结构 <code>ADT</code> (abstract data type)，可以使用 <code>数组</code> 、 <code>链表</code> 实现栈结构。</p><p>在 <code>计算机系统中</code> ，栈是一个具有以上属性的 <code>动态内存区域</code> ，程序可以将数据压入栈中，也可以将数据从栈中弹出，压栈操作时栈增大，弹出操作是栈减小</p><h3 id="22-list集合源码相关"><a class="anchor" href="#22-list集合源码相关">#</a> 2.2 List 集合源码相关</h3><h4 id="1-arraylist的默认大小是多少以及扩容机制顺-凡科技"><a class="anchor" href="#1-arraylist的默认大小是多少以及扩容机制顺-凡科技">#</a> 1. <mark>ArrayList 的默认大小是多少，以及扩容机制</mark>（顺 *、凡 * 科技）</h4><pre><code>类似问题：
&gt; 说说ArrayList的扩容机制吧(国*电网)
&gt; 讲一下ArrayList的扩容机制（*实在）
&gt; ArrayList的扩容机制，为什么是10，为什么是1.5倍（*软国际）
</code></pre><p>Java 中的 ArrayList 类实例化时如果不指定长度，底层数组初始化为 <code>&#123;&#125;</code> ，只有在 <code>首次添加元素时</code> 才会创建默认容量为 <code>10</code> 的数组。当元素数量超过 ArrayList 的容量时，ArrayList 会自动扩容到原来的 <code>1.5倍</code> 。ArrayList 的<mark>扩容机制</mark>如下：</p><ol><li>当添加新元素时，如果当前容量不足以容纳新元素，则会调用 <code>grow()</code> 方法进行扩容。</li><li>grow () 方法会 <code>计算新容量newCapacity</code> ，其中 newCapacity = oldCapacity + (oldCapacity&gt;&gt; 1)，也就是<font color="red">原有容量的 1.5 倍</font>。</li><li>如果 newCapacity 仍然小于新添加元素后的数量，那么 newCapacity 就会被设置为<font color="red">新添加元素后的数量</font>。</li><li>然后，ArrayList 会调用 <code>copyOf(T[] original, int newLength)</code> 创建一个新的数组，并<font color="red">将<u>原有元素</u>拷贝到新数组中</font>。</li><li>最后，<font color="red"><u>新元素</u>会被添加到新数组的尾部</font>。</li></ol><p>需要注意的是，由于<font color="red">扩容会涉及到数组的拷贝操作</font>，因此在实际开发中，尽量<font color="red">避免频繁对 ArrayList 进行扩容</font>，以提高程序的性能。为了避免频繁扩容，<font color="red">可以在创建 ArrayList 对象时，指定一个足够大的初始容量，以便能够容纳预期数量的元素</font>。</p><h4 id="2-arraylist的底层是怎么实现的腾"><a class="anchor" href="#2-arraylist的底层是怎么实现的腾">#</a> 2. ArrayList 的底层是怎么实现的？（腾 *）</h4><pre><code>类似问题：
集合类的ArrayList底层（安全不安全，扩容，初始大小，添加删除查询是怎么操作的，底层是什么组成的）
（湖**利软件、汇*云通、猎*、苏州***动、上海*进天下、北京博*软件、*科软、大连*点科技、中*亿达、德*物流、天*伟业、猫*娱乐）
</code></pre><p>ArrayList 的底层实现是基于 <code>Object[]数组</code> 的。我们可以在集合中存储任意类型的数据，但是它是 <code>线程不安全</code> 的。由于它底层是基于数组实现的，所以它非常适合用于对元素进行查找， <code>查找效率非常高</code> 。</p><p>当我们实例化一个 ArrayList 时，无参数构造函数默认将数组初始化为 <code>&#123;&#125;</code> ，只有在首次添加元素时为数组初始化长度为 <code>10</code> 。如果增加的元素个数超过了 10 个，那么 ArrayList 底层会新生成一个数组，长度为原数组的 <code>1.5倍</code> ，然后将原数组的内容 <code>复制</code> 到新数组当中，并且后续增加的内容都会 <code>追加</code> 到新数组。</p><blockquote><p>开发建议： <code>ArrayList(int capacity)&#123;&#125;</code> 创建指定长度的数组：开发中，如果能大体确认数组长度，推荐使用这种带参构造器，因为 <code>避免了扩容、复制数组带来的时空消耗</code> 。</p></blockquote><h4 id="3-在arraylist中remove后面几个元素该怎么做惠-中亿达"><a class="anchor" href="#3-在arraylist中remove后面几个元素该怎么做惠-中亿达">#</a> 3. 在 ArrayList 中 remove 后面几个元素该怎么做？（惠 *、中 * 亿达）</h4><p>前移。</p><h4 id="4-arraylist17和18的区别拓思"><a class="anchor" href="#4-arraylist17和18的区别拓思">#</a> 4. <mark>ArrayList1.7 和 1.8 的区别</mark>（拓 * 思）</h4><p>JDK 1.8 和 1.7 中 ArrayList 最明显的区别就是<strong>底层数组的初始化方式</strong>。</p><p>在 <code>JDK1.8</code> 中，如果不指定长度，使用 <code>无参构造方法</code> ArrayList list = new ArrayList () 创建 List 集合时，底层的 Object [] elementData 初始化为 <code>&#123;&#125;（空的数组）</code> ，并没有直接创建长度为 10 的数组。而在第一次调用 <code>add()</code> 方法时，底层才创建了长度为 <code>10</code> 的数组，并将本次要添加的元素添加进去。这样做可<font color="red">节省内存消耗</font>，因为在添加元素时，数组名将指针指向了新的数组，且老数组 {} 是一个空数组，这样有利于 System.gc ()，并不会一直占据内存。</p><p>相比之下，在 <code>JDK1.7</code> 中，使用 <code>无参构造方法</code> 创建 List 集合时，底层直接创建了长度是 <code>10</code> 的 Object [] 数组 elementData。后续的添加和扩容操作与 JDK1.8 无异。</p><h4 id="5-数组和-arraylist-的区别阿-科软"><a class="anchor" href="#5-数组和-arraylist-的区别阿-科软">#</a> 5. <mark>数组和 ArrayList 的区别</mark>（阿 *、* 科软）</h4><p>ArrayList 看做是对数组的常见操作的封装。</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">数组</th><th style="text-align:center">ArrayList</th></tr></thead><tbody><tr><td style="text-align:center">长度</td><td style="text-align:center">创建时确定，且长度固定</td><td style="text-align:center">长度是 <code>动态</code> 的</td></tr><tr><td style="text-align:center">存储类型</td><td style="text-align:center">基本数据类型、引用数据类型</td><td style="text-align:center"><code>引用数据类型</code></td></tr><tr><td style="text-align:center">操作</td><td style="text-align:center">基本的读写操作</td><td style="text-align:center">插入、删除、查找等 <code>高级操作</code></td></tr><tr><td style="text-align:center">性能</td><td style="text-align:center"><code>随机访问</code> 性能更优</td><td style="text-align:center"><code>插入和删除</code> 性能更优</td></tr><tr><td style="text-align:center">随机访问性能的说明</td><td style="text-align:center">可以直接通过 <code>索引</code> 来访问元素，<font color="red">O(1)$</font></td><td style="text-align:center"><font color="red">需要先检查索引是否越界，</font>这会增加一些开销</td></tr><tr><td style="text-align:center">插入删除性能的说明</td><td style="text-align:center">需要 <code>创建一个新数组</code> ，然后将原数组中的元素复制到新数组中</td><td style="text-align:center">只需要 <code>移动元素</code> ，而不需要创建新的数组</td></tr></tbody></table><h4 id="6-什么是线程安全的list平金服"><a class="anchor" href="#6-什么是线程安全的list平金服">#</a> 6. 什么是线程安全的 List？(平 * 金服)</h4><p>线程安全的 List 是指可以在多线程环境下安全使用的 List。这意味着，当多个线程同时访问和修改同一个 List 时，它能够保证 <code>数据的一致性</code> 和正确性。</p><p>Java 中提供了几种线程安全的 List 实现，包括 <code>Vector</code> 和 <code>CopyOnWriteArrayList</code> 。此外，我们还可以使用 <code>Collections.synchronizedList()</code> 方法来将任意一个 List 包装成线程安全的 List。</p><p>需要注意的是，虽然线程安全的 List 可以在多线程环境下安全使用，但它们通常比非线程安全的 List（如 ArrayList） <code>性能低</code> 一些。因此，在选择使用哪种 List 时，应该根据实际情况进行权衡。</p><h3 id="23-hashmap集合源码相关"><a class="anchor" href="#23-hashmap集合源码相关">#</a> 2.3 HashMap 集合源码相关</h3><h4 id="1-说说hahmap底层实现新股份-顺-猫娱乐"><a class="anchor" href="#1-说说hahmap底层实现新股份-顺-猫娱乐">#</a> 1. <mark>说说 HahMap 底层实现</mark> (新 * 股份、顺 *、猫 * 娱乐)</h4><pre><code>类似问题：
&gt; HashMap的实现讲一下？（腾*，上海**网络）
&gt; 说说HashMap的底层执行原理？（滴*，纬*软件，上海*想，*昂，*蝶**云，宇*科技，*东数科，猎*网）
&gt; 详细说一下 HashMap 的 put 过程（*度）
&gt; Java中的HashMap的工作原理是什么？（北京中**译咨询）
&gt; 集合类的HashMap底层（安全不安全，扩容，初始大小，添加删除查询是怎么操作的，底层是什么组成的）（湖**利软件）
&gt; HashMap 的存储过程（爱*信、杭州*智）
&gt; Hashmap底层实现及构造（汇**通、猎*、苏州博*讯动、上海*进天下、北京博*软件、*科软、大连*点科技、中*亿达、德*物流、天*伟业、猫*娱乐）
&gt; HashMap的实现原理（腾*、阿*）
&gt; HaspMap底层讲一讲（*米）
&gt; 说一下HashMap的实现，扩容机制？（*节）
&gt; 讲一下 HashMap 中 put 方法过程？（阿*）
</code></pre><p><strong>HashMap 的底层实现原理</strong></p><p>HashMap 是 Java 中一种常用的数据结构，它实现了 Map 接口，能够以 <code>键值对</code> 的形式存储数据。它的底层实现是基于 <code>哈希表</code> 的，具体来说，它是通过 <code>数组+单向链表+红黑树</code> 的形式来实现的。</p><p><strong>HashMap 的 put (key,value) 过程</strong></p><ol><li><p>计算 key 的哈希值，并将其映射到数组下标</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20220514190454633-1661448231965.png" alt="image-20220514190454633"></p><p>调用 <code>hashCode()</code> 和 <code>hash()</code> 计算 key 的哈希值 hash。</p><p>并根据 <code>下式</code> 计算该键值对被分配到数组中的索引位置 index，</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre>index <span class="token operator">=</span> <span class="token punctuation">(</span>hash <span class="token operator">&amp;</span> <span class="token punctuation">(</span>capacity <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr></table></figure><p>其中 hash 是键的哈希值，capacity 是数组的长度，<font color="red">&amp; 运算符是按位与运算</font>，运算结果的取值范围是 [0,capacity-1]，刚好对应数组的各个下标。</p><p>下标位置称为 <code>桶（bucket）</code> 或 <code>槽（slot）</code> 。</p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20220514190904009-1661448231966.png" alt="image-20220514190904009" style="zoom:50%"></li><li><p>检查该 bucket 是否为空</p><p>如果空，就直接将键值对添加到该 bucket 上，然后返回 null。</p><blockquote><p>添加情况 1</p></blockquote><p>如果该 bucket 不为空，执行下一步。</p></li><li><p>处理哈希冲突，采用链表或红黑树的方式将多个键值对存储在同一个槽中</p><p>如果该槽中存在一个键值对 (k,v)， <code>其键k的hash与当前键key的hash相同</code> ，<strong>并且</strong>， <code>key.equals(k)返回ture</code> ，则将该键值对的值 v 替换为当前值 value，并返回旧值 v。</p><blockquote><p>修改 value</p></blockquote><p>若二者的 <code>hash不相同</code> ，<strong>或者</strong>， <code>key.equals(k)返回false</code> ，则将当前键值对先采用 <code>单向链式存储（尾插法）</code> 的方式添加到该 bucket 链表中，（当一个 bucket 中的链表长度超过一定 <code>阈值</code> （默认为 8）时，Java 会将该链表转化为 <code>红黑树</code> 。这是因为链表的查找时间复杂度是 O (n)，而<font color="red">红黑树的查找时间复杂度是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:.01968em">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:.03588em">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></font>，所以对于较长的链表，使用红黑树可以<font color="red">提高查询效率</font>。）</p><blockquote><p>添加情况 2、3</p></blockquote></li><li><p>扩容</p><p>当 HashMap 中的元素数量达到一定 <code>阈值</code> （即负载因子与容量的乘积）时会触发扩容操作，步骤如下：</p><ul><li>创建一个 <code>2倍长度的新数组</code></li><li>将原数组中的元素 <code>重新计算哈希值</code> ，并 <code>重新分配</code> 到新数组中，会导致元素在新数组中的 <code>位置可能发生变化</code> 。</li><li><code>释放原数组的空间</code> ，将新数组设置为当前数组。</li></ul><p>注意：</p><p>HashMap 中 <code>负载因子默认是0.75</code> ，这意味着当 HashMap 中的元素数量达到数组长度的 75% 时，就会触发扩容操作。每次扩容时，它都会将数组的长度 <code>增加一倍</code> 。</p><p>由于扩容操作需要重新计算所有元素的哈希值，并将它们添加到新数组中，这个过程需要大量的时间和内存。在创建 HashMap 时，如果我们能够预估元素数量，可以通过 <code>指定初始容量</code> 来 <code>避免不必要的扩容操作</code> ，从而提高性能。</p></li><li><p>返回结果</p><p>如果添加成功，返回 <code>null</code> 。</p><p>如果修改成功，返回该键对应的 <code>旧值</code> 。</p></li></ol><h4 id="2-hashmap初始值16临界值12是怎么算的软力"><a class="anchor" href="#2-hashmap初始值16临界值12是怎么算的软力">#</a> 2. HashMap 初始值 16，临界值 12 是怎么算的（软 ** 力）</h4><p>底层源码中定义的成员变量 “ <code>默认初始容量</code> ”：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">DEFAULT_INITIAL_CAPACITY</span> <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">4</span></pre></td></tr></table></figure><p>底层源码中定义的成员变量 “ <code>默认加载因子</code> ”：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">float</span> <span class="token constant">DEFAULT_LOAD_FACTOR</span> <span class="token operator">=</span> <span class="token number">0.75f</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>临界值 = 数组的长度 * 加载因子</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre>newThr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token constant">DEFAULT_LOAD_FACTOR</span> <span class="token operator">*</span> <span class="token constant">DEFAULT_INITIAL_CAPACITY</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 16 * 0.75 = 12</span></pre></td></tr></table></figure><h4 id="3-hashmap长度为什么是2的幂次方国时代"><a class="anchor" href="#3-hashmap长度为什么是2的幂次方国时代">#</a> 3. <mark>HashMap 长度为什么是 2 的幂次方？</mark>(国 * 时代)</h4><p><strong>能保证哈希值能够均匀分布在数组中，从而减少哈希冲突</strong></p><p>将 key 的哈希值 hash 映射到数组下标 i 的计算如下：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre>i <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash</pre></td></tr></table></figure><p>其中 n 就是 HashMap 的长度，当 n 是 2 的幂次方时， <code>n-1的二进制是一个全为1的二进制数</code> 。这样，哈希值与数组长度减 1 的 <code>按位与运算</code> 结果的取值范围就在 <code>[0,table.length-1]</code> 上，对应数组的每个下标。这样可以减少哈希冲突，提高 HashMap 的性能。</p><h4 id="4-hashmap怎么计算哈希值和索引扩容机制怎么解决hash冲突软国际-中软腾"><a class="anchor" href="#4-hashmap怎么计算哈希值和索引扩容机制怎么解决hash冲突软国际-中软腾">#</a> 4. <mark>HashMap 怎么计算哈希值和索引？扩容机制？怎么解决 hash 冲突？</mark>（* 软国际、中软 * 腾）</h4><pre><code>类似问题：
&gt; HashMap key的哈希冲突了怎么做（新*股份）
&gt; HashMap的默认大小是多少，以及扩容机制（顺*、凡*科技）
&gt; 讲一下HashMap的扩容机制？（好实*）
</code></pre><p><strong>计算哈希值、索引</strong></p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20220514190454633-1661448231965.png" alt="image-20220514190454633"></p><p>在 HashMap 中，计算哈希值的方式是先调用键对象的 <code>hashCode()</code> 方法得到哈希值，然后再对哈希值进行一些额外的计算 <code>hash()</code> ，以增强哈希值的随机性，通过一些位运算（例如使用异或和移位等）来消除高位的影响，以此来得到最终的哈希值。</p><p>计算哈希桶索引时，HashMap 会使用<u>哈希值</u>和<u>哈希桶长度减 1</u>的值进行 <code>按位与运算</code> ，得到一个<u>哈希桶索引</u>，计算公式如下：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre>i <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash</pre></td></tr></table></figure><p><strong>扩容机制</strong></p><p>当 HashMap 中的元素数量达到一定 <code>阈值</code> （即负载因子与容量的乘积）时会触发扩容操作，步骤如下：</p><ul><li>创建一个 <code>2倍长度的新数组</code></li><li>将原数组中的元素 <code>重新计算哈希值</code> ，并 <code>重新分配</code> 到新数组中，会导致元素在新数组中的 <code>位置可能发生变化</code> 。</li><li><code>释放原数组的空间</code> ，将新数组设置为当前数组。</li></ul><p>注意：</p><p>HashMap 中 <code>负载因子默认是0.75</code> ，这意味着当 HashMap 中的元素数量达到数组长度的 75% 时，就会触发扩容操作。每次扩容时，它都会将数组的长度 <code>增加一倍</code> 。</p><p>由于扩容操作需要重新计算所有元素的哈希值，并将它们添加到新数组中，这个过程需要大量的时间和内存。在创建 HashMap 时，如果我们能够预估元素数量，可以通过 <code>指定初始容量</code> 来 <code>避免不必要的扩容操作</code> ，从而提高性能。</p><p><strong>处理哈希冲突</strong></p><p>哈希冲突是指不同的键，其哈希值映射到同一个数组下标上。HashMap 使用 <code>链表</code> 或 <code>红黑树</code> 来存储哈希桶中的元素，以解决哈希冲突。</p><ul><li><p>当添加一个键值对时，如果该键值对的哈希桶位置已经存在一个或多个键值对，那么 HashMap 就需要在这些键值对中查找具有相同键的键值对。</p></li><li><p>在查找过程中，HashMap 会 <code>先比较键的哈希值</code> ，</p><ul><li><p>如果不同，则说明这个键在哈希桶中不存在，可以将新的键值对添加到链表或红黑树中。</p></li><li><p>如果哈希值相同，HashMap 会 <code>再比较键是否相等</code> ，</p><ul><li><p>如果相等，则说明这个键在哈希桶中已经存在，需要用新的值替换旧的值。</p></li><li><p>如果键不相等，则说明发生了哈希冲突，需要将新的键值对添加到链表或红黑树中。</p><blockquote><p>如果 <code>链表的长度超过8</code> ，且 <code>数组长度达到64</code> 时，则会将链表转化为红黑树。这是因为当链表长度较长时，查找键值对的时间复杂度可能会变为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:.10903em">N</span><span class="mclose">)</span></span></span></span>，而红黑树的查找时间复杂度是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logN)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:.01968em">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:.03588em">g</span><span class="mord mathnormal" style="margin-right:.10903em">N</span><span class="mclose">)</span></span></span></span>，因此<font color="red">可以提高 HashMap 的查询性能</font>。</p></blockquote></li></ul></li></ul></li></ul><h4 id="5-hashmap底层是数组链表有数组很快了为什么加链表润软件"><a class="anchor" href="#5-hashmap底层是数组链表有数组很快了为什么加链表润软件">#</a> 5. HashMap 底层是数组 + 链表，有数组很快了，为什么加链表？（润 * 软件）</h4><p>HashMap 底层使用链表是 <code>为了解决哈希冲突</code> 。</p><p>当我们向 HashMap 中添加一个键值对时，它会先计算键的哈希值，然后根据哈希值确定这个键值对在数组中的位置。如果两个不同的键具有相同的哈希值，那么它们会被存储在同一个 bucket 中。这种情况被称为哈希冲突。</p><p>为了解决哈希冲突，HashMap 会使用链表、红黑树来存储同一个 bucket 中的多个键值对。<font color="red">每个 bucket 都可以看作是一个<u>链表的头节点</u>或<u>红黑树的根节点</u></font>。如果遇到哈希冲突，就将新的键值对<font color="red">添加到链表或红黑树的<u>末尾</u></font>。</p><p>但是，由于<font color="red">链表和红黑树本身需要占用额外的空间</font>，因此在 HashMap 的设计中需要进行权衡。通常来说，<font color="red">当哈希桶中的元素数量比较小时，使用链表就足够了</font>，而<font color="red">当元素数量比较大时，使用红黑树可以更好地平衡时间和空间的开销</font>。为了提高 HashMap 的性能， <code>JDK8</code> 开始引入了一种基于 “ <code>链表和红黑树的自适应存储方式</code> ”，也就是说，</p><ul><li><strong><font color="red">当链表中的元素数量超过 8 个，且数组长度达到 64 时，会将链表转换为红黑树</font></strong></li><li><strong><font color="red">当红黑树中的元素数量小于 6 个时，会将红黑树转换为链表</font></strong></li></ul><h4 id="6-hashmap为什么长度达到一定的长度要转化为红黑树度"><a class="anchor" href="#6-hashmap为什么长度达到一定的长度要转化为红黑树度">#</a> 6. HashMap 为什么长度达到一定的长度要转化为红黑树（* 度）</h4><pre><code>类似问题：
&gt; HashMap为什么用红黑树（*软国际）
</code></pre><ul><li>因为 <code>红黑树的增删改查操作的时间复杂度为O(logn)</code> ，比单向链表的 O (n) 效率高。</li><li>可以 <code>避免出现极长的单链表</code> ，导致空间浪费，提高了空间利用率</li></ul><h4 id="7-hashmap什么时候扩充为红黑树什么时候又返回到链表汉"><a class="anchor" href="#7-hashmap什么时候扩充为红黑树什么时候又返回到链表汉">#</a> 7. HashMap 什么时候扩充为红黑树，什么时候又返回到链表？（汉 *）</h4><pre><code>类似问题：
&gt; HashMap什么时候转换为红黑树（杭州*智公司）
&gt; 当HashMap中相同hashcode值的数据超过多少时会转变成红黑树？（百*云创）
&gt; 什么时候是数据+链表，什么时候是红黑树（*软国际）
</code></pre><p>链表 -&gt; 红黑树：当同一个 bucket 中的 <code>链表元素数量超过8</code> ，且 <code>数组长度达到64</code> 时，该 bucket 的链表需要转换为红黑树，这是为了<font color="red">提高增删改查的性能</font>。</p><p>红黑树 -&gt; 链表：当同一个 bucket 中的 <code>红黑树元素数量减少到6</code> 时，那么该 bucket 的红黑树转换回链表，这是为了<font color="red">节省内存空间</font>。</p><h4 id="8-在-jdk18中hashmap的数据结构与17相比有什么变化这些变化的好处在哪里海科"><a class="anchor" href="#8-在-jdk18中hashmap的数据结构与17相比有什么变化这些变化的好处在哪里海科">#</a> 8. <mark>在 JDK1.8 中，HashMap 的数据结构与 1.7 相比有什么变化，这些变化的好处在哪里</mark>？（海 * 科）</h4><table><thead><tr><th style="text-align:center">HashMap 的变化</th><th style="text-align:center">JDK7</th><th style="text-align:center">JDK8</th></tr></thead><tbody><tr><td style="text-align:center">table 数组类型</td><td style="text-align:center">Entry&lt;K,V&gt;[]</td><td style="text-align:center"><code>Node&lt;K,V&gt;</code> []</td></tr><tr><td style="text-align:center">创建 HashMap 实例时</td><td style="text-align:center">默认初始化数组的容量是 16（饿汉式）</td><td style="text-align:center">没有初始化 table 数组（当首次添加映射元素时才将数组的容量初始化为 16）（ <code>懒汉式</code> ）</td></tr><tr><td style="text-align:center">数据结构（七上八下）</td><td style="text-align:center">数组 + 单向链表（ <code>头插法</code> ）</td><td style="text-align:center">数组 + 单向链表（ <code>尾插法</code> ） + <code>红黑树</code></td></tr><tr><td style="text-align:center">单向链表←→红黑树</td><td style="text-align:center">×</td><td style="text-align:center">当某个索引位置 i 上的<font color="red">链表的长度达到 8，且数组的长度超过 64</font>时，此索引位置上的元素要从单向链表改为红黑树，<font color="orange">将增删改查的时间复杂度从<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 降到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:.01968em">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:.03588em">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></font>。<br>如果索引 i 位置是红黑树的结构，当不断删除元素的情况下，<font color="red">当前索引 i 位置上的元素的个数低于 6 时</font>，要从红黑树改为单向链表，<font color="orange">节省内存空间</font>。</td></tr><tr><td style="text-align:center">扩容条件</td><td style="text-align:center">size 达到 threshold，且 table [i]!=null</td><td style="text-align:center">size 达到 threshold，且 table [i]!=null；<br>或者，<font color="red">链表的长度达到 8，但数组的长度未超过 64</font></td></tr></tbody></table><p><strong>数据结构的变化</strong></p><ul><li><p>JDK1.8 中的 HashMap 仍然使用数组和链表结构，但是 <code>当链表长度达到一定阈值时，会将链表转换成红黑树</code> ，好处：</p><ul><li><font color="red">可以提高增删改查的性能</font>，因为红黑树在最坏情况也也能保证<font color="red"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logN)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:.01968em">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:.03588em">g</span><span class="mord mathnormal" style="margin-right:.10903em">N</span><span class="mclose">)</span></span></span></span></font>的时间复杂度</li><li>可以<font color="red">避免出现极长的单链表</font>，导致空间浪费，提高了空间利用率</li></ul></li><li><p>此外，链表的插入方法从 jdk1.7 的头插法变成了 jdk1.8 的 <code>尾插法</code> ，好处：</p><ul><li><font color="red">可以避免 JDK1.7 中，并发情况下，扩容，形成环状链表，造成死循环的问题</font>。</li></ul></li></ul><p><strong>其他变化</strong></p><ul><li>jdk1.7 中的 Entry 内部类，在 jdk1.8 中改名为 <code>Node</code></li><li>HashMap 调用无参构造器进行实例化时，在 jdk1.7 中会将数组的容量初始化为 16（饿汉式），在 jdk1.8 中不会初始化数组（懒汉式：只在首次添加元素时，才将数组容量初始化为 16），好处是：<ul><li><font color="red">减少内存的浪费</font>：在实例化 HashMap 对象时，如果立即初始化底层数组的大小，可能会导致数组过大或过小，从而浪费内存</li></ul></li><li>jdk1.7 的扩容条件是 <code>size达到threshold，且table[i]!=null</code> ，jdk1.8 在此基础上增加了一个可以触发扩容操作的条件：遇到哈希冲突时，如果 <code>链表的长度达到8，但数组的长度未超过64</code> ，也需要扩容。</li></ul><h4 id="9-hashmap的get方法的原理顺"><a class="anchor" href="#9-hashmap的get方法的原理顺">#</a> 9. HashMap 的 get () 方法的原理？（顺 *）</h4><ol><li>计算键的哈希值。</li><li>使用哈希值来确定键值对在 HashMap 内部数组中的索引位置。</li><li>检查该索引位置是否为空。如果为空，则返回 null。</li><li>如果该索引位置不为空，则检查该位置的第一个元素是否与给定键匹配。如果匹配，则返回与该键关联的值。</li><li>如果第一个元素与给定键不匹配，则遍历该位置处的链表（或红黑树），直到找到与给定键匹配的元素或到达链表末尾。</li><li>如果找到匹配项，则返回与该键关联的值；否则，返回 null。</li></ol><h4 id="10-hashmap的remove方法的原理"><a class="anchor" href="#10-hashmap的remove方法的原理">#</a> 10. HashMap 的 remove () 方法的原理？</h4><ol><li>计算键的哈希值。</li><li>使用哈希值来确定键值对在 HashMap 内部数组中的索引位置。</li><li>检查该索引位置是否为空。如果为空，则返回 null。</li><li>如果该索引位置不为空，则检查该位置的第一个元素是否与给定键匹配。如果匹配，则删除该元素并返回与该键关联的值。</li><li>如果第一个元素与给定键不匹配，则遍历该位置处的链表（或红黑树），直到找到与给定键匹配的元素或到达链表末尾。</li><li>如果找到匹配项，则删除该元素并返回与该键关联的值；否则，返回 null。</li></ol><h3 id="24-hashcode和equals"><a class="anchor" href="#24-hashcode和equals">#</a> 2.4 hashCode 和 equals</h3><h4 id="1-hashcode和equals的区别海供应链管理"><a class="anchor" href="#1-hashcode和equals的区别海供应链管理">#</a> 1. <mark>hashCode () 和 equals () 的区别？</mark>（海 * 供应链管理）</h4><p>hashCode () 和 equals () 都是 Java 中 Object 类中定义的方法，用于 <code>判断对象是否相等</code> 。它们通常被重写，并且一起使用，用于在集合类（如 HashMap）中确定对象的唯一性。</p><ul><li>hashCode()： <code>根据对象的属性计算对象的哈希码值</code> ，是一个整数。哈希码值通常用于快速确定对象在集合中的位置。例如，在 HashMap 中，hashCode () 方法用于确定键值对在内部数组中的索引位置。<ul><li><font color="red">如果两个对象的哈希码不相等，则它们肯定不相等</font></li><li>反之，<font color="red">如果两个对象的哈希码相等，则它们不一定相等，还需要调用 equals () 进一步判断</font></li></ul></li><li>equals()：<ul><li><font color="cornflowerblue">默认情况下</font>，equals () 方法 <code>比较的是两个对象的引用值</code> ，即它们是否指向同一个内存地址。</li><li>但<font color="cornflowerblue">通常被重写</font>，用于 <code>比较两个对象（的属性）是否相等</code> 。</li><li>在 HashMap 中，如果两个键具有相同的哈希码值，则会调用 equals () 方法来确定它们是否真正相等。</li></ul></li><li>二者之间有一个重要的关系：如果两个对象使用 equals () 方法比较相等，则它们必须具有相同的哈希码值。这意味着，<font color="red">如果重写了 equals () 方法，则也必须重写 hashCode () 方法</font>，以确保它们之间的 <code>一致性</code> 。</li></ul><h4 id="2-hashcode-与-equals-生成算法-方法怎么重写阿校招"><a class="anchor" href="#2-hashcode-与-equals-生成算法-方法怎么重写阿校招">#</a> 2. <mark>hashCode () 与 equals () 生成算法、方法怎么重写？</mark>（阿 * 校招）</h4><p><strong>省流版</strong></p><p><code>equals()判断中使用的属性，通常也都会参与到hashCode()的计算中</code> 。</p><p>重写时可以借助 <code>Objects.equals</code> 和 <code>Objects.hash()</code> 。</p><p><strong>详细版</strong></p><p>hashCode () 方法用于返回对象的哈希码，重写该方法时需要满足以下 <code>规则</code> ：</p><ul><li>如果两个对象使用 equals () 方法比较返回 true，那么它们的 hashCode () 方法返回的值必须相等；</li><li>如果两个对象使用 equals () 方法比较返回 false，那么它们的 hashCode () 方法返回的值可以相等，也可以不相等；</li><li>如果两个对象使用 equals () 方法比较返回 false，但是它们的 hashCode () 方法返回的值相等，那么它们被称为<font color="red">哈希冲突</font>，可能会影响散列表等数据结构的性能。</li></ul><p>常见的 hashCode () 方法 <code>实现方式</code> 有：</p><ul><li>对象的属性值的异或和；</li><li>乘法因子法；</li><li>幂和积法等。</li></ul><p>具体实现可以根据业务需求和对象的属性值来选择。</p><p>equals () 方法用于比较两个对象是否相等，重写该方法时需要满足以下 <code>规则</code> ：</p><ul><li>自反性：对于任意非空的引用值 x，x.equals (x) 必须返回 true；</li><li>对称性：对于任意非空的引用值 x 和 y，如果 x.equals (y) 返回 true，那么 y.equals (x) 也必须返回 true；</li><li>传递性：对于任意非空的引用值 x、y 和 z，如果 x.equals (y) 返回 true，并且 y.equals (z) 返回 true，那么 x.equals (z) 也必须返回 true；</li><li>一致性：对于任意非空的引用值 x 和 y，在对象的属性值没有改变的情况下，多次调用 x.equals (y) 的结果必须一致；</li><li>对于任意非空的引用值 x，x.equals (null) 必须返回 false。</li></ul><p>常见的 equals () 方法 <code>实现方式</code> 有：</p><ul><li>比较两个对象的引用值是否相等；</li><li>比较两个对象的属性值是否相等；</li><li>比较两个对象的类型是否相等等。</li></ul><p>具体实现可以根据业务需求和对象的属性值来选择。</p><p>示例代码：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">int</span> age<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token annotation punctuation">@Override</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token comment">// 方式一：乘法因子法</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token comment">// int result = 17;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token comment">// result = 31 * result + name.hashCode();</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token comment">// result = 31 * result + age;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token comment">// return result;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        </pre></td></tr><tr><td data-num="18"></td><td><pre>        <span class="token comment">// 方式二：借助 Objects.hash ()</span></pre></td></tr><tr><td data-num="19"></td><td><pre>        <span class="token keyword">return</span> <span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">hash</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> age<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="21"></td><td><pre></pre></td></tr><tr><td data-num="22"></td><td><pre>    <span class="token annotation punctuation">@Override</span></pre></td></tr><tr><td data-num="23"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">Object</span> obj<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>        <span class="token comment">// 判断传入的对象是否为当前对象的引用</span></pre></td></tr><tr><td data-num="25"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">==</span> obj<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>        <span class="token comment">// 判断传入的对象是否属于当前类型</span></pre></td></tr><tr><td data-num="27"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>obj <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> obj<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>        <span class="token comment">// 如果传入的对象属于当前类型，则进行强制转换</span></pre></td></tr><tr><td data-num="29"></td><td><pre>        <span class="token class-name">Person</span> person <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Person</span><span class="token punctuation">)</span> obj<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>        <span class="token comment">// 方式一：</span></pre></td></tr><tr><td data-num="31"></td><td><pre>        <span class="token comment">// return age == person.age &amp;&amp; name.equals(person.name);</span></pre></td></tr><tr><td data-num="32"></td><td><pre>        </pre></td></tr><tr><td data-num="33"></td><td><pre>        <span class="token comment">// 方式二：借助 Integer.compare ()、Objects.equals ()</span></pre></td></tr><tr><td data-num="34"></td><td><pre>        <span class="token keyword">return</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span>age<span class="token punctuation">,</span>person<span class="token punctuation">.</span>age<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span>person<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="35"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="36"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h4 id="3-说一下equals和的区别equals相等hash值一定相等吗hash值相等equals一定相等吗南电网-上海智网络"><a class="anchor" href="#3-说一下equals和的区别equals相等hash值一定相等吗hash值相等equals一定相等吗南电网-上海智网络">#</a> 3. 说一下 equals 和 == 的区别，equals 相等 hash 值一定相等吗？hash 值相等 equals 一定相等吗？（南 * 电网、上海 * 智网络）</h4><p>首先， <code>==</code> 是一个运算符，而 <code>equals()</code> 是一个方法。</p><p>其次，二者都可用于比较两个对象。 <code>==</code> 运算符用于比较两个对象的引用是否相等，即<strong>比较的是两个对象的内存地址</strong>，与 <code>equals()</code> 方法一样。</p><p>但是 <code>equals()</code> 通常被重写，例如 String、Integer、Date 等类对 <code>equals()</code> 方法进行了重写，所以在这些类中， <code>equals()</code> <strong>比较的是两个对象的内容</strong>。</p><p>如果两个对象通过 equals () 方法比较相等，那么它们的 hash 值也应该相等。但是，如果两个对象的 hash 值相等，并不意味着它们通过 equals () 方法比较也一定相等，这是<font color="red">因为不同的对象可能会产生相同的 hash 值</font>。</p><h3 id="25-set集合源码相关"><a class="anchor" href="#25-set集合源码相关">#</a> 2.5 Set 集合源码相关</h3><h4 id="1-hashset存放数据的方式拓软件"><a class="anchor" href="#1-hashset存放数据的方式拓软件">#</a> 1. <mark>HashSet 存放数据的方式？</mark>（拓 * 软件）</h4><p>HashSet 实际上是基于 HashMap 实现的，内部有一个 HashMap 类型的成员变量，用于存储元素。当向 HashSet 中添加一个元素时，实际上是将该元素添加到 <code>HashMap的键</code> 中，而该键对应的 <code>值则是一个固定的Object对象</code> 。</p><blockquote><p>由于 HashMap 中的键不能重复，所以当你向 HashSet 中添加重复元素时，实际上是向 HashMap 中添加重复键，这样就能<font color="red">保证 HashSet 中不会有重复元素</font>。此外，由于 HashMap 允许键为 null，所以<font color="red">HashSet 也允许有 null 值</font>。</p></blockquote><h4 id="2-set是如何实现元素的唯一性湖利软件"><a class="anchor" href="#2-set是如何实现元素的唯一性湖利软件">#</a> 2. Set 是如何实现元素的唯一性？（湖 ** 利软件）</h4><p><strong>Set 的元素存储在 Map 的键中</strong></p><p>因为 Set 实际上是基于 Map 实现的，Set 的元素实际上存储在 Map 的键中，而<font color="red">Map 的键是唯一的，不能重复的，因此 Set 的元素是唯一的</font>。</p><p><strong>Map 如何实现键的唯一性？</strong></p><p>Map 接口的不同实现类使用不同的数据结构和算法来<font color="red">保证键的唯一性</font>。</p><ul><li><p>HashMap：依赖于 <code>键的哈希值</code> 和 <code>equals()</code> 。通过哈希值来快速定位 key 所在的位置，再通过比较函数判断 key 是否相等。因此，<font color="orange">在使用 Map 时，我们需要保证键对象的 hashCode () 和 equals () 方法都正确实现，才能保证 Map 中的 key 唯一性</font>。</p><blockquote><p>例如，HashMap 是基于 <code>哈希表</code> 实现的。当你向 HashMap 中添加一个键值对时，它会根据键的哈希码值来确定该键值对在哈希表中的存储位置。如果该位置已经有一个键值对，那么 HashMap 会调用 <code>equals()</code> 方法来检查新添加的键与已有的键是否相等。如果 <code>equals()</code> 方法返回 <code>true</code> ，则新添加的键与已有的<u>键重复</u>，新添加的键值对将<u>替换</u>已有的键值对。如果 <code>equals()</code> 方法返回 <code>false</code> ，则新添加的键与已有的<u>键不重复</u>，新添加的键值对将被<u>添加</u>到哈希表中。</p></blockquote></li><li><p>TreeMap：依赖于 <code>键的自然排序</code> 或者 <code>指定的比较器</code></p><blockquote><p>对于 TreeMap，它是基于 <code>红黑树</code> 实现的。当你向 TreeMap 中添加一个键值对时，它<font color="red">会根据键的自然顺序或者指定的比较器来确定该键值对在红黑树中的位置</font>。<font color="red">如果你尝试向 TreeMap 中添加<u>重复键</u>，那么新添加的键值对将<u>不会被添加</u>到红黑树中</font>。</p></blockquote></li></ul><p>总之，Map 接口的不同实现类通过使用不同的数据结构和算法来保证键的唯一性。</p><h4 id="3-用哪两种方式来实现集合的排序凡科技"><a class="anchor" href="#3-用哪两种方式来实现集合的排序凡科技">#</a> 3. 用哪两种方式来实现集合的排序（凡 * 科技）</h4><pre><code>类似问题：
&gt; 集合怎么排序？（北京中**信科技）
</code></pre><p>在 Java 中，可以使用以下两种方式来实现集合的排序：</p><ol><li><font color="cornflowerblue">自然排序</font>：<font color="red">集合元素实现了 <code>Comparable 接口</code> ，通过重写 <code>compareTo() 方法</code> 来定义元素之间的排序关系</font>。Java 中的一些内置类型（如 Integer、String 等）已经实现了 Comparable 接口，可以直接使用自然排序。例如，可以使用 Collections.sort () 方法对实现了 Comparable 接口的 List 进行排序。</li><li><font color="cornflowerblue">定制排序</font>：使用一个比较器（Comparator）对象来定义元素之间的排序关系。<font color="red">需要创建一个实现了 <code>Comparator 接口</code> 的比较器对象，并实现了 <code>compare() 方法</code> 来定义元素之间的排序关系</font>。通过<font color="red">在集合类的构造器的排序方法参数中传入比较器对象</font>，可以实现自定义排序。例如，可以使用 Collections.sort () 方法对实现了 Comparator 接口的 List 进行排序。</li></ol></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2023-11-12 11:00:51" itemprop="dateModified" datetime="2023-11-12T11:00:51+08:00">2023-11-12</time> </span><span id="java/java-se/java-excise/第14章：随堂复习与企业真题（数据结构与集合源码）/" class="item leancloud_visitors" data-flag-title="宋红康_第14章：数据结构与集合源码" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>范特东东东 <i class="ic i-at"><em>@</em></i>水文 & 摄影</li><li class="link"><strong>本文链接：</strong> <a href="http://example.com/java/java-se/java-excise/%E7%AC%AC14%E7%AB%A0%EF%BC%9A%E9%9A%8F%E5%A0%82%E5%A4%8D%E4%B9%A0%E4%B8%8E%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%A2%98%EF%BC%88%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%EF%BC%89/" title="宋红康_第14章：数据结构与集合源码">http://example.com/java/java-se/java-excise/第14章：随堂复习与企业真题（数据结构与集合源码）/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/java/java-se/java-excise/%E7%AC%AC13%E7%AB%A0%EF%BC%9A%E9%9A%8F%E5%A0%82%E5%A4%8D%E4%B9%A0%E4%B8%8E%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%A2%98%EF%BC%88%E6%B3%9B%E5%9E%8B%EF%BC%89/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;s2.loli.net&#x2F;2023&#x2F;11&#x2F;14&#x2F;yBITpFeSzaHmgjW.webp" title="宋红康_第13章：泛型"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> Java基础-真题</span><h3>宋红康_第13章：泛型</h3></a></div><div class="item right"><a href="/java/java-se/java-excise/%E7%AC%AC15%E7%AB%A0%EF%BC%9A%E9%9A%8F%E5%A0%82%E5%A4%8D%E4%B9%A0%E4%B8%8E%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%A2%98%EF%BC%88File%E7%B1%BB%E4%B8%8EIO%E6%B5%81%EF%BC%89/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;hjx159&#x2F;picture-bed&#x2F;main&#x2F;img&#x2F;image-20230411183512545.png" title="宋红康_第15章：File类与IO流"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> Java基础-真题</span><h3>宋红康_第15章：File类与IO流</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC14%E7%AB%A0%E9%9A%8F%E5%A0%82%E5%A4%8D%E4%B9%A0%E4%B8%8E%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%A2%98%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81"><span class="toc-number">1.</span> <span class="toc-text">第 14 章：随堂复习与企业真题（数据结构与集合源码）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-%E9%9A%8F%E5%A0%82%E5%A4%8D%E4%B9%A0"><span class="toc-number">1.1.</span> <span class="toc-text">一、随堂复习</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.1.</span> <span class="toc-text">1. 数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-list%E6%8E%A5%E5%8F%A3%E4%B8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%B1%BB%E7%9A%84%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90"><span class="toc-number">1.1.2.</span> <span class="toc-text">2. List 接口下的实现类的源码剖析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-map%E6%8E%A5%E5%8F%A3%E4%B8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%B1%BB%E7%9A%84%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90"><span class="toc-number">1.1.3.</span> <span class="toc-text">3. Map 接口下的实现类的源码剖析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%A2%98"><span class="toc-number">1.2.</span> <span class="toc-text">二、企业真题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#21-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9B%B8%E5%85%B3"><span class="toc-number">1.2.1.</span> <span class="toc-text">2.1 数据结构相关</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%93%BE%E8%A1%A8%E5%92%8C%E6%95%B0%E7%BB%84%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E8%85%BE"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">1. 链表和数组有什么区别？（腾 *）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%A0%88%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%90%E8%A1%8C%E7%9A%84%E8%A5%BF%E4%BF%A1%E6%81%AF%E6%8A%80%E6%9C%AF"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">2. 栈是如何运行的？(西 * 信息技术)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-list%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%E7%9B%B8%E5%85%B3"><span class="toc-number">1.2.2.</span> <span class="toc-text">2.2 List 集合源码相关</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-arraylist%E7%9A%84%E9%BB%98%E8%AE%A4%E5%A4%A7%E5%B0%8F%E6%98%AF%E5%A4%9A%E5%B0%91%E4%BB%A5%E5%8F%8A%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6%E9%A1%BA-%E5%87%A1%E7%A7%91%E6%8A%80"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">1. ArrayList 的默认大小是多少，以及扩容机制（顺 *、凡 * 科技）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-arraylist%E7%9A%84%E5%BA%95%E5%B1%82%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%E8%85%BE"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">2. ArrayList 的底层是怎么实现的？（腾 *）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%9C%A8arraylist%E4%B8%ADremove%E5%90%8E%E9%9D%A2%E5%87%A0%E4%B8%AA%E5%85%83%E7%B4%A0%E8%AF%A5%E6%80%8E%E4%B9%88%E5%81%9A%E6%83%A0-%E4%B8%AD%E4%BA%BF%E8%BE%BE"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">3. 在 ArrayList 中 remove 后面几个元素该怎么做？（惠 *、中 * 亿达）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-arraylist17%E5%92%8C18%E7%9A%84%E5%8C%BA%E5%88%AB%E6%8B%93%E6%80%9D"><span class="toc-number">1.2.2.4.</span> <span class="toc-text">4. ArrayList1.7 和 1.8 的区别（拓 * 思）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E6%95%B0%E7%BB%84%E5%92%8C-arraylist-%E7%9A%84%E5%8C%BA%E5%88%AB%E9%98%BF-%E7%A7%91%E8%BD%AF"><span class="toc-number">1.2.2.5.</span> <span class="toc-text">5. 数组和 ArrayList 的区别（阿 *、* 科软）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84list%E5%B9%B3%E9%87%91%E6%9C%8D"><span class="toc-number">1.2.2.6.</span> <span class="toc-text">6. 什么是线程安全的 List？(平 * 金服)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-hashmap%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%E7%9B%B8%E5%85%B3"><span class="toc-number">1.2.3.</span> <span class="toc-text">2.3 HashMap 集合源码相关</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%AF%B4%E8%AF%B4hahmap%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E6%96%B0%E8%82%A1%E4%BB%BD-%E9%A1%BA-%E7%8C%AB%E5%A8%B1%E4%B9%90"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">1. 说说 HahMap 底层实现 (新 * 股份、顺 *、猫 * 娱乐)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-hashmap%E5%88%9D%E5%A7%8B%E5%80%BC16%E4%B8%B4%E7%95%8C%E5%80%BC12%E6%98%AF%E6%80%8E%E4%B9%88%E7%AE%97%E7%9A%84%E8%BD%AF%E5%8A%9B"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">2. HashMap 初始值 16，临界值 12 是怎么算的（软 ** 力）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-hashmap%E9%95%BF%E5%BA%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF2%E7%9A%84%E5%B9%82%E6%AC%A1%E6%96%B9%E5%9B%BD%E6%97%B6%E4%BB%A3"><span class="toc-number">1.2.3.3.</span> <span class="toc-text">3. HashMap 长度为什么是 2 的幂次方？(国 * 时代)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-hashmap%E6%80%8E%E4%B9%88%E8%AE%A1%E7%AE%97%E5%93%88%E5%B8%8C%E5%80%BC%E5%92%8C%E7%B4%A2%E5%BC%95%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3hash%E5%86%B2%E7%AA%81%E8%BD%AF%E5%9B%BD%E9%99%85-%E4%B8%AD%E8%BD%AF%E8%85%BE"><span class="toc-number">1.2.3.4.</span> <span class="toc-text">4. HashMap 怎么计算哈希值和索引？扩容机制？怎么解决 hash 冲突？（* 软国际、中软 * 腾）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-hashmap%E5%BA%95%E5%B1%82%E6%98%AF%E6%95%B0%E7%BB%84%E9%93%BE%E8%A1%A8%E6%9C%89%E6%95%B0%E7%BB%84%E5%BE%88%E5%BF%AB%E4%BA%86%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8A%A0%E9%93%BE%E8%A1%A8%E6%B6%A6%E8%BD%AF%E4%BB%B6"><span class="toc-number">1.2.3.5.</span> <span class="toc-text">5. HashMap 底层是数组 + 链表，有数组很快了，为什么加链表？（润 * 软件）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-hashmap%E4%B8%BA%E4%BB%80%E4%B9%88%E9%95%BF%E5%BA%A6%E8%BE%BE%E5%88%B0%E4%B8%80%E5%AE%9A%E7%9A%84%E9%95%BF%E5%BA%A6%E8%A6%81%E8%BD%AC%E5%8C%96%E4%B8%BA%E7%BA%A2%E9%BB%91%E6%A0%91%E5%BA%A6"><span class="toc-number">1.2.3.6.</span> <span class="toc-text">6. HashMap 为什么长度达到一定的长度要转化为红黑树（* 度）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-hashmap%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E6%89%A9%E5%85%85%E4%B8%BA%E7%BA%A2%E9%BB%91%E6%A0%91%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%8F%88%E8%BF%94%E5%9B%9E%E5%88%B0%E9%93%BE%E8%A1%A8%E6%B1%89"><span class="toc-number">1.2.3.7.</span> <span class="toc-text">7. HashMap 什么时候扩充为红黑树，什么时候又返回到链表？（汉 *）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-%E5%9C%A8-jdk18%E4%B8%ADhashmap%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E17%E7%9B%B8%E6%AF%94%E6%9C%89%E4%BB%80%E4%B9%88%E5%8F%98%E5%8C%96%E8%BF%99%E4%BA%9B%E5%8F%98%E5%8C%96%E7%9A%84%E5%A5%BD%E5%A4%84%E5%9C%A8%E5%93%AA%E9%87%8C%E6%B5%B7%E7%A7%91"><span class="toc-number">1.2.3.8.</span> <span class="toc-text">8. 在 JDK1.8 中，HashMap 的数据结构与 1.7 相比有什么变化，这些变化的好处在哪里？（海 * 科）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-hashmap%E7%9A%84get%E6%96%B9%E6%B3%95%E7%9A%84%E5%8E%9F%E7%90%86%E9%A1%BA"><span class="toc-number">1.2.3.9.</span> <span class="toc-text">9. HashMap 的 get () 方法的原理？（顺 *）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-hashmap%E7%9A%84remove%E6%96%B9%E6%B3%95%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">1.2.3.10.</span> <span class="toc-text">10. HashMap 的 remove () 方法的原理？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24-hashcode%E5%92%8Cequals"><span class="toc-number">1.2.4.</span> <span class="toc-text">2.4 hashCode 和 equals</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-hashcode%E5%92%8Cequals%E7%9A%84%E5%8C%BA%E5%88%AB%E6%B5%B7%E4%BE%9B%E5%BA%94%E9%93%BE%E7%AE%A1%E7%90%86"><span class="toc-number">1.2.4.1.</span> <span class="toc-text">1. hashCode () 和 equals () 的区别？（海 * 供应链管理）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-hashcode-%E4%B8%8E-equals-%E7%94%9F%E6%88%90%E7%AE%97%E6%B3%95-%E6%96%B9%E6%B3%95%E6%80%8E%E4%B9%88%E9%87%8D%E5%86%99%E9%98%BF%E6%A0%A1%E6%8B%9B"><span class="toc-number">1.2.4.2.</span> <span class="toc-text">2. hashCode () 与 equals () 生成算法、方法怎么重写？（阿 * 校招）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E8%AF%B4%E4%B8%80%E4%B8%8Bequals%E5%92%8C%E7%9A%84%E5%8C%BA%E5%88%ABequals%E7%9B%B8%E7%AD%89hash%E5%80%BC%E4%B8%80%E5%AE%9A%E7%9B%B8%E7%AD%89%E5%90%97hash%E5%80%BC%E7%9B%B8%E7%AD%89equals%E4%B8%80%E5%AE%9A%E7%9B%B8%E7%AD%89%E5%90%97%E5%8D%97%E7%94%B5%E7%BD%91-%E4%B8%8A%E6%B5%B7%E6%99%BA%E7%BD%91%E7%BB%9C"><span class="toc-number">1.2.4.3.</span> <span class="toc-text">3. 说一下 equals 和 &#x3D;&#x3D; 的区别，equals 相等 hash 值一定相等吗？hash 值相等 equals 一定相等吗？（南 * 电网、上海 * 智网络）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#25-set%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%E7%9B%B8%E5%85%B3"><span class="toc-number">1.2.5.</span> <span class="toc-text">2.5 Set 集合源码相关</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-hashset%E5%AD%98%E6%94%BE%E6%95%B0%E6%8D%AE%E7%9A%84%E6%96%B9%E5%BC%8F%E6%8B%93%E8%BD%AF%E4%BB%B6"><span class="toc-number">1.2.5.1.</span> <span class="toc-text">1. HashSet 存放数据的方式？（拓 * 软件）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-set%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%85%83%E7%B4%A0%E7%9A%84%E5%94%AF%E4%B8%80%E6%80%A7%E6%B9%96%E5%88%A9%E8%BD%AF%E4%BB%B6"><span class="toc-number">1.2.5.2.</span> <span class="toc-text">2. Set 是如何实现元素的唯一性？（湖 ** 利软件）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E7%94%A8%E5%93%AA%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F%E6%9D%A5%E5%AE%9E%E7%8E%B0%E9%9B%86%E5%90%88%E7%9A%84%E6%8E%92%E5%BA%8F%E5%87%A1%E7%A7%91%E6%8A%80"><span class="toc-number">1.2.5.3.</span> <span class="toc-text">3. 用哪两种方式来实现集合的排序（凡 * 科技）</span></a></li></ol></li></ol></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/java/java-se/java-excise/%E7%AC%AC01%E7%AB%A0%EF%BC%9A%E9%9A%8F%E5%A0%82%E5%A4%8D%E4%B9%A0%E4%B8%8E%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%A2%98%EF%BC%88Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0%EF%BC%89/" rel="bookmark" title="宋红康_第01章：Java语言概述">宋红康_第01章：Java语言概述</a></li><li><a href="/java/java-se/java-excise/%E7%AC%AC02%E7%AB%A0%EF%BC%9A%E9%9A%8F%E5%A0%82%E5%A4%8D%E4%B9%A0%E4%B8%8E%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%A2%98%EF%BC%88%E5%8F%98%E9%87%8F%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%89/" rel="bookmark" title="宋红康_第02章：变量与运算符">宋红康_第02章：变量与运算符</a></li><li><a href="/java/java-se/java-excise/%E7%AC%AC03%E7%AB%A0%EF%BC%9A%E9%9A%8F%E5%A0%82%E5%A4%8D%E4%B9%A0%E4%B8%8E%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%A2%98%EF%BC%88%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5%EF%BC%89/" rel="bookmark" title="宋红康_第03章：流程控制语句">宋红康_第03章：流程控制语句</a></li><li><a href="/java/java-se/java-excise/%E7%AC%AC04%E7%AB%A0%EF%BC%9A%E9%9A%8F%E5%A0%82%E5%A4%8D%E4%B9%A0%E4%B8%8E%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%A2%98%EF%BC%88IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%89/" rel="bookmark" title="宋红康_第04章：IDEA安装与使用">宋红康_第04章：IDEA安装与使用</a></li><li><a href="/java/java-se/java-excise/%E7%AC%AC05%E7%AB%A0%EF%BC%9A%E9%9A%8F%E5%A0%82%E5%A4%8D%E4%B9%A0%E4%B8%8E%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%A2%98%EF%BC%88%E6%95%B0%E7%BB%84%EF%BC%89/" rel="bookmark" title="宋红康_第05章：数组">宋红康_第05章：数组</a></li><li><a href="/java/java-se/java-excise/%E7%AC%AC06%E7%AB%A0%EF%BC%9A%E9%9A%8F%E5%A0%82%E5%A4%8D%E4%B9%A0%E4%B8%8E%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%A2%98%EF%BC%88%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%9F%BA%E7%A1%80%EF%BC%89/" rel="bookmark" title="宋红康_第06章：面向对象-基础">宋红康_第06章：面向对象-基础</a></li><li><a href="/java/java-se/java-excise/%E7%AC%AC07%E7%AB%A0%EF%BC%9A%E9%9A%8F%E5%A0%82%E5%A4%8D%E4%B9%A0%E4%B8%8E%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%A2%98%EF%BC%88%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E8%BF%9B%E9%98%B6%EF%BC%89/" rel="bookmark" title="宋红康_第07章：面向对象-进阶">宋红康_第07章：面向对象-进阶</a></li><li><a href="/java/java-se/java-excise/%E7%AC%AC08%E7%AB%A0%EF%BC%9A%E9%9A%8F%E5%A0%82%E5%A4%8D%E4%B9%A0%E4%B8%8E%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%A2%98%EF%BC%88%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E9%AB%98%E7%BA%A7%EF%BC%89/" rel="bookmark" title="宋红康_第08章：面向对象-高级">宋红康_第08章：面向对象-高级</a></li><li><a href="/java/java-se/java-excise/%E7%AC%AC09%E7%AB%A0%EF%BC%9A%E9%9A%8F%E5%A0%82%E5%A4%8D%E4%B9%A0%E4%B8%8E%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%A2%98%EF%BC%88%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%EF%BC%89/" rel="bookmark" title="宋红康_第09章：异常处理">宋红康_第09章：异常处理</a></li><li><a href="/java/java-se/java-excise/%E7%AC%AC10%E7%AB%A0%EF%BC%9A%E9%9A%8F%E5%A0%82%E5%A4%8D%E4%B9%A0%E4%B8%8E%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%A2%98%EF%BC%88%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%89/" rel="bookmark" title="宋红康_第10章：多线程">宋红康_第10章：多线程</a></li><li><a href="/java/java-se/java-excise/%E7%AC%AC11%E7%AB%A0%EF%BC%9A%E9%9A%8F%E5%A0%82%E5%A4%8D%E4%B9%A0%E4%B8%8E%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%A2%98%EF%BC%88%E5%B8%B8%E7%94%A8%E7%B1%BB%E4%B8%8E%E5%9F%BA%E7%A1%80API%EF%BC%89/" rel="bookmark" title="宋红康_第11章：常用类与基础API">宋红康_第11章：常用类与基础API</a></li><li><a href="/java/java-se/java-excise/%E7%AC%AC12%E7%AB%A0%EF%BC%9A%E9%9A%8F%E5%A0%82%E5%A4%8D%E4%B9%A0%E4%B8%8E%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%A2%98%EF%BC%88%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%EF%BC%89/" rel="bookmark" title="宋红康_第12章：集合框架">宋红康_第12章：集合框架</a></li><li><a href="/java/java-se/java-excise/%E7%AC%AC13%E7%AB%A0%EF%BC%9A%E9%9A%8F%E5%A0%82%E5%A4%8D%E4%B9%A0%E4%B8%8E%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%A2%98%EF%BC%88%E6%B3%9B%E5%9E%8B%EF%BC%89/" rel="bookmark" title="宋红康_第13章：泛型">宋红康_第13章：泛型</a></li><li class="active"><a href="/java/java-se/java-excise/%E7%AC%AC14%E7%AB%A0%EF%BC%9A%E9%9A%8F%E5%A0%82%E5%A4%8D%E4%B9%A0%E4%B8%8E%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%A2%98%EF%BC%88%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%EF%BC%89/" rel="bookmark" title="宋红康_第14章：数据结构与集合源码">宋红康_第14章：数据结构与集合源码</a></li><li><a href="/java/java-se/java-excise/%E7%AC%AC15%E7%AB%A0%EF%BC%9A%E9%9A%8F%E5%A0%82%E5%A4%8D%E4%B9%A0%E4%B8%8E%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%A2%98%EF%BC%88File%E7%B1%BB%E4%B8%8EIO%E6%B5%81%EF%BC%89/" rel="bookmark" title="宋红康_第15章：File类与IO流">宋红康_第15章：File类与IO流</a></li><li><a href="/java/java-se/java-excise/%E7%AC%AC16%E7%AB%A0%EF%BC%9A%E9%9A%8F%E5%A0%82%E5%A4%8D%E4%B9%A0%E4%B8%8E%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%A2%98%EF%BC%88%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%EF%BC%89/" rel="bookmark" title="宋红康_第16章：网络编程">宋红康_第16章：网络编程</a></li><li><a href="/java/java-se/java-excise/%E7%AC%AC17%E7%AB%A0%EF%BC%9A%E9%9A%8F%E5%A0%82%E5%A4%8D%E4%B9%A0%E4%B8%8E%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%A2%98%EF%BC%88%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%EF%BC%89/" rel="bookmark" title="宋红康_第17章：反射机制">宋红康_第17章：反射机制</a></li><li><a href="/java/java-se/java-excise/%E7%AC%AC18%E7%AB%A0%EF%BC%9A%E9%9A%8F%E5%A0%82%E5%A4%8D%E4%B9%A0%E4%B8%8E%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%A2%98%EF%BC%88JDK8-17%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%89/" rel="bookmark" title="宋红康_第18章：JDK8-17新特性">宋红康_第18章：JDK8-17新特性</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="范特东东东" data-src="/images/avatar.jpg"><p class="name" itemprop="name">范特东东东</p><div class="description" itemprop="description"></div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">47</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">12</span> <span class="name">分类</span></a></div></nav><div class="social"><span class="exturl item xiaohongshu" data-url="aHR0cHM6Ly93d3cueGlhb2hvbmdzaHUuY29tL3VzZXIvcHJvZmlsZS81ZTAyYzhhZDAwMDAwMDAwMDEwMDFmM2U=" title="https:&#x2F;&#x2F;www.xiaohongshu.com&#x2F;user&#x2F;profile&#x2F;5e02c8ad0000000001001f3e"><i class="ic i-xiaohongshu"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于我</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><span class="exturl" data-url="aHR0cHM6Ly9oangxNTkuZ2l0aHViLmlvL2NhdGVnb3JpZXMvcGhvdG9ncmFwaHkv"><i class="ic i-photography"></i>摄影</span></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/java/java-se/java-excise/%E7%AC%AC13%E7%AB%A0%EF%BC%9A%E9%9A%8F%E5%A0%82%E5%A4%8D%E4%B9%A0%E4%B8%8E%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%A2%98%EF%BC%88%E6%B3%9B%E5%9E%8B%EF%BC%89/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/java/java-se/java-excise/%E7%AC%AC15%E7%AB%A0%EF%BC%9A%E9%9A%8F%E5%A0%82%E5%A4%8D%E4%B9%A0%E4%B8%8E%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%A2%98%EF%BC%88File%E7%B1%BB%E4%B8%8EIO%E6%B5%81%EF%BC%89/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/java/" title="分类于 Java">Java</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/" title="分类于 Java基础">Java基础</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/java-excise/" title="分类于 Java基础-真题">Java基础-真题</a></div><span><a href="/java/java-se/java-excise/%E7%AC%AC15%E7%AB%A0%EF%BC%9A%E9%9A%8F%E5%A0%82%E5%A4%8D%E4%B9%A0%E4%B8%8E%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%A2%98%EF%BC%88File%E7%B1%BB%E4%B8%8EIO%E6%B5%81%EF%BC%89/" title="宋红康_第15章：File类与IO流">宋红康_第15章：File类与IO流</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/java/" title="分类于 Java">Java</a> <i class="ic i-angle-right"></i> <a href="/categories/java/jvm/" title="分类于 JVM">JVM</a></div><span><a href="/java/jvm/JVM%E7%AC%94%E8%AE%B0/" title="JVM笔记">JVM笔记</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/java/" title="分类于 Java">Java</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/" title="分类于 Java基础">Java基础</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/java-knowledge/" title="分类于 Java基础-知识点">Java基础-知识点</a></div><span><a href="/java/java-se/java-knowledge/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E5%AE%8B%E7%BA%A2%E5%BA%B7_%E7%AC%AC10%E7%AB%A0_%E5%A4%9A%E7%BA%BF%E7%A8%8B/" title="宋红康_第10章_多线程">宋红康_第10章_多线程</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/java/" title="分类于 Java">Java</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/" title="分类于 Java基础">Java基础</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/java-excise/" title="分类于 Java基础-真题">Java基础-真题</a></div><span><a href="/java/java-se/java-excise/%E7%AC%AC03%E7%AB%A0%EF%BC%9A%E9%9A%8F%E5%A0%82%E5%A4%8D%E4%B9%A0%E4%B8%8E%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%A2%98%EF%BC%88%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5%EF%BC%89/" title="宋红康_第03章：流程控制语句">宋红康_第03章：流程控制语句</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/java/" title="分类于 Java">Java</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/" title="分类于 Java基础">Java基础</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/java-knowledge/" title="分类于 Java基础-知识点">Java基础-知识点</a></div><span><a href="/java/java-se/java-knowledge/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E5%AE%8B%E7%BA%A2%E5%BA%B7_%E7%AC%AC06%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/" title="宋红康_第06章_面向对象编程（基础）">宋红康_第06章_面向对象编程（基础）</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/photography/" title="分类于 摄影">摄影</a></div><span><a href="/photography/%E8%AF%BE%E4%B8%8A%E6%91%B8%E9%B1%BC/" title="课上摸鱼">课上摸鱼</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/java/" title="分类于 Java">Java</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/" title="分类于 Java基础">Java基础</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/java-excise/" title="分类于 Java基础-真题">Java基础-真题</a></div><span><a href="/java/java-se/java-excise/%E7%AC%AC14%E7%AB%A0%EF%BC%9A%E9%9A%8F%E5%A0%82%E5%A4%8D%E4%B9%A0%E4%B8%8E%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%A2%98%EF%BC%88%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%EF%BC%89/" title="宋红康_第14章：数据结构与集合源码">宋红康_第14章：数据结构与集合源码</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/java/" title="分类于 Java">Java</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/" title="分类于 Java基础">Java基础</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/java-knowledge/" title="分类于 Java基础-知识点">Java基础-知识点</a></div><span><a href="/java/java-se/java-knowledge/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E5%AE%8B%E7%BA%A2%E5%BA%B7_%E7%AC%AC17%E7%AB%A0_%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/" title="宋红康_第17章_反射机制">宋红康_第17章_反射机制</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/java/" title="分类于 Java">Java</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/" title="分类于 Java基础">Java基础</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/java-knowledge/" title="分类于 Java基础-知识点">Java基础-知识点</a></div><span><a href="/java/java-se/java-knowledge/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E5%AE%8B%E7%BA%A2%E5%BA%B7_%E7%AC%AC18%E7%AB%A0_JDK8-17%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%88%E4%B8%8A%EF%BC%89/" title="宋红康_第18章_JDK8-17新特性（上）">宋红康_第18章_JDK8-17新特性（上）</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/leetcode/" title="分类于 LeetCode">LeetCode</a> <i class="ic i-angle-right"></i> <a href="/categories/leetcode/carl/" title="分类于 代码随想录">代码随想录</a></div><span><a href="/leetcode/carl/%E7%AC%94%E8%AE%B0%E9%9A%8F%E6%83%B3%E5%BD%95/" title="代码随想录-笔记">代码随想录-笔记</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2023</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">范特东东东 @ phantasy</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">1.5m 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">23:29</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"java/java-se/java-excise/第14章：随堂复习与企业真题（数据结构与集合源码）/",favicon:{show:"(●´3｀●)欢迎回来",hide:"(〃＞皿＜)你快回来"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hrmmi -->