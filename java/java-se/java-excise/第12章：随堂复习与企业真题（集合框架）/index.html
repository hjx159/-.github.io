<!-- build time:Sat Apr 27 2024 21:40:51 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="水文 & 摄影" href="http://example.com/rss.xml"><link rel="alternate" type="application/atom+xml" title="水文 & 摄影" href="http://example.com/atom.xml"><link rel="alternate" type="application/json" title="水文 & 摄影" href="http://example.com/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><link rel="canonical" href="http://example.com/java/java-se/java-excise/%E7%AC%AC12%E7%AB%A0%EF%BC%9A%E9%9A%8F%E5%A0%82%E5%A4%8D%E4%B9%A0%E4%B8%8E%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%A2%98%EF%BC%88%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%EF%BC%89/"><title>宋红康_第12章：集合框架 - Java基础-真题 - Java基础 - Java | fantedong = 水文 & 摄影 = 为了能更好地查看图片，你需要一点魔法</title><meta name="generator" content="Hexo 6.3.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">宋红康_第12章：集合框架</h1><div class="meta"><span class="item" title="创建时间：2023-11-12 11:06:50"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2023-11-12T11:06:50+08:00">2023-11-12</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>24k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>22 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">fantedong</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><img src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231112105809219.png"></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/java/" itemprop="item" rel="index" title="分类于 Java"><span itemprop="name">Java</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/java/java-se/" itemprop="item" rel="index" title="分类于 Java基础"><span itemprop="name">Java基础</span></a><meta itemprop="position" content="2"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/java/java-se/java-excise/" itemprop="item" rel="index" title="分类于 Java基础-真题"><span itemprop="name">Java基础-真题</span></a><meta itemprop="position" content="3"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://example.com/java/java-se/java-excise/%E7%AC%AC12%E7%AB%A0%EF%BC%9A%E9%9A%8F%E5%A0%82%E5%A4%8D%E4%B9%A0%E4%B8%8E%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%A2%98%EF%BC%88%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%EF%BC%89/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="范特东东东"><meta itemprop="description" content="为了能更好地查看图片，你需要一点魔法, "></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="水文 & 摄影"></span><div class="body md" itemprop="articleBody"><h1 id="第12章随堂复习与企业真题集合框架"><a class="anchor" href="#第12章随堂复习与企业真题集合框架">#</a> 第 12 章：随堂复习与企业真题（集合框架）</h1><hr><h2 id="一-随堂复习"><a class="anchor" href="#一-随堂复习">#</a> 一、随堂复习</h2><h3 id="1-数组存储数据方面的特点和弊端"><a class="anchor" href="#1-数组存储数据方面的特点和弊端">#</a> 1. 数组存储数据方面的特点和弊端</h3><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">数组</th><th style="text-align:center">集合</th></tr></thead><tbody><tr><td style="text-align:center">长度</td><td style="text-align:center">长度固定</td><td style="text-align:center">动态长度</td></tr><tr><td style="text-align:center">可存储的元素类型</td><td style="text-align:center">基本数据类型、引用数据类型</td><td style="text-align:center">引用数据类型 / 映射</td></tr><tr><td style="text-align:center">元素类型要求</td><td style="text-align:center">元素的类型必须相同</td><td style="text-align:center">元素的类型可以不同</td></tr><tr><td style="text-align:center">是否连续存储</td><td style="text-align:center">连续存储</td><td style="text-align:center">非连续存储</td></tr><tr><td style="text-align:center">元素特点</td><td style="text-align:center">有序、可重复</td><td style="text-align:center">List：有序、可重复；Set：无序、不可重复；Map：无序、不可重复；</td></tr><tr><td style="text-align:center">查找速度</td><td style="text-align:center">快（通过索引值，复杂度为 O (1)）</td><td style="text-align:center">慢（复杂度为 O (n)）</td></tr><tr><td style="text-align:center">增、删、插速度</td><td style="text-align:center">慢</td><td style="text-align:center">快</td></tr><tr><td style="text-align:center">举例</td><td style="text-align:center"></td><td style="text-align:center">List、Set、Map</td></tr></tbody></table><pre><code>   数组存储多个数据方面的特点：
   &gt; 数组一旦初始化，其长度就是确定的。
   &gt; 数组中的多个元素是依次紧密排列的，有序的，可重复的
   &gt; (优点) 数组一旦初始化完成，其元素的类型就是确定的。不是此类型的元素，就不能添加到此数组中。
      int[] arr = new int[10];
      arr[0] = 1;
      arr[1] = &quot;AA&quot;;//编译报错

      Object[] arr1 = new Object[10];
      arr1[0] = new String();
      arr1[1] = new Date();
   &gt; (优点)元素的类型既可以是基本数据类型，也可以是引用数据类型。

   数组存储多个数据方面的弊端：
   &gt; 数组一旦初始化，其长度就不可变了。
   &gt; 数组中存储数据特点的单一性。对于无序的、不可重复的场景的多个数据就无能为力了。
   &gt; 数组中可用的方法、属性都极少。具体的需求，都需要自己来组织相关的代码逻辑。
   &gt; 针对于数组中元素的删除、插入操作，性能较差。
</code></pre><h3 id="2-集合框架概述"><a class="anchor" href="#2-集合框架概述">#</a> 2. 集合框架概述</h3><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231112105809219.png" alt="集合框架概述"></p><pre><code>java.util.Collection:存储一个一个的数据
    |-----子接口：List:存储有序的、可重复的数据 (&quot;动态&quot;数组)
           |---- ArrayList(主要实现类)、LinkedList、Vector

    |-----子接口：Set:存储无序的、不可重复的数据(高中学习的集合)
           |---- HashSet(主要实现类)、LinkedHashSet、TreeSet


java.util.Map:存储一对一对的数据(key-value键值对，(x1,y1)、(x2,y2) --&gt; y=f(x),类似于高中的函数)
    |---- HashMap(主要实现类)、LinkedHashMap、TreeMap、Hashtable、Properties
</code></pre><pre><code>学习的程度把握：
层次1：针对于具体特点的多个数据，知道选择相应的适合的接口的主要实现类，会实例化，会调用常用的方法。
层次2：区分接口中不同的实现类的区别。
*****************
层次3：① 针对于常用的实现类，需要熟悉底层的源码 ② 熟悉常见的数据结构 （第14章讲）
</code></pre><h3 id="3-collection的常用方法"><a class="anchor" href="#3-collection的常用方法">#</a> 3. Collection 的常用方法</h3><h4 id="31-常用方法"><a class="anchor" href="#31-常用方法">#</a> 3.1 常用方法</h4><pre><code>add(Object obj)
addAll(Collection coll)
clear()
isEmpty()
size()
contains(Object obj)
containsAll(Collection coll)
retainAll(Collection coll)
remove(Object obj)
removeAll(Collection coll)
hashCode()
equals()
toArray()
**************
iterator() ---&gt; 引出了迭代器接口
</code></pre><pre><code>向Collection中添加元素的要求：
&gt; 要求元素所属的类一定要重写equals()!
</code></pre><pre><code>集合与数组的相互转换：
集合 ---&gt; 数组：toArray()
数组 ---&gt; 集合：调用Arrays的静态方法asList(Object ... objs)，返回一个List
</code></pre><h4 id="32-迭代器接口"><a class="anchor" href="#32-迭代器接口">#</a> 3.2 迭代器接口</h4><ul><li>设计模式的一种</li><li>迭代器不负责数据的存储；负责对集合类的遍历</li></ul><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token number">1.</span> 如何获取迭代器<span class="token punctuation">(</span><span class="token class-name">Iterator</span><span class="token punctuation">)</span>对象？</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name">Iterator</span> iterator <span class="token operator">=</span> coll<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token number">2.</span> 如何实现遍历<span class="token punctuation">(</span>代码实现<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">while</span><span class="token punctuation">(</span>iterator<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>iterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//next ():①指针下移 ② 将下移以后集合位置上的元素返回</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id="4-collection的子接口list"><a class="anchor" href="#4-collection的子接口list">#</a> 4. Collection 的子接口：List</h3><img data-src="https://gitee.com/jayhee/picture-bed/raw/master/img/image-20220407203244029.png" alt="image-20220407203244029" style="zoom:67%"><table><thead><tr><th style="text-align:center">List 接口的实现类</th><th style="text-align:center"><em>ArrayList</em></th><th style="text-align:center">LinkedList</th><th style="text-align:center"><s>Vector</s></th></tr></thead><tbody><tr><td style="text-align:center">地位</td><td style="text-align:center">主要实现类</td><td style="text-align:center"></td><td style="text-align:center">古老实现类</td></tr><tr><td style="text-align:center">底层实现</td><td style="text-align:center">Object 数组，但可以扩容</td><td style="text-align:center"><font color="red">双向链表</font></td><td style="text-align:center">Object 数组</td></tr><tr><td style="text-align:center">特点</td><td style="text-align:center">线程不安全、效率高</td><td style="text-align:center">线程不安全</td><td style="text-align:center"><font color="red">线程安全</font>、效率低</td></tr><tr><td style="text-align:center">使用场景</td><td style="text-align:center"><font color="red">频繁追加、查找数据</font></td><td style="text-align:center"><font color="red">频繁插入、删除数据</font></td><td style="text-align:center">避免使用</td></tr><tr><td style="text-align:center">说明</td><td style="text-align:center">对于频繁访问列表中的某一个元素，只需要在列表末尾进行添加和删除元素操作的情况下</td><td style="text-align:center">元素是通过指针相互连接的，在插入 / 删除元素时，只需要改动前后元素的指针即可</td><td style="text-align:center"></td></tr></tbody></table><ul><li>常用方法</li></ul><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre>小结：</pre></td></tr><tr><td data-num="2"></td><td><pre>    增</pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">Object</span> obj<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token function">addAll</span><span class="token punctuation">(</span><span class="token class-name">Collection</span> coll<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    删</pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token function">remove</span><span class="token punctuation">(</span><span class="token class-name">Object</span> obj<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token function">remove</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    改</pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span> <span class="token class-name">Object</span> ele<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    查</pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    插</pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span> <span class="token class-name">Object</span> ele<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token function">addAll</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span> <span class="token class-name">Collection</span> eles<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    长度</pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    遍历</pre></td></tr><tr><td data-num="18"></td><td><pre>        <span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> ：使用迭代器进行遍历</pre></td></tr><tr><td data-num="19"></td><td><pre>        增强<span class="token keyword">for</span>循环</pre></td></tr><tr><td data-num="20"></td><td><pre>        一般的<span class="token keyword">for</span>循环</pre></td></tr></table></figure><pre><code>List及其实现类特点
java.util.Collection:存储一个一个的数据
    |-----子接口：List:存储有序的、可重复的数据 (&quot;动态&quot;数组)
           |---- ArrayList:List的主要实现类；线程不安全的、效率高；底层使用Object[]数组存储
                           在添加数据、查找数据时，效率较高；在插入、删除数据时，效率较低
           |---- LinkedList:底层使用双向链表的方式进行存储；在对集合中的数据进行频繁的删除、插入操作时，建议							使用此类在插入、删除数据时，效率较高；在添加数据、查找数据时，效率较低；
           |---- Vector:List的古老实现类；线程安全的、效率低；底层使用Object[]数组存储

[面试题] ArrayList、Vector的区别？  ArrayList、LinkedList的区别？
</code></pre><h3 id="5-collection的子接口set"><a class="anchor" href="#5-collection的子接口set">#</a> 5. Collection 的子接口：Set</h3><img data-src="https://gitee.com/jayhee/picture-bed/raw/master/img/image-20220407203244029.png" alt="image-20220407203244029" style="zoom:67%"><table><thead><tr><th style="text-align:center">Set 接口的实现类</th><th style="text-align:center"><em>HashSet</em></th><th style="text-align:center">LinkedHashSet</th><th style="text-align:center">TreeSet</th></tr></thead><tbody><tr><td style="text-align:center">地位</td><td style="text-align:center">主要实现类</td><td style="text-align:center">HashSet 的子类</td><td style="text-align:center">了解即可</td></tr><tr><td style="text-align:center">底层实现（存储在 key 中）</td><td style="text-align:center">HashMap</td><td style="text-align:center">LinkedHashMap</td><td style="text-align:center">TreeMap</td></tr><tr><td style="text-align:center">数据结构</td><td style="text-align:center">数组 + 单向链表 + 红黑树</td><td style="text-align:center">数组 + 单向链表 + 红黑树 + <font color="red">双向链表</font></td><td style="text-align:center">红黑树</td></tr><tr><td style="text-align:center">对添加的元素的要求</td><td style="text-align:center">所在类要<font color="orange">重写 <code>equals()</code> 和 <code>hashCode()</code> </font>，同时要求二者保持一致性</td><td style="text-align:center">与 HashSet 相同</td><td style="text-align:center"><font color="red"><strong>属于同一个类</strong></font>，且要求<font color="orange">该类实现 <code>Comparable接口</code> 并重写 <code>compareTo(Object obj)</code> ，或者定义一个 <code>Comparator接口</code> 的实现类实例，并重写 <code>compare(Object o1,Object o2)</code> ，将实例作为参数传递给 TreeSet 的构造器</font></td></tr><tr><td style="text-align:center">遍历顺序</td><td style="text-align:center">与添加顺序不同</td><td style="text-align:center">与添加顺序相同（得益于双向链表）</td><td style="text-align:center"><font color="red">按照指定属性的大小顺序</font></td></tr><tr><td style="text-align:center">判断两个元素相等的标准</td><td style="text-align:center"><font color="red"><code>hashCode()</code> 返回的哈希值相等，且 <code>equals()</code> 返回 true</font></td><td style="text-align:center">与 HashSet 相同</td><td style="text-align:center">两个对象通过 <font color="red"><code>compareTo(Object obj) 或compare(Object o1,Object o2)</code> 方法的返回值为 0</font></td></tr><tr><td style="text-align:center">特点</td><td style="text-align:center"><font color="red">线程不安全</font>，元素可以是 null</td><td style="text-align:center"><font color="red"><code>插入性能略低</code> 于 HashSet，但在 <code>迭代访问</code> Set 里的全部元素时有很好的性能</font></td><td style="text-align:center">可以实现<font color="red">自然排序、定制排序</font></td></tr></tbody></table><ul><li>Set 中的常用的方法都是 Collection 中声明的方法，<font color="red">没有新增的方法</font></li><li>常见的实现类的对比</li></ul><pre><code>java.util.Collection:存储一个一个的数据
    |-----子接口：Set:存储无序的、不可重复的数据(高中学习的集合)
           |---- HashSet：主要实现类；底层使用的是HashMap，即使用数组+单向链表+红黑树结构进行存储。（jdk8中）
                |---- LinkedHashSet：是HashSet的子类；在现有的数组+单向链表+红黑树结构的基础上，又添加了
                                     一组双向链表，用于记录添加元素的先后顺序。即：我们可以按照添加元素的顺									序实现遍历。便于频繁的查询操作。
           |---- TreeSet：底层使用红黑树存储。可以按照添加的元素的指定的属性的大小顺序进行遍历。
</code></pre><ul><li>难点： Set 中无序性、不可重复性的理解（以 HashSet 及其子类为例说明）</li></ul><pre><code>&gt;无序性： != 随机性。
         添加元素的顺序和遍历元素的顺序不一致,是不是就是无序性呢？ No!
         到底什么是无序性？与添加的元素的位置有关，不像ArrayList一样是依次紧密排列的。
         这里是根据添加的元素的哈希值，计算的其在数组中的存储位置。此位置不是依次排列的，表现为无序性。

&gt;不可重复性：添加到Set中的元素是不能相同的。
          比较的标准，需要判断hashCode()得到的哈希值以及equals()得到的boolean型的结果。
          哈希值相同且equals()返回true，则认为元素是相同的。
</code></pre><pre><code>添加到HashSet/LinkedHashSet中元素的要求:
&gt;要求元素所在的类要重写两个方法：equals() 和 hashCode()。
&gt;同时，要求equals() 和 hashCode()要保持一致性！我们只需要在IDEA中自动生成两个方法的重写即可，即能保证两个方法的一致性。
</code></pre><ul><li>了解 TreeSet 的使用</li></ul><h3 id="6-map接口"><a class="anchor" href="#6-map接口">#</a> 6. Map 接口</h3><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230402211251010.png" alt="image-20230402211251010"></p><table><thead><tr><th style="text-align:center">Map 接口的实现类</th><th style="text-align:center"><em>HashMap</em></th><th style="text-align:center">LinkedHashMap</th><th style="text-align:center">TreeMap</th><th style="text-align:center"><s>Hashtable</s></th><th style="text-align:center">Properties</th></tr></thead><tbody><tr><td style="text-align:center">地位</td><td style="text-align:center">主要实现类</td><td style="text-align:center">HashMap 的子类</td><td style="text-align:center"></td><td style="text-align:center">古老实现类</td><td style="text-align:center"><s>Hashtable</s> 的子类</td></tr><tr><td style="text-align:center">底层实现</td><td style="text-align:center">哈希表</td><td style="text-align:center">哈希表 + <font color="red">双向链表</font></td><td style="text-align:center">红黑树</td><td style="text-align:center">哈希表</td><td style="text-align:center">哈希表</td></tr><tr><td style="text-align:center">数据结构</td><td style="text-align:center">一维数组 + 单向链表（+ 红黑树）</td><td style="text-align:center">一维数组 + 单向链表（+ 红黑树） + <font color="red">双向链表</font></td><td style="text-align:center">红黑树</td><td style="text-align:center">一维数组 + 单向链表</td><td style="text-align:center">一维数组 + 单向链表</td></tr><tr><td style="text-align:center">键、值是否允许为 null</td><td style="text-align:center">是</td><td style="text-align:center">是</td><td style="text-align:center"><font color="red">键不能为 null</font>，值可以为 null</td><td style="text-align:center">键和值都不能为 null</td><td style="text-align:center">键和值都不能为 null</td></tr><tr><td style="text-align:center">是否线程安全</td><td style="text-align:center">否</td><td style="text-align:center">否</td><td style="text-align:center">否</td><td style="text-align:center"><font color="red">是，因此效率低</font></td><td style="text-align:center"><font color="red">是，因此效率低</font></td></tr><tr><td style="text-align:center">特点</td><td style="text-align:center">查找、插入、删除速度快，但不保证元素的顺序</td><td style="text-align:center">保证元素的<font color="red">插入 / 访问顺序</font></td><td style="text-align:center"><font color="red">可以按照<strong> key 中的指定属性</strong>的大小顺序进行遍历</font>：①自然排序；②定制排序</td><td style="text-align:center"><font color="red">线程安全</font>，效率低</td><td style="text-align:center"><font color="red">键和值都是 String 类型</font></td></tr><tr><td style="text-align:center">性能</td><td style="text-align:center">①<font color="red">查找、插入、删除速度快</font>；②迭代遍历速度慢（因为和容量有关，需要遍历底层数组，以及每个数组元素对应的链表 / 红黑树，数组的长度就是 HashMap 的容量）</td><td style="text-align:center">①<font color="red">插入、删除速度慢</font>；②迭代遍历比 HashMap 快（因为只和实际数据有关，和容量无关）</td><td style="text-align:center">查找、插入、删除速度慢（<font color="red">因为要维护红黑树的平衡、顺序</font>）</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">内存</td><td style="text-align:center">占用大，保存数组</td><td style="text-align:center"></td><td style="text-align:center">占用小，保存节点</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">使用场景</td><td style="text-align:center">快速的查找和插入，不要求元素的顺序</td><td style="text-align:center">需要保持元素的插入顺序或者访问顺序</td><td style="text-align:center">适用于需要<font color="red">有序</font>的键值对集合</td><td style="text-align:center">适用于需要线程安全的场景</td><td style="text-align:center">以键值对的方式存储<font color="red">配置信息</font></td></tr><tr><td style="text-align:center">补充说明</td><td style="text-align:center"><font color="red">在 JDK8 引入红黑树</font></td><td style="text-align:center">双向链表: <font color="red">记录元素的添加顺序</font></td><td style="text-align:center"><font color="red">①自然排序</font>（key 所在类实现了 Comparable 接口）；<font color="red">②定制排序</font>（在创建 TreeMap 时传入 Comparator 对象）；</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">要求 key</td><td style="text-align:center"><font color="red">key 所在类要重写 <code>hashCode()</code> 和 <code>equals()</code></font></td><td style="text-align:center">与 HashMap 相同</td><td style="text-align:center"><font color="red">key 必须是同一个类的对象</font></td><td style="text-align:center">与 HashMap 相同</td><td style="text-align:center">key 是 String 类</td></tr><tr><td style="text-align:center">要求 value</td><td style="text-align:center"><font color="red">value 所在类要重写 <code>equals()</code></font></td><td style="text-align:center">与 HashMap 相同</td><td style="text-align:center">无</td><td style="text-align:center">与 HashMap 相同</td><td style="text-align:center">value 是 String 类</td></tr></tbody></table><ul><li>常用的方法</li></ul><pre><code>增：
    put(Object key,Object value)
    putAll(Map m)
删：
    Object remove(Object key)
改：
    put(Object key,Object value)
    putAll(Map m)
查：
    Object get(Object key)
长度：
    size()
遍历：
   遍历key集：Set keySet()
   遍历value集：Collection values()
   遍历entry集：Set entrySet()
</code></pre><ul><li>常用的实现类</li></ul><pre><code>java.util.Map:存储一对一对的数据(key-value键值对，(x1,y1)、(x2,y2) --&gt; y=f(x),类似于高中的函数)
    |---- HashMap:主要实现类;线程不安全的，效率高;可以添加null的key和value值;底层使用数组+单向链表+红黑树结构存储（jdk8）
        |---- LinkedHashMap:是HashMap的子类；在HashMap使用的数据结构的基础上，增加了一对双向链表，用于记录添加的元素的先后顺序，进而我们在遍历元素时，就可以按照添加的顺序显示。开发中，对于频繁的遍历操作，建议使用此类。
    |---- TreeMap:底层使用红黑树存储;可以按照添加的key-value中的key元素的指定的属性的大小顺序进行遍历。需要考虑使用①自然排序 ②定制排序。
    |---- Hashtable:古老实现类;线程安全的，效率低;不可以添加null的key或value值;底层使用数组+单向链表结构存储（jdk8）
        |---- Properties:其key和value都是String类型。常用来处理属性文件。


[面试题] 区别HashMap和Hashtable、区别HashMap和LinkedHashMap、HashMap的底层实现（① new HashMap() ② put(key,value)）
</code></pre><pre><code>HashMap中元素的特点:
&gt; HashMap中的所有的key彼此之间是不可重复的、无序的。所有的key就构成一个Set集合。---&gt;key所在的类要重写hashCode()和equals()
&gt; HashMap中的所有的value彼此之间是可重复的、无序的。所有的value就构成一个Collection集合。---&gt;value所在的类要重写equals()
&gt; HashMap中的一个key-value,就构成了一个entry。
&gt; HashMap中的所有的entry彼此之间是不可重复的、无序的。所有的entry就构成了一个Set集合。
</code></pre><ul><li><p>（了解）TreeMap 的使用</p></li><li><p>（重要）Properties 的使用</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PropertiesTest</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token annotation punctuation">@Test</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 注意：因为设计到流的操作，为了确保流能关闭，建议使用 try-catch-finally</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token comment">// 方式 1：数据和代码耦合度高；如果修改的话，需要重写的编译代码、打包发布，繁琐</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token comment">// 数据</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token comment">//        String name = "Tom";</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token comment">//        String password = "abc123";</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token comment">// 代码：用于操作 name,password</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token comment">//...</span></pre></td></tr><tr><td data-num="11"></td><td><pre></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token comment">// 方式 2：将数据封装到具体的配置文件中，在程序中读取配置文件中的信息。实现了</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token comment">// 数据和代码的解耦；由于我们没有修改代码，就省去了重新编译和打包的过程。</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token class-name">File</span> file <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span><span class="token string">"info.properties"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 注意，要提前创建好</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token comment">//        System.out.println(file.getAbsolutePath());</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token class-name">FileInputStream</span> fis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre></pre></td></tr><tr><td data-num="18"></td><td><pre>        <span class="token class-name">Properties</span> pros <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Properties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>        pros<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>fis<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 加载流中的文件中的数据</span></pre></td></tr><tr><td data-num="20"></td><td><pre></pre></td></tr><tr><td data-num="21"></td><td><pre>        <span class="token comment">// 读取数据</span></pre></td></tr><tr><td data-num="22"></td><td><pre>        <span class="token class-name">String</span> name <span class="token operator">=</span> pros<span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>        <span class="token class-name">String</span> pwd <span class="token operator">=</span> pros<span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token string">"password"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre></pre></td></tr><tr><td data-num="25"></td><td><pre>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>name <span class="token operator">+</span> <span class="token string">":"</span> <span class="token operator">+</span> pwd<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre></pre></td></tr><tr><td data-num="27"></td><td><pre>        fis<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="29"></td><td><pre></pre></td></tr><tr><td data-num="30"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure></li></ul><h3 id="7-collections工具类的使用"><a class="anchor" href="#7-collections工具类的使用">#</a> 7. Collections 工具类的使用</h3><pre><code>区分Collection 和 Collections
Collection：集合框架中的用于存储一个一个元素的接口，又分为List和Set等子接口。
Collections：用于操作集合框架的一个工具类。此时的集合框架包括：Set、List、Map
</code></pre><ul><li>熟悉常用的 Collections 中的方法即可。</li></ul><h2 id="二-企业真题"><a class="anchor" href="#二-企业真题">#</a> 二、企业真题</h2><h3 id="21-集合概述"><a class="anchor" href="#21-集合概述">#</a> 2.1 集合概述</h3><h4 id="1-listsetmap是否继承自collection接口北京中译咨询-思贸易"><a class="anchor" href="#1-listsetmap是否继承自collection接口北京中译咨询-思贸易">#</a> 1. List，Set，Map 是否继承自 collection 接口？（北京中 * 译咨询、思 * 贸易）</h4><p>Map 不是。</p><h4 id="2-说说listsetmap的区别民银行"><a class="anchor" href="#2-说说listsetmap的区别民银行">#</a> 2. 说说 List,Set,Map 的区别 (民 * 银行)</h4><pre><code>类似问题：
&gt; Map与Set、List的区别（纬*）
</code></pre><p>List、Set 是存储<font color="red">单列数据</font>集合，都继承与 Collection 接口。Map 是存储<font color="red">键值对</font>这样的<font color="red">双列数据</font>的集合，是个独立接口。</p><p>List 中存储的数据是有序的，可以是重复的。</p><p>Set 中存储的数据是无序的，且不允许重复。</p><p>Map 中存储的数据是无序的，他的键是不允许重复的，值是可以重复的。</p><h4 id="3-写出list-map-set接口的实现类并说出其特点华为"><a class="anchor" href="#3-写出list-map-set接口的实现类并说出其特点华为">#</a> 3. <mark>写出 list、map、set 接口的实现类，并说出其特点</mark>（华 ** 为）</h4><pre><code>类似问题：
&gt; 集合有哪些， 各自有哪些特点， 各自的API有哪些？（湖**利软件）
&gt; List Map Set三个接口在存储元素时个有什么特点（*软）
</code></pre><ul><li>List 接口的实现类<ul><li>ArrayList<ul><li>动态数组，可扩容的 Object 数组</li><li>支持随机访问元素，适用于频繁访问元素的场景</li><li>插入和删除操作效率较低</li></ul></li><li>LinkedList<ul><li>双向链表</li><li>随机访问元素效率较低</li><li>支持快速的插入和删除操作，适用于频繁插入和删除元素的场景</li></ul></li><li><s>Vector</s><ul><li>与 ArrayList 类似，底层也是可扩容的 Object 数组</li><li>线程安全，支持同步访问，也因此效率低，不适用于高并发场景</li></ul></li></ul></li><li>Set 接口的实现类<ul><li>HashSet<ul><li>哈希表</li><li>不保证元素的顺序</li></ul></li><li>LinkedHashSet<ul><li>哈希表 + 双向链表</li><li>保证元素有序</li></ul></li><li>TreeSet<ul><li>红黑树</li><li>要求元素属于同一个类</li><li>可以按照指定属性的大小顺序进行遍历</li><li>可以实现自然排序 / 定制排序</li></ul></li></ul></li><li>Map 接口的实现类<ul><li>HashMap<ul><li>哈希表</li><li>快速的查找和插入，不保证元素的顺序</li></ul></li><li>LinkedHashMap<ul><li>哈希表 + 双向链表</li><li>保证元素有序</li></ul></li><li>TreeMap<ul><li>红黑树</li><li>要求 key 都属于同一个类</li><li>可以按照<strong> key 中的指定属性</strong>的大小顺序进行遍历</li><li>适用于需要<font color="red">有序</font>的键值对集合</li></ul></li><li>Hashtable<ul><li>哈希表</li><li>线程安全</li></ul></li><li>Properties<ul><li>哈希表</li><li><font color="red">键和值都是 String 类型</font></li><li>适用于以键值对的方式存储<font color="red">配置信息</font></li></ul></li></ul></li></ul><h4 id="4-常见集合类的区别和适用场景饿"><a class="anchor" href="#4-常见集合类的区别和适用场景饿">#</a> 4. <mark>常见集合类的区别和适用场景</mark>（饿 **）</h4><p>Java 中常见的集合类有 List、Set、Map。</p><p>区别（元素特点）：</p><ul><li>List 中的元素是有序，可重复的；</li><li>Set 中的元素是无序，不可重复的；</li><li>Map 是由键值对组成的，键不可以重复，值可以重复。</li></ul><p>区别（实现类的底层数据结构）：</p><ul><li><p>List 的实现类</p><ul><li>ArrayList 是一个动态数组</li><li>LinkedList 是一个双向链表</li><li>Vector 是一个线程安全的动态数组</li></ul></li><li><p>Set 的实现类</p><ul><li>HashSet 是基于哈希表实现的</li><li>LinkedHashSet 是基于哈希表、双向链表实现的</li><li>TreeSet 是基于红黑树实现的</li></ul></li><li><p>Map 的实现类</p><ul><li>HashMap 是基于哈希表实现的</li><li>LinkedHashMap 是基于哈希表、双向链表实现的</li><li>TreeMap 是基于红黑树实现的</li></ul></li></ul><p>适用场景：</p><ul><li><p>List</p><ul><li>ArrayList：需要<font color="red">频繁访问元素</font>时使用</li><li>LinkedList：需要<font color="red">频繁插入或删除元素</font>时使用</li><li>Vector：需要<font color="red">线程安全</font>时使用</li></ul></li><li><p>Set</p><ul><li>HashSet：需要<font color="red">去重</font>时使用，不保证元素的顺序</li><li>TreeSet：需要<font color="red">排序</font>时使用</li></ul></li><li><p>Map</p><ul><li>HashMap：需要<font color="red">快速的查找和插入</font>，不要求元素的顺序时使用</li><li>LinkedHashMap：需要<font color="red">保证键值对元素的顺序</font>时使用</li><li>TreeMap：需要<font color="red">排序</font>时使用</li></ul></li></ul><h4 id="5-集合的父类是谁哪些安全的北京中信"><a class="anchor" href="#5-集合的父类是谁哪些安全的北京中信">#</a> 5. <mark>集合的父类是谁？哪些安全的？</mark>（北京中 ** 信）</h4><p>Collection、List、Set、Map 都是接口，不是类。</p><p>（线程）不安全：ArrayList、HashSet、HashMap</p><blockquote><p>这些都是常用的，当需要线程安全时，调用 Collections 工具类中的同步方法对集合进行包装</p></blockquote><p>（线程） 安全：Vector、Hashtable</p><blockquote><p>反而不常用，因为效率低</p></blockquote><h4 id="6-集合说一下哪些是线程不安全的科软"><a class="anchor" href="#6-集合说一下哪些是线程不安全的科软">#</a> 6. 集合说一下哪些是线程不安全的（* 科软）</h4><p>除了 Vector 和 Hashtable。</p><h4 id="7-遍历集合的方式有哪些恒电子"><a class="anchor" href="#7-遍历集合的方式有哪些恒电子">#</a> 7. 遍历集合的方式有哪些？（恒 * 电子）</h4><ul><li><p>迭代器 Iterator 用来遍历 Collection，不能用来遍历 Map！</p><blockquote><p><code>map.keySet().iterator()</code> 、 <code>map.values().iterator()</code> 、 <code>map.entrySet().iterator()</code> 本质上都是迭代器对 Set、Collection 进行遍历</p></blockquote></li><li><p>增强 for</p><blockquote><p>for (Object obj : 集合对象)</p></blockquote></li><li><p>一般的 for：可以用来遍历 List</p></li></ul><h3 id="22-list接口"><a class="anchor" href="#22-list接口">#</a> 2.2 List 接口</h3><h4 id="1-list下面有哪些实现软力"><a class="anchor" href="#1-list下面有哪些实现软力">#</a> 1. List 下面有哪些实现（软 ** 力）</h4><p>ArrayList、LinkedList、Vector</p><h4 id="2-arraylist与linkedlist区别oo-滴-汇天下-拓软件-博纳软件-上海进天下北京永生信息-联-在途游"><a class="anchor" href="#2-arraylist与linkedlist区别oo-滴-汇天下-拓软件-博纳软件-上海进天下北京永生信息-联-在途游">#</a> 2. <mark>ArrayList 与 LinkedList 区别</mark>？(O**O、滴 *、汇 * 天下、拓 * 软件、博纳 ** 软件、上海 * 进天下，北京永生 ** 信息、* 联、在 * 途游)</h4><pre><code>类似问题：
&gt; ArrayList跟LinkedList的区别详细说出？（阿*校招、*东）
</code></pre><p>ArrayList 和 LinkedList 的区别如下：</p><ul><li>ArrayList 是基于<font color="red">动态数组</font>实现的，而 LinkedList 是基于<font color="red">双向链表</font>实现的。</li><li><font color="red">对于随机访问 get 和 set，ArrayList 更快</font>，因为 ArrayList 可以根据<strong>下标</strong>以 O (1) 时间复杂度对元素进行随机访问；而 LinkedList 需要<strong>移动指针遍历</strong>每个元素直到找到为止。</li><li><font color="red">对于新增和删除操作 add 和 remove，LinkedList 更快</font>，因为 ArrayList 在新增和删除元素时，可能需要<strong>扩容和复制数组</strong>；而 LinkedList 除了<strong>实例化对象</strong>需要时间外，只需要<strong>修改指针</strong>即可。</li></ul><p>补充上第 14 章中的源码（底层的数据结构）</p><h4 id="3-arraylist与vector区别呢为什么要用arraylist取代vector呢湖利软件"><a class="anchor" href="#3-arraylist与vector区别呢为什么要用arraylist取代vector呢湖利软件">#</a> 3. ==ArrayList 与 Vector 区别呢？== 为什么要用 ArrayList 取代 Vector 呢？(湖 ** 利软件)</h4><p>ArrayList 和 Vector 的区别如下：</p><ul><li>ArrayList 不是同步的，而<font color="red">Vector 是线程安全的</font>，也就是说是同步的。</li><li><font color="red">ArrayList 在性能方面更优</font>，因为 ArrayList 没有使用 synchronized 加锁，不加锁，所以处理速度会快一些。</li><li>扩容：ArrayList 和 Vector 都会根据实际的需要动态的调整容量，只不过在<font color="red">Vector 扩容每次会增加 1 倍，而 ArrayList 只会增加 50%</font>。</li></ul><p>因此，如果不需要线程安全的话，建议使用 ArrayList。</p><h4 id="4-javautilarraylist常用的方法有哪些华为"><a class="anchor" href="#4-javautilarraylist常用的方法有哪些华为">#</a> 4. Java.util.ArrayList 常用的方法有哪些？（华 ** 为）</h4><ul><li>Collection 接口中的方法</li><li><font color="gree">List 接口中的方法</font></li><li><font color="purple">ArrayList 类特有的方法</font></li></ul><p>例如：</p><ul><li>增<ul><li>add (E obj)：在列表的<font color="red">末尾</font>添加指定元素</li><li>addAll(Collection other)</li></ul></li><li>删<ul><li>clear()</li><li>remove (Object obj)：移除列表中<font color="red">首次出现</font>的指定元素，如果存在，返回 true，否则返回 false</li><li>removeAll(Collection coll)</li><li>retainAll(Collection coll)</li><li><font color="gree"><strong>remove</strong>(int index)</font></li></ul></li><li>改<ul><li><font color="gree"><strong>set</strong>(int index, Object ele)</font></li></ul></li><li>查<ul><li><font color="gree"><strong>get</strong>(int index)</font></li><li><font color="gree">subList(int fromIndex, int toIndex):</font></li><li><font color="gree">indexOf(Object obj)</font></li><li><font color="gree">lastIndexOf(Object obj)</font></li></ul></li><li>插<ul><li><font color="gree"><strong>add</strong>(int index, Object ele)</font></li><li><font color="gree">addAll(int index, Collection eles)</font></li></ul></li><li>长度<ul><li>size ()：返回列表中<font color="red">实际存储的元素个数</font></li></ul></li><li>遍历<ul><li>iterator()</li><li>增强 for 循环</li><li>普通 for 循环</li></ul></li><li>其他<ul><li>isEmpty()</li><li>contains(Object obj)</li><li>containsAll(Collection coll)</li><li>equals(Object obj)</li><li>toArray()</li><li>hashCode()</li></ul></li><li>ArrayList 类特有<ul><li><font color="purple">ensureCapacity(int minCapacity)</font>：确保列表的容量至少等于指定的最小值</li><li><font color="purple">trimToSize()</font>：将列表的容量调整为列表的当前大小</li><li><font color="purple">clone()</font>：返回一个 ArrayList 对象的浅拷贝</li></ul></li></ul><h4 id="5-arraylist-是有序还是无序为什么蜜信息"><a class="anchor" href="#5-arraylist-是有序还是无序为什么蜜信息">#</a> 5. Arraylist 是有序还是无序？为什么？（蜜 * 信息）</h4><p>有序；底层使用数组：Object []</p><h3 id="23-set接口"><a class="anchor" href="#23-set接口">#</a> 2.3 Set 接口</h3><h4 id="1set集合有哪些实现类分别有什么特点拓软件"><a class="anchor" href="#1set集合有哪些实现类分别有什么特点拓软件">#</a> 1.<mark>Set 集合有哪些实现类，分别有什么特点？</mark>（拓 * 软件）</h4><pre><code>类似问题：
&gt; Set的实现类有哪些？（博*科技）
</code></pre><ul><li><p>HashSet</p><ul><li>主要实现类</li><li>基于哈希表</li><li>存取速度快</li><li>不保证元素的顺序</li><li>允许 null</li></ul></li><li><p>LinkedHashSet</p><ul><li><p>HashSet 的子类</p></li><li><p>基于哈希表 + <font color="red">双向链表</font></p></li><li><p>记录了元素的添加顺序，便于频繁查询</p></li><li><p><font color="red"><code>插入性能略低</code> 于 HashSet，但 <code>迭代访问性能</code> 优于 HashSet</font></p><blockquote><p>LinkedHashSet 的插入性能低于 HashSet，是因为 LinkedHashSet 除了维护一个哈希表外，还要维护一个双向链表来记录元素的插入顺序 ²³。这样<font color="red">在插入元素时，需要额外的操作来<strong>更新链表的指针</strong>，而 HashSet 不需要这样做</font>¹²。</p><p>LinkedHashSet 的迭代性能优于 HashSet，是因为<font color="red">LinkedHashSet 可以直接<strong>按照链表的顺序来遍历元素</strong>，而不需要对哈希表进行排序或者查找</font>²⁴。而<font color="red">HashSet 在遍历时，需要<strong>根据哈希值来确定元素的位置</strong>，可能会遇到哈希冲突或者空桶的情况，导致性能下降</font>¹²。</p></blockquote></li></ul></li><li><p>TreeSet</p><ul><li>基于红黑树</li><li>要求元素属于同一个类，不允许 null</li><li>可以按照元素的指定属性的大小顺序进行排序（自然排序 / 定制排序）</li></ul></li></ul><h4 id="2-list集合和set集合的区别亚科技-海翼科技华电系统达贷"><a class="anchor" href="#2-list集合和set集合的区别亚科技-海翼科技华电系统达贷">#</a> 2. <mark>List 集合和 Set 集合的区别？</mark>（亚 * 科技、* 海 * 翼科技，* 华电 * 系统，达 * 贷）</h4><p>List 集合和 Set 集合的区别有以下几点 ¹²：</p><ul><li><font color="red">List 集合<strong>是有序的</strong></font>，可以按照元素的插入顺序（LinkedList）或者指定的索引（ArrayList）来访问元素，而<font color="red">Set 集合是无序的</font>，不能通过索引来访问元素 ¹²。</li><li><font color="red">List 集合<strong>可以包含重复的元素</strong>，也可以包含多个 null 元素</font>，而<font color="red">Set 集合不允许包含重复的元素，最多只能包含一个 null 元素</font>¹²。</li><li><font color="red">List 集合继承了 Collection 接口，并提供了一些<strong>额外的方法</strong></font>，如 get (int index), set (int index, E element), add (int index, E element), remove (int index) 等，而<font color="red">Set 集合没有提供这些方法</font>¹²。</li><li><font color="red">List 集合的<strong>实现类</strong>有 ArrayList, LinkedList 和 Vector</font>，而<font color="red">Set 集合的实现类有 HashSet, LinkedHashSet 和 TreeSet</font>¹²。</li></ul><h4 id="3-set里的元素是不能重复的那么用什么方法来区分重复与否呢-是用还是equals-它们有何区别鸿网络"><a class="anchor" href="#3-set里的元素是不能重复的那么用什么方法来区分重复与否呢-是用还是equals-它们有何区别鸿网络">#</a> 3. <mark>Set 里的元素是不能重复的，那么用什么方法来区分重复与否呢？是用</mark>还是 equals ()? 它们有何区别？==（鸿 * 网络）</h4><pre><code>类似问题：
&gt; 1.HashSet如何检查重复(创*科技)
&gt; 3.Set使用哪个区分不能重复的元素的？（北京创**荣信息）
</code></pre><p>Set 里的元素是不能重复的，它是通过调用元素的<font color="orange"> <code>equals()</code> 和 <code>hashCode()</code> </font>方法来判断两个元素是否相等的 ¹²。<font color="red">如果两个元素的 equals () 方法返回 true，并且它们的 hashCode () 方法返回相同的值，那么它们就被认为是相等的</font>，Set 就不会存储重复的元素 ¹²。</p><p><code>==</code> 和 <code>equals()</code> 都是用来比较两个对象是否相等的，但它们有以下区别 ³：</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">==</th><th style="text-align:center">equals()</th></tr></thead><tbody><tr><td style="text-align:center">比较的数据类型</td><td style="text-align:center">基本数据类型、引用数据类型</td><td style="text-align:center">引用数据类型</td></tr><tr><td style="text-align:center">对于引用数据类型</td><td style="text-align:center">比较的是内存地址，是否指向同一个对象</td><td style="text-align:center">比较的是对象的内容</td></tr><tr><td style="text-align:center">比较规则</td><td style="text-align:center">固定</td><td style="text-align:center">可以重写</td></tr></tbody></table><ul><li><font color="red"><code>==</code> 是一个运算符，它可以用来比较<u>基本数据类型</u>和<u>引用数据类型</u></font>，而<font color="red"> <code>equals()</code> 是一个方法，它只能用来比较<u>引用数据类型</u></font>。</li><li><font color="red"><code>==</code> 比较的是两个对象的<u>内存地址</u>，即它们是否指向同一个对象</font>，而<font color="red"> <code>equals()</code> 比较的是两个<u>对象的内容</u>，即它们是否逻辑上相等</font>³。</li><li><font color="red"><code>==</code> 的<u>比较规则是固定的</u></font>，而<font color="red"> <code>equals()</code> 的<u>比较规则可以根据不同的类来重写</u></font>，例如 String 类就重写了 equals () 方法，使得它可以比较两个字符串的值是否相同 ³。</li></ul><h4 id="4-treeset两种排序方式在使用的时候怎么起作用拓软件"><a class="anchor" href="#4-treeset两种排序方式在使用的时候怎么起作用拓软件">#</a> 4. TreeSet 两种排序方式在使用的时候怎么起作用？（拓 * 软件）</h4><p>在<font color="red">添加新的元素</font>时，需要<font color="red">调用 <code>compareTo()</code> 或 <code>compare()</code> </font>。</p><p><font color="red">TreeSet 是一个基于<strong>红黑树</strong>实现的<strong>有序</strong>集合，它可以按照<strong>元素中的指定属性</strong>的<u>自然排序</u>或者<u>定制排序</u>来存储和遍历元素</font>¹²。它的两种排序方式在使用的时候有以下区别：</p><ul><li>自然排序：如果元素实现了 Comparable 接口，那么 TreeSet 会调用元素的 compareTo () 方法来比较元素的大小，并按照升序排列 ¹²³。例如，String 类就实现了 Comparable 接口，它的 compareTo () 方法是按照字典顺序比较字符串的 ¹²。</li><li>指定排序：如果元素没有实现 Comparable 接口，或者想要使用不同的排序规则，那么可以在构造 TreeSet 时传入一个 Comparator 对象，它是一个比较器接口，可以自定义比较元素的方法 ¹²⁴。这种方式可以覆盖元素的自然顺序，也可以对没有自然顺序的元素进行排序 ¹²。例如，Student 类没有实现 Comparable 接口，但是可以通过传入一个 Comparator 对象来按照学号或者姓名等属性进行排序</li></ul><h4 id="5-treeset的数据结构米"><a class="anchor" href="#5-treeset的数据结构米">#</a> 5. <mark>TreeSet 的数据结构</mark>（* 米）</h4><p>TreeSet 是一个有序集合，它的内部实现是<font color="orange">基于一个红黑树的 TreeMap</font>。<font color="red">TreeMap 是一个键值对的映射，它的键是按照自然顺序或者指定的比较器顺序来排序的</font>。<font color="red">TreeSet 只使用了 TreeMap 的键，而把值设置为一个固定的常量</font>。</p><p>红黑树是一种<font color="orange">自平衡的二叉搜索树</font>，它满足以下性质：</p><p><img data-src="https://upload.wikimedia.org/wikipedia/commons/thumb/6/66/Red-black_tree_example.svg/450px-Red-black_tree_example.svg.png" alt="img"></p><ul><li>每个节点要么是红色，要么是黑色</li><li>根节点是黑色</li><li>每个叶子节点（空节点）是黑色</li><li>如果一个节点是红色，那么它的两个子节点都是黑色</li><li>从任意一个节点到其每个叶子节点的所有路径都包含相同数目的黑色节点</li></ul><p>这些性质<font color="red">保证了红黑树的高度近似于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">log(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.01968em">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:.03588em">g</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，从而使得插入、删除和查找操作的时间复杂度都是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(log(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:.01968em">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:.03588em">g</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></font>。</p><p>TreeSet 使用红黑树的意义是<font color="red">为了保证集合中的元素可以按照<strong>一定的顺序</strong>进行存储和遍历</font>，同时也为了<font color="red">提高集合中的插入、删除和查找操作的效率</font>¹²³。</p><p>TreeSet 使用红黑树的好处有以下几点 ¹²³：</p><ul><li>红黑树是一种 **<font color="red">自平衡的二叉搜索树</font>**，它<font color="red">可以保证在最坏情况下，插入、删除和查找操作的时间复杂度都是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(log(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:.01968em">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:.03588em">g</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>，而不会退化成链表或者倾斜树</font></li><li>红黑树<font color="red"><strong>可以按照元素的自然顺序或者指定的比较器顺序来排序</strong></font>，这样可以<font color="red">方便地对集合中的元素进行遍历、查找、范围查询等操作</font></li><li>红黑树<font color="red"><strong>可以利用节点的颜色信息来维持树的平衡</strong>，这样可以减少旋转和重构的次数，提高操作的性能</font></li></ul><h3 id="24-map接口"><a class="anchor" href="#24-map接口">#</a> 2.4 Map 接口</h3><h4 id="1-说一下java的集合map有哪些实现类奥医药"><a class="anchor" href="#1-说一下java的集合map有哪些实现类奥医药">#</a> 1. <mark>说一下 Java 的集合 Map 有哪些实现类？</mark>（奥 * 医药）</h4><table><thead><tr><th style="text-align:center">Map 接口的实现类</th><th style="text-align:center"><em>HashMap</em></th><th style="text-align:center">LinkedHashMap</th><th style="text-align:center">TreeMap</th><th style="text-align:center"><s>Hashtable</s></th><th style="text-align:center">Properties</th></tr></thead><tbody><tr><td style="text-align:center">地位</td><td style="text-align:center">主要实现类</td><td style="text-align:center">HashMap 的子类</td><td style="text-align:center"></td><td style="text-align:center">古老实现类</td><td style="text-align:center"><s>Hashtable</s> 的子类</td></tr><tr><td style="text-align:center">底层实现</td><td style="text-align:center">哈希表</td><td style="text-align:center">哈希表 + <font color="red">双向链表</font></td><td style="text-align:center">红黑树</td><td style="text-align:center">哈希表</td><td style="text-align:center">哈希表</td></tr><tr><td style="text-align:center">数据结构</td><td style="text-align:center">一维数组 + 单向链表（+ 红黑树）</td><td style="text-align:center">一维数组 + 单向链表（+ 红黑树） + <font color="red">双向链表</font></td><td style="text-align:center">红黑树</td><td style="text-align:center">一维数组 + 单向链表</td><td style="text-align:center">一维数组 + 单向链表</td></tr><tr><td style="text-align:center">键、值是否允许为 null</td><td style="text-align:center">是</td><td style="text-align:center">是</td><td style="text-align:center"><font color="red">键不能为 null</font>，值可以为 null</td><td style="text-align:center">键和值都不能为 null</td><td style="text-align:center">键和值都不能为 null</td></tr><tr><td style="text-align:center">是否线程安全</td><td style="text-align:center">否</td><td style="text-align:center">否</td><td style="text-align:center">否</td><td style="text-align:center"><font color="red">是，因此效率低</font></td><td style="text-align:center"><font color="red">是，因此效率低</font></td></tr><tr><td style="text-align:center">特点</td><td style="text-align:center">查找、插入、删除速度快，但不保证元素的顺序</td><td style="text-align:center">保证元素的<font color="red">插入 / 访问顺序</font></td><td style="text-align:center"><font color="red">可以按照<strong> key 中的指定属性</strong>的大小顺序进行遍历</font>：①自然排序；②定制排序</td><td style="text-align:center"><font color="red">线程安全</font>，效率低</td><td style="text-align:center"><font color="red">键和值都是 String 类型</font></td></tr><tr><td style="text-align:center">性能</td><td style="text-align:center">①<font color="red">查找、插入、删除速度快</font>；②迭代遍历速度慢（因为和容量有关，需要遍历底层数组，以及每个数组元素对应的链表 / 红黑树，数组的长度就是 HashMap 的容量）</td><td style="text-align:center">①<font color="red">插入、删除速度慢</font>；②迭代遍历比 HashMap 快（因为只和实际数据有关，和容量无关）</td><td style="text-align:center">查找、插入、删除速度慢（<font color="red">因为要维护红黑树的平衡、顺序</font>）</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">内存</td><td style="text-align:center">占用大，保存数组</td><td style="text-align:center"></td><td style="text-align:center">占用小，保存节点</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">使用场景</td><td style="text-align:center">快速的查找和插入，不要求元素的顺序</td><td style="text-align:center">需要保持元素的插入顺序或者访问顺序</td><td style="text-align:center">适用于需要<font color="red">有序</font>的键值对集合</td><td style="text-align:center">适用于需要线程安全的场景</td><td style="text-align:center">以键值对的方式存储<font color="red">配置信息</font></td></tr><tr><td style="text-align:center">补充说明</td><td style="text-align:center"><font color="red">在 JDK8 引入红黑树</font></td><td style="text-align:center">双向链表: <font color="red">记录元素的添加顺序</font></td><td style="text-align:center"><font color="red">①自然排序</font>（key 所在类实现了 Comparable 接口）；<font color="red">②定制排序</font>（在创建 TreeMap 时传入 Comparator 对象）；</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">要求 key</td><td style="text-align:center"><font color="red">key 所在类要重写 <code>hashCode()</code> 和 <code>equals()</code></font></td><td style="text-align:center">与 HashMap 相同</td><td style="text-align:center"><font color="red">key 必须是同一个类的对象</font></td><td style="text-align:center">与 HashMap 相同</td><td style="text-align:center">key 是 String 类</td></tr><tr><td style="text-align:center">要求 value</td><td style="text-align:center"><font color="red">value 所在类要重写 <code>equals()</code></font></td><td style="text-align:center">与 HashMap 相同</td><td style="text-align:center">无</td><td style="text-align:center">与 HashMap 相同</td><td style="text-align:center">value 是 String 类</td></tr></tbody></table><p>Java 的集合 Map 有以下几种常见的实现类：</p><ul><li>HashMap：基于哈希表的 Map 接口的实现，允许使用 null 键和 null 值，不保证映射的顺序，是线程不安全的，支持快速的插入、删除和查找操作</li><li>TreeMap：基于红黑树的 Map 接口的实现，按照键的自然顺序或者指定的比较器顺序来排序，不允许使用 null 键，但可以使用 null 值，是线程不安全的，支持有序的插入、删除和查找操作</li><li>LinkedHashMap：基于哈希表和双向链表的 Map 接口的实现，按照插入顺序或者访问顺序来排序，允许使用 null 键和 null 值，是线程不安全的，结合了 HashMap 的查询速度和 LinkedHashSet 的插入顺序</li><li>Hashtable：基于哈希表的 Map 接口的旧版本实现，不允许使用 null 键和 null 值，保证映射的顺序，是线程安全的，但效率低于 HashMap 和 ConcurrentHashMap</li><li>ConcurrentHashMap：基于哈希表和分段锁或者 CAS 技术的 Map 接口的实现，不允许使用 null 键和 null 值，不保证映射的顺序，是线程安全的，并发性能高于 Hashtable</li></ul><h4 id="2-final怎么用修饰map可以继续添加数据吗深蓝"><a class="anchor" href="#2-final怎么用修饰map可以继续添加数据吗深蓝">#</a> 2. <mark>final 怎么用，修饰 Map 可以继续添加数据吗？</mark>（* 深蓝）</h4><p>final 是一个关键字，可以用来修饰类、方法、变量等。final 的作用有以下几点：</p><ul><li>修饰类：表示该类不能被继承，如 String 类</li><li>修饰方法：表示该方法不能被重写，如 Object 类的 getClass () 方法</li><li>修饰变量：表示该变量是一个常量，只能被赋值一次，如 Math 类的 PI 常量</li></ul><p><font color="red">final 修饰 Map 时，表示该 Map 的引用是一个常量，不能再指向其他的对象。但是，<strong>这并不影响 Map 中的键值对的添加、删除和修改</strong>。因为 final 只保证了引用的不变性，而不保证了引用指向的对象的不变性</font>。</p><p><font color="red">如果想要让 Map 中的键值对也不能被修改，可以使用 <code>Collections.unmodifiableMap()</code> 方法来返回一个不可修改的 Map 视图</font>。</p><p>例如：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 创建一个普通的 HashMap</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">></span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &#123;a=1, b=2&#125;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token comment">// 使用 final 修饰 map 的引用</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token keyword">final</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">></span></span> finalMap <span class="token operator">=</span> map<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token comment">//finalMap = new HashMap&lt;> (); // 编译错误，不能再赋值</span></pre></td></tr><tr><td data-num="10"></td><td><pre>finalMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"c"</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 可以添加数据</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>finalMap<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &#123;a=1, b=2, c=3&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token comment">// 使用 Collections.unmodifiableMap () 返回一个不可修改的 Map 视图</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">></span></span> unmodifiableMap <span class="token operator">=</span> <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">unmodifiableMap</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token comment">//unmodifiableMap.put ("d", 4); // 运行时异常，不能添加数据</span></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>unmodifiableMap<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &#123;a=1, b=2, c=3&#125;</span></pre></td></tr></table></figure><h4 id="3-set和map的比较亚科技"><a class="anchor" href="#3-set和map的比较亚科技">#</a> 3. <mark>Set 和 Map 的比较</mark>（亚 * 科技）</h4><p>HashSet 底层就是 HashMap</p><p>LinkedHashSet 底层就是 LinkedHashMap</p><p>TreeSet 底层就是 TreeMap</p><p>Set 和 Map 是 Java 中两种不同的集合接口，它们有以下几点区别：</p><ul><li><p>元素特点</p><ul><li>Set 是一个<font color="red">不包含重复元素</font>的集合，它只存储键，而不存储值</li><li>Map 是一个键值对的映射，它存储键和值，且<font color="red">键不能重复，但值可以重复</font></li></ul></li><li><p>无序性</p><ul><li>Set 是一个无序的集合，它不保证元素的存储顺序，除非使用有序的实现类如 TreeSet 或 LinkedHashSet</li><li>Map 也是一个无序的映射，它不保证键或值的存储顺序，除非使用有序的实现类如 TreeMap 或 LinkedHashMa</li></ul></li><li><p>遍历方式</p><ul><li>Set<font color="red">可以直接遍历</font>其元素，使用 iterator () 方法或 foreach 循环</li><li>Map 不能直接遍历其元素，需要使用 keySet ()、values () 或 entrySet () 方法<font color="red">先获取其键集、值集或键值对集</font>，然后再使用 iterator () 方法或 foreach 循环遍历</li></ul></li><li><p>null</p><ul><li>Set<font color="red">最多只能存储一个 null 元素</font></li><li>Map<font color="red">最多只能有一个 null 键和任意个 null 值</font></li></ul></li><li><p>实现类的特点、用途</p><ul><li><p>Set</p><ul><li>HashSet 是基于哈希表的 Set 实现类，它提供了快速的插入和查找操作，但不保证元素的顺序</li><li>LinkedHashSet 是基于哈希表和双向链表的 Set 实现类，它按照元素的插入顺序来排序，同时也保持了 HashSet 的查询速度</li><li>TreeSet 是基于红黑树的 Set 实现类，它按照<font color="red">元素</font>的自然顺序或指定的比较器顺序来排序，但插入和查找操作较慢</li></ul></li><li><p>Map</p><ul><li>HashMap 是基于哈希表的 Map 实现类，它提供了快速的插入、删除和查找操作，但不保证键或值的顺序</li><li>LinkedHashMap 是基于哈希表和双向链表的 Map 实现类，它按照键的插入顺序或访问顺序来排序，同时也保持了 HashMap 的查询速度</li><li>TreeMap 是基于红黑树的 Map 实现类，它按照<font color="red">键</font>的自然顺序或指定的比较器顺序来排序，但插入、删除和查找操作较慢</li></ul></li></ul></li></ul><h4 id="4-介绍一下hashmap是线程安全的吗米"><a class="anchor" href="#4-介绍一下hashmap是线程安全的吗米">#</a> 4. <mark>介绍一下 HashMap，是线程安全的吗？</mark>（* 米）</h4><pre><code>类似问题：
&gt; HashMap为什么线程不安全？（微*银行）
&gt; HashMap是线程安全的吗？为什么不安全？（*团、*东、顺*）
</code></pre><p>HashMap 是一种基于<font color="gree"><strong>哈希表</strong></font>的 Map 接口实现，它可以存储<font color="red"><strong>键值对 (key-value) 映射</strong></font>，具有以下特点:</p><ul><li><p>HashMap 是<font color="gree"><strong>无序的</strong></font>，也就是说它不会记录插入的顺序，而是<font color="red">根据键的哈希值来决定元素在数组中的位置</font></p></li><li><p>HashMap 是<font color="gree"><strong>线程不安全</strong></font>的，也就是说如果多个线程同时对 HashMap 进行修改操作，可能会导致数据丢失、死循环或数据覆盖等问题。<font color="orange">如果需要线程安全的 Map 实现，可以使用 Hashtable、 <code>Collections.synchronizedMap()</code> 或 ConcurrentHashMap</font></p></li><li><p>HashMap<font color="red">最多一个 null 键，任意个 null 值</font></p></li><li><p>HashMap 有<font color="gree">两个重要的参数</font>：</p><ul><li><font color="cornflowerblue">初始容量大小</font>是创建时给数组分配的容量大小，默认值为 16，<font color="cornflowerblue">加载因子</font>默认 0.75f，<font color="red">用数组容量大小乘以加载因子得到一个值，一旦数组中存储的元素个数超过该值就会调用 <code>resize()</code> 将数组容量增加到原来的两倍</font>，专业术语叫做<font color="gree">扩容</font>。<font color="red">扩容的操作非常消耗性能，因为需要重新计算所有元素的哈希值并重新分配到新的数组中</font></li></ul></li><li><p>HashMap 的<font color="gree">数据结构</font>是 **<font color="orange">数组 + 链表 + 红黑树</font>**。</p><ul><li>数组是主要的数据结构，<font color="red">每个数组元素又是一个链表或红黑树的头节点</font>。</li><li>当通过键的哈希值计算出数组下标时，<ul><li>如果该位置没有元素，则直接插入</li><li>如果该位置有元素，则需要判断该元素与插入元素的<font color="red">hashCode 是否相等</font><ul><li>如果相等则覆盖</li><li>如果不等则<font color="red">以链表或红黑树的形式插入到该位置</font>，<font color="red">当链表的长度超过 8 时，会将链表转换为红黑树，以提高查找效率</font></li></ul></li></ul></li></ul></li></ul><p>HashMap 的<font color="gree">主要操作</font>有 put () 和 get () 方法，它们的实现原理如下:</p><ul><li><p><font color="cornflowerblue">put()</font></p><ul><li>首先将键和值封装成一个 Node 对象</li><li>然后调用键的 hashCode () 方法得到哈希值，并通过哈希函数转换成数组下标<ul><li><p>如果该下标位置没有元素，则直接插入</p></li><li><p>如果该位置有元素，则遍历该位置的链表或红黑树，比较每个节点的键是否与插入元素的键相等</p><ul><li>如果相等则覆盖</li><li>如果不等则插入到链表尾部或红黑树中</li></ul></li><li><p>最后判断是否需要扩容</p></li></ul></li></ul></li><li><p><font color="cornflowerblue">get()</font></p><ul><li>首先调用键的 hashCode () 方法得到哈希值，并通过哈希函数转换成数组下标</li><li>然后根据下标找到对应的链表或红黑树头节点，遍历该链表或红黑树，比较每个节点的键是否与查找元素的键相等<ul><li>如果相等则返回该节点的值</li><li>如果不等则继续查找，如果遍历完毕没有找到，则返回 null</li></ul></li></ul></li></ul><h4 id="5-hashmap和hashtable的区别银数据-阿巴芝麻信用-众银行-爱信-杭州智公司"><a class="anchor" href="#5-hashmap和hashtable的区别银数据-阿巴芝麻信用-众银行-爱信-杭州智公司">#</a> 5. <mark>HashMap 和 Hashtable 的区别？</mark>(银 * 数据、阿 ** 巴芝麻信用、* 众银行、爱 * 信、杭州 * 智公司)</h4><pre><code>类似问题：
&gt; HashMap 和 HashTable 有什么区别，以及如何使用，以及他的一些方法？（阿*校招、*东、*度校招、顺*）
</code></pre><p>HashMap 和 Hashtable 都是实现了 Map 接口的类，它们都可以存储键值对 (key-value) 映射，但是它们之间也有一些区别:</p><ul><li><p><font color="red">HashMap 是线程不安全的</font>，也就是说如果多个线程同时对 HashMap 进行修改操作，可能会导致数据丢失、死循环或数据覆盖等问题。<font color="red">Hashtable 是线程安全的</font>，它的方法都使用了 synchronized 关键字来保证同步，但是这也降低了效率</p></li><li><p><font color="red">HashMap 允许键和值都为 null，但是最多只能有一个键为 null 的元素</font>。<font color="red">Hashtable 不允许键和值为 null</font>，否则会抛出 NullPointerException 异常</p><blockquote><ul><li><p>HashMap 是在 JDK1.2 中引入的，它是为了提供更高效和灵活的 Map 实现，而不考虑线程安全和兼容性。<font color="red">HashMap 允许键值为 null，是因为它使用了特殊的处理逻辑来处理 null 键值，比如使用 0 作为 null 键的哈希值，使用 equals 方法而不是 == 来比较 null 值等</font>。这样做的好处是可以使得 HashMap 更通用和灵活，可以适应不同的场景和需求。</p></li><li><p>Hashtable 是在 JDK1.0 中引入的，它是为了提供一个线程安全和兼容性较好的 Map 实现，而不考虑效率和灵活性。<font color="red">Hashtable 不允许键值为 null，是因为它直接使用了键值的 hashCode () 方法和 == 运算符来计算哈希值和比较对象，如果键值为 null，就会抛出 NullPointerException 异常</font>。这样做的好处是可以使得 Hashtable 更简单和稳定，可以避免一些潜在的错误和异常 。</p></li></ul></blockquote></li><li><p><font color="red">HashMap 的底层数组长度必须为 2 的幂次方，这样可以利用 &amp; 运算代替 % 运算提高效率，并且使得元素分布更均匀</font>。<font color="red">Hashtable 的底层数组长度可以为任意值</font>，但是一般使用质数来减少哈希冲突</p></li><li><p>HashMap 的哈希函数使用了键的 hashCode () 方法和高低位异或运算来计算哈希值，并且在链表长度超过 8 时会转换为红黑树来提高查找效率。Hashtable 的哈希函数只使用了键的 hashCode () 方法，并且一直使用链表来解决冲突</p></li></ul><h4 id="6-hashtable是怎么实现的为什么线程安全迪创新"><a class="anchor" href="#6-hashtable是怎么实现的为什么线程安全迪创新">#</a> 6. <mark>Hashtable 是怎么实现的，为什么线程安全？</mark>（迪 * 创新）</h4><p>哈希表（数组 + 单向链表）；底层方法使用 synchronized 修饰。</p><p>Hashtable 是一种基于哈希表的 Dictionary 的子类，它实现了 Map 接口，可以存储键值对 (key-value) 映射：</p><ul><li>Hashtable 的内部数据结构是<font color="orange">一个 Entry 数组，每个 Entry 是一个单向链表的头节点，用来解决哈希冲突</font>。当插入或查找一个元素时，首先根据键的 hashCode () 方法和取模运算计算出数组下标，然后遍历对应位置的链表，比较每个节点的键是否与目标元素的键相等，如果相等则返回或覆盖，如果不等则插入或继续查找</li><li>Hashtable 的<font color="orange">所有方法都使用了 <code>synchronized</code> 关键字来修饰</font>，这意味着它是线程安全的，多个线程可以共享一个 Hashtable 对象。但是<font color="red">这也导致了它的效率较低，因为每次操作都需要获取锁和释放锁</font></li><li>Hashtable<font color="red">不允许键和值为 null，否则会抛出 NullPointerException 异常</font>。这是因为它直接使用了键和值的 hashCode () 方法和 equals () 方法来计算哈希值和比较对象，如果键或值为 null，就会导致空指针异常</li><li>Hashtable 有两个重要的参数：<font color="cornflowerblue">初始容量大小</font>和<font color="cornflowerblue">加载因子</font>。初始容量大小是创建时给数组分配的容量大小，默认值为 11，加载因子默认 0.75f，用数组容量大小乘以加载因子得到一个值，一旦数组中存储的元素个数超过该值就会调用 rehash 方法将数组容量增加到原来的两倍加一（通常为质数），专业术语叫做<font color="red">扩容</font>。扩容的操作非常消耗性能，因为需要重新计算所有元素的哈希值并重新分配到新的数组中</li></ul><h4 id="7-hashmap和linkedhashmap的区别北京晨阳光"><a class="anchor" href="#7-hashmap和linkedhashmap的区别北京晨阳光">#</a> 7. <mark>HashMap 和 LinkedHashMap 的区别</mark>（北京 * 晨阳光）</h4><p>HashMap 和 LinkedHashMap 都是实现了 Map 接口的类，它们都可以存储键值对 (key-value) 映射，但是它们之间也有一些区别：</p><ul><li><font color="red">HashMap 是基于哈希表的</font>，它根据键的 hashCode () 方法和取模运算计算出数组下标，然后在对应位置的链表中查找或插入元素。<font color="red">HashMap 不保证元素的顺序，遍历时取得数据的顺序是完全随机的</font>。</li><li><font color="red">LinkedHashMap 是继承自 HashMap 的</font>，它<font color="red">在 HashMap 的基础上增加了一个<strong>双向链表</strong></font>，用来维护元素的插入顺序或访问顺序。<font color="red">LinkedHashMap 保证元素的顺序，遍历时取得数据的顺序是按照插入或访问的先后顺序</font>。</li><li>HashMap 和 LinkedHashMap 在性能方面：<ul><li><font color="gree">插入、删除元素</font>：<font color="red">由于 LinkedHashMap 需要额外维护一个双向链表，所以在 <code>插入和删除元素</code> 时会比 HashMap 慢一些</font>。</li><li><font color="gree">迭代遍历</font>：<font color="red">LinkedHashMap 在 <code>遍历元素</code> 时会比 HashMap 快一些，因为 LinkedHashMap 的遍历速度只和实际数据有关，和容量无关</font>。而<font color="red">HashMap 的遍历需要遍历底层数组，以及每个数组元素对应的链表 / 红黑树，数组的长度就是 HashMap 的容量，如果容量太大，那么遍历数组就会花费很多时间</font>。</li></ul></li></ul><h4 id="8-hashmap-和-treemap-的区别度太极-线途游-阿校招"><a class="anchor" href="#8-hashmap-和-treemap-的区别度太极-线途游-阿校招">#</a> 8. <mark>HashMap 和 TreeMap 的区别</mark>（<em>度，太极</em> *、* 线途游、阿 * 校招）</h4><p>HashMap 和 TreeMap 都是实现了 Map 接口的类，用来存储键值对，但是它们有以下几个方面的区别：</p><ul><li>数据结构：HashMap 是基于<font color="red">哈希表</font>来实现的，而 TreeMap 是基于<font color="red">红黑树</font>来实现的</li><li>排序：HashMap<font color="red">不保证映射的顺序</font>，而 TreeMap 根<font color="red">据键的自然顺序或者指定的比较器来对键进行排序</font></li><li>空值：HashMap 可以<font color="red">允许一个 null 键和多个 null 值</font>，而 TreeMap<font color="red">不允许 null 键，但是可以允许多个 null 值</font></li><li>性能：<ul><li>增、删、查：<font color="red">HashMap 在添加、查找、删除等操作上速度会比较快，因为它只需要计算哈希值和数组下标，而 TreeMap 在这些操作上速度会比较慢，因为它需要维护红黑树的平衡和顺序</font></li><li>内存：<font color="red">HashMap 会占用更多的空间，因为它需要保存一个数组，而 TreeMap 会占用更少的空间，因为它只需要保存节点</font></li><li>另外，HashMap 如果出现哈希冲突或者扩容的话，效率会降低</li></ul></li></ul><h4 id="9-hashmap里面实际装的是什么惠"><a class="anchor" href="#9-hashmap里面实际装的是什么惠">#</a> 9. <mark>HashMap 里面实际装的是什么？</mark>（惠 *）</h4><p>JDK7：HashMap 内部声明了 Entry，实现了 Map 中的 Entry 接口。（key，value 作为 Entry 的两个属性出现）</p><p>JDK8：HashMap 内部声明了 Node，实现了 Map 中的 Entry 接口。（key，value 作为 Node 的两个属性出现）</p><p>HashMap 的内部结构包括以下几个部分：</p><ul><li>一个<font color="gree">动态数组</font>，用来存放 Node 对象，每个 Node 对象包含一个 Entry 对象，Entry 对象中保存了键、值、哈希值等信息。</li><li>一个<font color="gree">哈希函数</font>，用来根据键的哈希值计算出数组的下标。</li><li>一个<font color="gree">负载因子</font>，用来控制数组的扩容时机，当数组中的元素个数超过数组长度乘以负载因子时，就会触发扩容操作。</li><li>一个<font color="gree">链表或者红黑树</font>，用来<font color="red">解决哈希冲突，即当多个键的哈希值相同或者映射到同一个数组下标时，就会把这些键值对连接起来，形成一个链表或者红黑树</font>。<font color="red">链表在元素个数达到 8 时会转换为红黑树，以提高查找效率</font></li></ul><h4 id="10-hashmap的key存储在哪里和value存储在一起吗那么value存储在哪里说具体点湖利软件-天伟业"><a class="anchor" href="#10-hashmap的key存储在哪里和value存储在一起吗那么value存储在哪里说具体点湖利软件-天伟业">#</a> 10. <mark>HashMap 的 key 存储在哪里？和 value 存储在一起吗？那么 value 存储在哪里？说具体点？</mark>（湖 ** 利软件、天 * 伟业）</h4><p>HashMap 的<font color="red">key 和 value 都存储在 Node 对象中，其中 Node 是 HashMap 的内部类，实现了 Map.Entry 接口</font>。<font color="red">Node 对象是一个链表节点或者红黑树节点，它有一个 next 属性指向下一个 Node 对象</font>。</p><p><font color="orange">HashMap 的底层结构是一个动态数组，数组的每个元素是一个 Node 对象，当多个 Node 对象的 key 的哈希值相同或者映射到同一个数组下标时，就会形成一个链表或者红黑树，通过 Node 对象的 next 属性连接起来</font>。</p><p>所以，<font color="red">可以说 HashMap 的 key 和 value<strong> 存储在动态数组中的 Node 对象中</strong>，Node 对象可以形成<strong>链表或者红黑树</strong>来解决<u>哈希冲突</u></font>。</p><h4 id="11-自定义类型可以作为key么阿"><a class="anchor" href="#11-自定义类型可以作为key么阿">#</a> 11. <mark>自定义类型可以作为 Key 么？</mark>（阿 *）</h4><p>Java 中<font color="red">自定义类型可以作为 HashMap 的 Key</font>，但是需要注意一些问题：</p><ul><li>自定义类型<font color="red">必须重写 <code>hashCode()</code> 和 <code>equals()</code> 方法</font>，以保证相同属性的对象有相同的哈希值和相等性判断，否则会导致 HashMap 无法正确存取元素。</li><li>自定义类型的 hashCode () 和 equals () 方法应该遵循以下原则：<ul><li><font color="red">如果两个对象相等，则两个对象的 hashCode () 必须相等</font>；</li><li><font color="red">如果两个对象不相等，则两个对象的 hashCode ()<strong> 尽量</strong>不要相等，以<strong>减少哈希冲突的可能性</strong></font>；</li><li>equals () 方法应该满足<font color="red">自反性、对称性、传递性、一致性</font>，即对于任意非空对象 x、y 和 z，有：<ul><li>x.equals (x) 为 true；</li><li>x.equals (y) 为 true 当且仅当 y.equals (x) 为 true；</li><li>如果 x.equals (y) 为 true 且 y.equals (z) 为 true，则 x.equals (z) 也为 true；</li><li>多次调用 x.equals (y) 的结果不会改变，除非 x 或 y 的属性发生变化。</li></ul></li></ul></li><li><font color="orange"><strong>自定义类型的属性应该是不可变的</strong>，或者至少在作为 HashMap 的 Key 期间不要改变，否则会导致哈希值和相等性判断发生变化，从而导致 HashMap 无法正确存取元素</font>。</li></ul><h3 id="collections"><a class="anchor" href="#collections">#</a> Collections</h3><h4 id="1-集合类的工具类是谁用过工具类哪些方法顺"><a class="anchor" href="#1-集合类的工具类是谁用过工具类哪些方法顺">#</a> 1. 集合类的工具类是谁？用过工具类哪些方法？（顺 *）</h4><p>Collections 是一个集合工具类，它提供了一系列静态方法，用于对集合类（Collection、List、Set、Map 等）进行操作，例如排序、查找、复制、同步等。</p><p>Collections 类的常用方法有：</p><ul><li><font color="gree">sort</font>(List list)：按照自然顺序对 list 进行升序排序，list 中的元素必须实现 Comparable 接口</li><li><font color="gree">sort</font>(List list, Comparator c)：按照定制的顺序对 list 进行排序，c 是一个比较器，用来控制排序逻辑</li><li><font color="gree">reverse</font>(List list)：反转 list 中的元素顺序</li><li><font color="gree">shuffle</font>(List list)：随机打乱 list 中的元素顺序</li><li><font color="gree">swap</font>(List list, int i, int j)：交换 list 中 i 和 j 位置的元素</li><li><font color="gree">fill</font>(List list, Object obj)：用 obj 替换 list 中的所有元素</li><li><font color="gree"><strong>copy</strong></font>(List <font color="red">dest</font>, List <font color="red">src</font>)：将 src 中的所有元素复制到 dest 中，<font color="red">dest 必须至少和 src 一样长</font></li><li><font color="gree">max</font>(Collection coll)：根据自然顺序返回 coll 中的最大元素，coll 中的元素必须实现 Comparable 接口</li><li><font color="gree">max</font>(Collection coll, Comparator c)：根据定制的顺序返回 coll 中的最大元素，c 是一个比较器，用来控制比较逻辑</li><li><font color="gree">min</font>(Collection coll)：根据自然顺序返回 coll 中的最小元素，coll 中的元素必须实现 Comparable 接口</li><li><font color="gree">min</font>(Collection coll, Comparator c)：根据定制的顺序返回 coll 中的最小元素，c 是一个比较器，用来控制比较逻辑</li><li><font color="gree">frequency</font>(Collection c, Object o)：返回 o 在 c 中出现的次数</li><li><font color="gree">indexOfSubList</font>(List <font color="red">source</font>, List <font color="red">target</font>)：返回 target 在 source 中第一次出现的索引，如果不存在则返回 - 1</li><li><font color="gree">lastIndexOfSubList</font>(List source, List target)：返回 target 在 source 中最后一次出现的索引，如果不存在则返回 - 1</li><li><font color="gree">replaceAll</font>(List list, Object <font color="red">oldVal</font>, Object <font color="red">newVal</font>)：用 newVal 替换 list 中所有等于 oldVal 的元素</li><li><font color="gree">synchronizedCollection</font>(Collection c)：返回一个<font color="red">线程安全的</font>Collection，它包装了 c</li><li><font color="gree">synchronizedList</font>(List list)：返回一个线程安全的 List，它包装了 list</li><li><font color="gree">synchronizedSet</font>(Set s)：返回一个线程安全的 Set，它包装了 s</li><li><font color="gree">synchronizedMap</font>(Map m)：返回一个线程安全的 Map，它包装了 m</li></ul><h4 id="2-collection-和-collections的区别平金服-软"><a class="anchor" href="#2-collection-和-collections的区别平金服-软">#</a> 2. <mark>Collection 和 Collections 的区别？</mark>（平 * 金服、* 软）</h4><p>Collection 是一个集合<font color="red">接口</font>，定义了一些操作集合的方法，有<font color="red">子接口 List 和 Set</font>。</p><p>Collections 是一个集合<font color="red">工具类</font>，提供了<font color="red">一系列静态方法</font>去操作 Collection、List、Set、Map 等集合框架。</p><h4 id="3-arraylist-如何实现排序阿"><a class="anchor" href="#3-arraylist-如何实现排序阿">#</a> 3. <mark>ArrayList 如何实现排序？</mark>（阿 *）</h4><p>ArrayList 是一个实现了 List 接口的动态数组，它可以存储任意类型的对象，也可以对其中的元素进行排序。有以下几种方法可以对 ArrayList 进行排序：</p><ul><li>使用<font color="gree"> <code>Collections.sort(List list)</code> </font>方法，它会按照元素的自然顺序（升序）对 list 进行排序，list 中的元素必须实现 Comparable 接口，或者是基本类型的包装类。</li><li>使用<font color="gree"> <code>Collections.sort(List list, Comparator c)</code> </font>方法，它会按照定制的顺序（由 c 指定）对 list 进行排序，c 是一个比较器，用来控制排序逻辑。</li><li>使用<font color="gree"> <code>List.sort(Comparator c)</code> </font>方法，它会按照定制的顺序（由 c 指定）对 list 进行排序，c 是一个比较器，用来控制排序逻辑。这个方法是在 Java 8 中引入的，默认调用 <code>Arrays.sort(Object[] a, Comparator c)</code> 方法。</li><li>使用<font color="gree"> <code>Arrays.sort(Object[] a)</code> </font>方法，它会按照元素的自然顺序（升序）对数组 a 进行排序，a 中的元素必须实现 Comparable 接口，或者是基本类型的包装类。这个方法需要调用 toArray () 先将 ArrayList 转换为数组。</li><li>使用<font color="gree"> <code>Arrays.sort(Object[] a, Comparator c)</code> </font>方法，它会按照定制的顺序（由 c 指定）对数组 a 进行排序，c 是一个比较器，用来控制排序逻辑。这个方法需要调用 toArray () 先将 ArrayList 转换为数组。</li></ul><p>下面给出一些示例代码：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token annotation punctuation">@Test</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token comment">// 创建一个 ArrayList 存储整数</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token comment">// 方式一：使用 Collections.sort (List list) 方法按照自然顺序（升序）排序</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出 [1, 3, 5, 7]</span></pre></td></tr><tr><td data-num="13"></td><td><pre></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token comment">// 方式二：使用 Collections.sort (List list, Comparator c) 方法按照定制的顺序（降序）排序</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token annotation punctuation">@Override</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span><span class="token class-name">Integer</span> o1<span class="token punctuation">,</span> <span class="token class-name">Integer</span> o2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>            <span class="token keyword">return</span> o2 <span class="token operator">-</span> o1<span class="token punctuation">;</span> <span class="token comment">// 降序</span></pre></td></tr><tr><td data-num="19"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出 [7, 5, 3, 1]</span></pre></td></tr><tr><td data-num="22"></td><td><pre></pre></td></tr><tr><td data-num="23"></td><td><pre>    <span class="token comment">// 方式三：使用 List.sort (Comparator c) 方法按照定制的顺序（降序）排序</span></pre></td></tr><tr><td data-num="24"></td><td><pre>    list<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>        <span class="token annotation punctuation">@Override</span></pre></td></tr><tr><td data-num="26"></td><td><pre>        <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span><span class="token class-name">Integer</span> o1<span class="token punctuation">,</span> <span class="token class-name">Integer</span> o2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>            <span class="token keyword">return</span> o2 <span class="token operator">-</span> o1<span class="token punctuation">;</span> <span class="token comment">// 降序</span></pre></td></tr><tr><td data-num="28"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出 [7, 5, 3, 1]</span></pre></td></tr><tr><td data-num="31"></td><td><pre></pre></td></tr><tr><td data-num="32"></td><td><pre>    <span class="token comment">// 方式四：使用 Arrays.sort (Object [] a) 方法按照自然顺序（升序）排序</span></pre></td></tr><tr><td data-num="33"></td><td><pre>    <span class="token class-name">Integer</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array1 <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">[</span>list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将 ArrayList 转换为数组</span></pre></td></tr><tr><td data-num="34"></td><td><pre>    <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>array1<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="35"></td><td><pre>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>array1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出 [1, 3, 5, 7]</span></pre></td></tr><tr><td data-num="36"></td><td><pre></pre></td></tr><tr><td data-num="37"></td><td><pre>    <span class="token comment">// 方式五：使用 Arrays.sort (Object [] a, Comparator c) 方法按照定制的顺序（降序）排序</span></pre></td></tr><tr><td data-num="38"></td><td><pre>    <span class="token class-name">Integer</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array2 <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">[</span>list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将 ArrayList 转换为数组</span></pre></td></tr><tr><td data-num="39"></td><td><pre>    <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>array2<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="40"></td><td><pre>        <span class="token annotation punctuation">@Override</span></pre></td></tr><tr><td data-num="41"></td><td><pre>        <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span><span class="token class-name">Integer</span> o1<span class="token punctuation">,</span> <span class="token class-name">Integer</span> o2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="42"></td><td><pre>            <span class="token keyword">return</span> o2 <span class="token operator">-</span> o1<span class="token punctuation">;</span> <span class="token comment">// 降序</span></pre></td></tr><tr><td data-num="43"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="44"></td><td><pre>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="45"></td><td><pre>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>array2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出 [7, 5, 3, 1]</span></pre></td></tr><tr><td data-num="46"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h4 id="4-hashmap是否线程安全怎样解决hashmap的线程不安全中卫星"><a class="anchor" href="#4-hashmap是否线程安全怎样解决hashmap的线程不安全中卫星">#</a> 4. HashMap 是否线程安全，怎样解决 HashMap 的线程不安全（中 * 卫星）</h4><pre><code>类似问题：
&gt; 怎么实现HashMap线程安全？（*团、*东、顺*）
</code></pre><p>HashMap 不是线程安全的。如果您希望在多线程环境中使用线程安全的 HashMap，可以使用以下方法之一：</p><ol><li>使用<font color="gree">Hashtable</font>，它通过对整个表上锁来实现线程安全，但效率较低。</li><li>使用<font color="gree"> <code>Collections.synchronizedMap(Map m)</code> </font>包装 HashMap。这样可以返回一个由指定映射支持的同步（线程安全）映射。</li><li>使用<font color="gree">ConcurrentHashMap</font>，它是 Java 5 之后引入的一个线程安全的 HashMap。它将哈希表分为 16 个桶（默认值），常用操作（如 get、put、remove）只锁定当前需要用到的桶。</li></ol></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2023-11-12 10:58:49" itemprop="dateModified" datetime="2023-11-12T10:58:49+08:00">2023-11-12</time> </span><span id="java/java-se/java-excise/第12章：随堂复习与企业真题（集合框架）/" class="item leancloud_visitors" data-flag-title="宋红康_第12章：集合框架" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>范特东东东 <i class="ic i-at"><em>@</em></i>水文 & 摄影</li><li class="link"><strong>本文链接：</strong> <a href="http://example.com/java/java-se/java-excise/%E7%AC%AC12%E7%AB%A0%EF%BC%9A%E9%9A%8F%E5%A0%82%E5%A4%8D%E4%B9%A0%E4%B8%8E%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%A2%98%EF%BC%88%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%EF%BC%89/" title="宋红康_第12章：集合框架">http://example.com/java/java-se/java-excise/第12章：随堂复习与企业真题（集合框架）/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/java/java-se/java-excise/%E7%AC%AC11%E7%AB%A0%EF%BC%9A%E9%9A%8F%E5%A0%82%E5%A4%8D%E4%B9%A0%E4%B8%8E%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%A2%98%EF%BC%88%E5%B8%B8%E7%94%A8%E7%B1%BB%E4%B8%8E%E5%9F%BA%E7%A1%80API%EF%BC%89/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;pic.imgdb.cn&#x2F;item&#x2F;656f2723c458853aef5c1279.jpg" title="宋红康_第11章：常用类与基础API"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> Java基础-真题</span><h3>宋红康_第11章：常用类与基础API</h3></a></div><div class="item right"><a href="/java/java-se/java-excise/%E7%AC%AC13%E7%AB%A0%EF%BC%9A%E9%9A%8F%E5%A0%82%E5%A4%8D%E4%B9%A0%E4%B8%8E%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%A2%98%EF%BC%88%E6%B3%9B%E5%9E%8B%EF%BC%89/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;pic.imgdb.cn&#x2F;item&#x2F;65e332b89f345e8d03173937.jpg" title="宋红康_第13章：泛型"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> Java基础-真题</span><h3>宋红康_第13章：泛型</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0%E9%9A%8F%E5%A0%82%E5%A4%8D%E4%B9%A0%E4%B8%8E%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%A2%98%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6"><span class="toc-number">1.</span> <span class="toc-text">第 12 章：随堂复习与企业真题（集合框架）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-%E9%9A%8F%E5%A0%82%E5%A4%8D%E4%B9%A0"><span class="toc-number">1.1.</span> <span class="toc-text">一、随堂复习</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%95%B0%E7%BB%84%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE%E6%96%B9%E9%9D%A2%E7%9A%84%E7%89%B9%E7%82%B9%E5%92%8C%E5%BC%8A%E7%AB%AF"><span class="toc-number">1.1.1.</span> <span class="toc-text">1. 数组存储数据方面的特点和弊端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E6%A6%82%E8%BF%B0"><span class="toc-number">1.1.2.</span> <span class="toc-text">2. 集合框架概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-collection%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">1.1.3.</span> <span class="toc-text">3. Collection 的常用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#31-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">3.1 常用方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#32-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.1.3.2.</span> <span class="toc-text">3.2 迭代器接口</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-collection%E7%9A%84%E5%AD%90%E6%8E%A5%E5%8F%A3list"><span class="toc-number">1.1.4.</span> <span class="toc-text">4. Collection 的子接口：List</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-collection%E7%9A%84%E5%AD%90%E6%8E%A5%E5%8F%A3set"><span class="toc-number">1.1.5.</span> <span class="toc-text">5. Collection 的子接口：Set</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-map%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.1.6.</span> <span class="toc-text">6. Map 接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-collections%E5%B7%A5%E5%85%B7%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">1.1.7.</span> <span class="toc-text">7. Collections 工具类的使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%A2%98"><span class="toc-number">1.2.</span> <span class="toc-text">二、企业真题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#21-%E9%9B%86%E5%90%88%E6%A6%82%E8%BF%B0"><span class="toc-number">1.2.1.</span> <span class="toc-text">2.1 集合概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-listsetmap%E6%98%AF%E5%90%A6%E7%BB%A7%E6%89%BF%E8%87%AAcollection%E6%8E%A5%E5%8F%A3%E5%8C%97%E4%BA%AC%E4%B8%AD%E8%AF%91%E5%92%A8%E8%AF%A2-%E6%80%9D%E8%B4%B8%E6%98%93"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">1. List，Set，Map 是否继承自 collection 接口？（北京中 * 译咨询、思 * 贸易）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%AF%B4%E8%AF%B4listsetmap%E7%9A%84%E5%8C%BA%E5%88%AB%E6%B0%91%E9%93%B6%E8%A1%8C"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">2. 说说 List,Set,Map 的区别 (民 * 银行)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%86%99%E5%87%BAlist-map-set%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%B1%BB%E5%B9%B6%E8%AF%B4%E5%87%BA%E5%85%B6%E7%89%B9%E7%82%B9%E5%8D%8E%E4%B8%BA"><span class="toc-number">1.2.1.3.</span> <span class="toc-text">3. 写出 list、map、set 接口的实现类，并说出其特点（华 ** 为）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%B8%B8%E8%A7%81%E9%9B%86%E5%90%88%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF%E9%A5%BF"><span class="toc-number">1.2.1.4.</span> <span class="toc-text">4. 常见集合类的区别和适用场景（饿 **）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E9%9B%86%E5%90%88%E7%9A%84%E7%88%B6%E7%B1%BB%E6%98%AF%E8%B0%81%E5%93%AA%E4%BA%9B%E5%AE%89%E5%85%A8%E7%9A%84%E5%8C%97%E4%BA%AC%E4%B8%AD%E4%BF%A1"><span class="toc-number">1.2.1.5.</span> <span class="toc-text">5. 集合的父类是谁？哪些安全的？（北京中 ** 信）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E9%9B%86%E5%90%88%E8%AF%B4%E4%B8%80%E4%B8%8B%E5%93%AA%E4%BA%9B%E6%98%AF%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84%E7%A7%91%E8%BD%AF"><span class="toc-number">1.2.1.6.</span> <span class="toc-text">6. 集合说一下哪些是线程不安全的（* 科软）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E9%81%8D%E5%8E%86%E9%9B%86%E5%90%88%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%E6%81%92%E7%94%B5%E5%AD%90"><span class="toc-number">1.2.1.7.</span> <span class="toc-text">7. 遍历集合的方式有哪些？（恒 * 电子）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-list%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.2.2.</span> <span class="toc-text">2.2 List 接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-list%E4%B8%8B%E9%9D%A2%E6%9C%89%E5%93%AA%E4%BA%9B%E5%AE%9E%E7%8E%B0%E8%BD%AF%E5%8A%9B"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">1. List 下面有哪些实现（软 ** 力）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-arraylist%E4%B8%8Elinkedlist%E5%8C%BA%E5%88%ABoo-%E6%BB%B4-%E6%B1%87%E5%A4%A9%E4%B8%8B-%E6%8B%93%E8%BD%AF%E4%BB%B6-%E5%8D%9A%E7%BA%B3%E8%BD%AF%E4%BB%B6-%E4%B8%8A%E6%B5%B7%E8%BF%9B%E5%A4%A9%E4%B8%8B%E5%8C%97%E4%BA%AC%E6%B0%B8%E7%94%9F%E4%BF%A1%E6%81%AF-%E8%81%94-%E5%9C%A8%E9%80%94%E6%B8%B8"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">2. ArrayList 与 LinkedList 区别？(O**O、滴 *、汇 * 天下、拓 * 软件、博纳 ** 软件、上海 * 进天下，北京永生 ** 信息、* 联、在 * 途游)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-arraylist%E4%B8%8Evector%E5%8C%BA%E5%88%AB%E5%91%A2%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8arraylist%E5%8F%96%E4%BB%A3vector%E5%91%A2%E6%B9%96%E5%88%A9%E8%BD%AF%E4%BB%B6"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">3. &#x3D;&#x3D;ArrayList 与 Vector 区别呢？&#x3D;&#x3D; 为什么要用 ArrayList 取代 Vector 呢？(湖 ** 利软件)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-javautilarraylist%E5%B8%B8%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8D%8E%E4%B8%BA"><span class="toc-number">1.2.2.4.</span> <span class="toc-text">4. Java.util.ArrayList 常用的方法有哪些？（华 ** 为）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-arraylist-%E6%98%AF%E6%9C%89%E5%BA%8F%E8%BF%98%E6%98%AF%E6%97%A0%E5%BA%8F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%9C%9C%E4%BF%A1%E6%81%AF"><span class="toc-number">1.2.2.5.</span> <span class="toc-text">5. Arraylist 是有序还是无序？为什么？（蜜 * 信息）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-set%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.2.3.</span> <span class="toc-text">2.3 Set 接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1set%E9%9B%86%E5%90%88%E6%9C%89%E5%93%AA%E4%BA%9B%E5%AE%9E%E7%8E%B0%E7%B1%BB%E5%88%86%E5%88%AB%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9%E6%8B%93%E8%BD%AF%E4%BB%B6"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">1.Set 集合有哪些实现类，分别有什么特点？（拓 * 软件）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-list%E9%9B%86%E5%90%88%E5%92%8Cset%E9%9B%86%E5%90%88%E7%9A%84%E5%8C%BA%E5%88%AB%E4%BA%9A%E7%A7%91%E6%8A%80-%E6%B5%B7%E7%BF%BC%E7%A7%91%E6%8A%80%E5%8D%8E%E7%94%B5%E7%B3%BB%E7%BB%9F%E8%BE%BE%E8%B4%B7"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">2. List 集合和 Set 集合的区别？（亚 * 科技、* 海 * 翼科技，* 华电 * 系统，达 * 贷）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-set%E9%87%8C%E7%9A%84%E5%85%83%E7%B4%A0%E6%98%AF%E4%B8%8D%E8%83%BD%E9%87%8D%E5%A4%8D%E7%9A%84%E9%82%A3%E4%B9%88%E7%94%A8%E4%BB%80%E4%B9%88%E6%96%B9%E6%B3%95%E6%9D%A5%E5%8C%BA%E5%88%86%E9%87%8D%E5%A4%8D%E4%B8%8E%E5%90%A6%E5%91%A2-%E6%98%AF%E7%94%A8%E8%BF%98%E6%98%AFequals-%E5%AE%83%E4%BB%AC%E6%9C%89%E4%BD%95%E5%8C%BA%E5%88%AB%E9%B8%BF%E7%BD%91%E7%BB%9C"><span class="toc-number">1.2.3.3.</span> <span class="toc-text">3. Set 里的元素是不能重复的，那么用什么方法来区分重复与否呢？是用还是 equals ()? 它们有何区别？&#x3D;&#x3D;（鸿 * 网络）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-treeset%E4%B8%A4%E7%A7%8D%E6%8E%92%E5%BA%8F%E6%96%B9%E5%BC%8F%E5%9C%A8%E4%BD%BF%E7%94%A8%E7%9A%84%E6%97%B6%E5%80%99%E6%80%8E%E4%B9%88%E8%B5%B7%E4%BD%9C%E7%94%A8%E6%8B%93%E8%BD%AF%E4%BB%B6"><span class="toc-number">1.2.3.4.</span> <span class="toc-text">4. TreeSet 两种排序方式在使用的时候怎么起作用？（拓 * 软件）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-treeset%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%B1%B3"><span class="toc-number">1.2.3.5.</span> <span class="toc-text">5. TreeSet 的数据结构（* 米）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24-map%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.2.4.</span> <span class="toc-text">2.4 Map 接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%AF%B4%E4%B8%80%E4%B8%8Bjava%E7%9A%84%E9%9B%86%E5%90%88map%E6%9C%89%E5%93%AA%E4%BA%9B%E5%AE%9E%E7%8E%B0%E7%B1%BB%E5%A5%A5%E5%8C%BB%E8%8D%AF"><span class="toc-number">1.2.4.1.</span> <span class="toc-text">1. 说一下 Java 的集合 Map 有哪些实现类？（奥 * 医药）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-final%E6%80%8E%E4%B9%88%E7%94%A8%E4%BF%AE%E9%A5%B0map%E5%8F%AF%E4%BB%A5%E7%BB%A7%E7%BB%AD%E6%B7%BB%E5%8A%A0%E6%95%B0%E6%8D%AE%E5%90%97%E6%B7%B1%E8%93%9D"><span class="toc-number">1.2.4.2.</span> <span class="toc-text">2. final 怎么用，修饰 Map 可以继续添加数据吗？（* 深蓝）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-set%E5%92%8Cmap%E7%9A%84%E6%AF%94%E8%BE%83%E4%BA%9A%E7%A7%91%E6%8A%80"><span class="toc-number">1.2.4.3.</span> <span class="toc-text">3. Set 和 Map 的比较（亚 * 科技）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8Bhashmap%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%90%97%E7%B1%B3"><span class="toc-number">1.2.4.4.</span> <span class="toc-text">4. 介绍一下 HashMap，是线程安全的吗？（* 米）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-hashmap%E5%92%8Chashtable%E7%9A%84%E5%8C%BA%E5%88%AB%E9%93%B6%E6%95%B0%E6%8D%AE-%E9%98%BF%E5%B7%B4%E8%8A%9D%E9%BA%BB%E4%BF%A1%E7%94%A8-%E4%BC%97%E9%93%B6%E8%A1%8C-%E7%88%B1%E4%BF%A1-%E6%9D%AD%E5%B7%9E%E6%99%BA%E5%85%AC%E5%8F%B8"><span class="toc-number">1.2.4.5.</span> <span class="toc-text">5. HashMap 和 Hashtable 的区别？(银 * 数据、阿 ** 巴芝麻信用、* 众银行、爱 * 信、杭州 * 智公司)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-hashtable%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%E4%B8%BA%E4%BB%80%E4%B9%88%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E8%BF%AA%E5%88%9B%E6%96%B0"><span class="toc-number">1.2.4.6.</span> <span class="toc-text">6. Hashtable 是怎么实现的，为什么线程安全？（迪 * 创新）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-hashmap%E5%92%8Clinkedhashmap%E7%9A%84%E5%8C%BA%E5%88%AB%E5%8C%97%E4%BA%AC%E6%99%A8%E9%98%B3%E5%85%89"><span class="toc-number">1.2.4.7.</span> <span class="toc-text">7. HashMap 和 LinkedHashMap 的区别（北京 * 晨阳光）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-hashmap-%E5%92%8C-treemap-%E7%9A%84%E5%8C%BA%E5%88%AB%E5%BA%A6%E5%A4%AA%E6%9E%81-%E7%BA%BF%E9%80%94%E6%B8%B8-%E9%98%BF%E6%A0%A1%E6%8B%9B"><span class="toc-number">1.2.4.8.</span> <span class="toc-text">8. HashMap 和 TreeMap 的区别（度，太极 *、* 线途游、阿 * 校招）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-hashmap%E9%87%8C%E9%9D%A2%E5%AE%9E%E9%99%85%E8%A3%85%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88%E6%83%A0"><span class="toc-number">1.2.4.9.</span> <span class="toc-text">9. HashMap 里面实际装的是什么？（惠 *）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-hashmap%E7%9A%84key%E5%AD%98%E5%82%A8%E5%9C%A8%E5%93%AA%E9%87%8C%E5%92%8Cvalue%E5%AD%98%E5%82%A8%E5%9C%A8%E4%B8%80%E8%B5%B7%E5%90%97%E9%82%A3%E4%B9%88value%E5%AD%98%E5%82%A8%E5%9C%A8%E5%93%AA%E9%87%8C%E8%AF%B4%E5%85%B7%E4%BD%93%E7%82%B9%E6%B9%96%E5%88%A9%E8%BD%AF%E4%BB%B6-%E5%A4%A9%E4%BC%9F%E4%B8%9A"><span class="toc-number">1.2.4.10.</span> <span class="toc-text">10. HashMap 的 key 存储在哪里？和 value 存储在一起吗？那么 value 存储在哪里？说具体点？（湖 ** 利软件、天 * 伟业）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E5%8F%AF%E4%BB%A5%E4%BD%9C%E4%B8%BAkey%E4%B9%88%E9%98%BF"><span class="toc-number">1.2.4.11.</span> <span class="toc-text">11. 自定义类型可以作为 Key 么？（阿 *）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#collections"><span class="toc-number">1.2.5.</span> <span class="toc-text">Collections</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%9B%86%E5%90%88%E7%B1%BB%E7%9A%84%E5%B7%A5%E5%85%B7%E7%B1%BB%E6%98%AF%E8%B0%81%E7%94%A8%E8%BF%87%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95%E9%A1%BA"><span class="toc-number">1.2.5.1.</span> <span class="toc-text">1. 集合类的工具类是谁？用过工具类哪些方法？（顺 *）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-collection-%E5%92%8C-collections%E7%9A%84%E5%8C%BA%E5%88%AB%E5%B9%B3%E9%87%91%E6%9C%8D-%E8%BD%AF"><span class="toc-number">1.2.5.2.</span> <span class="toc-text">2. Collection 和 Collections 的区别？（平 * 金服、* 软）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-arraylist-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%8E%92%E5%BA%8F%E9%98%BF"><span class="toc-number">1.2.5.3.</span> <span class="toc-text">3. ArrayList 如何实现排序？（阿 *）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-hashmap%E6%98%AF%E5%90%A6%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%8E%E6%A0%B7%E8%A7%A3%E5%86%B3hashmap%E7%9A%84%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E4%B8%AD%E5%8D%AB%E6%98%9F"><span class="toc-number">1.2.5.4.</span> <span class="toc-text">4. HashMap 是否线程安全，怎样解决 HashMap 的线程不安全（中 * 卫星）</span></a></li></ol></li></ol></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/java/java-se/java-excise/%E7%AC%AC01%E7%AB%A0%EF%BC%9A%E9%9A%8F%E5%A0%82%E5%A4%8D%E4%B9%A0%E4%B8%8E%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%A2%98%EF%BC%88Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0%EF%BC%89/" rel="bookmark" title="宋红康_第01章：Java语言概述">宋红康_第01章：Java语言概述</a></li><li><a href="/java/java-se/java-excise/%E7%AC%AC02%E7%AB%A0%EF%BC%9A%E9%9A%8F%E5%A0%82%E5%A4%8D%E4%B9%A0%E4%B8%8E%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%A2%98%EF%BC%88%E5%8F%98%E9%87%8F%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%89/" rel="bookmark" title="宋红康_第02章：变量与运算符">宋红康_第02章：变量与运算符</a></li><li><a href="/java/java-se/java-excise/%E7%AC%AC03%E7%AB%A0%EF%BC%9A%E9%9A%8F%E5%A0%82%E5%A4%8D%E4%B9%A0%E4%B8%8E%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%A2%98%EF%BC%88%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5%EF%BC%89/" rel="bookmark" title="宋红康_第03章：流程控制语句">宋红康_第03章：流程控制语句</a></li><li><a href="/java/java-se/java-excise/%E7%AC%AC04%E7%AB%A0%EF%BC%9A%E9%9A%8F%E5%A0%82%E5%A4%8D%E4%B9%A0%E4%B8%8E%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%A2%98%EF%BC%88IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%89/" rel="bookmark" title="宋红康_第04章：IDEA安装与使用">宋红康_第04章：IDEA安装与使用</a></li><li><a href="/java/java-se/java-excise/%E7%AC%AC05%E7%AB%A0%EF%BC%9A%E9%9A%8F%E5%A0%82%E5%A4%8D%E4%B9%A0%E4%B8%8E%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%A2%98%EF%BC%88%E6%95%B0%E7%BB%84%EF%BC%89/" rel="bookmark" title="宋红康_第05章：数组">宋红康_第05章：数组</a></li><li><a href="/java/java-se/java-excise/%E7%AC%AC06%E7%AB%A0%EF%BC%9A%E9%9A%8F%E5%A0%82%E5%A4%8D%E4%B9%A0%E4%B8%8E%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%A2%98%EF%BC%88%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%9F%BA%E7%A1%80%EF%BC%89/" rel="bookmark" title="宋红康_第06章：面向对象-基础">宋红康_第06章：面向对象-基础</a></li><li><a href="/java/java-se/java-excise/%E7%AC%AC07%E7%AB%A0%EF%BC%9A%E9%9A%8F%E5%A0%82%E5%A4%8D%E4%B9%A0%E4%B8%8E%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%A2%98%EF%BC%88%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E8%BF%9B%E9%98%B6%EF%BC%89/" rel="bookmark" title="宋红康_第07章：面向对象-进阶">宋红康_第07章：面向对象-进阶</a></li><li><a href="/java/java-se/java-excise/%E7%AC%AC08%E7%AB%A0%EF%BC%9A%E9%9A%8F%E5%A0%82%E5%A4%8D%E4%B9%A0%E4%B8%8E%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%A2%98%EF%BC%88%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E9%AB%98%E7%BA%A7%EF%BC%89/" rel="bookmark" title="宋红康_第08章：面向对象-高级">宋红康_第08章：面向对象-高级</a></li><li><a href="/java/java-se/java-excise/%E7%AC%AC09%E7%AB%A0%EF%BC%9A%E9%9A%8F%E5%A0%82%E5%A4%8D%E4%B9%A0%E4%B8%8E%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%A2%98%EF%BC%88%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%EF%BC%89/" rel="bookmark" title="宋红康_第09章：异常处理">宋红康_第09章：异常处理</a></li><li><a href="/java/java-se/java-excise/%E7%AC%AC10%E7%AB%A0%EF%BC%9A%E9%9A%8F%E5%A0%82%E5%A4%8D%E4%B9%A0%E4%B8%8E%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%A2%98%EF%BC%88%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%89/" rel="bookmark" title="宋红康_第10章：多线程">宋红康_第10章：多线程</a></li><li><a href="/java/java-se/java-excise/%E7%AC%AC11%E7%AB%A0%EF%BC%9A%E9%9A%8F%E5%A0%82%E5%A4%8D%E4%B9%A0%E4%B8%8E%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%A2%98%EF%BC%88%E5%B8%B8%E7%94%A8%E7%B1%BB%E4%B8%8E%E5%9F%BA%E7%A1%80API%EF%BC%89/" rel="bookmark" title="宋红康_第11章：常用类与基础API">宋红康_第11章：常用类与基础API</a></li><li class="active"><a href="/java/java-se/java-excise/%E7%AC%AC12%E7%AB%A0%EF%BC%9A%E9%9A%8F%E5%A0%82%E5%A4%8D%E4%B9%A0%E4%B8%8E%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%A2%98%EF%BC%88%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%EF%BC%89/" rel="bookmark" title="宋红康_第12章：集合框架">宋红康_第12章：集合框架</a></li><li><a href="/java/java-se/java-excise/%E7%AC%AC13%E7%AB%A0%EF%BC%9A%E9%9A%8F%E5%A0%82%E5%A4%8D%E4%B9%A0%E4%B8%8E%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%A2%98%EF%BC%88%E6%B3%9B%E5%9E%8B%EF%BC%89/" rel="bookmark" title="宋红康_第13章：泛型">宋红康_第13章：泛型</a></li><li><a href="/java/java-se/java-excise/%E7%AC%AC14%E7%AB%A0%EF%BC%9A%E9%9A%8F%E5%A0%82%E5%A4%8D%E4%B9%A0%E4%B8%8E%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%A2%98%EF%BC%88%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%EF%BC%89/" rel="bookmark" title="宋红康_第14章：数据结构与集合源码">宋红康_第14章：数据结构与集合源码</a></li><li><a href="/java/java-se/java-excise/%E7%AC%AC15%E7%AB%A0%EF%BC%9A%E9%9A%8F%E5%A0%82%E5%A4%8D%E4%B9%A0%E4%B8%8E%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%A2%98%EF%BC%88File%E7%B1%BB%E4%B8%8EIO%E6%B5%81%EF%BC%89/" rel="bookmark" title="宋红康_第15章：File类与IO流">宋红康_第15章：File类与IO流</a></li><li><a href="/java/java-se/java-excise/%E7%AC%AC16%E7%AB%A0%EF%BC%9A%E9%9A%8F%E5%A0%82%E5%A4%8D%E4%B9%A0%E4%B8%8E%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%A2%98%EF%BC%88%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%EF%BC%89/" rel="bookmark" title="宋红康_第16章：网络编程">宋红康_第16章：网络编程</a></li><li><a href="/java/java-se/java-excise/%E7%AC%AC17%E7%AB%A0%EF%BC%9A%E9%9A%8F%E5%A0%82%E5%A4%8D%E4%B9%A0%E4%B8%8E%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%A2%98%EF%BC%88%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%EF%BC%89/" rel="bookmark" title="宋红康_第17章：反射机制">宋红康_第17章：反射机制</a></li><li><a href="/java/java-se/java-excise/%E7%AC%AC18%E7%AB%A0%EF%BC%9A%E9%9A%8F%E5%A0%82%E5%A4%8D%E4%B9%A0%E4%B8%8E%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%A2%98%EF%BC%88JDK8-17%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%89/" rel="bookmark" title="宋红康_第18章：JDK8-17新特性">宋红康_第18章：JDK8-17新特性</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="范特东东东" data-src="/images/avatar.jpg"><p class="name" itemprop="name">范特东东东</p><div class="description" itemprop="description"></div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">65</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">21</span> <span class="name">分类</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hqeDE1OQ==" title="https:&#x2F;&#x2F;github.com&#x2F;hjx159"><i class="ic i-github"></i></span> <span class="exturl item xiaohongshu" data-url="aHR0cHM6Ly93d3cueGlhb2hvbmdzaHUuY29tL3VzZXIvcHJvZmlsZS81ZTAyYzhhZDAwMDAwMDAwMDEwMDFmM2U=" title="https:&#x2F;&#x2F;www.xiaohongshu.com&#x2F;user&#x2F;profile&#x2F;5e02c8ad0000000001001f3e"><i class="ic i-xiaohongshu2"></i></span> <span class="exturl item email" data-url="bWFpbHRvOjgxMjE0MzI4MEBxcS5jb20=" title="mailto:812143280@qq.com"><i class="ic i-envelope"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><a href="/categories/photography/" rel="section"><i class="ic i-photography"></i>摄影</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于我</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/java/java-se/java-excise/%E7%AC%AC11%E7%AB%A0%EF%BC%9A%E9%9A%8F%E5%A0%82%E5%A4%8D%E4%B9%A0%E4%B8%8E%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%A2%98%EF%BC%88%E5%B8%B8%E7%94%A8%E7%B1%BB%E4%B8%8E%E5%9F%BA%E7%A1%80API%EF%BC%89/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/java/java-se/java-excise/%E7%AC%AC13%E7%AB%A0%EF%BC%9A%E9%9A%8F%E5%A0%82%E5%A4%8D%E4%B9%A0%E4%B8%8E%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%A2%98%EF%BC%88%E6%B3%9B%E5%9E%8B%EF%BC%89/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/java/" title="分类于 Java">Java</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/" title="分类于 Java基础">Java基础</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/java-knowledge/" title="分类于 Java基础-知识点">Java基础-知识点</a></div><span><a href="/java/java-se/java-knowledge/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E5%AE%8B%E7%BA%A2%E5%BA%B7_%E7%AC%AC02%E7%AB%A0_%E5%8F%98%E9%87%8F%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6/" title="宋红康_第02章_变量与运算符">宋红康_第02章_变量与运算符</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/java/" title="分类于 Java">Java</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/" title="分类于 Java基础">Java基础</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/java-excise/" title="分类于 Java基础-真题">Java基础-真题</a></div><span><a href="/java/java-se/java-excise/%E7%AC%AC10%E7%AB%A0%EF%BC%9A%E9%9A%8F%E5%A0%82%E5%A4%8D%E4%B9%A0%E4%B8%8E%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%A2%98%EF%BC%88%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%89/" title="宋红康_第10章：多线程">宋红康_第10章：多线程</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/photography/" title="分类于 摄影">摄影</a></div><span><a href="/photography/%E4%B8%80%E4%BA%9B%E8%93%9D%E8%89%B2/" title="一些蓝色">一些蓝色</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/java/" title="分类于 Java">Java</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/" title="分类于 Java基础">Java基础</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/java-knowledge/" title="分类于 Java基础-知识点">Java基础-知识点</a></div><span><a href="/java/java-se/java-knowledge/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E5%AE%8B%E7%BA%A2%E5%BA%B7_%E7%AC%AC16%E7%AB%A0_%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" title="宋红康_第16章_网络编程">宋红康_第16章_网络编程</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/interview-experience/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E9%9D%A2%E7%BB%8F/" title="未命名">未命名</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/framework/" title="分类于 常用框架">常用框架</a> <i class="ic i-angle-right"></i> <a href="/categories/framework/spring/" title="分类于 Spring">Spring</a></div><span><a href="/framework/spring/spring6/" title="尚硅谷 Spring6">尚硅谷 Spring6</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/java/" title="分类于 Java">Java</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/" title="分类于 Java基础">Java基础</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/java-excise/" title="分类于 Java基础-真题">Java基础-真题</a></div><span><a href="/java/java-se/java-excise/%E7%AC%AC08%E7%AB%A0%EF%BC%9A%E9%9A%8F%E5%A0%82%E5%A4%8D%E4%B9%A0%E4%B8%8E%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%A2%98%EF%BC%88%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E9%AB%98%E7%BA%A7%EF%BC%89/" title="宋红康_第08章：面向对象-高级">宋红康_第08章：面向对象-高级</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/java/" title="分类于 Java">Java</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/" title="分类于 Java基础">Java基础</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/java-knowledge/" title="分类于 Java基础-知识点">Java基础-知识点</a></div><span><a href="/java/java-se/java-knowledge/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E5%AE%8B%E7%BA%A2%E5%BA%B7_%E7%AC%AC07%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E8%BF%9B%E9%98%B6%EF%BC%89/" title="宋红康_第07章_面向对象编程(进阶)">宋红康_第07章_面向对象编程(进阶)</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/database/" title="分类于 数据库">数据库</a></div><span><a href="/database/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" title="数据库总结">数据库总结</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/java/" title="分类于 Java">Java</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/" title="分类于 Java基础">Java基础</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/java-excise/" title="分类于 Java基础-真题">Java基础-真题</a></div><span><a href="/java/java-se/java-excise/%E7%AC%AC01%E7%AB%A0%EF%BC%9A%E9%9A%8F%E5%A0%82%E5%A4%8D%E4%B9%A0%E4%B8%8E%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%A2%98%EF%BC%88Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0%EF%BC%89/" title="宋红康_第01章：Java语言概述">宋红康_第01章：Java语言概述</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">范特东东东 @ fantedong</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">1.9m 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">28:49</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"java/java-se/java-excise/第12章：随堂复习与企业真题（集合框架）/",favicon:{show:"(●´3｀●)欢迎回来",hide:"(〃＞皿＜)你快回来"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hrmmi -->