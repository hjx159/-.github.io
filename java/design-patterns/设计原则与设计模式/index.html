<!-- build time:Sun Mar 10 2024 01:40:03 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="水文 & 摄影" href="http://example.com/rss.xml"><link rel="alternate" type="application/atom+xml" title="水文 & 摄影" href="http://example.com/atom.xml"><link rel="alternate" type="application/json" title="水文 & 摄影" href="http://example.com/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><link rel="canonical" href="http://example.com/java/design-patterns/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><title>设计原则与设计模式 - 设计模式 - Java | fantedong = 水文 & 摄影 = 为了能更好地查看图片，你需要一点魔法</title><meta name="generator" content="Hexo 6.3.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">设计原则与设计模式</h1><div class="meta"><span class="item" title="创建时间：2024-03-08 00:00:00"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2024-03-08T00:00:00+08:00">2024-03-08</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>11k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>10 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">fantedong</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><img src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20220520174508815.png"></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/java/" itemprop="item" rel="index" title="分类于 Java"><span itemprop="name">Java</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/java/design-patterns/" itemprop="item" rel="index" title="分类于 设计模式"><span itemprop="name">设计模式</span></a><meta itemprop="position" content="2"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://example.com/java/design-patterns/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="范特东东东"><meta itemprop="description" content="为了能更好地查看图片，你需要一点魔法, "></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="水文 & 摄影"></span><div class="body md" itemprop="articleBody"><h1 id="软件设计原则有哪些"><a class="anchor" href="#软件设计原则有哪些">#</a> （软件）设计原则有哪些</h1><p>常⽤的⾯向对象设计原则包括<font color="red">7 个</font>，这些原则并不是孤⽴存在的，它们相互依赖，相互补充。</p><table><thead><tr><th>设计原则</th><th>英文</th><th>简单定义</th></tr></thead><tbody><tr><td>开闭原则</td><td>Open Closed Principle（OCP）</td><td>对扩展开放，对修改关闭</td></tr><tr><td>单⼀职责原则</td><td>Single Responsibility Principle（SRP）</td><td>⼀个类只负责⼀个功能领域中的相应职责</td></tr><tr><td>里氏替换原则</td><td>Liskov Substitution Principle（LSP）</td><td>所有引用基类的地方，必须能透明地使用其子类的对象</td></tr><tr><td>依赖倒置原则</td><td>Dependency Inversion Principle（DIP）</td><td>依赖于抽象，不能依赖于具体实现</td></tr><tr><td>接口隔离原则</td><td>Interface Segregation Principle（ISP）</td><td>类之间的依赖关系应该建立在最小的接口上</td></tr><tr><td>合成 / 聚合复用原则</td><td>Composite/Aggregate Reuse Principle（C/ARP）</td><td>尽量使用合成 / 聚合，而不是通过继承达到复用的目的</td></tr><tr><td>最少知识原则 / 迪米特法则</td><td>Least Knowledge Principle（LKP）/Law of Demeter（LOD）</td><td>一个软件实体应当尽可能少的与其他实体发生相互作用</td></tr></tbody></table><h1 id="设计模式简介"><a class="anchor" href="#设计模式简介">#</a> 设计模式简介</h1><p>设计模式 (Design pattern) 代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。</p><p>设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结，是经过广泛接受、验证有效的解决问题的方法。<strong>使用设计模式是为了重用代码、让代码更易于理解、保证代码可靠性</strong>。毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。项目中合理地运用设计模式可以完美地解决很多问题，每种模式在现实中都有相应的原理来与之对应，每种模式都描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是设计模式能被广泛应用的原因。</p><h1 id="设计模式的分类"><a class="anchor" href="#设计模式的分类">#</a> 设计模式的分类</h1><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20220520174508815.png" alt="image-20220520174508815"></p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20240308140318516.png" alt="image-20240308140318516"></p><p>设计模式主要分为 3 大类，24 小种。</p><ul><li><p><strong>创建型</strong>（Creational）：在创建对象的同时 **<font color="red">隐藏对象的创建逻辑，不直接使用 new 来实例化对象</font>**，程序在判断需要创建哪些对象时更灵活。</p><ul><li><strong><font color="gree">单例模式</font></strong>（Singleton）：确保一个类<font color="red">只有一个实例</font>，提供全局访问点。例如配置管理、日志管理等。</li><li><strong><font color="gree">简单工厂模式</font></strong>：<font color="red">由工厂对象来创建实例</font>，根据<font color="red">传入的参数</font>决定创建哪种产品类的实例。</li><li><strong><font color="gree">工厂方法模式</font></strong>（Factory Method）：定义一个创建对象的<font color="red">抽象工厂</font>，内部声明了产品的<font color="red">生产接口</font>，将生产任务交给不同的<font color="red">派生类工厂</font>，让它们决定实例化哪个类。</li><li><strong><font color="gree">抽象工厂模式</font></strong>（Abstract Factory）：提供一个<font color="red">创建一系列相关或相互依赖对象</font>的接口，而无需指定它们具体的类。</li><li><strong><font color="gree">建造者模式</font></strong>（Builder）：将一个<font color="red">复杂对象</font>的构建过程与其表示分离，封装对象的构建过程，使同样的构建过程可以创建不同的表示。</li><li><font color="gree">原型模式</font>（Prototype）：通过<font color="red">复制现有实例</font>来创建新实例。</li></ul></li><li><p><strong>结构型</strong>（Structural）：**<font color="red">通过类和接口间的继承和引用</font>** 实现创建复杂结构的对象。</p><ul><li><strong><font color="gree">适配器模式</font></strong>（Adapter）：将一个类的<font color="red">接口转换</font>成客户希望的另一个接口，适用于接口不兼容的场景。</li><li><font color="gree">桥接模式</font>（Bridge）：<font color="red">将抽象部分和实现部分分离</font>，使它们可以独立变化。</li><li><font color="gree">组合模式</font>（Composite）：<font color="red">将对象组合成树形结构</font>，以表示 “部分 - 整体” 的层次结构。适用于处理对象的组合的场景。</li><li><font color="gree">装饰者模式</font>（Decorator）：<font color="red">动态地给一个对象添加额外功能</font>，而不希望影响其他对象时。</li><li><font color="gree">外观模式</font>（Facade）：为子系统中的一组接口<font color="red">提供一个统一的高层接口</font>。适用于简化复杂系统的场景。</li><li><font color="gree">享元模式</font>（Flyweight）：<font color="red">通过共享对象来减少内存占用</font>，适用于<font color="red">大量相似对象</font>的场景。可以共享一部分相同状态的对象以减少内存占用，如果有相同的业务请求，直接返回在内存中已有的对象，<font color="red">避免重新创建</font>。</li><li><font color="gree">代理模式</font>（Proxy）：为其他对象提供一种代理，以<font color="red">控制对其的访问</font>。适用于权限控制、延迟加载等场景。</li></ul></li><li><p><strong>行为型</strong>（Behavioral）：<strong><font color="red">通过类之间的不同通信方式实现不同行为</font></strong>。</p><ul><li><font color="gree">模板模式</font>（Template）：定义一个操作中的算法的骨架，而<font color="red">将一些步骤延迟到子类中实现</font>。</li><li><font color="gree">策略模式</font>（Strategy）：<font color="red">定义一系列算法</font>，将每个算法封装起来，并使它们可以互换。例如当一个类有多个行为，而且这些行为在运行时可以相互替代时，可以使用策略模式。</li><li><font color="gree">状态模式</font>（State）：允许对象在其<font color="red">内部状态发生变化时</font>，改变它的行为。当一个对象的行为取决于它的状态，并且它在运行时可以切换状态时，可以使用状态模式。</li><li><font color="gree">观察者模式</font>（Observer）：定义对象间<font color="red">一对多</font>的依赖关系，使得每当一个对象状态发生改变时，<font color="red">所有依赖于它的对象都得到通知并自动更新</font>。</li><li><font color="gree">命令模式</font>（Command）：<font color="red">将一个请求封装成一个对象</font>，从而让你使用不同的请求把客户端参数化，对请求排队或者记录请求日志，可以提供命令的撤销和恢复功能。例如 GUI、操作系统命令调用、需要对行为进行记录、撤销或重做、事务等处理。</li><li><strong><font color="gree">责任链模式</font></strong>（Chain of Responsibility）：<font color="red">为请求创建一条由多个接收者对象组成的链，并将请求沿着这条链传递，直到有对象处理它为止</font>。当系统中有多个对象可以处理同一请求，但具体哪个对象处理由运行时决定。使多个对象都有机会处理请求，从而避免了请求的发送者和接收者之间的耦合关系。例如拦截器、过滤器、数据清洗、规则引擎等。</li><li><font color="gree">解释器模式</font>（Interpreter）：给定一门语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来<font color="red">解释语言中的句子</font>。例如正则匹配、规则引擎、将字符串解析成对象等。</li><li><font color="gree">迭代器模式</font>（Iterator）：提供一种方法来<font color="red">顺序访问一个容器对象中的各个元素，而不暴露该对象的内部细节</font>。例如异构集合统一遍历方式。</li><li><font color="gree">中介者模式</font>（Mediator）：<font color="red">用一个中介对象来封装一系列的对象交互</font>，使得其他对象之间不需要显示地相互作用，而且可以独立地改变它们之间的交互。当系统中的多个对象之间存在复杂的相互依赖关系，而且这些关系难以维护时，可以使用中介者模式，例如聊天室、GUI 组件之间的通信等。</li><li><font color="gree">备忘录模式</font>（Memento）：在不破坏封装性的前提下，<font color="red">捕获一个对象的内部状态，并在该对象之外保存这个状态</font>，这样以后就可以将该对象恢复到原先保存的状态。例如撤销、恢复、历史记录等。</li><li><font color="gree">访问者模式</font>（Visitor）：表示一个作用于某对象结构中的各元素的操作，它使你可以在不改变各元素类的前提下定义作用于这些元素的新操作。适用于：需要对一个对象结构中的各元素进行不同的操作，但是不希望在该对象的类中添加这些操作时。</li></ul></li></ul><h1 id="单例模式"><a class="anchor" href="#单例模式">#</a> 单例模式</h1><h2 id="定义与特点"><a class="anchor" href="#定义与特点">#</a> 定义与特点</h2><p>单例模式属于创建型模式，<strong><font color="red">单例类在任何情况下都只存在一个实例</font></strong>，特点如下：</p><ul><li><font color="cornflowerblue">私有的构造方法</font></li><li><font color="cornflowerblue">私有的静态变量</font>：存储实例</li><li><font color="cornflowerblue">公有的静态方法</font>：获取实例</li></ul><p>优点：内存中只有一个实例，减少了开销，尤其是在频繁创建和销毁实例的情况下；可以避免对资源的多重占用。</p><p>缺点：<font color="red">没有抽象层，难以扩展</font>，与单一职责原则冲突。</p><h2 id="常见写法"><a class="anchor" href="#常见写法">#</a> 常见写法</h2><h3 id="饿汉式线程安全"><a class="anchor" href="#饿汉式线程安全">#</a> 饿汉式（线程安全）</h3><p><strong><font color="red">类在加载时就直接创建单例实例</font></strong>。</p><p>优点：<font color="red">线程安全，不用加锁</font>，执行效率高。</p><blockquote><p>基于<font color="red">类加载机制</font>避免了多线程的同步问题，但是如果类被不同的类加载器加载就会创建不同的实例。</p></blockquote><p>缺点：<font color="red">易产生垃圾对象，浪费内存空间</font>。</p><p>代码实现：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">/**</span></pre></td></tr><tr><td data-num="2"></td><td><pre> * 饿汉式单例测试</pre></td></tr><tr><td data-num="3"></td><td><pre> *</pre></td></tr><tr><td data-num="4"></td><td><pre> * @className: Singleton</pre></td></tr><tr><td data-num="5"></td><td><pre> * @date: 2021/6/7 14:32</pre></td></tr><tr><td data-num="6"></td><td><pre> */</pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span>  <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token comment">// 1、私有化构造⽅法</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token comment">// 2、定义⼀个私有的静态变量，指向自己类型</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token comment">// 3、对外提供⼀个公有的静态方法，获取实例</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token keyword">return</span> instance<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>这种情况的单例模式<font color="red">容易被反射破坏</font>：</p><blockquote><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20240309161137415.png" alt="image-20240309161137415"></p></blockquote><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 使用反射破坏单例</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token comment">// 获取空参构造方法（通过反射机制可以调用内部的 private 属性 / 方法 / 构造器）</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token class-name">Constructor</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Singleton</span><span class="token punctuation">></span></span> declaredConstructor <span class="token operator">=</span> <span class="token class-name">Singleton</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getDeclaredConstructor</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token comment">// 将空参构造方法设置为强制访问</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        declaredConstructor<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token comment">// 创建实例</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token class-name">Singleton</span> singleton <span class="token operator">=</span> declaredConstructor<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>		</pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"反射创建的实例"</span> <span class="token operator">+</span> singleton<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>		<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"正常创建的实例"</span> <span class="token operator">+</span> <span class="token class-name">Singleton</span><span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"正常创建的实例"</span> <span class="token operator">+</span> <span class="token class-name">Singleton</span><span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>输入结果如下，可见<font color="red">创建了多个单例实例</font>：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre>反射创建的实例</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name"><span class="token namespace">com<span class="token punctuation">.</span>example<span class="token punctuation">.</span>spring<span class="token punctuation">.</span>demo<span class="token punctuation">.</span>single<span class="token punctuation">.</span></span>Singleton</span><span class="token annotation punctuation">@6267c3bb</span></pre></td></tr><tr><td data-num="3"></td><td><pre>正常创建的实例</pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token class-name"><span class="token namespace">com<span class="token punctuation">.</span>example<span class="token punctuation">.</span>spring<span class="token punctuation">.</span>demo<span class="token punctuation">.</span>single<span class="token punctuation">.</span></span>Singleton</span><span class="token annotation punctuation">@533ddba</span></pre></td></tr><tr><td data-num="5"></td><td><pre>正常创建的实例</pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token class-name"><span class="token namespace">com<span class="token punctuation">.</span>example<span class="token punctuation">.</span>spring<span class="token punctuation">.</span>demo<span class="token punctuation">.</span>single<span class="token punctuation">.</span></span>Singleton</span><span class="token annotation punctuation">@533ddba</span></pre></td></tr></table></figure><h3 id="懒汉式线程不安全"><a class="anchor" href="#懒汉式线程不安全">#</a> 懒汉式（线程不安全）</h3><p><strong><font color="red">使用的时候再创建单例实例</font></strong>。</p><p>优点：懒加载</p><p>缺点：<font color="red">线程不安全</font>，在多线程环境是无法保证单例的</p><p>代码实现:</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">/**</span></pre></td></tr><tr><td data-num="2"></td><td><pre> * 懒汉式单例，线程不安全</pre></td></tr><tr><td data-num="3"></td><td><pre>*</pre></td></tr><tr><td data-num="4"></td><td><pre> * @className: Singleton</pre></td></tr><tr><td data-num="5"></td><td><pre> * @date: 2021/6/7 14:32</pre></td></tr><tr><td data-num="6"></td><td><pre> */</pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span>  <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token comment">// 1、私有化构造⽅法</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token comment">// 2、定义⼀个私有的静态变量，指向自身类型</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> instance<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token comment">// 3、对外提供⼀个公共的⽅法，获取实例</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token comment">// 判断为 null 的时候再创建对象</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>            instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>        <span class="token comment">// 判断为 not null 的时候直接返回对象</span></pre></td></tr><tr><td data-num="19"></td><td><pre>        <span class="token keyword">return</span> instance<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="21"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><font color="red">容易被多线程破坏</font>，测试代码如下：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>            <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"多线程创建的单例："</span> <span class="token operator">+</span>  <span class="token class-name">Singleton</span><span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>            <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>输出结果如下，可见<font color="red">创建了多个单例实例</font>：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre>多线程创建的单例：</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name"><span class="token namespace">com<span class="token punctuation">.</span>example<span class="token punctuation">.</span>spring<span class="token punctuation">.</span>demo<span class="token punctuation">.</span>single<span class="token punctuation">.</span></span>Singleton</span><span class="token annotation punctuation">@18396bd5</span></pre></td></tr><tr><td data-num="3"></td><td><pre>多线程创建的单例：</pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token class-name"><span class="token namespace">com<span class="token punctuation">.</span>example<span class="token punctuation">.</span>spring<span class="token punctuation">.</span>demo<span class="token punctuation">.</span>single<span class="token punctuation">.</span></span>Singleton</span><span class="token annotation punctuation">@7f23db98</span></pre></td></tr><tr><td data-num="5"></td><td><pre>多线程创建的单例：</pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token class-name"><span class="token namespace">com<span class="token punctuation">.</span>example<span class="token punctuation">.</span>spring<span class="token punctuation">.</span>demo<span class="token punctuation">.</span>single<span class="token punctuation">.</span></span>Singleton</span><span class="token annotation punctuation">@5000d44</span></pre></td></tr></table></figure><h3 id="懒汉式线程安全"><a class="anchor" href="#懒汉式线程安全">#</a> <mark>懒汉式（线程安全）</mark></h3><h4 id="方式一synchronized-加锁"><a class="anchor" href="#方式一synchronized-加锁">#</a> 方式一：synchronized 加锁</h4><p><strong><font color="red">通过 <code>synchronized</code> 关键字加锁来保证线程安全</font></strong>，既可以添加在方法上面，也可以添加在代码块上面。</p><p>优点：懒加载，线程安全</p><p>缺点：<font color="red">每一次调用 getInstance () 获取实例时都需要加锁和释放锁</font>，效率较低</p><p>这里演示将 synchronized 关键字添加在方法上面，代码实现如下:</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">/**</span></pre></td></tr><tr><td data-num="2"></td><td><pre> * 懒汉式单例，⽅法上⾯添加 synchronized 保证线程安全</pre></td></tr><tr><td data-num="3"></td><td><pre>*</pre></td></tr><tr><td data-num="4"></td><td><pre> * @className: Singleton</pre></td></tr><tr><td data-num="5"></td><td><pre> * @date: 2021/6/7 14:32</pre></td></tr><tr><td data-num="6"></td><td><pre> */</pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span>  <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token comment">// 1、私有化构造⽅法</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token comment">// 2、定义⼀个私有的静态变量，指向⾃⼰类型</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> instance<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token comment">// 3、对外提供⼀个公共的方法，获取实例（添加 synchronized 关键字加锁）</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>            instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token keyword">return</span> instance<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h4 id="方式二双重检查锁dcl"><a class="anchor" href="#方式二双重检查锁dcl">#</a> 方式二：双重检查锁（DCL）</h4><blockquote><p>double-checked locking</p></blockquote><p><strong><font color="red">双重检查指的是两次空判断，锁指的仍然是 <code>synchronized</code> 加锁</font></strong>。</p><p>优点︰懒加载，线程安全，效率较高</p><p>缺点︰实现较复杂</p><p>代码实现如下：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">/**</span></pre></td></tr><tr><td data-num="2"></td><td><pre> * 双重检查锁（DCL， 即 double-checked locking）</pre></td></tr><tr><td data-num="3"></td><td><pre>*</pre></td></tr><tr><td data-num="4"></td><td><pre> * @className: Singleton</pre></td></tr><tr><td data-num="5"></td><td><pre> * @date: 2021/6/7 14:32</pre></td></tr><tr><td data-num="6"></td><td><pre> */</pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token comment">// 1、私有化构造⽅法</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token comment">// 2、定义⼀个私有的静态变量，指向自己类型（volatile 表明该变量是共享且不稳定的，可以避免线程从自己工作内存的高速缓存中读写变量的值，要求每次读写都需要到主内存中进行，从而保证变量的线程可见性；此外，编译器和处理器会禁止对该 volatile 修饰的变量进行指令重排，从而保证程序在多线程环境下的正确性）</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> instance<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token comment">// 3、对外提供⼀个公共的静态方法，获取实例</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token comment">// 第⼀重检查是否为 null</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>            <span class="token comment">// 使用 synchronized 加锁！！！！！！！</span></pre></td></tr><tr><td data-num="17"></td><td><pre>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token class-name">Singleton</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>                <span class="token comment">// 第⼆重检查是否为 null</span></pre></td></tr><tr><td data-num="19"></td><td><pre>                <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>                    <span class="token comment">//new 关键字创建对象不是原子操作</span></pre></td></tr><tr><td data-num="21"></td><td><pre>                    instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>                <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>        <span class="token keyword">return</span> instance<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="27"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>第一重空判断：</p><ul><li><p>如果实例已经存在，就直接返回这个实例，不再需要进行同步操作</p></li><li><p>如果实例还没创建，才会进入同步块去创建实例</p><blockquote><p>同步块：目的是为了防止有多个线程同时调用导致生成多个实例，使得每次只能有一个线程访问同步块内容。当第一个线程抢到锁的调用获取了实例之后，这个实例就会被创建，之后其他线程的所有调用都不会进入同步块，直接在第一重判断就返回了单例。</p></blockquote></li></ul><p>第二重空判断：当多个线程一起到达锁位置时，进行锁竞争，其中一个线程获取锁，如果是第一次进入则为 null，则会创建单例对象，然后释放锁。<strong><font color="red">其他线程获取锁后，就会被第二重空判断拦截，从而直接返回已创建的单例对象</font></strong>。</p><p>其中最关键的一个点就是 <code>volatile</code> 关键字的使用，被它修饰的变量意味着是共享且不稳定的，会拥有两个特性：</p><ul><li><p><strong><font color="red">线程可见性</font></strong>：可以避免线程从自己本地内存的高速缓存中读写变量副本的值，而是<font color="red">强制到主内存中读写该变量本身的值</font>，从而保证该变量的线程可见性。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/jmm2.png" alt="JMM(Java 内存模型)强制在主存中进行读取"></p></li><li><p><strong><font color="red">禁止指令重排</font></strong>：JVM 为了优化，会在不影响正确性的前提下，调整代码的执行顺序，但在多线程下指令重排会影响正确性！但是，<font color="red">编译器和处理器会禁止对 <code>volatile</code> 修饰的变量进行指令重排，从而保证程序在多线程环境下的正确性</font>。</p></li></ul><p>因此就能理解这里为什么要使用 volatile 了，因为 **<font color="red"> new 关键字创建对象的过程不是原子操作</font>**， <code>instance = new Singleton();</code> 这行代码分为三步执行：</p><ol><li>在堆内存中为 <code>instance</code> 分配内存空间</li><li>调用构造方法，初始化对象 <code>instance</code></li><li>将 <code>instance</code> 指向分配的内存地址</li></ol><p>对应字节码指令如下（17、20、21、24）：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20240309193545865.png" alt="image-20240309193545865"></p><p>由于 JVM 具有指令重排的特性，执行顺序有可能变成 1-&gt;3-&gt;2。<font color="red">指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例</font>。例如，线程 T1 执行了 1 和 3，此时 T2 调用 getInstance () 后在第一重空判断发现 instance 不为空，因此直接返回 instance ，<font color="red">但此时 instance 还未被初始化</font>，这就是著名的 <strong>DCL 失效问题</strong>。</p><p>当我们在引用变量上面添加 volatile 关键字以后，会<font color="red">通过在创建对象指令的前后添加内存屏障来禁止指令重排序</font>，就可以避免这个问题。而且对 volatile 修饰的<font color="red">变量的修改对其他任何线程都是可见的</font>。</p><h4 id="方式三静态内部类"><a class="anchor" href="#方式三静态内部类">#</a> 方式三：静态内部类</h4><p>优点：<font color="red">懒加载、线程安全、效率较高、实现简单</font></p><p>代码实现：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">/**</span></pre></td></tr><tr><td data-num="2"></td><td><pre> * 静态内部类实现单例</pre></td></tr><tr><td data-num="3"></td><td><pre>*</pre></td></tr><tr><td data-num="4"></td><td><pre> * @className: Singleton</pre></td></tr><tr><td data-num="5"></td><td><pre> * @date: 2021/6/7 14:32</pre></td></tr><tr><td data-num="6"></td><td><pre> */</pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token comment">// 1、私有化构造⽅法</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    </pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token comment">// 2、对外提供获取实例的公共静态方法</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token keyword">return</span> <span class="token class-name">InnerClass</span><span class="token punctuation">.</span><span class="token constant">INSTANCE</span><span class="token punctuation">;</span> <span class="token comment">// 返回静态内部类的静态成员变量！</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token comment">// 3、定义私有的静态内部类</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">InnerClass</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token comment">// 私有的静态变量</span></pre></td></tr><tr><td data-num="18"></td><td><pre>        <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token constant">INSTANCE</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="19"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><hr><p>懒加载如何理解？</p><p>首先，了解一下<strong>类的生命周期</strong>。类是在运行期间<font color="red">第一次使用时才动态加载</font>的（不使用不加载），而不是一次性加载所有类，因为一次性加载会占用很多的内存，<font color="red">加载的类信息存放于方法区中</font>。类从被加载到虚拟机内存中开始，到卸载出内存为止，类的生命周期可概括为 7 个阶段，如下图所示。</p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/lifecycle-of-a-class.png" alt="一个类的完整生命周期" style="zoom:67%"><p>其中，<font color="red">虚拟机加载 Class 文件的过程主要分为三步：加载、链接、初始化</font>。《虚拟机规范》要求<font color="red"><u>有且仅有</u>以下 5 种 “<strong>类的主动引用</strong>” 情况，必须立即对类进行初始化</font>：</p><ol><li>遇到 <code>new</code> 、 <code>getstatic</code> 、 <code>putstatic</code> 、 <code>invokestatic</code> 这 4 条字节码指令时，分别对应以下 Java 代码场景：<ul><li><font color="red">使用 new 关键字实例化对象</font></li><li><font color="red">读取 / 设置一个类的静态字段</font>（ <code>final</code> 修饰除外，被 final 修饰的静态字段是常量，已在编译期把结果放入常量池）</li><li><font color="red">调用一个类的静态方法</font></li></ul></li><li>使用 <code>java.lang.reflect</code> 包方法对类进行<font color="red">反射调用</font>的时候。</li><li>当初始化一个类的时候，如果发现其<font color="red">父类还没有初始化</font>，则需要先触发其父类的初始化。</li><li>当虚拟机启动时，用户需要指定一个<font color="red">要执行的主类</font>（包含 main () 的那个类)，虚拟机会先初始化这个主类。</li><li>当使用 JDK 1.7 的动态语言支持时，如果一个 <code>java.lang.invoke.MethodHandle</code> 实例最后的解析结果是 REF_getStatic 、REF_putStatic 、REF_invokeStatic 的方法句柄，则需要先触发这个方法句柄所对应的类的初始化。</li></ol><p><font color="red">除此之外的所有引用都不会立即对类进行初始化，称为<strong>类的被动引用</strong></font>。</p><p>首先了解一下线程共享的 <code>方法区</code> 。</p><ul><li><code>常量池表</code> ：<font color="red">JVM 为每个已加载的类维护一个常量池表，存储了类在<u>编译期间</u>生成的符号引用、字面量</font>。<ul><li>符号引用：类、字段、方法、接口等的符号引用</li><li>字面量：基本数据类型、String 类型常量、声明为 final 的常量值等</li></ul></li><li><code>运行时常量池</code> ：<ul><li><font color="red">常量池中的数据会在<u>对应类被加载</u>后放入运行时常量池</font></li><li><font color="red">类在<u>解析阶段</u>将这些符号引用替换成直接引用</font></li><li>除了在编译期生成的常量，还允许动态生成常量，例如 String 类的 intern ()</li></ul></li></ul><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/68747470733a2f2f7365617a65616e2e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f696d672f4a6176612f4a564d2d4a617661382545352538362538352545352541442539382545372542422539332545362539452538342545352539422542452e706e67" alt="img"></p><center>Java8 内存结构图</center><p>因此，Singleton 类不会在加载时就被初始化，那么当 Singleton 类的静态方法 getInstance () 被调用时，它才会被初始化。InnerClass 才会被放入 Singleton 的运行时常量池里，并把符号引用替换为直接引用，这时静态对象 INSTANCE 也真正被创建，然后再被 getInstance () 方法返回出去。</p><hr><p>线程安全如何实现？</p><p>在《深入理解 JAVA 虚拟机》中，有这么一句话:“虚拟机会保证一个类的<clinit>() 方法在多线程环境中被正确地加锁、同步。如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的<clinit>() 方法，其他线程都需要阻塞等待，直到活动线程执行<clinit>() 方法完毕。如果在一个类的<clinit>() 方法中有耗时很长的操作，就可能造成多个进程阻塞（需要注意的是，其他线程虽然会被阻塞，但如果执行<clinit>() 方法后，其他线程唤醒之后不会再次进入<clinit>() 方法。同一个加载器下，一个类型只会初始化一次。)，在实际应用中，这种阻塞往往是很隐蔽的。”</clinit></clinit></clinit></clinit></clinit></clinit></p><hr><p>从上面的分析可以看出 INSTANCE 在创建过程中是线程安全的，所以说静态内部类形式的单例既可保证线程安全，也能保证单例的唯一性，同时也延迟了单例的实例化。</p><h3 id="枚举单例"><a class="anchor" href="#枚举单例">#</a> 枚举单例</h3><p>在 Java 中，<font color="red">枚举类与普通类一样，都能拥有字段与方法</font>，而且<font color="red">枚举类的实例创建是线程安全的，在任何情况下都是一个单例</font>，因此使用枚举类（ <code>enum</code> ）可以非常方便地实现单例模式：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">Singleton</span> <span class="token punctuation">&#123;</span> <span class="token comment">//enum 表示枚举类</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token constant">INSTANCE</span><span class="token punctuation">;</span> <span class="token comment">// 这是枚举类的单个实例</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token comment">// 在这里可以添加其他成员变量和方法</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token comment">// 实现单例模式的操作</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Singleton instance is doing something."</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>在这个例子中，<strong><font color="red"> <code>Singleton</code> 是一个枚举类， <code>INSTANCE</code> 是该枚举类的单个实例。由于枚举类的特性，这个实例是在程序启动时被初始化（类似于饿汉式），并且在整个程序生命周期内只有一个</font></strong>。</p><p>使用时，可以通过 <code>Singleton.INSTANCE</code> 来访问单例对象，并调用其中的方法：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token comment">// 访问单例实例</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token class-name">Singleton</span> singleton <span class="token operator">=</span> <span class="token class-name">Singleton</span><span class="token punctuation">.</span><span class="token constant">INSTANCE</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        </pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token comment">// 调用单例方法</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        singleton<span class="token punctuation">.</span><span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>特点：<font color="red">类似于饿汉式</font>，简单，高效，<strong><font color="red">线程安全</font></strong>，<strong><font color="red">可以避免通过反射破坏枚举单例</font></strong></p><ul><li><font color="red">枚举类天生就是线程安全的，且只会被加载一次</font></li><li>防止反射和反序列化时破坏单例的问题，因为<font color="red">枚举类型不会在反序列化时重新创建新的对象，会报错</font></li></ul><hr><center>枚举类的实例创建为什么是线程安全的？</center><p>利用 <code>javap</code> 命令反编译枚举类：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre>javap <span class="token class-name">Singleton</span><span class="token punctuation">.</span><span class="token keyword">class</span></pre></td></tr></table></figure><p>得到如下内容：</p><hr><center>枚举类的实例为什么都是单例？</center><h1 id="工厂模式"><a class="anchor" href="#工厂模式">#</a> 工厂模式</h1><h2 id="简单工厂模式"><a class="anchor" href="#简单工厂模式">#</a> 简单工厂模式</h2><p>目的是将客户程序与具体类解耦，<strong><font color="red">由⼀个工厂类来创建实例</font></strong>，根据传入工厂的不同参数来实例化不同产品类，不需要客户端关注创建逻辑。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20240309140922573.png" alt="image-20240309140922573"></p><center>简单工厂模式的 UML 类图</center><p>优点：简单粗暴，适用于创建对象较少的情况。</p><p>缺点：<font color="red">如果要增加新产品，就需要修改工厂类的判断逻辑，违背开闭原则</font>。而且<font color="red">产品多的话会使工厂类比较复杂</font>。</p><p>举个例子， <code>Calendar</code> 抽象类的 getInstance 方法，调用 createCalendar 方法根据不同的地区参数创建不同的日历对象；Spring 中的 <code>BeanFactory</code> 使用简单工厂模式，根据传入一个唯一的标识来获得 Bean 对象。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AnimalFactory</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Animal</span> <span class="token function">createAnimal</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">"cat"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Cat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">"dog"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Dog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">"cow"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Dog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h2 id="工厂方法模式"><a class="anchor" href="#工厂方法模式">#</a> 工厂方法模式</h2><p>对简单工厂模式进行抽象，该模式 **<font color="red">定义了一个抽象工厂类，其内部声明了抽象的生产方法。具体要实例化哪个类由派生工厂类决定，它们通过继承该抽象工厂类并重写实现其内部抽象生产方法来实例化不同的产品类</font>**。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20240309153832142.png" alt="image-20240309153832142"></p><center>工厂方法模式的 UML 类图</center><p>优点：不用通过指定产品类型来创建对象了，减轻了工厂类的负担，支持增加新产品，符合开放 - 封闭原则。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 抽象的动物工厂</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">AnimalFactory</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token class-name">Animal</span> <span class="token function">createAnimal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 抽象的生产方法（接口）</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token comment">// 具体的工厂实现类</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CatFactory</span> <span class="token keyword">extends</span> <span class="token class-name">AnimalFactory</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 继承抽象工厂类</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token annotation punctuation">@Override</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">Animal</span> <span class="token function">createAnimal</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 重写抽象工厂方法</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Cat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DogFactory</span> <span class="token keyword">extends</span> <span class="token class-name">AnimalFactory</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token annotation punctuation">@Override</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">Animal</span> <span class="token function">createAnimal</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Dog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h2 id="抽象工厂模式"><a class="anchor" href="#抽象工厂模式">#</a> 抽象工厂模式</h2><p>简单工厂模式和工厂方法模式不管怎么拆分 / 抽象工厂，都只是针对一类产品，如果要生成另一种产品，就比较难办了！因此，抽象工厂模式中<font color="red">抽象工厂类中定义了多类产品，而不是一类产品</font>。</p><p>抽象工厂模式通过 **<font color="red">在抽象工厂类中增加创建产品的抽象方法接口</font>**，并在具体子工厂中实现新加产品的创建，当然前提是子工厂支持生产该产品。否则继承的这个接口可以什么也不干。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20240309153609323.png" alt="image-20240309153609323"></p><h2 id="工厂模式小结"><a class="anchor" href="#工厂模式小结">#</a> 工厂模式小结</h2><ul><li>简单工厂：用<font color="red">一个工厂对象</font>生产同一等级结构中的任意产品。</li><li>工厂方法：提供<font color="red">多个派生工厂</font>，用来创建不同的对象。</li><li>抽象工厂：用多个派生工厂对象生产<font color="red">不同产品族</font>的全部产品。</li></ul></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2024-03-10 01:34:00" itemprop="dateModified" datetime="2024-03-10T01:34:00+08:00">2024-03-10</time> </span><span id="java/design-patterns/设计原则与设计模式/" class="item leancloud_visitors" data-flag-title="设计原则与设计模式" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>范特东东东 <i class="ic i-at"><em>@</em></i>水文 & 摄影</li><li class="link"><strong>本文链接：</strong> <a href="http://example.com/java/design-patterns/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="设计原则与设计模式">http://example.com/java/design-patterns/设计原则与设计模式/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/photography/%E7%B4%AB%E7%AB%B9%E9%99%A2%E5%85%AC%E5%9B%AD/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;pic.imgdb.cn&#x2F;item&#x2F;65e5f89e9f345e8d036fa68a.jpg" title="紫竹院公园"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> 摄影</span><h3>紫竹院公园</h3></a></div><div class="item right"></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">1.</span> <span class="toc-text">（软件）设计原则有哪些</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AE%80%E4%BB%8B"><span class="toc-number">2.</span> <span class="toc-text">设计模式简介</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">3.</span> <span class="toc-text">设计模式的分类</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.</span> <span class="toc-text">单例模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E4%B8%8E%E7%89%B9%E7%82%B9"><span class="toc-number">4.1.</span> <span class="toc-text">定义与特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E5%86%99%E6%B3%95"><span class="toc-number">4.2.</span> <span class="toc-text">常见写法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A5%BF%E6%B1%89%E5%BC%8F%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="toc-number">4.2.1.</span> <span class="toc-text">饿汉式（线程安全）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%87%92%E6%B1%89%E5%BC%8F%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8"><span class="toc-number">4.2.2.</span> <span class="toc-text">懒汉式（线程不安全）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%87%92%E6%B1%89%E5%BC%8F%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="toc-number">4.2.3.</span> <span class="toc-text">懒汉式（线程安全）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F%E4%B8%80synchronized-%E5%8A%A0%E9%94%81"><span class="toc-number">4.2.3.1.</span> <span class="toc-text">方式一：synchronized 加锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F%E4%BA%8C%E5%8F%8C%E9%87%8D%E6%A3%80%E6%9F%A5%E9%94%81dcl"><span class="toc-number">4.2.3.2.</span> <span class="toc-text">方式二：双重检查锁（DCL）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F%E4%B8%89%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">4.2.3.3.</span> <span class="toc-text">方式三：静态内部类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E5%8D%95%E4%BE%8B"><span class="toc-number">4.2.4.</span> <span class="toc-text">枚举单例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="toc-number">5.</span> <span class="toc-text">工厂模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="toc-number">5.1.</span> <span class="toc-text">简单工厂模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F"><span class="toc-number">5.2.</span> <span class="toc-text">工厂方法模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="toc-number">5.3.</span> <span class="toc-text">抽象工厂模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E5%B0%8F%E7%BB%93"><span class="toc-number">5.4.</span> <span class="toc-text">工厂模式小结</span></a></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li class="active"><a href="/java/design-patterns/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="bookmark" title="设计原则与设计模式">设计原则与设计模式</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="范特东东东" data-src="/images/avatar.jpg"><p class="name" itemprop="name">范特东东东</p><div class="description" itemprop="description"></div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">63</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">22</span> <span class="name">分类</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hqeDE1OQ==" title="https:&#x2F;&#x2F;github.com&#x2F;hjx159"><i class="ic i-github"></i></span> <span class="exturl item xiaohongshu" data-url="aHR0cHM6Ly93d3cueGlhb2hvbmdzaHUuY29tL3VzZXIvcHJvZmlsZS81ZTAyYzhhZDAwMDAwMDAwMDEwMDFmM2U=" title="https:&#x2F;&#x2F;www.xiaohongshu.com&#x2F;user&#x2F;profile&#x2F;5e02c8ad0000000001001f3e"><i class="ic i-xiaohongshu2"></i></span> <span class="exturl item email" data-url="bWFpbHRvOjgxMjE0MzI4MEBxcS5jb20=" title="mailto:812143280@qq.com"><i class="ic i-envelope"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><a href="/categories/photography/" rel="section"><i class="ic i-photography"></i>摄影</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于我</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/java/" title="分类于 Java">Java</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/" title="分类于 Java基础">Java基础</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/java-knowledge/" title="分类于 Java基础-知识点">Java基础-知识点</a></div><span><a href="/java/java-se/java-knowledge/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E5%AE%8B%E7%BA%A2%E5%BA%B7_%E7%AC%AC10%E7%AB%A0_%E5%A4%9A%E7%BA%BF%E7%A8%8B/" title="宋红康_第10章_多线程">宋红康_第10章_多线程</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/java/" title="分类于 Java">Java</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/" title="分类于 Java基础">Java基础</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/java-excise/" title="分类于 Java基础-真题">Java基础-真题</a></div><span><a href="/java/java-se/java-excise/%E7%AC%AC09%E7%AB%A0%EF%BC%9A%E9%9A%8F%E5%A0%82%E5%A4%8D%E4%B9%A0%E4%B8%8E%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%A2%98%EF%BC%88%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%EF%BC%89/" title="宋红康_第09章：异常处理">宋红康_第09章：异常处理</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/java/" title="分类于 Java">Java</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/" title="分类于 Java基础">Java基础</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/java-excise/" title="分类于 Java基础-真题">Java基础-真题</a></div><span><a href="/java/java-se/java-excise/%E7%AC%AC11%E7%AB%A0%EF%BC%9A%E9%9A%8F%E5%A0%82%E5%A4%8D%E4%B9%A0%E4%B8%8E%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%A2%98%EF%BC%88%E5%B8%B8%E7%94%A8%E7%B1%BB%E4%B8%8E%E5%9F%BA%E7%A1%80API%EF%BC%89/" title="宋红康_第11章：常用类与基础API">宋红康_第11章：常用类与基础API</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/distributed-microservices/" title="分类于 分布式微服务">分布式微服务</a></div><span><a href="/distributed-microservices/ShardingSphere/" title="ShardingSphere">ShardingSphere</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/java/" title="分类于 Java">Java</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/" title="分类于 Java基础">Java基础</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/java-excise/" title="分类于 Java基础-真题">Java基础-真题</a></div><span><a href="/java/java-se/java-excise/%E7%AC%AC01%E7%AB%A0%EF%BC%9A%E9%9A%8F%E5%A0%82%E5%A4%8D%E4%B9%A0%E4%B8%8E%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%A2%98%EF%BC%88Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0%EF%BC%89/" title="宋红康_第01章：Java语言概述">宋红康_第01章：Java语言概述</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/java/" title="分类于 Java">Java</a> <i class="ic i-angle-right"></i> <a href="/categories/java/jvm/" title="分类于 JVM">JVM</a></div><span><a href="/java/jvm/JVM%E7%AC%94%E8%AE%B0/" title="JVM笔记">JVM笔记</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/java/" title="分类于 Java">Java</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/" title="分类于 Java基础">Java基础</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/java-knowledge/" title="分类于 Java基础-知识点">Java基础-知识点</a></div><span><a href="/java/java-se/java-knowledge/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E5%AE%8B%E7%BA%A2%E5%BA%B7_%E7%AC%AC06%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/" title="宋红康_第06章_面向对象编程（基础）">宋红康_第06章_面向对象编程（基础）</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/java/" title="分类于 Java">Java</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/" title="分类于 Java基础">Java基础</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/java-knowledge/" title="分类于 Java基础-知识点">Java基础-知识点</a></div><span><a href="/java/java-se/java-knowledge/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E5%AE%8B%E7%BA%A2%E5%BA%B7_%E7%AC%AC13%E7%AB%A0_%E6%B3%9B%E5%9E%8B/" title="宋红康_第13章_泛型(Generic)">宋红康_第13章_泛型(Generic)</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/java/" title="分类于 Java">Java</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/" title="分类于 Java基础">Java基础</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/java-knowledge/" title="分类于 Java基础-知识点">Java基础-知识点</a></div><span><a href="/java/java-se/java-knowledge/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E5%AE%8B%E7%BA%A2%E5%BA%B7_%E7%AC%AC16%E7%AB%A0_%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" title="宋红康_第16章_网络编程">宋红康_第16章_网络编程</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/distributed-microservices/" title="分类于 分布式微服务">分布式微服务</a></div><span><a href="/distributed-microservices/%E5%88%86%E5%B8%83%E5%BC%8FID&%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81&%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1&%E5%88%86%E5%B8%83%E5%BC%8F%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/" title="分布式ID&amp;分布式锁&amp;分布式事务&amp;分布式配置中心">分布式ID&分布式锁&分布式事务&分布式配置中心</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">范特东东东 @ fantedong</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">2m 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">29:36</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"java/design-patterns/设计原则与设计模式/",favicon:{show:"(●´3｀●)欢迎回来",hide:"(〃＞皿＜)你快回来"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hrmmi -->