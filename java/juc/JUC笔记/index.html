<!-- build time:Sat Apr 13 2024 20:46:06 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="水文 & 摄影" href="http://example.com/rss.xml"><link rel="alternate" type="application/atom+xml" title="水文 & 摄影" href="http://example.com/atom.xml"><link rel="alternate" type="application/json" title="水文 & 摄影" href="http://example.com/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><link rel="canonical" href="http://example.com/java/juc/JUC%E7%AC%94%E8%AE%B0/"><title>JUC 笔记 - JUC - Java | fantedong = 水文 & 摄影 = 为了能更好地查看图片，你需要一点魔法</title><meta name="generator" content="Hexo 6.3.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">JUC 笔记</h1><div class="meta"><span class="item" title="创建时间：2023-11-12 11:12:33"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2023-11-12T11:12:33+08:00">2023-11-12</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>83k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>1:16</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">fantedong</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><img src="https://s2.loli.net/2023/11/14/FGOQ6Jg9C8zwdAf.png"></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/java/" itemprop="item" rel="index" title="分类于 Java"><span itemprop="name">Java</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/java/juc/" itemprop="item" rel="index" title="分类于 JUC"><span itemprop="name">JUC</span></a><meta itemprop="position" content="2"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://example.com/java/juc/JUC%E7%AC%94%E8%AE%B0/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="范特东东东"><meta itemprop="description" content="为了能更好地查看图片，你需要一点魔法, "></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="水文 & 摄影"></span><div class="body md" itemprop="articleBody"><h1 id="java-并发概述"><a class="anchor" href="#java-并发概述">#</a> Java 并发概述</h1><hr><h2 id="什么是进程和线程"><a class="anchor" href="#什么是进程和线程">#</a> 什么是进程和线程？</h2><h3 id="何为进程"><a class="anchor" href="#何为进程">#</a> 何为进程？</h3><p><strong>进程是程序的一次执行过程，是系统进行资源分配的基本单位</strong>。系统运行一个程序即是一个进程从创建，运行到消亡的过程。</p><p>在 Java 中，当我们启动 main 函数时其实就是启动了一个 JVM 的进程，而 main 函数所在的线程就是这个进程中的一个线程，也称<font color="red">主线程</font>。</p><p>如下图所示，在 Windows 中通过查看任务管理器的方式，我们就可以清楚看到 Windows 当前运行的进程（ <code>.exe</code> 文件的运行）。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231008000329935.png" alt="进程示例图片-Windows"></p><h3 id="何为线程"><a class="anchor" href="#何为线程">#</a> 何为线程？</h3><p><strong>线程属于进程中的一个实体，是一个基本的 CPU 执行单元，是系统独立调度的基本单位</strong>。一个进程在其执行的过程中可以产生多个线程。与进程不同的是，<font color="red">同类的多个线程共享进程的<strong>堆</strong>和<strong>方法区</strong>资源，但每个线程有自己的<strong>程序计数器</strong>、<strong>虚拟机栈</strong>和<strong>本地方法栈</strong></font>。所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为<font color="red">轻量级进程</font>。</p><p>Java 程序天生就是多线程程序，我们可以通过 JMX 来看看一个普通的 Java 程序有哪些线程，代码如下。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MultiThread</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>		<span class="token comment">// 获取 Java 线程管理 MXBean</span></pre></td></tr><tr><td data-num="4"></td><td><pre>	<span class="token class-name">ThreadMXBean</span> threadMXBean <span class="token operator">=</span> <span class="token class-name">ManagementFactory</span><span class="token punctuation">.</span><span class="token function">getThreadMXBean</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>		<span class="token comment">// 不需要获取同步的 monitor 和 synchronizer 信息，仅获取线程和线程堆栈信息</span></pre></td></tr><tr><td data-num="6"></td><td><pre>		<span class="token class-name">ThreadInfo</span><span class="token punctuation">[</span><span class="token punctuation">]</span> threadInfos <span class="token operator">=</span> threadMXBean<span class="token punctuation">.</span><span class="token function">dumpAllThreads</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>		<span class="token comment">// 遍历线程信息，仅打印线程 ID 和线程名称信息</span></pre></td></tr><tr><td data-num="8"></td><td><pre>		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">ThreadInfo</span> threadInfo <span class="token operator">:</span> threadInfos<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>			<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"["</span> <span class="token operator">+</span> threadInfo<span class="token punctuation">.</span><span class="token function">getThreadId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"] "</span> <span class="token operator">+</span> threadInfo<span class="token punctuation">.</span><span class="token function">getThreadName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>		<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>	<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>上述程序输出如下（输出内容可能不同，不用太纠结下面每个线程的作用，只用知道 main 线程执行 main 方法即可）：</p><figure class="highlight text"><figcaption data-lang="text"></figcaption><table><tr><td data-num="1"></td><td><pre>[5] Attach Listener //添加事件</pre></td></tr><tr><td data-num="2"></td><td><pre>[4] Signal Dispatcher // 分发处理给 JVM 信号的线程</pre></td></tr><tr><td data-num="3"></td><td><pre>[3] Finalizer //调用对象 finalize 方法的线程</pre></td></tr><tr><td data-num="4"></td><td><pre>[2] Reference Handler //清除 reference 线程</pre></td></tr><tr><td data-num="5"></td><td><pre>[1] main //main 线程,程序入口</pre></td></tr></table></figure><p>从上面的输出内容可以看出：<strong>一个 Java 程序（进程）的运行是 main 线程和多个其他线程同时运行</strong>。</p><h2 id="进程和线程的关系区别优缺点"><a class="anchor" href="#进程和线程的关系区别优缺点">#</a> 进程和线程的关系，区别，优缺点？</h2><ul><li><strong>调度</strong>：线程是调度的基本单位（PC，状态码，通用寄存器，线程栈及栈指针）；进程是拥有资源的基本单位（打开文件，堆，静态区，代码段等）。</li><li><strong>并发性</strong>：一个进程内多个线程可以并发（最好和 CPU 核数相等）；多个进程可以并发。</li><li><strong>拥有资源</strong>：线程不拥有系统资源，但一个进程的多个线程可以共享隶属进程的资源；进程是拥有资源的独立单位。</li><li><strong>系统开销</strong>：线程创建销毁只需要处理 PC 值，状态码，通用寄存器值，线程栈及栈指针即可；进程创建和销毁需要重新分配及销毁 task_struct 结构。</li></ul><h3 id="图解进程与线程的关系"><a class="anchor" href="#图解进程与线程的关系">#</a> 图解进程与线程的关系</h3><p>下图是 Java 8 后的的内存结构（运行时数据区），通过下图我们从 JVM 的角度来说一下线程和进程之间的关系。</p><p><img data-src="https://oss.javaguide.cn/github/javaguide/java/jvm/java-runtime-data-areas-jdk1.8.png" alt="Java 运行时数据区域（JDK1.8 之后）"></p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231008002249305.png" alt="image-20231008002249305"></p><p>从上图可以看出：一个进程中可以有多个线程，多个线程共享进程的<strong>堆</strong>和<strong>方法区 (JDK1.8 之后的元空间)<strong> 资源，但是每个线程有自己的</strong>程序计数器</strong>、<strong>虚拟机栈</strong> 和 <strong>本地方法栈</strong>。</p><p>进程与线程的对比总结：</p><ul><li><strong>线程是进程划分成的更小的运行单位</strong>。</li><li>线程和进程最大的不同在于，<strong>各进程基本上是独立的，而各线程则不一定</strong>，因为同一进程中的线程极有可能会相互影响。</li><li><strong>线程执行开销小，上下文切换的成本低</strong>，但不利于资源的管理和保护；而进程正相反。</li></ul><h3 id="为什么程序计数器的私有的"><a class="anchor" href="#为什么程序计数器的私有的">#</a> 为什么程序计数器的私有的？</h3><p>程序计数器主要有下面两个作用：</p><ol><li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</li><li>在多线程的情况下，程序计数器用于<font color="red">记录当前线程执行的位置</font>，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</li></ol><p>需要注意的是，如果执行的是 native 方法，那么程序计数器记录的是 undefined 地址，<font color="red">只有执行的是 Java 代码时，程序计数器记录的才是下一条指令的地址</font>。</p><p>所以，程序计数器私有主要是<strong>为了线程切换后能恢复到正确的执行位置</strong>。</p><h3 id="为什么虚拟机栈和本地方法栈是私有的"><a class="anchor" href="#为什么虚拟机栈和本地方法栈是私有的">#</a> 为什么虚拟机栈和本地方法栈是私有的？</h3><ul><li><p>** 虚拟机栈：** 每个 Java 方法在执行之前会创建一个栈帧用于<font color="red">存储调用方法的局部变量表、操作数栈、常量池引用等信息</font>。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231008001952766.png" alt="image-20231008001952766"></p></li><li><p>** 本地方法栈：** 和虚拟机栈所发挥的作用非常相似，区别是：** 虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。** 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</p></li></ul><p>所以，<strong>为了保证线程中的局部变量不被别的线程访问到</strong>，虚拟机栈和本地方法栈是线程私有的。</p><h3 id="为什么堆和方法区是共享的"><a class="anchor" href="#为什么堆和方法区是共享的">#</a> 为什么堆和方法区是共享的？</h3><ul><li><strong>堆</strong>：是进程中最大的一块内存，主要用于<strong>存放新创建的对象</strong> (几乎所有对象都在这里分配内存)</li><li><strong>方法区</strong>：主要用于<strong>存放已被加载的类信息、常量等数据</strong>。</li></ul><h2 id="并发和并行的区别"><a class="anchor" href="#并发和并行的区别">#</a> 并发和并行的区别？</h2><ul><li><strong>并发</strong>：两个及两个以上的作业在同一 <strong>时间段</strong> 内执行。</li><li><strong>并行</strong>：两个及两个以上的作业在同一 <strong>时刻</strong> 执行。</li></ul><p>最关键的点是：是否是 <strong>同时</strong> 执行。</p><h2 id="同步和异步的区别"><a class="anchor" href="#同步和异步的区别">#</a> 同步和异步的区别？</h2><ul><li><strong>同步</strong>：发出一个调用之后，在没有得到结果之前，该调用就<strong>不可以返回，一直等待</strong></li><li><strong>异步</strong>：调用在发出之后，不用等待返回结果，该调用<strong>直接返回</strong></li></ul><h2 id="为什么要使用多线程"><a class="anchor" href="#为什么要使用多线程">#</a> 为什么要使用多线程？</h2><p>先从总体上来说：</p><ul><li><strong>从计算机底层来说：</strong> 线程可以比作是轻量级的进程，是程序执行的最小单位，<font color="red">线程间的切换和调度的成本远远小于进程</font>。另外，多核 CPU 时代意味着多个线程可以同时运行，这减少了线程上下文切换的开销。</li><li><strong>从当代互联网发展趋势来说：</strong> 现在的系统动不动就要求百万级甚至千万级的并发量，而<font color="red">多线程并发编程正是开发高并发系统的基础</font>，利用好多线程机制可以大大提高系统整体的并发能力以及性能。</li></ul><p>再深入到计算机底层来探讨：</p><ul><li><strong>单核时代</strong>：在单核时代多线程主要是<font color="red">为了提高单进程利用 CPU 和 IO 系统的效率</font>。 假设只运行了一个 Java 进程的情况，当我们请求 IO 的时候，如果 Java 进程中只有一个线程，此线程被 IO 阻塞则整个进程被阻塞。CPU 和 IO 设备只有一个在运行，那么可以简单地说系统整体效率只有 50%。当使用多线程的时候，一个线程被 IO 阻塞，其他线程还可以继续使用 CPU。从而提高了 Java 进程利用系统资源的整体效率。</li><li><strong>多核时代</strong>：多核时代多线程主要是<font color="red">为了提高进程利用多核 CPU 的能力</font>。举个例子：假如我们要计算一个复杂的任务，我们只用一个线程的话，不论系统有几个 CPU 核心，都只会有一个 CPU 核心被利用到。而创建多个线程，这些线程可以被映射到底层多个 CPU 上执行，在任务中的多个线程没有资源竞争的情况下，任务执行的效率会有显著性的提高，约等于（单核时执行时间 / CPU 核心数）。</li></ul><h2 id="多线程会带来什么问题"><a class="anchor" href="#多线程会带来什么问题">#</a> 多线程会带来什么问题？</h2><p>并发编程的目的就是为了能提高程序的执行效率，提高程序运行速度。但是并发编程并不总是能提高程序运行速度的，而且并发编程可能会遇到很多问题，比如：<font color="red">内存泄漏、死锁、线程不安全</font>等。</p><h2 id="如何理解线程安全和不安全"><a class="anchor" href="#如何理解线程安全和不安全">#</a> 如何理解线程安全和不安全？</h2><p>线程安全和不安全是在多线程环境下对于同一份数据的访问<font color="red">是否能保证共享资源的正确性和一致性</font>的描述。</p><ul><li>线程安全：在多线程环境下，对于同一份数据，不管有多少个线程同时访问，都能保证这份数据的正确性和一致性。</li><li>线程不安全：在多线程环境下，对于同一份数据，多个线程同时访问时可能会导致数据混乱、错误或者丢失。</li></ul><h2 id="单核-cpu-上运行多个线程效率一定会高吗"><a class="anchor" href="#单核-cpu-上运行多个线程效率一定会高吗">#</a> 单核 CPU 上运行多个线程效率一定会高吗？</h2><p>单核 CPU 同时运行多个线程的效率是否会高，<font color="red">取决于线程的类型和任务的性质</font>。</p><p>一般来说，有两种类型的线程：</p><ul><li><font color="cornflowerblue">CPU 密集型</font>：主要进行计算和逻辑处理，需要占用大量的 CPU 资源。</li><li><font color="cornflowerblue">IO 密集型</font>：主要进行输入输出操作，如读写文件、网络通信等，需要等待 IO 设备的响应，而不占用太多的 CPU 资源。</li></ul><p><font color="red">在单核 CPU 上，同一时刻只能有一个线程在运行，其他线程需要等待 CPU 的时间片分配</font>。如果线程是 CPU 密集型的，那么多个线程同时运行会导致频繁的线程切换，增加了系统的开销，降低了效率。如果线程是 IO 密集型的，那么多个线程同时运行可以利用 CPU 在等待 IO 时的空闲时间，提高了效率。</p><p>因此，<strong>对于单核 CPU 来说，如果任务是 CPU 密集型的，那么多线程会影响效率；如果任务是 IO 密集型的，那么多线程会提高效率</strong>。当然，这里的 “多” 也要适度，不能超过系统能够承受的上限。</p><h1 id="线程"><a class="anchor" href="#线程">#</a> 线程</h1><h2 id="线程的创建方式"><a class="anchor" href="#线程的创建方式">#</a> 线程的创建方式</h2><h3 id="继承-thread-类"><a class="anchor" href="#继承-thread-类">#</a> 继承 Thread 类</h3><p>Thread 创建线程方式：创建线程类，匿名内部类方式</p><ul><li><strong>start () 方法底层其实是给 CPU 注册当前线程，并且触发 run () 方法执行</strong></li><li>线程的启动必须调用 start () 方法，如果线程直接调用 run () 方法，相当于变成了普通类的执行，此时主线程将只有执行该线程</li><li>建议线程先创建子线程，主线程的任务放在之后，否则主线程（main）永远是先执行完</li></ul><p>Thread 构造器：</p><ul><li><code>public Thread()</code></li><li><code>public Thread(String name)</code></li></ul><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadDemo</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token class-name">Thread</span> t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>       	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span> <span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"main线程"</span> <span class="token operator">+</span> i<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token comment">//main 线程输出放在上面 就变成有先后顺序了，因为是 main 线程驱动的子线程运行</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">MyThread</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token annotation punctuation">@Override</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span> <span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"子线程输出："</span><span class="token operator">+</span>i<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>继承 Thread 类的优缺点：</p><ul><li>优点：编码简单</li><li>缺点：线程类已经继承了 Thread 类，<font color="red">无法继承其他类了</font>，功能不能通过继承拓展（单继承的局限性）</li></ul><h3 id="实现-runnable-接口"><a class="anchor" href="#实现-runnable-接口">#</a> 实现 Runnable 接口</h3><p>Runnable 创建线程方式：创建线程类，匿名内部类方式</p><p>Thread 的构造器：</p><ul><li><code>public Thread(Runnable target)</code></li><li><code>public Thread(Runnable target, String name)</code></li></ul><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadDemo</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token class-name">Runnable</span> target <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyRunnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token class-name">Thread</span> t1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span><span class="token string">"1号线程"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>		t1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token class-name">Thread</span> t2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//Thread-0</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyRunnable</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token annotation punctuation">@Override</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span> <span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"->"</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><strong>Thread 类本身也是实现了 Runnable 接口</strong>，Thread 类中持有 Runnable 的属性，执行线程 run 方法底层是调用 Runnable#run：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Thread</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">private</span> <span class="token class-name">Runnable</span> target<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    </pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>target <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>          	<span class="token comment">// 底层调用的是 Runnable 的 run 方法</span></pre></td></tr><tr><td data-num="7"></td><td><pre>            target<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>Runnable 方式的优缺点：</p><ul><li>缺点：代码复杂一点。</li><li>优点：<ol><li>线程任务类只是实现了 Runnable 接口，可以继续继承其他类，<font color="red">避免了单继承的局限性</font></li><li>同一个线程任务对象可以被包装成多个线程对象</li><li>适合多个线程去共享同一个资源</li><li>实现解耦操作，线程任务代码可以被多个线程共享，<font color="red">线程任务代码和线程独立</font></li><li>线程池可以放入实现 Runnable 或 Callable 线程任务对象</li></ol></li></ul><h3 id="实现-callable-接口"><a class="anchor" href="#实现-callable-接口">#</a> 实现 Callable 接口</h3><p>实现 Callable 接口：</p><ol><li>定义一个线程任务类实现 Callable 接口，声明线程执行的结果类型</li><li>重写线程任务类的 call 方法，这个方法可以直接返回执行的结果</li><li>创建一个 Callable 的线程任务对象</li><li>把 Callable 的线程任务对象<strong>包装成一个 FutureTask 对象</strong></li><li>把 FutureTask 对象包装成 Thread 对象</li><li>调用线程的 start () 方法启动线程</li></ol><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadDemo</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token class-name">Callable</span> call <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyCallable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token class-name">FutureTask</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> task <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FutureTask</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>call<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token class-name">Thread</span> t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>            <span class="token class-name">String</span> s <span class="token operator">=</span> task<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 获取 call 方法返回的结果（正常 / 异常结果）</span></pre></td></tr><tr><td data-num="9"></td><td><pre>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token punctuation">&#125;</span>  <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyCallable</span> <span class="token keyword">implements</span> <span class="token class-name">Callable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token annotation punctuation">@Override</span><span class="token comment">// 重写线程任务类方法</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>        <span class="token keyword">return</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"->"</span> <span class="token operator">+</span> <span class="token string">"Hello World"</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><code>public FutureTask(Callable&lt;V&gt; callable)</code> ：未来任务对象，在线程执行完后得到线程的执行结果</p><ul><li>FutureTask 就是 Runnable 对象，因为 <strong>Thread 类只能执行 Runnable 实例的任务对象</strong>，所以把 Callable 包装成未来任务对象</li><li>线程池部分详解了 FutureTask 的源码</li></ul><p><code>public V get()</code> ：同步等待 task 执行完毕的结果，如果在线程中获取另一个线程执行结果，会阻塞等待，用于线程同步</p><ul><li>get () 线程会阻塞等待任务执行完成</li><li>run () 执行完后会把结果设置到 FutureTask 的一个成员变量，get () 线程可以获取到该变量的值</li></ul><p>优缺点：</p><ul><li>优点：同 Runnable，并且<font color="red">能得到线程执行的结果</font></li><li>缺点：编码复杂</li></ul><h3 id="runnable-和-callable-的区别"><a class="anchor" href="#runnable-和-callable-的区别">#</a> Runnable 和 Callable 的区别？</h3><ol><li>接口类型：Runnable 是一个接口类型，而 Callable 是一个<font color="red">通用接口类型</font>。</li><li>返回值：Runnable 接口的 run () 方法没有返回值，它只能执行某个任务。Callable 接口的<font color="red"> call () 方法可以返回一个结果</font>。</li><li>异常处理：Runnable 接口的 run () 方法不能抛出任何已检查异常，而 Callable 接口的<font color="red"> call () 方法可以抛出异常</font>。</li><li>使用方式：Runnable 接口通常用于创建多线程任务，它不能直接返回结果或抛出异常。Callable 接口通常用于创建线程任务，它可以返回结果或抛出异常。</li><li>多线程执行返回的结果：Runnable 接口无法直接获取执行结果，而<font color="red"> Callable 接口通过 Future 接口的 get () 方法可以获取线程执行的结果</font>。</li></ol><h2 id="thread-类的常用-api"><a class="anchor" href="#thread-类的常用-api">#</a> Thread 类的常用 API</h2><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>public void <code>start()</code></td><td><strong>启动一个新线程，Java 虚拟机调用此线程的 run () 方法</strong></td></tr><tr><td>public void <code>run()</code></td><td>线程启动后，调用该方法</td></tr><tr><td>public void <code>setName(String name)</code></td><td>给当前线程取名字</td></tr><tr><td>public void <code>getName()</code></td><td>获取当前线程的名字。线程存在默认名称：子线程是 Thread - 索引，主线程是 main</td></tr><tr><td>public final int <code>getPriority()</code></td><td>返回此线程的优先级</td></tr><tr><td>public final void <code>setPriority(int priority)</code></td><td>更改此线程的优先级，常用 1 5 10</td></tr><tr><td>public void <code>interrupt()</code></td><td>中断这个线程，异常处理机制</td></tr><tr><td>public boolean <code>isInterrupted()</code></td><td>判断当前线程是否被打断，不清除打断标记</td></tr><tr><td>public final void <code>join()</code></td><td>等待这个线程结束</td></tr><tr><td>public final void <code>join(long millis)</code></td><td>等待这个线程死亡 millis 毫秒，0 意味着永远等待</td></tr><tr><td>public final native boolean <code>isAlive()</code></td><td>线程是否存活（还没有运行完毕）</td></tr><tr><td>public final void <code>setDaemon(boolean on)</code></td><td>将此线程标记为守护线程或用户线程</td></tr><tr><td>public <strong>static</strong> boolean <code>interrupted()</code></td><td>判断当前线程是否被打断，清除打断标记</td></tr><tr><td>public <strong>static</strong> Thread <code>currentThread()</code></td><td>获取当前线程对象</td></tr><tr><td>public <strong>static</strong> void <code>sleep(long time)</code></td><td>让当前线程休眠 time 毫秒，同时让出 CPU 时间片。<strong>Thread.sleep(0)</strong> : 让操作系统立刻重新进行一次 CPU 竞争</td></tr><tr><td>public <strong>static</strong> native void <code>yield()</code></td><td>提示线程调度器<strong>让出当前线程对 CPU 的使用</strong></td></tr></tbody></table><h3 id="start-与-run"><a class="anchor" href="#start-与-run">#</a> start () 与 run ()</h3><p><strong>直接调用 <code>start()</code> 方法的话，可启动新的线程（进入 Runnable 状态），通过新线程间接执行 <code>run()</code> 方法。</strong></p><p><strong>直接调用 <code>run()</code> 方法的话，是在 main 线程下作为普通方法执行，不会启动新线程。</strong></p><p>run () 方法中的异常不能抛出，只能 try/catch</p><ul><li>因为父类中没有抛出任何异常，子类不能比父类抛出更多的异常</li><li><strong>异常不能跨线程传播回 main () 中</strong>，因此必须在本地进行处理</li></ul><h3 id="sleep-与-yield"><a class="anchor" href="#sleep-与-yield">#</a> sleep () 与 yield ()</h3><p>sleep：</p><ul><li>调用 sleep 会让当前线程从 <code>Running</code> 进入 <code>Timed Waiting</code> 状态（计时等待）</li><li>sleep () 方法的过程中，<strong>线程不会释放对象锁</strong></li><li>其它线程可以使用 interrupt 方法打断正在睡眠的线程，这时 sleep 方法会抛出 InterruptedException</li><li><font color="red">睡眠结束后的线程未必会立刻得到执行，需要抢占 CPU</font></li><li>建议用 TimeUnit 的 sleep 代替 Thread 的 sleep 来获得更好的可读性</li></ul><p>yield：</p><ul><li>调用 yield 会让提示线程调度器<font color="red">让出当前线程对 CPU 的使用</font></li><li>具体的实现依赖于操作系统的任务调度器</li><li><strong>会放弃 CPU 资源，但不会释放锁资源</strong></li></ul><h3 id="sleep-与-wait"><a class="anchor" href="#sleep-与-wait">#</a> sleep () 与 wait ()</h3><p>共同点：两者都可以暂停线程的执行。</p><p>区别：</p><ul><li><strong><code>sleep()</code> 方法没有释放锁，而 <code>wait()</code> 方法释放了锁</strong>。</li><li><font color="red"><code>wait()</code> 通常被用于线程间交互 / 通信， <code>sleep()</code> 通常被用于暂停执行</font>。</li><li><code>wait()</code> 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 <code>notify()</code> 或者 <code>notifyAll()</code> 方法。 <code>sleep()</code> 方法执行完成后，线程会自动苏醒，或者也可以使用 <code>wait(long timeout)</code> 超时后线程会自动苏醒。</li><li><font color="red"><code>sleep()</code> 是 <code>Thread</code> 类的静态本地方法， <code>wait()</code> 则是 <code>Object</code> 类的本地方法</font></li></ul><h2 id="说说线程的生命周期和状态"><a class="anchor" href="#说说线程的生命周期和状态">#</a> 说说线程的生命周期和状态？</h2><p>在 <code>java.lang.Thread.State</code> 这个枚举类中给出了 Java 线程的六种线程状态：</p><table><thead><tr><th>线程状态</th><th>导致状态发生条件</th></tr></thead><tbody><tr><td><font color="cornflowerblue">NEW（初始）</font></td><td>线程刚被创建，但还没有调用 <code>start()</code> 。只有线程对象，没有线程特征。</td></tr><tr><td><font color="cornflowerblue">RUNNABLE（运行）</font></td><td>线程调用了 <code>start()</code> ，可能正在运行，也可能在等待运行，这取决于操作系统处理器。</td></tr><tr><td><font color="cornflowerblue">BLOCKED（锁阻塞）</font></td><td>需要等待锁释放。当一个线程试图获取一个对象锁，而该对象锁被其他的线程持有，则该线程进入 Blocked 状态；当该线程持有锁时，该线程将变成 Runnable 状态。</td></tr><tr><td><font color="cornflowerblue">WAITING（无限等待）</font></td><td>表示该线程需要等待其他线程做出一些特定动作（通知或中断）。一个线程在等待另一个线程时，该线程进入 Waiting 状态，进入这个状态后不能自动唤醒，必须等待另一个线程调用 notify 或者 notifyAll 方法才能唤醒。</td></tr><tr><td><font color="cornflowerblue">TIME_WAITING（计时等待）</font></td><td>可以在指定的时间后自行返回，而不是像 WAITING 那样一直等待。有几个方法有超时参数，调用将进入 Timed Waiting 状态，这一状态将一直保持到超时期满或者接收到唤醒通知。带有超时参数的常用方法有 Thread.sleep 、Object.wait</td></tr><tr><td><font color="cornflowerblue">TERMINATED（终止）</font></td><td>表示该线程已经运行完毕。run 方法正常退出而死亡，或者因为没有捕获的异常终止了 run 方法而死亡。</td></tr></tbody></table><p>Java 线程状态转移图：</p><blockquote><p>图源：<span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvVU9yWHFsX0xoT0Q4ZGhUcV9FUEkwdw==">挑错 |《Java 并发编程的艺术》中关于线程状态的三处错误</span></p></blockquote><p><img data-src="https://oss.javaguide.cn/github/javaguide/java/concurrent/640.png" alt="Java 线程状态变迁图"></p><p>由上图可以看出：线程创建之后它将处于 <strong>NEW（新建）</strong> 状态，调用 <code>start()</code> 方法后开始运行，线程这时候处于 <strong>READY（可运行）</strong> 状态。可运行状态的线程获得了 CPU 时间片（timeslice）后就处于 <strong>RUNNING（运行）</strong> 状态。</p><ul><li><p>当线程执行 <code>wait()</code> 方法之后，线程进入 <strong>WAITING（无限等待）</strong> 状态，需要依靠其他线程的通知才能够返回到 RUNNABLE 状态。</p></li><li><p><strong>TIMED_WAITING (计时等待)</strong> 状态相当于在 WAITING 状态的基础上增加了超时限制，比如通过 <code>sleep（long millis）</code> 方法或 <code>wait（long millis）</code> 方法可以将线程置于 TIMED_WAITING 状态。当超时时间结束后，线程将会返回到 RUNNABLE 状态。</p></li><li><p>当线程进入 <code>synchronized</code> 方法 / 块或者调用 <code>wait</code> 后（被 <code>notify</code> ）重新进入 <code>synchronized</code> 方法 / 块，但是锁被其它线程占有，这个时候线程就会进入 <strong>BLOCKED（锁阻塞）</strong> 状态。</p></li><li><p>线程在执行完了 <code>run()</code> 方法之后将会进入到 <strong>TERMINATED（终止）</strong> 状态。</p></li></ul><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20220524203355448.png" alt="image-20220524203355448"></p><h2 id="什么是线程上下文切换"><a class="anchor" href="#什么是线程上下文切换">#</a> 什么是线程上下文切换？</h2><p>线程在执行过程中会有自己的运行条件和状态（也称上下文），在上下文切换过程中，需要保存和恢复的资源包括：</p><ul><li><font color="cornflowerblue">寄存器</font></li><li><font color="cornflowerblue">程序计数器（PC）</font>：保存当前任务执行的下一条指令的地址，以便在切换回来时继续执行。</li><li><font color="cornflowerblue">栈指针（SP）</font></li><li><font color="cornflowerblue">内存管理单元（MMU）</font>：保存当前任务的页表、段表等内存管理信息，以便在切换回来时继续使用该任务的内存映射。</li><li><font color="cornflowerblue">文件描述符表</font></li><li><font color="cornflowerblue">环境变量</font></li></ul><p>当出现如下情况的时候，线程会从占用 CPU 状态中退出：</p><ul><li>主动让出 CPU，比如调用了 <code>sleep()</code> , <code>wait()</code> 等。</li><li>时间片用完，因为操作系统要防止一个线程或者进程长时间占用 CPU 导致其他线程或者进程饿死。</li><li>调用了阻塞类型的系统中断，比如请求 IO，线程被阻塞。</li><li>被终止或结束运行。</li></ul><p>这其中前三种都会发生线程切换，线程切换意味着<strong>需要保存当前线程的上下文，留待线程下次占用 CPU 时恢复现场。并加载下一个将要占用 CPU 的线程上下文</strong>。这就是所谓的上下文切换。</p><p>上下文切换是现代操作系统的基本功能，因其每次需要保存信息恢复信息，这将会占用 CPU，内存等系统资源进行处理，也就意味着效率会有一定损耗，<font color="red">如果频繁切换就会造成整体效率低下</font>。</p><h2 id="什么是线程死锁"><a class="anchor" href="#什么是线程死锁">#</a> 什么是线程死锁？</h2><blockquote><p>面试题：<span class="exturl" data-url="aHR0cHM6Ly90b3AuaW50ZXJ2aWV3Z3VpZGUuY24vaXNzdWUvMzAz">说说你了解的死锁？包括死锁产生原因、必要条件、处理方法、死锁恢复以及死锁预防等（死锁相关问题大总结，超全！）</span></p></blockquote><p>线程死锁描述的是这样一种情况：多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。</p><p>如下图所示，线程 A 持有资源 2，线程 B 持有资源 1，他们同时都想申请对方的资源，所以<strong>这两个线程就会互相等待，而进入死锁状态</strong>。</p><p><img data-src="https://oss.javaguide.cn/github/javaguide/java/2019-4%E6%AD%BB%E9%94%811.png" alt="线程死锁示意图 "></p><h3 id="死锁产生的原因"><a class="anchor" href="#死锁产生的原因">#</a> 死锁产生的原因</h3><p>理论上认为死锁产生有以下四个必要条件，缺一不可：</p><ol><li><strong>互斥</strong>：该资源任意一个时刻只由一个线程占用。</li><li><strong>请求并保持</strong>：一个线程因请求资源而阻塞时，对已获得的资源保持不放。</li><li><strong>不剥夺</strong>：线程已获得的资源在未使用完之前，不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。</li><li><strong>循环等待</strong>：若干线程之间形成一种头尾相接的循环等待资源关系。</li></ol><h3 id="如何预防-避免死锁"><a class="anchor" href="#如何预防-避免死锁">#</a> 如何预防、避免死锁？</h3><p><font color="red">如何预防死锁？</font>破坏死锁的产生的必要条件即可：</p><ol><li>破坏请求并保持条件：<strong>一次性申请所有的资源</strong>。</li><li>破坏不剥夺条件：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以<strong>主动释放自身占有的资源</strong>。</li><li>破坏循环等待条件：靠<strong>按序申请资源</strong>来预防。按某一顺序申请资源，释放资源则反序释放。</li></ol><p><font color="red">如何避免死锁？</font>避免死锁就是<strong>在资源分配时，借助于算法（比如银行家算法）对资源分配进行计算评估，使其进入安全状态</strong>。</p><blockquote><p><strong>安全状态</strong>：指的是系统能够按照某种线程推进顺序（P1、P2、P3.....Pn）来为每个线程分配所需资源，直到<font color="red">满足每个线程对资源的最大需求，使每个线程都可顺利完成</font>。称 <code>&lt;P1、P2、P3.....Pn&gt;</code> 序列为安全序列。</p></blockquote><h2 id="为什么-wait-定义在-object-类中而不是-thread-类中"><a class="anchor" href="#为什么-wait-定义在-object-类中而不是-thread-类中">#</a> 为什么 wait () 定义在 Object 类中，而不是 Thread 类中？</h2><p><strong><code>wait()</code> 是让获得对象锁的线程实现等待，会自动释放当前线程占有的对象锁</strong>。每个对象（ <code>Object</code> ）都拥有对象锁，既然要释放当前线程占有的对象锁，并让其进入 WAITING 状态，自然是要操作对应的对象（ <code>Object</code> ）而非当前的线程（ <code>Thread</code> ）。</p><p>类似的问题：为什么 <code>sleep()</code> 方法定义在 <code>Thread</code> 中？</p><p>因为 <strong><code>sleep()</code> 是让当前线程暂停执行，不涉及到对象类，也不需要获得对象锁</strong>。</p><h2 id="可以直接调用-thread-类的-run-吗"><a class="anchor" href="#可以直接调用-thread-类的-run-吗">#</a> 可以直接调用 Thread 类的 run () 吗？</h2><p>new 一个 <code>Thread</code> ，线程进入了新建状态。调用 <code>start()</code> 方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。<font color="red"> <code>start()</code> 会执行线程的相应准备工作，然后自动执行 <code>run()</code> 方法的内容</font>，这是真正的多线程工作。但是，<font color="red">直接执行 <code>run()</code> 方法，会把 <code>run()</code> 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它</font>，所以这并不是多线程工作。</p><p>总结：</p><ul><li><strong>直接调用 <code>start()</code> 方法的话，可启动新的线程（进入 Runnable 状态），通过新线程间接执行 <code>run()</code> 方法。</strong></li><li><strong>直接调用 <code>run()</code> 方法的话，是在 main 线程下作为普通方法执行，不会启动新线程。</strong></li></ul><h1 id="同步"><a class="anchor" href="#同步">#</a> 同步</h1><h2 id="临界区"><a class="anchor" href="#临界区">#</a> 临界区</h2><p><font color="cornflowerblue">临界资源</font>：一次仅允许一个进程使用的资源成为临界资源</p><p><font color="cornflowerblue">临界区</font>：访问临界资源的代码块</p><p><font color="cornflowerblue">竞态条件</font>：多个线程在临界区内执行，由于代码的执行序列不同而导致结果无法预测，称之为发生了竞态条件</p><p>一个程序运行多个线程是没有问题，多个线程读共享资源也没有问题，<font color="red">在多个线程对共享资源读写操作时发生指令交错，就会出现问题</font></p><p>为了避免临界区的竞态条件发生（解决线程安全问题）：</p><ul><li>阻塞式的解决方案：synchronized，lock</li><li>非阻塞式的解决方案：原子变量</li></ul><p><font color="cornflowerblue">管程（monitor）</font>：也称监视器，指的是<font color="red">管理共享变量以及对共享变量的操作过程，让它们支持并发</font>。翻译为 Java 就是 **<font color="red">管理类的成员变量和成员方法，让这个类是线程安全的</font>**。实现了<font color="red">同一时刻，只有一个线程在执行管程的某个子程序</font>。</p><p><strong>synchronized：对象锁，保证了临界区内代码的原子性</strong>，采用互斥的方式让同一时刻至多只有一个线程能持有对象锁，其它线程获取这个对象锁时会阻塞，保证拥有锁的线程可以安全的执行临界区内的代码，不用担心线程上下文切换。</p><p>互斥和同步都可以采用 synchronized 关键字来完成，区别：</p><ul><li><font color="cornflowerblue">互斥</font>：同一时刻只能有一个线程执行临界区代码</li><li><font color="cornflowerblue">同步</font>：是由于线程执行的先后、顺序不同，需要一个线程等待其它线程运行到某个点</li></ul><p>性能：</p><ul><li>线程安全：性能差</li><li>线程不安全：性能好，假如开发中不会存在多线程安全问题，建议使用线程不安全的设计类</li></ul><hr><blockquote><p>以下内容，参考《<span class="exturl" data-url="aHR0cDovL3huLS1KVk0tbnE2aHUyMmUubWQ=">JVM 笔记.md</span>》的第五章</p></blockquote><h2 id="乐观锁和悲观锁"><a class="anchor" href="#乐观锁和悲观锁">#</a> 乐观锁和悲观锁</h2><h3 id="数据库悲观锁和乐观锁的原理和应用场景分别有什么"><a class="anchor" href="#数据库悲观锁和乐观锁的原理和应用场景分别有什么">#</a> 数据库悲观锁和乐观锁的原理和应用场景分别有什么？</h3><ul><li><p><font color="cornflowerblue">悲观锁</font>：<strong>先获取锁，再进行业务操作</strong>。例如 <code>synchronized</code> 和 <code>ReentrantLock</code> 。一般就是利用类似 SELECT … FOR UPDATE 这样的语句，对数据加锁，避免其他事务意外修改数据。<br>当数据库执行 SELECT … FOR UPDATE 时会获取被 select 中的数据行的行锁， select for update 获取的行锁会在当前事务结束时自动释放，因此必须在事务中使用。</p></li><li><p><font color="cornflowerblue">乐观锁</font>：<strong>先进行业务操作，只在最后实际更新数据时检查数据是否被更新过</strong>。Java 并发包中的 AtomicFieldUpdater 类似，也是利用 CAS 机制，并不会对数据加锁，而是通过对比数据的时间戳或者版本号，来实现乐观锁需要的版本判断。</p></li></ul><h2 id="synchronized-关键字"><a class="anchor" href="#synchronized-关键字">#</a> synchronized 关键字</h2><blockquote><p><strong>独占锁</strong>（悲观锁）</p></blockquote><h3 id="为什么把-jdk-16-之前的-synchronized-称为重量级锁"><a class="anchor" href="#为什么把-jdk-16-之前的-synchronized-称为重量级锁">#</a> 为什么把 JDK 1.6 之前的 synchronized 称为重量级锁？</h3><ol><li>JDK 1.6 之前的 synchronized 是重量级锁主要是因为：其实现方式会导致性能上的较大损耗。</li><li>在 JDK 1.6 之前，synchronized 关键字<strong>使用的是对象级别的锁</strong>，即每个对象都有一个相关的锁。<strong>在获取和释放锁的过程中需要进行用户态和内核态的切换，这个切换的代价比较高，消耗的时间比较多</strong>，因此被称为重量级锁。</li><li>在 JDK 1.6 之前的 synchronized <strong>在获取锁时使用的是互斥量（Mutex）来实现，这是一种悲观锁，即当某个线程获取了锁之后，其他的线程将被阻塞，直到该线程释放锁</strong>。这种阻塞和唤醒线程的操作需要操作系统层面的支持，因此会有较高的开销。</li><li>另外，JDK 1.6 之前的 synchronized 的实现没有进行优化，每一次锁的获取和释放都需要进行同步操作，无法做到细粒度的控制，导致锁的粒度较大，同一时间只能一个线程访问被锁定的代码块，效率较低。</li></ol><p>因此，JDK 1.6 之前的 synchronized 被称为重量级锁，主要是因为它在性能和资源消耗方面存在一些不足之处。不过随着 JDK 的不断更新，synchronized 的实现方式得到了改善，JDK 1.6 之后引入了偏向锁、轻量级锁等优化措施，使得 synchronized 的性能也得到了提升。</p><h3 id="synchronized-锁升级过程偏向锁-轻量级锁-重量级锁"><a class="anchor" href="#synchronized-锁升级过程偏向锁-轻量级锁-重量级锁">#</a> synchronized 锁升级过程（偏向锁、轻量级锁、重量级锁）</h3><ol><li><font color="cornflowerblue">偏向锁</font>：</li></ol><ul><li>在锁对象初始化时，对象头中的 Mark Word 会记录当前线程 ID，表示该锁对象偏向于该线程。</li><li>当另一个线程也尝试获取这个锁对象时，会检查该对象头的 Mark Word，<ul><li>如果记录的线程 ID 是自己，表示可以直接获取锁。</li><li>如果记录的线程 ID 不是自己，会<strong>撤销偏向锁，升级为轻量级锁</strong>。</li></ul></li></ul><ol start="2"><li><font color="cornflowerblue">轻量级锁</font>：</li></ol><ul><li>当多个线程尝试获取锁对象时，JVM 会为参与竞争的各个线程的栈帧中各自分配 ** 锁记录（ <code>Lock Record</code> ）** 空间，并将锁对象的 Mark Word 拷贝到其中，称为 <code>Displaced Mark Word</code> 。</li><li>然后，一个线程使用 CAS 操作尝试将对象头的 Mark Word 替换为指向自己线程栈帧中的锁记录的指针。<ul><li>如果 CAS 成功，表示获取锁成功。</li><li>如果 CAS 失败，那么当前线程也不会阻塞，而是通过<strong>自旋</strong>的方式不断尝试获取锁，当达到一定次数仍未获得锁时，会进一步<strong>膨胀为重量级锁</strong>。</li></ul></li></ul><ol start="3"><li><font color="cornflowerblue">重量级锁</font>：</li></ol><ul><li>当一个线程尝试获取对象锁时，发现对象已经是轻量级锁状态，但是锁的拥有者不是自己时，此时线程会进入<strong> BLOCKED（锁阻塞）状态</strong>，开始<strong>锁膨胀</strong>流程。</li><li>升级为重量级锁时，虚拟机会在操作系统层面申请一个 ** 互斥量（Mutex）** 来保护整个对象。</li><li>获取重量级锁失败的线程将会进入阻塞状态，只有当拥有锁的线程释放锁后，其他线程才有机会获取锁。</li></ul><p>需要注意的是，锁的升级过程中是逐级升级的，即从<strong>偏向锁 -&gt; 轻量级锁 -&gt; 重量级锁</strong>。而且<strong>锁只能升级，不能降级</strong>。这是为了防止频繁锁的请求和释放造成的性能损耗。</p><h1 id="内存"><a class="anchor" href="#内存">#</a> 内存</h1><h2 id="java-内存模型jmm"><a class="anchor" href="#java-内存模型jmm">#</a> Java 内存模型（JMM）</h2><h2 id="volatile-关键字"><a class="anchor" href="#volatile-关键字">#</a> volatile 关键字</h2><h3 id="volatile实现什么能力怎么实现的"><a class="anchor" href="#volatile实现什么能力怎么实现的">#</a> volatile 实现什么能力，怎么实现的？</h3><ul><li><strong>能保证变量的可见性</strong>：如果我们将变量声明为 <code>volatile</code> ，表明这个变量是共享且不稳定的，<font color="red">每次读写都强制发生在主内存中</font>。</li><li><strong>禁止指令重排</strong>：当一个变量被 <code>volatile</code> 修饰时，编译器和处理器会禁止对其进行指令重排，从而保证程序的正确性。</li></ul><h2 id="happens-before-原则"><a class="anchor" href="#happens-before-原则">#</a> happens-before 原则</h2><h1 id="无锁"><a class="anchor" href="#无锁">#</a> 无锁</h1><h2 id="cas"><a class="anchor" href="#cas">#</a> CAS</h2><h2 id="atomic-原子类"><a class="anchor" href="#atomic-原子类">#</a> Atomic 原子类</h2><ol><li><p><strong>Atomic 原子类是 <code>Java.util.concurrent</code> 包中的一个类，用于提供<u>线程安全</u>的<u>原子操作</u></strong>。</p></li><li><p>Atomic 原子类可以保证在多线程环境下对变量的原子操作，即操作过程不会被其他线程中断，从而避免了竞态条件的发生。</p></li><li><p>Atomic 原子类<font color="red">提供了一系列的方法，可以对变量进行读取、写入、比较并设置等操作</font>，如 get、set、compareAndSet 等。</p></li><li><p>Atomic 原子类<font color="red">支持不同的数据类型</font>，</p><ul><li><font color="cornflowerblue">基本类型</font>的原子类： <code>AtomicInteger</code> （整型）、 <code>AtomicLong</code> （长整型）、 <code>AtomicBoolean</code> （布尔型）</li><li><font color="cornflowerblue">数组类型</font>的原子类： <code>AtomicIntegerArray</code> （整型数组）、 <code>AtomicLongArray</code> （长整型数组）、 <code>AtomicReferenceArray</code> （引用类型数组）</li><li><font color="cornflowerblue">引用类型</font>的原子类： <code>AtomicReference</code> （引用类型）、 <code>AtomicStampedReference</code> （原子更新带有版本号的引用类型）、 <code>AtomicMarkableReference</code> （原子更新带有标记的引用类型）</li></ul></li><li><p>Atomic 原子类的内部实现<strong>基于 CAS（Compare-and-Swap）算法</strong>，该算法<font color="red">通过比较内存中的值与期望值是否一致来判断是否更新</font>。</p></li><li><p>Atomic 原子类的使用场景包括计数器、线程安全的累加器、标志位的设置等。</p></li><li><p>Atomic 原子类 **<font color="red">在高并发场景下可以提高性能，避免了使用锁造成的线程等待和上下文切换的开销</font>**。</p></li></ol><h2 id="threadlocal-类"><a class="anchor" href="#threadlocal-类">#</a> ThreadLocal 类</h2><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/1-af0577dc.png" alt="img"><h3 id="有什么用"><a class="anchor" href="#有什么用">#</a> 有什么用？</h3><p><strong><code>ThreadLocal</code> 类可以让每个线程拥有自己单独的变量副本，分配在堆内的 TLAB 中，使得每个线程中的变量相互独立，从而保证线程安全。</strong></p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/68747470733a2f2f7365617a65616e2e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f696d672f4a6176612f4a564d2d4a617661382545352538362538352545352541442539382545372542422539332545362539452538342545352539422542452e706e67" alt="img"></p><p><font color="red"><code>ThreadLocal</code> 变量是 private static 类型的，访问这个变量的每个线程都会在 TLAB 中存储这个变量的本地副本，所以是线程安全的</font>。他们可以使用 <code>get()</code> 和 <code>set()</code> 方法来获取默认值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题。</p><h3 id="如何使用"><a class="anchor" href="#如何使用">#</a> 如何使用？</h3><p>下面简单演示一下如何在项目中实际使用 <code>ThreadLocal</code> 。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>text<span class="token punctuation">.</span></span><span class="token class-name">SimpleDateFormat</span></span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Random</span></span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadLocalExample</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre>     <span class="token comment">// SimpleDateFormat 不是线程安全的，所以每个线程都要有自己独立的副本</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">SimpleDateFormat</span><span class="token punctuation">></span></span> formatter <span class="token operator">=</span> <span class="token class-name">ThreadLocal</span><span class="token punctuation">.</span><span class="token function">withInitial</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token keyword">new</span> <span class="token class-name">SimpleDateFormat</span><span class="token punctuation">(</span><span class="token string">"yyyyMMdd HHmm"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token class-name">ThreadLocalExample</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadLocalExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span> <span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>            <span class="token class-name">Thread</span> t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token string">""</span><span class="token operator">+</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>            <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>            t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="17"></td><td><pre></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token annotation punctuation">@Override</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Thread Name= "</span><span class="token operator">+</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">" default Formatter = "</span><span class="token operator">+</span>formatter<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toPattern</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>            <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>        <span class="token comment">//formatter pattern is changed here by thread, but it won't reflect to other threads</span></pre></td></tr><tr><td data-num="27"></td><td><pre>        formatter<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">SimpleDateFormat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre></pre></td></tr><tr><td data-num="29"></td><td><pre>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Thread Name= "</span><span class="token operator">+</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">" formatter = "</span><span class="token operator">+</span>formatter<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toPattern</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="31"></td><td><pre></pre></td></tr><tr><td data-num="32"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id="原理"><a class="anchor" href="#原理">#</a> 原理</h3><p>从 <code>Thread</code> 类源代码入手。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Thread</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">//......</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token comment">// 与此线程有关的 ThreadLocal 值。由 ThreadLocal 类维护</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token class-name">ThreadLocal<span class="token punctuation">.</span>ThreadLocalMap</span> threadLocals <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token comment">// 与此线程有关的 InheritableThreadLocal 值。由 InheritableThreadLocal 类维护</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token class-name">ThreadLocal<span class="token punctuation">.</span>ThreadLocalMap</span> inheritableThreadLocals <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token comment">//......</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>从上面 <code>Thread</code> 类的源代码有<font color="red">一个 threadLocals 变量和一个 inheritableThreadLocals 变量</font>，它们都是 <strong>ThreadLocalMap</strong> 类型的变量，可以理解为 <code>ThreadLocal</code> 类实现的定制化 <code>HashMap</code> 。</p><ul><li>默认情况下这两个变量都是 null</li><li>只有当前线程调用 <code>ThreadLocal</code> 类的 <code>set()</code> 或 <code>get()</code> 方法时才创建它们，实际上调用的是 <code>ThreadLocalMap</code> 类对应的 <code>get()</code> 、 <code>set()</code> 方法。</li></ul><p><code>ThreadLocal</code> 类的 <code>set()</code> 方法</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token class-name">T</span> value<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 获取当前请求的线程</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token class-name">Thread</span> t <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token comment">// 取出 Thread 类内部的 threadLocals 变量 (哈希表结构)</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token class-name">ThreadLocalMap</span> map <span class="token operator">=</span> <span class="token function">getMap</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>map <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token comment">// 将需要存储的值放入到这个哈希表中</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        map<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">else</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token function">createMap</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token class-name">ThreadLocalMap</span> <span class="token function">getMap</span><span class="token punctuation">(</span><span class="token class-name">Thread</span> t<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token keyword">return</span> t<span class="token punctuation">.</span>threadLocals<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>结论：<strong>最终的变量是存放在当前线程的 <code>ThreadLocalMap</code> 中，而不是 <code>ThreadLocal</code> 上</strong>。</p><ul><li><code>ThreadLocal</code> 可以理解为只是 <code>ThreadLocalMap</code> 的封装，传递了变量值。</li><li><code>ThrealLocal</code> 类中可以通过 <code>Thread.currentThread()</code> 获取到当前线程对象后，直接通过 <code>getMap(Thread t)</code> 可以访问到该线程的 <code>ThreadLocalMap</code> 对象。</li></ul><p><strong>每个 <code>Thread</code> 中都具备一个 <code>ThreadLocalMap</code> ，可以存储（key= <code>ThreadLocal</code> 对象，value= Object 对象）的键值对。</strong></p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">ThreadLocalMap</span><span class="token punctuation">(</span><span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> firstKey<span class="token punctuation">,</span> <span class="token class-name">Object</span> firstValue<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">//......</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>比如我们在同一个线程中声明了两个 <code>ThreadLocal</code> 对象的话， <code>Thread</code> 内部都是使用仅有的那个 <code>ThreadLocalMap</code> 存放数据的，key 就是 <code>ThreadLocal</code> 对象，value 就是 <code>ThreadLocal</code> 对象调用 <code>set()</code> 方法设置的值。</p><p><code>ThreadLocal</code> 数据结构如下图所示：</p><p><img data-src="https://oss.javaguide.cn/github/javaguide/java/concurrent/threadlocal-data-structure.png" alt="ThreadLocal 数据结构"></p><p><code>ThreadLocalMap</code> 是 <code>ThreadLocal</code> 的静态内部类。</p><p><img data-src="https://oss.javaguide.cn/github/javaguide/java/concurrent/thread-local-inner-class.png" alt="ThreadLocal内部类"></p><h3 id="内存泄露问题"><a class="anchor" href="#内存泄露问题">#</a> 内存泄露问题</h3><p><code>ThreadLocalMap</code> 中使用的<font color="red"> key 为 <code>ThreadLocal</code> 的弱引用</font>，而 value 是强引用。所以，如果 <code>ThreadLocal</code> 没有被外部强引用的情况下，<font color="red">在垃圾回收的时候，key 会被清理掉</font>，而 value 不会被清理掉。这样一来， <code>ThreadLocalMap</code> 中就<font color="red">会出现 key 为 null 的 Entry</font>。假如我们不做任何措施的话，<font color="red">value 永远无法被 GC 回收</font>，这个时候就可能会产生<strong>内存泄露</strong>。</p><p><code>ThreadLocalMap</code> 实现中已经考虑了这种情况，在调用 <code>set()</code> 、 <code>get()</code> 、 <code>remove()</code> 方法的时候，会清理掉 key 为 null 的记录。使用完 <code>ThreadLocal</code> 方法后最好手动调用 <code>remove()</code> 方法。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Entry</span> <span class="token keyword">extends</span> <span class="token class-name">WeakReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ThreadLocal</span><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">/** The value associated with this ThreadLocal. */</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token class-name">Object</span> value<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token class-name">Entry</span><span class="token punctuation">(</span><span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> k<span class="token punctuation">,</span> <span class="token class-name">Object</span> v<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token keyword">super</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        value <span class="token operator">=</span> v<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><strong>弱引用介绍：</strong></p><blockquote><p>如果一个对象只具有弱引用，那就类似于<strong>可有可无的生活用品</strong>。弱引用与软引用的区别在于：<font color="red">只具有弱引用的对象拥有更短暂的生命周期</font>。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，<font color="red">不管当前内存空间足够与否，都会回收它的内存</font>。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。</p><p>弱引用可以和一个<font color="red">引用队列（ReferenceQueue）</font>联合使用，如果弱引用所引用的对象被垃圾回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p></blockquote><h3 id="你的理解小结"><a class="anchor" href="#你的理解小结">#</a> 你的理解？（小结）</h3><p>ThreadLocal 提供了一种方式，在多线程环境下，<strong>每个线程都可以独立地维护自己的变量副本，互不干扰</strong>。</p><p>在多线程编程中，共享变量的访问可能会引发线程安全的问题。比如多个线程同时修改同一个变量，可能会导致数据不一致或者竞态条件等问题。而 ThreadLocal 则可以解决这个问题，它为每个线程提供了一个独立的变量副本，每个线程都可以访问和修改自己的变量副本，而不会影响其他线程的副本。这样就避免了多个线程之间的竞争和冲突。</p><p>ThreadLocal 的工作原理是，<strong>在每个线程内部维护一个 <code>ThreadLocalMap</code> ，用于存储线程局部变量的副本，（key=ThreadLocal 对象，value=Object 对象）</strong>。</p><p>当线程需要访问这个变量时，首先通过 ThreadLocal 对象获取当前线程的副本，如果不存在则创建一个新的副本，并存储到 Map 中。而<font color="red">线程对变量的访问和修改都是通过 ThreadLocal 对象进行，保了线程间的隔离性</font>。</p><p>ThreadLocal 的典型应用场景包括：</p><ul><li><font color="red">数据库连接管理</font>：每个线程都可以拥有自己的数据库连接，避免了多个线程之间的数据库连接竞争和冲突。</li><li><font color="red">用户身份信息传递</font>：将用户身份信息存储在 ThreadLocal 中，可以在多个方法中方便地获取和传递，避免了显式地传递参数。</li><li><font color="red">事务管理</font>：将事务对象存储在 ThreadLocal 中，可以在多个方法中共享同一个事务，避免了事务对象的传递和管理。</li></ul><p>需要注意的是，使用 ThreadLocal 时<font color="red">要注意及时清理资源，避免内存泄漏问题</font>。一般可以通过在 ThreadLocal 使用完毕后，调用 <code>remove()</code> 方法进行清理。</p><h1 id="同步器"><a class="anchor" href="#同步器">#</a> 同步器</h1><h2 id="aqs-抽象类"><a class="anchor" href="#aqs-抽象类">#</a> AQS 抽象类</h2><h3 id="简介"><a class="anchor" href="#简介">#</a> 简介</h3><p>AQS 的全称为 <code>AbstractQueuedSynchronizer</code> ，翻译过来的意思就是<font color="red">抽象队列同步器</font>。这个类在 <code>java.util.concurrent.locks</code> 包下面。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/AQS.png" alt="img"></p><p>AQS 就是一个抽象类，主要用来<strong>简单且高效地构造出大量的同步器</strong>，<font color="red">比如 <code>ReentrantLock</code> ， <code>Semaphore</code> ，其他的诸如 <code>ReentrantReadWriteLock</code> ， <code>SynchronousQueue</code> 等等皆是基于 AQS 的</font>。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">AbstractQueuedSynchronizer</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractOwnableSynchronizer</span> <span class="token keyword">implements</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>Serializable</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id="底层原理"><a class="anchor" href="#底层原理">#</a> 底层原理</h3><h4 id="核心思想"><a class="anchor" href="#核心思想">#</a> 核心思想</h4><p>AQS 核心思想是：</p><ul><li>如果被请求的共享资源是<font color="gree">空闲</font>的，则将当前请求资源的线程设置为有效的<font color="red">工作线程</font>，并且将共享资源设置为<font color="red">锁定状态</font>。</li><li>如果被请求的共享资源<font color="gree">被占用</font>了，那么就需要<font color="red">一套线程阻塞等待以及被唤醒时锁分配的机制</font>，这个机制是基于 <strong>CLH 队列锁</strong> （Craig, Landin, and Hagersten locks） 实现的，即<font color="red">将暂时获取不到锁的线程加入到队列中</font>。</li></ul><p>CLH 锁是<font color="red">对自旋锁的一种改进</font>，是一个 **<font color="red">虚拟的双向 FIFO 队列</font>**（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。<strong>AQS 将每个请求共享资源的线程封装成 CLH 队列锁的一个结点（Node）来实现锁的分配</strong>。每个结点包含：</p><ul><li><font color="cornflowerblue">thread</font>：线程的引用</li><li><font color="cornflowerblue">waitStatus</font>：当前节点在队列中的状态</li><li><font color="cornflowerblue">prev</font>：前驱节点</li><li><font color="cornflowerblue">next</font>：后继节点</li></ul><p>CLH 队列结构如下：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/clh-queue-structure.png" alt="CLH 队列结构"></p><p>AQS( <code>AbstractQueuedSynchronizer</code> ) 的核心原理图：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231013130403824.png" alt="image-20231013130403824"></p><p>AQS 使用 <strong>int 成员变量 <code>state</code> 表示同步状态</strong>，通过内置的 <strong>双向 FIFO 线程等待队列</strong> 来完成获取资源线程的排队工作。</p><ul><li><p><code>state</code> 变量由 <code>volatile</code> 修饰，保证线程可见性，用于展示当前临界资源的获锁情况。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 共享变量，使用 volatile 修饰保证线程可见性</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> state<span class="token punctuation">;</span></pre></td></tr></table></figure></li><li><p>另外，状态信息 <code>state</code> 可以通过 <code>protected</code> 类型的 <code>getState()</code> 、 <code>setState()</code> 和 <code>compareAndSetState()</code> 进行操作。并且，这几个方法都是 <code>final</code> 修饰的，在子类中无法被重写。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 返回同步状态的当前值</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>     <span class="token keyword">return</span> state<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token comment">// 设置同步状态的值</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">setState</span><span class="token punctuation">(</span><span class="token keyword">int</span> newState<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>     state <span class="token operator">=</span> newState<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token comment">// 原子地（CAS 操作）将同步状态值设置为给定值 update 如果当前同步状态的值等于 expect（期望值）</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">compareAndSetState</span><span class="token punctuation">(</span><span class="token keyword">int</span> expect<span class="token punctuation">,</span> <span class="token keyword">int</span> update<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>      <span class="token keyword">return</span> unsafe<span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> stateOffset<span class="token punctuation">,</span> expect<span class="token punctuation">,</span> update<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure></li></ul><hr><p>以<strong>可重入式的独占锁</strong> <code>ReentrantLock</code> 为例，它的内部维护了一个 <code>state</code> 变量，<font color="red">表示这个锁被多少个线程所持有</font>。</p><ul><li><p><code>state</code> 的<font color="red">初始值为 0</font>，表示锁处于未锁定状态。</p></li><li><p>当线程 A 调用 <code>lock()</code> 方法时，会尝试通过 <code>tryAcquire()</code> 方法独占该锁，并让 <code>state</code> 的值<font color="red">加 1</font>。</p><ul><li>如果成功了，那么线程 A 就获取到了锁。</li><li>如果失败了，那么线程 A 就会<font color="red">被加入到一个等待队列（CLH 队列）中</font>，直到其他线程释放该锁。</li></ul></li><li><p>假设线程 A 获取锁成功了，<strong><font color="red">释放锁之前，A 线程自己是可以重复获取此锁的</font></strong>（ <code>state</code> 会累加）。</p><blockquote><p>这就是<strong>可重入性</strong>的体现：<strong>一个线程可以多次获取同一个锁而不会被阻塞</strong>。但是，这也意味着，一个线程必须释放与获取的次数相同的锁，才能让 <code>state</code> 的值回到 0，也就是让锁恢复到未锁定状态。只有这样，其他等待的线程才能有机会获取该锁。</p></blockquote></li></ul><p>线程 A 尝试获取 <code>ReentrantLock</code> 锁的过程如下图所示：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/aqs-exclusive-mode-acquire-lock.png" alt="AQS 独占模式获取锁"></p><center>（AQS 独占模式获取锁）</center><hr><p>再以倒计时器 <code>CountDownLatch</code> 以例，</p><ul><li><p>任务分为 N 个子线程去执行， <code>state</code> 也初始化为 N（<font color="red">表示子线程的个数</font>）。</p></li><li><p>这 N 个子线程开始执行任务，每执行完一个子线程，就调用一次 <code>countDown()</code> 方法。该方法会尝试使用 CAS 操作，让 <code>state</code> 的值减少 1。</p></li><li><p>当所有的子线程都执行完毕后（即 <code>state</code> 的值变为 0）， <code>CountDownLatch</code> 会调用 <code>unpark()</code> 方法，唤醒主线程。</p><blockquote><p>park () 和 unpark () 是 LockSupport 类中的方法：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">LockSupport</span><span class="token punctuation">.</span><span class="token function">park</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 暂停当前线程</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name">LockSupport</span><span class="token punctuation">.</span><span class="token function">unpark</span><span class="token punctuation">(</span>暂停线程对象<span class="token punctuation">)</span> <span class="token comment">// 恢复某个线程的运行</span></pre></td></tr></table></figure></blockquote></li><li><p>主线程被唤醒后就可以从 <code>CountDownLatch</code> 中的 <code>await()</code> 方法（而非 AQS 中的）返回，继续执行后续的操作。</p></li></ul><h4 id="资源共享方式"><a class="anchor" href="#资源共享方式">#</a> 资源共享方式</h4><p>AQS 定义两种资源共享方式：</p><ul><li><code>Exclusive</code> ：<strong>独占式</strong>，只有一个线程能执行，如 <code>ReentrantLock</code></li><li><code>Share</code> ：<strong>共享式</strong>，多个线程可同时执行，如 <code>Semaphore</code> / <code>CountDownLatch</code></li></ul><p><font color="red">一般来说，自定义同步器的共享方式要么是独占，要么是共享</font>，他们也只需实现 <code>tryAcquire-tryRelease</code> 、 <code>tryAcquireShared-tryReleaseShared</code> 中的一种即可。<font color="red">但 AQS 也支持自定义同步器同时实现独占和共享两种方式</font>，如 <code>ReentrantReadWriteLock</code> 。</p><h4 id="自定义同步器"><a class="anchor" href="#自定义同步器">#</a> 自定义同步器</h4><p>同步器的设计是基于<font color="red">模板方法模式</font>的，如果需要自定义同步器一般的方式是这样：</p><ol><li><strong><font color="red">继承 <code>AbstractQueuedSynchronizer</code> （AQS 抽象类），并重写指定的钩子方法</font></strong>。</li><li>将 AQS 组合在自定义同步组件的实现中，并调用其模板方法，而这些模板方法会调用使用者重写的方法。</li></ol><p><strong>AQS 使用了模板方法模式，自定义同步器时，需要重写下面几个 AQS 提供的钩子方法：</strong></p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 独占方式。尝试获取资源，成功则返回 true，失败则返回 false。</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">// 独占方式。尝试释放资源，成功则返回 true，失败则返回 false。</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">tryRelease</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token comment">// 共享方式。尝试获取资源。负数表示失败；0 表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">protected</span> <span class="token keyword">int</span> <span class="token function">tryAcquireShared</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token comment">// 共享方式。尝试释放资源，成功则返回 true，失败则返回 false。</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">tryReleaseShared</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token comment">// 该线程是否正在独占资源。只有用到 condition 才需要去实现它。</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">isHeldExclusively</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr></table></figure><p><strong>钩子方法</strong>是一种<font color="red">被声明在抽象类中</font>的方法，一般使用<font color="red"> <code>protected</code> 关键字</font>修饰，它可以是空方法（由子类实现），也可以是默认实现的方法。模板设计模式通过钩子方法控制固定步骤的实现。</p><p><strong><font color="red">除了上面提到的钩子方法之外，AQS 类中的其他方法都是 <code>final</code> ，所以无法被其他类重写</font></strong>。</p><h3 id="常见同步工具类"><a class="anchor" href="#常见同步工具类">#</a> 常见同步工具类</h3><p>下面介绍几个基于 AQS 的常见同步工具类：</p><ul><li><font color="cornflowerblue">Semaphore（信号量）</font>：共享式，AQS 的 <code>state</code> 值为 <code>permits</code> ，表示许可证的数量，只有拿到许可证的线程才能执行。可以用来控制同时访问特定资源的线程数量。</li><li><font color="cornflowerblue">CountDownLatch（倒计时器）</font>：共享式，AQS 的 <code>state</code> 值为 <code>count</code> ，表示允许 <code>count</code> 个线程阻塞在一个地方，直至所有线程的任务都执行完毕。</li><li><font color="cornflowerblue">CyclicBarrier（循环栅栏）</font></li></ul><h4 id="semaphore信号量"><a class="anchor" href="#semaphore信号量">#</a> Semaphore（信号量）</h4><blockquote><p><strong>共享式</strong>的资源访问方式</p></blockquote><h5 id="简介-2"><a class="anchor" href="#简介-2">#</a> 简介</h5><p><strong><code>Semaphore</code> (信号量) 是共享锁，默认构造 AQS 的 <code>state</code> 值为 <code>permits</code> ，理解为许可证的数量，只有拿到许可证的线程才能执行</strong>。</p><p>Semaphore 的使用简单，我们这里假设有 N (N&gt;5) 个线程来获取 <code>Semaphore</code> 中的共享资源。下面的代码将 <code>permits</code> 初始化为 5，表示同一时刻只有 5 个线程能获取到共享资源，其他线程都会阻塞，只有获取到共享资源的线程才能执行。等到有线程释放了共享资源，其他阻塞的线程才能获取到。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 初始共享资源数量</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">final</span> <span class="token class-name">Semaphore</span> semaphore <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Semaphore</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">// 获取 1 个许可</span></pre></td></tr><tr><td data-num="4"></td><td><pre>semaphore<span class="token punctuation">.</span><span class="token function">acquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token comment">// 释放 1 个许可</span></pre></td></tr><tr><td data-num="6"></td><td><pre>semaphore<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p><font color="red">当初始的  <code>permits</code> 为 1 的时候， <code>Semaphore</code> 退化为独占锁</font>。</p><p><code>Semaphore</code> 有两种模式：</p><ul><li><font color="cornflowerblue">公平模式</font>：调用 <code>acquire()</code> 方法的顺序就是获取许可证的顺序，遵循 <font color="red">FIFO</font></li><li><font color="cornflowerblue">非公平模式</font>：<font color="red">抢占式</font>，也是<font color="red">默认</font>的模式。</li></ul><p><strong><code>Semaphore</code> 的两个构造方法如下，二者都必须提供 <code>permits</code> ，其中第二个构造方法可以通过提供 <code>fair</code> 指定是公平模式 / 非公平模式，默认非公平模式。</strong></p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token class-name">Semaphore</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token keyword">permits</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  	sync <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NonfairSync</span><span class="token punctuation">(</span><span class="token keyword">permits</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">public</span> <span class="token class-name">Semaphore</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token keyword">permits</span><span class="token punctuation">,</span> <span class="token keyword">boolean</span> fair<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>  	sync <span class="token operator">=</span> fair <span class="token operator">?</span> <span class="token keyword">new</span> <span class="token class-name">FairSync</span><span class="token punctuation">(</span><span class="token keyword">permits</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token keyword">new</span> <span class="token class-name">NonfairSync</span><span class="token punctuation">(</span><span class="token keyword">permits</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><code>Semaphore</code> 通常用于那些对资源有明确访问数量限制的场景比如限流（仅限于单机模式，<font color="red">实际项目中推荐使用 Redis +Lua 来做限流</font>）。</p><h5 id="原理-2"><a class="anchor" href="#原理-2">#</a> 原理</h5><p>线程调用 <code>semaphore.acquire()</code> 尝试获取许可证，</p><ul><li>如果 <code>permits &gt;= 0</code> 的话，则表示可以获取成功。使用<font color="red"> CAS 操作</font>去修改 <code>permits</code> 的值减 1。</li><li>如果 <code>permits &lt; 0</code> 的话，则表示许可证数量不足。此时会<font color="red">创建一个 Node 节点加入 CLH 队列锁，挂起当前线程</font>。</li></ul><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">/**</span></pre></td></tr><tr><td data-num="2"></td><td><pre> *  获取 1 个许可证</pre></td></tr><tr><td data-num="3"></td><td><pre> */</pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre> 	 sync<span class="token punctuation">.</span><span class="token function">acquireSharedInterruptibly</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token comment">/**</span></pre></td></tr><tr><td data-num="8"></td><td><pre> * 共享模式下获取许可证，获取成功则返回，失败则加入阻塞队列，挂起线程</pre></td></tr><tr><td data-num="9"></td><td><pre> */</pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">acquireSharedInterruptibly</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="13"></td><td><pre>      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token comment">// 尝试获取许可证，arg 为获取许可证个数，当可用许可证数减当前获取的许可证数结果小于 0, 则创建一个节点加入阻塞队列，挂起当前线程。</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tryAcquireShared</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="16"></td><td><pre>      <span class="token function">doAcquireSharedInterruptibly</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>线程调用 <code>semaphore.release()</code> 尝试释放许可证，</p><ul><li>并使用<font color="red"> CAS 操作</font>去修改 <code>permits</code> 的值加 1。</li><li>释放许可证成功之后，同时会<font color="red">唤醒 CLH 队列锁 中的一个线程</font>。</li><li>被唤醒的线程会重新尝试获取许可证，修改 <code>permits</code> 的值减 1，<ul><li>如果 <code>permits &gt;= 0</code> 则获取令牌成功</li><li>如果 <code>permits &lt; 0</code> 则重新进入阻塞队列，挂起线程</li></ul></li></ul><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 释放一个许可证</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  	sync<span class="token punctuation">.</span><span class="token function">releaseShared</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token comment">// 释放共享锁，同时会唤醒同步队列中的一个线程。</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">releaseShared</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token comment">// 释放共享锁</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tryReleaseShared</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>      <span class="token comment">// 唤醒同步队列中的一个线程</span></pre></td></tr><tr><td data-num="11"></td><td><pre>      <span class="token function">doReleaseShared</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>      <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h4 id="countdownlatch倒计时器"><a class="anchor" href="#countdownlatch倒计时器">#</a> CountDownLatch（倒计时器）</h4><blockquote><p><strong>共享式</strong>的资源访问方式</p></blockquote><h5 id="简介-3"><a class="anchor" href="#简介-3">#</a> 简介</h5><p><strong><code>CountDownLatch</code> （倒计时器）是共享锁，默认构造 AQS 的 <code>state</code> 值为 <code>count</code> ，理解为允许 <code>count</code> 个线程阻塞在一个地方，直至所有线程的任务都执行完毕</strong>。</p><p><code>CountDownLatch</code> 是 **<font color="red">一次性</font>** 的，<font color="red"> <code>count</code> 只能在构造方法中初始化一次，之后没有任何机制再次对其设置值</font>，当 <code>CountDownLatch</code> 使用完毕后，它不能再次被使用。</p><h5 id="原理-3"><a class="anchor" href="#原理-3">#</a> 原理</h5><ul><li><p>当线程调用 <code>countDown()</code> 方法时，其实调用了 <code>tryReleaseShared()</code> 方法以 CAS 的操作来减少 <code>count</code> ，直至 <code>count</code> 为 0</p></li><li><p>当调用 <code>await()</code> 方法的时候，如果 <code>count</code> 不为 0，那就证明任务还没有执行完毕， <code>await()</code> 方法就会一直阻塞。也就是说 <code>await()</code> 方法之后的语句不会被执行。</p></li><li><p>直到 <code>count</code> 个线程调用了 <code>countDown()</code> ，使 <code>count</code> 值被减为 0。或者调用 <code>await()</code> 的线程被中断，该线程才会从阻塞中被唤醒， <code>await()</code> 方法之后的语句得到执行。</p></li></ul><h5 id="应用场景"><a class="anchor" href="#应用场景">#</a> 应用场景</h5><p><code>CountDownLatch</code> 的作用就是允许 count 个线程阻塞在一个地方，直至所有线程的任务都执行完毕。之前在项目中，有一个<font color="red">使用多线程读取多个文件</font>处理的场景，我用到了 <code>CountDownLatch</code> 。具体场景是下面这样的：</p><p>我们要读取处理 6 个文件，这 6 个任务都是<font color="red">没有执行顺序依赖</font>的任务，但是我们需要返回给用户的时候将这几个文件的处理结果进行统计整理。</p><p>为此我们定义了一个线程池和 count 为 6 的 <code>CountDownLatch</code> 对象 。</p><ul><li>使用线程池处理读取任务</li><li>每一个线程处理完，调用 <code>CountDownLatch</code> 对象的 <code>countDown()</code> 将 count 减 1</li><li>当所有线程处理完，调用 <code>CountDownLatch</code> 对象的 <code>await()</code> 方法。直到所有文件读取完之后，才会接着执行后面的逻辑。</li></ul><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CountDownLatchExample1</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 处理文件的数量</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> threadCount <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token comment">// 创建一个具有固定线程数量的线程池对象（推荐使用构造方法创建）</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token class-name">ExecutorService</span> threadPool <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token keyword">final</span> <span class="token class-name">CountDownLatch</span> countDownLatch <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountDownLatch</span><span class="token punctuation">(</span>threadCount<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> threadCount<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>            <span class="token keyword">final</span> <span class="token keyword">int</span> threadnum <span class="token operator">=</span> i<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>            threadPool<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>                <span class="token keyword">try</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>                    <span class="token comment">// 处理文件的业务操作</span></pre></td></tr><tr><td data-num="14"></td><td><pre>                    <span class="token comment">//......</span></pre></td></tr><tr><td data-num="15"></td><td><pre>                <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>                <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>                    <span class="token comment">// 表示一个文件已经被完成</span></pre></td></tr><tr><td data-num="19"></td><td><pre>                    countDownLatch<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>                <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="21"></td><td><pre></pre></td></tr><tr><td data-num="22"></td><td><pre>            <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>        countDownLatch<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>        threadPool<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"finish"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="28"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><hr><p>有没有可以改进的地方呢？** 可以使用 <code>CompletableFuture</code> 类来改进！**Java8 的 <code>CompletableFuture</code> 提供了很多对多线程友好的方法，使用它可以很方便地为我们编写多线程程序，什么异步、串行、并行或者等待所有线程执行完任务什么的都非常方便。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Void</span><span class="token punctuation">></span></span> task1 <span class="token operator">=</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token class-name">CompletableFuture</span><span class="token punctuation">.</span><span class="token function">supplyAsync</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-></span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token comment">// 自定义业务操作</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Void</span><span class="token punctuation">></span></span> task6 <span class="token operator">=</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token class-name">CompletableFuture</span><span class="token punctuation">.</span><span class="token function">supplyAsync</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-></span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token comment">// 自定义业务操作</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Void</span><span class="token punctuation">></span></span> headerFuture<span class="token operator">=</span><span class="token class-name">CompletableFuture</span><span class="token punctuation">.</span><span class="token function">allOf</span><span class="token punctuation">(</span>task1<span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span>task6<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token keyword">try</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    headerFuture<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> ex<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token comment">//......</span></pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"all done. "</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>上面的代码还可以继续优化，当任务过多的时候，把每一个 task 都列出来不太现实，可以考虑<font color="red">通过循环来添加任务</font>。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 文件夹位置</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> filePaths <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">// 异步处理所有文件</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">CompletableFuture</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span><span class="token punctuation">></span></span> fileFutures <span class="token operator">=</span> filePaths<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>filePath <span class="token operator">-></span> <span class="token function">doSomeThing</span><span class="token punctuation">(</span>filePath<span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token comment">// 将他们合并起来</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Void</span><span class="token punctuation">></span></span> allFutures <span class="token operator">=</span> <span class="token class-name">CompletableFuture</span><span class="token punctuation">.</span><span class="token function">allOf</span><span class="token punctuation">(</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    fileFutures<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">CompletableFuture</span><span class="token punctuation">[</span>fileFutures<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h4 id="cyclicbarrier循环栅栏"><a class="anchor" href="#cyclicbarrier循环栅栏">#</a> CyclicBarrier（循环栅栏）</h4><blockquote><p><strong>共享式</strong>的资源访问方式</p></blockquote><h5 id="简介-4"><a class="anchor" href="#简介-4">#</a> 简介</h5><p><strong><code>CyclicBarrier</code> （循环栅栏）和 <code>CountDownLatch</code> 非常类似，也是共享锁，内部通过一个 <code>count</code> 变量作为计数器，其初始值也是 <code>parties</code> 属性（表示拦截的线程数量）的初始值</strong>。</p><p><code>CyclicBarrier</code> 也可以实现线程间的技术等待，但是它的功能比 <code>CountDownLatch</code> 更加复杂和强大，主要应用场景类似。</p><blockquote><p><code>CountDownLatch</code> 的实现是基于 AQS 的，而 <strong><code>CycliBarrier</code> 是基于 <code>ReentrantLock</code> ( <code>ReentrantLock</code> 也属于 AQS 同步器) 和 <code>Condition</code> 的</strong>。</p></blockquote><p><code>CyclicBarrier</code> 的字面意思是<font color="red">可循环使用（Cyclic）的屏障（Barrier）</font>。它要做的事情是：让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。</p><h5 id="原理-4"><a class="anchor" href="#原理-4">#</a> 原理</h5><blockquote><p>难！</p></blockquote><p>每当一个线程到了栅栏这里了，那么就将 count 减 1。当 count 值为 0 时，表示这是这一代最后一个线程到达栅栏，就尝试执行我们构造方法中输入的任务。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 每次拦截的线程数</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> parties<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">// 计数器</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">int</span> count<span class="token punctuation">;</span></pre></td></tr></table></figure><p>结合源码来简单看看。</p><p>1、 <code>CyclicBarrier</code> 默认的构造方法是 <code>CyclicBarrier(int parties)</code> ，参数 <code>parties</code> 表示屏障拦截的线程数量，每个线程调用 <code>await()</code> 方法告诉 <code>CyclicBarrier</code> 我已经到达了屏障，然后当前线程被阻塞。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token class-name">CyclicBarrier</span><span class="token punctuation">(</span><span class="token keyword">int</span> parties<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">this</span><span class="token punctuation">(</span>parties<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">public</span> <span class="token class-name">CyclicBarrier</span><span class="token punctuation">(</span><span class="token keyword">int</span> parties<span class="token punctuation">,</span> <span class="token class-name">Runnable</span> barrierAction<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>parties <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">this</span><span class="token punctuation">.</span>parties <span class="token operator">=</span> parties<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">this</span><span class="token punctuation">.</span>count <span class="token operator">=</span> parties<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">this</span><span class="token punctuation">.</span>barrierCommand <span class="token operator">=</span> barrierAction<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>其中，<strong> <code>parties</code> 就代表了需要拦截的线程数量，当拦截的线程数量达到这个值的时候就打开栅栏，让所有线程通过</strong>。</p><p>2、当调用 <code>CyclicBarrier</code> 对象调用 <code>await()</code> 方法时，实际上调用的是 <code>dowait(false, 0L)</code> 方法。 <code>await()</code> 方法就像树立起一个栅栏的行为一样，将线程挡住了，当拦住的线程数量达到 <code>parties</code> 的值时，栅栏才会打开，线程才得以通过执行。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">,</span> <span class="token class-name">BrokenBarrierException</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  <span class="token keyword">try</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    	<span class="token keyword">return</span> <span class="token function">dowait</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token number">0L</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>  <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">TimeoutException</span> toe<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>   	 <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span>toe<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// cannot happen</span></pre></td></tr><tr><td data-num="6"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><code>dowait(false, 0L)</code> 方法源码分析如下：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 当线程数量或者请求数量达到 count 时 await 之后的方法才会被执行。上面的示例中 count 的值就为 5。</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">int</span> count<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token comment">/**</span></pre></td></tr><tr><td data-num="4"></td><td><pre>     * Main barrier code, covering the various policies.</pre></td></tr><tr><td data-num="5"></td><td><pre>     */</pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">dowait</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> timed<span class="token punctuation">,</span> <span class="token keyword">long</span> nanos<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">,</span> <span class="token class-name">BrokenBarrierException</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="8"></td><td><pre>               <span class="token class-name">TimeoutException</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token keyword">final</span> <span class="token class-name">ReentrantLock</span> lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token comment">// 锁住</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>            <span class="token keyword">final</span> <span class="token class-name">Generation</span> g <span class="token operator">=</span> generation<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre></pre></td></tr><tr><td data-num="15"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>g<span class="token punctuation">.</span>broken<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="16"></td><td><pre>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">BrokenBarrierException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre></pre></td></tr><tr><td data-num="18"></td><td><pre>            <span class="token comment">// 如果线程中断了，抛出异常</span></pre></td></tr><tr><td data-num="19"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>                <span class="token function">breakBarrier</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>            <span class="token comment">//cout 减 1</span></pre></td></tr><tr><td data-num="24"></td><td><pre>            <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token operator">--</span>count<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>            <span class="token comment">// 当 count 数量减为 0 之后说明最后一个线程已经到达栅栏了，也就是达到了可以执行 await 方法之后的条件</span></pre></td></tr><tr><td data-num="26"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// tripped</span></pre></td></tr><tr><td data-num="27"></td><td><pre>                <span class="token keyword">boolean</span> ranAction <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>                <span class="token keyword">try</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>                    <span class="token keyword">final</span> <span class="token class-name">Runnable</span> command <span class="token operator">=</span> barrierCommand<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>command <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="31"></td><td><pre>                        command<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>                    ranAction <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="33"></td><td><pre>                    <span class="token comment">// 将 count 重置为 parties 属性的初始化值</span></pre></td></tr><tr><td data-num="34"></td><td><pre>                    <span class="token comment">// 唤醒之前等待的线程</span></pre></td></tr><tr><td data-num="35"></td><td><pre>                    <span class="token comment">// 下一波执行开始</span></pre></td></tr><tr><td data-num="36"></td><td><pre>                    <span class="token function">nextGeneration</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="37"></td><td><pre>                    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="38"></td><td><pre>                <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="39"></td><td><pre>                    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>ranAction<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="40"></td><td><pre>                        <span class="token function">breakBarrier</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="41"></td><td><pre>                <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="42"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="43"></td><td><pre></pre></td></tr><tr><td data-num="44"></td><td><pre>            <span class="token comment">// loop until tripped, broken, interrupted, or timed out</span></pre></td></tr><tr><td data-num="45"></td><td><pre>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="46"></td><td><pre>                <span class="token keyword">try</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="47"></td><td><pre>                    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>timed<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="48"></td><td><pre>                        trip<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="49"></td><td><pre>                    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nanos <span class="token operator">></span> <span class="token number">0L</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="50"></td><td><pre>                        nanos <span class="token operator">=</span> trip<span class="token punctuation">.</span><span class="token function">awaitNanos</span><span class="token punctuation">(</span>nanos<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="51"></td><td><pre>                <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> ie<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="52"></td><td><pre>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>g <span class="token operator">==</span> generation <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span> g<span class="token punctuation">.</span>broken<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="53"></td><td><pre>                        <span class="token function">breakBarrier</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="54"></td><td><pre>                        <span class="token keyword">throw</span> ie<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="55"></td><td><pre>                    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="56"></td><td><pre>                        <span class="token comment">// We're about to finish waiting even if we had not</span></pre></td></tr><tr><td data-num="57"></td><td><pre>                        <span class="token comment">// been interrupted, so this interrupt is deemed to</span></pre></td></tr><tr><td data-num="58"></td><td><pre>                        <span class="token comment">// "belong" to subsequent execution.</span></pre></td></tr><tr><td data-num="59"></td><td><pre>                        <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="60"></td><td><pre>                    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="61"></td><td><pre>                <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="62"></td><td><pre></pre></td></tr><tr><td data-num="63"></td><td><pre>                <span class="token keyword">if</span> <span class="token punctuation">(</span>g<span class="token punctuation">.</span>broken<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="64"></td><td><pre>                    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">BrokenBarrierException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="65"></td><td><pre></pre></td></tr><tr><td data-num="66"></td><td><pre>                <span class="token keyword">if</span> <span class="token punctuation">(</span>g <span class="token operator">!=</span> generation<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="67"></td><td><pre>                    <span class="token keyword">return</span> index<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="68"></td><td><pre></pre></td></tr><tr><td data-num="69"></td><td><pre>                <span class="token keyword">if</span> <span class="token punctuation">(</span>timed <span class="token operator">&amp;&amp;</span> nanos <span class="token operator">&lt;=</span> <span class="token number">0L</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="70"></td><td><pre>                    <span class="token function">breakBarrier</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="71"></td><td><pre>                    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">TimeoutException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="72"></td><td><pre>                <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="73"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="74"></td><td><pre>        <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="75"></td><td><pre>            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="76"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="77"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id="面试题aqs-的底层原理是什么"><a class="anchor" href="#面试题aqs-的底层原理是什么">#</a> 【面试题】AQS 的底层原理是什么？</h3><blockquote><p>互联网、美团 / 阿里、后端、Java。</p></blockquote><p>**AQS（AbstractQueuedSynchronizer，抽象队列同步器）** 的底层是通过 Java 中的<font color="red"> <code>Lock</code> 接口和 <code>Condition</code> 接口</font>实现的。AQS 是一个抽象类，提供了一种灵活的机制来<font color="red">实现线程间的同步和互斥操作</font>。它提供了两种同步模式：<font color="cornflowerblue">独占模式（Exclusive）</font>和<font color="cornflowerblue">共享模式（Shared）</font>。</p><p>在 AQS 的底层实现中，主要使用了一个 ** 虚拟的双向 FIFO 队列（CLH 队列锁）** 来维护等待获取锁的线程队列。当一个线程请求获取锁时，如果锁已经被其他线程占用，则该线程会被加入到队列中，并进入等待状态。当持有锁的线程释放锁时，AQS 会从队列中选择一个线程唤醒并允许其获取锁。</p><p>AQS 还提供了一些核心的方法，如 acquire 、 release 和 tryAcquire 等，用于实现具体的同步操作。这些方法通过内置的 ** 状态变量（state）** 来记录锁的状态，并根据不同的情况进行相应的操作。</p><h3 id="讲讲你对-aqs-的理解"><a class="anchor" href="#讲讲你对-aqs-的理解">#</a> 讲讲你对 AQS 的理解</h3><p>AQS（AbstractQueuedSynchronizer）是 Java 并发包中一个重要的工具类，它<font color="red">提供了实现锁、同步器的基础框架</font>。</p><ol><li>AQS 是一个<strong>抽象类</strong>，它定义了锁和同步器的基本接口和方法。它的子类可以通过继承 AQS 并重写其中的方法来实现自定义的同步器。</li><li>AQS 通过一个 ** 状态变量（state）** 来表示锁的状态。state 的具体含义对于不同的同步器会有不同的解释，例如，ReentrantLock 中 的 state 表示持有锁的线程数量。</li><li><font color="red">AQS 使用一个 ** 双向队列（CLH 队列锁）** 来管理等待获取资源的线程</font>。每个等待线程会被包装成一个 &quot;Node&quot; 对象，并且会按照一定的顺序排队。</li><li>AQS <font color="red">提供了两个主要的方法： <code>acquire()</code> 和 <code>release()</code> </font>。<ul><li>acquire () 方法用于获取资源，而 release () 方法用于释放资源。</li><li>当一个线程调用 acquire () 方法时，如果资源已经被其他线程占用，那么该线程将会被加入到 CLH 队列 中进行等待。</li></ul></li><li><font color="red">Condition 是 AQS 的一个补充接口，它提供了更为细粒度的等待 / 通知机制</font>。Condition 对象可以通过 AQS 的 newCondition () 方法创建。Condition 底层的实现依赖于 AQS ，并且使用 AQS 队列来管理等待线程。</li><li><font color="red">Condition 的底层原理是基于 AQS 的状态和 CLH 队列</font>。当一个线程调用 Condition 的 await 方法时，该线程会释放持有的 AQS 状态（比如锁），并且进入 Condition 维护的等待队列中等待通知。当另一个线程执行相应的通知操作时，被唤醒的线程可以重新竞争资源。</li></ol><p>总的来说，</p><ul><li>AQS 是 Java 并发包中实现锁和同步器的基础框架。它使用一个双向队列来管理等待获取资源的线程，并提供 acquire 和 release 等方法来获取和释放资源。</li><li>Condition 是 AQS 的补充接口，提供了更为细粒度的等待 / 通知机制。Condition 底层的实现依赖于 AQS 的状态和 CLH 队列。</li></ul><h2 id="reentrantlock-类"><a class="anchor" href="#reentrantlock-类">#</a> ReentrantLock 类</h2><blockquote><p><strong>可重入</strong>式的<strong>独占锁</strong>（悲观锁）</p></blockquote><h3 id="简介-5"><a class="anchor" href="#简介-5">#</a> 简介</h3><p><code>ReentrantLock</code> 实现了 <code>Lock</code> 接口，是一个<font color="red">可重入</font>且<font color="red">独占式</font>的锁，和 <code>synchronized</code> 关键字类似。不过， <code>ReentrantLock</code> 更灵活、更强大，增加了<font color="red">轮询、超时、中断、公平锁和非公平锁</font>等高级功能。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ReentrantLock</span> <span class="token keyword">implements</span> <span class="token class-name">Lock</span><span class="token punctuation">,</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>Serializable</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><code>ReentrantLock</code> 里面有一个<strong>继承自 AQS（ <code>AbstractQueuedSynchronizer</code> ）的内部类 <code>Sync</code> </strong>，添加锁和释放锁的大部分操作实际上都是其中实现的。 <code>Sync</code> 有两个子类：</p><ul><li><font color="cornflowerblue">公平锁 <code>FairSync</code></font></li><li><font color="cornflowerblue">非公平锁 <code>NonfairSync</code></font></li></ul><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/reentrantlock-class-diagram.png" alt="img"></p><p><font color="red"><code>ReentrantLock</code> 默认使用非公平锁</font>，也可以通过构造器来显式的指定使用公平锁。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 传入一个 boolean 值，true 时为公平锁，false 时为非公平锁</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> fair<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    sync <span class="token operator">=</span> fair <span class="token operator">?</span> <span class="token keyword">new</span> <span class="token class-name">FairSync</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token keyword">new</span> <span class="token class-name">NonfairSync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>从上面的内容可以看出， <code>ReentrantLock</code> 的底层就是由 AQS 来实现的。</p><h3 id="公平锁和非公平锁有什么区别"><a class="anchor" href="#公平锁和非公平锁有什么区别">#</a> 公平锁和非公平锁有什么区别？</h3><p><strong>公平锁</strong>:</p><ul><li>锁被释放之后，<strong><font color="red">先申请的线程先得到锁</font></strong>。</li><li><font color="red">性能较差一些</font>，因为公平锁为了保证时间上的绝对顺序，上下文切换更频繁。</li></ul><p><strong>非公平锁</strong>：</p><ul><li>锁被释放之后，<strong><font color="red">后申请的线程可能会先获取到锁</font></strong>，是随机或者按照其他优先级排序的。</li><li><font color="red">性能更好</font>，但可能会导致某些线程永远无法获取到锁。</li><li>例如： <code>synchronized</code></li></ul><h3 id="synchronized-和-reentrantlock-有何异同"><a class="anchor" href="#synchronized-和-reentrantlock-有何异同">#</a> synchronized 和 ReentrantLock 有何异同？</h3><h4 id="都是可重入锁"><a class="anchor" href="#都是可重入锁">#</a> 都是可重入锁</h4><p><strong>可重入锁</strong>也叫递归锁，是指<font color="red">线程可以再次获取自己的内部锁</font>。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，<font color="red">如果是不可重入锁的话，就会造成死锁</font>。</p><p>JDK 提供的所有现成的 <code>Lock</code> 实现类，包括 <code>synchronized</code> 关键字锁都是可重入的。</p><hr><p>在下面的代码中， <code>method1()</code> 和 <code>method2()</code> 都被 <code>synchronized</code> 关键字修饰， <code>method1()</code> 调用了 <code>method2()</code> 。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SynchronizedDemo</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">method1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"方法1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token function">method2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">method2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"方法2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>由于 <code>synchronized</code> 锁是可重入的，同一个线程在调用 <code>method1()</code> 时可以直接获得当前对象的锁，执行 <code>method2()</code> 的时候可以再次获取这个对象的锁，不会产生死锁问题。假如 <code>synchronized</code> 是不可重入锁的话，由于该对象的锁已被当前线程所持有且无法释放，这就导致线程在执行 <code>method2()</code> 时获取锁失败，会出现死锁问题。</p><h4 id="synchronized-依赖于-jvm而-reentrantlock-依赖于-api"><a class="anchor" href="#synchronized-依赖于-jvm而-reentrantlock-依赖于-api">#</a> synchronized 依赖于 JVM，而 ReentrantLock 依赖于 API</h4><p><code>synchronized</code> 是依赖于 JVM 实现的，前面我们也讲到了虚拟机团队在 JDK1.6 为 <code>synchronized</code> 关键字进行了很多优化，但是<font color="red">这些优化都是在虚拟机层面实现的</font>，并没有直接暴露给我们。</p><p><code>ReentrantLock</code> 是 JDK 层面实现的（也就是<font color="red"> API 层面，需要 lock () 和 unlock () 方法配合 try/finally 语句块来完成</font>），所以我们可以通过查看它的源代码，来看它是如何实现的。</p><h4 id="reentrantlock-比-synchronized-增加了一些高级功能"><a class="anchor" href="#reentrantlock-比-synchronized-增加了一些高级功能">#</a> ReentrantLock 比 synchronized 增加了一些高级功能</h4><p>相比 <code>synchronized</code> ， <code>ReentrantLock</code> 增加了一些高级功能。主要来说主要有三点：</p><ul><li><strong>等待可中断</strong> : <code>ReentrantLock</code> 提供了一种能够中断等待锁的线程的机制，通过 <code>lock.lockInterruptibly()</code> 来实现这个机制。也就是说<font color="red">正在等待的线程可以选择放弃等待，改为处理其他事情</font>。</li><li><strong>可实现公平锁</strong> : <code>ReentrantLock</code> 可以指定是公平锁还是非公平锁。<font color="red">而 <code>synchronized</code> 只能是非公平锁</font>。所谓的公平锁就是先等待的线程先获得锁。 <code>ReentrantLock</code> 默认情况是非公平的，可以通过 <code>ReentrantLock</code> 类的 <code>ReentrantLock(boolean fair)</code> 构造方法来指定是否是公平的。</li><li><strong>可实现选择性通知（锁可以绑定多个条件）</strong>: <code>synchronized</code> 关键字与 <code>wait()</code> 和 <code>notify()</code> / <code>notifyAll()</code> 方法相结合可以实现等待 / 通知机制。 <code>ReentrantLock</code> 类当然也可以实现，但是需要借助于 <code>Condition</code> 接口与 <code>newCondition()</code> 方法。</li></ul><p>关于 <code>Condition</code> 接口的补充：</p><blockquote><p><code>Condition</code> 接口是 JDK1.5 之后才有的，它具有很好的灵活性，比如可以实现多路通知功能。也就是在一个 <code>Lock</code> 对象中可以创建多个 <code>Condition</code> 实例（即对象监视器），<strong>线程对象可以注册在指定的 <code>Condition</code> 中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。 在使用 <code>notify()/notifyAll()</code> 方法进行通知时，被通知的线程是由 JVM 选择的，用 <code>ReentrantLock</code> 类结合 <code>Condition</code> 实例可以实现 “选择性通知”</strong> ，这个功能非常重要，而且是 <code>Condition</code> 接口默认提供的。</p><p>而 <code>synchronized</code> 关键字就相当于整个 <code>Lock</code> 对象中只有一个 <code>Condition</code> 实例，所有的线程都注册在它一个身上。如果执行 <code>notifyAll()</code> 方法的话就会通知所有处于等待状态的线程，这样会造成很大的效率问题。而 <code>Condition</code> 实例的 <code>signalAll()</code> 方法，只会唤醒注册在该 <code>Condition</code> 实例中的所有等待线程。</p></blockquote><h3 id="可中断锁和不可中断锁有什么区别"><a class="anchor" href="#可中断锁和不可中断锁有什么区别">#</a> 可中断锁和不可中断锁有什么区别？</h3><blockquote><p>等待可中断</p></blockquote><p><strong>可中断锁</strong>：获取锁的过程中可以被中断，不需要一直等到获取锁之后 才能进行其他逻辑处理。 <code>ReentrantLock</code> 就属于是可中断锁。</p><p><strong>不可中断锁</strong>：一旦线程申请了锁，就只能等到拿到锁以后才能进行其他的逻辑处理。 <code>synchronized</code> 就属于是不可中断锁。</p><h3 id="介绍下-reentrantlock-的底层原理可重入-公平锁和非公平锁的原理"><a class="anchor" href="#介绍下-reentrantlock-的底层原理可重入-公平锁和非公平锁的原理">#</a> 介绍下 ReentrantLock 的底层原理（可重入、公平锁和非公平锁的原理）</h3><ol><li>可重入的原理：<font color="red">ReentrantLock 通过一个计数器（<strong>状态变量 state</strong>）来记录锁的持有线程数</font>。当一个线程第一次获取锁时，计数器加 1，当该线程再次获取锁时，计数器再次加 1。当线程释放锁时，计数器减 1。只有当计数器值为 0 时，表示锁完全释放，其他线程可以获取该锁。</li><li>公平锁和非公平锁的原理：ReentrantLock 提供了公平锁（ <code>FairSync</code> ）和非公平锁（ <code>NonfairSync</code> ）两种模式。</li></ol><ul><li>公平锁模式：当多个线程等待获取锁时，<font color="red">按照线程的申请顺序来获取锁</font>。即先到先得的原则，保证等待时间越久的线程越早获取锁。</li><li>非公平锁模式：当多个线程等待获取锁时，不按照线程的申请顺序来获取锁。即存在一个竞争机制，<font color="red">新来的线程有机会抢占锁</font>，这样可以提高吞吐量。</li></ul><ol start="3"><li>在底层实现上，公平锁和非公平锁的区别在于线程获取锁的方式：</li></ol><ul><li>公平锁先检查队列中是否有正在等待的线程，如果有，则按照 FIFO 的顺序选择锁的持有者。</li><li>非公平锁先尝试直接获取锁，<ul><li>如果失败，则再进入同步队列等待。</li><li>如果失败，则进入队列等待，但在这个等待过程中，可能会允许新来的线程抢占锁。</li></ul></li></ul><p>总结：</p><ul><li>ReentrantLock 通过计数器实现可重入的机制，保证同一个线程可以多次获取同一个锁。</li><li>公平锁和非公平锁的区别在于锁的获取方式，公平锁按照线程等待的顺序进行获取，而非公平锁允许在锁释放时新来的线程有机会优先获取锁。</li></ul><h1 id="线程池"><a class="anchor" href="#线程池">#</a> 线程池</h1><h2 id="线程池-2"><a class="anchor" href="#线程池-2">#</a> 线程池</h2><h3 id="简介-6"><a class="anchor" href="#简介-6">#</a> 简介</h3><p>顾名思义，线程池就是<strong>管理一系列线程的资源池</strong>。当有任务要处理时，直接从线程池中获取线程来处理，<font color="red">处理完之后线程并不会立即被销毁，而是等待下一个任务</font>。</p><p>池化技术的主要思想：<strong>为了减少每次获取资源的消耗</strong>，提高对资源的利用率。</p><p>借用《Java 并发编程的艺术》来说一下<font color="red">使用线程池的好处</font>：</p><ul><li><strong>降低资源消耗</strong>。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li><li><strong>提高响应速度</strong>。当任务到达时，任务可以不需要等到线程创建就能立即执行。</li><li><strong>提高线程的可管理性</strong>。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li></ul><h3 id="executor-框架"><a class="anchor" href="#executor-框架">#</a> Executor 框架</h3><h4 id="简介-7"><a class="anchor" href="#简介-7">#</a> 简介</h4><p><code>Executor</code> 框架是 Java5 之后引进的，<font color="red">通过 <code>Executor</code> 来启动线程比使用 <code>Thread</code> 的 <code>start</code> 方法更好</font>。除了更易管理，效率更好（<font color="red">用线程池实现，节约开销</font>）外，还有关键的一点：<strong><font color="red">有助于避免 this 逃逸问题</font></strong>。</p><blockquote><p><strong>this 逃逸</strong>：在构造函数返回之前，其他线程就持有该对象的引用，调用尚未构造完全的对象的方法，可能引发令人疑惑的错误。</p></blockquote><p><code>Executor</code> 框架不仅包括了<font color="red">线程池的管理</font>，还提供了<font color="red">线程工厂、队列、拒绝策略</font>等， <code>Executor</code> 框架让并发编程变得更加简单。</p><h4 id="三大部分"><a class="anchor" href="#三大部分">#</a> 三大部分</h4><h5 id="任务runnablecallable"><a class="anchor" href="#任务runnablecallable">#</a> 任务（ <code>Runnable</code> / <code>Callable</code> ）</h5><p>执行任务需要实现 <strong><code>Runnable</code> 接口</strong> 或 <strong><code>Callable</code> 接口</strong>，对应的实现类可以被 <strong><code>ThreadPoolExecutor</code> </strong>或 <strong><code>ScheduledThreadPoolExecutor</code> </strong>执行。</p><h5 id="任务的执行executor"><a class="anchor" href="#任务的执行executor">#</a> 任务的执行（ <code>Executor</code> ）</h5><p>如下图所示，包括任务执行机制的核心接口 <code>Executor</code> ，以及继承自它的 <code>ExecutorService</code> 接口。</p><p><strong><code>ThreadPoolExecutor</code> 和 <code>ScheduledThreadPoolExecutor</code> 是两个关键的实现类。</strong></p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/executor-class-diagram.png" alt="img"></p><p><code>ThreadPoolExecutor</code> 类描述：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">//AbstractExecutorService 类实现了 ExecutorService 接口</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadPoolExecutor</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractExecutorService</span></pre></td></tr></table></figure><p><code>ScheduledThreadPoolExecutor</code> 类描述:</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">//ScheduledExecutorService 继承 ExecutorService 接口</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ScheduledThreadPoolExecutor</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token keyword">extends</span> <span class="token class-name">ThreadPoolExecutor</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token keyword">implements</span> <span class="token class-name">ScheduledExecutorService</span></pre></td></tr></table></figure><h5 id="异步计算的结果future"><a class="anchor" href="#异步计算的结果future">#</a> 异步计算的结果（ <code>Future</code> ）</h5><p><strong><code>Future</code> 接口</strong>及<strong>其实现类 <code>FutureTask</code> 类</strong>都可以代表异步计算的结果。</p><p>当我们把 <code>Runnable</code> 接口或 <code>Callable</code> 接口的实现类提交给 <code>ThreadPoolExecutor</code> 或 <code>ScheduledThreadPoolExecutor</code> 执行时，在内部调用 <code>submit()</code> 方法时会返回一个 <code>FutureTask</code> 对象。</p><h4 id="如何使用-2"><a class="anchor" href="#如何使用-2">#</a> 如何使用</h4><p><code>Executor</code> 框架的使用示意图：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231020143912018.png" alt="image-20231020143912018"></p><ol><li><p>主线程首先要创建实现了 <code>Runnable</code> 接口或者 <code>Callable</code> 接口的任务对象。</p></li><li><p>把创建完成的实现了 <code>Runnable</code> / <code>Callable</code> 接口的对象直接交给 <code>ExecutorService</code> 的 <code>execute()</code> 或者 <code>submit()</code> 执行。</p><blockquote><p>由于 <code>FutureTask</code> 实现了 <code>Runnable</code> ，我们也可以直接创建 <code>FutureTask</code> ，然后交给 <code>ExecutorService</code> 执行。</p></blockquote></li><li><p>如果执行的是 <code>ExecutorService.submit（）</code> ，将返回一个实现了 <code>Future</code> 接口的 <code>FutureTask</code> 对象。</p></li><li><p>最后，主线程可以执行 <code>FutureTask.get()</code> 方法来等待任务执行完成。主线程也可以执行 <code>FutureTask.cancel（boolean mayInterruptIfRunning）</code> 来取消此任务的执行。</p></li></ol><h3 id="threadpoolexecutor-类"><a class="anchor" href="#threadpoolexecutor-类">#</a> <mark>ThreadPoolExecutor 类</mark></h3><blockquote><p>线程池实现类 <code>ThreadPoolExecutor</code> 是 <code>Executor</code> 框架最核心的类。</p></blockquote><h4 id="构造方法"><a class="anchor" href="#构造方法">#</a> 构造方法</h4><p><code>ThreadPoolExecutor</code> 类中提供的<font color="red">四个构造方法</font>。我们来看最长的那个，其余三个都是在这个构造方法的基础上产生（其他几个构造方法说白点都是给定某些默认参数的构造方法，比如默认制定拒绝策略是什么）。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">/**</span></pre></td></tr><tr><td data-num="2"></td><td><pre>     * 用给定的初始参数创建一个新的 ThreadPoolExecutor。</pre></td></tr><tr><td data-num="3"></td><td><pre>     */</pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">,</span><span class="token comment">// 线程池的核心线程数量</span></pre></td></tr><tr><td data-num="5"></td><td><pre>                              <span class="token keyword">int</span> maximumPoolSize<span class="token punctuation">,</span><span class="token comment">// 线程池的最大线程数</span></pre></td></tr><tr><td data-num="6"></td><td><pre>                              <span class="token keyword">long</span> keepAliveTime<span class="token punctuation">,</span><span class="token comment">// 当线程数大于核心线程数时，多余的空闲线程存活的最长时间</span></pre></td></tr><tr><td data-num="7"></td><td><pre>                              <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">,</span><span class="token comment">// 时间单位</span></pre></td></tr><tr><td data-num="8"></td><td><pre>                              <span class="token class-name">BlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">></span></span> workQueue<span class="token punctuation">,</span><span class="token comment">// 任务队列，用来储存等待执行任务的队列</span></pre></td></tr><tr><td data-num="9"></td><td><pre>                              <span class="token class-name">ThreadFactory</span> threadFactory<span class="token punctuation">,</span><span class="token comment">// 线程工厂，用来创建线程，一般默认即可</span></pre></td></tr><tr><td data-num="10"></td><td><pre>                              <span class="token class-name">RejectedExecutionHandler</span> handler<span class="token comment">// 拒绝策略，当提交的任务过多而不能及时处理时，我们可以定制策略来处理任务</span></pre></td></tr><tr><td data-num="11"></td><td><pre>                               <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>corePoolSize <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span></pre></td></tr><tr><td data-num="13"></td><td><pre>            maximumPoolSize <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">||</span></pre></td></tr><tr><td data-num="14"></td><td><pre>            maximumPoolSize <span class="token operator">&lt;</span> corePoolSize <span class="token operator">||</span></pre></td></tr><tr><td data-num="15"></td><td><pre>            keepAliveTime <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="16"></td><td><pre>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>workQueue <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> threadFactory <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> handler <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="18"></td><td><pre>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>        <span class="token keyword">this</span><span class="token punctuation">.</span>corePoolSize <span class="token operator">=</span> corePoolSize<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>        <span class="token keyword">this</span><span class="token punctuation">.</span>maximumPoolSize <span class="token operator">=</span> maximumPoolSize<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>        <span class="token keyword">this</span><span class="token punctuation">.</span>workQueue <span class="token operator">=</span> workQueue<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>        <span class="token keyword">this</span><span class="token punctuation">.</span>keepAliveTime <span class="token operator">=</span> unit<span class="token punctuation">.</span><span class="token function">toNanos</span><span class="token punctuation">(</span>keepAliveTime<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>        <span class="token keyword">this</span><span class="token punctuation">.</span>threadFactory <span class="token operator">=</span> threadFactory<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>        <span class="token keyword">this</span><span class="token punctuation">.</span>handler <span class="token operator">=</span> handler<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h4 id="常见参数"><a class="anchor" href="#常见参数">#</a> <mark>常见参数</mark></h4><p><code>ThreadPoolExecutor</code> 3 个最重要的参数：</p><ul><li><strong><code>corePoolSize</code> :</strong> <font color="gree">核心线程数量</font>。<font color="red">当任务队列未达到队列容量时</font>，最大可以同时运行的线程数量。如果没有全局设置池内线程的过期时间，池内会维持此数量线程。</li><li><strong><code>maximumPoolSize</code> </strong>: <font color="gree">最大线程数量</font>。<font color="red">当核心线程都在运行任务，并且任务队列中的任务数量已满</font>，此时会创建<font color="red">非核心线程</font>，当前池内可以同时运行的线程数量变为最大线程数。</li><li><strong><code>workQueue</code> </strong>：<font color="gree">用于存放池内任务的任务队列</font>。新任务到来时会先判断<font color="red">当前运行的线程数量是否达到核心线程数</font>，如果达到的话，新任务就会先被存放在任务队列中。</li></ul><p>其他常见参数:</p><ul><li><strong><code>keepAliveTime</code> </strong>：<font color="gree">当线程数大于  <code>corePoolSize</code> 时，多余的空闲线程能够存活的最长时间</font>。<ul><li>当线程池中的线程数量大于 <code>corePoolSize</code> 时，如果这时没有新的任务提交，多余的空闲线程不会立即销毁，而是会等待，直到等待的时间超过了 <code>keepAliveTime</code> 才会被回收销毁。</li><li>线程池回收线程时，会对核心线程和非核心线程一视同仁，直到线程池中线程的数量等于 <code>corePoolSize</code> ，回收过程才会停止。</li></ul></li><li><strong><code>unit</code> </strong>： <code>keepAliveTime</code> 参数的<font color="gree">时间单位</font>。</li><li><strong><code>threadFactory</code> </strong>:<font color="gree">线程工厂</font>，用来创建线程（包括优先级、名称、守护状态等属性的初始化），一般默认即可。</li><li><strong><code>handler</code> </strong>：<font color="gree">拒绝策略 / 饱和策略</font>。当池内线程都在运行，同时任务队列也满时，可以制定相关策略来处理新来的任务。JDK 线程池中实现了四种拒绝策略，默认 AbortPolicy，抛出异常。</li></ul><p>对线程池中各个参数的相互关系的理解：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231018163149255.png" alt="image-20231018163149255"></p><h4 id="饱和策略"><a class="anchor" href="#饱和策略">#</a> 饱和策略</h4><p>如果当前同时运行的线程数量达到 <code>maximumPoolSize</code> ，并且 <code>workQueue</code> 也被放满任务时， <code>ThreadPoolTaskExecutor</code> 定义一些策略：</p><ul><li>ThreadPoolExecutor.<strong> <code>AbortPolicy</code> </strong>：<font color="red">默认的饱和策略</font>。抛出 <code>RejectedExecutionException</code> 异常来<font color="gree">拒绝新任务的处理</font>。</li><li>ThreadPoolExecutor.<strong> <code>CallerRunsPolicy</code> </strong>：它既<font color="gree">不会抛弃任务</font>，也不会抛出异常，而是<font color="gree">将任务回退给调用者，使用调用者的线程来执行任务</font>。直接在调用 <code>execute</code> 方法的调用者线程中运行 ( <code>run</code> ) 任务。如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。如果您的应用程序可以承受此延迟并且你要求任何一个任务请求都要被执行的话，你可以选择这个策略。</li><li>ThreadPoolExecutor.<strong> <code>DiscardPolicy</code> </strong>：不处理新任务，<font color="gree">直接丢弃掉</font>。</li><li>ThreadPoolExecutor.<strong> <code>DiscardOldestPolicy</code> </strong>：此策略将<font color="gree">丢弃最早的未处理的任务请求</font>。</li></ul><hr><p>举个例子：</p><p>Spring 通过 <code>ThreadPoolTaskExecutor</code> 或者我们直接通过 <code>ThreadPoolExecutor</code> 的构造函数创建线程池的时候，当我们不指定 <code>RejectedExecutionHandler</code> 饱和策略来配置线程池的时候，默认使用的是 <code>AbortPolicy</code> 。在这种饱和策略下，如果队列满了， <code>ThreadPoolExecutor</code> 将抛出 <code>RejectedExecutionException</code> 异常来拒绝新来的任务 ，这代表你将丢失对这个任务的处理。</p><p>如果不想丢弃任务的话，可以使用 <code>CallerRunsPolicy</code> 。和其他的几个策略不同，它既不会抛弃任务，也不会抛出异常，而是将任务回退给调用者，使用调用者的线程来执行任务。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">CallerRunsPolicy</span> <span class="token keyword">implements</span> <span class="token class-name">RejectedExecutionHandler</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token keyword">public</span> <span class="token class-name">CallerRunsPolicy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">rejectedExecution</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> r<span class="token punctuation">,</span> <span class="token class-name">ThreadPoolExecutor</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>e<span class="token punctuation">.</span><span class="token function">isShutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>                <span class="token comment">// 直接主线程执行，而不是线程池中的线程执行</span></pre></td></tr><tr><td data-num="8"></td><td><pre>                r<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h4 id="线程池的创建方式"><a class="anchor" href="#线程池的创建方式">#</a> 线程池的创建方式</h4><h5 id="方式1threadpoolexecutor-类的构造函数"><a class="anchor" href="#方式1threadpoolexecutor-类的构造函数">#</a> 方式 1：ThreadPoolExecutor 类的构造函数</h5><blockquote><p>推荐！</p></blockquote><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231015003053159.png" alt="image-20231015003053159"></p><h5 id="方式2executor-框架的-executors-工具类"><a class="anchor" href="#方式2executor-框架的-executors-工具类">#</a> 方式 2：Executor 框架的 Executors 工具类</h5><blockquote><p>不推荐～</p></blockquote><p>我们可以创建多种类型的 <code>ThreadPoolExecutor</code> ：</p><ul><li><strong><code>FixedThreadPool</code> </strong>：该方法返回一个<font color="red">固定线程数量</font>的线程池。<ul><li>该线程池中的线程数量始终不变。</li><li>当有一个新的任务提交时，<ul><li>若线程池中有空闲线程，则立即执行。</li><li>若线程池中没有空间线程，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。</li></ul></li></ul></li><li><strong><code>SingleThreadExecutor</code> ：</strong> 该方法返回一个<font color="red">只有一个线程</font>的线程池。<ul><li>若多于一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。</li></ul></li><li><strong><code>CachedThreadPool</code> ：</strong> 该方法返回一个<font color="red">会根据需要创建线程</font>的线程池。<ul><li>初始大小为 0。</li><li>当有新任务提交时，如果当前线程池中没有线程可用，它会创建一个新的线程来处理该任务。</li><li>如果在一段时间内（默认为 60 秒）没有新任务提交，核心线程会超时并被销毁，从而缩小线程池的大小。</li></ul></li><li><strong><code>ScheduledThreadPool</code> </strong>：该方法返回一个用来<font color="red">在给定的延迟后，或者定期执行任务</font>的线程池。</li></ul><p>对应 <code>Executors</code> 工具类中的方法如图所示：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/executors-inner-threadpool.png" alt="img"></p><p>在《阿里巴巴 Java 开发手册》“并发处理” 这一章节，明确指出<strong>线程资源必须通过线程池提供，不允许在应用中自行显式创建线程</strong>。</p><blockquote><p>原因：<font color="red">使用线程池可以减少在创建和销毁线程上所消耗的开销</font>，解决资源不足的问题。如果不使用线程池，有可能会造成系统创建大量同类线程而导致消耗完内存或者 “过度切换” 的问题。</p></blockquote><p>另外，《阿里巴巴 Java 开发手册》中<strong>强制线程池不允许使用 <code>Executors</code> 工具类去创建，而是通过 <code>ThreadPoolExecutor</code> 构造函数的方式</strong>。这样的处理方式让写的同学更加明确线程池的运行规则，<font color="red">规避资源耗尽（OOM）的风险</font>。</p><p><code>Executors</code> 工具类返回线程池对象的弊端如下 (后文会详细介绍到)：</p><ul><li><strong><code>FixedThreadPool</code> 和 <code>SingleThreadExecutor</code> </strong>：使用的是无界的 <code>LinkedBlockingQueue</code> ，任务队列最大长度为 <code>Integer.MAX_VALUE</code> ，<font color="red">可能堆积大量的请求，从而导致 OOM</font>。</li><li><strong><code>CachedThreadPool</code> </strong>：使用的是同步队列 <code>SynchronousQueue</code> ，允许创建的线程数量为 <code>Integer.MAX_VALUE</code> ，如果任务数量过多且执行速度较慢，<font color="red">可能会创建大量的线程，从而导致 OOM</font>。</li><li><strong><code>ScheduledThreadPool</code> 和 <code>SingleThreadScheduledExecutor</code> </strong>: 使用的无界的延迟阻塞队列 <code>DelayedWorkQueue</code> ，任务队列最大长度为 <code>Integer.MAX_VALUE</code> ，可能堆积大量的请求，从而导致 OOM 。</li></ul><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 无界队列 LinkedBlockingQueue</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">ExecutorService</span> <span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token keyword">int</span> nThreads<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span>nThreads<span class="token punctuation">,</span> nThreads<span class="token punctuation">,</span><span class="token number">0L</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">MILLISECONDS</span><span class="token punctuation">,</span><span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token comment">// 无界队列 LinkedBlockingQueue</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">ExecutorService</span> <span class="token function">newSingleThreadExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">FinalizableDelegatedExecutorService</span> <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0L</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">MILLISECONDS</span><span class="token punctuation">,</span><span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token comment">// 同步队列 SynchronousQueue，没有容量，最大线程数是 Integer.MAX_VALUE`</span></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">ExecutorService</span> <span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="17"></td><td><pre></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token constant">MAX_VALUE</span><span class="token punctuation">,</span><span class="token number">60L</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">,</span><span class="token keyword">new</span> <span class="token class-name">SynchronousQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre></pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="21"></td><td><pre></pre></td></tr><tr><td data-num="22"></td><td><pre><span class="token comment">// DelayedWorkQueue（延迟阻塞队列）</span></pre></td></tr><tr><td data-num="23"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">ScheduledExecutorService</span> <span class="token function">newScheduledThreadPool</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ScheduledThreadPoolExecutor</span><span class="token punctuation">(</span>corePoolSize<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="26"></td><td><pre><span class="token keyword">public</span> <span class="token class-name">ScheduledThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>    <span class="token keyword">super</span><span class="token punctuation">(</span>corePoolSize<span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token constant">MAX_VALUE</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token constant">NANOSECONDS</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="28"></td><td><pre>          <span class="token keyword">new</span> <span class="token class-name">DelayedWorkQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="29"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h4 id="常用的阻塞队列"><a class="anchor" href="#常用的阻塞队列">#</a> 常用的阻塞队列</h4><blockquote><p>即任务队列。难！</p></blockquote><p>新任务来的时候会先判断当前运行的线程数量是否达到 <code>corePoolSize</code> ，如果达到的话，新任务就会被存放在阻塞队列 <code>workQueue</code> 中。</p><p>不同的线程池会选用不同的阻塞队列，我们可以结合内置线程池来分析：</p><ul><li><p><strong>无界阻塞队列 <code>LinkedBlockingQueue</code> </strong>：</p><ul><li>容量为 <code>Integer.MAX_VALUE</code></li><li><code>FixedThreadPool</code> 和 <code>SingleThreadExector</code> 这两种线程池都是用的是无界队列，因此二者的任务队列永远不会被放满。</li><li><code>FixedThreadPool</code> 最多只能创建 <code>corePoolSize</code> 个线程</li><li><code>SingleThreadExector</code> 只能创建 1 个线程</li></ul></li><li><p><strong>同步队列 <code>SynchronousQueue</code> </strong>：</p><ul><li><font color="red">容量为 0，不存储元素</font>。</li><li>目的是保证对于提交的任务，如果有空闲线程，则使用空闲线程来处理；否则新建一个线程来处理任务。</li><li><code>CachedThreadPool</code> 线程池使用的是同步队列。</li><li>也就是说， <code>CachedThreadPool</code> 的最大线程数是 <code>Integer.MAX_VALUE</code> ，可以理解为线程数是可以无限扩展的，可能会创建大量线程，从而导致 OOM 。</li></ul></li><li><p><strong>延迟阻塞队列 <code>DelayedWorkQueue</code> </strong>：</p><ul><li>该队列的<font color="red">内部元素并不是按照放入的时间排序，而是会按照延迟的时间长短对任务进行排序</font>。内部采用的是 “堆” 的数据结构，可以保证每次出队的任务都是当前队列中执行时间最靠前的。</li><li><code>ScheduledThreadPool</code> 和 <code>SingleThreadScheduledExecutor</code> 这两种线程池使用的是延迟阻塞队列。</li><li><code>DelayedWorkQueue</code> 添加元素满了之后会自动<font color="red">扩容原来容量的 1/2</font>，即永远不会阻塞，最大扩容可达 <code>Integer.MAX_VALUE</code> ，所以最多只能创建 <code>corePoolSize</code> 个线程。</li></ul></li></ul><h3 id="线程池原理分析"><a class="anchor" href="#线程池原理分析">#</a> <mark>线程池原理分析</mark></h3><p>我们上面讲解了 <code>Executor</code> 框架以及 <code>ThreadPoolExecutor</code> 类，下面让我们实战一下，来通过写一个 <code>ThreadPoolExecutor</code> 的小 Demo 来回顾上面的内容。</p><h4 id="threadpoolexecutor-示例代码"><a class="anchor" href="#threadpoolexecutor-示例代码">#</a> ThreadPoolExecutor 示例代码</h4><p>首先创建一个 <code>Runnable</code> 接口的实现类（也可以是 <code>Callable</code> 接口的实现类）</p><p><code>MyRunnable.java</code> ：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Date</span></span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">/**</span></pre></td></tr><tr><td data-num="4"></td><td><pre> * 这是一个简单的 Runnable 类，需要大约 5 秒钟来执行其任务。</pre></td></tr><tr><td data-num="5"></td><td><pre> * @author shuang.kou</pre></td></tr><tr><td data-num="6"></td><td><pre> */</pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyRunnable</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">private</span> <span class="token class-name">String</span> command<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">MyRunnable</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token keyword">this</span><span class="token punctuation">.</span>command <span class="token operator">=</span> s<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token annotation punctuation">@Override</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" Start. Time = "</span> <span class="token operator">+</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>        <span class="token function">processCommand</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" End. Time = "</span> <span class="token operator">+</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="21"></td><td><pre></pre></td></tr><tr><td data-num="22"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">processCommand</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>            <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="29"></td><td><pre></pre></td></tr><tr><td data-num="30"></td><td><pre>    <span class="token annotation punctuation">@Override</span></pre></td></tr><tr><td data-num="31"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>command<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="33"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="34"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>编写测试程序，我们这里以阿里巴巴推荐的使用 <code>ThreadPoolExecutor</code> 构造函数自定义参数的方式来创建线程池。</p><p><code>ThreadPoolExecutorDemo.java</code> ：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token class-name">ArrayBlockingQueue</span></span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token class-name">ThreadPoolExecutor</span></span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token class-name">TimeUnit</span></span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadPoolExecutorDemo</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">CORE_POOL_SIZE</span> <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">MAX_POOL_SIZE</span> <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">QUEUE_CAPACITY</span> <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Long</span> <span class="token constant">KEEP_ALIVE_TIME</span> <span class="token operator">=</span> <span class="token number">1L</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token comment">// 使用阿里巴巴推荐的创建线程池的方式</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token comment">// 通过 ThreadPoolExecutor 构造函数自定义参数创建</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token class-name">ThreadPoolExecutor</span> executor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span></pre></td></tr><tr><td data-num="16"></td><td><pre>                <span class="token constant">CORE_POOL_SIZE</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="17"></td><td><pre>                <span class="token constant">MAX_POOL_SIZE</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="18"></td><td><pre>                <span class="token constant">KEEP_ALIVE_TIME</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="19"></td><td><pre>                <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="20"></td><td><pre>                <span class="token keyword">new</span> <span class="token class-name">ArrayBlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token constant">QUEUE_CAPACITY</span><span class="token punctuation">)</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="21"></td><td><pre>                <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor<span class="token punctuation">.</span>CallerRunsPolicy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre></pre></td></tr><tr><td data-num="23"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>            <span class="token comment">// 创建 WorkerThread 对象（WorkerThread 类实现了 Runnable 接口）</span></pre></td></tr><tr><td data-num="25"></td><td><pre>            <span class="token class-name">Runnable</span> worker <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyRunnable</span><span class="token punctuation">(</span><span class="token string">""</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>            <span class="token comment">// 执行 Runnable</span></pre></td></tr><tr><td data-num="27"></td><td><pre>            executor<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>worker<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>        <span class="token comment">// 终止线程池</span></pre></td></tr><tr><td data-num="30"></td><td><pre>        executor<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="31"></td><td><pre>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>executor<span class="token punctuation">.</span><span class="token function">isTerminated</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="33"></td><td><pre>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Finished all threads"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="34"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="35"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>上面的代码指定了：</p><ul><li><code>corePoolSize</code> : 核心线程数为 5。</li><li><code>maximumPoolSize</code> ：最大线程数 10</li><li><code>keepAliveTime</code> : 等待时间为 1L。</li><li><code>unit</code> : 等待时间的单位为 TimeUnit.SECONDS。</li><li><code>workQueue</code> ：任务队列为 <code>ArrayBlockingQueue</code> ，并且容量为 100;</li><li><code>handler</code> : 饱和策略为 <code>CallerRunsPolicy</code> 。</li></ul><p>输出结构：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre>pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">3</span> <span class="token class-name">Start<span class="token punctuation">.</span> Time</span> <span class="token operator">=</span> <span class="token class-name">Sun</span> <span class="token class-name">Apr</span> <span class="token number">12</span> <span class="token number">11</span><span class="token operator">:</span><span class="token number">14</span><span class="token operator">:</span><span class="token number">37</span> <span class="token constant">CST</span> <span class="token number">2020</span></pre></td></tr><tr><td data-num="2"></td><td><pre>pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">5</span> <span class="token class-name">Start<span class="token punctuation">.</span> Time</span> <span class="token operator">=</span> <span class="token class-name">Sun</span> <span class="token class-name">Apr</span> <span class="token number">12</span> <span class="token number">11</span><span class="token operator">:</span><span class="token number">14</span><span class="token operator">:</span><span class="token number">37</span> <span class="token constant">CST</span> <span class="token number">2020</span></pre></td></tr><tr><td data-num="3"></td><td><pre>pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">2</span> <span class="token class-name">Start<span class="token punctuation">.</span> Time</span> <span class="token operator">=</span> <span class="token class-name">Sun</span> <span class="token class-name">Apr</span> <span class="token number">12</span> <span class="token number">11</span><span class="token operator">:</span><span class="token number">14</span><span class="token operator">:</span><span class="token number">37</span> <span class="token constant">CST</span> <span class="token number">2020</span></pre></td></tr><tr><td data-num="4"></td><td><pre>pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">1</span> <span class="token class-name">Start<span class="token punctuation">.</span> Time</span> <span class="token operator">=</span> <span class="token class-name">Sun</span> <span class="token class-name">Apr</span> <span class="token number">12</span> <span class="token number">11</span><span class="token operator">:</span><span class="token number">14</span><span class="token operator">:</span><span class="token number">37</span> <span class="token constant">CST</span> <span class="token number">2020</span></pre></td></tr><tr><td data-num="5"></td><td><pre>pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">4</span> <span class="token class-name">Start<span class="token punctuation">.</span> Time</span> <span class="token operator">=</span> <span class="token class-name">Sun</span> <span class="token class-name">Apr</span> <span class="token number">12</span> <span class="token number">11</span><span class="token operator">:</span><span class="token number">14</span><span class="token operator">:</span><span class="token number">37</span> <span class="token constant">CST</span> <span class="token number">2020</span></pre></td></tr><tr><td data-num="6"></td><td><pre>pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">3</span> <span class="token class-name">End<span class="token punctuation">.</span> Time</span> <span class="token operator">=</span> <span class="token class-name">Sun</span> <span class="token class-name">Apr</span> <span class="token number">12</span> <span class="token number">11</span><span class="token operator">:</span><span class="token number">14</span><span class="token operator">:</span><span class="token number">42</span> <span class="token constant">CST</span> <span class="token number">2020</span></pre></td></tr><tr><td data-num="7"></td><td><pre>pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">4</span> <span class="token class-name">End<span class="token punctuation">.</span> Time</span> <span class="token operator">=</span> <span class="token class-name">Sun</span> <span class="token class-name">Apr</span> <span class="token number">12</span> <span class="token number">11</span><span class="token operator">:</span><span class="token number">14</span><span class="token operator">:</span><span class="token number">42</span> <span class="token constant">CST</span> <span class="token number">2020</span></pre></td></tr><tr><td data-num="8"></td><td><pre>pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">1</span> <span class="token class-name">End<span class="token punctuation">.</span> Time</span> <span class="token operator">=</span> <span class="token class-name">Sun</span> <span class="token class-name">Apr</span> <span class="token number">12</span> <span class="token number">11</span><span class="token operator">:</span><span class="token number">14</span><span class="token operator">:</span><span class="token number">42</span> <span class="token constant">CST</span> <span class="token number">2020</span></pre></td></tr><tr><td data-num="9"></td><td><pre>pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">5</span> <span class="token class-name">End<span class="token punctuation">.</span> Time</span> <span class="token operator">=</span> <span class="token class-name">Sun</span> <span class="token class-name">Apr</span> <span class="token number">12</span> <span class="token number">11</span><span class="token operator">:</span><span class="token number">14</span><span class="token operator">:</span><span class="token number">42</span> <span class="token constant">CST</span> <span class="token number">2020</span></pre></td></tr><tr><td data-num="10"></td><td><pre>pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">1</span> <span class="token class-name">Start<span class="token punctuation">.</span> Time</span> <span class="token operator">=</span> <span class="token class-name">Sun</span> <span class="token class-name">Apr</span> <span class="token number">12</span> <span class="token number">11</span><span class="token operator">:</span><span class="token number">14</span><span class="token operator">:</span><span class="token number">42</span> <span class="token constant">CST</span> <span class="token number">2020</span></pre></td></tr><tr><td data-num="11"></td><td><pre>pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">2</span> <span class="token class-name">End<span class="token punctuation">.</span> Time</span> <span class="token operator">=</span> <span class="token class-name">Sun</span> <span class="token class-name">Apr</span> <span class="token number">12</span> <span class="token number">11</span><span class="token operator">:</span><span class="token number">14</span><span class="token operator">:</span><span class="token number">42</span> <span class="token constant">CST</span> <span class="token number">2020</span></pre></td></tr><tr><td data-num="12"></td><td><pre>pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">5</span> <span class="token class-name">Start<span class="token punctuation">.</span> Time</span> <span class="token operator">=</span> <span class="token class-name">Sun</span> <span class="token class-name">Apr</span> <span class="token number">12</span> <span class="token number">11</span><span class="token operator">:</span><span class="token number">14</span><span class="token operator">:</span><span class="token number">42</span> <span class="token constant">CST</span> <span class="token number">2020</span></pre></td></tr><tr><td data-num="13"></td><td><pre>pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">4</span> <span class="token class-name">Start<span class="token punctuation">.</span> Time</span> <span class="token operator">=</span> <span class="token class-name">Sun</span> <span class="token class-name">Apr</span> <span class="token number">12</span> <span class="token number">11</span><span class="token operator">:</span><span class="token number">14</span><span class="token operator">:</span><span class="token number">42</span> <span class="token constant">CST</span> <span class="token number">2020</span></pre></td></tr><tr><td data-num="14"></td><td><pre>pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">3</span> <span class="token class-name">Start<span class="token punctuation">.</span> Time</span> <span class="token operator">=</span> <span class="token class-name">Sun</span> <span class="token class-name">Apr</span> <span class="token number">12</span> <span class="token number">11</span><span class="token operator">:</span><span class="token number">14</span><span class="token operator">:</span><span class="token number">42</span> <span class="token constant">CST</span> <span class="token number">2020</span></pre></td></tr><tr><td data-num="15"></td><td><pre>pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">2</span> <span class="token class-name">Start<span class="token punctuation">.</span> Time</span> <span class="token operator">=</span> <span class="token class-name">Sun</span> <span class="token class-name">Apr</span> <span class="token number">12</span> <span class="token number">11</span><span class="token operator">:</span><span class="token number">14</span><span class="token operator">:</span><span class="token number">42</span> <span class="token constant">CST</span> <span class="token number">2020</span></pre></td></tr><tr><td data-num="16"></td><td><pre>pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">1</span> <span class="token class-name">End<span class="token punctuation">.</span> Time</span> <span class="token operator">=</span> <span class="token class-name">Sun</span> <span class="token class-name">Apr</span> <span class="token number">12</span> <span class="token number">11</span><span class="token operator">:</span><span class="token number">14</span><span class="token operator">:</span><span class="token number">47</span> <span class="token constant">CST</span> <span class="token number">2020</span></pre></td></tr><tr><td data-num="17"></td><td><pre>pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">4</span> <span class="token class-name">End<span class="token punctuation">.</span> Time</span> <span class="token operator">=</span> <span class="token class-name">Sun</span> <span class="token class-name">Apr</span> <span class="token number">12</span> <span class="token number">11</span><span class="token operator">:</span><span class="token number">14</span><span class="token operator">:</span><span class="token number">47</span> <span class="token constant">CST</span> <span class="token number">2020</span></pre></td></tr><tr><td data-num="18"></td><td><pre>pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">5</span> <span class="token class-name">End<span class="token punctuation">.</span> Time</span> <span class="token operator">=</span> <span class="token class-name">Sun</span> <span class="token class-name">Apr</span> <span class="token number">12</span> <span class="token number">11</span><span class="token operator">:</span><span class="token number">14</span><span class="token operator">:</span><span class="token number">47</span> <span class="token constant">CST</span> <span class="token number">2020</span></pre></td></tr><tr><td data-num="19"></td><td><pre>pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">3</span> <span class="token class-name">End<span class="token punctuation">.</span> Time</span> <span class="token operator">=</span> <span class="token class-name">Sun</span> <span class="token class-name">Apr</span> <span class="token number">12</span> <span class="token number">11</span><span class="token operator">:</span><span class="token number">14</span><span class="token operator">:</span><span class="token number">47</span> <span class="token constant">CST</span> <span class="token number">2020</span></pre></td></tr><tr><td data-num="20"></td><td><pre>pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">2</span> <span class="token class-name">End<span class="token punctuation">.</span> Time</span> <span class="token operator">=</span> <span class="token class-name">Sun</span> <span class="token class-name">Apr</span> <span class="token number">12</span> <span class="token number">11</span><span class="token operator">:</span><span class="token number">14</span><span class="token operator">:</span><span class="token number">47</span> <span class="token constant">CST</span> <span class="token number">2020</span></pre></td></tr><tr><td data-num="21"></td><td><pre><span class="token class-name">Finished</span> all threads  <span class="token comment">// 任务全部执行完了才会跳出来，因为 executor.isTerminated () 判断为 true 了才会跳出 while 循环，当且仅当调用 shutdown () 方法后，并且所有提交的任务完成后返回为 true</span></pre></td></tr></table></figure><h4 id="线程池原理分析处理任务的流程"><a class="anchor" href="#线程池原理分析处理任务的流程">#</a> <mark>线程池原理分析（处理任务的流程）</mark></h4><p>在示例代码中，我们使用 <code>executor.execute(worker)</code> 来提交一个任务到线程池中去。为了搞懂线程池的原理，我们需要首先分析一下 <code>execute()</code> 方法，源码如下：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 存放线程池的运行状态 (runState) 和线程池内有效线程的数量 (workerCount)</span></pre></td></tr><tr><td data-num="2"></td><td><pre>   <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">AtomicInteger</span> ctl <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token function">ctlOf</span><span class="token punctuation">(</span><span class="token constant">RUNNING</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">workerCountOf</span><span class="token punctuation">(</span><span class="token keyword">int</span> c<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">return</span> c <span class="token operator">&amp;</span> <span class="token constant">CAPACITY</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token comment">// 任务队列</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">BlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">></span></span> workQueue<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> command<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token comment">// 如果任务为 null，则抛出异常。</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>command <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="13"></td><td><pre>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token comment">//ctl 中保存的线程池当前的一些状态信息</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token keyword">int</span> c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token comment">//  下面会涉及到 3 步 操作</span></pre></td></tr><tr><td data-num="18"></td><td><pre>        <span class="token comment">// 1. 首先判断当前线程池中执行的任务数量是否小于 corePoolSize</span></pre></td></tr><tr><td data-num="19"></td><td><pre>        <span class="token comment">// 如果小于的话，通过 addWorker (command, true) 新建一个线程，并将任务 (command) 添加到该线程中；然后，启动该线程从而执行任务。</span></pre></td></tr><tr><td data-num="20"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">workerCountOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">&lt;</span> corePoolSize<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">addWorker</span><span class="token punctuation">(</span>command<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="22"></td><td><pre>                <span class="token keyword">return</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>            c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>        <span class="token comment">// 2. 如果当前执行的任务数量大于等于 corePoolSize 的时候就会走到这里，表明创建新的线程失败。</span></pre></td></tr><tr><td data-num="26"></td><td><pre>        <span class="token comment">// 通过 isRunning 方法判断线程池状态，线程池处于 RUNNING 状态并且队列可以加入任务，该任务才会被加入进去</span></pre></td></tr><tr><td data-num="27"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isRunning</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> workQueue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>            <span class="token keyword">int</span> recheck <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>            <span class="token comment">// 再次获取线程池状态，如果线程池状态不是 RUNNING 状态就需要从任务队列中移除任务，并尝试判断线程是否全部执行完毕。同时执行拒绝策略。</span></pre></td></tr><tr><td data-num="30"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isRunning</span><span class="token punctuation">(</span>recheck<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">remove</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="31"></td><td><pre>                <span class="token function">reject</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>                <span class="token comment">// 如果当前工作线程数量为 0，新创建一个线程并执行。</span></pre></td></tr><tr><td data-num="33"></td><td><pre>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">workerCountOf</span><span class="token punctuation">(</span>recheck<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="34"></td><td><pre>                <span class="token function">addWorker</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="35"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="36"></td><td><pre>        <span class="token comment">//3. 通过 addWorker (command, false) 新建一个线程，并将任务 (command) 添加到该线程中；然后，启动该线程从而执行任务。</span></pre></td></tr><tr><td data-num="37"></td><td><pre>        <span class="token comment">// 传入 false 代表增加线程时判断当前线程数是否少于 maxPoolSize</span></pre></td></tr><tr><td data-num="38"></td><td><pre>        <span class="token comment">// 如果 addWorker (command, false) 执行失败，则通过 reject () 执行相应的拒绝策略的内容。</span></pre></td></tr><tr><td data-num="39"></td><td><pre>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">addWorker</span><span class="token punctuation">(</span>command<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="40"></td><td><pre>            <span class="token function">reject</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="41"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><hr><p><strong>简单分析一下整个流程</strong>：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/thread-pool-principle.png" alt="图解线程池实现原理"></p><ol><li><p>如果 当前运行的线程数 ＜ <code>corePoolSize</code> ，那么就会<font color="red">新建一个线程</font>来执行任务。</p></li><li><p>如果 <code>corePoolSize</code> ≤ 当前运行的线程数 ＜ <code>maximumPoolSize</code> ，那么就<font color="red">把该任务放入到任务队列里等待执行</font>。</p><ol><li><font color="red">如果向任务队列添加任务失败（即任务队列已经满了），就新建一个线程</font>来执行任务。</li></ol></li><li><p>如果 当前运行的线程数 == <code>maximumPoolSize</code> ，此时任务队列、线程池都满了，那么会根据<font color="red">饱和策略</font>来处理无法接收的任务，比如抛出异常或者丢弃任务。</p></li></ol><hr><p>在 <code>execute()</code> 方法中，多次调用 <code>addWorker()</code> 方法，该方法主要用来<font color="red">创建新的工作线程</font>，如果创建和启动工作线程成功则返回 true ，否则返回 false。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 全局锁，并发操作必备</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">ReentrantLock</span> mainLock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token comment">// 跟踪线程池的最大大小，只有在持有全局锁 mainLock 的前提下才能访问此集合</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">int</span> largestPoolSize<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token comment">// 工作线程集合，存放线程池中所有的（活跃的）工作线程，只有在持有全局锁 mainLock 的前提下才能访问此集合</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Worker</span><span class="token punctuation">></span></span> workers <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token comment">// 获取线程池状态</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">runStateOf</span><span class="token punctuation">(</span><span class="token keyword">int</span> c<span class="token punctuation">)</span>     <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> c <span class="token operator">&amp;</span> <span class="token operator">~</span><span class="token constant">CAPACITY</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token comment">// 判断线程池的状态是否为 Running</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">isRunning</span><span class="token punctuation">(</span><span class="token keyword">int</span> c<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token keyword">return</span> c <span class="token operator">&lt;</span> <span class="token constant">SHUTDOWN</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre></pre></td></tr><tr><td data-num="14"></td><td><pre></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token comment">/**</span></pre></td></tr><tr><td data-num="16"></td><td><pre>     * 添加新的工作线程到线程池</pre></td></tr><tr><td data-num="17"></td><td><pre>     * @param firstTask 要执行</pre></td></tr><tr><td data-num="18"></td><td><pre>     * @param core 参数为 true 的话表示使用线程池的基本大小，为 false 使用线程池最大大小</pre></td></tr><tr><td data-num="19"></td><td><pre>     * @return 添加成功就返回 true 否则返回 false</pre></td></tr><tr><td data-num="20"></td><td><pre>     */</pre></td></tr><tr><td data-num="21"></td><td><pre>   <span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">addWorker</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> firstTask<span class="token punctuation">,</span> <span class="token keyword">boolean</span> core<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>        retry<span class="token operator">:</span></pre></td></tr><tr><td data-num="23"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>            <span class="token comment">// 这两句用来获取线程池的状态</span></pre></td></tr><tr><td data-num="25"></td><td><pre>            <span class="token keyword">int</span> c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>            <span class="token keyword">int</span> rs <span class="token operator">=</span> <span class="token function">runStateOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre></pre></td></tr><tr><td data-num="28"></td><td><pre>            <span class="token comment">// Check if queue empty only if necessary.</span></pre></td></tr><tr><td data-num="29"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>rs <span class="token operator">>=</span> <span class="token constant">SHUTDOWN</span> <span class="token operator">&amp;&amp;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>                <span class="token operator">!</span> <span class="token punctuation">(</span>rs <span class="token operator">==</span> <span class="token constant">SHUTDOWN</span> <span class="token operator">&amp;&amp;</span></pre></td></tr><tr><td data-num="31"></td><td><pre>                   firstTask <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>                   <span class="token operator">!</span> workQueue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="33"></td><td><pre>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="34"></td><td><pre></pre></td></tr><tr><td data-num="35"></td><td><pre>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="36"></td><td><pre>               <span class="token comment">// 获取线程池中工作的线程的数量</span></pre></td></tr><tr><td data-num="37"></td><td><pre>                <span class="token keyword">int</span> wc <span class="token operator">=</span> <span class="token function">workerCountOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="38"></td><td><pre>                <span class="token comment">//core 参数为 false 的话表明队列也满了，线程池大小变为 maximumPoolSize</span></pre></td></tr><tr><td data-num="39"></td><td><pre>                <span class="token keyword">if</span> <span class="token punctuation">(</span>wc <span class="token operator">>=</span> <span class="token constant">CAPACITY</span> <span class="token operator">||</span></pre></td></tr><tr><td data-num="40"></td><td><pre>                    wc <span class="token operator">>=</span> <span class="token punctuation">(</span>core <span class="token operator">?</span> corePoolSize <span class="token operator">:</span> maximumPoolSize<span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="41"></td><td><pre>                    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="42"></td><td><pre>               <span class="token comment">// 原子操作将 workcount 的数量加 1</span></pre></td></tr><tr><td data-num="43"></td><td><pre>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndIncrementWorkerCount</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="44"></td><td><pre>                    <span class="token keyword">break</span> retry<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="45"></td><td><pre>                <span class="token comment">// 如果线程的状态改变了就再次执行上述操作</span></pre></td></tr><tr><td data-num="46"></td><td><pre>                c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="47"></td><td><pre>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">runStateOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">!=</span> rs<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="48"></td><td><pre>                    <span class="token keyword">continue</span> retry<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="49"></td><td><pre>                <span class="token comment">// else CAS failed due to workerCount change; retry inner loop</span></pre></td></tr><tr><td data-num="50"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="51"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="52"></td><td><pre>        <span class="token comment">// 标记工作线程是否启动成功</span></pre></td></tr><tr><td data-num="53"></td><td><pre>        <span class="token keyword">boolean</span> workerStarted <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="54"></td><td><pre>        <span class="token comment">// 标记工作线程是否创建成功</span></pre></td></tr><tr><td data-num="55"></td><td><pre>        <span class="token keyword">boolean</span> workerAdded <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="56"></td><td><pre>        <span class="token class-name">Worker</span> w <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="57"></td><td><pre>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="58"></td><td><pre></pre></td></tr><tr><td data-num="59"></td><td><pre>            w <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Worker</span><span class="token punctuation">(</span>firstTask<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="60"></td><td><pre>            <span class="token keyword">final</span> <span class="token class-name">Thread</span> t <span class="token operator">=</span> w<span class="token punctuation">.</span>thread<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="61"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="62"></td><td><pre>              <span class="token comment">// 加锁</span></pre></td></tr><tr><td data-num="63"></td><td><pre>                <span class="token keyword">final</span> <span class="token class-name">ReentrantLock</span> mainLock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>mainLock<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="64"></td><td><pre>                mainLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="65"></td><td><pre>                <span class="token keyword">try</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="66"></td><td><pre>                   <span class="token comment">// 获取线程池状态</span></pre></td></tr><tr><td data-num="67"></td><td><pre>                    <span class="token keyword">int</span> rs <span class="token operator">=</span> <span class="token function">runStateOf</span><span class="token punctuation">(</span>ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="68"></td><td><pre>                   <span class="token comment">//rs &lt; SHUTDOWN 如果线程池状态依然为 RUNNING, 并且线程的状态是存活的话，就会将工作线程添加到工作线程集合中</span></pre></td></tr><tr><td data-num="69"></td><td><pre>                  <span class="token comment">//(rs=SHUTDOWN &amp;&amp; firstTask == null) 如果线程池状态小于 STOP，也就是 RUNNING 或者 SHUTDOWN 状态下，同时传入的任务实例 firstTask 为 null，则需要添加到工作线程集合和启动新的 Worker</span></pre></td></tr><tr><td data-num="70"></td><td><pre>                   <span class="token comment">//firstTask == null 证明只新建线程而不执行任务</span></pre></td></tr><tr><td data-num="71"></td><td><pre>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>rs <span class="token operator">&lt;</span> <span class="token constant">SHUTDOWN</span> <span class="token operator">||</span></pre></td></tr><tr><td data-num="72"></td><td><pre>                        <span class="token punctuation">(</span>rs <span class="token operator">==</span> <span class="token constant">SHUTDOWN</span> <span class="token operator">&amp;&amp;</span> firstTask <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="73"></td><td><pre>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">isAlive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// precheck that t is startable</span></pre></td></tr><tr><td data-num="74"></td><td><pre>                            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalThreadStateException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="75"></td><td><pre>                        workers<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="76"></td><td><pre>                       <span class="token comment">// 更新当前工作线程的最大容量</span></pre></td></tr><tr><td data-num="77"></td><td><pre>                        <span class="token keyword">int</span> s <span class="token operator">=</span> workers<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="78"></td><td><pre>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">></span> largestPoolSize<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="79"></td><td><pre>                            largestPoolSize <span class="token operator">=</span> s<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="80"></td><td><pre>                      <span class="token comment">// 工作线程是否启动成功</span></pre></td></tr><tr><td data-num="81"></td><td><pre>                        workerAdded <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="82"></td><td><pre>                    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="83"></td><td><pre>                <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="84"></td><td><pre>                    <span class="token comment">// 释放锁</span></pre></td></tr><tr><td data-num="85"></td><td><pre>                    mainLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="86"></td><td><pre>                <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="87"></td><td><pre>                <span class="token comment">//// 如果成功添加工作线程，则调用 Worker 内部的线程实例 t 的 Thread#start () 方法启动真实的线程实例</span></pre></td></tr><tr><td data-num="88"></td><td><pre>                <span class="token keyword">if</span> <span class="token punctuation">(</span>workerAdded<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="89"></td><td><pre>                    t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="90"></td><td><pre>                  <span class="token comment">/// 标记线程启动成功</span></pre></td></tr><tr><td data-num="91"></td><td><pre>                    workerStarted <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="92"></td><td><pre>                <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="93"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="94"></td><td><pre>        <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="95"></td><td><pre>           <span class="token comment">// 线程启动失败，需要从工作线程中移除对应的 Worker</span></pre></td></tr><tr><td data-num="96"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span> workerStarted<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="97"></td><td><pre>                <span class="token function">addWorkerFailed</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="98"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="99"></td><td><pre>        <span class="token keyword">return</span> workerStarted<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="100"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>现在，对于上述示例代码，分析如下：我们模拟了 10 个任务，配置的核心线程数为 5、等待队列容量为 100 ，所以每次只可能存在 5 个任务同时执行，剩下的 5 个任务会被放到等待队列中去。当前的 5 个任务中如果有任务被执行完了，线程池就会去拿新的任务执行。</p><h3 id="几个常见的对比"><a class="anchor" href="#几个常见的对比">#</a> 几个常见的对比</h3><h4 id="runnable-vs-callable"><a class="anchor" href="#runnable-vs-callable">#</a> Runnable vs Callable</h4><p><code>Runnable</code> 接口自 Java 1.0 以来一直存在，但 <code>Callable</code> 接口仅在 Java 1.5 中引入，目的是为了处理 <code>Runnable</code> 接口不支持的用例。</p><p><strong><code>Runnable</code> 接口无返回值，且不会向上抛出异常，但是 <code>Callable</code> 接口可以</strong>。</p><blockquote><p>所以，如果任务不需要返回结果或抛出异常，则推荐使用 <code>Runnable</code> 接口，这样代码看起来会更加简洁。</p></blockquote><p>工具类 <code>Executors</code> 可以实现将 <code>Runnable</code> 对象转换成 <code>Callable</code> 对象。</p><ul><li><code>Executors.callable(Runnable task)</code></li><li><code>Executors.callable(Runnable task, Object result)</code> ）</li></ul><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token annotation punctuation">@FunctionalInterface</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Runnable</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>   <span class="token comment">/**</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    * 被线程执行，没有返回值，也无法抛出异常</pre></td></tr><tr><td data-num="5"></td><td><pre>    */</pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token annotation punctuation">@FunctionalInterface</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Callable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token comment">/**</span></pre></td></tr><tr><td data-num="4"></td><td><pre>     * 计算结果，或在无法这样做时抛出异常。</pre></td></tr><tr><td data-num="5"></td><td><pre>     * @return 计算得出的结果</pre></td></tr><tr><td data-num="6"></td><td><pre>     * @throws 如果无法计算结果，则抛出异常</pre></td></tr><tr><td data-num="7"></td><td><pre>     */</pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token class-name">V</span> <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h4 id="execute-vs-submit"><a class="anchor" href="#execute-vs-submit">#</a> execute() vs submit()</h4><table><thead><tr><th></th><th style="text-align:center"><code>execute()</code></th><th style="text-align:center"><code>submit()</code></th></tr></thead><tbody><tr><td>声明位置</td><td style="text-align:center"><code>Executor</code> 接口</td><td style="text-align:center"><code>ExecutorService</code> 接口</td></tr><tr><td>接收参数</td><td style="text-align:center"><code>Runnable</code></td><td style="text-align:center"><code>Runnable</code> 或 <code>Callable&lt;T&gt;</code></td></tr><tr><td>返回值类型</td><td style="text-align:center"><strong>void</strong></td><td style="text-align:center"><strong><code>Future</code></strong></td></tr><tr><td>能否处理异常</td><td style="text-align:center"><strong>无法处理异常</strong></td><td style="text-align:center">借助 <code>Future.get()</code> 可以捕获并处理异常</td></tr></tbody></table><ul><li><p><code>execute()</code> 方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功</p></li><li><p><code>submit()</code> 方法用于提交需要返回值的任务。线程池会返回一个 <code>Future</code> 类型的对象，通过这个 <code>Future</code> 对象可以判断任务是否执行成功。</p><ul><li>可以通过 <code>Future</code> 的 <code>get()</code> 方法来获取返回值，该方法会阻塞当前线程直到任务完成。</li><li>而使用 <code>Future</code> 的 <code>get（long timeout，TimeUnit unit）</code> 方法的话，如果在 <code>timeout</code> 时间内任务还没有执行完，就会抛出 <code>java.util.concurrent.TimeoutException</code> 。</li></ul></li></ul><p>示例 1：使用 <code>get()</code> 方法获取返回值。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">ExecutorService</span> executorService <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> submit <span class="token operator">=</span> executorService<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">5000L</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">return</span> <span class="token string">"abc"</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token class-name">String</span> s <span class="token operator">=</span> submit<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>executorService<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><figcaption data-lang="plain"></figcaption><table><tr><td data-num="1"></td><td><pre>abc</pre></td></tr></table></figure><p>示例 2：使用 <code>get（long timeout，TimeUnit unit）</code> 方法获取返回值。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">ExecutorService</span> executorService <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> submit <span class="token operator">=</span> executorService<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">5000L</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">return</span> <span class="token string">"abc"</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token class-name">String</span> s <span class="token operator">=</span> submit<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>executorService<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><figcaption data-lang="plain"></figcaption><table><tr><td data-num="1"></td><td><pre>Exception in thread "main" java.util.concurrent.TimeoutException</pre></td></tr><tr><td data-num="2"></td><td><pre>	at java.util.concurrent.FutureTask.get(FutureTask.java:205)</pre></td></tr></table></figure><h4 id="shutdown-vs-shutdownnow"><a class="anchor" href="#shutdown-vs-shutdownnow">#</a> shutdown() vs shutdownNow()</h4><ul><li><p><strong><code>shutdown()</code> </strong>：</p><ul><li>关闭线程池，线程池的状态变为 <code>SHUTDOWN</code></li><li><strong>线程池不再接受新任务了，但是队列里的任务得执行完毕</strong></li></ul></li><li><p><strong><code>shutdownNow()</code> </strong>：</p><ul><li>关闭线程池，线程池的状态变为 <code>STOP</code></li><li><strong>线程池会终止当前正在运行的任务，并停止处理排队的任务，并返回正在等待执行的 List</strong></li></ul></li></ul><h4 id="isshutdown-vs-isterminated"><a class="anchor" href="#isshutdown-vs-isterminated">#</a> isShutdown() vs isTerminated()</h4><ul><li><p><strong><code>isShutDown()</code> </strong>：当调用 <code>shutdown()</code> 方法后，返回为 true</p></li><li><p><strong><code>isTerminated()</code> </strong>：当调用 <code>shutdown()</code> 方法后，<strong>并且所有提交的任务完成后</strong>，返回为 true</p></li></ul><h3 id="几种常见的内置线程池"><a class="anchor" href="#几种常见的内置线程池">#</a> 几种常见的内置线程池</h3><blockquote><p>即上文提到的 <code>Executor</code> 框架的 <code>Executors</code> 工具类中所提供的线程池</p></blockquote><h4 id="fixedthreadpool"><a class="anchor" href="#fixedthreadpool">#</a> FixedThreadPool</h4><h5 id="介绍"><a class="anchor" href="#介绍">#</a> 介绍</h5><p><code>FixedThreadPool</code> 被称为可重用<strong>固定线程数</strong>的线程池。通过 <code>Executors</code> 类中的相关源代码来看一下相关实现：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">/**</span></pre></td></tr><tr><td data-num="2"></td><td><pre>     * 创建一个可重用固定数量线程的线程池</pre></td></tr><tr><td data-num="3"></td><td><pre>     */</pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">ExecutorService</span> <span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token keyword">int</span> nThreads<span class="token punctuation">,</span> <span class="token class-name">ThreadFactory</span> threadFactory<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span>nThreads<span class="token punctuation">,</span> nThreads<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="6"></td><td><pre>                                      <span class="token number">0L</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">MILLISECONDS</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="7"></td><td><pre>                                      <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="8"></td><td><pre>                                      threadFactory<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>可以看出 <font color="red"><code>corePoolSize</code> 和 <code>maximumPoolSize</code> 都被设置为 <code>nThreads</code> </font>，这个 <code>nThreads</code> 参数是我们使用的时候自己传递的。</p><p>即使 <code>maximumPoolSize</code> 的值比 <code>corePoolSize</code> 大，也至多只会创建 <code>corePoolSize</code> 个线程。这是因为 <code>FixedThreadPool</code> <font color="red">使用的是容量为 <code>Integer.MAX_VALUE</code> 的 <code>LinkedBlockingQueue</code> （<strong>无界队列</strong>），任务队列永远不会被放满</font>。</p><h5 id="处理任务的流程"><a class="anchor" href="#处理任务的流程">#</a> 处理任务的流程</h5><p><code>FixedThreadPool</code> 的 <code>execute()</code> 方法运行示意图：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/FixedThreadPool-f8172448.png" alt="FixedThreadPool的execute()方法运行示意图"></p><ol><li><p>如果当前运行的线程数小于 <code>corePoolSize</code> ， 如果再来新任务的话，就创建新的线程来执行任务；</p></li><li><p>当前运行的线程数等于 <code>corePoolSize</code> 后， 如果再来新任务的话，会将任务加入 <code>LinkedBlockingQueue</code> ；</p></li><li><p>线程池中的线程执行完手头的任务后，会在循环中反复从 <code>LinkedBlockingQueue</code> 中获取任务来执行；</p></li></ol><h5 id="为什么不推荐使用"><a class="anchor" href="#为什么不推荐使用">#</a> 为什么不推荐使用？</h5><p><code>FixedThreadPool</code> 使用无界队列 <code>LinkedBlockingQueue</code> （队列的容量为 <code>Integer.MAX_VALUE</code> ）作为线程池的工作队列会对线程池带来如下影响：</p><ol><li>当线程池中的线程数达到 <code>corePoolSize</code> 后，新任务将在无界队列中等待，因此线程池中的线程数不会超过 <code>corePoolSize</code> ；</li><li>由于使用无界队列时 <code>maximumPoolSize</code> 将是一个无效参数，因为不可能存在任务队列满的情况。所以，通过创建 <code>FixedThreadPool</code> 的源码可以看出创建的 <code>FixedThreadPool</code> 的 <code>corePoolSize</code> 和 <code>maximumPoolSize</code> 被设置为同一个值。</li><li>由于 1 和 2，使用无界队列时 <code>keepAliveTime</code> 将是一个无效参数；</li><li>运行中的 <code>FixedThreadPool</code> （未执行 <code>shutdown()</code> 或 <code>shutdownNow()</code> ）不会拒绝任务，<strong>在任务比较多的时候会导致 OOM（内存溢出）</strong>。</li></ol><h4 id="singlethreadexecutor"><a class="anchor" href="#singlethreadexecutor">#</a> SingleThreadExecutor</h4><h5 id="介绍-2"><a class="anchor" href="#介绍-2">#</a> 介绍</h5><p><code>SingleThreadExecutor</code> 是<strong>只有一个线程</strong>的线程池。下面看看 SingleThreadExecutor 的实现：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">/**</span></pre></td></tr><tr><td data-num="2"></td><td><pre>     * 返回只有一个线程的线程池</pre></td></tr><tr><td data-num="3"></td><td><pre>     */</pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">ExecutorService</span> <span class="token function">newSingleThreadExecutor</span><span class="token punctuation">(</span><span class="token class-name">ThreadFactory</span> threadFactory<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">FinalizableDelegatedExecutorService</span></pre></td></tr><tr><td data-num="6"></td><td><pre>            <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="7"></td><td><pre>                                    <span class="token number">0L</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">MILLISECONDS</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="8"></td><td><pre>                                    <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="9"></td><td><pre>                                    threadFactory<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>可以看出<font color="red"> <code>corePoolSize</code> 和 <code>maximumPoolSize</code> 都被设置为 1</font>，其他参数和 <code>FixedThreadPool</code> 相同。</p><h5 id="处理任务的流程-2"><a class="anchor" href="#处理任务的流程-2">#</a> 处理任务的流程</h5><p><code>SingleThreadExecutor</code> 的运行示意图：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/SingleThreadExecutor-7ffd92c2.png" alt="SingleThreadExecutor的运行示意图"></p><ol><li>如果当前运行的线程数少于 <code>corePoolSize</code> ，则创建一个新的线程执行任务；</li><li>当前线程池中有一个运行的线程后，将任务加入 <code>LinkedBlockingQueue</code></li><li>线程执行完当前的任务后，会在循环中反复从 <code>LinkedBlockingQueue</code> 中获取任务来执行；</li></ol><h5 id="为什么不推荐使用-2"><a class="anchor" href="#为什么不推荐使用-2">#</a> 为什么不推荐使用？</h5><p><code>SingleThreadExecutor</code> 和 <code>FixedThreadPool</code> 一样，<strong>使用的都是容量为 <code>Integer.MAX_VALUE</code> 的 <code>LinkedBlockingQueue</code> （无界队列）<strong>作为线程池的工作队列。说简单点，就是</strong>可能会导致 OOM</strong>。</p><h4 id="cachedthreadpool"><a class="anchor" href="#cachedthreadpool">#</a> CachedThreadPool</h4><h5 id="介绍-3"><a class="anchor" href="#介绍-3">#</a> 介绍</h5><p><code>CachedThreadPool</code> 是一个会<strong>根据需要创建新线程</strong>的线程池。下面通过源码来看看实现：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">/**</span></pre></td></tr><tr><td data-num="2"></td><td><pre>     * 创建一个线程池，根据需要创建新线程，但会在先前构建的线程可用时重用它。</pre></td></tr><tr><td data-num="3"></td><td><pre>     */</pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">ExecutorService</span> <span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token class-name">ThreadFactory</span> threadFactory<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token constant">MAX_VALUE</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="6"></td><td><pre>                                      <span class="token number">60L</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="7"></td><td><pre>                                      <span class="token keyword">new</span> <span class="token class-name">SynchronousQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="8"></td><td><pre>                                      threadFactory<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><font color="red"><code>corePoolSize</code> 被设置为空（0）， <code>maximumPoolSize</code> 被设置为 <code>Integer.MAX.VALUE</code> ，即它是无界的</font>。这也就意味着如果主线程提交任务的速度高于 <code>maximumPool</code> 中线程处理任务的速度时， <code>CachedThreadPool</code> 会不断创建新的线程。极端情况下，这样<strong>会导致耗尽 cpu 和内存资源</strong>。</p><h5 id="处理任务的流程-3"><a class="anchor" href="#处理任务的流程-3">#</a> 处理任务的流程</h5><p><code>CachedThreadPool</code> 的 <code>execute()</code> 方法的执行示意图：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231021003533603.png" alt="image-20231021003533603"></p><ol><li>首先执行 <code>SynchronousQueue.offer(Runnable task)</code> 提交任务到任务队列。如果当前 <code>maximumPool</code> 中有闲线程正在执行 <code>SynchronousQueue.poll(keepAliveTime,TimeUnit.NANOSECONDS)</code> ，那么主线程执行 offer 操作与空闲线程执行的 <code>poll</code> 操作配对成功，主线程把任务交给空闲线程执行， <code>execute()</code> 方法执行完成，否则执行下面的步骤 2；</li><li>当初始 <code>maximumPool</code> 为空，或者 <code>maximumPool</code> 中没有空闲线程时，将没有线程执行 <code>SynchronousQueue.poll(keepAliveTime,TimeUnit.NANOSECONDS)</code> 。这种情况下，步骤 1 将失败，此时 <code>CachedThreadPool</code> 会创建新线程执行任务，execute 方法执行完成；</li></ol><h5 id="为什么不推荐使用-3"><a class="anchor" href="#为什么不推荐使用-3">#</a> 为什么不推荐使用？</h5><p><code>CachedThreadPool</code> 使用的是同步队列 <code>SynchronousQueue</code> ，<strong>允许创建的线程数量为 <code>Integer.MAX_VALUE</code> ，可能会创建大量线程，从而导致 OOM</strong>。</p><h4 id="scheduledthreadpool"><a class="anchor" href="#scheduledthreadpool">#</a> ScheduledThreadPool</h4><h5 id="介绍-4"><a class="anchor" href="#介绍-4">#</a> 介绍</h5><p><code>ScheduledThreadPool</code> 用来<strong>在给定的延迟后运行任务或者定期执行任务</strong>。这个在实际项目中基本不会被用到，也<font color="red">不推荐使用</font>，大家只需要简单了解一下即可。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">ScheduledExecutorService</span> <span class="token function">newScheduledThreadPool</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ScheduledThreadPoolExecutor</span><span class="token punctuation">(</span>corePoolSize<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">public</span> <span class="token class-name">ScheduledThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">super</span><span class="token punctuation">(</span>corePoolSize<span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token constant">MAX_VALUE</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token constant">NANOSECONDS</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="6"></td><td><pre>          <span class="token keyword">new</span> <span class="token class-name">DelayedWorkQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><code>ScheduledThreadPool</code> 是通过 <code>ScheduledThreadPoolExecutor</code> 创建的，** 使用的 <code>DelayedWorkQueue</code> （延迟阻塞队列）** 作为线程池的任务队列。</p><p><code>DelayedWorkQueue</code> 的内部元素并不是按照放入时间排序的，而是<font color="red">按照延迟时间长短对任务进行排序的</font>，内部采用的是 “堆” 的数据结构，可以保证<font color="red">每次出队的任务都是当前队列中执行时间最靠前的</font>。 <code>DelayedWorkQueue</code> 添加元素<font color="red">满了之后会自动扩容原来容量的 1/2</font>，即永远不会阻塞，最大扩容可达 <code>Integer.MAX_VALUE</code> ，所以最多只能创建核心线程数的线程。</p><p><code>ScheduledThreadPoolExecutor</code> 继承了 <code>ThreadPoolExecutor</code> ，所以创建 <code>ScheduledThreadExecutor</code> 本质也是创建一个 <code>ThreadPoolExecutor</code> 线程池，只是传入的参数不相同。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ScheduledThreadPoolExecutor</span></pre></td></tr><tr><td data-num="2"></td><td><pre>        <span class="token keyword">extends</span> <span class="token class-name">ThreadPoolExecutor</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token keyword">implements</span> <span class="token class-name">ScheduledExecutorService</span></pre></td></tr></table></figure><h5 id="scheduledthreadpoolexecutor-和-timer-对比"><a class="anchor" href="#scheduledthreadpoolexecutor-和-timer-对比">#</a> ScheduledThreadPoolExecutor 和 Timer 对比</h5><ul><li><p><code>Timer</code> 对系统时钟的变化敏感， <code>ScheduledThreadPoolExecutor</code> 不是；</p></li><li><p><code>Timer</code> 只有一个执行线程，因此长时间运行的任务可以延迟其他任务。 <code>ScheduledThreadPoolExecutor</code> 可以配置任意数量的线程。 此外，如果你想（通过提供 <code>ThreadFactory</code> ），你可以完全控制创建的线程；</p></li><li><p>在 <code>TimerTask</code> 中抛出的运行时异常会杀死一个线程，从而导致 <code>Timer</code> 死机即计划任务将不再运行。 <code>ScheduledThreadExecutor</code> 不仅捕获运行时异常，还允许您在需要时处理它们（通过重写 <code>afterExecute</code> 方法 <code>ThreadPoolExecutor</code> ）。抛出异常的任务将被取消，但其他任务将继续运行。</p></li></ul><h3 id="如何设计一个能根据任务优先级来执行的线程池"><a class="anchor" href="#如何设计一个能根据任务优先级来执行的线程池">#</a> 如何设计一个能根据任务优先级来执行的线程池？</h3><p>这是一个常见的面试问题，本质其实还是在考察求职者对于<font color="red">线程池</font>以及<font color="red">阻塞队列（任务队列）</font>的掌握。上面也提到了，<strong><font color="red">不同的线程池会选用不同的阻塞队列作为任务队列</font></strong>。比如 <code>FixedThreadPool</code> 使用的是 <code>LinkedBlockingQueue</code> （无界队列），由于该队列永远不会被放满，因此 <code>FixedThreadPool</code> 最多只能创建 <code>corePoolSize</code> 个线程。</p><p>假如我们需要实现一个优先级任务线程池的话，那可以<strong>考虑使用 <code>PriorityBlockingQueue</code> （优先级阻塞队列）作为任务队列</strong>（ <code>ThreadPoolExecutor</code> 的构造函数有一个 <code>workQueue</code> 参数可以传入任务队列）。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/common-parameters-of-threadpool-workqueue.jpg" alt="ThreadPoolExecutor构造函数"></p><p><strong>优先级阻塞队列 <code>PriorityBlockingQueue</code> </strong>：<font color="red">一个支持优先级的无界阻塞队列</font>，可以看作是<font color="red">线程安全</font>的 <code>PriorityQueue</code> ，两者底层都是使用<font color="red">小顶堆形式的二叉堆</font>，即值最小的元素优先出队。不过， <code>PriorityQueue</code> 不<font color="red">支持阻塞操作</font>。</p><p>要想让 <code>PriorityBlockingQueue</code> 实现对任务的排序，<strong><font color="red">传入的任务必须是具备排序能力的</font></strong>，方式有两种：</p><ol><li>让任务实现 <code>Comparable</code> 接口，并重写 <code>compareTo</code> 方法来指定任务之间的优先级比较规则。</li><li>(推荐！)<strong> 创建 <code>PriorityBlockingQueue</code> 时传入一个 <code>Comparator</code> 对象来指定任务之间的排序规则</strong>。</li></ol><p>不过，<strong><font color="red">这存在一些风险和问题</font></strong>，比如：</p><ul><li><p><code>PriorityBlockingQueue</code> 是无界的，可能堆积大量的请求，从而导致 <font color="red">OOM</font> 。</p><blockquote><p>解决方法：继承 <code>PriorityBlockingQueue</code> 并<strong>重写一下 <code>offer</code> (入队) 方法</strong>的逻辑，当插入的元素数量超过指定值就返回 false</p></blockquote></li><li><p>可能会导致<font color="red">饥饿问题</font>，即低优先级的任务长时间得不到执行。</p><blockquote><p>解决方法：可以通过优化设计来解决（比较麻烦），比如<strong>等待时间过长的任务会被移除并重新添加到队列中，但是优先级会被提升</strong></p></blockquote></li><li><p>由于需要对队列中的元素进行排序操作以及保证线程安全（并发控制采用的是可重入锁 <code>ReentrantLock</code> ），因此会<font color="red">降低性能</font>。</p><blockquote><p>解决方法：性能方面的影响是<strong>没法避免</strong>的，毕竟需要对任务进行排序操作。并且，对于大部分业务场景来说，这点性能影响是可以接受的</p></blockquote></li></ul><h3 id="面试题线程池有了解吗线程池大概的原理"><a class="anchor" href="#面试题线程池有了解吗线程池大概的原理">#</a> 【面试题】线程池有了解吗？线程池大概的原理？</h3><blockquote><p>互联网、米哈游、后端、Java。考察的是<strong>线程池的常见参数、处理任务的流程</strong>。</p></blockquote><p>线程池的核心参数如下：</p><ul><li><strong><font color="gree">corePoolSize</font></strong>：核心线程数</li><li><strong><font color="gree">maximumPoolSize</font></strong>：最大线程数</li><li><strong><font color="gree">workQueue</font></strong>：任务的阻塞队列</li><li><font color="gree">keepAliveTime</font>：当线程池中的线程数量超过 corePoolSize 时，多余的空闲线程在超过 keepAliveTime 时间后会被终止。</li><li><font color="gree">threadFactory</font>：线程工厂，用于创建新的线程。</li><li><font color="gree">handler</font>：拒绝策略（饱和策略），当线程池无法接收新的任务时，采取的处理方式。</li></ul><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231018163149255.png" alt="image-20231018163149255"></p><p>线程池处理一个新任务的执行流程：</p><ol><li><p>如果 当前运行的线程数 ＜ <code>corePoolSize</code> ，那么就会<font color="red">新建一个线程</font>来执行任务。</p></li><li><p>如果 <code>corePoolSize</code> ≤ 当前运行的线程数 ＜ <code>maximumPoolSize</code> ，那么就<font color="red">把该任务放入到任务队列里等待执行</font>。</p><blockquote><p>随着不断添加任务，<font color="red">如果任务队列满了，就新建一个线程</font>来执行任务。</p></blockquote></li><li><p>如果 当前运行的线程数 == <code>maximumPoolSize</code> ，此时任务队列、线程池都满了，那么根据<font color="red">拒绝策略（饱和策略）</font>来处理无法接收的任务，比如抛出异常或者丢弃任务。</p></li></ol><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/thread-pool-principle.png" alt="图解线程池实现原理"></p><ol start="4"><li>当线程执行完任务后，会从任务队列中获取下一个任务继续执行，直到任务队列为空。</li><li>当空闲线程的时间超过 <code>keepAliveTime</code> 时，如果线程池中的线程数量超过 <code>corePoolSize</code> ，则多余的空闲线程会被终止，直到线程数量等于 <code>corePoolSize</code> 为止。</li></ol><h3 id="面试题设计一个线程池需要考虑哪些因素"><a class="anchor" href="#面试题设计一个线程池需要考虑哪些因素">#</a> 【面试题】设计一个线程池需要考虑哪些因素？</h3><blockquote><p>互联网、米哈游、后端情景题、系统设计。考察的是<strong>线程池的特征</strong>，比较综合全面</p></blockquote><p>设计一个线程池需要考虑以下几个方面：</p><ol><li><font color="gree">线程池的大小</font>：线程池的大小应该根据系统的负载情况和任务的性质来确定。<ul><li>如果线程池太小，会导致任务排队等待，影响系统的性能</li><li>如果线程池太大，会造成过多的上下文切换。</li></ul></li><li><font color="gree">任务队列</font>：线程池中的等待任务需要有一个队列来存储。任务队列可以是阻塞队列或非阻塞队列，根据具体的需求来选择。</li><li><font color="gree">线程工厂</font>：用于创建新的线程。</li><li><font color="gree">拒绝策略</font>：当线程池中的线程都处于忙碌状态时，新提交的任务会被放入任务队列中等待执行。此时需要设置一个拒绝策略，<font color="red">防止任务一直被放入队列中而无法执行</font>。常见的拒绝策略有<font color="red">直接抛出异常、丢弃任务</font>等。</li><li><font color="gree">饱和策略</font>：当线程池中的线程数量达到最大值时，新提交的任务可能会被拒绝执行。此时需要设置一个饱和策略，<font color="red">防止线程池过度扩展</font>。常见的饱和策略有<font color="red">直接抛出异常、丢弃任务</font>等。</li><li><font color="gree">线程池监控</font>：为了方便对线程池进行监控和管理，可以添加一些监控功能，如<font color="red">获取当前线程池的状态、获取当前正在执行的任务</font>等。</li></ol><p>基于以上方面，可以设计一个简单的线程池示例代码如下：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token operator">*</span></span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadPoolExample</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token comment">// 创建一个固定大小的线程池</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token class-name">ExecutorService</span> executorService <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">60L</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token comment">// 提交任务到线程池中执行</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">20</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>            <span class="token keyword">final</span> <span class="token keyword">int</span> taskId <span class="token operator">=</span> i<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>            executorService<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Task "</span> <span class="token operator">+</span> taskId <span class="token operator">+</span> <span class="token string">" is running by thread "</span> <span class="token operator">+</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>            <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre></pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token comment">// 关闭线程池</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        executorService<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id="java线程池最佳实践"><a class="anchor" href="#java线程池最佳实践">#</a> Java 线程池最佳实践</h3><h4 id="1-正确声明线程池"><a class="anchor" href="#1-正确声明线程池">#</a> 1、正确声明线程池</h4><p>** 线程池必须手动通过 <code>ThreadPoolExecutor</code> 的构造函数来声明，避免使用 <code>Executors</code> 类创建线程池，会有 OOM 风险。** 说白了就是：<strong>使用有界队列，控制线程创建数量。</strong></p><p>除了避免 OOM 的原因之外，不推荐使用 <code>Executors</code> 提供的两种快捷的线程池的原因还有：</p><ul><li>实际使用中需要根据自己机器的性能、业务场景来<font color="red">手动配置线程池的参数</font>比如核心线程数、使用的任务队列、饱和策略等等。</li><li>我们应该显示地给我们的线程池命名，这样有助于我们定位问题。</li></ul><h4 id="2-监测线程池运行状态"><a class="anchor" href="#2-监测线程池运行状态">#</a> 2、监测线程池运行状态</h4><p>你可以通过一些手段来检测线程池的运行状态比如 SpringBoot 中的 <font color="red">Actuator 组件</font>。</p><p>除此之外，我们还可以利用 <code>ThreadPoolExecutor</code> 的相关 API 做一个简陋的监控。从下图可以看出， <code>ThreadPoolExecutor</code> 提供了获取线程池当前的线程数和活跃线程数、已经执行完成的任务数、正在排队中的任务数等等。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231021094845929.png" alt="image-20231021094845929"></p><p>下面是一个简单的 Demo。 <code>printThreadPoolStatus()</code> 会每隔一秒打印出线程池的线程数、活跃线程数、完成的任务数、以及队列中的任务数。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">/**</span></pre></td></tr><tr><td data-num="2"></td><td><pre> * 打印线程池的状态</pre></td></tr><tr><td data-num="3"></td><td><pre> *</pre></td></tr><tr><td data-num="4"></td><td><pre> * @param threadPool 线程池对象</pre></td></tr><tr><td data-num="5"></td><td><pre> */</pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">printThreadPoolStatus</span><span class="token punctuation">(</span><span class="token class-name">ThreadPoolExecutor</span> threadPool<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token class-name">ScheduledExecutorService</span> scheduledExecutorService <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ScheduledThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token function">createThreadFactory</span><span class="token punctuation">(</span><span class="token string">"print-images/thread-pool-status"</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    scheduledExecutorService<span class="token punctuation">.</span><span class="token function">scheduleAtFixedRate</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"========================="</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"ThreadPool Size: [&#123;&#125;]"</span><span class="token punctuation">,</span> threadPool<span class="token punctuation">.</span><span class="token function">getPoolSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"Active Threads: &#123;&#125;"</span><span class="token punctuation">,</span> threadPool<span class="token punctuation">.</span><span class="token function">getActiveCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"Number of Tasks : &#123;&#125;"</span><span class="token punctuation">,</span> threadPool<span class="token punctuation">.</span><span class="token function">getCompletedTaskCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"Number of Tasks in Queue: &#123;&#125;"</span><span class="token punctuation">,</span> threadPool<span class="token punctuation">.</span><span class="token function">getQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"========================="</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h4 id="3-建议不同类别的业务用不同的线程池"><a class="anchor" href="#3-建议不同类别的业务用不同的线程池">#</a> 3、建议不同类别的业务用不同的线程池</h4><p>很多人在实际项目中都会有类似这样的问题：我的项目中多个业务需要用到线程池，是为每个线程池都定义一个还是说定义一个公共的线程池呢？</p><p>一般建议是<strong>不同的业务使用不同的线程池</strong>，配置线程池的时候根据当前业务的情况对当前线程池进行配置，因为不同的业务的并发以及对资源的使用情况都不同，重心优化系统性能瓶颈相关的业务。</p><p>我们再来看一个真实的事故案例！ (本案例来源自：<span class="exturl" data-url="aHR0cHM6Ly9jbHViLnBlcmZtYS5jb20vYXJ0aWNsZS82NDY2Mzk=">《线程池运用不当的一次线上事故》</span> ，很精彩的一个案例)</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/production-accident-threadpool-sharing-example.png" alt="案例代码概览"></p><p>上面的代码可能会存在死锁的情况，为什么呢？画个图给大家捋一捋。</p><p>试想这样一种极端情况：假如我们线程池的核心线程数为 n，父任务（扣费任务）数量为 n，父任务下面有两个子任务（扣费任务下的子任务），其中一个已经执行完成，另外一个被放在了任务队列中。由于父任务把线程池核心线程资源用完，所以子任务因为无法获取到线程资源无法正常执行，一直被阻塞在队列中。父任务等待子任务执行完成，而子任务等待父任务释放线程池资源，这也就造成了 <strong>&quot;死锁&quot;</strong> 。</p><p>解决方法也很简单，就是<strong>专门为执行子任务新增加一个线程池</strong>为其服务。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/production-accident-threadpool-sharing-deadlock.png" alt="线程池使用不当导致死锁"></p><h4 id="4-别忘记给线程池命名"><a class="anchor" href="#4-别忘记给线程池命名">#</a> 4、别忘记给线程池命名</h4><p>初始化线程池的时候需要<font color="red">显示命名（设置线程池名称前缀）</font>，有利于定位问题。</p><p>默认情况下创建的线程名字类似 <code>pool-1-thread-n</code> 这样的，没有业务含义，不利于我们定位问题。</p><p>给线程池里的线程命名通常有下面两种方式：</p><p><strong>1、利用 guava 的 <code>ThreadFactoryBuilder</code></strong></p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">ThreadFactory</span> threadFactory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadFactoryBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre>                        <span class="token punctuation">.</span><span class="token function">setNameFormat</span><span class="token punctuation">(</span>threadNamePrefix <span class="token operator">+</span> <span class="token string">"-%d"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre>                        <span class="token punctuation">.</span><span class="token function">setDaemon</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token class-name">ExecutorService</span> threadPool <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span>corePoolSize<span class="token punctuation">,</span> maximumPoolSize<span class="token punctuation">,</span> keepAliveTime<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">MINUTES</span><span class="token punctuation">,</span> workQueue<span class="token punctuation">,</span> threadFactory<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p><strong>2、自己实现 <code>ThreadFactory</code></strong></p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token class-name">Executors</span></span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token class-name">ThreadFactory</span></span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>atomic<span class="token punctuation">.</span></span><span class="token class-name">AtomicInteger</span></span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment">/**</span></pre></td></tr><tr><td data-num="5"></td><td><pre> * 线程工厂，它设置线程名称，有利于我们定位问题。</pre></td></tr><tr><td data-num="6"></td><td><pre> */</pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">NamingThreadFactory</span> <span class="token keyword">implements</span> <span class="token class-name">ThreadFactory</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">AtomicInteger</span> threadNum <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">ThreadFactory</span> delegate<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token comment">/**</span></pre></td></tr><tr><td data-num="14"></td><td><pre>     * 创建一个带名字的线程池生产工厂</pre></td></tr><tr><td data-num="15"></td><td><pre>     */</pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">NamingThreadFactory</span><span class="token punctuation">(</span><span class="token class-name">ThreadFactory</span> delegate<span class="token punctuation">,</span> <span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token keyword">this</span><span class="token punctuation">.</span>delegate <span class="token operator">=</span> delegate<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span> <span class="token comment">// TODO consider uniquifying this</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="20"></td><td><pre></pre></td></tr><tr><td data-num="21"></td><td><pre>    <span class="token annotation punctuation">@Override</span></pre></td></tr><tr><td data-num="22"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">Thread</span> <span class="token function">newThread</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> r<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>        <span class="token class-name">Thread</span> t <span class="token operator">=</span> delegate<span class="token punctuation">.</span><span class="token function">newThread</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>        t<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span>name <span class="token operator">+</span> <span class="token string">" [#"</span> <span class="token operator">+</span> threadNum<span class="token punctuation">.</span><span class="token function">incrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"]"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>        <span class="token keyword">return</span> t<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="27"></td><td><pre></pre></td></tr><tr><td data-num="28"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h4 id="5-正确配置线程池大小"><a class="anchor" href="#5-正确配置线程池大小">#</a> 5、正确配置线程池大小</h4><h5 id="常规操作"><a class="anchor" href="#常规操作">#</a> 常规操作</h5><p>线程池大小设置过大或者过小都会有问题，合适的才是最好。</p><ul><li><p>** 线程过少会导致大量任务堆积，造成 OOM **。如果同一时间有大量任务 / 请求需要处理，可能会导致大量的请求 / 任务在任务队列中排队等待执行，甚至会出现任务队列满了之后任务 / 请求无法处理的情况，或者大量任务堆积在任务队列导致 OOM。这样很明显是有问题的，CPU 根本没有得到充分利用。</p></li><li><p><strong>线程过多会增加上下文切换成本</strong>。大量线程可能会同时在争取 CPU 资源，这样会导致大量的上下文切换，从而增加线程的执行时间，影响了整体执行效率。</p><blockquote><p>上下文切换：任务从保存到再加载的过程</p></blockquote></li></ul><p>有一个简单并且适用面较广的公式：</p><ul><li><p><strong>CPU 密集型任务 (N+1)</strong>：这种任务消耗的主要是 CPU 资源，可以将线程数设置为 N（CPU 核心数）+1。比 CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU 就会处于空闲状态，而在这种情况下<font color="red">多出来的一个线程就可以充分利用 CPU 的空闲时间</font>。</p><blockquote><p>CPU 密集型任务：简单理解就是<font color="red">利用 CPU 计算能力</font>的任务。比如你在内存中对大量数据进行排序。</p></blockquote></li><li><p><strong>I/O 密集型任务 (2N)</strong>：这种任务应用起来，系统会用大部分的时间来处理 I/O 交互，而线程在处理 I/O 的时间段内不会占用 CPU 来处理，这时就可以将 CPU 交出给其它线程使用。<font color="red">因此在 I/O 密集型任务的应用中，我们可以多配置一些线程</font>，具体的计算方法是 2N。</p><blockquote><p>IO 密集型任务：但凡<font color="red">涉及到网络读取，文件读取</font>，这类任务都是 IO 密集型，特点是 CPU 计算耗费时间相比于等待 IO 操作完成的时间来说很少，<font color="red">大部分时间都花在了等待 IO 操作完成上</font>。</p></blockquote></li></ul><h5 id="美团骚操作"><a class="anchor" href="#美团骚操作">#</a> 美团骚操作</h5><p>美团技术团队的思路是<font color="red">对<strong>线程池的 3 个核心参数</strong>实现自定义可配置</font>。</p><ul><li><strong><code>corePoolSize</code> </strong>：核心线程数量。当任务队列未达到容量时，可以同时运行的最大线程数量。</li><li><strong><code>maximumPoolSize</code> </strong>：最大线程数量。当任务队列达到容量时，可以同时运行的最大线程数量。</li><li><strong><code>workQueue</code> </strong>：任务队列。当新任务来时，如果当前运行的线程数量达到了 <code>corePoolSize</code> 的话，新任务就会被存放在该队列中。</li></ul><blockquote><p>这 3 个参数之所以如此重要，是因为它们基本决定了线程池对任务的处理策略。</p></blockquote><p><code>ThreadPoolExecutor</code> 提供的下面这些方法支持参数的动态配置。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/threadpoolexecutor-methods.png" alt="img"></p><ul><li><p>需要注意的是 <code>corePoolSize</code> ， 程序运行期间的时候，我们调用 <code>setCorePoolSize（）</code> 方法的话，线程池会首先判断当前工作线程数是否大于 <code>corePoolSize</code> ，如果大于的话就会回收工作线程。</p></li><li><p>另外，<font color="red">上面并没有动态指定任务队列长度的方法</font>，因此美团自定义了一个叫做 <strong><code>ResizableCapacityLinkedBlockIngQueue</code> </strong>的队列。</p><blockquote><p>主要就是把 <code>LinkedBlockingQueue</code> 的 capacity 字段的 final 关键字修饰给去掉了，让它变为可变的</p></blockquote></li></ul><p>最终实现的可动态修改线程池参数效果如下。👏👏👏</p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/meituan-dynamically-configuring-thread-pool-parameters.png" alt="动态配置线程池参数最终效果" style="zoom:50%"><p>如果我们的项目也想要实现这种效果的话，可以借助现成的开源项目：</p><ul><li><strong><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL29wZW5nb29meS9oaXBwbzRq">Hippo4j</span></strong>：异步线程池框架，支持线程池动态变更 &amp; 监控 &amp; 报警，无需修改代码轻松引入。支持多种使用模式，轻松引入，致力于提高系统运行保障能力。</li><li><strong><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Ryb21hcmEvZHluYW1pYy10cA==">Dynamic TP</span></strong>：轻量级动态线程池，内置监控告警功能，集成三方中间件线程池管理，基于主流配置中心（已支持 Nacos、Apollo，Zookeeper、Consul、Etcd，可通过 SPI 自定义实现）。</li></ul><h4 id="6-记得关闭线程池"><a class="anchor" href="#6-记得关闭线程池">#</a> 6、记得关闭线程池</h4><p>当线程池不再需要使用时，应该显式地关闭线程池，释放线程资源。</p><p>线程池提供了两个关闭方法：</p><ul><li><strong><code>shutdown()</code> </strong>：关闭线程池，线程池的状态变为 <code>SHUTDOWN</code> 。线程池不再接受新任务了，但是<strong>队列里的任务得执行完毕</strong>。</li><li><strong><code>shutdownNow()</code> </strong>：关闭线程池，线程池的状态变为 <code>STOP</code> 。线程池会终止当前正在运行的任务，<strong>停止处理排队的任务</strong>，并返回正在等待执行的 List。</li></ul><p>调用完 <code>shutdownNow</code> 和 <code>shuwdown</code> 方法后，并不代表线程池已经完成关闭操作，它只是异步的通知线程池进行关闭处理。</p><p><strong>如果要同步等待线程池彻底关闭后才继续往下执行，需要调用 <code>awaitTermination()</code> 方法进行同步等待</strong>。</p><ul><li>在调用 <code>awaitTermination()</code> 方法时，应该设置合理的超时时间，以避免程序长时间阻塞而导致性能问题。</li><li>另外，由于线程池中的任务可能会被取消或抛出异常，因此在使用 <code>awaitTermination()</code> 方法时还需要进行异常处理。该方法会抛出 <code>InterruptedException</code> 异常，需要捕获并处理该异常，以避免程序崩溃或者无法正常退出。</li></ul><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// ...</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment">// 关闭线程池</span></pre></td></tr><tr><td data-num="3"></td><td><pre>executor<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">try</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token comment">// 等待线程池关闭，最多等待 5 分钟</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>executor<span class="token punctuation">.</span><span class="token function">awaitTermination</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">MINUTES</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token comment">// 如果等待超时，则打印日志</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token class-name">System</span><span class="token punctuation">.</span>err<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"线程池未能在5分钟内完全关闭"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token comment">// 异常处理</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h4 id="7-线程池尽量不要放耗时任务"><a class="anchor" href="#7-线程池尽量不要放耗时任务">#</a> 7、线程池尽量不要放耗时任务</h4><p>线程池本身的目的是为了提高任务执行效率，避免因频繁创建和销毁线程而带来的性能开销。如果将耗时任务提交到线程池中执行，可能会导致线程池中的线程被长时间占用，无法及时响应其他任务，甚至会导致线程池崩溃或者程序假死。</p><p>因此，在使用线程池时，我们应该尽量避免将耗时任务提交到线程池中执行<font color="red">。对于一些比较耗时的操作，如网络请求、文件读写等，可以采用<strong>异步操作</strong>的方式来处理，以避免阻塞线程池中的线程</font>。</p><h4 id="8-线程池使用的一些小坑"><a class="anchor" href="#8-线程池使用的一些小坑">#</a> 8、线程池使用的一些小坑</h4><h5 id="不要重复创建线程池"><a class="anchor" href="#不要重复创建线程池">#</a> 不要重复创建线程池</h5><p>线程池是可以复用的，一定不要频繁创建线程池（比如一个用户请求到了就单独创建一个线程池）。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"wrong"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">wrong</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token comment">// 自定义线程池</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token class-name">ThreadPoolExecutor</span> executor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">1L</span><span class="token punctuation">,</span><span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">,</span><span class="token keyword">new</span> <span class="token class-name">ArrayBlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor<span class="token punctuation">.</span>CallerRunsPolicy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token comment">//  处理任务</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    executor<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>      <span class="token comment">// ......</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token keyword">return</span> <span class="token string">"OK"</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>出现这种问题的原因还是对于线程池认识不够，需要加强线程池的基础知识。</p><h5 id="使用spring内部线程池时一定要手动自定义"><a class="anchor" href="#使用spring内部线程池时一定要手动自定义">#</a> 使用 Spring 内部线程池时一定要手动自定义</h5><p>使用 Spring 内部线程池时，一定要手动自定义线程池，配置合理的参数，不然会出现生产问题（一个请求创建一个线程）。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token annotation punctuation">@Configuration</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token annotation punctuation">@EnableAsync</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadPoolExecutorConfig</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token annotation punctuation">@Bean</span><span class="token punctuation">(</span>name<span class="token operator">=</span><span class="token string">"threadPoolExecutor"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">Executor</span> <span class="token function">threadPoolExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token class-name">ThreadPoolTaskExecutor</span> threadPoolExecutor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolTaskExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token keyword">int</span> processNum <span class="token operator">=</span> <span class="token class-name">Runtime</span><span class="token punctuation">.</span><span class="token function">getRuntime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">availableProcessors</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 返回可用处理器的 Java 虚拟机的数量</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token keyword">int</span> corePoolSize <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>processNum <span class="token operator">/</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">-</span> <span class="token number">0.2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token keyword">int</span> maxPoolSize <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>processNum <span class="token operator">/</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">-</span> <span class="token number">0.5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        threadPoolExecutor<span class="token punctuation">.</span><span class="token function">setCorePoolSize</span><span class="token punctuation">(</span>corePoolSize<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 核心池大小</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        threadPoolExecutor<span class="token punctuation">.</span><span class="token function">setMaxPoolSize</span><span class="token punctuation">(</span>maxPoolSize<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 最大线程数</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        threadPoolExecutor<span class="token punctuation">.</span><span class="token function">setQueueCapacity</span><span class="token punctuation">(</span>maxPoolSize <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 队列程度</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        threadPoolExecutor<span class="token punctuation">.</span><span class="token function">setThreadPriority</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token constant">MAX_PRIORITY</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        threadPoolExecutor<span class="token punctuation">.</span><span class="token function">setDaemon</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        threadPoolExecutor<span class="token punctuation">.</span><span class="token function">setKeepAliveSeconds</span><span class="token punctuation">(</span><span class="token number">300</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 线程空闲时间</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        threadPoolExecutor<span class="token punctuation">.</span><span class="token function">setThreadNamePrefix</span><span class="token punctuation">(</span><span class="token string">"test-Executor-"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 线程名字前缀</span></pre></td></tr><tr><td data-num="18"></td><td><pre>        <span class="token keyword">return</span> threadPoolExecutor<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h5 id="线程池和-threadlocal-不要共用"><a class="anchor" href="#线程池和-threadlocal-不要共用">#</a> 线程池和 ThreadLocal 不要共用</h5><p>线程池和 <code>ThreadLocal</code> 共用，可能会导致线程从 <code>ThreadLocal</code> 获取到的是旧值 / 脏数据。<strong>因为线程池会复用线程对象，与线程对象绑定的类的静态属性 <code>ThreadLocal</code> 变量也会被重用，这就导致一个线程可能获取到其他线程的 <code>ThreadLocal</code> 值</strong>。</p><p>不要以为代码中没有显示使用线程池就不存在线程池了，像常用的 Web 服务器 Tomcat 处理任务为了提高并发量，就使用到了线程池，并且使用的是基于原生 Java 线程池改进完善得到的自定义线程池。</p><p>当然了，你可以将 Tomcat 设置为单线程处理任务。不过，这并不合适，会严重影响其处理任务的速度。</p><figure class="highlight properties"><figcaption data-lang=".properties"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token key attr-name">server.tomcat.max-threads</span><span class="token punctuation">=</span><span class="token value attr-value">1</span></pre></td></tr></table></figure><p>解决上述问题比较建议的办法是<strong>使用阿里巴巴开源的 <code>TransmittableThreadLocal</code> ( <code>TTL</code> ) 来代替 <code>ThreadLocal</code> </strong>。</p><blockquote><p>该类继承并加强了 JDK 内置的 <code>InheritableThreadLocal</code> 类，在使用线程池等会池化复用线程的执行组件情况下，提供 <code>ThreadLocal</code> 的值传递功能，解决异步执行时上下文传递的问题。</p><p>项目地址：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FsaWJhYmEvdHJhbnNtaXR0YWJsZS10aHJlYWQtbG9jYWw=">https://github.com/alibaba/transmittable-thread-local</span></p></blockquote><h2 id="future-接口"><a class="anchor" href="#future-接口">#</a> Future 接口</h2><h3 id="有什么用-2"><a class="anchor" href="#有什么用-2">#</a> 有什么用？</h3><p><code>Future</code> 类是 **<font color="red">异步调用思想</font>** 的典型运用，可以将这个耗时任务交给一个子线程去异步执行，同时我们可以干点其他事情，<font color="red">不用傻傻等待耗时任务执行完成</font>。等我们的事情干完后，再通过 <code>Future</code> 类获取到耗时任务的执行结果。<font color="red">可以提高程序的执行效率</font>。</p><p>在 Java 中， <code>Future</code> 类只是一个 **<font color="red">泛型接口</font>**，位于 <code>java.util.concurrent</code> 包下，其中定义了 5 个方法，主要包括下面这 4 个功能：</p><ul><li><font color="gree">取消任务</font></li><li>判断任务是否被取消</li><li>判断任务是否已经执行完成</li><li><font color="gree">获取任务执行结果</font></li></ul><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// V 代表了 Future 执行的任务返回值的类型</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token comment">// 取消任务执行</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token comment">// 成功取消返回 true，否则返回 false</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">boolean</span> <span class="token function">cancel</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> mayInterruptIfRunning<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token comment">// 判断任务是否被取消</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">boolean</span> <span class="token function">isCancelled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token comment">// 判断任务是否已经执行完成</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">boolean</span> <span class="token function">isDone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token comment">// 获取任务执行结果</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token class-name">V</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">,</span> <span class="token class-name">ExecutionException</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token comment">// 指定时间内没有返回计算结果就抛出 TimeOutException 异常</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token class-name">V</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">long</span> timeout<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">,</span> <span class="token class-name">ExecutionException</span><span class="token punctuation">,</span> <span class="token class-name">TimeoutException</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>简单理解就是：</p><ul><li>我有一个任务，提交给了 <code>Future</code> 来处理。</li><li>任务执行期间，我可以去做任何想做的事情，还可以取消任务或者获取任务的执行状态。</li><li>一段时间之后，我就可以 <code>Future</code> 那里直接取出任务执行结果。</li></ul><h3 id="与-callable-的关系"><a class="anchor" href="#与-callable-的关系">#</a> 与 Callable 的关系</h3><p><strong><code>FutureTask</code> 类基本实现了 <code>Future</code> 接口</strong>，常用来封装 <code>Callable</code> 和 <code>Runnable</code> ，具有取消任务、查看任务是否执行完成、获取任务执行结果的方法。 <code>ExecutorService.submit()</code> 方法返回的其实就是 <code>Future</code> 的实现类 <code>FutureTask</code> 。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token function">submit</span><span class="token punctuation">(</span><span class="token class-name">Callable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> task<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> <span class="token function">submit</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> task<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p><code>FutureTask</code> 不光实现了 <code>Future</code> 接口，还实现了 <code>Runnable</code> 接口，因此可以作为任务直接被线程执行。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/completablefuture-class-diagram.jpg" alt="img"></p><p><code>FutureTask</code> 有两个构造函数，可传入 <code>Callable</code> 或者 <code>Runnable</code> 对象。实际上，传入 <code>Runnable</code> 对象也会在方法内部转换为 <code>Callable</code> 对象。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token class-name">FutureTask</span><span class="token punctuation">(</span><span class="token class-name">Callable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">V</span><span class="token punctuation">></span></span> callable<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>callable <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">this</span><span class="token punctuation">.</span>callable <span class="token operator">=</span> callable<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token constant">NEW</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">public</span> <span class="token class-name">FutureTask</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> runnable<span class="token punctuation">,</span> <span class="token class-name">V</span> result<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token comment">// 通过适配器 RunnableAdapter 来将 Runnable 对象转换成 Callable 对象</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">this</span><span class="token punctuation">.</span>callable <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">callable</span><span class="token punctuation">(</span>runnable<span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token constant">NEW</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><strong><code>FutureTask</code> 相当于对 <code>Callable</code> 进行了封装，管理着任务执行的情况，存储了 <code>Callable</code> 的 <code>call</code> 方法的任务执行结果</strong>。</p><h3 id="completablefuture-类"><a class="anchor" href="#completablefuture-类">#</a> CompletableFuture 类</h3><p><code>Future</code> 在实际使用过程中存在一些局限性，比如不支持异步任务的编排组合、获取计算结果的 <code>get()</code> 方法为阻塞调用。</p><p><strong>Java 8 引入 <code>CompletableFuture</code> 类来解决 <code>Future</code> 的这些缺陷</strong>。除了提供了更为好用和强大的 <code>Future</code> 特性之外，还提供了<font color="red">函数式编程、异步任务编排组合（可以将多个异步任务串联起来，组成一个完整的链式调用）</font>等能力。</p><p>下面我们来简单看看 <code>CompletableFuture</code> 类的定义。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token keyword">implements</span> <span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span><span class="token punctuation">,</span> <span class="token class-name">CompletionStage</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>可以看到， <code>CompletableFuture</code> 同时实现了 <code>Future</code> 接口和 <code>CompletionStage</code> 接口。</p><p><img data-src="https://oss.javaguide.cn/github/javaguide/java/concurrent/completablefuture-class-diagram.jpg" alt="img"></p><p><font color="red"><code>CompletionStage</code> 接口描述了一个异步计算的阶段</font>。很多计算可以分成多个阶段或步骤，此时可以通过它将所有步骤组合起来，形成异步计算的流水线。</p><p><code>CompletionStage</code> 接口中的方法比较多， <code>CompletableFuture</code> 的函数式能力就是这个接口赋予的。从这个接口的方法参数你就可以发现其大量使用了 Java8 引入的函数式编程。</p><h1 id="并发包juc"><a class="anchor" href="#并发包juc">#</a> 并发包（J.U.C）</h1><blockquote><p><code>java.util.concurrent</code> 包</p></blockquote><h2 id="java常见并发容器"><a class="anchor" href="#java常见并发容器">#</a> Java 常见并发容器</h2><p>JDK 提供的这些容器大部分在 <code>java.util.concurrent</code> 包中。</p><ul><li><strong><code>ConcurrentHashMap</code> </strong>: 线程安全的 <code>HashMap</code></li><li><strong><code>CopyOnWriteArrayList</code> </strong>: 线程安全的 <code>List</code> ，在<font color="red">读多写少</font>的场合性能非常好，远远好于 <code>Vector</code></li><li><strong><code>ConcurrentLinkedQueue</code> </strong>: 高效的并发队列，<font color="red">使用链表实现</font>。可以看做一个线程安全的 <code>LinkedList</code> ，这是一个<font color="red">非阻塞队列</font></li><li><strong><code>BlockingQueue</code> </strong>: 这是一个<font color="red">接口</font>，JDK 内部通过链表、数组等方式实现了这个接口。表示<font color="red">阻塞队列</font>，非常适合用于作为数据共享的通道</li><li><strong><code>ConcurrentSkipListMap</code> </strong>: <font color="red">跳表</font>的实现。这是一个 Map，使用跳表的数据结构进行快速查找</li></ul><h3 id="concurrenthashmap"><a class="anchor" href="#concurrenthashmap">#</a> ConcurrentHashMap</h3><blockquote><p><strong>线程安全的 <code>HashMap</code></strong></p></blockquote><p><font color="red"><code>HashMap</code> 不是线程安全的</font>，在并发场景下如果要保证一种可行的方式是使用 <code>Collections.synchronizedMap()</code> 方法来包装我们的 <code>HashMap</code> 。但这是通过使用一个全局的锁来同步不同线程间的并发访问，因此会带来不可忽视的性能问题。</p><p>所以就有了 <strong><code>HashMap</code> 的线程安全版本</strong> —— <code>ConcurrentHashMap</code> 的诞生。</p><ul><li>在 JDK 1.7 的时候， <code>ConcurrentHashMap</code> 对整个桶数组进行了分段（Segment），采用的是<strong>分段锁</strong>，每把锁对应一个 Segment。每个 <code>Segment</code> 都是一个类似 <code>HashMap</code> 数组的结构，它可以扩容，它的冲突会转化为链表。但是 <code>Segment</code> 的个数一但初始化就不能改变。</li><li>到了 JDK 1.8 的时候， <code>ConcurrentHashMap</code> 摒弃了 <code>Segment</code> 的概念，而是采用 <strong><code>Node</code> 数组 + 链表 / 红黑树</strong> 的数据结构来实现，使用 <strong><code>synchronized</code> 锁 + CAS</strong> 来控制并发。Node 是类似于一个 HashEntry 的结构。它的冲突再达到一定大小时会转化成红黑树，在冲突小于一定数量时又退回链表。</li></ul><h4 id="concurrenthashmap-17"><a class="anchor" href="#concurrenthashmap-17">#</a> ConcurrentHashMap 1.7</h4><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/java7_concurrenthashmap.png" alt="Java 7 ConcurrentHashMap 存储结构"></p><p>Java 7 中 <code>ConcurrentHashMap</code> 的存储结构如上图，</p><ul><li><code>ConcurrnetHashMap</code> 由很多个 <code>Segment</code> 组合</li><li>每一个 <code>Segment</code> 是一个类似于 <code>HashMap</code> 的结构 <code>HashEntry</code> 数组，所以每一个 <code>HashEntry</code> 的内部可以进行扩容。</li><li>但是 <code>Segment</code> 的个数一旦<strong>初始化就不能改变</strong>，默认 <code>Segment</code> 的个数是 16 个，你也可以认为 <code>ConcurrentHashMap</code> 默认支持最多 16 个线程并发。</li></ul><h4 id="concurrenthashmap-18"><a class="anchor" href="#concurrenthashmap-18">#</a> ConcurrentHashMap 1.8</h4><h5 id="存储结构"><a class="anchor" href="#存储结构">#</a> 存储结构</h5><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/java8_concurrenthashmap.png" alt="Java8 ConcurrentHashMap 存储结构（图片来自 javadoop）"></p><p>可以发现 Java8 的 ConcurrentHashMap 相对于 Java7 来说变化比较大，不再是之前的 Segment 数组 + HashEntry 数组 + 链表，而是 <strong>Node 数组 + 链表 / 红黑树</strong>。<font color="red">当冲突链表达到一定长度时，链表会转换成红黑树</font>。</p><h5 id="初始化-inittable"><a class="anchor" href="#初始化-inittable">#</a> 初始化 initTable</h5><p>从源码中可以发现 <code>ConcurrentHashMap</code> 的初始化是通过<strong>自旋</strong>和 <strong>CAS 操作</strong>完成的。里面需要注意的是变量 <code>sizeCtl</code> ，它的值决定着当前的初始化状态。</p><ul><li><p>-1 说明正在初始化</p></li><li><p>-N 说明有 N-1 个线程正在进行扩容</p></li><li><p>0 表示 table 初始化大小，如果 table 没有初始化</p></li><li><p>&gt;0 表示 table 扩容的阈值，如果 table 已经初始化。</p></li></ul><h5 id="put"><a class="anchor" href="#put">#</a> put</h5><ol><li><p>根据 key 计算出 hashcode</p></li><li><p>判断是否需要进行初始化</p></li><li><p>即为当前 key 定位出的 Node，如果为空表示当前位置可以写入数据，利用 CAS 尝试写入，失败则自旋保证成功</p></li><li><p>如果当前位置的 <code>hashcode == MOVED == -1</code> ，则需要进行扩容</p></li><li><p>如果都不满足，则利用 synchronized 锁写入数据</p></li><li><p>如果数量大于 <code>TREEIFY_THRESHOLD</code> 则要执行树化方法，在 <code>treeifyBin</code> 中会首先判断当前数组长度 ≥64 时才会将链表转换为红黑树</p></li></ol><h5 id="get"><a class="anchor" href="#get">#</a> get</h5><ol><li>根据 hash 值计算位置。</li><li>查找到指定位置，如果头节点就是要找的，直接返回它的 value.</li><li>如果头节点 hash 值小于 0 ，说明正在扩容或者是红黑树，查找之。</li><li>如果是链表，遍历查找之。</li></ol><h4 id="面试题concurrenthashmap-相对于-hashmap-好在哪里"><a class="anchor" href="#面试题concurrenthashmap-相对于-hashmap-好在哪里">#</a> 【面试题】concurrentHashMap 相对于 hashMap 好在哪里？</h4><p>ConcurrentHashMap 是 Java 中的一个<strong>线程安全</strong>的 hashMap 实现，它可以在多线程环境下并发地进行读写操作，而<font color="red">不需要像传统的 hashMap 那样在读写时加锁</font>。</p><p>ConcurrentHashMap 的实现原理主要基于<strong>分段锁</strong>和 CAS 操作。它将整个哈希表分成了多个 Segment（段），每个 Segment 都类似于一个小的 HashMap，它拥有自己的数组和一个独立的锁。在 ConcurrentHashMap 中，读操作不需要锁，可以直接对 Segment 进行读取，而<font color="red">写操作则只需要锁定对应的 Segment，而不是整个哈希表</font>，这样可以大大提高并发性能。</p><h3 id="copyonwritearraylist"><a class="anchor" href="#copyonwritearraylist">#</a> CopyOnWriteArrayList</h3><blockquote><p><strong>线程安全的 <code>List</code> </strong>，适合读多写少的场景</p></blockquote><p>在 JDK1.5 之前，如果想要使用并发安全的 <code>List</code> 只能选择 <code>Vector</code> 。而 <code>Vector</code> 是一种老旧的集合，已经被淘汰。 <code>Vector</code> 对于增删改查等方法基本都加了 <code>synchronized</code> ，这种方式虽然能够保证同步，但这相当于对整个 <code>Vector</code> 加上了一把大锁，使得每个方法执行的时候都要去获得锁，导致性能非常低下。</p><p>JDK1.5 引入了 <code>Java.util.concurrent</code> （JUC）包，其中提供了很多线程安全且并发性能良好的容器，其中唯一的线程安全 <code>List</code> 实现就是 <code>CopyOnWriteArrayList</code> 。</p><p>对于大部分业务场景来说，读取操作往往是远大于写入操作的。由于读取操作不会对原有数据进行修改，因此，对于每次读取都进行加锁其实是一种资源浪费。相比之下，我们应该允许多个线程同时访问 <code>List</code> 的内部数据，毕竟对于读取操作来说是安全的。</p><p>这种思路与 <code>ReentrantReadWriteLock</code> 读写锁的设计思想非常类似，即读读不互斥、读写互斥、写写互斥（<font color="red">只有读读不互斥</font>）。 <code>CopyOnWriteArrayList</code> 更进一步地实现了这一思想。为了将读操作性能发挥到极致， <code>CopyOnWriteArrayList</code> 中的<font color="red">读取操作是完全无需加锁的</font>。更加厉害的是，<font color="red">写入操作也不会阻塞读取操作，只有写写才会互斥</font>。这样一来，读操作的性能就可以大幅度提升。</p><p><code>CopyOnWriteArrayList</code> 线程安全的核心在于其采用了 <strong>写时复制（Copy-On-Write）</strong> 的策略，从 <code>CopyOnWriteArrayList</code> 的名字就能看出了。</p><p>当需要修改（ <code>add</code> ， <code>set</code> 、 <code>remove</code> 等操作） <code>CopyOnWriteArrayList</code> 的内容时，<strong><font color="red">不会直接修改原数组，而是会先创建底层数组的副本，对副本数组进行修改，修改完之后再将修改后的数组赋值回去</font></strong>，这样就可以保证写操作不会影响读操作了。</p><h3 id="concurrentlinkedqueue"><a class="anchor" href="#concurrentlinkedqueue">#</a> ConcurrentLinkedQueue</h3><blockquote><p><strong>线程安全的<font color="red">非阻塞队列</font></strong></p></blockquote><p>Java 提供的线程安全的 <code>Queue</code> 可以分为阻塞队列和非阻塞队列，其中阻塞队列的典型例子是 <code>BlockingQueue</code> ，非阻塞队列的典型例子是 <code>ConcurrentLinkedQueue</code> ，在实际应用中要根据实际需要选用阻塞队列或者非阻塞队列。</p><p><strong>阻塞队列可以通过加锁来实现，非阻塞队列可以通过 CAS 操作实现。</strong></p><p>从名字可以看出， <code>ConcurrentLinkedQueue</code> 这个队列使用<font color="red">链表</font>作为其数据结构。 <code>ConcurrentLinkedQueue</code> 应该算是在高并发环境中性能最好的队列了。它之所有能有<font color="red">很好的性能</font>，是因为其内部复杂的实现。</p><p><code>ConcurrentLinkedQueue</code> 主要使用 <strong>CAS 非阻塞算法</strong>来实现线程安全就好了。</p><p><code>ConcurrentLinkedQueue</code> 适合在对性能要求相对较高，同时对队列的读写存在多个线程同时进行的场景，即如果对队列加锁的成本较高则适合使用<font color="red">无锁</font>的 <code>ConcurrentLinkedQueue</code> 来替代。</p><h3 id="blockingqueue-接口"><a class="anchor" href="#blockingqueue-接口">#</a> BlockingQueue 接口</h3><blockquote><p><strong>线程安全的<font color="red">阻塞队列</font></strong>，可用作线程池中的工作队列 <code>workQueue</code></p></blockquote><h4 id="简介-8"><a class="anchor" href="#简介-8">#</a> 简介</h4><p>阻塞队列（ <code>BlockingQueue</code> ）被广泛使用在 “生产者 - 消费者” 问题中，其原因是 <code>BlockingQueue</code> 提供了<font color="red">可阻塞的插入和移除</font>的方法。</p><ul><li>当队列容器已满，生产者线程会被阻塞，直到队列未满</li><li>当队列容器为空时，消费者线程会被阻塞，直至队列非空时为止</li></ul><p><code>BlockingQueue</code> 是一个<font color="red">接口</font>，继承自 <code>Queue</code> ，所以其实现类也可以作为 <code>Queue</code> 的实现来使用，而 <code>Queue</code> 又继承自 <code>Collection</code> 接口。下面是 <code>BlockingQueue</code> 的实现类：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/51622268.jpg" alt="BlockingQueue 的实现类"></p><p>下面主要介绍一下 3 个常见的 <code>BlockingQueue</code> 的实现类： <code>ArrayBlockingQueue</code> 、 <code>LinkedBlockingQueue</code> 、 <code>PriorityBlockingQueue</code> 。</p><h4 id="arrayblockingqueue"><a class="anchor" href="#arrayblockingqueue">#</a> ArrayBlockingQueue</h4><p><code>ArrayBlockingQueue</code> 是 <code>BlockingQueue</code> 接口的<strong>有界阻塞队列</strong>实现类，底层采用<font color="red">数组</font>来实现。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ArrayBlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">extends</span> <span class="token class-name">AbstractQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">implements</span> <span class="token class-name">BlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span><span class="token punctuation">,</span> <span class="token class-name">Serializable</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><code>ArrayBlockingQueue</code> <font color="red">一旦创建，容量不能改变</font>。其并发控制采用<font color="red">可重入锁</font> <code>ReentrantLock</code> ，不管是插入操作还是读取操作，都需要获取到锁才能进行操作。</p><ul><li>当队列容量满时，尝试将元素放入队列将导致操作阻塞</li><li>尝试从一个空队列中取一个元素也会同样阻塞</li></ul><p><code>ArrayBlockingQueue</code> 默认情况下不能保证线程访问队列的公平性，所谓公平性是指严格按照线程等待的绝对时间顺序，即最先等待的线程能够最先访问到 <code>ArrayBlockingQueue</code> 。而<font color="red">非公平性</font>则是指访问 <code>ArrayBlockingQueue</code> 的顺序不是遵守严格的时间顺序，有可能存在，当 <code>ArrayBlockingQueue</code> 可以被访问时，长时间阻塞的线程依然无法访问到 <code>ArrayBlockingQueue</code> 。如果保证公平性，通常会降低吞吐量。</p><p>如果需要获得公平性的 <code>ArrayBlockingQueue</code> ，可采用如下代码：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">ArrayBlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> blockingQueue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayBlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h4 id="linkedblockingqueue"><a class="anchor" href="#linkedblockingqueue">#</a> LinkedBlockingQueue</h4><p><code>LinkedBlockingQueue</code> 底层基于 **<font color="red">单向链表</font><strong>实现的阻塞队列，可以当做</strong>无界阻塞队列 ** 也可以当做有界阻塞队列来使用，同样满足 <strong><font color="red">FIFO</font></strong> 的特性，与 <code>ArrayBlockingQueue</code> 相比起来具有更高的吞吐量，为了防止 <code>LinkedBlockingQueue</code> 容量迅速增大，损耗大量内存。通常在创建 <code>LinkedBlockingQueue</code> 对象时，会指定其大小，<font color="red">如果未指定大小，容量等于 <code>Integer.MAX_VALUE</code> </font>。</p><p>相关构造方法:</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">/**</span></pre></td></tr><tr><td data-num="2"></td><td><pre> * 某种意义上的无界队列</pre></td></tr><tr><td data-num="3"></td><td><pre> * Creates a &#123;@code LinkedBlockingQueue&#125; with a capacity of</pre></td></tr><tr><td data-num="4"></td><td><pre> * &#123;@link Integer#MAX_VALUE&#125;.</pre></td></tr><tr><td data-num="5"></td><td><pre> */</pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">public</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">this</span><span class="token punctuation">(</span><span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token constant">MAX_VALUE</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token comment">/**</span></pre></td></tr><tr><td data-num="11"></td><td><pre> * 有界队列</pre></td></tr><tr><td data-num="12"></td><td><pre> * Creates a &#123;@code LinkedBlockingQueue&#125; with the given (fixed) capacity.</pre></td></tr><tr><td data-num="13"></td><td><pre> *</pre></td></tr><tr><td data-num="14"></td><td><pre> * @param capacity the capacity of this queue</pre></td></tr><tr><td data-num="15"></td><td><pre> * @throws IllegalArgumentException if &#123;@code capacity&#125; is not greater</pre></td></tr><tr><td data-num="16"></td><td><pre> *         than zero</pre></td></tr><tr><td data-num="17"></td><td><pre> */</pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token keyword">public</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token punctuation">(</span><span class="token keyword">int</span> capacity<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>capacity <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    <span class="token keyword">this</span><span class="token punctuation">.</span>capacity <span class="token operator">=</span> capacity<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>    last <span class="token operator">=</span> head <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h4 id="priorityblockingqueue"><a class="anchor" href="#priorityblockingqueue">#</a> PriorityBlockingQueue</h4><blockquote><p>线程安全的 <code>PriorityQueue</code></p></blockquote><p><code>PriorityBlockingQueue</code> 是一个<strong>支持优先级的无界阻塞队列</strong>。默认情况下元素采用<font color="red">自然顺序</font>进行排序，也可以通过自定义类<font color="red">实现 <code>compareTo()</code> 方法</font>来指定元素排序规则，或者初始化时通过<font color="red">构造器参数 <code>Comparator</code> </font>来指定排序规则。</p><p><code>PriorityBlockingQueue</code> 并发控制采用的是<font color="red">可重入锁</font> <code>ReentrantLock</code> ，队列为<font color="red">无界队列</font>（ <code>ArrayBlockingQueue</code> 是有界队列， <code>LinkedBlockingQueue</code> 也可以通过在构造函数中传入 <code>capacity</code> 指定队列最大的容量，但是 <code>PriorityBlockingQueue</code> 只能指定初始的队列大小，后面插入元素的时候，<strong>如果空间不够的话会自动扩容</strong>）。</p><p>简单地说，它就是 <code>PriorityQueue</code> 的线程安全版本。<strong><font color="red">不可以插入 null 值，同时，插入队列的对象必须是可比较大小的（comparable）</font></strong>，否则报 <code>ClassCastException</code> 异常。它的插入操作 put 方法不会 block，因为它是无界队列（take 方法在队列为空的时候会阻塞）。</p><h3 id="concurrentskiplistmap"><a class="anchor" href="#concurrentskiplistmap">#</a> ConcurrentSkipListMap</h3><blockquote><p><strong>使用跳表实现的 Map</strong></p></blockquote><p>首先要清楚什么是 “跳表”：对于一个单链表，即使链表是有序的，如果我们想要在其中查找某个数据，也只能从头到尾遍历链表，这样效率自然就会很低，跳表就不一样了。跳表是一种<font color="red">可用来快速查找</font>的数据结构，有点类似于平衡树。它们都可以对元素进行快速的查找。但一个重要的区别是：对平衡树的插入和删除往往很可能导致平衡树进行一次全局的调整。而<font color="red">对跳表的插入和删除只需要对数据结构的局部进行操作即可</font>。这样带来的好处是：在高并发的情况下，你会需要一个全局锁来保证整个平衡树的线程安全。而对于跳表，你只需要<font color="red">部分锁即可</font>。这样，在高并发环境下，你就可以拥有<font color="red">更好的性能</font>。而就查询的性能而言，跳表的<font color="red">时间复杂度也是 O (logn)</font> 。所以在并发数据结构中，JDK 使用跳表来实现一个 Map。</p><p>跳表的本质：<strong>同时维护了多个链表，并且链表是分层的</strong>。<font color="red">最低层的链表维护了跳表内所有的元素，每上面一层链表都是下面一层的子集</font>。跳表内的<font color="red">所有链表的元素都是排序的</font>。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/93666217.jpg" alt="2级索引跳表"></p><center>（2级索引跳表）</center><p>从顶级链表开始查找。<font color="red">一旦发现被查找的元素大于当前链表中的<strong>所有</strong>取值，就会转入下一层链表继续找</font>。这也就是说在查找过程中，搜索是跳跃式的。</p><p>如下图所示，在跳表中查找元素 18。查找 18 的时候原来需要遍历 18 次，现在只需要 7 次即可。针对链表长度比较大的时候，<font color="red">构建索引</font>对查找效率的提升就会非常明显。</p><p>从上面很容易看出，<strong>跳表是一种利用空间换时间的算法。</strong></p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/32005738.jpg" alt="在跳表中查找元素18"></p><center>（在跳表中查找元素18）</center><p>使用跳表实现 <code>Map</code> 和使用哈希算法实现 <code>Map</code> 的另外一个不同之处是：哈希并不会保存元素的顺序，而<strong>跳表内所有的元素都是排序的</strong>。因此在对跳表进行遍历时，你会得到一个有序的结果。所以，如果你的应用需要有序性，那么跳表就是你不二的选择。JDK 中实现这一数据结构的类是 <code>ConcurrentSkipListMap</code> 。</p><h1 id="java-io"><a class="anchor" href="#java-io">#</a> Java IO</h1><h2 id="基础知识"><a class="anchor" href="#基础知识">#</a> 基础知识</h2><p>Java IO 流的 40 多个类都是从如下<strong> 4 个抽象类</strong>基类中派生出来的：</p><ul><li><code>InputStream</code> ：字节输入流</li><li><code>OutputStream</code> ：字节输出流</li><li><code>Reader</code> : 字符输入流</li><li><code>Writer</code> : 字符输出流</li></ul><h2 id="设计模式"><a class="anchor" href="#设计模式">#</a> 设计模式</h2><blockquote><p>从 IO 中能够学习到的设计模式</p></blockquote><h3 id="装饰器模式decorator"><a class="anchor" href="#装饰器模式decorator">#</a> 装饰器模式（Decorator）</h3><p>装饰器模式<strong>可以在不改变原有对象的情况下，拓展其功能</strong>。通过<font color="red">组合</font>替代继承，来扩展原始类的功能，在一些继承关系比较复杂的场景更加实用。</p><p><font color="red">对于字节流来说， <code>FilterInputStream</code> 和 <code>FilterOutputStream</code> 是装饰器模式的核心</font>，分别用于增强 <code>InputStream</code> 和 <code>OutputStream</code> 子类对象的功能。</p><p>我们常见的 <code>BufferedInputStream</code> (字节缓冲输入流)、 <code>DataInputStream</code> 等等都是 <code>FilterInputStream</code> 的子类， <code>BufferedOutputStream</code> （字节缓冲输出流）、 <code>DataOutputStream</code> 等等都是 <code>FilterOutputStream</code> 的子类。</p><h3 id="适配器模式adapter"><a class="anchor" href="#适配器模式adapter">#</a> 适配器模式（Adapter）</h3><p>适配器（Adapter Pattern）模式主要<strong>用于接口互不兼容的类的协调工作</strong>，你可以将其联想到我们日常经常使用的电源适配器。</p><p>适配器模式中存在被适配的对象或者类称为<strong>适配者 (Adaptee)</strong> ，作用于适配者的对象或者类称为<strong>适配器 (Adapter)</strong> 。适配器分为对象适配器和类适配器。</p><ul><li>类适配器：使用继承关系来实现</li><li>对象适配器：使用组合关系来实现</li></ul><h4 id="与装饰器模式的区别"><a class="anchor" href="#与装饰器模式的区别">#</a> 与装饰器模式的区别</h4><p>装饰器模式：更侧重于动态地增强原始类的功能，装饰器类需要跟原始类继承相同的抽象类或者实现相同的接口。并且，装饰器模式支持对原始类嵌套使用多个装饰器。</p><p>适配器模式：更侧重于让接口不兼容而不能交互的类可以一起工作，当我们调用适配器对应的方法时，适配器内部会调用适配者类或者和适配类相关的类的方法，这个过程透明的。就比如说 <code>StreamDecoder</code> （流解码器）和 <code>StreamEncoder</code> （流编码器）就是分别基于 <code>InputStream</code> 和 <code>OutputStream</code> 来获取 <code>FileChannel</code> 对象并调用对应的 <code>read</code> 方法和 <code>write</code> 方法进行字节数据的读取和写入。</p><h3 id="工厂模式factory"><a class="anchor" href="#工厂模式factory">#</a> 工厂模式（Factory）</h3><p>工厂模式<strong>用于创建对象</strong>，NIO 中大量用到了工厂模式，比如 <code>Files</code> 类的 <code>newInputStream</code> 方法用于创建 <code>InputStream</code> 对象（静态工厂）、 <code>Paths</code> 类的 <code>get</code> 方法创建 <code>Path</code> 对象（静态工厂）、 <code>ZipFileSystem</code> 类（ <code>sun.nio</code> 包下的类，属于 <code>java.nio</code> 相关的一些内部实现）的 <code>getPath</code> 的方法创建 <code>Path</code> 对象（简单工厂）。</p><h3 id="观察者模式"><a class="anchor" href="#观察者模式">#</a> 观察者模式</h3><p>NIO 中的文件目录<strong>监听服务</strong>使用到了观察者模式。</p><p>NIO 中的文件目录监听服务基于 <code>WatchService</code> 接口和 <code>Watchable</code> 接口。<strong> <code>WatchService</code> 属于观察者， <code>Watchable</code> 属于被观察者</strong>。</p><p><code>Watchable</code> 接口定义了一个用于将对象注册到 <code>WatchService</code> （监控服务） 并绑定监听事件的方法 <code>register</code> 。</p><p>常用的监听事件有 3 种：</p><ul><li><code>StandardWatchEventKinds.ENTRY_CREATE</code> ：文件创建。</li><li><code>StandardWatchEventKinds.ENTRY_DELETE</code> : 文件删除。</li><li><code>StandardWatchEventKinds.ENTRY_MODIFY</code> : 文件修改。</li></ul><h2 id="io-模型"><a class="anchor" href="#io-模型">#</a> <mark>IO 模型</mark></h2><h3 id="何为-io"><a class="anchor" href="#何为-io">#</a> 何为 IO ？</h3><p>从应用程序的角度来解读一下 I/O。</p><p>根据操作系统相关知识：<font color="red">为了保证操作系统的稳定性和安全性，一个进程的地址空间划分为<strong>用户空间（User space）<strong>和</strong>内核空间（Kernel space）</strong></font>。</p><blockquote><p><strong>为了限制不同的程序之间的访问能力</strong>，防止它们获取别的程序的内存数据，或者获取外围设备的数据，并发送到网络，CPU 划分出两个权限等级：</p><ul><li><p><strong>用户态</strong>：只能受限地访问内存，且不允许访问外围设备，占用 cpu 的能力被剥夺，cpu 资源可以被其他程序获取。</p></li><li><p><strong>内核态</strong>：cpu 可以访问内存的所有数据，包括外围设备，例如硬盘，网卡，cpu 也可以将自己从一个程序切换到另一个程序。</p></li></ul><p><strong>最大的区别：权限不同</strong>，运行在用户态下的程序不能直接访问操作系统内核数据结构和程序。</p></blockquote><p>像我们平常运行的应用程序都是运行在用户空间，只有内核空间才能进行系统态级别的资源有关的操作，比如文件管理、进程通信、内存管理等等。也就是说，<font color="red">想要进行 IO 操作，一定是要依赖内核空间的能力</font>。并且，用户空间的程序不能直接访问内核空间。当想要执行 IO 操作时，由于没有执行这些操作的权限，只能发起系统调用请求操作系统帮忙完成。</p><p>因此，用户进程想要执行 IO 操作的话，必须通过<font color="red">系统调用</font>来间接访问内核空间。</p><p>我们在平常开发过程中接触最多的就是<font color="red">磁盘 IO（读写文件）</font>和<font color="red">网络 IO（网络请求和响应）</font>。</p><p>从应用程序的视角来看，应用程序对操作系统的内核发起 IO 调用（系统调用），操作系统负责的内核执行具体的 IO 操作。也就是说，<strong>应用程序实际上只是发起了 IO 操作的调用而已，具体 IO 的执行是由操作系统的内核来完成的</strong>。</p><p>当应用程序发起 I/O 调用后，会经历两个步骤：</p><ol><li>内核等待 I/O 设备准备好数据</li><li>内核将数据从内核空间拷贝到用户空间</li></ol><h3 id="常见的-io-模型"><a class="anchor" href="#常见的-io-模型">#</a> 常见的 IO 模型</h3><p>UNIX 系统下，IO 模型一共有 5 种：</p><ul><li>同步阻塞 I/O</li><li>同步非阻塞 I/O</li><li>I/O 多路复用</li><li>信号驱动 I/O</li><li>异步 I/O</li></ul><h3 id="java-中-3-种常见-io-模型"><a class="anchor" href="#java-中-3-种常见-io-模型">#</a> Java 中 3 种常见 IO 模型</h3><h4 id="bioblocking"><a class="anchor" href="#bioblocking">#</a> BIO（Blocking）</h4><p>BIO 属于<strong>同步阻塞 IO 模型</strong>，应用程序发起 read 调用后，会一直阻塞，直到内核把数据拷贝到用户空间。这种阻塞模型<font color="red">在处理多个并发连接时可能会导致性能瓶颈</font>，因为需要为每个连接创建一个线程，而线程的创建和切换都是有开销的。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/6a9e704af49b4380bb686f0c96d33b81%7Etplv-k3u1fbpfcp-watermark.png" alt="图源：《深入拆解Tomcat &amp; Jetty》"></p><h4 id="nionon-blockingnew"><a class="anchor" href="#nionon-blockingnew">#</a> <mark>NIO（Non-blocking/New）</mark></h4><h5 id="nio-简介"><a class="anchor" href="#nio-简介">#</a> NIO 简介</h5><p>为了解决 BIO 同步阻塞 IO 模型导致在高并发下的性能瓶颈问题，Java 1.4 引入了 NIO，对应 <code>java.nio</code> 包，提供了 <code>Channel</code> , <code>Selector</code> ， <code>Buffer</code> 等抽象。它在标准 Java 代码中提供了<strong>非阻塞、面向缓冲、基于通道</strong>的 I/O，<font color="red">在高负载、高并发情况下可以使用少量的线程来处理多个连接</font>，大大提高了 I/O 效率和并发。</p><p>NIO 可以看作是 <strong>I/O 多路复用模型</strong>。也有很多人认为，Java 中的 NIO 属于同步非阻塞 IO 模型。</p><hr><p>先来看看<strong>同步非阻塞 IO 模型</strong>。应用程序会一直发起 read 调用，等待数据从内核空间拷贝到用户空间的这段时间里，线程依然是阻塞的，直到在内核把数据拷贝到用户空间。<font color="red">通过 轮询 操作，避免了一直阻塞</font>。</p><p>但是存在问题：<strong><font color="red">应用程序不断进行 I/O 系统调用轮询数据是否已经准备好的过程是十分消耗 CPU 资源的</font></strong>。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/bb174e22dbe04bb79fe3fc126aed0c61%7Etplv-k3u1fbpfcp-watermark.png" alt="图源：《深入拆解Tomcat &amp; Jetty》"></p><hr><p>这个时候，<strong>I/O 多路复用模型</strong> 就上场了。线程首先发起 <code>select</code> 调用，询问内核数据是否准备就绪，等内核把数据准备好了，用户线程再发起 <code>read</code> 调用。read 调用的过程（数据从内核空间 -&gt; 用户空间）还是阻塞的。</p><blockquote><p>目前支持 IO 多路复用的系统调用，有 <code>select</code> ， <code>epoll</code> 等等。select 系统调用，目前几乎在所有的操作系统上都有支持。</p><ul><li><strong>select 调用</strong>：内核提供的系统调用，它支持一次查询多个系统调用的可用状态。几乎所有的操作系统都支持。</li><li><strong>epoll 调用</strong>：linux 2.6 内核，属于 select 调用的增强版本，优化了 IO 的执行效率。</li></ul></blockquote><p>IO 多路复用模型，<strong><font color="red">通过减少无效的系统调用，减少了对 CPU 资源的消耗</font></strong>。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/88ff862764024c3b8567367df11df6ab%7Etplv-k3u1fbpfcp-watermark.png" alt="img"></p><hr><h5 id="nio-三大组件"><a class="anchor" href="#nio-三大组件">#</a> NIO 三大组件</h5><p>NIO 主要包括以下三个核心组件：</p><ul><li><strong>Buffer（缓冲区）</strong>：NIO 读写数据都是通过缓冲区进行操作的。读操作的时候将 Channel 中的数据填充到 Buffer 中，而写操作时将 Buffer 中的数据写入到 Channel 中。</li><li><strong>Channel（通道）</strong>：Channel 是一个双向的、可读可写的数据传输通道，NIO 通过 Channel 来实现数据的输入输出。通道是一个抽象的概念，它可以代表文件、套接字或者其他数据源之间的连接。</li><li><strong>Selector（选择器）</strong>：也被称为<font color="red">多路复用器</font>，<font color="red">允许一个线程处理多个 Channel</font>。所有的 Channel 都可以注册到 Selector 上，由 Selector 来分配线程来处理事件。</li></ul><p>三者的关系如下图所示（暂时不理解没关系，后文会详细介绍）：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/channel-buffer-selector.png" alt="Buffer、Channel和Selector三者之间的关系"></p><center>（Buffer、Channel和Selector三者之间的关系）</center><h6 id="buffer缓冲区"><a class="anchor" href="#buffer缓冲区">#</a> Buffer（缓冲区）</h6><p>在传统的 BIO 中，数据的读写是面向流的， 分为字节流和字符流。</p><p>在 Java 1.4 的 **<font color="red"> NIO 库中，所有数据都是用缓冲区处理的</font>**，这是新库和之前的 BIO 的一个重要区别，有点类似于 BIO 中的缓冲流。</p><ul><li>NIO 在读取数据时，它是直接读取缓冲区中的</li><li>在写入数据时，是写入到缓冲区中</li></ul><p><code>Buffer</code> 的子类如下图所示，其中最常用的是 <code>ByteBuffer</code> ，它可以用来存储和操作字节数据。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/buffer-subclasses.png" alt="Buffer 的子类"></p><center>（Buffer的子类）</center><p>可以将 Buffer <font color="red">理解为数组</font>， <code>IntBuffer</code> 、 <code>FloatBuffer</code> 、 <code>CharBuffer</code> 等分别对应 <code>int[]</code> 、 <code>float[]</code> 、 <code>char[]</code> 等。</p><hr><p>为了更清晰地认识缓冲区，我们来简单看看 <code>Buffer</code> 类中定义的<font color="gree">四个成员变量</font>：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Buffer</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">int</span> mark <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">int</span> position <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">int</span> limit<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">int</span> capacity<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>这四个成员变量满足如下的关系：<font color="red">0 &lt;= mark &lt;= position &lt;= limit &lt;= capacity</font>，具体含义如下：</p><ol><li><font color="cornflowerblue">容量（ <code>capacity</code> ）</font>： <code>Buffer</code> 可以存储的<font color="red">最大数据量</font>， <code>Buffer</code> 创建时设置且<font color="red">不可改变</font>。</li><li><font color="cornflowerblue">界限（ <code>limit</code> ）</font>： <code>Buffer</code> 中可以<font color="red">读 / 写数据的边界</font>。<ul><li><font color="red">写模式下，表示最多能写入的数据</font>，一般等于 <code>capacity</code> ；</li><li><font color="red">读模式下，表示 Buffer 中实际写入的数据大小</font>；</li></ul></li><li><font color="cornflowerblue">位置（ <code>position</code> ）</font>：<font color="red">下一个可以被读写的数据的索引</font>。从写操作模式到读操作模式切换的时候（flip）， <code>position</code> 都会归零，这样就可以<font color="red">从头开始读写</font>了。</li><li><font color="cornflowerblue">标记（ <code>mark</code> ）</font>： <code>Buffer</code> <font color="red">允许将位置直接定位到该标记处</font>，这是一个可选属性；</li></ol><p>另外，Buffer 有<font color="gree">读模式和写模式</font>这两种模式，分别用于从 Buffer 中读取数据或者向 Buffer 中写入数据。</p><ul><li>Buffer 被创建之后<font color="red">默认是写模式，调用 <code>flip()</code> 可以切换到读模式</font></li><li><font color="red">通过调用 <code>clear()</code> 或者 <code>compact()</code> 方法可以再次切换回写模式</font></li></ul><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/JavaNIOBuffer.png" alt="position 、limit 和 capacity 之前的关系"></p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/NIOBufferClassAttributes.png" alt="position 、limit 和 capacity 之前的关系"></p><hr><p><code>Buffer</code> 对象不能通过 <code>new</code> 调用构造方法创建对象，<strong><font color="gree">只能通过静态方法实例化 <code>Buffer</code> </font></strong>。</p><p>以 <code>ByteBuffer</code> 为例进行介绍：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 分配堆内存</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">ByteBuffer</span> <span class="token function">allocate</span><span class="token punctuation">(</span><span class="token keyword">int</span> capacity<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">// 分配直接内存</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">ByteBuffer</span> <span class="token function">allocateDirect</span><span class="token punctuation">(</span><span class="token keyword">int</span> capacity<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>Buffer <font color="gree">最核心的两个方法</font>：</p><ol><li><code>get()</code> : 读取缓冲区的数据</li><li><code>put()</code> ：向缓冲区写入数据</li></ol><p>除上述两个方法之外，其他的重要方法：</p><ul><li><code>flip()</code> ：将缓冲区从写模式<font color="red">切换到读模式</font>，将 <code>limit</code> 的值设置为当前 <code>position</code> 的值，将 <code>position</code> 的值设置为 0。</li><li><code>clear()</code> : <font color="red">清空缓冲区</font>，将缓冲区从读模式<font color="red">切换到写模式</font>，并将 <code>position</code> 的值设置为 0，将 <code>limit</code> 的值设置为 <code>capacity</code> 的值。</li><li>……</li></ul><hr><p>Buffer 中<font color="gree">数据变化的过程</font>：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>nio<span class="token punctuation">.</span></span><span class="token operator">*</span></span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CharBufferDemo</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token comment">// 分配一个容量为 8 的 CharBuffer</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token class-name">CharBuffer</span> buffer <span class="token operator">=</span> <span class="token class-name">CharBuffer</span><span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"初始状态："</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token function">printState</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token comment">// 向 buffer 写入 3 个字符</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        buffer<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token char">'a'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token char">'b'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token char">'c'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"写入3个字符后的状态："</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token function">printState</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token comment">// 调用 flip () 方法，准备读取 buffer 中的数据，将 position 置 0,limit 的置 3</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        buffer<span class="token punctuation">.</span><span class="token function">flip</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"调用flip()方法后的状态："</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>        <span class="token function">printState</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre></pre></td></tr><tr><td data-num="20"></td><td><pre>        <span class="token comment">// 读取字符</span></pre></td></tr><tr><td data-num="21"></td><td><pre>        <span class="token keyword">while</span> <span class="token punctuation">(</span>buffer<span class="token punctuation">.</span><span class="token function">hasRemaining</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="22"></td><td><pre>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>buffer<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="24"></td><td><pre></pre></td></tr><tr><td data-num="25"></td><td><pre>        <span class="token comment">// 调用 clear () 方法，清空缓冲区，将 position 的值置为 0，将 limit 的值置为 capacity 的值</span></pre></td></tr><tr><td data-num="26"></td><td><pre>        buffer<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"调用clear()方法后的状态："</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>        <span class="token function">printState</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="29"></td><td><pre></pre></td></tr><tr><td data-num="30"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="31"></td><td><pre></pre></td></tr><tr><td data-num="32"></td><td><pre>    <span class="token comment">// 打印 buffer 的 capacity、limit、position、mark 的位置</span></pre></td></tr><tr><td data-num="33"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">printState</span><span class="token punctuation">(</span><span class="token class-name">CharBuffer</span> buffer<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="34"></td><td><pre>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"capacity: "</span> <span class="token operator">+</span> buffer<span class="token punctuation">.</span><span class="token function">capacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="35"></td><td><pre>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">", limit: "</span> <span class="token operator">+</span> buffer<span class="token punctuation">.</span><span class="token function">limit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="36"></td><td><pre>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">", position: "</span> <span class="token operator">+</span> buffer<span class="token punctuation">.</span><span class="token function">position</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="37"></td><td><pre>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">", mark 开始读取的字符: "</span> <span class="token operator">+</span> buffer<span class="token punctuation">.</span><span class="token function">mark</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="38"></td><td><pre>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="39"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="40"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>输出：</p><figure class="highlight sh"><figcaption data-lang="sh"></figcaption><table><tr><td data-num="1"></td><td><pre>初始状态：</pre></td></tr><tr><td data-num="2"></td><td><pre>capacity: <span class="token number">8</span>, limit: <span class="token number">8</span>, position: <span class="token number">0</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre>写入3个字符后的状态：</pre></td></tr><tr><td data-num="5"></td><td><pre>capacity: <span class="token number">8</span>, limit: <span class="token number">8</span>, position: <span class="token number">3</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre>准备读取buffer中的数据！</pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre>调用flip<span class="token punctuation">(</span><span class="token punctuation">)</span>方法后的状态：</pre></td></tr><tr><td data-num="10"></td><td><pre>capacity: <span class="token number">8</span>, limit: <span class="token number">3</span>, position: <span class="token number">0</span></pre></td></tr><tr><td data-num="11"></td><td><pre></pre></td></tr><tr><td data-num="12"></td><td><pre>读取到的数据：abc</pre></td></tr><tr><td data-num="13"></td><td><pre></pre></td></tr><tr><td data-num="14"></td><td><pre>调用clear<span class="token punctuation">(</span><span class="token punctuation">)</span>方法后的状态：</pre></td></tr><tr><td data-num="15"></td><td><pre>capacity: <span class="token number">8</span>, limit: <span class="token number">8</span>, position: <span class="token number">0</span></pre></td></tr></table></figure><p>为了帮助理解，我绘制了一张图片展示 <code>capacity</code> 、 <code>limit</code> 和 <code>position</code> 每一阶段的变化。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/NIOBufferClassAttributesDataChanges.png" alt="capacity、limit和position每一阶段的变化"></p><h6 id="channel通道"><a class="anchor" href="#channel通道">#</a> Channel（通道）</h6><p>Channel 是一个通道，它建立了与数据源（如文件、网络套接字等）之间的连接。我们可以<font color="red">用它来读取和写入数据</font>，就像打开了一条自来水管，让数据在 Channel 中自由流动。</p><p>BIO 中的流是单向的，分为各种 <code>InputStream</code> （输入流）和 <code>OutputStream</code> （输出流），数据只是在一个方向上传输。通道与流的不同之处在于通道<font color="red">是双向的</font>，它可以用于读、写或者同时用于读写。</p><p>Channel 与前面介绍的 Buffer 打交道，读操作的时候将 Channel 中的数据填充到 Buffer 中，而写操作时将 Buffer 中的数据写入到 Channel 中。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/channel-buffer.png" alt="Channel 和 Buffer之间的关系"></p><center>（Channel 和 Buffer之间的关系）</center><p>另外，因为 Channel 是<font color="red">全双工</font>的，所以它可以比流更好地映射底层操作系统的 API。特别是在 UNIX 网络编程模型中，底层操作系统的通道都是全双工的，同时支持读写操作。</p><hr><p><code>Channel</code> 的<font color="gree">子类</font>如下图所示。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/channel-subclasses.png" alt="Channel 的子类"></p><p>其中，最常用的是以下几种类型的通道：</p><ul><li><code>FileChannel</code> ：文件访问通道；</li><li><code>SocketChannel</code> 、 <code>ServerSocketChannel</code> ：TCP 通信通道；</li><li><code>DatagramChannel</code> ：UDP 通信通道；</li></ul><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/channel-inheritance-relationship.png" alt="Channel继承关系图"></p><center>（Channel继承关系图）</center><hr><p>Channel <font color="gree">最核心的两个方法</font>：</p><ol><li><code>read（）</code> ：<font color="red">读取数据并写入到 Buffer 中</font>。</li><li><code>write（）</code> ：<font color="red">将 Buffer 中的数据写入到 Channel 中</font>。</li></ol><p>这里我们以 <code>FileChannel</code> 为例演示一下是读取文件数据的。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">RandomAccessFile</span> reader <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RandomAccessFile</span><span class="token punctuation">(</span><span class="token string">"/Users/guide/Documents/test_read.in"</span><span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> </pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name">FileChannel</span> channel <span class="token operator">=</span> reader<span class="token punctuation">.</span><span class="token function">getChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token class-name">ByteBuffer</span> buffer <span class="token operator">=</span> <span class="token class-name">ByteBuffer</span><span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>channel<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h6 id="selector选择器"><a class="anchor" href="#selector选择器">#</a> Selector（选择器）</h6><p>Selector 是 NIO 中的一个关键组件，是<strong>基于事件驱动的 I/O 多路复用模型</strong>，它<font color="red">允许一个线程处理多个 Channel</font>。其主要<font color="gree">运作原理</font>是：</p><ul><li>将 Channel 的事件<font color="red">注册</font>在 Selector 上</li><li>Selector 会<font color="red">轮询</font>注册在它上的 Channel。当某个 Channel 的事件发生时，该 Channel 就处于就绪状态，会被 Selector 轮询出来，并将相关的 Channel <font color="red">加入就绪集合中</font>。</li><li>通过 <font color="red">SelectionKey</font> 集合可以获取就绪 Channel 的集合（<font color="red">一个 SelectionKey 对应一个 Channel</font>），然后对这些就绪的 Channel 进行<font color="red">响应的 I/O 操作</font>。</li></ul><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/selector-channel-selectionkey.png" alt="Selector 选择器工作示意图"></p><center>（Selector 选择器工作示意图）</center><p>一个多路复用器 Selector 可以同时轮询多个 Channel，由于 JDK 使用了 <code>epoll()</code> 代替传统的 <code>select()</code> 实现，所以它并没有最大连接句柄 <code>1024/2048</code> 的限制。这也就意味着<strong>只需要一个线程负责 Selector 的轮询，就可以接入成千上万的客户端</strong>。</p><hr><p>Selector 可以<font color="gree">监听四种事件类型</font>：</p><ol><li><code>SelectionKey.OP_ACCEPT</code> ：表示<font color="red">通道接受连接</font>的事件，这通常用于 <code>ServerSocketChannel</code> 。</li><li><code>SelectionKey.OP_CONNECT</code> ：表示<font color="red">通道完成连接</font>的事件，这通常用于 <code>SocketChannel</code> 。</li><li><code>SelectionKey.OP_READ</code> ：表示<font color="red">通道准备好进行读取</font>的事件，即有数据可读。</li><li><code>SelectionKey.OP_WRITE</code> ：表示<font color="red">通道准备好进行写入</font>的事件，即可以写入数据。</li></ol><hr><p><code>Selector</code> 是抽象类，可以<strong>通过调用此类的静态方法 <code>open()</code> 来创建 Selector 实例</strong>。Selector 可以同时监控多个 <code>SelectableChannel</code> 的 <code>IO</code> 状况，是非阻塞 <code>IO</code> 的核心。</p><p>一个 Selector 实例<font color="gree">有三种  <code>SelectionKey</code> 集合</font>：</p><ol><li><font color="red">所有的</font> <code>SelectionKey</code> 集合：代表了注册在该 Selector 上的 <code>Channel</code> ，这个集合可以通过 <code>keys()</code> 方法返回。</li><li><font color="red">被选择的</font> <code>SelectionKey</code> 集合：代表了所有可通过 <code>select()</code> 方法获取的、需要进行 <code>IO</code> 处理的 Channel，这个集合可以通过 <code>selectedKeys()</code> 返回。</li><li><font color="red">被取消的</font> <code>SelectionKey</code> 集合：代表了所有被取消注册关系的 <code>Channel</code> ，在下一次执行 <code>select()</code> 方法时，这些 <code>Channel</code> 对应的 <code>SelectionKey</code> 会被彻底删除，程序通常无须直接访问该集合，也没有暴露访问的方法。</li></ol><p>简单演示一下如何<font color="gree">遍历被选择的 <code>SelectionKey</code> 集合</font>并进行处理：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">SelectionKey</span><span class="token punctuation">></span></span> selectedKeys <span class="token operator">=</span> selector<span class="token punctuation">.</span><span class="token function">selectedKeys</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">SelectionKey</span><span class="token punctuation">></span></span> keyIterator <span class="token operator">=</span> selectedKeys<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">while</span> <span class="token punctuation">(</span>keyIterator<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token class-name">SelectionKey</span> key <span class="token operator">=</span> keyIterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">isAcceptable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>            <span class="token comment">// ServerSocketChannel 接收了一个新连接</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">isConnectable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>            <span class="token comment">// 表示一个新连接建立</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">isReadable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>            <span class="token comment">// Channel 有准备好的数据，可以读取</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">isWritable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>            <span class="token comment">// Channel 有空闲的 Buffer，可以写入数据</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    keyIterator<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><hr><p>Selector 还提供了一系列<font color="gree">和 <code>select()</code> 相关的方法</font>：</p><ul><li><strong><code>int select()</code> </strong>：<font color="red">阻塞线程</font>，监控所有注册的 <code>Channel</code> 中是否有<font color="red">需要进行  <code>IO</code>  处理</font>的。如果有，该方法会将对应的 <code>SelectionKey</code> 加入到被选择的 <code>SelectionKey</code> 集合中，并<strong>返回这些 <code>Channel</code> 的数量</strong>。</li><li><code>int select(long timeout)</code> ：可以设置超时时长的 <code>select()</code> 操作。</li><li><code>int selectNow()</code> ：执行一个立即返回的 <code>select()</code> 操作，相对于无参数的 <code>select()</code> 方法而言，该方法<font color="red">不会阻塞线程</font>。</li><li><code>Selector wakeup()</code> ：使一个还未返回的 <code>select()</code> 方法立刻返回。</li><li>……</li></ul><p>使用 Selector 实现网络读写的简单示例：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">IOException</span></span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>net<span class="token punctuation">.</span></span><span class="token class-name">InetSocketAddress</span></span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>nio<span class="token punctuation">.</span></span><span class="token class-name">ByteBuffer</span></span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>nio<span class="token punctuation">.</span>channels<span class="token punctuation">.</span></span><span class="token class-name">SelectionKey</span></span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>nio<span class="token punctuation">.</span>channels<span class="token punctuation">.</span></span><span class="token class-name">Selector</span></span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>nio<span class="token punctuation">.</span>channels<span class="token punctuation">.</span></span><span class="token class-name">ServerSocketChannel</span></span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>nio<span class="token punctuation">.</span>channels<span class="token punctuation">.</span></span><span class="token class-name">SocketChannel</span></span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Iterator</span></span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Set</span></span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">NioSelectorExample</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre></pre></td></tr><tr><td data-num="13"></td><td><pre>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>      <span class="token comment">// 实例化一个用于处理连接事件的 Channel ：ServerSocketChannel</span></pre></td></tr><tr><td data-num="16"></td><td><pre>      <span class="token class-name">ServerSocketChannel</span> serverSocketChannel <span class="token operator">=</span> <span class="token class-name">ServerSocketChannel</span><span class="token punctuation">.</span><span class="token keyword">open</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>      serverSocketChannel<span class="token punctuation">.</span><span class="token function">configureBlocking</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>      serverSocketChannel<span class="token punctuation">.</span><span class="token function">socket</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InetSocketAddress</span><span class="token punctuation">(</span><span class="token number">8080</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 设置 Channel 去监听 8080 端口</span></pre></td></tr><tr><td data-num="19"></td><td><pre></pre></td></tr><tr><td data-num="20"></td><td><pre>      <span class="token comment">// 实例化一个 Selector 对象</span></pre></td></tr><tr><td data-num="21"></td><td><pre>      <span class="token class-name">Selector</span> selector <span class="token operator">=</span> <span class="token class-name">Selector</span><span class="token punctuation">.</span><span class="token keyword">open</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>      <span class="token comment">// 将 ServerSocketChannel 注册到 Selector 并监听 OP_ACCEPT 事件（通道接受连接）</span></pre></td></tr><tr><td data-num="23"></td><td><pre>      serverSocketChannel<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span>selector<span class="token punctuation">,</span> <span class="token class-name">SelectionKey</span><span class="token punctuation">.</span><span class="token constant">OP_ACCEPT</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre></pre></td></tr><tr><td data-num="25"></td><td><pre>      <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 轮询</span></pre></td></tr><tr><td data-num="26"></td><td><pre>        <span class="token keyword">int</span> readyChannels <span class="token operator">=</span> selector<span class="token punctuation">.</span><span class="token function">select</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 一直阻塞，直到 Selector 上存在需要进行 IO 处理的 Channel ，立即返回这些 Channel 的数量</span></pre></td></tr><tr><td data-num="27"></td><td><pre></pre></td></tr><tr><td data-num="28"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>readyChannels <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>          <span class="token keyword">continue</span><span class="token punctuation">;</span> <span class="token comment">// 此时 Selector 上没有需要进行 IO 处理的 Channel，继续轮询</span></pre></td></tr><tr><td data-num="30"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="31"></td><td><pre></pre></td></tr><tr><td data-num="32"></td><td><pre>        <span class="token comment">// 此时 Selector 上有需要进行 IO 处理的 Channel</span></pre></td></tr><tr><td data-num="33"></td><td><pre>        <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">SelectionKey</span><span class="token punctuation">></span></span> selectedKeys <span class="token operator">=</span> selector<span class="token punctuation">.</span><span class="token function">selectedKeys</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 获取 SelectionKey 集合，借此可获取就绪的 Channel 集合，从而得以处理它们的 IO 操作</span></pre></td></tr><tr><td data-num="34"></td><td><pre>        <span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">SelectionKey</span><span class="token punctuation">></span></span> keyIterator <span class="token operator">=</span> selectedKeys<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 获取 SelectionKey 的迭代器</span></pre></td></tr><tr><td data-num="35"></td><td><pre></pre></td></tr><tr><td data-num="36"></td><td><pre>        <span class="token keyword">while</span> <span class="token punctuation">(</span>keyIterator<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 遍历 SelectionKey</span></pre></td></tr><tr><td data-num="37"></td><td><pre>          <span class="token class-name">SelectionKey</span> key <span class="token operator">=</span> keyIterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="38"></td><td><pre></pre></td></tr><tr><td data-num="39"></td><td><pre>          <span class="token keyword">if</span> <span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">isAcceptable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="40"></td><td><pre>            <span class="token comment">// 处理连接事件：ServerSocketChannel</span></pre></td></tr><tr><td data-num="41"></td><td><pre>            <span class="token class-name">ServerSocketChannel</span> server <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">ServerSocketChannel</span><span class="token punctuation">)</span> key<span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 获取当前 SelectionKey 对应的 Channel</span></pre></td></tr><tr><td data-num="42"></td><td><pre>            <span class="token comment">// 完成连接，返回一个 SocketChannel 对象</span></pre></td></tr><tr><td data-num="43"></td><td><pre>            <span class="token class-name">SocketChannel</span> client <span class="token operator">=</span> server<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="44"></td><td><pre>            client<span class="token punctuation">.</span><span class="token function">configureBlocking</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="45"></td><td><pre></pre></td></tr><tr><td data-num="46"></td><td><pre>            <span class="token comment">// 将 SocketChannel 对象注册到 Selector 并监听 OP_READ 事件</span></pre></td></tr><tr><td data-num="47"></td><td><pre>            client<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span>selector<span class="token punctuation">,</span> <span class="token class-name">SelectionKey</span><span class="token punctuation">.</span><span class="token constant">OP_READ</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="48"></td><td><pre>          <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">isReadable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="49"></td><td><pre>            <span class="token comment">// 处理读事件：SocketChannel</span></pre></td></tr><tr><td data-num="50"></td><td><pre>            <span class="token class-name">SocketChannel</span> client <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">SocketChannel</span><span class="token punctuation">)</span> key<span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 获取当前 SelectionKey 对应的 Channel</span></pre></td></tr><tr><td data-num="51"></td><td><pre>            <span class="token class-name">ByteBuffer</span> buffer <span class="token operator">=</span> <span class="token class-name">ByteBuffer</span><span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 新建 Buffer 帮助读取数据</span></pre></td></tr><tr><td data-num="52"></td><td><pre>            <span class="token keyword">int</span> bytesRead <span class="token operator">=</span> client<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 通过 Channel 读取 Buffer 中的数据</span></pre></td></tr><tr><td data-num="53"></td><td><pre></pre></td></tr><tr><td data-num="54"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>bytesRead <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="55"></td><td><pre>              buffer<span class="token punctuation">.</span><span class="token function">flip</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将 Buffer 切换为读模式（position 置为 0，limit 置为当前 Buffer 中的数据大小）</span></pre></td></tr><tr><td data-num="56"></td><td><pre>              <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"收到数据："</span> <span class="token operator">+</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>buffer<span class="token punctuation">.</span><span class="token function">array</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> bytesRead<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="57"></td><td><pre>              <span class="token comment">// 将 SocketChannel 注册到 Selector 并监听 OP_WRITE 事件</span></pre></td></tr><tr><td data-num="58"></td><td><pre>              client<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span>selector<span class="token punctuation">,</span> <span class="token class-name">SelectionKey</span><span class="token punctuation">.</span><span class="token constant">OP_WRITE</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="59"></td><td><pre>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>bytesRead <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="60"></td><td><pre>              <span class="token comment">// 客户端断开连接</span></pre></td></tr><tr><td data-num="61"></td><td><pre>              client<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="62"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="63"></td><td><pre>          <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">isWritable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="64"></td><td><pre>            <span class="token comment">// 处理写事件：SocketChannel</span></pre></td></tr><tr><td data-num="65"></td><td><pre>            <span class="token class-name">SocketChannel</span> client <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">SocketChannel</span><span class="token punctuation">)</span> key<span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="66"></td><td><pre>            <span class="token class-name">ByteBuffer</span> buffer <span class="token operator">=</span> <span class="token class-name">ByteBuffer</span><span class="token punctuation">.</span><span class="token function">wrap</span><span class="token punctuation">(</span><span class="token string">"Hello, Client!"</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="67"></td><td><pre>            client<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 通过 Channel 将数据写入 Buffer 中</span></pre></td></tr><tr><td data-num="68"></td><td><pre></pre></td></tr><tr><td data-num="69"></td><td><pre>            <span class="token comment">// 将 SocketChannel 注册到 Selector 并监听 OP_READ 事件</span></pre></td></tr><tr><td data-num="70"></td><td><pre>            client<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span>selector<span class="token punctuation">,</span> <span class="token class-name">SelectionKey</span><span class="token punctuation">.</span><span class="token constant">OP_READ</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="71"></td><td><pre>          <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="72"></td><td><pre></pre></td></tr><tr><td data-num="73"></td><td><pre>          keyIterator<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 移除当前已处理完毕的 SelectionKey ，准备遍历下一个 SelectionKey </span></pre></td></tr><tr><td data-num="74"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="75"></td><td><pre>        <span class="token comment">// 当前 select () 处理完毕，进入下一次轮询</span></pre></td></tr><tr><td data-num="76"></td><td><pre>      <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="77"></td><td><pre>    <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="78"></td><td><pre>      e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="79"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="80"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="81"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>在示例中，我们创建了一个简单的服务器，监听 8080 端口，使用 Selector 处理连接、读取和写入事件。当接收到客户端的数据时，服务器将读取数据并将其打印到控制台，然后向客户端回复 &quot;Hello, Client!&quot;。</p><h5 id="nio-零拷贝"><a class="anchor" href="#nio-零拷贝">#</a> NIO 零拷贝</h5><p>零拷贝是<font color="red">提升 IO 操作性能</font>的一个常用手段，像 ActiveMQ、Kafka 、RocketMQ、QMQ、Netty 等顶级开源项目都用到了零拷贝。</p><p>零拷贝是指<strong>计算机执行 IO 操作时，CPU 不需要将数据从一个存储区域复制到另一个存储区域，从而可以减少 CPU 拷贝、上下文切换的时间</strong>。也就是说，零拷贝主主要解决操作系统在处理 I/O 操作时<font color="red">频繁复制数据的问题</font>。零拷贝的常见实现技术有： <code>mmap+write</code> 、 <code>sendfile</code> 和 <code>sendfile + DMA gather copy</code> 。</p><p>下图展示了各种零拷贝技术的对比图：</p><table><thead><tr><th></th><th>CPU 拷贝</th><th>DMA 拷贝</th><th>上下文切换</th><th>系统调用</th></tr></thead><tbody><tr><td>传统方法 (read + write)</td><td>2</td><td>2</td><td>4</td><td>read+write</td></tr><tr><td>mmap + write</td><td>1</td><td>2</td><td>4</td><td>mmap+write</td></tr><tr><td>sendfile</td><td>1</td><td>2</td><td>2</td><td>sendfile</td></tr><tr><td>sendfile + DMA gather copy</td><td>0</td><td>2</td><td>2</td><td>sendfile</td></tr></tbody></table><p>可以看出，无论是传统的 I/O 方式，还是引入了零拷贝之后，<font color="red">2 次 DMA（Direct Memory Access）拷贝是都少不了的</font>。因为两次 DMA 都是依赖硬件完成的。零拷贝主要是减少了 CPU 拷贝及上下文的切换。</p><p>Java 对零拷贝的支持：</p><ul><li><p><code>MappedByteBuffer</code> ：是 NIO 基于 ** 内存映射（ <code>mmap</code> ）** 这种零拷⻉⽅式的提供的⼀种实现，底层实际是调用了 Linux 内核的 <code>mmap</code> 系统调用。它可以将一个文件或者文件的一部分映射到内存中，形成一个虚拟内存文件，这样就可以<font color="red">直接操作内存中的数据</font>，而不需要通过系统调用来读写文件。</p></li><li><p><code>FileChannel</code> ：其 <code>transferTo()/transferFrom()</code> 是 NIO 基于 ** 发送文件（ <code>sendfile</code> ）** 这种零拷贝方式的提供的一种实现，底层实际是调用了 Linux 内核的 <code>sendfile</code> 系统调用。它可以<font color="red">直接将文件数据从磁盘发送到网络，而不需要经过用户空间的缓冲区</font>。</p><blockquote><p>关于 <code>FileChannel</code> 的用法可以看看这篇文章：<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vcm9ib3RoeS9wLzE0MjM1NTk4Lmh0bWw=">Java NIO 文件通道 FileChannel 用法</span>。</p></blockquote></li></ul><p>代码示例：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">loadFileIntoMemory</span><span class="token punctuation">(</span><span class="token class-name">File</span> xmlFile<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  <span class="token class-name">FileInputStream</span> fis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span>xmlFile<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token comment">// 创建 FileChannel 对象</span></pre></td></tr><tr><td data-num="4"></td><td><pre>  <span class="token class-name">FileChannel</span> fc <span class="token operator">=</span> fis<span class="token punctuation">.</span><span class="token function">getChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>  <span class="token comment">// FileChannle.map () 将文件映射到直接内存并返回 MappedByteBuffer 对象</span></pre></td></tr><tr><td data-num="6"></td><td><pre>  <span class="token class-name">MappedByteBuffer</span> mmb <span class="token operator">=</span> fc<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token class-name">FileChannel<span class="token punctuation">.</span>MapMode</span><span class="token punctuation">.</span><span class="token constant">READ_ONLY</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> fc<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>  xmlFileBuffer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>fc<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>  mmb<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>xmlFileBuffer<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>  fis<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h5 id="小结"><a class="anchor" href="#小结">#</a> 小结</h5><p>这篇文章我们主要介绍了 NIO 的核心组件、零拷贝。</p><p>如果我们需要使用 NIO 构建网络程序的话，<font color="red">不建议直接使用原生 NIO</font>，编程复杂且功能性太弱，推荐使用一些成熟的<strong>基于 NIO 的网络编程框架比如 Netty</strong> 。Netty 在 NIO 的基础上进行了一些优化和扩展，比如支持多种协议、支持 SSL/TLS 等等。</p><h4 id="aioasynchronous"><a class="anchor" href="#aioasynchronous">#</a> AIO（Asynchronous）</h4><p>Java 7 中引入了 NIO 的改进版 AIO（即 NIO 2），它是<strong>异步 IO 模型</strong>。基于事件和<font color="red">回调机制</font>实现的，也就是<font color="red">应用操作之后会直接返回</font>，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。</p><p>目前来说 AIO 的<font color="red">应用还不是很广泛</font>。Netty 之前也尝试使用过 AIO，不过又放弃了。这是因为，Netty 使用了 AIO 之后，在 Linux 系统上的性能并没有多少提升。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/3077e72a1af049559e81d18205b56fd7%7Etplv-k3u1fbpfcp-watermark.png" alt="img"></p><h4 id="小结-2"><a class="anchor" href="#小结-2">#</a> 小结</h4><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/bio-aio-nio.png" alt="BIO、NIO 和 AIO 对比"></p><center>（BIO、NIO 和 AIO 对比）</center><h3 id="面试题nio-是如何实现同步非阻塞的主线程是只有一个吗"><a class="anchor" href="#面试题nio-是如何实现同步非阻塞的主线程是只有一个吗">#</a> 【面试题】NIO 是如何实现同步非阻塞的？主线程是只有一个吗？</h3><p>NIO 底层是用 <code>Selector</code> 、 <code>Channel</code> 和 <code>Buffer</code> 来实现的。主线程在循环调用 <code>select()</code> 方法进行阻塞等待，当有 acceptable 、 readable 或者 writable 事件发生的时候，循环就会往下走，将对应的事件交给对应的事件处理器进行处理。</p><p>它可以多线程的，可以有多个 accept () 线程和多个 worker 线程。</p><blockquote><p>补充：</p><p>在 NIO 中，使用了多路复用器 Selector 来实现同步非阻塞的 IO 操作。 Selector 可以监控多个 Channel 是否需要 IO 处理，当一个或多个 Channel 准备好读或写时，Selector 会通知程序进行读写操作，而不像 BIO 一样阻塞等待 IO 操作完成。</p><p>在 NIO 中，主线程通常只有一个，但是可以使用 Selector 来管理多个 Channel，实现多个连接的非阻塞读写操作。当有多个 Channel 需要进行 IO 操作时，Selector 会轮询这些 Channel，检查它们的状态是否可读或可写。如果有可读或可写的 Channel，就将其加入到一个已选择键集合中，等待程序处理。这样，一个线程就可以同时处理多个 Channel，提高了系统的并发处理能力。</p></blockquote><h3 id="面试题bionioaio的区别"><a class="anchor" href="#面试题bionioaio的区别">#</a> 【面试题】BIO/NIO/AIO 的区别？</h3><p><strong>BIO（同步阻塞 IO）</strong>：在进行 IO 操作时，<font color="red">必须等待 IO 操作完成</font>后才能进行下一步操作，这时线程会被<font color="red">阻塞</font>。适用于连接数比较小且固定的架构，由于线程阻塞等待 IO 操作，所以<font color="red">并发处理能力不强</font>。</p><p><strong>NIO（同步非阻塞 IO）</strong>：支持多个连接同时进行读写操作，因此可以<font color="red">用较少的线程来处理大量的连接</font>。NIO 通过 <code>Selector</code> 来监听多个 <code>Channel</code> 的状态，当 Channel 中有数据可读或可写时，Selector 会通知程序进行读写操作。适用于连接数多且连接时间较短的场景。</p><p><strong>AIO（异步非阻塞 IO）</strong>：与 NIO 不同的是，<font color="red">AIO 不需要用户线程等待 IO 操作完成</font>，而是由操作系统来完成 IO 操作，操作系统完成 IO 操作后会利用<font color="red">回调机制</font>通知用户线程处理。适用于连接数较多且连接时间较长的场景，如高性能网络服务器等。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231025210135977.png" alt="image-20231025210135977"></p></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2024-03-17 13:19:59" itemprop="dateModified" datetime="2024-03-17T13:19:59+08:00">2024-03-17</time> </span><span id="java/juc/JUC笔记/" class="item leancloud_visitors" data-flag-title="JUC 笔记" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>范特东东东 <i class="ic i-at"><em>@</em></i>水文 & 摄影</li><li class="link"><strong>本文链接：</strong> <a href="http://example.com/java/juc/JUC%E7%AC%94%E8%AE%B0/" title="JUC 笔记">http://example.com/java/juc/JUC笔记/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/java/java-se/java-excise/%E7%AC%AC18%E7%AB%A0%EF%BC%9A%E9%9A%8F%E5%A0%82%E5%A4%8D%E4%B9%A0%E4%B8%8E%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%A2%98%EF%BC%88JDK8-17%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%89/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;pic.imgdb.cn&#x2F;item&#x2F;6554c7d9c458853aefd85660.jpg" title="宋红康_第18章：JDK8-17新特性"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> Java基础-真题</span><h3>宋红康_第18章：JDK8-17新特性</h3></a></div><div class="item right"><a href="/photography/%E8%AF%BE%E4%B8%8A%E6%91%B8%E9%B1%BC/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;store.heytapimage.com&#x2F;cdo-portal&#x2F;feedback&#x2F;202311&#x2F;14&#x2F;d14ad5b8a21733d0ad00c6f42a36a476.jpeg" title="课上摸鱼"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> 摄影</span><h3>课上摸鱼</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#java-%E5%B9%B6%E5%8F%91%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">Java 并发概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.1.</span> <span class="toc-text">什么是进程和线程？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%95%E4%B8%BA%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.1.1.</span> <span class="toc-text">何为进程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%95%E4%B8%BA%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.1.2.</span> <span class="toc-text">何为线程？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%85%B3%E7%B3%BB%E5%8C%BA%E5%88%AB%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">1.2.</span> <span class="toc-text">进程和线程的关系，区别，优缺点？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E8%A7%A3%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">1.2.1.</span> <span class="toc-text">图解进程与线程的关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8%E7%9A%84%E7%A7%81%E6%9C%89%E7%9A%84"><span class="toc-number">1.2.2.</span> <span class="toc-text">为什么程序计数器的私有的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E5%92%8C%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88%E6%98%AF%E7%A7%81%E6%9C%89%E7%9A%84"><span class="toc-number">1.2.3.</span> <span class="toc-text">为什么虚拟机栈和本地方法栈是私有的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%A0%86%E5%92%8C%E6%96%B9%E6%B3%95%E5%8C%BA%E6%98%AF%E5%85%B1%E4%BA%AB%E7%9A%84"><span class="toc-number">1.2.4.</span> <span class="toc-text">为什么堆和方法区是共享的？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E5%92%8C%E5%B9%B6%E8%A1%8C%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.3.</span> <span class="toc-text">并发和并行的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.4.</span> <span class="toc-text">同步和异步的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.5.</span> <span class="toc-text">为什么要使用多线程？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BC%9A%E5%B8%A6%E6%9D%A5%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98"><span class="toc-number">1.6.</span> <span class="toc-text">多线程会带来什么问题？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%92%8C%E4%B8%8D%E5%AE%89%E5%85%A8"><span class="toc-number">1.7.</span> <span class="toc-text">如何理解线程安全和不安全？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E6%A0%B8-cpu-%E4%B8%8A%E8%BF%90%E8%A1%8C%E5%A4%9A%E4%B8%AA%E7%BA%BF%E7%A8%8B%E6%95%88%E7%8E%87%E4%B8%80%E5%AE%9A%E4%BC%9A%E9%AB%98%E5%90%97"><span class="toc-number">1.8.</span> <span class="toc-text">单核 CPU 上运行多个线程效率一定会高吗？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B"><span class="toc-number">2.</span> <span class="toc-text">线程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F"><span class="toc-number">2.1.</span> <span class="toc-text">线程的创建方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF-thread-%E7%B1%BB"><span class="toc-number">2.1.1.</span> <span class="toc-text">继承 Thread 类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0-runnable-%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.1.2.</span> <span class="toc-text">实现 Runnable 接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0-callable-%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.1.3.</span> <span class="toc-text">实现 Callable 接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#runnable-%E5%92%8C-callable-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.1.4.</span> <span class="toc-text">Runnable 和 Callable 的区别？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#thread-%E7%B1%BB%E7%9A%84%E5%B8%B8%E7%94%A8-api"><span class="toc-number">2.2.</span> <span class="toc-text">Thread 类的常用 API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#start-%E4%B8%8E-run"><span class="toc-number">2.2.1.</span> <span class="toc-text">start () 与 run ()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sleep-%E4%B8%8E-yield"><span class="toc-number">2.2.2.</span> <span class="toc-text">sleep () 与 yield ()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sleep-%E4%B8%8E-wait"><span class="toc-number">2.2.3.</span> <span class="toc-text">sleep () 与 wait ()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E7%8A%B6%E6%80%81"><span class="toc-number">2.3.</span> <span class="toc-text">说说线程的生命周期和状态？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2"><span class="toc-number">2.4.</span> <span class="toc-text">什么是线程上下文切换？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E6%AD%BB%E9%94%81"><span class="toc-number">2.5.</span> <span class="toc-text">什么是线程死锁？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E4%BA%A7%E7%94%9F%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">2.5.1.</span> <span class="toc-text">死锁产生的原因</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%A2%84%E9%98%B2-%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81"><span class="toc-number">2.5.2.</span> <span class="toc-text">如何预防、避免死锁？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-wait-%E5%AE%9A%E4%B9%89%E5%9C%A8-object-%E7%B1%BB%E4%B8%AD%E8%80%8C%E4%B8%8D%E6%98%AF-thread-%E7%B1%BB%E4%B8%AD"><span class="toc-number">2.6.</span> <span class="toc-text">为什么 wait () 定义在 Object 类中，而不是 Thread 类中？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E4%BB%A5%E7%9B%B4%E6%8E%A5%E8%B0%83%E7%94%A8-thread-%E7%B1%BB%E7%9A%84-run-%E5%90%97"><span class="toc-number">2.7.</span> <span class="toc-text">可以直接调用 Thread 类的 run () 吗？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5"><span class="toc-number">3.</span> <span class="toc-text">同步</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%B4%E7%95%8C%E5%8C%BA"><span class="toc-number">3.1.</span> <span class="toc-text">临界区</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81"><span class="toc-number">3.2.</span> <span class="toc-text">乐观锁和悲观锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E6%82%B2%E8%A7%82%E9%94%81%E5%92%8C%E4%B9%90%E8%A7%82%E9%94%81%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E5%88%86%E5%88%AB%E6%9C%89%E4%BB%80%E4%B9%88"><span class="toc-number">3.2.1.</span> <span class="toc-text">数据库悲观锁和乐观锁的原理和应用场景分别有什么？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#synchronized-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">3.3.</span> <span class="toc-text">synchronized 关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8A%8A-jdk-16-%E4%B9%8B%E5%89%8D%E7%9A%84-synchronized-%E7%A7%B0%E4%B8%BA%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81"><span class="toc-number">3.3.1.</span> <span class="toc-text">为什么把 JDK 1.6 之前的 synchronized 称为重量级锁？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized-%E9%94%81%E5%8D%87%E7%BA%A7%E8%BF%87%E7%A8%8B%E5%81%8F%E5%90%91%E9%94%81-%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81-%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81"><span class="toc-number">3.3.2.</span> <span class="toc-text">synchronized 锁升级过程（偏向锁、轻量级锁、重量级锁）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%86%85%E5%AD%98"><span class="toc-number">4.</span> <span class="toc-text">内存</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8Bjmm"><span class="toc-number">4.1.</span> <span class="toc-text">Java 内存模型（JMM）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#volatile-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">4.2.</span> <span class="toc-text">volatile 关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#volatile%E5%AE%9E%E7%8E%B0%E4%BB%80%E4%B9%88%E8%83%BD%E5%8A%9B%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="toc-number">4.2.1.</span> <span class="toc-text">volatile 实现什么能力，怎么实现的？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#happens-before-%E5%8E%9F%E5%88%99"><span class="toc-number">4.3.</span> <span class="toc-text">happens-before 原则</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%97%A0%E9%94%81"><span class="toc-number">5.</span> <span class="toc-text">无锁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#cas"><span class="toc-number">5.1.</span> <span class="toc-text">CAS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#atomic-%E5%8E%9F%E5%AD%90%E7%B1%BB"><span class="toc-number">5.2.</span> <span class="toc-text">Atomic 原子类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#threadlocal-%E7%B1%BB"><span class="toc-number">5.3.</span> <span class="toc-text">ThreadLocal 类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8"><span class="toc-number">5.3.1.</span> <span class="toc-text">有什么用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8"><span class="toc-number">5.3.2.</span> <span class="toc-text">如何使用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-number">5.3.3.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E9%97%AE%E9%A2%98"><span class="toc-number">5.3.4.</span> <span class="toc-text">内存泄露问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%A0%E7%9A%84%E7%90%86%E8%A7%A3%E5%B0%8F%E7%BB%93"><span class="toc-number">5.3.5.</span> <span class="toc-text">你的理解？（小结）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E5%99%A8"><span class="toc-number">6.</span> <span class="toc-text">同步器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#aqs-%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">6.1.</span> <span class="toc-text">AQS 抽象类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">6.1.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="toc-number">6.1.2.</span> <span class="toc-text">底层原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3"><span class="toc-number">6.1.2.1.</span> <span class="toc-text">核心思想</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB%E6%96%B9%E5%BC%8F"><span class="toc-number">6.1.2.2.</span> <span class="toc-text">资源共享方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%90%8C%E6%AD%A5%E5%99%A8"><span class="toc-number">6.1.2.3.</span> <span class="toc-text">自定义同步器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-number">6.1.3.</span> <span class="toc-text">常见同步工具类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#semaphore%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">6.1.3.1.</span> <span class="toc-text">Semaphore（信号量）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-2"><span class="toc-number">6.1.3.1.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-2"><span class="toc-number">6.1.3.1.2.</span> <span class="toc-text">原理</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#countdownlatch%E5%80%92%E8%AE%A1%E6%97%B6%E5%99%A8"><span class="toc-number">6.1.3.2.</span> <span class="toc-text">CountDownLatch（倒计时器）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-3"><span class="toc-number">6.1.3.2.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-3"><span class="toc-number">6.1.3.2.2.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">6.1.3.2.3.</span> <span class="toc-text">应用场景</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#cyclicbarrier%E5%BE%AA%E7%8E%AF%E6%A0%85%E6%A0%8F"><span class="toc-number">6.1.3.3.</span> <span class="toc-text">CyclicBarrier（循环栅栏）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-4"><span class="toc-number">6.1.3.3.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-4"><span class="toc-number">6.1.3.3.2.</span> <span class="toc-text">原理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98aqs-%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">6.1.4.</span> <span class="toc-text">【面试题】AQS 的底层原理是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%B2%E8%AE%B2%E4%BD%A0%E5%AF%B9-aqs-%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">6.1.5.</span> <span class="toc-text">讲讲你对 AQS 的理解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#reentrantlock-%E7%B1%BB"><span class="toc-number">6.2.</span> <span class="toc-text">ReentrantLock 类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-5"><span class="toc-number">6.2.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AC%E5%B9%B3%E9%94%81%E5%92%8C%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">6.2.2.</span> <span class="toc-text">公平锁和非公平锁有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized-%E5%92%8C-reentrantlock-%E6%9C%89%E4%BD%95%E5%BC%82%E5%90%8C"><span class="toc-number">6.2.3.</span> <span class="toc-text">synchronized 和 ReentrantLock 有何异同？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%83%BD%E6%98%AF%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81"><span class="toc-number">6.2.3.1.</span> <span class="toc-text">都是可重入锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#synchronized-%E4%BE%9D%E8%B5%96%E4%BA%8E-jvm%E8%80%8C-reentrantlock-%E4%BE%9D%E8%B5%96%E4%BA%8E-api"><span class="toc-number">6.2.3.2.</span> <span class="toc-text">synchronized 依赖于 JVM，而 ReentrantLock 依赖于 API</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#reentrantlock-%E6%AF%94-synchronized-%E5%A2%9E%E5%8A%A0%E4%BA%86%E4%B8%80%E4%BA%9B%E9%AB%98%E7%BA%A7%E5%8A%9F%E8%83%BD"><span class="toc-number">6.2.3.3.</span> <span class="toc-text">ReentrantLock 比 synchronized 增加了一些高级功能</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E4%B8%AD%E6%96%AD%E9%94%81%E5%92%8C%E4%B8%8D%E5%8F%AF%E4%B8%AD%E6%96%AD%E9%94%81%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">6.2.4.</span> <span class="toc-text">可中断锁和不可中断锁有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%8B-reentrantlock-%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E5%8F%AF%E9%87%8D%E5%85%A5-%E5%85%AC%E5%B9%B3%E9%94%81%E5%92%8C%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">6.2.5.</span> <span class="toc-text">介绍下 ReentrantLock 的底层原理（可重入、公平锁和非公平锁的原理）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">7.</span> <span class="toc-text">线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0-2"><span class="toc-number">7.1.</span> <span class="toc-text">线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-6"><span class="toc-number">7.1.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#executor-%E6%A1%86%E6%9E%B6"><span class="toc-number">7.1.2.</span> <span class="toc-text">Executor 框架</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-7"><span class="toc-number">7.1.2.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E5%A4%A7%E9%83%A8%E5%88%86"><span class="toc-number">7.1.2.2.</span> <span class="toc-text">三大部分</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1runnablecallable"><span class="toc-number">7.1.2.2.1.</span> <span class="toc-text">任务（ Runnable &#x2F; Callable ）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E7%9A%84%E6%89%A7%E8%A1%8Cexecutor"><span class="toc-number">7.1.2.2.2.</span> <span class="toc-text">任务的执行（ Executor ）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E8%AE%A1%E7%AE%97%E7%9A%84%E7%BB%93%E6%9E%9Cfuture"><span class="toc-number">7.1.2.2.3.</span> <span class="toc-text">异步计算的结果（ Future ）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-2"><span class="toc-number">7.1.2.3.</span> <span class="toc-text">如何使用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#threadpoolexecutor-%E7%B1%BB"><span class="toc-number">7.1.3.</span> <span class="toc-text">ThreadPoolExecutor 类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">7.1.3.1.</span> <span class="toc-text">构造方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E5%8F%82%E6%95%B0"><span class="toc-number">7.1.3.2.</span> <span class="toc-text">常见参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A5%B1%E5%92%8C%E7%AD%96%E7%95%A5"><span class="toc-number">7.1.3.3.</span> <span class="toc-text">饱和策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F"><span class="toc-number">7.1.3.4.</span> <span class="toc-text">线程池的创建方式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F1threadpoolexecutor-%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">7.1.3.4.1.</span> <span class="toc-text">方式 1：ThreadPoolExecutor 类的构造函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F2executor-%E6%A1%86%E6%9E%B6%E7%9A%84-executors-%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-number">7.1.3.4.2.</span> <span class="toc-text">方式 2：Executor 框架的 Executors 工具类</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97"><span class="toc-number">7.1.3.5.</span> <span class="toc-text">常用的阻塞队列</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90"><span class="toc-number">7.1.4.</span> <span class="toc-text">线程池原理分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#threadpoolexecutor-%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81"><span class="toc-number">7.1.4.1.</span> <span class="toc-text">ThreadPoolExecutor 示例代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E5%A4%84%E7%90%86%E4%BB%BB%E5%8A%A1%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="toc-number">7.1.4.2.</span> <span class="toc-text">线程池原理分析（处理任务的流程）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%A0%E4%B8%AA%E5%B8%B8%E8%A7%81%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">7.1.5.</span> <span class="toc-text">几个常见的对比</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#runnable-vs-callable"><span class="toc-number">7.1.5.1.</span> <span class="toc-text">Runnable vs Callable</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#execute-vs-submit"><span class="toc-number">7.1.5.2.</span> <span class="toc-text">execute() vs submit()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#shutdown-vs-shutdownnow"><span class="toc-number">7.1.5.3.</span> <span class="toc-text">shutdown() vs shutdownNow()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#isshutdown-vs-isterminated"><span class="toc-number">7.1.5.4.</span> <span class="toc-text">isShutdown() vs isTerminated()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E5%86%85%E7%BD%AE%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">7.1.6.</span> <span class="toc-text">几种常见的内置线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#fixedthreadpool"><span class="toc-number">7.1.6.1.</span> <span class="toc-text">FixedThreadPool</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D"><span class="toc-number">7.1.6.1.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E4%BB%BB%E5%8A%A1%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="toc-number">7.1.6.1.2.</span> <span class="toc-text">处理任务的流程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8"><span class="toc-number">7.1.6.1.3.</span> <span class="toc-text">为什么不推荐使用？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#singlethreadexecutor"><span class="toc-number">7.1.6.2.</span> <span class="toc-text">SingleThreadExecutor</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-2"><span class="toc-number">7.1.6.2.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E4%BB%BB%E5%8A%A1%E7%9A%84%E6%B5%81%E7%A8%8B-2"><span class="toc-number">7.1.6.2.2.</span> <span class="toc-text">处理任务的流程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8-2"><span class="toc-number">7.1.6.2.3.</span> <span class="toc-text">为什么不推荐使用？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#cachedthreadpool"><span class="toc-number">7.1.6.3.</span> <span class="toc-text">CachedThreadPool</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-3"><span class="toc-number">7.1.6.3.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E4%BB%BB%E5%8A%A1%E7%9A%84%E6%B5%81%E7%A8%8B-3"><span class="toc-number">7.1.6.3.2.</span> <span class="toc-text">处理任务的流程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8-3"><span class="toc-number">7.1.6.3.3.</span> <span class="toc-text">为什么不推荐使用？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#scheduledthreadpool"><span class="toc-number">7.1.6.4.</span> <span class="toc-text">ScheduledThreadPool</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-4"><span class="toc-number">7.1.6.4.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#scheduledthreadpoolexecutor-%E5%92%8C-timer-%E5%AF%B9%E6%AF%94"><span class="toc-number">7.1.6.4.2.</span> <span class="toc-text">ScheduledThreadPoolExecutor 和 Timer 对比</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E8%83%BD%E6%A0%B9%E6%8D%AE%E4%BB%BB%E5%8A%A1%E4%BC%98%E5%85%88%E7%BA%A7%E6%9D%A5%E6%89%A7%E8%A1%8C%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">7.1.7.</span> <span class="toc-text">如何设计一个能根据任务优先级来执行的线程池？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%9C%89%E4%BA%86%E8%A7%A3%E5%90%97%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%A4%A7%E6%A6%82%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">7.1.8.</span> <span class="toc-text">【面试题】线程池有了解吗？线程池大概的原理？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E6%B1%A0%E9%9C%80%E8%A6%81%E8%80%83%E8%99%91%E5%93%AA%E4%BA%9B%E5%9B%A0%E7%B4%A0"><span class="toc-number">7.1.9.</span> <span class="toc-text">【面试题】设计一个线程池需要考虑哪些因素？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-number">7.1.10.</span> <span class="toc-text">Java 线程池最佳实践</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%AD%A3%E7%A1%AE%E5%A3%B0%E6%98%8E%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">7.1.10.1.</span> <span class="toc-text">1、正确声明线程池</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%9B%91%E6%B5%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%BF%90%E8%A1%8C%E7%8A%B6%E6%80%81"><span class="toc-number">7.1.10.2.</span> <span class="toc-text">2、监测线程池运行状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%BB%BA%E8%AE%AE%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%88%AB%E7%9A%84%E4%B8%9A%E5%8A%A1%E7%94%A8%E4%B8%8D%E5%90%8C%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">7.1.10.3.</span> <span class="toc-text">3、建议不同类别的业务用不同的线程池</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%88%AB%E5%BF%98%E8%AE%B0%E7%BB%99%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%91%BD%E5%90%8D"><span class="toc-number">7.1.10.4.</span> <span class="toc-text">4、别忘记给线程池命名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E6%AD%A3%E7%A1%AE%E9%85%8D%E7%BD%AE%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%A4%A7%E5%B0%8F"><span class="toc-number">7.1.10.5.</span> <span class="toc-text">5、正确配置线程池大小</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B8%B8%E8%A7%84%E6%93%8D%E4%BD%9C"><span class="toc-number">7.1.10.5.1.</span> <span class="toc-text">常规操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BE%8E%E5%9B%A2%E9%AA%9A%E6%93%8D%E4%BD%9C"><span class="toc-number">7.1.10.5.2.</span> <span class="toc-text">美团骚操作</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E8%AE%B0%E5%BE%97%E5%85%B3%E9%97%AD%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">7.1.10.6.</span> <span class="toc-text">6、记得关闭线程池</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%B0%BD%E9%87%8F%E4%B8%8D%E8%A6%81%E6%94%BE%E8%80%97%E6%97%B6%E4%BB%BB%E5%8A%A1"><span class="toc-number">7.1.10.7.</span> <span class="toc-text">7、线程池尽量不要放耗时任务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%BF%E7%94%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E5%9D%91"><span class="toc-number">7.1.10.8.</span> <span class="toc-text">8、线程池使用的一些小坑</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%8D%E8%A6%81%E9%87%8D%E5%A4%8D%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">7.1.10.8.1.</span> <span class="toc-text">不要重复创建线程池</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8spring%E5%86%85%E9%83%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%97%B6%E4%B8%80%E5%AE%9A%E8%A6%81%E6%89%8B%E5%8A%A8%E8%87%AA%E5%AE%9A%E4%B9%89"><span class="toc-number">7.1.10.8.2.</span> <span class="toc-text">使用 Spring 内部线程池时一定要手动自定义</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%92%8C-threadlocal-%E4%B8%8D%E8%A6%81%E5%85%B1%E7%94%A8"><span class="toc-number">7.1.10.8.3.</span> <span class="toc-text">线程池和 ThreadLocal 不要共用</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#future-%E6%8E%A5%E5%8F%A3"><span class="toc-number">7.2.</span> <span class="toc-text">Future 接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8-2"><span class="toc-number">7.2.1.</span> <span class="toc-text">有什么用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8E-callable-%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">7.2.2.</span> <span class="toc-text">与 Callable 的关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#completablefuture-%E7%B1%BB"><span class="toc-number">7.2.3.</span> <span class="toc-text">CompletableFuture 类</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E5%8C%85juc"><span class="toc-number">8.</span> <span class="toc-text">并发包（J.U.C）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#java%E5%B8%B8%E8%A7%81%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8"><span class="toc-number">8.1.</span> <span class="toc-text">Java 常见并发容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#concurrenthashmap"><span class="toc-number">8.1.1.</span> <span class="toc-text">ConcurrentHashMap</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#concurrenthashmap-17"><span class="toc-number">8.1.1.1.</span> <span class="toc-text">ConcurrentHashMap 1.7</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#concurrenthashmap-18"><span class="toc-number">8.1.1.2.</span> <span class="toc-text">ConcurrentHashMap 1.8</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">8.1.1.2.1.</span> <span class="toc-text">存储结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96-inittable"><span class="toc-number">8.1.1.2.2.</span> <span class="toc-text">初始化 initTable</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#put"><span class="toc-number">8.1.1.2.3.</span> <span class="toc-text">put</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#get"><span class="toc-number">8.1.1.2.4.</span> <span class="toc-text">get</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98concurrenthashmap-%E7%9B%B8%E5%AF%B9%E4%BA%8E-hashmap-%E5%A5%BD%E5%9C%A8%E5%93%AA%E9%87%8C"><span class="toc-number">8.1.1.3.</span> <span class="toc-text">【面试题】concurrentHashMap 相对于 hashMap 好在哪里？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#copyonwritearraylist"><span class="toc-number">8.1.2.</span> <span class="toc-text">CopyOnWriteArrayList</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#concurrentlinkedqueue"><span class="toc-number">8.1.3.</span> <span class="toc-text">ConcurrentLinkedQueue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#blockingqueue-%E6%8E%A5%E5%8F%A3"><span class="toc-number">8.1.4.</span> <span class="toc-text">BlockingQueue 接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-8"><span class="toc-number">8.1.4.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#arrayblockingqueue"><span class="toc-number">8.1.4.2.</span> <span class="toc-text">ArrayBlockingQueue</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#linkedblockingqueue"><span class="toc-number">8.1.4.3.</span> <span class="toc-text">LinkedBlockingQueue</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#priorityblockingqueue"><span class="toc-number">8.1.4.4.</span> <span class="toc-text">PriorityBlockingQueue</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#concurrentskiplistmap"><span class="toc-number">8.1.5.</span> <span class="toc-text">ConcurrentSkipListMap</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#java-io"><span class="toc-number">9.</span> <span class="toc-text">Java IO</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">9.1.</span> <span class="toc-text">基础知识</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">9.2.</span> <span class="toc-text">设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8Fdecorator"><span class="toc-number">9.2.1.</span> <span class="toc-text">装饰器模式（Decorator）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8Fadapter"><span class="toc-number">9.2.2.</span> <span class="toc-text">适配器模式（Adapter）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8E%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">9.2.2.1.</span> <span class="toc-text">与装饰器模式的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8Ffactory"><span class="toc-number">9.2.3.</span> <span class="toc-text">工厂模式（Factory）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">9.2.4.</span> <span class="toc-text">观察者模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#io-%E6%A8%A1%E5%9E%8B"><span class="toc-number">9.3.</span> <span class="toc-text">IO 模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%95%E4%B8%BA-io"><span class="toc-number">9.3.1.</span> <span class="toc-text">何为 IO ？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84-io-%E6%A8%A1%E5%9E%8B"><span class="toc-number">9.3.2.</span> <span class="toc-text">常见的 IO 模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java-%E4%B8%AD-3-%E7%A7%8D%E5%B8%B8%E8%A7%81-io-%E6%A8%A1%E5%9E%8B"><span class="toc-number">9.3.3.</span> <span class="toc-text">Java 中 3 种常见 IO 模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#bioblocking"><span class="toc-number">9.3.3.1.</span> <span class="toc-text">BIO（Blocking）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#nionon-blockingnew"><span class="toc-number">9.3.3.2.</span> <span class="toc-text">NIO（Non-blocking&#x2F;New）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#nio-%E7%AE%80%E4%BB%8B"><span class="toc-number">9.3.3.2.1.</span> <span class="toc-text">NIO 简介</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#nio-%E4%B8%89%E5%A4%A7%E7%BB%84%E4%BB%B6"><span class="toc-number">9.3.3.2.2.</span> <span class="toc-text">NIO 三大组件</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#buffer%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">9.3.3.2.2.1.</span> <span class="toc-text">Buffer（缓冲区）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#channel%E9%80%9A%E9%81%93"><span class="toc-number">9.3.3.2.2.2.</span> <span class="toc-text">Channel（通道）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#selector%E9%80%89%E6%8B%A9%E5%99%A8"><span class="toc-number">9.3.3.2.2.3.</span> <span class="toc-text">Selector（选择器）</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#nio-%E9%9B%B6%E6%8B%B7%E8%B4%9D"><span class="toc-number">9.3.3.2.3.</span> <span class="toc-text">NIO 零拷贝</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">9.3.3.2.4.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#aioasynchronous"><span class="toc-number">9.3.3.3.</span> <span class="toc-text">AIO（Asynchronous）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-2"><span class="toc-number">9.3.3.4.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98nio-%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%90%8C%E6%AD%A5%E9%9D%9E%E9%98%BB%E5%A1%9E%E7%9A%84%E4%B8%BB%E7%BA%BF%E7%A8%8B%E6%98%AF%E5%8F%AA%E6%9C%89%E4%B8%80%E4%B8%AA%E5%90%97"><span class="toc-number">9.3.4.</span> <span class="toc-text">【面试题】NIO 是如何实现同步非阻塞的？主线程是只有一个吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98bionioaio%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">9.3.5.</span> <span class="toc-text">【面试题】BIO&#x2F;NIO&#x2F;AIO 的区别？</span></a></li></ol></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li class="active"><a href="/java/juc/JUC%E7%AC%94%E8%AE%B0/" rel="bookmark" title="JUC 笔记">JUC 笔记</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="范特东东东" data-src="/images/avatar.jpg"><p class="name" itemprop="name">范特东东东</p><div class="description" itemprop="description"></div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">65</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">21</span> <span class="name">分类</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hqeDE1OQ==" title="https:&#x2F;&#x2F;github.com&#x2F;hjx159"><i class="ic i-github"></i></span> <span class="exturl item xiaohongshu" data-url="aHR0cHM6Ly93d3cueGlhb2hvbmdzaHUuY29tL3VzZXIvcHJvZmlsZS81ZTAyYzhhZDAwMDAwMDAwMDEwMDFmM2U=" title="https:&#x2F;&#x2F;www.xiaohongshu.com&#x2F;user&#x2F;profile&#x2F;5e02c8ad0000000001001f3e"><i class="ic i-xiaohongshu2"></i></span> <span class="exturl item email" data-url="bWFpbHRvOjgxMjE0MzI4MEBxcS5jb20=" title="mailto:812143280@qq.com"><i class="ic i-envelope"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><a href="/categories/photography/" rel="section"><i class="ic i-photography"></i>摄影</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于我</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/java/java-se/java-excise/%E7%AC%AC18%E7%AB%A0%EF%BC%9A%E9%9A%8F%E5%A0%82%E5%A4%8D%E4%B9%A0%E4%B8%8E%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%A2%98%EF%BC%88JDK8-17%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%89/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/photography/%E8%AF%BE%E4%B8%8A%E6%91%B8%E9%B1%BC/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/java/" title="分类于 Java">Java</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/" title="分类于 Java基础">Java基础</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/java-knowledge/" title="分类于 Java基础-知识点">Java基础-知识点</a></div><span><a href="/java/java-se/java-knowledge/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E5%AE%8B%E7%BA%A2%E5%BA%B7_%E7%AC%AC18%E7%AB%A0_JDK8-17%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%88%E4%B8%8B%EF%BC%89/" title="宋红康_第18章_JDK8-17新特性（下）">宋红康_第18章_JDK8-17新特性（下）</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/mind-map/" title="分类于 思维导图">思维导图</a></div><span><a href="/mind-map/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE%E5%90%88%E9%9B%86/" title="思维导图合集">思维导图合集</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/mq/" title="分类于 消息队列">消息队列</a></div><span><a href="/mq/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" title="消息队列">消息队列</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/java/" title="分类于 Java">Java</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/" title="分类于 Java基础">Java基础</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/java-excise/" title="分类于 Java基础-真题">Java基础-真题</a></div><span><a href="/java/java-se/java-excise/%E7%AC%AC06%E7%AB%A0%EF%BC%9A%E9%9A%8F%E5%A0%82%E5%A4%8D%E4%B9%A0%E4%B8%8E%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%A2%98%EF%BC%88%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%9F%BA%E7%A1%80%EF%BC%89/" title="宋红康_第06章：面向对象-基础">宋红康_第06章：面向对象-基础</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/database/" title="分类于 数据库">数据库</a> <i class="ic i-angle-right"></i> <a href="/categories/database/mysql/" title="分类于 MySQL">MySQL</a></div><span><a href="/database/mysql/MySQL-JavaGuide/" title="MySQL-JavaGuide">MySQL-JavaGuide</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/java/" title="分类于 Java">Java</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/" title="分类于 Java基础">Java基础</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/java-knowledge/" title="分类于 Java基础-知识点">Java基础-知识点</a></div><span><a href="/java/java-se/java-knowledge/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E5%AE%8B%E7%BA%A2%E5%BA%B7_%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/" title="宋红康_第01章_Java语言概述">宋红康_第01章_Java语言概述</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/database/" title="分类于 数据库">数据库</a> <i class="ic i-angle-right"></i> <a href="/categories/database/redis/" title="分类于 Redis">Redis</a></div><span><a href="/database/redis/Redis-JavaGuide/" title="Redis-JavaGuide">Redis-JavaGuide</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/java/" title="分类于 Java">Java</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/" title="分类于 Java基础">Java基础</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/java-knowledge/" title="分类于 Java基础-知识点">Java基础-知识点</a></div><span><a href="/java/java-se/java-knowledge/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E5%AE%8B%E7%BA%A2%E5%BA%B7_%E7%AC%AC07%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E8%BF%9B%E9%98%B6%EF%BC%89/" title="宋红康_第07章_面向对象编程(进阶)">宋红康_第07章_面向对象编程(进阶)</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/java/" title="分类于 Java">Java</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/" title="分类于 Java基础">Java基础</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/java-excise/" title="分类于 Java基础-真题">Java基础-真题</a></div><span><a href="/java/java-se/java-excise/%E7%AC%AC07%E7%AB%A0%EF%BC%9A%E9%9A%8F%E5%A0%82%E5%A4%8D%E4%B9%A0%E4%B8%8E%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%A2%98%EF%BC%88%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E8%BF%9B%E9%98%B6%EF%BC%89/" title="宋红康_第07章：面向对象-进阶">宋红康_第07章：面向对象-进阶</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/distributed-microservices/" title="分类于 分布式微服务">分布式微服务</a></div><span><a href="/distributed-microservices/API%E7%BD%91%E5%85%B3&SpringCloud%20Gateway/" title="API网关 &amp; SpringCloud Gateway">API网关 & SpringCloud Gateway</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">范特东东东 @ fantedong</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">1.9m 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">28:48</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"java/juc/JUC笔记/",favicon:{show:"(●´3｀●)欢迎回来",hide:"(〃＞皿＜)你快回来"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hrmmi -->