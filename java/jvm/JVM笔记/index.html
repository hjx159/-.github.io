<!-- build time:Sat Nov 11 2023 16:59:22 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="水文 & 摄影" href="http://example.com/rss.xml"><link rel="alternate" type="application/atom+xml" title="水文 & 摄影" href="http://example.com/atom.xml"><link rel="alternate" type="application/json" title="水文 & 摄影" href="http://example.com/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><link rel="canonical" href="http://example.com/java/jvm/JVM%E7%AC%94%E8%AE%B0/"><title>JVM笔记 - JVM - Java | phantasy = 水文 & 摄影</title><meta name="generator" content="Hexo 6.3.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">JVM笔记</h1><div class="meta"><span class="item" title="创建时间：2023-11-11 11:29:40"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2023-11-11T11:29:40+08:00">2023-11-11</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>116k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>1:45</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">phantasy</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><img src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/68747470733a2f2f7365617a65616e2e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f696d672f4a6176612f4a564d2d4a617661382545352538362538352545352541442539382545372542422539332545362539452538342545352539422542452e706e67"></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/java/" itemprop="item" rel="index" title="分类于 Java"><span itemprop="name">Java</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/java/jvm/" itemprop="item" rel="index" title="分类于 JVM"><span itemprop="name">JVM</span></a><meta itemprop="position" content="2"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://example.com/java/jvm/JVM%E7%AC%94%E8%AE%B0/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="范特东东东"><meta itemprop="description" content=", "></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="水文 & 摄影"></span><div class="body md" itemprop="articleBody"><h1 id="第一章jvm-概述"><a class="anchor" href="#第一章jvm-概述">#</a> 第一章：JVM 概述</h1><h2 id="1-jvm是什么"><a class="anchor" href="#1-jvm是什么">#</a> 1、JVM 是什么？</h2><ol><li><p><code>JVM</code> ：全称 Java Virtual Machine，即 <span style="color:red">Java 虚拟机</span>，是 Java 程序的运行环境。（<strong>Java 二进制字节码的运行环境</strong>）。</p></li><li><p>JVM 的特点：</p></li></ol><ul><li>Java 虚拟机基于<strong>二进制字节码</strong>执行，由一套字节码指令集、一组寄存器、一个栈、一个垃圾回收堆、一个方法区等组成</li><li>JVM 屏蔽了与操作系统平台相关的信息，从而能够让 Java 程序只需要生成能够在 JVM 上运行的字节码文件，通过该机制实现的<strong>跨平台性</strong></li></ul><ol start="3"><li>JVM 的好处：</li></ol><ul><li><font color="red">一次编译，到处运行</font></li><li><font color="red">自动内存管理，垃圾回收机制</font></li><li>数组下标越界检查</li><li>多态</li></ul><ol start="4"><li><p>Java 代码的执行流程：Java 源代码 --（<font color="red">编译</font>）--&gt; 二进制字节码文件（JVM 指令） --（<font color="red">解释</font>）--&gt; 机器码 --（交给 CPU<font color="red">执行</font>）--&gt;</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230916160844225.png" alt="image-20230916160844225"></p></li><li><p>JVM、JRE、JDK 之间的关系：</p></li></ol><ul><li><p><code>JRE</code> (Java Runtime Environment)：<font color="red">Java 运行环境</font>，用于解释执行 Java 的字节码文件。</p><blockquote><p>JRE = JVM + Java SE 标准类库</p></blockquote></li><li><p><code>JDK</code> (Java SE Development Kit)：<font color="red">Java 标准开发包</font>，提供了编译、运行 Java 程序所需的各种工具和资源。</p><blockquote><p>JDK = JRE + 开发工具集（例如 Javac 编译工具等）</p></blockquote></li></ul><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/20210207154634171.png" alt="在这里插入图片描述"></p><ol start="6"><li>常见的 JVM：</li></ol><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230916122611371.png" alt="image-20230916122611371"></p><blockquote><p>我们主要学习的是 <strong>HotSpot</strong> 版本的虚拟机。</p></blockquote><h2 id="2-jvm结构"><a class="anchor" href="#2-jvm结构">#</a> 2、JVM 结构</h2><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230916122929515.png" alt="image-20230916122929515"></p><ul><li><p><code>ClassLoader（类加载器）</code> ：Java 代码编译成二进制后，需要经过类加载器，才能加载到 JVM 中运行。</p></li><li><p><code>Method Area（方法区）</code> ：存放类。</p></li><li><p><code>Heap（堆）</code> ：存放类的实例对象。</p></li><li><p><code>JVM Stack（虚拟机栈）</code> ：是线程私有的内存空间，用于存储每个线程执行 Java 方法时的栈帧，包括局部变量、操作数栈、动态链接、方法出口等信息。</p></li><li><p><code>PC Register（程序计数器）</code> ：是一块较小的内存空间，记录当前线程所执行的字节码行号指示器。</p></li><li><p><code>Native Method Stacks（本地方法栈）</code> ：为虚拟机使用到的本地（Native）方法服务。</p></li><li><p><code>Interpreter（解释器）</code> ：逐行执行方法的每行代码</p></li><li><p><code>JIT Compiler（即时编译器）</code> ：优化方法中的热点代码、频繁调用的方法</p></li><li><p><code>GC（垃圾回收）</code> ：回收堆中不引用的对象。</p></li><li><p><code>本地方法接口</code> ：和操作系统打交道。</p></li></ul><h2 id="3-jvm生命周期"><a class="anchor" href="#3-jvm生命周期">#</a> 3、JVM 生命周期</h2><p>JVM 的生命周期分为三个阶段：</p><ul><li><strong>启动</strong>：当启动一个 Java 程序时，通过引导类加载器（bootstrap class loader）创建一个初始类（initial class），对于拥有 main 函数的类就是 JVM 实例运行的起点</li><li><strong>运行</strong>：<ul><li>main () 方法是一个程序的初始起点，任何线程均可由在此处启动</li><li>在 JVM 内部有两种线程类型，分别为： <code>用户线程</code> 和 <code>守护线程</code> ，<font color="red">JVM 使用的是守护线程，main () 和其他线程使用的是用户线程</font>，守护线程会随着用户线程的结束而结束</li><li>执行一个 Java 程序时，真真正正在执行的是<font color="red">一个 Java 虚拟机的进程</font></li><li>JVM 有两种运行模式 <code>Server</code> 与 <code>Client</code> ，两种模式的区别在于：<ul><li>Client 模式启动速度较快，Server 模式启动较慢</li><li>但是，启动进入稳定期并长期运行之后，Server 模式的程序运行速度比 Client 要快很多</li><li>Server 模式启动的 JVM 采用的是重量级的虚拟机，对程序采用了更多的优化；Client 模式启动的 JVM 采用的是轻量级的虚拟机</li></ul></li></ul></li><li><strong>死亡</strong>：<ul><li>当程序中的用户线程都中止，JVM 才会退出</li><li>程序正常执行结束、程序异常或错误而异常终止、操作系统错误导致终止</li><li>线程调用 Runtime 类 halt 方法或 System 类 exit 方法，并且 Java 安全管理器允许这次 exit 或 halt 操作</li></ul></li></ul><h1 id="第二章jvm-内存结构"><a class="anchor" href="#第二章jvm-内存结构">#</a> 第二章：JVM 内存结构</h1><h2 id="0-概述"><a class="anchor" href="#0-概述">#</a> 0、概述</h2><p>内存结构是 JVM 中非常重要的一部分，是非常重要的系统资源，<font color="red">是硬盘和 CPU 的桥梁，承载着操作系统和应用程序的实时运行，又叫<strong>运行时数据区</strong></font>。</p><p>JVM 内存结构<font color="red">规定了 Java 程序在运行过程中<strong>内存申请、分配、管理的策略</strong></font>，保证了 JVM 的高效稳定运行。</p><h3 id="java7的内存结构图"><a class="anchor" href="#java7的内存结构图">#</a> Java7 的内存结构图</h3><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230916132120271.png" alt="image-20230916132120271"></p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/1742867-20191022115805221-1590249013.jpg" alt="Java7及以前版本的内存结构"></p><blockquote><p>颜色的意义：<font color="orange">线程隔离的数据区</font>、<font color="gree">线程共享的数据区</font></p></blockquote><p>方法区是规范，<font color="cornflowerblue">永久代（PermGen）</font>是 Hotspot 针对该规范进行的实现。<strong>堆和方法区（永久代）在逻辑上依旧是分开的，但在物理上来说，它们又是连续的一块内存</strong>。也就是说，方法区（永久代）和前面讲到的新生代、老年代是连续的。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/1742867-20191022115807239-1958802553.jpg" alt="Java7及以前版本的堆和方法区的物理存储"></p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/v2-3ea6cab3f8c08e271fea9eed86733ea7_r.jpg" alt="Java堆内存又溢出了！教你一招必杀技 - 知乎"></p><h3 id="java8的内存结构图"><a class="anchor" href="#java8的内存结构图">#</a> Java8 的内存结构图</h3><p>HotSpot 取消了永久代，采用<font color="cornflowerblue">元空间（Metaspace）</font>实现方法区，同时<strong>方法区（元空间）不再与堆连续，而是存在于本地内存中</strong>。</p><blockquote><p>本地内存（Native memory）是供 JVM 自身进程使用的。当 Java Heap 空间不足时会触发 GC，但 Native memory 空间不够却不会触发 GC。</p></blockquote><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/68747470733a2f2f7365617a65616e2e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f696d672f4a6176612f4a564d2d4a617661382545352538362538352545352541442539382545372542422539332545362539452538342545352539422542452e706e67" alt="img"></p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/1742867-20191022115808845-1101254140.jpg" alt="Java8的内存结构"></p><h3 id="常见-oom-错误"><a class="anchor" href="#常见-oom-错误">#</a> 常见 OOM 错误</h3><ul><li>java.lang.StackOverflowError</li><li>java.lang.OutOfMemoryError：java heap space</li><li>java.lang.OutOfMemoryError：GC overhead limit exceeded</li><li>java.lang.OutOfMemoryError：Direct buffer memory</li><li>java.lang.OutOfMemoryError：unable to create new native thread</li><li>java.lang.OutOfMemoryError：Metaspace</li></ul><h2 id="1-程序计数器"><a class="anchor" href="#1-程序计数器">#</a> 1、程序计数器</h2><blockquote><p>JVM 内存，线程私有</p></blockquote><ol><li><p><code>PC Register（程序计数器（寄存器））</code> ：物理上通过<font color="red">寄存器</font>实现</p></li><li><p>作用：<strong>记录当前线程要执行的下一条 JVM 指令的地址（行号）</strong></p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230916161103415.png" alt="image-20230916161103415"></p><blockquote><ul><li><p>解释器会将 JVM 指令解释为机器码，交给 CPU 执行。</p></li><li><p>程序计数器会记录下一条 JVM 指令的地址行号，这样下一次<font color="red">解释器会从程序计数器拿到指令，然后进行解释执行</font>。</p></li></ul></blockquote><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230916161223844.png" alt="image-20230916161223844"></p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/program-counter.jpg" alt="image"></p></li><li><p>特点：</p></li></ol><ul><li><p>是<strong>线程私有</strong>的</p><blockquote><p>多线程的环境下，<font color="red">如果两个线程发生了上下文切换，那么程序计数器会记录其线程下一行指令的地址行号</font>，以便于接着往下执行。</p></blockquote></li><li><p><strong>不存在内存溢出</strong></p><blockquote><p>由 JVM 规范</p></blockquote></li></ul><h2 id="2-虚拟机栈"><a class="anchor" href="#2-虚拟机栈">#</a> 2、虚拟机栈</h2><blockquote><p>JVM 内存，线程私有</p></blockquote><h3 id="定义"><a class="anchor" href="#定义">#</a> 定义</h3><p><code>JVM Stacks（Java 虚拟机栈）</code> ：为<strong>每个线程</strong>提供运行时所需要的<font color="red">私有内存</font></p><ul><li>虚拟机栈由多个 <code>栈帧（Frame）</code> 组成，对应着<strong>每个调用方法</strong>占用的内存，存储了方法的：<ul><li><font color="cornflowerblue">局部变量表</font>：存储方法的参数、方法体内的局部变量，包含 8 种 Java 基本数据类型，以及引用数据类型</li><li><font color="cornflowerblue">操作数栈</font>：随着方法执行和字节码指令的执行，会从局部变量表或对象实例的字段中复制常量或变量写入到操作数栈，再随着计算的进行将栈中元素出栈到局部变量表或者返回给方法调用者，也就是出栈 / 入栈操作</li><li><font color="cornflowerblue">动态链接</font>：每个栈帧都包含一个指向运行时常量池中该栈所属方法的符号引用，持有这个引用的目的是为了支持方法调用过程中的动态链接 (Dynamic Linking)</li><li><font color="cornflowerblue">方法返回地址</font>：无论方法是否正常完成，都需要返回到方法被调用的位置，程序才能继续进行</li></ul></li><li>每个线程只能有一个<font color="red">活动栈帧</font>，对应着当前正在执行的方法</li><li>每一个方法从调用至执行完成的过程，都对应着一个栈帧在虚拟机栈里从入栈到出栈的过程。</li></ul><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230920161330926.png" alt="image-20230920161330926"></p><h3 id="问题辨析"><a class="anchor" href="#问题辨析">#</a> 问题辨析</h3><ol><li><p>垃圾回收是否涉及栈内存？</p><blockquote><p><strong>GC 不涉及栈内存</strong>。栈内存是方法调用产生的，<font color="red">方法调用结束后会自动弹出栈，相当于清空了数据</font>。</p></blockquote></li><li><p>栈内存分配越大越好吗？</p><blockquote><p><strong>栈内存并非越大越好</strong>。因为物理内存是一定的，栈内存分配越大，可以支持更多的递归调用，但是<font color="red">可执行的线程数就会越少</font>。</p></blockquote></li><li><p>方法内的局部变量是否线程安全？</p><blockquote><ul><li><strong>如果方法内部的变量没有逃离方法的作用访问，它是线程安全的</strong>（逃逸分析）</li><li>如果是局部变量引用了对象，并逃离了方法的作用范围，需要考虑线程安全</li></ul></blockquote></li></ol><h3 id="栈内存溢出"><a class="anchor" href="#栈内存溢出">#</a> 栈内存溢出</h3><p>以下两种情况会导致栈内存溢出（ <code>java.lang.StackOverflowError</code> 异常）：</p><ul><li><font color="red">栈帧过多</font>，例如递归层数过多，或者递归终止条件不合理</li><li><font color="red">线程请求的栈深度超过最大值</font></li></ul><h3 id="线程运行诊断"><a class="anchor" href="#线程运行诊断">#</a> 线程运行诊断</h3><p>案例 1：Linux 环境下运行某些程序的时候，可能导致 CPU 的占用过高</p><blockquote><p>解决方法：找到占用 CPU 过高的线程</p><ul><li><code>top</code> 命令：定位哪个<font color="red">进程</font>占用 CPU 过高</li><li><code>ps H -eo pid,tid,%cpu | grep 进程id</code> ：进一步定位是哪个<font color="red">线程</font>引起的 cpu 占用过高</li><li><code>jstack 进程id</code> ：可以根据线程 id 找到有问题的线程，进一步排查出<font color="red">问题代码的源码行号</font>。注意 jstack 查找出的线程 id 是 16 进制的，需要转换。</li></ul></blockquote><p>案例 2：程序运行了很长时间都没有结果</p><blockquote><p>解决方法与上类似，观察 <code>jstack</code> 命令的最后面的输出信息（例如死锁）</p></blockquote><h2 id="3-本地方法栈"><a class="anchor" href="#3-本地方法栈">#</a> 3、本地方法栈</h2><blockquote><p>JVM 内存，线程私有</p></blockquote><p><code>Native Method Stack（本地方法栈）</code> ：当 Java 需要调用一些<font color="red">带有 native 关键字的本地的 C 或者 C++ 方法</font>时，因为 JAVA 有时候没法直接和操作系统底层交互，所以需要用到本地方法栈，服务于带 native 关键字的方法，为其<font color="red">提供内存空间</font>。</p><h2 id="4-堆"><a class="anchor" href="#4-堆">#</a> 4、堆</h2><blockquote><p>JVM 内存，线程共享</p></blockquote><h3 id="定义-2"><a class="anchor" href="#定义-2">#</a> 定义</h3><ol><li><code>Heap（堆）</code> ：JVM 内存中最大的一块</li><li>特点如下：</li></ol><ul><li>由所有<font color="red">线程共享</font>，堆中对象大部分都需要考虑<font color="red">线程安全</font>的问题</li><li>由<font color="red">垃圾回收器</font>管理的主要区域</li></ul><ol start="3"><li>存放以下资源：</li></ol><ul><li><font color="cornflowerblue">对象实例</font>：类初始化生成的对象，<font color="red">基本数据类型的数组也是对象实例</font>，new 创建对象都使用堆内存</li><li><font color="cornflowerblue">字符串常量池</font>：<ul><li>字符串常量池<font color="red">原本存放于方法区，JDK7 开始放置于堆中</font></li><li>字符串常量池<strong>存储的是 String 对象的直接引用或者对象</strong>，是一张 string table</li></ul></li><li><font color="cornflowerblue">静态变量</font>：由 static 修饰的变量，<font color="red">JDK8 时从方法区迁移至堆中</font></li><li><font color="cornflowerblue">线程分配缓冲区（TLAB）</font>：Thread Local Allocation Buffer，<strong>线程私有</strong>但不影响堆的共性，可以提升对象分配的效率</li></ul><h3 id="溢出"><a class="anchor" href="#溢出">#</a> 溢出</h3><blockquote><p>设置堆内存大小的指令： <code>-Xmx Size</code></p></blockquote><p>堆内存溢出的异常信息： <code>java.lang.OutOfMemoryError ：java heap space.</code></p><h3 id="堆内存诊断工具"><a class="anchor" href="#堆内存诊断工具">#</a> 堆内存诊断工具</h3><blockquote><p>控制台命令</p></blockquote><ol><li><p><code>jps</code> ：查看当前系统中有哪些 Java 进程</p></li><li><p>jmap：查看堆内存占用情况 <code>jmap -heap 进程id</code></p></li><li><p><code>jconsole</code> ：图形界面的，多功能的监测工具，可以连续监测</p></li><li><p><strong><code>jvisualvm</code> </strong>：可视化展示 JVM，可以查看某时刻堆内存的信息，以及具体哪些对象占用堆内存最多</p></li></ol><p>堆内存诊断案例：多次垃圾回收后，堆内存占用仍然很高，怎么办？试试 jvisualvm！</p><h3 id="java7中的堆内存组成分代"><a class="anchor" href="#java7中的堆内存组成分代">#</a> Java7 中的堆内存组成（分代）</h3><ul><li><font color="cornflowerblue">年轻代（Young）</font>：分为三部分，Eden 区和两个大小严格相同的 Survivor 区。<ul><li>Survivor 区某时刻只有其中一个是被使用的，另外一个留做垃圾回收时复制对象。</li><li>在 Eden 区变满的时候，GC 就会将存活的对象移到空闲的 Survivor 区间中，根据 JVM 的策略，在经过几次垃圾回收后，仍然存活于 Survivor 的对象将被移动到 Tenured 区间。</li></ul></li><li><font color="cornflowerblue">老年代（Tenured）</font>：主要保存生命周期长的对象，一般是一些老的对象，当一些对象在 Young 复制转移一定的次数以后，对象就会被转移到 Tenured 区。</li><li><font color="cornflowerblue">永久代（Perm，方法区）</font>：主要保存 Class、ClassLoader、静态变量、常量、编译后的代码，在 Java7 中堆内方法区会受到 GC 的管理。</li></ul><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230920165900317.png" alt="image-20230920165900317"></p><p>分代原因：不同对象的生命周期不同，70%-99% 的对象都是临时对象，优化 GC 性能。</p><h3 id="java8中的堆内存组成分代"><a class="anchor" href="#java8中的堆内存组成分代">#</a> Java8 中的堆内存组成（分代）</h3><blockquote><p>方法区的实现不再是永久代，而是位于本地内存中的元空间（Metaspace）</p></blockquote><ul><li><font color="cornflowerblue">年轻代</font></li><li><font color="cornflowerblue">老年代</font></li></ul><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/68747470733a2f2f7365617a65616e2e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f696d672f4a6176612f4a564d2de58886e4bba3e694b6e99b86e7ae97e6b3952e706e67" alt="img"></p><h2 id="5-方法区"><a class="anchor" href="#5-方法区">#</a> 5、方法区</h2><blockquote><p>本地内存，线程共享</p></blockquote><h3 id="定义-3"><a class="anchor" href="#定义-3">#</a> 定义</h3><ol><li><p><code>Method Area（方法区）</code> ：一块所有 Java 虚拟机<font color="red">线程之间共享</font>的方法区域</p></li><li><p>特点：</p></li></ol><ul><li><p><strong>存储每个类的结构信息</strong>：</p><ul><li><strong><font color="cornflowerblue">运行时常量池</font></strong></li><li><font color="cornflowerblue">字段和方法数据</font></li><li><font color="cornflowerblue">方法和构造函数的代码</font></li></ul></li><li><p><strong>在虚拟机启动时被创建</strong>。尽管 JVM 规范认为方法区在逻辑上是堆的一部分，但简单的实现可能会选择不进行垃圾收集或压缩。<font color="red">JVM 规范不强制要求方法区的位置（例如 Hotspot JVM 在 Java7 中方法区位于堆中的<strong>永久代</strong>，而在 Java8 中采用<strong>元空间</strong>来实现方法区，位于本地内存中）</font>或用于管理编译代码的策略。</p><blockquote><p>方法区是一个 JVM 规范，<strong><font color="cornflowerblue">永久代</font>与<font color="cornflowerblue">元空间</font>都是方法区的一种实现方式</strong></p></blockquote></li><li><p><font color="red">方法区的大小不必是固定的</font>，可动态扩展</p></li><li><p><font color="red">方法区的内存不必是连续的</font></p></li></ul><h3 id="组成"><a class="anchor" href="#组成">#</a> 组成</h3><blockquote><p>Hotspot 虚拟机中的方法区在 Java1.6 与 Java1.8 的结构对比图</p></blockquote><p>在 Java 1.6 中，方法区的实现方式是<font color="red">堆内存</font>中的<font color="cornflowerblue">永久代（PermGen）</font>，包括：</p><ul><li>Class</li><li>ClassLoader</li><li>运行时常量池<ul><li><font color="red">StringTable</font></li></ul></li></ul><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230917130739069.png" alt="image-20230917130739069"></p><center>Java 1.6 内存结构图</center><p>在 Java 1.8 中，将堆内的方法区（永久代）移动到了<font color="red">本地内存</font>上，重新开辟了一块空间，叫做<font color="cornflowerblue">元空间（Metaspace）</font>，存储类的元信息：</p><ul><li>Class</li><li>ClassLoader</li><li>运行时常量池</li></ul><blockquote><p><font color="red">StringTable 不再跟随方法区的实现了，而是留在堆内存中</font></p></blockquote><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230917130751140.png" alt="image-20230917130751140"></p><center>Java 1.8 内存结构图</center><h3 id="溢出-2"><a class="anchor" href="#溢出-2">#</a> 溢出</h3><p>如果方法区中的内存无法满足分配请求（例如<font color="red">加载的类太多</font>），那么 JVM</p><ul><li><p>在 1.8 之前，将抛出<font color="cornflowerblue">永久代</font>空间内存溢出异常 <code>java.lang.OutOfMemoryError: PermGen space</code></p><blockquote><p>修改永久代的内存大小： <code>-XX:MaxPermSize=8m</code></p></blockquote></li><li><p>在 1.8 之后，将抛出<font color="cornflowerblue">元空间</font>内存溢出异常 <code>java.lang.OutOfMemoryError: Metaspace</code></p><blockquote><p>修改元空间的内存大小： <code>-XX:MaxMetaspaceSize=8m</code></p></blockquote></li></ul><p>场景：spring、mybatis 中大量使用动态生成类（二进制字节码），而后加载</p><h3 id="运行时常量池"><a class="anchor" href="#运行时常量池">#</a> 运行时常量池</h3><h4 id="常量池表"><a class="anchor" href="#常量池表">#</a> 常量池表</h4><blockquote><p>Java 源代码经过编译后，生成 Java 字节码文件（即 Class 文件），分为以下三部分：</p><ul><li>类基本信息</li><li><font color="red">常量池表</font></li><li>类方法定义：包含 JVM 指令</li></ul></blockquote><p><code>常量池表（Constant Pool Table）</code> 是 Class 文件的一部分，存储了<strong>类在<u>编译期间</u>生成的字面量、符号引用</strong>，<font color="red">JVM 为每个已加载的类维护一个常量池</font>，JVM 指令根据常量池表查找要执行的类名、方法名、参数类型、字面量等信息。</p><ul><li><font color="cornflowerblue">字面量</font>：基本数据类型、String 类型常量、声明为 final 的常量值等</li><li><font color="cornflowerblue">符号引用</font>：类、字段、方法、接口等的符号引用</li></ul><h4 id="运行时常量池-2"><a class="anchor" href="#运行时常量池-2">#</a> 运行时常量池</h4><p><code>运行时常量池（Runtime Constant Pool）</code> ：</p><ul><li><strong>常量池中的数据会在<u>对应类被加载</u>后放入运行时常量池</strong></li><li>类在解析阶段将这些<font color="red">符号引用替换成直接引用</font></li><li>除了在编译期生成的常量，<font color="red">还允许动态生成常量</font>，例如 String 类的 intern ()</li></ul><h3 id="stringtable"><a class="anchor" href="#stringtable">#</a> StringTable</h3><blockquote><p>jdk 1.6 在永久代（即方法区的常量池）中，jdk 1.8 在堆内存中。</p></blockquote><p><code>StringTable</code> （ <code>字符串常量池</code> / <code>串池</code> / <code>String Pool</code> ）保存着所有<strong>字符串字面量（literal strings）</strong>，这些字面量在编译时期就确定。<font color="red">是 HashTable 结构，不能扩容</font>，通过 <code>-XX:StringTableSize</code> 设置大小，JDK 1.8 中默认 60013。</p><p>有以下特性，下文会逐一展开介绍：</p><ul><li>常量池中的字符串仅是符号，只有在被用到时才会转化为 String 对象，添加到 StringTable（串池）中</li><li><font color="red">利用串池的机制（Hashtable 结构），字符串对象是唯一的，避免重复创建</font></li><li>字符串<font color="red">变量</font>拼接的原理是<font color="cornflowerblue">StringBuilder</font></li><li>字符串<font color="red">常量</font>拼接的原理是<font color="cornflowerblue">编译器优化</font></li><li>可以使用<font color="red">String 的 intern 方法，尝试将字符串对象放入串池中，如果已存在则不会重复放入。最终返回串池中的该字符串对象。</font></li></ul><h4 id="stringtable与常量池的关系"><a class="anchor" href="#stringtable与常量池的关系">#</a> StringTable 与常量池的关系</h4><p><strong>字符串延迟实例化</strong>：<font color="red">常量池中的字符串仅是符号，第一次使用时才变为 String 对象添加到 StringTable（串池）中</font>。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230917152113099.png" alt="image-20230917152113099"></p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230917154323511.png" alt="image-20230917154323511"></p><h4 id="字符串拼接原理"><a class="anchor" href="#字符串拼接原理">#</a> 字符串拼接原理</h4><ul><li><p>字符串<strong>变量</strong>的拼接的原理是<font color="cornflowerblue">StringBuilder 的 append () 方法</font></p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230917152827900.png" alt="image-20230917152827900"></p><blockquote><p>s3 是 StringTable（串池）中的一个 String 对象，而 s4 是 new 出来的 String 对象，位于堆内存中，二者只是值相同，但地址不同！</p></blockquote></li><li><p>字符串<strong>常量</strong>拼接的原理是<font color="cornflowerblue">编译期优化</font>，先判断拼接结果对应的 String 对象是否已存在于<font color="red">StringTable（串池）</font>中，是则直接复用该 String 对象</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230917153822577.png" alt="image-20230917153822577"></p></li></ul><h4 id="stringtable如何添加字符串对象"><a class="anchor" href="#stringtable如何添加字符串对象">#</a> StringTable 如何添加字符串对象</h4><p>使用 <code>String 的 intern()</code> 方法可尝试将字符串对象添加到 StringTable（串池）中：</p><blockquote><p><strong>无论如何，最终 intern () 都会返回 StringTable（串池）中的字符串对象的引用！</strong></p></blockquote><ul><li><p>JDK 1.8：当一个字符串调用 intern () 方法时，如果 StringTable（串池）中：</p><ul><li><p>若存在一个字符串和该字符串值相等，则不会将该字符串对象放入传值</p><blockquote><p>此时，堆内存与串池中的字符串对象不是同一个对象</p></blockquote><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230917161639164.png" alt="image-20230917161639164"></p></li><li><p>若不存在，则会把该字符串对象的 **<u>引用地址</u>复制一份，放入串池 **</p><blockquote><p>此时，堆内存与串池中的字符串对象<strong>是同一个对象</strong></p></blockquote><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230917161329890.png" alt="image-20230917161329890"></p></li></ul></li><li><p>JDK 1.6：将这个字符串对象尝试放入串池，</p><ul><li><p>若存在一个字符串和该字符串值相等，则不放入</p><blockquote><p>此时，堆内存与串池中的字符串对象不是同一个对象</p></blockquote><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230917162609942.png" alt="image-20230917162609942"></p></li><li><p>若不存在，则会把此 **<u>对象</u>复制一份，放入串池 **</p><blockquote><p>此时，堆内存与串池中的字符串对象<strong>不是同一个对象</strong></p></blockquote><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230917162513392.png" alt="image-20230917162513392"></p></li></ul></li></ul><h4 id="stringtable-面试题"><a class="anchor" href="#stringtable-面试题">#</a> StringTable 面试题</h4><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230917170027499.png" alt="image-20230917170027499"></p><h4 id="stringtable-位置"><a class="anchor" href="#stringtable-位置">#</a> StringTable 位置</h4><p>Java 7 之前，StringTable 被放在<font color="cornflowerblue">永久代中的运行时常量池</font>中。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230917130739069.png" alt="image-20230917130739069"></p><center>Java 1.6 内存结构图</center><p>Java 7 以后，StringTable 被移到<font color="cornflowerblue">堆</font>中。</p><blockquote><p>因为永久代的空间有限，在大量使用字符串的场景下会导致 <code>OutOfMemoryError</code> 错误</p></blockquote><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230917130751140.png" alt="image-20230917130751140"></p><center>Java 1.8 内存结构图</center><h4 id="stringtable-垃圾回收"><a class="anchor" href="#stringtable-垃圾回收">#</a> StringTable 垃圾回收</h4><ul><li><code>-Xmx10m</code> ：指定堆内存大小为 10m</li><li><code>-XX:+PrintStringTableStatistics</code> ：打印 StringTable（串池）的统计信息</li><li><code>-XX:+PrintGCDetails</code> ：打印垃圾回收的详细信息</li><li><code>-verbose:gc</code> ：打印 gc 的次数，耗费时间等信息</li></ul><h4 id="stringtable-性能调优"><a class="anchor" href="#stringtable-性能调优">#</a> StringTable 性能调优</h4><ul><li><p><font color="red">适当增加 StringTableSize（即桶个数）</font>，来提高字符串放入串池的性能。</p><blockquote><p>因为 StringTable 是由<strong> HashTable</strong> 实现的，底层是<strong>数组 + 链表</strong>，数组长度代表 HashTable 的桶个数，桶个数越多意味着元素存储地越分散，哈希冲突的概率越小，各个桶上的链表较短，查找性能越高。命令如下：</p><p><code>-XX:StringTableSize=桶个数</code> （最少设置为 1009 以上）</p></blockquote></li><li><p>若数据中存在许多重复的字符串，可以<font color="red">通过 <code>intern</code> 方法将字符串对象放入 StringTable（串池）</font>，通过复用字符串的引用，减少内存占用</p></li></ul><h2 id="6-直接内存"><a class="anchor" href="#6-直接内存">#</a> 6、直接内存</h2><blockquote><p>本地内存，线程共享</p></blockquote><h3 id="定义-4"><a class="anchor" href="#定义-4">#</a> 定义</h3><p><code>Direct Memory（直接内存）</code> ：是<strong>直接向系统申请的内存区间</strong>，位于本地内存，不是 JVM 运行时数据区的一部分，但<font color="red">操作系统和 Java 代码都可以访问</font>。直接内存有以下特点：</p><ul><li><p>常见于 **<font color="red">NIO（同步非阻塞 IO）操作</font>** 时，用于数据缓冲区</p><blockquote><p>三种 IO 模型：</p><ul><li><p><font color="cornflowerblue">BIO【Blocking I/O，同步阻塞 IO】</font>：数据的写入和读取都必须阻塞在一个线程中执行，在写入完成或读取完成前，线程阻塞。</p></li><li><p><font color="cornflowerblue">NIO【Non-Blocking I/O，同步非阻塞 IO】</font>：出现于 JDK 1.4，NIO 相对于 BIO 来说出现了几个核心的组件：</p><ul><li><font color="red">Selector（选择器）</font>：可以让单个线程处理多个通道，达到复用的目的</li><li><font color="red">Channle（通道）</font>：NIO 的所有 IO 操作都从 Channle 开始：<ul><li>从通道进行数据读取 ：创建一个缓冲区，然后请求通道读取数据。</li><li>从通道进行数据写入 ：创建一个缓冲区，填充数据，并要求通道写入数据。</li></ul></li><li><font color="red">Buffer（缓冲区）</font>：<strong>缓冲区的出现导致了 NIO 和 BIO 的不同</strong>：<ul><li>读数据时可以先读一部分到缓冲区中，然后处理其他事情；</li><li>写数据时可以先写一部分到缓冲区中，然后处理其他事情。</li><li>读和写操作可以不再持续，所以不会阻塞。</li><li>当缓冲区满后才会将其放入真正地读 / 写。</li></ul></li></ul><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230918003534675.png" alt="image-20230918003534675"></p><blockquote><p>从以上代码实例可以看出，使用原生的 Buffer、Channel 和 Selector 来实现 NIO 还是很麻烦的，所以才会出现 Netty。<strong>Netty 能够让我们快速便捷地实现 NIO，是一个基于 Java NIO 类库的<font color="red">异步通信框架</font>，它的架构特点是：<font color="red">异步非阻塞</font>、基于事件驱动、高性能、高可靠性和高可定制性。使用 Netty 可以很好地替代掉繁琐的、难以使用的 Java NIO 类库，并且 Netty 提供了更多可用的功能。</strong></p><p>还有一个原因是，JDK 原生的 NIO 是基于操作系统的 epoll 函数的，而这个函数可能会引发阻塞，而 Netty 是给予 select 函数的。</p></blockquote></li><li><p><font color="cornflowerblue">AIO【Asynchronous I/O，异步非阻塞 IO】</font>：出现于 JDK 1.7，是 NIO 的改进版，主要基于事件和回调机制来实现异步处理。</p></li></ul></blockquote></li><li><p>分配回收成本较高，但 **<font color="red">读写性能高</font>**</p></li><li><p><font color="red">不受 JVM 内存回收管理</font></p></li></ul><h3 id="直接内存的好处"><a class="anchor" href="#直接内存的好处">#</a> 直接内存的好处</h3><h4 id="文件读写流程"><a class="anchor" href="#文件读写流程">#</a> 文件读写流程</h4><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/20210208180041113.png" alt="在这里插入图片描述"></p><p>因为 java 不能直接操作文件管理，需要切换到内核态，使用本地方法进行操作，然后读取磁盘文件，会在系统内存中创建一个缓冲区，将数据读到系统缓冲区，然后在将系统缓冲区数据，复制到 java 堆内存中。</p><p>缺点：<font color="red">数据存储了两份</font>，在系统内存中有一份，java 堆中有一份，造成了不必要的复制。</p><h4 id="使用了-directbuffer-文件读取流程"><a class="anchor" href="#使用了-directbuffer-文件读取流程">#</a> 使用了 DirectBuffer 文件读取流程</h4><p><img data-src="https://img-blog.csdnimg.cn/20210208181022863.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDI4MDU3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>直接内存是操作系统和 Java 代码都可以访问的一块区域</strong>，无需将代码从系统内存复制到 Java 堆内存，从而提高了效率。</p><h3 id="直接内存的回收原理"><a class="anchor" href="#直接内存的回收原理">#</a> 直接内存的回收原理</h3><p>直接内存溢出异常会报错： <code>java.lang.OutOfMemoryError:Direct buffer memory</code> 。</p><ul><li>直接内存的回收不是通过 JVM 的垃圾回收来释放的，而是使用 <code>Unsafe 类</code> 来完成直接内存的分配与回收：<ul><li><strong>调用 <code>allocateMemory</code> 方法分配直接内存</strong></li><li><strong>手动调用 <code>freeMemory</code> 方法回收直接内存</strong></li></ul></li><li>ByteBuffer 的实现类内部使用了 <code>Cleaner（虚引用）</code> 来检测 ByteBuffer 对象。<font color="red">一旦 ByteBuffer 对象被垃圾回收</font>，那么会由 <code>ReferenceHandler（守护线程）</code> 来调用 Cleaner 的 <code>clean 方法</code> 调用 <code>freeMemory 方法</code> 来释放直接内存。</li></ul><blockquote><p>在 JVM 调优时，一般会加上以下参数：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token operator">-</span><span class="token constant">XX</span><span class="token operator">:</span><span class="token operator">+</span><span class="token class-name">DisableExplicitGC</span>  <span class="token comment">// 禁用显示的 GC</span></pre></td></tr></table></figure><p>意思就是<font color="red">禁止手动的 GC，导致直接内存无法及时回收</font>。比如手动 System.gc () 无效，它是一种 full gc，会回收新生代、老年代，会造成程序执行的时间比较长。</p><p>解决方案：所以我们就<font color="red">通过 unsafe 对象调用 freeMemory 的方式释放直接内存</font>。</p></blockquote><h1 id="第三章垃圾回收gc"><a class="anchor" href="#第三章垃圾回收gc">#</a> 第三章：垃圾回收（GC）</h1><p>垃圾回收器的工作流程大体如下：</p><ol><li><strong>标记</strong>出哪些对象是存活的，哪些是垃圾（可回收）；</li><li>进行<strong>回收</strong>（清除 / 复制 / 整理），如果有移动过对象（复制 / 整理），还需要更新引用。</li></ol><h2 id="1-垃圾判断标记"><a class="anchor" href="#1-垃圾判断标记">#</a> 1、垃圾判断（标记）</h2><p>垃圾：<strong>如果一个或多个对象没有任何的引用指向它了，那么这个对象就是垃圾</strong></p><p>作用：释放未被引用的对象，清除内存里的记录碎片，碎片整理将所占用的堆内存移到堆的一端，以便 JVM 将整理出的内存分配给新的对象</p><p><strong>GC 主要是针对堆和方法区内的基本数据类型和对象</strong>，程序计数器、虚拟机栈和本地方法栈这三个区域属于线程私有的，只存在于线程的生命周期内，线程结束之后就会消失，因此不需要对这三个区域进行垃圾回收</p><p>在堆里存放着几乎所有的 Java 对象实例，<font color="red">在 GC 执行之前，首先需要区分出内存中哪些是存活对象，哪些是已经死亡的对象</font>。只有被标记为己经死亡的对象，GC 才会在执行垃圾回收时，释放掉其所占用的内存空间，因此这个过程可以称为垃圾标记阶段。</p><p>判断对象是否存活一般有两种方式：<strong>引用计数算法</strong>和<strong>可达性分析算法</strong>。</p><h3 id="引用计数法"><a class="anchor" href="#引用计数法">#</a> 引用计数法</h3><blockquote><p>未被 JVM 采用</p></blockquote><p>对每个对象保存一个整型的引用计数器属性，用于记录对象被引用的情况。</p><ul><li>对于一个对象 A，只要有任何一个对象引用了 A，则 A 的引用计数器就加 1；</li><li>当引用失效时，引用计数器就减 1；</li><li>当对象 A 的引用计数器的值为 0，即表示对象 A 不再被引用，可进行回收</li></ul><p>优点：</p><ul><li>回收没有延迟性，无需等到内存不够的时候才开始回收，运行时根据对象计数器是否为 0，可以直接回收</li><li>在垃圾回收过程中，应用无需挂起；如果申请内存时，内存不足，则立刻报 OOM 错误</li><li>区域性，更新对象的计数器时，只是影响到该对象，不会扫描全部对象</li></ul><p>缺点：</p><ul><li>每次对象被引用时，都需要去更新计数器，有一点时间开销</li><li>浪费 CPU 资源，即使内存够用，仍然在运行时进行计数器的统计</li><li><strong>无法解决循环引用问题，会引发内存泄露</strong>【最大的缺点】。如下图所示，两个对象的计数都为 1，导致两个对象都无法被释放。</li></ul><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230919202610889.png" alt="image-20230919202610889"></p><h3 id="可达性分析算法"><a class="anchor" href="#可达性分析算法">#</a> <mark>可达性分析算法</mark></h3><blockquote><p>JVM 采用的垃圾判断算法，据此探索所有存活的对象</p></blockquote><p>也称为根搜索算法、追踪性垃圾收集。</p><h4 id="gc-roots-对象"><a class="anchor" href="#gc-roots-对象">#</a> GC Roots 对象</h4><p><strong>GC Roots 是一组活跃的引用，不是对象</strong>，放在 GC Roots Set 集合，一般包含以下对象：</p><ul><li><font color="cornflowerblue">虚拟机栈（栈帧）的局部变量表</font>中引用的对象：各个线程的各个调用方法中使用到的参数、局部变量等</li><li><font color="cornflowerblue">本地方法栈</font>中引用的对象</li><li><font color="cornflowerblue">堆中类静态属性</font>中引用的对象</li><li><font color="cornflowerblue">方法区中的常量</font>中引用的对象</li><li><font color="cornflowerblue">字符串常量池（StringTable）</font>中引用的对象</li><li><font color="cornflowerblue">同步锁 synchronized 持有的对象</font></li></ul><p>可以借助 <code>Eclipse Memory Analyzer（MAT）工具</code> 来查找 GC Roots 对象。</p><h4 id="算法原理"><a class="anchor" href="#算法原理">#</a> 算法原理</h4><p><strong>扫描堆内存中的对象，以 GC Roots 对象集合为起始点，沿着引用链查找目标对象是否被连接，是则表示目标对象仍然存活，否则表示可以被回收</strong>。基本原理：</p><ul><li>可达性分析算法后，内存中的存活对象都会被 GC Roots 对象集合直接或间接连接着，搜索走过的路径称为 <code>引用链</code></li><li>如果目标对象没有任何引用链相连，则是不可达的，就意味着该对象己经死亡，可以标记为<font color="red">垃圾对象</font></li><li>在可达性分析算法中，只有能够被 GC Roots 对象集合直接或者间接连接的对象才是<font color="red">存活对象</font></li></ul><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/68747470733a2f2f7365617a65616e2e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f696d672f4a6176612f4a564d2de58fafe8bebee680a7e58886e69e90e7ae97e6b3952e706e67" alt="img"></p><p>分析工作必须在一个<strong>保障一致性的快照</strong>中进行，否则结果的准确性无法保证，这意味着 GC 进行时必须 <code>Stop The World (STW，停顿用户线程进行GC标记)</code> ，若堆中存储的对象很多，那么 GC roots 图越复杂，需要标记更多的节点，停顿更长的时间，对于用户不友好。</p><h4 id="三色标记算法"><a class="anchor" href="#三色标记算法">#</a> 三色标记算法</h4><blockquote><p>是可达性分析算法的一种，也可以说是标记清除算法的一种升级版本，<strong>可削弱 STW 所耗费的时间</strong>。</p></blockquote><h5 id="标记算法"><a class="anchor" href="#标记算法">#</a> 标记算法</h5><p>三色标记法把遍历对象图过程中遇到的对象，标记成以下<font color="red">三种颜色</font>：</p><blockquote><p>“本对象” 可以理解成一个遍历指针，指向当前对象，从 GC Roots 对象开始。</p></blockquote><ul><li>白色：尚未访问过</li><li>灰色：本对象已访问过，但是本对象引用到的其他对象尚未全部访问</li><li>黑色：本对象已访问过，而且本对象引用到的其他对象也全部访问完成</li></ul><p><strong>当 <code>Stop The World (STW)</code> 时，对象间的引用是不会发生变化的，可以轻松完成标记</strong>，遍历访问过程为：</p><ol><li><p>初始时，所有对象都在 【白色集合】中；</p></li><li><p>将 GC Roots 直接引用到的对象 挪到 【灰色集合】中；</p></li><li><p>从灰色集合中获取对象：<br>3.1. 将本对象 引用到的 其他对象 全部挪到 【灰色集合】中；</p><p>3.2. 将本对象 挪到 【黑色集合】里面。</p></li><li><p>重复步骤 3，<font color="red">直至【灰色集合】为空时结束</font>。</p></li><li><p>结束后，<strong>仍在【白色集合】的对象即为 GC Roots 不可达，可以进行回收</strong>。</p></li></ol><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/7779607-eecbd09f81b721f8.gif" alt="img"></p><h5 id="并发标记"><a class="anchor" href="#并发标记">#</a> 并发标记</h5><blockquote><p>当需要支持并发标记时，即<strong>标记期间应用线程还在继续跑，对象间的引用可能发生变化</strong>。此时，<strong>多标</strong>和<strong>漏标</strong>的情况就有可能发生。</p></blockquote><h6 id="多标情况"><a class="anchor" href="#多标情况">#</a> 多标情况</h6><p>当 E 变为灰色或黑色时，其他线程断开的 D 对 E 的引用，导致这部分对象仍会被标记为存活，本轮 GC 不会回收这部分内存，这部分本应该回收但是没有回收到的内存，被称之为<font color="cornflowerblue">浮动垃圾</font>。</p><ul><li>针对并发标记开始后的<strong>新对象</strong>，通常的做法是直接全部当成黑色，也算浮动垃圾</li><li>浮动垃圾并不会影响应用程序的正确性，只是需要等到下一轮垃圾回收中才被清除</li></ul><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/68747470733a2f2f7365617a65616e2e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f696d672f4a6176612f4a564d2de4b889e889b2e6a087e8aeb0e6b395e5a49ae6a087e68385e586b52e706e67" alt="img"></p><h6 id="漏标情况"><a class="anchor" href="#漏标情况">#</a> 漏标情况</h6><ul><li>条件一：灰色对象断开了对一个白色对象的引用（直接或间接），即灰色对象原成员变量的引用发生了变化</li><li>条件二：其他线程中修改了黑色对象，插入了一条或多条对该白色对象的新引用</li></ul><p>结果：导致该白色对象当作垃圾被 GC，影响到了程序的正确性。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/68747470733a2f2f7365617a65616e2e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f696d672f4a6176612f4a564d2de4b889e889b2e6a087e8aeb0e6b395e6bc8fe6a087e68385e586b52e706e67" alt="img"></p><p>代码角度解释漏标：</p><pre><code>Object G = objE.fieldG; // 读
objE.fieldG = null;  	// 写
objD.fieldG = G;     	// 写
</code></pre><p>为了解决问题，可以操作上面三步，<strong>将对象 G 记录起来，然后作为灰色对象再进行遍历</strong>，比如放到一个特定的集合，等初始的 GC Roots 遍历完（并发标记），再遍历该集合（重新标记）</p><blockquote><p>所以<strong>重新标记需要 STW</strong>，应用程序一直在运行，该集合可能会一直增加新的对象，导致永远都运行不完</p></blockquote><p>解决方法：添加读写屏障，读屏障拦截第一步，写屏障拦截第二三步，在读写前后进行一些后置处理：</p><ul><li><p><strong>写屏障 + 增量更新</strong>：黑色对象新增引用，会将黑色对象变成灰色对象，最后对该节点重新扫描</p><p>增量更新 (Incremental Update) 破坏了条件二，从而保证了不会漏标</p><p>缺点：对黑色变灰的对象重新扫描所有引用，比较耗费时间</p></li><li><p><strong>写屏障 (Store Barrier) + SATB</strong>：当原来成员变量的引用发生变化之前，记录下原来的引用对象</p><p>保留 GC 开始时的对象图，即原始快照 SATB，当 GC Roots 确定后，对象图就已经确定，那后续的标记也应该是按照这个时刻的对象图走，如果期间对白色对象有了新的引用会记录下来，并且将白色对象变灰（说明可达了，并且原始快照中本来就应该是灰色对象），最后重新扫描该对象的引用关系</p><p>SATB (Snapshot At The Beginning) 破坏了条件一，从而保证了不会漏标</p></li><li><p><strong>读屏障 (Load Barrier)</strong>：破坏条件二，黑色对象引用白色对象的前提是获取到该对象，此时读屏障发挥作用</p></li></ul><p>以 Java HotSpot VM 为例，其并发标记时对漏标的处理方案如下：</p><ul><li>CMS：写屏障 + 增量更新</li><li>G1：写屏障 + SATB</li><li>ZGC：读屏障</li></ul><h3 id="五种引用"><a class="anchor" href="#五种引用">#</a> 五种引用</h3><p>无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象是否可达，判定对象是否可被回收都与【引用】有关，Java 提供了 4 种 (5？) 强度不同的引用类型。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/20210209113952135.png" alt="五种引用"></p><h4 id="强引用"><a class="anchor" href="#强引用">#</a> 强引用</h4><p>被强引用关联的对象不会被回收，只有<font color="red">所有 GC Roots 都不通过强引用引用该对象</font>，才能被垃圾回收</p><ul><li>强引用可以直接访问目标对象</li><li>虚拟机宁愿抛出 OOM 异常，也不会回收强引用所指向对象</li><li>强引用可能导致<strong>内存泄漏</strong></li></ul><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">Object</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 使用 new 一个新对象的方式来创建强引用</span></pre></td></tr></table></figure><h4 id="软引用softreference"><a class="anchor" href="#软引用softreference">#</a> 软引用（SoftReference）</h4><p>被软引用关联的对象只有在<font color="red">内存不够</font>的情况下才会被回收</p><ul><li>仅（可能有强引用，一个对象可以被多个引用）有软引用引用该对象时，在垃圾回收后，内存仍不足时会再次出发垃圾回收，回收软引用对象</li><li><strong>可以配合 <code>引用队列（ReferenceQueue）</code> 来释放软引用自身</strong>，在构造软引用时，可以指定一个引用队列，当软引用对象被回收时，就会加入指定的引用队列，通过这个队列可以跟踪对象的回收情况</li><li>软引用通常<strong>用来实现内存敏感的缓存</strong>，比如高速缓存就有用到软引用；如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时不会耗尽内存</li></ul><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">Object</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name">SoftReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">></span></span> sf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SoftReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>obj <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>  <span class="token comment">// 使对象只被软引用关联</span></pre></td></tr></table></figure><h5 id="演示"><a class="anchor" href="#演示">#</a> 演示</h5><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">/**</span></pre></td></tr><tr><td data-num="2"></td><td><pre> * 演示 软引用</pre></td></tr><tr><td data-num="3"></td><td><pre> * -Xmx20m -XX:+PrintGCDetails -verbose:gc</pre></td></tr><tr><td data-num="4"></td><td><pre> */</pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Code_08_SoftReferenceTest</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> _4MB <span class="token operator">=</span> <span class="token number">4</span> <span class="token operator">*</span> <span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token function">method2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token comment">// 设置 -Xmx20m , 演示堆内存不足</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">method1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>            list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span>_4MB<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>        <span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="22"></td><td><pre></pre></td></tr><tr><td data-num="23"></td><td><pre>    <span class="token comment">// 演示 软引用</span></pre></td></tr><tr><td data-num="24"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">method2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>        <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token class-name">SoftReference</span><span class="token operator">&lt;</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">>></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>            <span class="token class-name">SoftReference</span><span class="token operator">&lt;</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span> ref <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SoftReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span>_4MB<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>ref<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>            list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>ref<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="31"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"循环结束："</span> <span class="token operator">+</span> list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="33"></td><td><pre>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token class-name">SoftReference</span><span class="token operator">&lt;</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span> ref <span class="token operator">:</span> list<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="34"></td><td><pre>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>ref<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="35"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="36"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="37"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><ul><li><p>method1 () 方法解析：<br>首先会设置一个堆内存的大小为 20m，然后运行 mehtod1 方法，会抛异常，堆内存溢出，因为 mehtod1 中的 list 都是强引用。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/20210209125537878.png" alt="在这里插入图片描述"></p></li><li><p>method2 () 方法解析：<br>在 list 集合中存放了<font color="red">软引用对象</font>，当内存不足时，会触发 full gc，将软引用的对象回收。细节如图：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/20210209130334776.png" alt="在这里插入图片描述"></p></li></ul><p>上面的代码中，<font color="red">当软引用引用的对象被回收了，但是软引用自身还存在（但值为 null，也需要回收清理），所以一般搭配一个 <code>引用队列（ReferenceQueue）</code> 一起使用</font>。<br>将 method2 () 修改为 method3 () 如下：</p><blockquote><p>由于软引用自身关联了引用队列，<strong>当软引用所引用的 byte [] 被回收时，此时已经无用的软引用（值为 null）会加入到引用队列中</strong>。</p><p>因此，<strong>可从引用队列的队头获取无用的软引用（值为 null），并移除</strong>。</p></blockquote><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 演示 软引用 搭配引用队列</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">method3</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token class-name">SoftReference</span><span class="token operator">&lt;</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">>></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token comment">// 引用队列</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token class-name">ReferenceQueue</span><span class="token operator">&lt;</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReferenceQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>            <span class="token comment">// 关联了引用队列，当软引用所关联的 byte [] 被回收时，软引用（值为 null）自己会加入到 queue 中去</span></pre></td></tr><tr><td data-num="9"></td><td><pre>            <span class="token class-name">SoftReference</span><span class="token operator">&lt;</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span> ref <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SoftReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span>_4MB<span class="token punctuation">]</span><span class="token punctuation">,</span> queue<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>ref<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>            list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>ref<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token comment">// 从引用队列中获取值为 null 的软引用对象，并移除</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token class-name">Reference</span><span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span> poll <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 弹出队头元素</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token keyword">while</span><span class="token punctuation">(</span>poll <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>            list<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>poll<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>            poll <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="21"></td><td><pre></pre></td></tr><tr><td data-num="22"></td><td><pre>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"====================="</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token class-name">SoftReference</span><span class="token operator">&lt;</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span> ref <span class="token operator">:</span> list<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>ref<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 只会打印非 null 的软引用对象</span></pre></td></tr><tr><td data-num="25"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/20210209140627985.png" alt="在这里插入图片描述"></p><h4 id="弱引用weakreference"><a class="anchor" href="#弱引用weakreference">#</a> 弱引用（WeakReference）</h4><p>被弱引用关联的对象<font color="red">在 GC 时一定会被回收</font>，只能存活到下一次 GC 发生之前</p><ul><li>仅有弱引用引用该对象时，在垃圾回收时，<font color="red">无论内存是否充足</font>，都会回收弱引用对象</li><li><strong>可以配合 <code>引用队列（ReferenceQueue）</code> 来释放弱引用自身</strong></li><li>WeakHashMap 用来存储图片信息，可以在内存不足的时候及时回收，避免了 OOM</li></ul><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">Object</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name">WeakReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">></span></span> wf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>obj <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h5 id="演示-2"><a class="anchor" href="#演示-2">#</a> 演示</h5><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">/**</span></pre></td></tr><tr><td data-num="2"></td><td><pre> * 演示 弱引用</pre></td></tr><tr><td data-num="3"></td><td><pre> * -Xmx20m -XX:+PrintGCDetails -verbose:gc</pre></td></tr><tr><td data-num="4"></td><td><pre> */</pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Code_09_WeakReferenceTest</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token comment">//        method1();</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token function">method2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> _4MB <span class="token operator">=</span> <span class="token number">4</span> <span class="token operator">*</span> <span class="token number">1024</span> <span class="token operator">*</span><span class="token number">1024</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token comment">// 演示 弱引用</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">method1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token class-name">List</span><span class="token operator">&lt;</span><span class="token class-name">WeakReference</span><span class="token operator">&lt;</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">>></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>            <span class="token class-name">WeakReference</span><span class="token operator">&lt;</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span> weakReference <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span>_4MB<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>            list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>weakReference<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre></pre></td></tr><tr><td data-num="21"></td><td><pre>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token class-name">WeakReference</span><span class="token operator">&lt;</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span> wake <span class="token operator">:</span> list<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>wake<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="27"></td><td><pre></pre></td></tr><tr><td data-num="28"></td><td><pre>    <span class="token comment">// 演示 弱引用搭配 引用队列</span></pre></td></tr><tr><td data-num="29"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">method2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>        <span class="token class-name">List</span><span class="token operator">&lt;</span><span class="token class-name">WeakReference</span><span class="token operator">&lt;</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">>></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="31"></td><td><pre>        <span class="token class-name">ReferenceQueue</span><span class="token operator">&lt;</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReferenceQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="32"></td><td><pre></pre></td></tr><tr><td data-num="33"></td><td><pre>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">9</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="34"></td><td><pre>            <span class="token class-name">WeakReference</span><span class="token operator">&lt;</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span> weakReference <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span>_4MB<span class="token punctuation">]</span><span class="token punctuation">,</span> queue<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="35"></td><td><pre>            list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>weakReference<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="36"></td><td><pre>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token class-name">WeakReference</span><span class="token operator">&lt;</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span> wake <span class="token operator">:</span> list<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="37"></td><td><pre>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>wake<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="38"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="39"></td><td><pre>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="40"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="41"></td><td><pre>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"==========================================="</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="42"></td><td><pre>        <span class="token class-name">Reference</span><span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span> poll <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="43"></td><td><pre>        <span class="token keyword">while</span> <span class="token punctuation">(</span>poll <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="44"></td><td><pre>            list<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>poll<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="45"></td><td><pre>            poll <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="46"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="47"></td><td><pre>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token class-name">WeakReference</span><span class="token operator">&lt;</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span> wake <span class="token operator">:</span> list<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="48"></td><td><pre>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>wake<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="49"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="50"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="51"></td><td><pre>    </pre></td></tr><tr><td data-num="52"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h4 id="虚引用phantomreference"><a class="anchor" href="#虚引用phantomreference">#</a> 虚引用（PhantomReference）</h4><blockquote><p>例如在直接内存中提到的 Cleaner 虚引用</p></blockquote><p>也称为幽灵引用或者幻影引用，是<font color="red">最弱的引用类型</font></p><ul><li>一个对象是否有虚引用的存在，不会对其生存时间造成影响，也无法通过虚引用得到一个对象</li><li>为对象<font color="red">设置虚引用的唯一目的是在于跟踪垃圾回收过程，能在这个对象被回收时收到一个系统通知</font></li><li><strong>必须配合 <code>引用队列（ReferenceQueue）</code> 使用，主要配合 <code>ByteBuffer</code> 使用，被引用对象回收时会将虚引用自身入队，由 <code>Reference Handler 线程</code> 调用虚引用相关方法（例如 Unsafe 类的 freeMemory 方法）释放直接内存</strong></li></ul><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">Object</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name">PhantomReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">></span></span> pf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PhantomReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>obj <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h4 id="终结器引用finalization"><a class="anchor" href="#终结器引用finalization">#</a> 终结器引用（finalization）</h4><p>无需手动编码，但其内部<strong>必须配合 <code>引用队列（ReferenceQueue）</code> 使用</strong>。</p><ul><li><p><strong>第一次 GC 时，终结器引用自身首先入队</strong>（被引用对象暂时没有被回收）</p></li><li><p>再由 <code>Finalizer 线程</code> 通过终结器引用，找到被引用对象，并调用它的 <code>finalize 方法</code> ，<strong>第二次 GC 时才能回收被引用对象</strong></p><blockquote><p>并不推荐使用 finalize 方法释放资源，因为可能导致资源迟迟不能释放。</p></blockquote></li></ul><h2 id="2-gc算法"><a class="anchor" href="#2-gc算法">#</a> 2、GC 算法</h2><h3 id="标记-清除-算法"><a class="anchor" href="#标记-清除-算法">#</a> 标记 - 清除 算法</h3><p><code>标记-清除（Mark-Sweep）算法</code> 将垃圾回收分为两个阶段，分别是标记和清除</p><ul><li><strong>标记</strong>：Collector 从引用 GC Roots 节点开始遍历，标记所有被引用的对象，一般是在对象的 Header 中记录为可达对象，<strong>标记的是可达对象，不是垃圾</strong></li><li><strong>清除</strong>：Collector 对堆内存从头到尾进行线性的遍历，如果发现某个对象在其 Header 中没有标记为可达对象，则将其回收，把分块连接到<strong>空闲链表</strong>的单向链表，<ul><li>判断回收后的分块与前一个空闲分块是否连续，若连续会合并这两个分块</li><li>之后进行分配时只需要遍历这个空闲列表，就可以找到分块</li></ul></li><li><strong>分配阶段</strong>：程序会搜索空闲链表寻找空间大于等于新对象大小 size 的块 block，<ul><li>如果找到的块等于 size，会直接返回这个分块</li><li>如果找到的块大于 size，会将块分割成大小为 size 与 block - size 的两部分，返回大小为 size 的分块，并把大小为 block - size 的块返回给空闲列表</li></ul></li></ul><p>算法缺点：</p><ul><li>标记和清除过程效率都不高</li><li>会产生大量不连续的<strong>内存碎片</strong>，导致无法给大对象分配内存，需要维护一个空闲链表</li></ul><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/v2-1e4e744442d9dc1adefd6805a1bfdea0_r.jpg" alt="JVM 如何标记垃圾对象 之 可达性算法 - 知乎"></p><h3 id="标记-整理-算法"><a class="anchor" href="#标记-整理-算法">#</a> 标记 - 整理 算法</h3><p><code>标记-整理（Mark-Compact）算法</code> 是在标记清除算法的基础之上，做了优化改进的算法。</p><ul><li><strong>标记</strong>：和标记 - 清除算法一样，也是从根节点开始，对对象的引用进行标记</li><li><strong>整理</strong>：并不是简单的直接清理可回收对象，而是<strong>将存活对象都向内存另一端移动</strong>，然后清理边界以外的垃圾，从而<strong>解决了内存碎片化</strong>的问题</li></ul><p>优点：不会产生内存碎片</p><p>缺点：需要移动大量对象，处理<strong>效率比较低</strong></p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/v2-c5ac27ceecebacef2d56cdcbc839cf2c_r.jpg" alt="Java性能优化之JVM GC（垃圾回收机制） - 知乎"></p><h3 id="标记-复制-算法"><a class="anchor" href="#标记-复制-算法">#</a> <mark>标记 - 复制 算法</mark></h3><blockquote><p><strong>大多 JVM 的新生代都使用这个</strong></p></blockquote><p><code>标记-复制（Mark-Copy）算法</code> 的核心就是，<strong>将原有的内存空间划分为大小相等的【FROM 空间】和【TO 空间】，每次分配给新建对象的内存都在【FROM 空间】</strong>。</p><blockquote><p>这里的【FROM 空间】又称【分配空间（Allocation Space）】，【TO 空间】又称【幸存者空间（Survivor Space）】。</p></blockquote><ul><li><strong>标记</strong>：和标记 - 清除算法一样，也是从根节点开始，对【FROM 空间】中的对象引用进行标记</li><li><strong>复制</strong>：在垃圾回收时，<strong>将【FROM 空间】中的存活对象（可达对象）复制到【TO 空间】</strong></li><li><strong>清空</strong>：清空【FROM 空间】的内存</li><li><strong>交换</strong>：交换【FROM 空间】、【TO 空间】的角色，完成垃圾的回收</li></ul><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/20210209144026784.png" alt="在这里插入图片描述"></p><p>应用场景：如果<font color="red">内存中的垃圾对象较多，需要复制的对象（存活对象）就较少</font>，这种情况下适合使用该方式并且效率比较高，反之则不适合。</p><p>算法优点：</p><ul><li><font color="red">不需要构造空闲链表</font>，实现简单，运行速度快</li><li>复制过去以后保证空间的连续性，<font color="red">不会出现内存碎片问题</font></li></ul><p>算法缺点：</p><ul><li>由于总有一块内存区域是空的，主要不足是<strong>只使用了内存的一半</strong>，所以 GC 复制算法的难点在于<font color="red">定义【From 空间】与【To 空间】的比例</font>。</li><li>对于 G1 这种分拆成为大量 region 的 GC，复制而不是移动，意味着 GC 需要维护 region 之间对象引用关系，不管是内存占用或者时间开销都不小</li></ul><p>现在的商业 JVM 都采用这种收集算法<strong>回收堆内存的新生代</strong>，因为新生代的<font color="red"> GC 频繁并且对象的存活率不高</font>，但是并不是划分为大小相等的两块，而是<font color="red">一块较大的 Eden 空间和两块较小的 Survivor 空间（【FROM 空间】和【TO 空间】），比例是 8:1:1</font>。</p><h3 id="小结"><a class="anchor" href="#小结">#</a> 小结</h3><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">标记 - 清除（Mark-Sweep）</th><th style="text-align:center">标记 - 整理（Mark-Compact）</th><th style="text-align:center">标记 - 复制（Mark-Copy）</th></tr></thead><tbody><tr><td style="text-align:center">速度</td><td style="text-align:center">中等</td><td style="text-align:center">最慢</td><td style="text-align:center">最快</td></tr><tr><td style="text-align:center">空间开销</td><td style="text-align:center">少（会产生内存碎片）</td><td style="text-align:center">少（不存在内存碎片）</td><td style="text-align:center">需要占用双倍内存（但不存在内存碎片）</td></tr><tr><td style="text-align:center">移动对象</td><td style="text-align:center">否</td><td style="text-align:center">是</td><td style="text-align:center">是</td></tr></tbody></table><h2 id="3-分代gc"><a class="anchor" href="#3-分代gc">#</a> 3、<mark>分代 GC</mark></h2><blockquote><p>JVM 的垃圾回收机制中并不会只采用某一种 GC 算法，而是结合多种 GC 算法来协同工作。</p></blockquote><h3 id="前置知识"><a class="anchor" href="#前置知识">#</a> 前置知识</h3><h4 id="堆内存是如何分代的"><a class="anchor" href="#堆内存是如何分代的">#</a> 堆内存是如何分代的？</h4><p>介绍内存结构中的堆内存时，<a href="###Java7%E4%B8%AD%E7%9A%84%E5%A0%86%E5%86%85%E5%AD%98%E7%BB%84%E6%88%90%EF%BC%88%E5%88%86%E4%BB%A3%EF%BC%89">Java7 中的堆内存组成（分代）</a>提到<strong> Java7 中堆、方法区分为三份：年轻代、老年代、永久代（方法区）</strong>。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230920165900317.png" alt="image-20230920165900317"></p><p><a href="#Java8%E4%B8%AD%E7%9A%84%E5%A0%86%E5%86%85%E5%AD%98%E7%BB%84%E6%88%90%EF%BC%88%E5%88%86%E4%BB%A3%EF%BC%89">Java8 中的堆内存组成（分代）</a>提到 Java8 中方法区不再和堆内存连续，而是被移到了本地内存中，此时<strong>堆内存分为年轻代、老年代</strong>：</p><blockquote><ul><li>年轻代与老年代的默认比例是 1:2</li><li>而年轻代又分为 Eden、Survivor0（from）、Survivor1（to），默认比例为 8:1:1</li></ul></blockquote><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230921104531387.png" alt="image-20230921104531387"></p><h4 id="不同代的gc算法"><a class="anchor" href="#不同代的gc算法">#</a> 不同代的 GC 算法</h4><p>分代 GC 算法：</p><ul><li><font color="red">年轻代</font>： <code>复制算法</code></li><li><font color="red">老年代</font>： <code>标记-清除</code> 或者 <code>标记-整理</code> 算法</li></ul><h4 id="minor-gc-major-gc和full-gc"><a class="anchor" href="#minor-gc-major-gc和full-gc">#</a> Minor GC、Major GC 和 Full GC</h4><p>这三种 GC 都会触发 STW，暂停其他线程，等垃圾回收结束后，恢复用户线程运行。</p><ul><li><strong>Minor GC</strong>：也称为新生代 GC，是指在<font color="gree">新生代空间（包括 Eden、Survivor0 和 Survivor1 区域）</font>回收内存的过程。<ul><li><font color="red">当 JVM 无法为一个新对象分配空间时（例如当 Eden 区满了），会触发 Minor GC</font></li><li>执行 Minor GC 时，不会影响到老年代、永久代</li><li>但是<font color="red">Minor GC 会引发 STW，暂停其他线程</font>，等垃圾回收结束后，恢复用户线程运行</li><li>因为新生代对象存活时间很短，所以 Minor GC 的发生频率较高，回收速度较快</li></ul></li><li><strong>Major GC</strong>：也称为老年代 GC，是指在<font color="gree">老年代空间</font>回收内存的过程。<ul><li>Major GC 的速度一般会比 Minor GC 慢 10 倍以上</li></ul></li><li><strong>Full GC</strong>：也称为完全 GC，是指清理<font color="gree">整个堆空间（包括年轻代、老年代）</font>的过程。<ul><li>Full GC 的触发条件：<ul><li>调用 System.gc 时，系统建议执行 Full GC，但是不必然执行</li><li><font color="red">老年代空间不足</font><ul><li>通过 Minor GC 后进入老年代的平均大小大于老年代的可用内存</li><li>由 Eden 区、From Space 区向 To Space 区复制时，对象大小大于 To Space 可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小</li></ul></li><li><s>方法区（永久代）空间不足</s></li></ul></li><li>因为老年代对象其存活时间长，所以 Full GC 很少执行，执行速度也会比 Minor GC 慢很多</li><li>Full GC 会停止应用程序的线程，因此可能导致较长的停顿时间</li></ul></li></ul><h3 id="工作机制"><a class="anchor" href="#工作机制">#</a> 工作机制</h3><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230921124136455.png" alt="image-20230921124136455"></p><h4 id="新生代的内存分配策略"><a class="anchor" href="#新生代的内存分配策略">#</a> 新生代的内存分配策略</h4><ul><li><strong>新对象优先在 Eden 分配</strong>：当创建一个对象的时候，对象会被分配在新生代的 Eden 区</li><li>** 当 Eden 区要满时，触发 Minor GC **，引发 <code>STW</code> ，暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行：<ul><li>扫描 Eden 区、from 区，利用 <code>可达性分析算法</code> ，沿着 GC Roots 对象的引用链，<font color="red">标记可达对象（存活对象）</font></li><li>使用 <code>复制算法</code> 将 Eden 区、from 区的存活对象<font color="red">复制</font>到 to 区，并且让存活对象的<font color="red">年龄加 1</font></li><li><font color="red">清空</font> Eden 区、from 区，回收垃圾</li><li><font color="red">交换</font> from 区、to 区的角色【<strong>保证 to 区始终为空</strong>】</li></ul></li></ul><blockquote><ul><li><p>To 区永远为空，From 区是有数据的，每次 Minor GC 后交换这两个区域</p></li><li><p>From 区和 To 区 也可以叫做 S0 区和 S1 区</p></li></ul></blockquote><h4 id="老年代的内存分配策略"><a class="anchor" href="#老年代的内存分配策略">#</a> 老年代的内存分配策略</h4><ul><li><p><strong>长期存活的对象晋升到老年代</strong>：为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中</p><blockquote><p><code>-XX:MaxTenuringThreshold</code> ：定义年龄的阈值，对象的 header 中用 4 个 bit 存储，所以最大值是 15，也是默认值</p></blockquote></li><li><p><strong>大对象直接进入老年代</strong>：需要连续内存空间的对象，最典型的大对象是很长的字符串以及数组；避免在 Eden 和 Survivor 之间的大量复制；经常出现大对象会提前触发 GC 以获取足够的连续空间分配给大对象</p><blockquote><p><code>-XX:PretenureSizeThreshold</code> ：大于此值的对象直接在老年代分配</p></blockquote></li><li><p><strong>动态对象年龄判定</strong>：如果在 Survivor 区中相同年龄的对象的所有大小之和超过 Survivor 空间的一半，年龄大于等于该年龄的对象就可以直接进入老年代</p></li><li><p><strong>当老年代空间不足时，先尝试触发 Minor GC 回收新生代空间，如果仍不足，则触发 Full GC，采用 <code>标记-清除</code> 或者 <code>标记-整理</code> 算法回收老年代垃圾</strong>， <code>STW</code> 的时间更长。</p></li></ul><h3 id="相关-vm-参数"><a class="anchor" href="#相关-vm-参数">#</a> 相关 VM 参数</h3><table><thead><tr><th style="text-align:left">含义</th><th>参数</th></tr></thead><tbody><tr><td style="text-align:left">堆初始大小</td><td>-Xms</td></tr><tr><td style="text-align:left">堆最大大小</td><td>-Xmx 或 -XX:MaxHeapSize=size</td></tr><tr><td style="text-align:left">新生代大小</td><td>-Xmn 或 (-XX:NewSize=size + -XX:MaxNewSize=size)</td></tr><tr><td style="text-align:left">幸存区比例（动态）</td><td>-XX:InitialSurvivorRatio=ratio 和 -XX:+UseAdaptiveSizePolicy</td></tr><tr><td style="text-align:left">幸存区比例</td><td>-XX:SurvivorRatio=ratio</td></tr><tr><td style="text-align:left">晋升阈值</td><td>-XX:MaxTenuringThreshold=threshold</td></tr><tr><td style="text-align:left">晋升详情</td><td>-XX:+PrintTenuringDistribution</td></tr><tr><td style="text-align:left">GC 详情</td><td>-XX:+PrintGCDetails -verbose:gc</td></tr><tr><td style="text-align:left">FullGC 前 MinorGC</td><td>-XX:+ScavengeBeforeFullGC</td></tr></tbody></table><h3 id="gc演示与分析"><a class="anchor" href="#gc演示与分析">#</a> GC 演示与分析</h3><p>在 main 函数为空时运行程序，GC 详细信息如下：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Code_10_GCTest</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> _512KB <span class="token operator">=</span> <span class="token number">512</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> _1MB <span class="token operator">=</span> <span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> _6MB <span class="token operator">=</span> <span class="token number">6</span> <span class="token operator">*</span> <span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> _7MB <span class="token operator">=</span> <span class="token number">7</span> <span class="token operator">*</span> <span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> _8MB <span class="token operator">=</span> <span class="token number">8</span> <span class="token operator">*</span> <span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token comment">// -Xms20m -Xmx20m -Xmn10m -XX:+UseSerialGC -XX:+PrintGCDetails -verbose:gc</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230921125529072.png" alt="image-20230921125529072"></p><p>通过下面的代码，给 list 分配内存，来<font color="red">观察新生代和老年代的情况，什么时候触发 minor gc，什么时候触发 full gc 等情况</font>，使用前需要设置 jvm 参数。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Code_10_GCTest</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> _512KB <span class="token operator">=</span> <span class="token number">512</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> _1MB <span class="token operator">=</span> <span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> _6MB <span class="token operator">=</span> <span class="token number">6</span> <span class="token operator">*</span> <span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> _7MB <span class="token operator">=</span> <span class="token number">7</span> <span class="token operator">*</span> <span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> _8MB <span class="token operator">=</span> <span class="token number">8</span> <span class="token operator">*</span> <span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token comment">// -Xms20m -Xmx20m -Xmn10m -XX:+UseSerialGC -XX:+PrintGCDetails -verbose:gc</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token class-name">List</span><span class="token operator">&lt;</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span>_6MB<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span>_512KB<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span>_6MB<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span>_512KB<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span>_6MB<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="18"></td><td><pre></pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h2 id="4-gc器"><a class="anchor" href="#4-gc器">#</a> 4、GC 器</h2><h3 id="前置知识-2"><a class="anchor" href="#前置知识-2">#</a> 前置知识</h3><h4 id="gc器如何分类"><a class="anchor" href="#gc器如何分类">#</a> GC 器如何分类</h4><ul><li>按<font color="gree">GC 线程数</font>分，可以分为<font color="red">串行</font>垃圾回收器和<font color="red">并行</font>垃圾回收器<ul><li>除了 CMS 和 G1 之外，其它垃圾收集器都是以串行的方式执行</li></ul></li><li>按<font color="gree">工作模式</font>分，可以分为<font color="red">并发式</font>垃圾回收器和<font color="red">独占式</font>垃圾回收器<ul><li>并发式垃圾回收器与应用程序线程交替工作，以尽可能减少应用程序的停顿时间</li><li>独占式垃圾回收器（STW，Stop the world）一旦运行，就停止应用程序中的所有用户线程，直到垃圾回收过程完全结束</li></ul></li></ul><blockquote><p>注意区分并行 GC 器与并发 GC 器：</p><ul><li>并行收集：指多条垃圾收集线程并行工作，但此时用户线程仍处于等待状态。</li><li>并发收集：指用户线程与垃圾收集线程同时工作（不一定是并行的可能会交替执行）。用户程序在继续运行，而垃圾收集程序运行在另一个 CPU 上。</li></ul></blockquote><ul><li>按<font color="gree">碎片处理方式</font>分，可分为<font color="red">压缩式</font>垃圾回收器和<font color="red">非压缩式</font>垃圾回收器<ul><li>压缩式垃圾回收器在回收完成后进行压缩整理，消除回收后的碎片，再分配对象空间使用指针碰撞</li><li>非压缩式的垃圾回收器不进行这步操作，再分配对象空间使用空闲列表</li></ul></li><li>按<font color="gree">工作的内存区间</font>分，又可分为<font color="red">年轻代</font>垃圾回收器和<font color="red">老年代</font>垃圾回收器</li></ul><h4 id="gc性能指标"><a class="anchor" href="#gc性能指标">#</a> GC 性能指标</h4><ul><li><p><strong>吞吐量</strong>：用户程序的运行时间占总运行时间的比例（吞吐量 = 用户程序的运行时间 / (用户程序的运行时间 + GC 的时间)）</p><blockquote><p>例如：虚拟机共运行 100 分钟，垃圾收集器花掉 1 分钟，那么吞吐量就是 99% 。</p></blockquote></li><li><p>垃圾收集开销：吞吐量的补数，垃圾收集所用时间与总运行时间的比例</p></li><li><p>暂停（STW）时间：执行垃圾收集时，程序的工作线程被暂停的时间</p></li><li><p>收集频率：相对于应用程序的执行，收集操作发生的频率</p></li><li><p>内存占用：Java 堆区所占的内存大小</p></li><li><p>快速：一个对象从诞生到被回收所经历的时间</p></li></ul><h4 id="gc器的组合使用关系"><a class="anchor" href="#gc器的组合使用关系">#</a> GC 器的组合使用关系</h4><p>新生代的 GC 器：Serial、ParNew、Parallel Scavenge</p><blockquote><p>新生代采用的 GC 算法：<strong>复制算法</strong></p></blockquote><p>老年代的 GC 器：Serial old、Parallel old、CMS</p><blockquote><p>老年代采用的 GC 算法：<strong>标记 - 整理算法</strong></p></blockquote><p><strong>整堆收集器：G1</strong></p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/68747470733a2f2f7365617a65616e2e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f696d672f4a6176612f4a564d2d2545352539452538332545352539432542452545352539422539452545362539342542362545352539392541382545352538352542332545372542332542422545352539422542452e706e67" alt="img"></p><blockquote><p>红色虚线在 JDK9 移除、绿色虚线在 JDK14 弃用该组合、青色虚线在 JDK14 删除 CMS 垃圾回收器</p></blockquote><p>查看默认的垃圾收回收器：</p><ul><li><code>-XX:+PrintcommandLineFlags</code> ：查看命令行相关参数（包含使用的垃圾收集器）</li><li>使用命令行指令： <code>jinfo -flag 相关垃圾回收器参数 进程ID</code></li></ul><h3 id="串行"><a class="anchor" href="#串行">#</a> 串行</h3><p>特点：</p><ul><li>单线程</li><li>堆内存较少，适合个人电脑</li></ul><p>开启参数： <code>-XX:+UseSerialGC = Serial + SerialOld</code> ，新生代用 Serial GC 且老年代用 Serial old GC。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230921200154073.png" alt="image-20230921200154073"></p><blockquote><p>安全点：让其他线程都在这个点停下来，以免 GC 时移动对象地址，使得其他线程找不到被移动的对象。</p><p>因为是串行的，所以<font color="red">只有一个 GC 线程</font>，且在该线程执行回收工作时，<font color="red">其他线程进入阻塞状态</font>。</p></blockquote><h4 id="serial-收集器"><a class="anchor" href="#serial-收集器">#</a> Serial 收集器</h4><p><strong>Serial</strong>：串行垃圾收集器，作用于<font color="red">新生代</font>，使用<font color="red">单线程</font>进行垃圾回收，采用的 GC 算法是<strong>复制算法</strong>，会导致 STW 。</p><blockquote><p><strong>STW（Stop-The-World）</strong>：垃圾回收时，只有一个线程在工作，并且 Java 应用中的所有其他线程都要暂停，等待垃圾回收的完成。</p></blockquote><h4 id="serial-old-收集器"><a class="anchor" href="#serial-old-收集器">#</a> Serial Old 收集器</h4><p><strong>Serial old</strong>：串行垃圾收集器，作用于<font color="red">老年代</font>，使用<font color="red">单线程</font>进行垃圾回收，采用的 GC 算法是<strong>标记 - 整理算法</strong>，会导致 STW 。</p><ul><li>Serial old 是 Client 模式下默认的老年代的垃圾回收器</li><li>Serial old 在 Server 模式下主要有两个用途：<ul><li>在 JDK 1.5 以及之前版本（Parallel Old 诞生以前）中与 Parallel Scavenge 收集器搭配使用</li><li>作为老年代 CMS 收集器的<strong>后备垃圾回收方案</strong>，在并发收集发生 Concurrent Mode Failure 时使用</li></ul></li></ul><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/68747470733a2f2f7365617a65616e2e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f696d672f4a6176612f4a564d2d53657269616c2545362539342542362545392539422538362545352539392541382e706e67" alt="img"></p><h4 id="优缺点"><a class="anchor" href="#优缺点">#</a> 优缺点</h4><p>优点：<font color="red">简单</font>高效（与其他收集器的单线程比），对于限定单个 CPU 的环境来说，Serial 收集器由于<font color="red">没有线程交互的开销</font>，可以获得最高的单线程收集效率</p><p>缺点：对于交互性较强的应用而言，这种垃圾收集器是不能够接受的，比如 JavaWeb 应用</p><h4 id="parnew-收集器"><a class="anchor" href="#parnew-收集器">#</a> ParNew 收集器</h4><blockquote><p>并行的收集器</p></blockquote><p><strong>ParNew</strong>：Par 是 Parallel <font color="red">并行</font>的缩写，New 是只能处理的是<font color="red">新生代</font>。采用的 GC 算法是<strong>复制算法</strong>，将单线程改为了 **<font color="red">多线程</font>** 进行垃圾回收，可以缩短垃圾回收的时间。</p><blockquote><p>区分并行与并发：并行（Parallelism）、并发（Concurrency）</p></blockquote><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/68747470733a2f2f7365617a65616e2e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f696d672f4a6176612f4a564d2d5061724e65772545362539342542362545392539422538362545352539392541382e706e67" alt="img"></p><p>对于其他的行为（收集算法、stop the world、对象分配规则、回收策略等）同 Serial 收集器一样，应用在年轻代，除 Serial 外，只有<strong> ParNew GC 能与 CMS 收集器配合工作</strong></p><p>ParNew 是很多 JVM 运行在 Server 模式下新生代的默认垃圾收集器</p><ul><li><font color="red">对于新生代，回收次数频繁，使用并行方式高效</font></li><li><font color="red">对于老年代，回收次数少，使用串行方式节省资源</font>（CPU 并行需要切换线程，串行可以省去切换线程的资源）</li></ul><p>相关参数：</p><ul><li><code>-XX:+UseParNewGC</code> ：表示年轻代使用并行收集器，不影响老年代</li><li><code>-XX:ParallelGCThreads</code> ：默认开启和 CPU 数量相同的线程数</li></ul><h3 id="吞吐量优先"><a class="anchor" href="#吞吐量优先">#</a> 吞吐量优先</h3><blockquote><p>并行的收集器</p></blockquote><p>特点：</p><ul><li>多线程</li><li>堆内存较大，多核 cpu</li><li><strong>希望一定时间内的 STW 总时长最短</strong> 0.2 0.2 = 0.4</li></ul><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230921203308852.png" alt="image-20230921203308852"></p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/68747470733a2f2f7365617a65616e2e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f696d672f4a6176612f4a564d2d506172616c6c656c53636176656e67652545362539342542362545392539422538362545352539392541382e706e67" alt="img"></p><h4 id="parallel-scavenge-收集器"><a class="anchor" href="#parallel-scavenge-收集器">#</a> Parallel Scavenge 收集器</h4><p><strong>Parallel Scavenge</strong>：应用于<font color="red">新生代</font>的<font color="red">并行</font>垃圾回收器，GC 算法采用<strong>复制算法</strong>，会导致 <font color="red">STW</font> 。</p><h4 id="parallel-old-收集器"><a class="anchor" href="#parallel-old-收集器">#</a> Parallel Old 收集器</h4><p><strong>Parallel Old</strong>：应用于<font color="red">老年代</font>的<font color="red">并行</font>垃圾回收器，GC 算法采用<strong>标记 - 整理算法</strong>。</p><h4 id="相关-vm-参数-2"><a class="anchor" href="#相关-vm-参数-2">#</a> 相关 VM 参数</h4><p>开启参数：</p><ul><li><p><code>-XX:+UseParallelGC</code> ：指定<font color="red">年轻代</font>使用 Parallel Scavenge 并行收集器</p></li><li><p><code>-XX:+UseParalleOldGC</code> ：指定<font color="red">老年代</font>使用 Parallel Old 收集器</p><blockquote><p>上面两个参数，默认开启一个，另一个也会被开启（<font color="red">互相激活</font>）， JDK8 是<font color="red">默认开启</font>的</p></blockquote></li></ul><p>以下参数都是调整<font color="red">新生代的 Parallel Scavenge 收集器</font>：</p><ul><li><code>-XX:+UseAdaptiveSizePolicy</code> ：设置<strong>自适应调节策略</strong>。自动调整以下参数：<ul><li>新生代的大小</li><li>Eden 和 Survivor 的比例</li><li>新生代的对象晋升老年代的年龄阈值</li></ul></li><li><code>-XX:ParallelGCThreads=n</code> ：设置收集器的<font color="red">线程数</font>，一般与 CPU 数量相等，以避免过多的线程数影响垃圾收集性能<ul><li>在默认情况下，当 CPU 数量小于 8 个，ParallelGCThreads 的值等于 CPU 数量</li><li>当 CPU 数量大于 8 个，ParallelGCThreads 的值等于 3+[5*CPU Count]/8]</li></ul></li><li><code>-XX:MaxGCPauseMillis=ms</code> ：设置垃圾收集器的 **<font color="red">最大停顿时间（即 STW 的时间）</font>**，单位是毫秒，默认是 200ms<ul><li>对于用户来讲，停顿时间越短体验越好；在服务器端，注重高并发，整体的吞吐量</li><li>为了把停顿时间控制在 MaxGCPauseMillis 以内，收集器在工作时<font color="red">会调整 Java 堆大小</font>或其他一些参数</li></ul></li><li><code>-XX:GCTimeRatio=ratio</code> ：设置 **<font color="red">吞吐量的大小</font>**，计算公式是 1/(1+radio)，ratio 越大，计算结果越小，GC 时间的目标占比越小，吞吐量的目标越大。<ul><li>ratio 的取值范围（0，100），默认是 99，也就是垃圾回收时间不超过 1</li><li><strong>与 <code>-XX:MaxGCPauseMillis</code> 参数有一定矛盾性</strong>，暂停时间越长，Radio 参数就容易超过设定的比例</li></ul></li></ul><h4 id="小结-2"><a class="anchor" href="#小结-2">#</a> 小结</h4><p>对比其他回收器：</p><ul><li>其它收集器目标是尽可能缩短 GC 时用户线程的停顿时间</li><li>Parallel 目标是达到一个可控制的吞吐量，被称为<strong>吞吐量优先</strong>收集器</li><li>Parallel Scavenge 对比 ParNew 拥有<strong>自适应调节策略</strong></li></ul><p>应用场景：</p><ul><li>停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验</li><li>高吞吐量可以高效率地利用 CPU 时间，尽快完成程序的运算任务，适合在后台运算而不需要太多交互</li></ul><p>暂停时间和吞吐量的关系：新生代空间变小 → 缩短暂停时间 → 垃圾回收变得频繁 → 导致吞吐量下降</p><p>在注重吞吐量及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge + Parallel Old 收集器，在 Server 模式下的内存回收性能很好，<strong>Java8 默认是此垃圾收集器组合</strong></p><h3 id="停顿时间优先低延时"><a class="anchor" href="#停顿时间优先低延时">#</a> 停顿时间优先（低延时）</h3><p>特点：</p><ul><li>多线程</li><li>堆内存较大，多核 cpu</li><li><strong>希望 STW 的单次时间最短</strong> 0.1 0.1 0.1 0.1 0.1 = 0.5</li></ul><h4 id="cms-收集器"><a class="anchor" href="#cms-收集器">#</a> CMS 收集器</h4><blockquote><p>并发的收集器</p></blockquote><h5 id="cms-特点"><a class="anchor" href="#cms-特点">#</a> CMS 特点</h5><p><strong>CMS(Concurrent Mark Sweep)</strong>：是一款<strong>并发的</strong>、使用<strong>标记 - 清除</strong>算法、针对<font color="red">老年代</font>的垃圾回收器，其最大特点是<strong>让垃圾收集线程与用户线程同时工作</strong>，但可能产生<strong>内存碎片</strong>。</p><p>CMS 收集器的关注点是<font color="red">尽可能缩短 GC 时用户线程的停顿时间</font>，停顿时间越短（<strong>低延迟</strong>）越适合与用户交互的程序，良好的响应速度能提升用户体验。</p><h5 id="cms-工作过程"><a class="anchor" href="#cms-工作过程">#</a> CMS 工作过程</h5><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230922152445957.png" alt="image-20230922152445957"></p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/68747470733a2f2f7365617a65616e2e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f696d672f4a6176612f4a564d2d434d532545362539342542362545392539422538362545352539392541382e706e67" alt="img"></p><p>分为以下四个流程：</p><ul><li><p><font color="cornflowerblue">初始标记</font>：使用 <font color="gree">STW</font> 出现短暂停顿，<font color="red">仅标记 GC Roots 直接关联的对象</font>，速度很快</p></li><li><p><font color="cornflowerblue">并发标记</font>：从 GC Roots 对象出发<font color="red">沿着引用链遍历整个对象图，找出所有可达对象（存活对象）</font>，在整个回收过程中<font color="red">耗时最长</font>，不需要 STW，可以与用户线程<font color="gree">并发</font>运行</p></li><li><p><font color="cornflowerblue">重新标记</font>：扫描 **<font color="red">整个堆内存上</font>** 的对象，修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象，比初始标记时间长，但远比并发标记时间短，需要 <font color="gree">STW</font></p><blockquote><p>采用<strong>写屏障（pre-write barrier）<strong>技术，在对象引用改变前，将对象加入到</strong> satb_mark_queue</strong> 中，将来可以对此重新标记。</p></blockquote></li><li><p><font color="cornflowerblue">并发清除</font>：清除可以回收的垃圾对象，<strong>不需要移动存活对象</strong>，因此会造成<strong>内存碎片</strong>。可以与用户线程同时<font color="gree">并发</font>执行，因此仍然<font color="red">可能产生新的垃圾</font>，即 **<font color="red">浮动垃圾</font>**（本轮 GC 本应该回收，但是没有回收到的内存）。</p><blockquote><ul><li>不采用标记 - 整理算法的原因：标记 - 整理算法会整理内存，导致用户线程使用的<strong>对象地址改变</strong>，影响用户线程继续执行。</li><li>当用户需要存入一个大对象，而新生代空间不足时，<strong><font color="red">老年代由于浮动垃圾过多，就会退化为 serial Old 收集器</font></strong>，将老年代垃圾进行<strong>标记 - 整理</strong>，当然这也是<strong>很耗费时间</strong>的！</li></ul></blockquote></li></ul><h5 id="相关-vm-参数-3"><a class="anchor" href="#相关-vm-参数-3">#</a> 相关 VM 参数</h5><ul><li><p><code>-XX：+UseConcMarkSweepGC</code> ：指定<font color="red">老年代</font>使用 CMS 收集器执行内存回收任务</p><blockquote><p>开启该参数后会自动将 <code>-XX:+UseParNewGC</code> 打开，即<font color="red">新生代</font>使用的 ParNew 收集器，是<font color="red">并行</font>的，采用<font color="red">复制算法</font>。即<strong> ParNew + CMS + Serial old</strong> 的组合</p></blockquote></li><li><p><code>-XX:ParallelGCThreads</code> ：设置<font color="gree">并行</font>时的 GC 线程数，一般与 CPU 核数保持一致</p></li><li><p><code>-XX:ConcGCThreads</code> ：设置<font color="gree">并发</font>时的 GC 线程数，一般设为 CPU 核数的 1/4。即 3/4 作用户线程，1/4 作 GC 线程，可见 CMS 收集器对 CPU 的占用率并不高，但是对吞吐量是有影响的。</p></li><li><p><code>-XX:CMSInitiatingOccupancyFraction=percent</code> ：设置<strong>老年代在堆内存中的初始占用率，代表触发老年代 GC 的阈值</strong>，一旦达到该阈值，便开始采用 CMS 收集器进行垃圾回收</p><ul><li>JDK5 及以前版本的默认值为 68，即当老年代的空间使用率达到 68% 时，会执行一次 CMS 回收</li><li>JDK6 及以上版本默认值为 92%</li></ul></li><li><p><code>-XX:+CMSScavengeBeforeRemark</code> ：<font color="red">在重新标记阶段前，对新生代进行一次 GC（ParNew 收集器）</font>，以减轻重新标记所做的无用功。</p></li><li><p><code>-XX:+UseCMSCompactAtFullCollection</code> ：用于指定<font color="red">在执行完 Full GC 后对内存空间进行压缩整理</font>，以此避免内存碎片的产生，由于内存压缩整理过程<font color="red">无法并发执行</font>，所带来的问题就是<font color="red"> STW 时间变得更长</font></p></li><li><p><code>-XX:CMSFullGCsBeforeCompaction</code> ：<strong>设置在执行多少次 Full GC 后对内存空间进行压缩整理</strong></p></li></ul><h5 id="cms-优缺点"><a class="anchor" href="#cms-优缺点">#</a> CMS 优缺点</h5><p>优点：</p><ul><li><font color="gree">并发</font>收集</li><li>低延迟</li></ul><p>缺点：</p><ul><li><p><strong>吞吐量降低</strong>：在并发阶段虽然不会导致用户停顿，但是会因为占用了一部分线程而导致应用程序变慢，CPU 利用率不够高</p></li><li><p><strong>无法处理浮动垃圾</strong>，可能出现 Concurrent Mode Failure 导致另一次 Full GC 的产生</p><blockquote><p><strong>浮动垃圾</strong>：并发清除阶段由于用户线程继续运行而产生的垃圾（产生了新对象），这部分垃圾只能到下一次 GC 时才能进行回收。</p><p>由于浮动垃圾的存在，CMS 收集需要预留出一部分内存，不能等待老年代快满的时候再回收。如果预留的内存不够存放浮动垃圾，就会<strong>出现 Concurrent Mode Failure，这时 CMS 收集器将退化为 Serial Old 收集器，导致很长的停顿时间</strong>。</p></blockquote></li><li><p><strong>内存碎片</strong>：往往导致<font color="red">老年代</font>空间无法找到一块足够大的连续空间来分配当前对象，不得不提前<font color="red">触发一次 Full GC</font>。为新对象分配内存空间时，将无法使用指针碰撞（Bump the Pointer）技术，而只能够选择<font color="red">空闲列表（Free List）</font>执行内存分配。</p></li></ul><h4 id="g1-收集器"><a class="anchor" href="#g1-收集器">#</a> <mark>G1</mark> 收集器</h4><blockquote><p>Garbage-First，一种 ** 基于区域（region）** 的垃圾回收器，用于代替 CMS，JDK9 开始成为默认的 GC 器</p></blockquote><h5 id="g1-特点"><a class="anchor" href="#g1-特点">#</a> G1 特点</h5><p>G1 是一款<strong>应用于新生代和老年代</strong>的垃圾收集器，整体采用<strong>标记 - 整理算法</strong>，区域之间采用<strong>复制算法</strong>、软实时、低延迟、** 可设定目标（最大 STW 停顿时间，默认 200ms）** 的垃圾回收器，用于<font color="red">代替 CMS</font>，适用于<font color="red">超大堆内存</font>（&gt;4 ~ 6G），会将堆内存划分为多个大小相等的区域。</p><p>G1 的优点：</p><ul><li><p><strong>并行、并发</strong>：</p><ul><li>并行性：G1 在回收期间，可以有多个 GC 线程同时工作，有效利用多核计算能力，此时用户线程 <font color="gree">STW</font></li><li>并发性：G1 拥有与应用程序交替执行的能力，部分工作可以和应用程序同时<font color="gree">并发</font>执行，因此不会在整个回收阶段发生完全阻塞应用程序的情况</li><li>其他的垃圾收集器使用 <code>内置的 JVM 线程</code> 执行 GC 的多线程操作，而 G1 收集器可以采用应用线程承担后台运行的 GC 工作。JVM 的 GC 线程处理速度慢时，系统会<strong>调用 <code>应用程序线程</code> 加速垃圾回收</strong>过程</li></ul></li><li><p><strong>分区算法</strong>：</p><ul><li><p>从分代上看，G1 属于分代型垃圾回收器，区分年轻代和老年代，年轻代依然有 Eden 区和 Survivor 区。从堆结构上看，<strong>新生代和老年代不再物理隔离</strong>，不用担心每个代内存是否足够，这种特性有利于程序长时间运行，<font color="red">分配大对象时不会因为无法找到连续内存空间而提前触发下一次 GC</font></p></li><li><p><strong>将整个堆划分成约 2048 个大小相同的独立 Region 块，每个 Region 块可以单独进行 GC</strong>，每个 Region 块大小根据堆空间的实际大小而定，整体被控制在 1MB 到 32 MB 之间且为 2 的 N 次幂，所有 Region 大小相同，在 JVM 生命周期内不会被改变。</p></li><li><p><strong>新的区域 Humongous</strong>：<font color="red">本身属于老年代</font>，当出现了一个<font color="red">巨型对象</font>超出了分区容量的一半，该对象就会进入到该区域。如果一个 H 区装不下一个巨型对象，那么 G1 会寻找连续的 H 分区来存储，为了能找到连续的 H 区，有时候不得不启动 Full GC</p></li><li><p><strong>G1 不会对巨型对象进行拷贝，回收时被优先考虑</strong>。G1 会跟踪老年代所有 incoming 引用，这样老年代 incoming 引用为 0 的巨型对象就可以在新生代垃圾回收时处理掉</p></li><li><p><strong>Region 结构图</strong>：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/68747470733a2f2f7365617a65616e2e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f696d672f4a6176612f4a564d2d47312d526567696f6e2545352538432542412545352539462539462e706e67" alt="img"></p></li></ul></li><li><p><strong>空间整合策略</strong>：</p><ul><li>CMS：标记 - 清除算法、内存碎片、若干次 GC 后进行一次碎片整理</li><li>G1：整体来看是<strong>标记 - 整理算法</strong>的收集器，从局部（Region 之间）上来看是基于<strong>复制算法</strong>实现的，两种算法都可以<font color="red">避免内存碎片</font></li></ul></li><li><p><strong>可预测的停顿时间模型（软实时 soft real-time）</strong>：可以指定在 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒</p><ul><li><p>由于分块的原因，<font color="red">G1 可以只选取部分区域进行内存回收</font>，这样缩小了回收的范围，对于全局停顿情况也能得到较好的控制</p></li><li><p>G1 跟踪各个 Region 里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间，通过过去回收的经验获得），在后台维护一个<strong>优先列表</strong>，每次根据允许的收集时间优先回收价值最大的 Region，保证了 G1 收集器在有限的时间内可以获取尽可能高的收集效率</p></li><li><p>相比于 CMS GC，<font color="red">G1 未必能做到 CMS 在最好情况下的延时停顿，但是最差情况要好很多</font></p></li></ul></li></ul><p>G1 的缺点：</p><ul><li>相较于 CMS，G1 还不具备全方位、压倒性优势。比如<font color="red">在用户程序运行过程中，G1 无论是为了垃圾收集产生的内存占用，还是程序运行时的额外执行负载，都要比 CMS 要高</font></li><li>从经验上来说，<font color="red">在小内存应用上 CMS 的表现大概率会优于 G1，而 G1 在大内存应用上则发挥其优势</font>，平衡点在 6-8GB 之间</li></ul><p>应用场景：</p><ul><li>面向服务端应用，针对具有大内存、多处理器的机器</li><li>需要低 GC 延迟，并具有大堆的应用程序提供解决方案</li></ul><h5 id="记忆集rset"><a class="anchor" href="#记忆集rset">#</a> 记忆集（Rset）</h5><p><code>记忆集 Rset（Remembered Set）</code> 在 **<font color="red">新生代</font>** 中，<font color="red">每个 Region 都有</font>一个 Remembered Set，用来<font color="red">记录自身被哪些 Region 中的对象引用</font>（谁引用了我就记录谁）。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/68747470733a2f2f7365617a65616e2e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f696d672f4a6176612f4a55432d4731e8aeb0e5bf86e99b862e706e67" alt="img"></p><ul><li>程序对 Reference 类型数据写操作时，产生一个 Write Barrier 暂时中断操作，检查该对象和 Reference 类型数据是否在不同的 Region（跨代引用），不同就将相关引用信息记录到 Reference 类型所属的 Region 的 Remembered Set 之中</li><li>进行内存回收时，在 GC 根节点的枚举范围中加入 Remembered Set 即可保证不对全堆扫描也不会有遗漏</li></ul><p>垃圾收集器在新生代中建立了记忆集这样的数据结构，<font color="red">可以将 Rset 理解为一个抽象类，具体有三种实现方式</font>：</p><ul><li><font color="cornflowerblue">字长精度</font></li><li><font color="cornflowerblue">对象精度</font></li><li><strong><font color="cornflowerblue">卡精度 (卡表)</font></strong></li></ul><h5 id="卡表card-table"><a class="anchor" href="#卡表card-table">#</a> 卡表（Card Table）</h5><p><code>卡表（Card Table）</code> 在 **<font color="red">老年代</font><strong>中，是一种对记忆集的具体实现，主要<font color="red">定义了记忆集的记录精度、与堆内存的映射关系等</font>，卡表中的<font color="red">每一个元素都对应着一块特定大小的内存块，这个内存块称之为 <code>卡页（card page）</code> </font>。当存在</strong>跨代引用（老年代对象引用新生代对象）** 时，会将卡页标记为 <strong><font color="red">dirty</font></strong>，JVM 对于卡页的维护也是通过写屏障（post</p><p>-write barrier + dirty card queue）的方式</p><p><code>收集集合 CSet</code> 代表每次 GC 暂停时回收的一系列目标分区，在任意一次收集暂停中，CSet 所有分区都会被释放，内部存活的对象都会被转移到分配的空闲分区中。年轻代收集 CSet 只容纳年轻代分区，而混合收集会通过启发式算法，在老年代候选回收分区中，筛选出回收收益最高的分区添加到 CSet 中</p><ul><li>CSet of Young Collection</li><li>CSet of Mix Collection</li></ul><h5 id="g1-工作过程"><a class="anchor" href="#g1-工作过程">#</a> G1 工作过程</h5><h6 id="概述"><a class="anchor" href="#概述">#</a> 概述</h6><p>G1 中提供了三种垃圾回收模式：Young GC、Mixed GC 和 Full GC，在不同的条件下被触发</p><ul><li>当堆内存的使用比例达到预设的阈值（默认 45%，可以通过 <code>-XX:InitiatingHeapOccupancyPercent</code> 设置）时，开始在整个堆上进行并发标记</li><li>标记完成马上开始 Mixed GC</li></ul><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230923000741533.png" alt="image-20230923000741533"></p><p>垃圾回收顺序（顺时针）：Young GC → Young GC + 并发标记 → Mixed GC</p><h6 id="young-gc"><a class="anchor" href="#young-gc">#</a> Young GC</h6><blockquote><p>发生在<font color="red">年轻代</font>的 GC 算法。</p></blockquote><p>一般对象（除了巨型对象）都是<font color="red">在 eden region 中分配内存</font></p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230923002237743.png" alt="image-20230923002237743" style="zoom:67%"><p><strong><font color="red">当所有 eden region 被耗尽无法申请内存时，就会触发一次 Young GC</font></strong>，<font color="gree">引发 STW </font>，把活跃对象通过<font color="red">复制算法</font>放入 survivor 区</p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230923002252284.png" alt="image-20230923002252284" style="zoom:67%"><p><strong><font color="red">当 Survivor region 的空间紧张时，又会触发一次 Young GC</font></strong>，通过复制算法移动到其他 Survivor region 中。<font color="red">当活跃对象的年龄达到阈值时，晋升到老年代</font>。</p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230923002306276.png" alt="image-20230923002306276" style="zoom:67%"><p><strong><font color="red">Young GC 的具体过程</font></strong>：</p><ol><li><p>扫描根：根引用连同 RSet 记录的外部引用作为扫描存活对象的入口</p></li><li><p>更新 RSet：处理 dirty card queue 更新 RSet，此后 RSet 准确的反映对象的引用关系</p><ul><li>dirty card queue：类似缓存，产生了引用先记录在这里，然后更新到 RSet</li><li>作用：产生引用直接更新 RSet 需要线程同步开销很大，使用队列性能好</li></ul></li><li><p>处理 RSet：识别被老年代对象指向的 Eden 中的对象，这些被指向的对象被认为是存活的对象，把需要回收的分区放入 Young CSet 中进行回收</p><blockquote><p>Young GC 的跨代引用问题：即老年代对象引用新生代对象。</p><p><code>卡表（Card Table）</code> ：使用在 **<font color="red">老年代</font><strong>中，是一种对记忆集 Rset 的具体实现，卡表中的<font color="red">每一个元素都对应着一块特定大小的内存块，称为 <code>卡页（card page）</code> </font>。当存在跨代引用时，会将卡页标记为 <strong>dirty</strong>，即</strong>脏卡 **。</p><p><code>记忆集（Rset）</code> 存在于 **<font color="red">新生代</font>** 中，用于<font color="red">记录自身被哪些 Region 中的对象引用</font>，因此<font color="red">可用于记录新生代对象对应的脏卡</font>。</p><p>好处：将来进行 GC Roots 对象遍历时，不需要扫描整个老年代（卡表），只需要关注标记为 dirty 的卡页即可，缩小了搜索范围。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230924102519002.png" alt="image-20230924102519002"></p></blockquote></li><li><p><font color="red">复制对象</font>：</p><ul><li>Eden 区内存段中存活的对象会被复制到 survivor 区</li><li>survivor 区内存段中存活的对象如果年龄未达阈值，年龄会加 1</li><li>survivor 区内达到阈值的存活对象会被复制到 old 区中空的内存分段</li><li>如果 survivor 空间不够，Eden 空间的部分数据会直接晋升到老年代空间</li></ul></li><li><p>处理引用：处理 Soft，Weak，Phantom，JNI Weak 等引用，最终 Eden 空间的数据为空，GC 停止工作</p></li></ol><h6 id="concurrent-mark"><a class="anchor" href="#concurrent-mark">#</a> Concurrent Mark</h6><blockquote><p>并发标记，触发条件：堆空间的使用比例达到预设阈值（InitiatingHeapOccupancyPercent，默认 45%）时</p></blockquote><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/68747470733a2f2f7365617a65616e2e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f696d672f4a6176612f4a564d2d47312545362539342542362545392539422538362545352539392541382e6a7067" alt="img"></p><ul><li><font color="cornflowerblue">初始标记</font>：在<font color="red"> Young GC 时</font>会标记从根节点<font color="red">直接可达的对象</font>，这个阶段是 <font color="gree">STW</font> 的，并不占用并发标记的时间。</li><li><font color="cornflowerblue">并发标记</font>：<strong><font color="red">当<u>堆空间的使用比例</u>达到预设阈值（InitiatingHeapOccupancyPercent，默认 45%）时，会在<u>整个堆</u>中进行并发标记（<font color="gree">不会 STW</font>）</font></strong>，可能被 Young GC 中断。此过程会计算每个区域的存活对象比例，若区域中的所有对象都是垃圾，则这个区域会被立即回收（<strong>实时回收</strong>），为浮动垃圾准备出更多的空间，把需要收集的 Region 放入 CSet 当中。</li><li><font color="cornflowerblue">最终标记</font>：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要<font color="red">把 Remembered Set Logs 的数据合并到 Remembered Set 中，这阶段需要停顿线程（<font color="gree">STW</font>），但是可并行执行</font>（<strong>防止漏标</strong>）</li><li><font color="cornflowerblue">筛选回收</font>：并发清理阶段，首先对 CSet 中各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划，也需要 <font color="gree">STW</font></li></ul><h6 id="mixed-gc"><a class="anchor" href="#mixed-gc">#</a> Mixed GC</h6><p>当很多对象晋升到老年代时，为了避免堆内存被耗尽，虚拟机会触发一个混合的垃圾收集器，即 Mixed GC，<strong><font color="red">除了回收整个 young region，还会回收一部分回收价值高的 old region，过程同 Young GC</font></strong>。</p><blockquote><p>注意：<font color="red">是一部分老年代（回收价值高的），而不是全部老年代</font>，因为指定了最大停顿时间（ <code>-XX:MaxGCPauseMillis</code> ），如果对所有老年代都进行回收，耗时可能过高。为了保证时间不超过设定的停顿时间，Mixed GC 仅回收最有价值的老年代（回收后，能够得到更多内存）。</p></blockquote><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230923193042183.png" alt="image-20230923193042183"></p><h6 id="full-gc"><a class="anchor" href="#full-gc">#</a> Full GC</h6><p><strong><font color="red">当对象内存分配速度过快，Mixed GC 来不及回收，导致老年代被填满时，就会触发一次 Full GC</font></strong>。G1 的 Full GC 算法就是<font color="red">多线程</font>执行的垃圾回收，会导致异常<font color="gree">长时间的暂停（STW）时间</font>，需要进行不断的调优，尽可能的避免 Full GC 。</p><p>产生 Full GC 的原因：</p><ul><li><font color="red">新生代晋升时没有足够的老年代空间</font></li><li><font color="red">并发处理过程中产生浮动垃圾</font>，导致空间耗尽</li></ul><h5 id="相关-vm-参数-4"><a class="anchor" href="#相关-vm-参数-4">#</a> 相关 VM 参数</h5><ul><li><code>-XX:+UseG1GC</code> ：使用 G1 垃圾收集器执行内存回收任务</li><li><code>-XX:G1HeapRegionSize</code> ：设置每个 Region 的大小。取值是 2 的幂，范围是 1MB 到 32MB 之间，目标是根据最小的 Java 堆大小划分出约 2048 个区域，默认是堆内存的 1/2000</li><li><code>-XX:MaxGCPauseMillis</code> ：设置<font color="red">期望的最长 GC 停顿时间</font>指标，JVM 会尽力实现，但不保证达到，默认值是 200ms</li><li><code>-XX:+ParallelGcThread</code> ：设置 STW 时 GC 线程数的值，最多设置为 8</li><li><code>-XX:ConcGCThreads</code> ：设置并发标记线程数，设置为并行垃圾回收线程数 ParallelGcThreads 的 1/4 左右</li><li><code>-XX:InitiatingHeapoccupancyPercent</code> ：设置触发并发 Mixed GC 周期的 Java 堆占用率阈值，超过此值，就触发 GC，默认值是 45</li><li><code>-XX:+ClassUnloadingWithConcurrentMark</code> ：并发标记类卸载，默认启用，所有对象都经过并发标记后，就可以知道哪些类不再被使用，当一个类加载器的所有类都不再使用，则卸载它所加载的所有类</li><li><code>-XX:G1NewSizePercent</code> ：新生代占用整个堆内存的最小百分比（默认 5％）</li><li><code>-XX:G1MaxNewSizePercent</code> ：新生代占用整个堆内存的最大百分比（默认 60％）</li><li><code>-XX:G1ReservePercent=10</code> ：保留内存区域，防止 to space（Survivor 中的 to 区）溢出</li></ul><h5 id="g1-优化"><a class="anchor" href="#g1-优化">#</a> G1 优化</h5><h6 id="字符串去重"><a class="anchor" href="#字符串去重">#</a> 字符串去重</h6><blockquote><p>JDK 8u20</p></blockquote><p>问题：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">String</span> s1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// char[]&#123;'h','e','l','l','o'&#125;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name">String</span> s2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// char[]&#123;'h','e','l','l','o'&#125;</span></pre></td></tr></table></figure><p>过程：</p><ul><li>将所有新分配的字符串放入一个队列</li><li>当新生代回收时，G1 并发检查是否有重复的字符串</li><li><strong>如果字符串的值一样，就让它们引用同一个字符串对象</strong></li><li>注意，其与 <code>String.intern()</code> 的区别<ul><li>String.intern () 关注的是字符串对象（引用地址）</li><li>字符串去重关注的是 char []</li><li>在 JVM 内部，使用了不同的字符串表</li></ul></li></ul><p>优点：节省了大量内存</p><p>缺点：新生代回收时间略微增加，导致略微多占用 CPU</p><p>VM 参数： <code>-XX:+UseStringDeduplication</code> ，默认开启</p><h6 id="并发标记时的类卸载"><a class="anchor" href="#并发标记时的类卸载">#</a> 并发标记时的类卸载</h6><blockquote><p>JDK 8u40</p></blockquote><p>在并发标记结束后，就能知道哪些类不再被使用。如果一个类加载器的所有类都不再使用，则卸载它所加载的所有类。</p><p>VM 参数： <code>-XX:+ClassUnloadingWithConcurrentMark</code> ，默认开启</p><h6 id="回收巨型对象"><a class="anchor" href="#回收巨型对象">#</a> 回收巨型对象</h6><blockquote><p>JDK 8u60</p></blockquote><ul><li>一个对象大于 region 的一半时，就称为巨型对象</li><li>G1 不会对巨型对象进行拷贝</li><li>回收时，巨型对象被优先考虑</li><li>G1 会跟踪老年代所有 incoming 引用，这样老年代 incoming 引用为 0 的巨型对象就可以在新生代垃圾回收时处理掉</li></ul><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/20210210165555732.png" alt="在这里插入图片描述"></p><h6 id="并发标记的起始时间的调整"><a class="anchor" href="#并发标记的起始时间的调整">#</a> 并发标记的起始时间的调整</h6><ul><li>并发标记的触发条件：当堆内存的使用比例达到<font color="red">预设阈值（默认 45%）</font>时，开始在整个堆上进行并发标记</li><li>并发标记必须在堆空间占满前完成，否则会退化为 Full GC</li><li>JDK 9 之前：通过 <code>-XX:InitiatingHeapOccupancyPercent</code> 设置阈值</li><li>JDK 9 ：<strong>可以动态调整阈值</strong>，<ul><li><code>-XX:InitiatingHeapOccupancyPercent</code> 用来设置阈值的初始值</li><li>GC 时进行对数据采样，并动态调整阈值</li><li>总是会添加一个安全的空挡空间，以容纳浮动垃圾，尽可能避免老年代被填满而导致 Full GC</li></ul></li></ul><h5 id="g1-调优"><a class="anchor" href="#g1-调优">#</a> G1 调优</h5><p>G1 的设计原则就是简化 JVM 性能调优，只需要简单的三步即可完成调优：</p><ol><li>开启 G1 垃圾收集器</li><li><strong>设置堆的最大内存</strong></li><li><strong>设置最大的停顿时间（STW）</strong></li></ol><p><font color="red">不断调优停顿时间指标</font>：</p><ul><li><code>XX:MaxGCPauseMillis=x</code> 可以设置启动应用程序暂停的时间，G1 会根据这个参数选择 CSet 来满足响应时间的设置</li><li>设置到 100ms 或者 200ms 都可以（不同情况下会不一样），但设置成 50ms 就不太合理</li><li>暂停时间设置的太短，就会导致出现 G1 跟不上垃圾产生的速度，最终退化成 Full GC</li><li>对这个参数的调优是一个持续的过程，逐步调整到最佳状态</li></ul><p><font color="red">不要显示地设置新生代和老年代的大小</font>：</p><ul><li>避免使用 <code>-Xmn</code> 或 <code>-XX:NewRatio</code> 等相关选项显式设置年轻代大小，G1 收集器在运行的时候会调整新生代和老年代的大小，从而达到我们为收集器设置的暂停时间目标</li><li>设置了新生代大小相当于放弃了 G1 的自动调优，我们只需要设置整个堆内存的大小，剩下的交给 G1 自己去分配各个代的大小</li></ul><h4 id="zgc-收集器"><a class="anchor" href="#zgc-收集器">#</a> ZGC 收集器</h4><blockquote><p>在 JDK11 中引入，追求低延时，希望停顿时间不会超过 10ms</p></blockquote><h5 id="zgc-特点"><a class="anchor" href="#zgc-特点">#</a> ZGC 特点</h5><p>ZGC 收集器是一款<strong>追求低延时</strong>的垃圾收集器，<strong>基于 Region 的内存布局</strong>，<strong>暂时不设分代</strong>，使用了<strong>读屏障</strong>、<strong>染色指针</strong>和<strong>内存多重映射</strong>等技术来实现 **<font color="orange">可并发的标记 - 整理算法</font>**。</p><h5 id="基于-region-的内存布局"><a class="anchor" href="#基于-region-的内存布局">#</a> 基于 Region 的内存布局</h5><p>和 G1 一样，ZGC 也采取基于 Region 的堆内存布局，但与他们不同的是，<strong>ZGC 的 Region 具有动态性（动态的创建、销毁，以及动态的区域容量大小）</strong>，可以分为三类：</p><ul><li><font color="cornflowerblue">小型 Region</font>：容量固定为 2MB，用于放置小于 256KB 的小对象。</li><li><font color="cornflowerblue">中型 Region</font>：容量固定为 32MB，用于放置大于等于 256KB 但小于 4MB 的对象。</li><li><font color="cornflowerblue">大型 Region</font>：<font color="red">容量可以动态变化</font>，但必须为 2MB 的整数倍，用于存放 4MB 或以上的大对象。并且每个大型 Region<font color="red">只存放一个对象</font>。</li></ul><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/20200620112717942.png" alt="在这里插入图片描述"></p><h5 id="可并发的标记-整理算法"><a class="anchor" href="#可并发的标记-整理算法">#</a> 可并发的标记 - 整理算法</h5><p>ZGC 使用了读屏障、染色指针和内存多重映射等技术来实现 **<font color="orange">可并发的标记 - 整理算法</font>**。</p><ul><li><p>在 CMS 和 G1 中都用到了写屏障，而 ZGC 用到了<strong>读屏障</strong></p></li><li><p><strong>染色指针</strong>：直接将少量的标记信息存储在引用对象的指针上，从 64 位的指针中拿高 4 位来标识对象此时的状态</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/20200620144003255.png" alt="染色指针示意图"></p><ul><li>染色指针可以使某个 Region 的存活对象被移走之后，这个 Region 能被<font color="red">立即释放和重用</font></li><li>可以直接从指针中看到引用对象的三色标记状态（Marked0、Marked1）、是否进入了重分配集、是否被移动过（Remapped）、是否只能通过 finalize () 方法才能被访问到（Finalizable）</li><li>可以大幅减少在垃圾收集过程中内存屏障的使用数量，写屏障的目的通常是为了记录对象引用的变动情况，如果将这些信息直接维护在指针中，显然就可以省去一些专门的记录操作</li><li>可以作为一种可扩展的存储结构用来记录更多与对象标记、重定位过程相关的数据</li></ul></li><li><p><strong>内存多重映射</strong>：多个虚拟地址指向同一个物理地址</p></li></ul><p><strong><font color="orange">可并发的标记 - 整理算法</font></strong>：染色指针标识对象是否被标记或移动，读屏障保证在每次应用程序或 GC 程序访问对象时先根据染色指针的标识判断是否被移动，如果被移动就根据转发表访问新的移动对象，<strong><font color="red">并更新引用</font></strong>，不会像 G1 一样必须等待垃圾回收完成才能访问。</p><h5 id="zgc-目标"><a class="anchor" href="#zgc-目标">#</a> ZGC 目标</h5><ul><li><strong>停顿时间不会超过 10ms</strong></li><li>停顿时间不会随着堆的增大而增大（不管多大的堆都能保持在 10ms 以下）</li><li>可支持几百 M，甚至几 T 的堆大小（最大支持 4T）</li></ul><h5 id="zgc-工作过程"><a class="anchor" href="#zgc-工作过程">#</a> ZGC 工作过程</h5><p>ZGC 的运作过程大致可划分为以下四个大的阶段，每阶段都是<strong>可以并发执行</strong>的，仅是两个阶段中间会存在<font color="gree">短暂的停顿小阶段</font>。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/20200620161451497.png" alt="ZGC运行过程"></p><ul><li>并发标记（Concurrent Mark）： 遍历对象图做可达性分析的阶段，也要经过初始标记和最终标记，需要短暂停顿</li><li>并发预备重分配（Concurrent Prepare for Relocate）：根据特定的查询条件统计得出本次收集过程要清理哪些 Region，将这些 Region 组成重分配集（Relocation Set）</li><li>并发重分配（Concurrent Relocate）： 重分配是 ZGC 执行过程中的核心阶段，这个过程要把重分配集中的存活对象复制到新的 Region 上，并为重分配集中的<strong>每个 Region 维护一个 <code>转发表（Forward Table）</code> ，记录从旧地址到新地址的转向关系</strong></li><li>并发重映射（Concurrent Remap）：修正整个堆中指向重分配集中旧对象的所有引用，ZGC 的并发映射并不是一个必须要立即完成的任务，ZGC 很巧妙地把并发重映射阶段要做的工作，合并到下一次垃圾收集循环中的并发标记阶段里去完成，因为都是要遍历所有对象，这样合并节省了一次遍历的开销</li></ul><p>ZGC 几乎在所有地方并发执行的，除了初始标记的是 STW 的，但这部分的实际时间是非常少的，所以响应速度快，在尽可能对吞吐量影响不大的前提下，实现在任意堆内存大小下都可以把垃圾收集的停顿时间限制在十毫秒以内的低延迟</p><h5 id="zgc-优缺点"><a class="anchor" href="#zgc-优缺点">#</a> ZGC 优缺点</h5><p>优点：高吞吐量、低延迟</p><p>缺点：浮动垃圾，当 ZGC 准备要对一个很大的堆做一次完整的并发收集，其全过程要持续十分钟以上，由于应用的对象分配速率很高，将创造大量的新对象产生浮动垃圾</p><blockquote><p>参考文章：<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vamltb2VyL3AvMTMxNzAyNDkuaHRtbA==">https://www.cnblogs.com/jimoer/p/13170249.html</span></p></blockquote><h3 id="总结"><a class="anchor" href="#总结">#</a> 总结</h3><p>Serial GC、Parallel GC、Concurrent Mark Sweep GC 这三个 GC 的不同：</p><ul><li>最小化地使用内存和并行开销，选 Serial GC</li><li>最大化应用程序的吞吐量，选 Parallel GC</li><li>最小化 GC 的中断或停顿时间，选 CMS GC</li></ul><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/68747470733a2f2f7365617a65616e2e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f696d672f4a6176612f4a564d2d2545352539452538332545352539432542452545352539422539452545362539342542362545352539392541382545362538302542422545372542422539332e706e67" alt="img"></p><h2 id="5-gc调优"><a class="anchor" href="#5-gc调优">#</a> 5、GC 调优</h2><h3 id="前言"><a class="anchor" href="#前言">#</a> 前言</h3><h4 id="预备知识"><a class="anchor" href="#预备知识">#</a> 预备知识</h4><ul><li><p>掌握 GC 相关的 VM 参数，会基本的空间调整</p><blockquote><p>查看虚拟机的 VM 参数的命令： <code>D:\JavaJDK1.8\bin\java -XX:+PrintFlagsFinal -version | findstr &quot;GC&quot;</code> ，可以根据参数去查询具体的信息。</p></blockquote></li><li><p>掌握相关工具</p></li><li><p>明白一点：调优跟应用、环境有关，没有放之四海而皆准的法则</p></li></ul><h4 id="调优领域"><a class="anchor" href="#调优领域">#</a> 调优领域</h4><ul><li>内存</li><li>锁竞争</li><li>cpu 占用</li><li>io</li><li>GC</li></ul><h4 id="确定目标"><a class="anchor" href="#确定目标">#</a> 确定目标</h4><p>高吞吐量 / 低延时？ 选择合适的 GC 器</p><ul><li><p>高吞吐量：Parallel GC</p></li><li><p>低延时（响应时间优先）：CMS -&gt; G1 -&gt; ZGC</p></li></ul><p>Zing 虚拟机的垃圾回收效率比 Hotspot 虚拟机更高！</p><h4 id="最快的gc"><a class="anchor" href="#最快的gc">#</a> 最快的 GC</h4><p><font color="red">最快的 GC 是不发生 GC ！</font>首先排除减少因为自身编写的代码而引发的内存问题</p><ul><li>查看 Full GC 前后的内存占用，考虑以下几个问题<ul><li>数据是不是太多？<ul><li>resultSet = statement.executeQuery (“select * from 大表 <font color="red">limit n</font>”)</li></ul></li><li>数据类型表示是否太臃肿？<ul><li>对象图</li><li>对象大小 16 Integer 24 int 4</li></ul></li><li>是否存在内存泄漏？<ul><li>static Map map …</li><li>软</li><li>弱</li><li>第三方缓存实现</li></ul></li></ul></li></ul><h3 id="新生代调优"><a class="anchor" href="#新生代调优">#</a> 新生代调优</h3><p>新生代的特点：</p><ul><li><p><strong>所有的 new 操作分配内存都是非常廉价的</strong></p><ul><li><p><code>TLAB：thread-local allocation buffer</code> ，线程私有的分配缓存区，每个线程使用自己私有的 Eden 区内存来进行对象的内存分配，效率很高</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230924162720790.png" alt="image-20230924162720790"></p></li></ul></li><li><p><strong>死亡对象的回收是零代价的</strong></p><ul><li>所有 GC 器在新生代的回收算法都是<font color="red">复制算法</font>，将 Eden 区、From 区中的存活对象复制到 To 区中，复制完毕后 Eden 区、From 区的内存都被释放。</li></ul></li><li><p><strong>大部分对象用过即死（朝生夕死）</strong></p></li><li><p>因为上一点，所以<strong> Minor GC 所用时间远小于 Full GC</strong></p></li></ul><p>新生代内存越大越好么？当然不是！</p><ul><li><p>新生代内存太小：频繁触发 Minor GC ，会 STW ，会使得吞吐量下降</p></li><li><p>新生代内存太大：老年代内存占比有所降低，会更频繁地触发 Full GC。而且触发 Minor GC 时，清理新生代所花费的时间会更长。</p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/%E6%96%B0%E7%94%9F%E4%BB%A3%E7%A9%BA%E9%97%B4%E5%A4%A7%E5%B0%8F%E4%B8%8E%E5%90%9E%E5%90%90%E9%87%8F%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt="新生代空间大小与吞吐量的关系" style="zoom:50%"></li><li><p>新生代内存大小设置为<strong>能容纳所有【并发量 * (请求 - 响应)】的数据</strong>为宜，大约 512M</p></li></ul><p><strong>新生代的 Survivor 区需要能够保存【当前活跃对象 + 需要晋升的对象】</strong>。</p><p>晋升阈值需要配置得当，让长时间存活的对象尽快晋升。</p><ul><li><p><code>-XX:MaxTenuringThreshold=threshold</code> ：设置晋升阈值</p></li><li><p><code>-XX:+PrintTenuringDistrubution</code> ：打印 Survivor 区的详细信息</p></li></ul><h3 id="老年代调优"><a class="anchor" href="#老年代调优">#</a> 老年代调优</h3><p>以 CMS 为例：</p><ul><li>CMS 的<font color="red">老年代内存越大越好</font></li><li>先尝试不做调优，如果并没有 Full GC 那么说明老年代的空间充裕，否则，也是先尝试调优新生代。如果还是不奏效，再考虑老年代调优。</li><li>观察发现 Full GC 时老年代内存占用，<font color="red">将老年代内存预设调大 1/4 ~ 1/3</font><ul><li><code>-XX:CMSInitiatingOccupancyFraction=percent</code> ：设置<strong>老年代在堆内存中的预设占用率，代表触发 Full GC 的阈值</strong>。一般设为 75%~80%，也就是预留大概 25% 的空间给浮动垃圾。一旦达到该阈值，便开始采用 CMS 收集器进行垃圾回收。</li></ul></li></ul><h3 id="案例"><a class="anchor" href="#案例">#</a> 案例</h3><p>案例 1：Full GC 和 Minor GC 频繁</p><blockquote><p>解决方法：</p><ol><li><strong><font color="red">增大新生代内存</font></strong>：新生代的内存充裕了，自然就减少了 Minor GC</li><li><strong><font color="red">增大 Survivor 区空间，以及晋升阈值</font></strong>：让很多生命周期较短的对象能尽可能留在新生代，而不进入老年代，减少 Full GC</li></ol></blockquote><p>案例 2：请求高峰期发生 Full GC，单次暂停时间特别长（CMS）</p><blockquote><p>解决方法：</p><p>使用 CMS 垃圾回收器时单次暂停时间特别长，通过查看 GC 日志确定是哪个阶段最耗时：初始标记、并发标记、重新标记、并发清理。发现是<strong>重新标记</strong>阶段最耗时，因为会扫描<strong>整个堆内存上</strong>的对象。</p><p>因此可以考虑 **<font color="red">开启 VM 参数 <code>-XX:+CMSScavengeBeforeRemark</code> ，在重新标记前，对新生代进行一次 GC（ParNew 收集器），以缩小重新标记阶段的搜索范围。</font>**</p></blockquote><p>案例 3：老年代充裕情况下，发生 Full GC（CMS、jdk1.7）</p><blockquote><p>CMS 中产生 Full GC 的原因：</p><ol><li>空间不足，导致并发失败</li><li>内存碎片过多</li></ol><p>但是老年代空间其实是充裕的，不存在以上问题。而是因为 jdk1.7，采用的是永久代作为方法区的实现，而<strong>堆和永久代在逻辑上虽然是分开的，但在物理上来说，它们是连续的一块内存！</strong> <strong>因此如果永久代的空间不足时，会触发堆的 Full GC ！</strong></p><p>解决方案：<strong><font color="red">增大永久代空间大小的初始值、最大值</font></strong>，确保了 Full GC 不再发生。</p></blockquote><h1 id="第四章类加载与字节码技术"><a class="anchor" href="#第四章类加载与字节码技术">#</a> 第四章：类加载与字节码技术</h1><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230924182346694.png" alt="image-20230924182346694"></p><h2 id="1-类文件的结构"><a class="anchor" href="#1-类文件的结构">#</a> 1、类文件的结构</h2><blockquote><p>类文件（.class），也叫二进制字节码文件，内容是 <strong>JVM 的字节码指令</strong>，不是机器码，经过编译得到，而后供虚拟机解释执行。</p><p>C、C++ 经由编译器直接生成机器码，所以执行效率比 Java 高。</p><p>官网：<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vamF2YXNlL3NwZWNzL2p2bXMvc2U4L2h0bWwv">https://docs.oracle.com/javase/specs/jvms/se8/html/</span></p></blockquote><h3 id="概述-2"><a class="anchor" href="#概述-2">#</a> 概述</h3><p>一个简单的 HelloWorld.java：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">package</span> <span class="token namespace">cn<span class="token punctuation">.</span>itcast<span class="token punctuation">.</span>jvm<span class="token punctuation">.</span>t5</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment">// HelloWorld 示例</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HelloWorld</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"hello world"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>通过命令 <code>javac -parameters -d . HellowWorld.java</code> 编译后，会生成一个类文件（.class）：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token number">0000000</span> ca fe ba be <span class="token number">00</span> <span class="token number">00</span> <span class="token number">00</span> <span class="token number">34</span> <span class="token number">00</span> <span class="token number">23</span> <span class="token number">0</span>a <span class="token number">00</span> <span class="token number">06</span> <span class="token number">00</span> <span class="token number">15</span> <span class="token number">09</span> </pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token number">0000020</span> <span class="token number">00</span> <span class="token number">16</span> <span class="token number">00</span> <span class="token number">17</span> <span class="token number">08</span> <span class="token number">00</span> <span class="token number">18</span> <span class="token number">0</span>a <span class="token number">00</span> <span class="token number">19</span> <span class="token number">00</span> <span class="token number">1</span>a <span class="token number">07</span> <span class="token number">00</span> <span class="token number">1</span>b <span class="token number">07</span> </pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token number">0000040</span> <span class="token number">00</span> <span class="token number">1</span>c <span class="token number">01</span> <span class="token number">00</span> <span class="token number">06</span> <span class="token number">3</span>c <span class="token number">69</span> <span class="token number">6</span>e <span class="token number">69</span> <span class="token number">74</span> <span class="token number">3</span>e <span class="token number">01</span> <span class="token number">00</span> <span class="token number">03</span> <span class="token number">28</span> <span class="token number">29</span> </pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token number">0000060</span> <span class="token number">56</span> <span class="token number">01</span> <span class="token number">00</span> <span class="token number">04</span> <span class="token number">43</span> <span class="token number">6f</span> <span class="token number">64</span> <span class="token number">65</span> <span class="token number">01</span> <span class="token number">00</span> <span class="token number">0f</span> <span class="token number">4</span>c <span class="token number">69</span> <span class="token number">6</span>e <span class="token number">65</span> <span class="token number">4</span>e </pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token number">0000100</span> <span class="token number">75</span> <span class="token number">6d</span> <span class="token number">62</span> <span class="token number">65</span> <span class="token number">72</span> <span class="token number">54</span> <span class="token number">61</span> <span class="token number">62</span> <span class="token number">6</span>c <span class="token number">65</span> <span class="token number">01</span> <span class="token number">00</span> <span class="token number">12</span> <span class="token number">4</span>c <span class="token number">6f</span> <span class="token number">63</span> </pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token number">0000120</span> <span class="token number">61</span> <span class="token number">6</span>c <span class="token number">56</span> <span class="token number">61</span> <span class="token number">72</span> <span class="token number">69</span> <span class="token number">61</span> <span class="token number">62</span> <span class="token number">6</span>c <span class="token number">65</span> <span class="token number">54</span> <span class="token number">61</span> <span class="token number">62</span> <span class="token number">6</span>c <span class="token number">65</span> <span class="token number">01</span> </pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token number">0000140</span> <span class="token number">00</span> <span class="token number">04</span> <span class="token number">74</span> <span class="token number">68</span> <span class="token number">69</span> <span class="token number">73</span> <span class="token number">01</span> <span class="token number">00</span> <span class="token number">1d</span> <span class="token number">4</span>c <span class="token number">63</span> <span class="token number">6</span>e <span class="token number">2f</span> <span class="token number">69</span> <span class="token number">74</span> <span class="token number">63</span> </pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token number">0000160</span> <span class="token number">61</span> <span class="token number">73</span> <span class="token number">74</span> <span class="token number">2f</span> <span class="token number">6</span>a <span class="token number">76</span> <span class="token number">6d</span> <span class="token number">2f</span> <span class="token number">74</span> <span class="token number">35</span> <span class="token number">2f</span> <span class="token number">48</span> <span class="token number">65</span> <span class="token number">6</span>c <span class="token number">6</span>c <span class="token number">6f</span> </pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token number">0000200</span> <span class="token number">57</span> <span class="token number">6f</span> <span class="token number">72</span> <span class="token number">6</span>c <span class="token number">64</span> <span class="token number">3</span>b <span class="token number">01</span> <span class="token number">00</span> <span class="token number">04</span> <span class="token number">6d</span> <span class="token number">61</span> <span class="token number">69</span> <span class="token number">6</span>e <span class="token number">01</span> <span class="token number">00</span> <span class="token number">16</span> </pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token number">0000220</span> <span class="token number">28</span> <span class="token number">5</span>b <span class="token number">4</span>c <span class="token number">6</span>a <span class="token number">61</span> <span class="token number">76</span> <span class="token number">61</span> <span class="token number">2f</span> <span class="token number">6</span>c <span class="token number">61</span> <span class="token number">6</span>e <span class="token number">67</span> <span class="token number">2f</span> <span class="token number">53</span> <span class="token number">74</span> <span class="token number">72</span> </pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token number">0000240</span> <span class="token number">69</span> <span class="token number">6</span>e <span class="token number">67</span> <span class="token number">3</span>b <span class="token number">29</span> <span class="token number">56</span> <span class="token number">01</span> <span class="token number">00</span> <span class="token number">04</span> <span class="token number">61</span> <span class="token number">72</span> <span class="token number">67</span> <span class="token number">73</span> <span class="token number">01</span> <span class="token number">00</span> <span class="token number">13</span> </pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token number">0000260</span> <span class="token number">5</span>b <span class="token number">4</span>c <span class="token number">6</span>a <span class="token number">61</span> <span class="token number">76</span> <span class="token number">61</span> <span class="token number">2f</span> <span class="token number">6</span>c <span class="token number">61</span> <span class="token number">6</span>e <span class="token number">67</span> <span class="token number">2f</span> <span class="token number">53</span> <span class="token number">74</span> <span class="token number">72</span> <span class="token number">69</span> </pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token number">0000300</span> <span class="token number">6</span>e <span class="token number">67</span> <span class="token number">3</span>b <span class="token number">01</span> <span class="token number">00</span> <span class="token number">10</span> <span class="token number">4d</span> <span class="token number">65</span> <span class="token number">74</span> <span class="token number">68</span> <span class="token number">6f</span> <span class="token number">64</span> <span class="token number">50</span> <span class="token number">61</span> <span class="token number">72</span> <span class="token number">61</span> </pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token number">0000320</span> <span class="token number">6d</span> <span class="token number">65</span> <span class="token number">74</span> <span class="token number">65</span> <span class="token number">72</span> <span class="token number">73</span> <span class="token number">01</span> <span class="token number">00</span> <span class="token number">0</span>a <span class="token number">53</span> <span class="token number">6f</span> <span class="token number">75</span> <span class="token number">72</span> <span class="token number">63</span> <span class="token number">65</span> <span class="token number">46</span> </pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token number">0000340</span> <span class="token number">69</span> <span class="token number">6</span>c <span class="token number">65</span> <span class="token number">01</span> <span class="token number">00</span> <span class="token number">0f</span> <span class="token number">48</span> <span class="token number">65</span> <span class="token number">6</span>c <span class="token number">6</span>c <span class="token number">6f</span> <span class="token number">57</span> <span class="token number">6f</span> <span class="token number">72</span> <span class="token number">6</span>c <span class="token number">64</span></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token number">0000360</span> <span class="token number">2</span>e <span class="token number">6</span>a <span class="token number">61</span> <span class="token number">76</span> <span class="token number">61</span> <span class="token number">0</span>c <span class="token number">00</span> <span class="token number">07</span> <span class="token number">00</span> <span class="token number">08</span> <span class="token number">07</span> <span class="token number">00</span> <span class="token number">1d</span> <span class="token number">0</span>c <span class="token number">00</span> <span class="token number">1</span>e </pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token number">0000400</span> <span class="token number">00</span> <span class="token number">1f</span> <span class="token number">01</span> <span class="token number">00</span> <span class="token number">0</span>b <span class="token number">68</span> <span class="token number">65</span> <span class="token number">6</span>c <span class="token number">6</span>c <span class="token number">6f</span> <span class="token number">20</span> <span class="token number">77</span> <span class="token number">6f</span> <span class="token number">72</span> <span class="token number">6</span>c <span class="token number">64</span> </pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token number">0000420</span> <span class="token number">07</span> <span class="token number">00</span> <span class="token number">20</span> <span class="token number">0</span>c <span class="token number">00</span> <span class="token number">21</span> <span class="token number">00</span> <span class="token number">22</span> <span class="token number">01</span> <span class="token number">00</span> <span class="token number">1</span>b <span class="token number">63</span> <span class="token number">6</span>e <span class="token number">2f</span> <span class="token number">69</span> <span class="token number">74</span> </pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token number">0000440</span> <span class="token number">63</span> <span class="token number">61</span> <span class="token number">73</span> <span class="token number">74</span> <span class="token number">2f</span> <span class="token number">6</span>a <span class="token number">76</span> <span class="token number">6d</span> <span class="token number">2f</span> <span class="token number">74</span> <span class="token number">35</span> <span class="token number">2f</span> <span class="token number">48</span> <span class="token number">65</span> <span class="token number">6</span>c <span class="token number">6</span>c </pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token number">0000460</span> <span class="token number">6f</span> <span class="token number">57</span> <span class="token number">6f</span> <span class="token number">72</span> <span class="token number">6</span>c <span class="token number">64</span> <span class="token number">01</span> <span class="token number">00</span> <span class="token number">10</span> <span class="token number">6</span>a <span class="token number">61</span> <span class="token number">76</span> <span class="token number">61</span> <span class="token number">2f</span> <span class="token number">6</span>c <span class="token number">61</span> </pre></td></tr><tr><td data-num="21"></td><td><pre><span class="token number">0000500</span> <span class="token number">6</span>e <span class="token number">67</span> <span class="token number">2f</span> <span class="token number">4f</span> <span class="token number">62</span> <span class="token number">6</span>a <span class="token number">65</span> <span class="token number">63</span> <span class="token number">74</span> <span class="token number">01</span> <span class="token number">00</span> <span class="token number">10</span> <span class="token number">6</span>a <span class="token number">61</span> <span class="token number">76</span> <span class="token number">61</span> </pre></td></tr><tr><td data-num="22"></td><td><pre><span class="token number">0000520</span> <span class="token number">2f</span> <span class="token number">6</span>c <span class="token number">61</span> <span class="token number">6</span>e <span class="token number">67</span> <span class="token number">2f</span> <span class="token number">53</span> <span class="token number">79</span> <span class="token number">73</span> <span class="token number">74</span> <span class="token number">65</span> <span class="token number">6d</span> <span class="token number">01</span> <span class="token number">00</span> <span class="token number">03</span> <span class="token number">6f</span> </pre></td></tr><tr><td data-num="23"></td><td><pre><span class="token number">0000540</span> <span class="token number">75</span> <span class="token number">74</span> <span class="token number">01</span> <span class="token number">00</span> <span class="token number">15</span> <span class="token number">4</span>c <span class="token number">6</span>a <span class="token number">61</span> <span class="token number">76</span> <span class="token number">61</span> <span class="token number">2f</span> <span class="token number">69</span> <span class="token number">6f</span> <span class="token number">2f</span> <span class="token number">50</span> <span class="token number">72</span> </pre></td></tr><tr><td data-num="24"></td><td><pre><span class="token number">0000560</span> <span class="token number">69</span> <span class="token number">6</span>e <span class="token number">74</span> <span class="token number">53</span> <span class="token number">74</span> <span class="token number">72</span> <span class="token number">65</span> <span class="token number">61</span> <span class="token number">6d</span> <span class="token number">3</span>b <span class="token number">01</span> <span class="token number">00</span> <span class="token number">13</span> <span class="token number">6</span>a <span class="token number">61</span> <span class="token number">76</span> </pre></td></tr><tr><td data-num="25"></td><td><pre><span class="token number">0000600</span> <span class="token number">61</span> <span class="token number">2f</span> <span class="token number">69</span> <span class="token number">6f</span> <span class="token number">2f</span> <span class="token number">50</span> <span class="token number">72</span> <span class="token number">69</span> <span class="token number">6</span>e <span class="token number">74</span> <span class="token number">53</span> <span class="token number">74</span> <span class="token number">72</span> <span class="token number">65</span> <span class="token number">61</span> <span class="token number">6d</span> </pre></td></tr><tr><td data-num="26"></td><td><pre><span class="token number">0000620</span> <span class="token number">01</span> <span class="token number">00</span> <span class="token number">07</span> <span class="token number">70</span> <span class="token number">72</span> <span class="token number">69</span> <span class="token number">6</span>e <span class="token number">74</span> <span class="token number">6</span>c <span class="token number">6</span>e <span class="token number">01</span> <span class="token number">00</span> <span class="token number">15</span> <span class="token number">28</span> <span class="token number">4</span>c <span class="token number">6</span>a </pre></td></tr><tr><td data-num="27"></td><td><pre><span class="token number">0000640</span> <span class="token number">61</span> <span class="token number">76</span> <span class="token number">61</span> <span class="token number">2f</span> <span class="token number">6</span>c <span class="token number">61</span> <span class="token number">6</span>e <span class="token number">67</span> <span class="token number">2f</span> <span class="token number">53</span> <span class="token number">74</span> <span class="token number">72</span> <span class="token number">69</span> <span class="token number">6</span>e <span class="token number">67</span> <span class="token number">3</span>b </pre></td></tr><tr><td data-num="28"></td><td><pre><span class="token number">0000660</span> <span class="token number">29</span> <span class="token number">56</span> <span class="token number">00</span> <span class="token number">21</span> <span class="token number">00</span> <span class="token number">05</span> <span class="token number">00</span> <span class="token number">06</span> <span class="token number">00</span> <span class="token number">00</span> <span class="token number">00</span> <span class="token number">00</span> <span class="token number">00</span> <span class="token number">02</span> <span class="token number">00</span> <span class="token number">01</span> </pre></td></tr><tr><td data-num="29"></td><td><pre><span class="token number">0000700</span> <span class="token number">00</span> <span class="token number">07</span> <span class="token number">00</span> <span class="token number">08</span> <span class="token number">00</span> <span class="token number">01</span> <span class="token number">00</span> <span class="token number">09</span> <span class="token number">00</span> <span class="token number">00</span> <span class="token number">00</span> <span class="token number">2f</span> <span class="token number">00</span> <span class="token number">01</span> <span class="token number">00</span> <span class="token number">01</span> </pre></td></tr><tr><td data-num="30"></td><td><pre><span class="token number">0000720</span> <span class="token number">00</span> <span class="token number">00</span> <span class="token number">00</span> <span class="token number">05</span> <span class="token number">2</span>a b7 <span class="token number">00</span> <span class="token number">01</span> b1 <span class="token number">00</span> <span class="token number">00</span> <span class="token number">00</span> <span class="token number">02</span> <span class="token number">00</span> <span class="token number">0</span>a <span class="token number">00</span> </pre></td></tr><tr><td data-num="31"></td><td><pre><span class="token number">0000740</span> <span class="token number">00</span> <span class="token number">00</span> <span class="token number">06</span> <span class="token number">00</span> <span class="token number">01</span> <span class="token number">00</span> <span class="token number">00</span> <span class="token number">00</span> <span class="token number">04</span> <span class="token number">00</span> <span class="token number">0</span>b <span class="token number">00</span> <span class="token number">00</span> <span class="token number">00</span> <span class="token number">0</span>c <span class="token number">00</span> </pre></td></tr><tr><td data-num="32"></td><td><pre><span class="token number">0000760</span> <span class="token number">01</span> <span class="token number">00</span> <span class="token number">00</span> <span class="token number">00</span> <span class="token number">05</span> <span class="token number">00</span> <span class="token number">0</span>c <span class="token number">00</span> <span class="token number">0d</span> <span class="token number">00</span> <span class="token number">00</span> <span class="token number">00</span> <span class="token number">09</span> <span class="token number">00</span> <span class="token number">0</span>e <span class="token number">00</span> </pre></td></tr><tr><td data-num="33"></td><td><pre><span class="token number">0001000</span> <span class="token number">0f</span> <span class="token number">00</span> <span class="token number">02</span> <span class="token number">00</span> <span class="token number">09</span> <span class="token number">00</span> <span class="token number">00</span> <span class="token number">00</span> <span class="token number">37</span> <span class="token number">00</span> <span class="token number">02</span> <span class="token number">00</span> <span class="token number">01</span> <span class="token number">00</span> <span class="token number">00</span> <span class="token number">00</span> </pre></td></tr><tr><td data-num="34"></td><td><pre><span class="token number">0001020</span> <span class="token number">09</span> b2 <span class="token number">00</span> <span class="token number">02</span> <span class="token number">12</span> <span class="token number">03</span> b6 <span class="token number">00</span> <span class="token number">04</span> b1 <span class="token number">00</span> <span class="token number">00</span> <span class="token number">00</span> <span class="token number">02</span> <span class="token number">00</span> <span class="token number">0</span>a </pre></td></tr><tr><td data-num="35"></td><td><pre><span class="token number">0001040</span> <span class="token number">00</span> <span class="token number">00</span> <span class="token number">00</span> <span class="token number">0</span>a <span class="token number">00</span> <span class="token number">02</span> <span class="token number">00</span> <span class="token number">00</span> <span class="token number">00</span> <span class="token number">06</span> <span class="token number">00</span> <span class="token number">08</span> <span class="token number">00</span> <span class="token number">07</span> <span class="token number">00</span> <span class="token number">0</span>b </pre></td></tr><tr><td data-num="36"></td><td><pre><span class="token number">0001060</span> <span class="token number">00</span> <span class="token number">00</span> <span class="token number">00</span> <span class="token number">0</span>c <span class="token number">00</span> <span class="token number">01</span> <span class="token number">00</span> <span class="token number">00</span> <span class="token number">00</span> <span class="token number">09</span> <span class="token number">00</span> <span class="token number">10</span> <span class="token number">00</span> <span class="token number">11</span> <span class="token number">00</span> <span class="token number">00</span> </pre></td></tr><tr><td data-num="37"></td><td><pre><span class="token number">0001100</span> <span class="token number">00</span> <span class="token number">12</span> <span class="token number">00</span> <span class="token number">00</span> <span class="token number">00</span> <span class="token number">05</span> <span class="token number">01</span> <span class="token number">00</span> <span class="token number">10</span> <span class="token number">00</span> <span class="token number">00</span> <span class="token number">00</span> <span class="token number">01</span> <span class="token number">00</span> <span class="token number">13</span> <span class="token number">00</span> </pre></td></tr><tr><td data-num="38"></td><td><pre><span class="token number">0001120</span> <span class="token number">00</span> <span class="token number">00</span> <span class="token number">02</span> <span class="token number">00</span> <span class="token number">14</span></pre></td></tr></table></figure><p>根据 JVM 规范，<strong>类文件（.class）的结构</strong>如下：</p><pre><code>ClassFile &#123;
	u4 				magic;						
    u2 				minor_version;						
    u2 				major_version;						
    u2 				constant_pool_count;
    cp_info			constant_pool[constant_pool_count-1];
    u2	 			access_flags;
    u2 				this_class;
    u2 				super_class;
    u2 				interfaces_count;
    u2 				interfaces[interfaces_count];
    u2 				fields_count;
    field_info 		fields[fields_count];
    u2 				methods_count;
    method_info 	methods[methods_count];
    u2 				attributes_count;
    attribute_info 	attributes[attributes_count];
&#125;
</code></pre><p>具体信息如下表：</p><table><thead><tr><th>类型（字节数）</th><th>名称</th><th>含义</th><th>长度</th><th>数量</th></tr></thead><tbody><tr><td>u4</td><td>magic</td><td><strong>魔数</strong>，标识类文件的格式</td><td>4 个字节</td><td>1</td></tr><tr><td>u2</td><td>minor_version</td><td>副版本号 (<strong>小版本</strong>)</td><td>2 个字节</td><td>1</td></tr><tr><td>u2</td><td>major_version</td><td>主版本号 (<strong>大版本</strong>)</td><td>2 个字节</td><td>1</td></tr><tr><td>u2</td><td>constant_pool_count</td><td><strong>常量池计数器</strong>，表示常量池的长度</td><td>2 个字节</td><td>1</td></tr><tr><td>cp_info</td><td>constant_pool</td><td><strong>常量池表</strong></td><td>n 个字节</td><td>constant_pool_count-1</td></tr><tr><td>u2</td><td>access_flags</td><td><strong>访问标识</strong></td><td>2 个字节</td><td>1</td></tr><tr><td>u2</td><td>this_class</td><td>本类（的全限定名的）索引</td><td>2 个字节</td><td>1</td></tr><tr><td>u2</td><td>super_class</td><td>父类（的全限定名的）索引</td><td>2 个字节</td><td>1</td></tr><tr><td>u2</td><td>interfaces_count</td><td>接口计数</td><td>2 个字节</td><td>1</td></tr><tr><td><strong>u2</strong></td><td>interfaces</td><td>接口索引集合</td><td>2 个字节</td><td>interfaces_count</td></tr><tr><td>u2</td><td>fields_count</td><td>字段计数器</td><td>2 个字节</td><td>1</td></tr><tr><td>field_info</td><td>fields</td><td><strong>字段表</strong></td><td>n 个字节</td><td>fields_count</td></tr><tr><td>u2</td><td>methods_count</td><td>方法计数器</td><td>2 个字节</td><td>1</td></tr><tr><td>method_info</td><td>methods</td><td><strong>方法表</strong></td><td>n 个字节</td><td>methods_count</td></tr><tr><td>u2</td><td>attributes_count</td><td>属性计数器</td><td>2 个字节</td><td>1</td></tr><tr><td>attribute_info</td><td>attributes</td><td><strong>属性表</strong></td><td>n 个字节</td><td>attributes_count</td></tr></tbody></table><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/68747470733a2f2f7365617a65616e2e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f696d672f4a6176612f4a564d2d2545372542312542422545372542422539332545362539452538342e706e67" alt="img"></p><p>Class 文件的结构中只有两种数据类型：</p><ul><li><font color="gree">无符号数</font>：属于<font color="red">基本的数据类型</font>，以 u1、u2、u4、u8 来分别代表 1 个字节、2 个字节、4 个字节和 8 个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照 UTF-8 编码构成字符串</li><li><font color="gree">表</font>：是由多个无符号数或者其他表作为数据项构成的<font color="red">复合数据类型</font>，表都<font color="red">以 <code>_info</code> 结尾</font>，用于描述有层次关系的数据，整个 Class 文件本质上就是一张表，由于表没有固定长度，所以通常会在其前面加上个数说明</li></ul><p>下面对一些重要的信息展开介绍。</p><h3 id="魔数"><a class="anchor" href="#魔数">#</a> 魔数</h3><p><font color="cornflowerblue">魔数（u4，magic）</font>：每个 Class 文件开头的<font color="red">4 个字节</font>的无符号整数，<font color="red">是 Class 文件的标识符</font></p><ul><li><p><font color="red">0~3 字节即为魔数值，固定为 <code>0xCAFEBABE</code> </font>，不符合则会抛出错误</p></li><li><p>使用魔数而不是扩展名来进行识别主要是基于安全方面的考虑，因为文件扩展名可以随意地改动</p></li></ul><h3 id="版本"><a class="anchor" href="#版本">#</a> 版本</h3><ul><li><p><font color="cornflowerblue">副版本号（u2，minor_version）</font></p></li><li><p><font color="cornflowerblue">主版本号（u2，major_version）</font></p></li></ul><p>举例：4~7 字节 <code>00 00 00 34</code> 表示主版本号是 00 34（16 进制） = 52（10 进制），代表 JDK8</p><table><thead><tr><th>主版本（十进制）</th><th>副版本（十进制）</th><th>编译器版本</th></tr></thead><tbody><tr><td>45</td><td>3</td><td>1.1</td></tr><tr><td>46</td><td>0</td><td>1.2</td></tr><tr><td>47</td><td>0</td><td>1.3</td></tr><tr><td>48</td><td>0</td><td>1.4</td></tr><tr><td>49</td><td>0</td><td>1.5</td></tr><tr><td>50</td><td>0</td><td>1.6</td></tr><tr><td>51</td><td>0</td><td>1.7</td></tr><tr><td>52</td><td>0</td><td>1.8</td></tr><tr><td>53</td><td>0</td><td>1.9</td></tr><tr><td>54</td><td>0</td><td>1.10</td></tr><tr><td>55</td><td>0</td><td>1.11</td></tr></tbody></table><p>不同版本的 Java 编译器编译的 Class 文件对应的版本是不一样的，<font color="red">高版本的 Java 虚拟机可以执行由低版本编译器生成的 Class 文件</font>，反之 JVM 会抛出异常 <code>java.lang.UnsupportedClassVersionError</code> 。</p><h3 id="常量池表-2"><a class="anchor" href="#常量池表-2">#</a> 常量池 (表)</h3><ul><li><p><font color="cornflowerblue">常量池计数器（u2，constant_pool_count）</font>：记录常量池的长度（即常量的数目）</p><ul><li><font color="red">8~9 字节表示常量池长度， <code>00 23</code> （35） 表示常量池有 #1~#34 项，注意 #0 项不计入，也没有值</font><br>0000000 ca fe ba be 00 00 00 34 <code>00 23</code> 0a 00 06 00 15 09`</li><li><font color="red">第 0 项不记录</font>，是为了满足后面某些指向常量池的索引值的数据在特定情况下需要表达不引用任何一个常量池项目，这种情况可用索引值 0 来表示</li></ul></li><li><p><font color="cornflowerblue">常量池表（cp_info，constant_pool）</font>：一种表结构，以 1 ~ constant_pool_count - 1 为索引，表明有多少个常量池表项。<font color="red">表中存放编译时期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的<strong>运行时常量池</strong></font>：</p><ul><li><p><font color="gree">字面量（Literal）</font> ：基本数据类型、字符串类型常量、声明为 final 的常量值等</p></li><li><p><font color="gree">符号引用（Symbolic References）</font>：类和接口的全限定名、字段的名称和描述符、方法的名称和描述符</p><ul><li><p>全限定名：com/test/Demo 这个就是类的全限定名，仅仅是把包名的 <code>.</code> 替换成 <code>/</code> ，为了使连续的多个全限定名之间不产生混淆，在使用时最后一般会加入一个 <code>;</code> 表示全限定名结束</p></li><li><p>简单名称：指没有类型和参数修饰的方法或者字段名称，比如字段 x 的简单名称就是 x</p></li><li><p>描述符：用来描述字段的数据类型、方法的参数列表（包括数量、类型以及顺序）和返回值</p><table><thead><tr><th>标志符</th><th>含义</th></tr></thead><tbody><tr><td>B</td><td>基本数据类型 byte</td></tr><tr><td>C</td><td>基本数据类型 char</td></tr><tr><td>D</td><td>基本数据类型 double</td></tr><tr><td>F</td><td>基本数据类型 float</td></tr><tr><td>I</td><td>基本数据类型 int</td></tr><tr><td><strong>J</strong></td><td>基本数据类型 long</td></tr><tr><td>S</td><td>基本数据类型 short</td></tr><tr><td><strong>Z</strong></td><td>基本数据类型 boolean</td></tr><tr><td>V</td><td>代表 void 类型</td></tr><tr><td><strong>L</strong></td><td>对象类型，比如： <code>Ljava/lang/Object;</code> ，不同方法间用 <code>;</code> 隔开</td></tr><tr><td><strong>[</strong></td><td>数组类型，代表一维数组。比如： <code>double[][][] is [[[D</code></td></tr><tr><td>()</td><td>无参</td></tr></tbody></table></li></ul></li></ul></li></ul><p><strong>常量类型和结构</strong>：</p><table><thead><tr><th>标识</th><th>类型</th><th>描述</th><th>取值的含义</th></tr></thead><tbody><tr><td>1</td><td>CONSTANT_utf8_info</td><td>UTF-8 编码的字符串</td><td>【字符串长度】和【字符串】</td></tr><tr><td>3</td><td>CONSTANT_Integer_info</td><td>整型字面量</td><td></td></tr><tr><td>4</td><td>CONSTANT_Float_info</td><td>浮点型字面量</td><td></td></tr><tr><td>5</td><td>CONSTANT_Long_info</td><td>长整型字面量</td><td></td></tr><tr><td>6</td><td>CONSTANT_Double_info</td><td>双精度浮点型字面量</td><td></td></tr><tr><td>7</td><td>CONSTANT_Class_info</td><td>类或接口的符号引用</td><td>【引用】</td></tr><tr><td>8</td><td>CONSTANT_String_info</td><td>字符串类型字面量</td><td>【引用】</td></tr><tr><td>9</td><td>CONSTANT_Fieldref_info</td><td>字段的符号引用</td><td>字段的【所属类】和【字段名】</td></tr><tr><td>10</td><td>CONSTANT_Methodref_info</td><td>类中方法的符号引用</td><td>方法的【所属类】和【方法名】</td></tr><tr><td>11</td><td>CONSTANT_InterfaceMethodref_info</td><td>接口中方法的符号引用</td><td></td></tr><tr><td>12</td><td>CONSTANT_NameAndType_info</td><td>字段或方法的符号引用</td><td>【名】和【类型】</td></tr><tr><td>15</td><td>CONSTANT_MethodHandle_info</td><td>表示方法句柄</td><td></td></tr><tr><td>16</td><td>CONSTANT_MethodType_info</td><td>标志方法类型</td><td></td></tr><tr><td>18</td><td>CONSTANT_InvokeDynamic_info</td><td>表示一个动态方法调用点</td><td></td></tr></tbody></table><blockquote><p>18 种常量没有出现 byte、short、char，boolean 的原因：编译之后都可以理解为 Integer</p></blockquote><h3 id="访问标识"><a class="anchor" href="#访问标识">#</a> 访问标识</h3><p><font color="cornflowerblue">访问标识（u2，access_flag）</font>用 2 个字节表示，用于<font color="red">识别一些类或者接口层次的访问信息</font>，包括这个 Class 是类还是接口，是否定义为 public 类型，是否定义为 abstract 类型等</p><ul><li>类的访问权限通常为<font color="red"> ACC_ 开头的常量</font></li><li>每一种类型的表示都是通过<font color="red">设置访问标记的 32 位中的特定位</font>来实现的，比如若是 public final 的类，则该标记为 <code>ACC_PUBLIC | ACC_FINAL</code></li><li>使用 <code>ACC_SUPER</code> 可以让类更准确地定位到父类的方法，确定类或接口里面的 invokespecial 指令使用的是哪一种执行语义，现代编译器都会设置并且使用这个标记</li></ul><table><thead><tr><th>标志名称</th><th>标志值</th><th>含义</th></tr></thead><tbody><tr><td>ACC_PUBLIC</td><td>0x0001</td><td>标志为 public 类型</td></tr><tr><td>ACC_FINAL</td><td>0x0010</td><td>标志被声明为 final，只有类可以设置</td></tr><tr><td>ACC_SUPER</td><td>0x0020</td><td>标志允许使用 invokespecial 字节码指令的新语义，JDK1.0.2 之后编译出来的类的这个标志默认为真，使用增强的方法调用父类方法</td></tr><tr><td>ACC_INTERFACE</td><td>0x0200</td><td>标志这是一个接口</td></tr><tr><td>ACC_ABSTRACT</td><td>0x0400</td><td>是否为 abstract 类型，对于接口或者抽象类来说，次标志值为真，其他类型为假</td></tr><tr><td>ACC_SYNTHETIC</td><td>0x1000</td><td>标志此类并非由用户代码产生（由编译器产生的类，没有源码对应）</td></tr><tr><td>ACC_ANNOTATION</td><td>0x2000</td><td>标志这是一个注解</td></tr><tr><td>ACC_ENUM</td><td>0x4000</td><td>标志这是一个枚举</td></tr></tbody></table><h3 id="继承信息索引集合"><a class="anchor" href="#继承信息索引集合">#</a> 继承信息（索引集合）</h3><ul><li><p><font color="cornflowerblue">类索引（u2，this_class）</font>：本类的全限定名的索引</p></li><li><p><font color="cornflowerblue">父类索引（u2，super_class）</font>：父类的全限定名的索引</p><blockquote><p>Java 语言不允许多重继承，所以父类索引只有一个，除了 Object 之外，所有的 Java 类都有父类，因此<strong>除了 java.lang.Object 外，所有 Java 类的父类索引都不为 0</strong></p></blockquote></li><li><p><font color="cornflowerblue">接口数量（u2，interfaces_count）</font>：当前类或接口的直接超接口数量</p></li><li><p><font color="cornflowerblue">接口索引集合（u2，interfaces [interfaces_count]）</font>：描述这个类实现了哪些接口，被实现的接口将按 implements 语句后的接口顺序从左到右排列在接口索引集合中</p></li></ul><h3 id="字段表"><a class="anchor" href="#字段表">#</a> 字段表</h3><p>字段 fields 用于描述接口或类中声明的变量，包括<font color="red">类变量、实例变量</font>，但不包括方法内部、代码块内部声明的局部变量以及从父类或父接口继承。字段叫什么名字、被定义为什么数据类型，都是无法固定的，因此<font color="red">只能引用常量池中的常量来描述字段的名字、数据类型</font></p><p><font color="cornflowerblue">字段计数器（u2，fields_count）</font>：表示当前 class 文件 fields 表的成员个数，用两个字节来表示</p><p><font color="cornflowerblue">字段表（field_info，fields [fields_count]）</font>：</p><ul><li><p>表中的每个成员都是一个 fields_info 结构的数据项，用于表示当前类或接口中某个字段的完整描述</p></li><li><p><font color="gree">字段访问标识</font>：</p><table><thead><tr><th>标志名称</th><th>标志值</th><th>含义</th></tr></thead><tbody><tr><td>ACC_PUBLIC</td><td>0x0001</td><td>字段是否为 public</td></tr><tr><td>ACC_PRIVATE</td><td>0x0002</td><td>字段是否为 private</td></tr><tr><td>ACC_PROTECTED</td><td>0x0004</td><td>字段是否为 protected</td></tr><tr><td>ACC_STATIC</td><td>0x0008</td><td>字段是否为 static</td></tr><tr><td>ACC_FINAL</td><td>0x0010</td><td>字段是否为 final</td></tr><tr><td>ACC_VOLATILE</td><td>0x0040</td><td>字段是否为 volatile</td></tr><tr><td>ACC_TRANSTENT</td><td>0x0080</td><td>字段是否为 transient</td></tr><tr><td>ACC_SYNCHETIC</td><td>0x1000</td><td>字段是否为由编译器自动产生</td></tr><tr><td>ACC_ENUM</td><td>0x4000</td><td>字段是否为 enum</td></tr></tbody></table></li><li><p><font color="gree">字段名索引</font>：根据该值查询常量池中的指定索引项即可</p></li><li><p><font color="gree">描述符索引</font>：用来描述字段的数据类型、方法的参数列表和返回值</p><table><thead><tr><th>字符</th><th>类型</th><th>含义</th></tr></thead><tbody><tr><td>B</td><td>byte</td><td>有符号字节型树</td></tr><tr><td>C</td><td>char</td><td>Unicode 字符，UTF-16 编码</td></tr><tr><td>D</td><td>double</td><td>双精度浮点数</td></tr><tr><td>F</td><td>float</td><td>单精度浮点数</td></tr><tr><td>I</td><td>int</td><td>整型数</td></tr><tr><td><strong>J</strong></td><td>long</td><td>长整数</td></tr><tr><td>S</td><td>short</td><td>有符号短整数</td></tr><tr><td><strong>Z</strong></td><td>boolean</td><td>布尔值 true/false</td></tr><tr><td>V</td><td>void</td><td>代表 void 类型</td></tr><tr><td><strong>L Classname;</strong></td><td>reference</td><td>一个名为 Classname 的实例</td></tr><tr><td><strong>[</strong></td><td>reference</td><td>一个一维数组</td></tr></tbody></table></li><li><p><font color="gree">属性表集合</font>：属性个数存放在 attribute_count 中，属性具体内容存放在 attribute 数组中，一个字段还可能拥有一些属性，用于存储更多的额外信息，比如初始化值、一些注释信息等</p><pre><code>ConstantValue_attribute&#123;
    u2 attribute_name_index;
    u4 attribute_length;
    u2 constantvalue_index;
&#125;
</code></pre><p>对于常量属性而言，attribute_length 值恒为 2</p></li></ul><h3 id="方法表"><a class="anchor" href="#方法表">#</a> 方法表</h3><p>方法表是 methods 指向常量池索引集合，其中每一个 method_info 项都对应着一个类或者接口中的方法信息，<font color="red">完整描述了每个方法的签名</font></p><ul><li>如果这个方法不是抽象的或者不是 native 的，字节码中就会体现出来</li><li>methods 表<font color="red">只描述当前类或当前接口中声明的方法</font>，不包括从父类或父接口继承的方法</li><li>methods 表<font color="red">可能会出现由编译器自动添加的方法，比如 初始化方法 和 实例化方法</font></li></ul><p>** 重载（Overload）** 一个方法，除了要与原方法具有相同的简单名称之外，还要求必须拥有一个与原方法不同的特征签名，<font color="red">特征签名就是一个方法中各个参数在常量池中的字段符号引用的集合</font>，因为返回值不会包含在特征签名之中，因此 Java 语言里无法仅仅依靠返回值的不同来对一个已有方法进行重载。<font color="red">但在 Class 文件格式中，特征签名的范围更大一些，只要描述符不是完全一致的两个方法就可以共存</font>。</p><p><font color="cornflowerblue">方法计数器（u2，methods_count）</font>：表示 class 文件 methods 表的成员个数，使用两个字节来表示</p><p><font color="cornflowerblue">方法表（method_info，methods [methods_count]）</font>：每个表项都是一个 method_info 结构，表示当前类或接口中某个方法的完整描述</p><ul><li><p>一个方法的组成：</p><ul><li><font color="gree">访问修饰符</font></li><li><font color="gree">方法名称</font></li><li><font color="gree">参数描述</font></li><li><font color="gree">方法的属性数量</font></li><li><font color="gree">方法的属性集合</font></li></ul></li><li><p>方法表结构如下：</p><table><thead><tr><th>类型</th><th>名称</th><th>含义</th><th>数量</th></tr></thead><tbody><tr><td>u2</td><td>access_flags</td><td>访问标志</td><td>1</td></tr><tr><td>u2</td><td>name_index</td><td>方法名索引</td><td>1</td></tr><tr><td>u2</td><td>descriptor_index</td><td>方法参数的描述符索引</td><td>1</td></tr><tr><td>u2</td><td>attrubutes_count</td><td>方法的属性计数器</td><td>1</td></tr><tr><td>attribute_info</td><td>attributes</td><td>方法的属性集合</td><td>attributes_count</td></tr></tbody></table></li><li><p>方法表访问标志：</p><table><thead><tr><th>标志名称</th><th>标志值</th><th>含义</th></tr></thead><tbody><tr><td>ACC_PUBLIC</td><td>0x0001</td><td>字段是否为 public</td></tr><tr><td>ACC_PRIVATE</td><td>0x0002</td><td>字段是否为 private</td></tr><tr><td>ACC_PROTECTED</td><td>0x0004</td><td>字段是否为 protected</td></tr><tr><td>ACC_STATIC</td><td>0x0008</td><td>字段是否为 static</td></tr><tr><td>ACC_FINAL</td><td>0x0010</td><td>字段是否为 final</td></tr><tr><td>ACC_VOLATILE</td><td>0x0040</td><td>字段是否为 volatile</td></tr><tr><td>ACC_TRANSTENT</td><td>0x0080</td><td>字段是否为 transient</td></tr><tr><td>ACC_SYNCHETIC</td><td>0x1000</td><td>字段是否为由编译器自动产生</td></tr><tr><td>ACC_ENUM</td><td>0x4000</td><td>字段是否为 enum</td></tr></tbody></table></li></ul><h3 id="属性表"><a class="anchor" href="#属性表">#</a> 属性表</h3><p>属性表，指的是<font color="red"> Class 文件所携带的辅助信息</font>，比如该 Class 文件的源文件的名称，以及任何带有 <code>RetentionPolicy.CLASS</code> 或者 <code>RetentionPolicy.RUNTIME</code> 的注解，这类信息通常<font color="red">被用于 Java 虚拟机的验证和运行，以及 Java 程序的调试</font>。<strong><font color="red">字段表、方法表都可以有自己的属性表</font></strong>，用于描述某些场景专有的信息</p><p><font color="cornflowerblue">属性计数器（u2，attributes_count）</font>：表示当前文件属性表的成员个数</p><p><font color="cornflowerblue">属性表（attribute_info，attributes [attributes_count]）</font>：属性表的每个项的值必须是 attribute_info 结构</p><ul><li><p><strong>属性的通用格式</strong>：</p><pre><code>ConstantValue_attribute&#123;
    u2 attribute_name_index;	//属性名索引
    u4 attribute_length;		//属性的长度
    u2 attribute_info;			//属性表
&#125;
</code></pre></li><li><p>属性类型：</p><table><thead><tr><th>属性名称</th><th>使用位置</th><th>含义</th></tr></thead><tbody><tr><td>Code</td><td>方法表</td><td>Java 代码编译成的字节码指令</td></tr><tr><td>ConstantValue</td><td>字段表</td><td>final 关键字定义的常量池</td></tr><tr><td>Deprecated</td><td>类、方法、字段表</td><td>被声明为 deprecated 的方法和字段</td></tr><tr><td>Exceptions</td><td>方法表</td><td>方法抛出的异常</td></tr><tr><td>EnclosingMethod</td><td>类文件</td><td>仅当一个类为局部类或者匿名类是才能拥有这个属性，这个属性用于标识这个类所在的外围方法</td></tr><tr><td>InnerClass</td><td>类文件</td><td>内部类列表</td></tr><tr><td>LineNumberTable</td><td>Code 属性</td><td>Java 源码的行号与字节码指令的对应关系</td></tr><tr><td>LocalVariableTable</td><td>Code 属性</td><td>方法的局部变量描述</td></tr><tr><td>StackMapTable</td><td>Code 属性</td><td>JDK1.6 中新增的属性，供新的类型检查检验器检查和处理目标方法的局部变量和操作数有所需要的类是否匹配</td></tr><tr><td>Signature</td><td>类，方法表，字段表</td><td>用于支持泛型情况下的方法签名</td></tr><tr><td>SourceFile</td><td>类文件</td><td>记录源文件名称</td></tr><tr><td>SourceDebugExtension</td><td>类文件</td><td>用于存储额外的调试信息</td></tr><tr><td>Syothetic</td><td>类，方法表，字段表</td><td>标志方法或字段为编泽器自动生成的</td></tr><tr><td>LocalVariableTypeTable</td><td>类</td><td>使用特征签名代替描述符，是为了引入泛型语法之后能描述泛型参数化类型而添加</td></tr><tr><td>RuntimeVisibleAnnotations</td><td>类，方法表，字段表</td><td>为动态注解提供支持</td></tr><tr><td>RuntimelnvisibleAnnotations</td><td>类，方法表，字段表</td><td>用于指明哪些注解是运行时不可见的</td></tr><tr><td>RuntimeVisibleParameterAnnotation</td><td>方法表</td><td>作用与 RuntimeVisibleAnnotations 属性类似，只不过作用对象为方法</td></tr><tr><td>RuntirmelnvisibleParameterAnniotation</td><td>方法表</td><td>作用与 RuntimelnvisibleAnnotations 属性类似，作用对象哪个为方法参数</td></tr><tr><td>AnnotationDefauit</td><td>方法表</td><td>用于记录注解类元素的默认值</td></tr><tr><td>BootstrapMethods</td><td>类文件</td><td>用于保存 invokeddynanic 指令引用的引导方式限定符</td></tr></tbody></table></li></ul><h2 id="2-字节码指令"><a class="anchor" href="#2-字节码指令">#</a> 2、字节码指令</h2><blockquote><p>官网：<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vamF2YXNlL3NwZWNzL2p2bXMvc2U4L2h0bWwvanZtcy02Lmh0bWwjanZtcy02LjU=">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5</span></p></blockquote><h3 id="javac-工具"><a class="anchor" href="#javac-工具">#</a> javac 工具</h3><p>javac：编译命令，<strong><font color="red">将 java 源文件编译成 class 字节码文件</font></strong></p><p>用法： <code>javac xx.java</code> 不会再生成对应的局部变量表等信息，使用 <code>javac -g xx.java</code> 可以生成所有相关信息</p><h3 id="javap-工具"><a class="anchor" href="#javap-工具">#</a> javap 工具</h3><p>javap：<strong><font color="red">反编译生成的 class 字节码文件</font></strong>，反解析出当前类对应的<font color="gree"> code 区 （字节码指令）</font>、<font color="gree">局部变量表</font>、<font color="gree">异常表</font>、<font color="gree">代码行偏移量映射表</font>和<font color="gree">常量池</font>等信息</p><p>用法： <code>javap -v xx.class</code></p><pre><code>-help  --help  -?        输出此用法消息
-version                 版本信息
-public                  仅显示公共类和成员
-protected               显示受保护的/公共类和成员
-package                 显示程序包/受保护的/公共类和成员 (默认)
-p  -private             显示所有类和成员
						 #常用的以下三个
-v  -verbose             输出附加信息
-l                       输出行号和本地变量表
-c                       对代码进行反汇编	#反编译

-s                       输出内部类型签名
-sysinfo                 显示正在处理的类的系统信息 (路径, 大小, 日期, MD5 散列)
-constants               显示最终常量
-classpath &lt;path&gt;        指定查找用户类文件的位置
-cp &lt;path&gt;               指定查找用户类文件的位置
-bootclasspath &lt;path&gt;    覆盖引导类文件的位置
</code></pre><h3 id="图解方法的执行流程"><a class="anchor" href="#图解方法的执行流程">#</a> 图解：方法的执行流程</h3><h4 id="1原始-java-代码"><a class="anchor" href="#1原始-java-代码">#</a> 1）原始 java 代码</h4><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 演示 字节码指令 和 操作数栈、常量池的关系</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo3_1</span> <span class="token punctuation">&#123;</span>    </pre></td></tr><tr><td data-num="3"></td><td><pre>	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        </pre></td></tr><tr><td data-num="4"></td><td><pre>		<span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>        </pre></td></tr><tr><td data-num="5"></td><td><pre>		<span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token class-name">Short</span><span class="token punctuation">.</span><span class="token constant">MAX_VALUE</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        </pre></td></tr><tr><td data-num="6"></td><td><pre>		<span class="token keyword">int</span> c <span class="token operator">=</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>        </pre></td></tr><tr><td data-num="7"></td><td><pre>		<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>   </pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h4 id="2编译后的字节码文件"><a class="anchor" href="#2编译后的字节码文件">#</a> 2）编译后的字节码文件</h4><p>通过 javap 工具对字节码文件进行反编译</p><h4 id="3常量池载入运行时常量池"><a class="anchor" href="#3常量池载入运行时常量池">#</a> 3）常量池载入<strong>运行时常量池</strong></h4><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230927094818385.png" alt="image-20230927094818385"></p><h4 id="4方法字节码载入方法区"><a class="anchor" href="#4方法字节码载入方法区">#</a> 4）方法字节码载入<strong>方法区</strong></h4><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230927095219061.png" alt="image-20230927095219061"></p><h4 id="5main-线程开始运行分配栈帧内存"><a class="anchor" href="#5main-线程开始运行分配栈帧内存">#</a> 5）main 线程开始运行，分配<strong>栈帧</strong>内存</h4><p>（局部变量表 locals=4，操作数栈 stack=2）</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230927095114023.png" alt="image-20230927095114023"></p><h4 id="6执行引擎开始执行字节码"><a class="anchor" href="#6执行引擎开始执行字节码">#</a> 6）<strong>执行引擎</strong>开始执行字节码</h4><p>首先回顾一下 8 种基本数据类型各自所占用的字节数：</p><table><thead><tr><th>基本数据类型</th><th>占用字节数</th><th>取值范围</th></tr></thead><tbody><tr><td>byte</td><td>1 字节</td><td>-128（-2<sup>7</sup>）~ 127（2<sup>7</sup>-1），默认为 0</td></tr><tr><td>boolean</td><td>至少 1 字节（根据编译环境而定）</td><td>只作为一种标志来记录 true/false 情况，默认为 false</td></tr><tr><td>short</td><td>2 字节</td><td>-32768(-2<sup>15</sup>) ~ 32767(2<sup>15</sup>-1)，默认为 0</td></tr><tr><td>char</td><td>2 字节</td><td>最小值是 <strong>\u0000</strong>（即为 0）；最大值是 <strong>\uffff</strong>（即为 65,535）；默认为 \u0000</td></tr><tr><td>int</td><td>4 字节</td><td>-2<sup>31</sup> ~ 2<sup>31</sup>-1，默认为 0</td></tr><tr><td>long</td><td>8 字节</td><td>-2<sup>63</sup> ~ 2<sup>63</sup>-1，默认为 0</td></tr><tr><td>float</td><td>4 字节</td><td>单精度浮点数字长 32 位，尾数长度 23，指数长度 8, 指数偏移量 127；默认为 0.0f</td></tr><tr><td>double</td><td>8 字节</td><td>双精度浮点数字长 64 位，尾数长度 52，指数长度 11，指数偏移量 1023；默认为 0.0d</td></tr></tbody></table><h5 id="int-a-10"><a class="anchor" href="#int-a-10">#</a> int a = 10</h5><h6 id="bipush-10"><a class="anchor" href="#bipush-10">#</a> bipush 10</h6><p><strong>将一个 byte （占 1 字节）类型的值压入操作数栈</strong></p><blockquote><ul><li>因为 10 在 -128~127 之间，属于 byte ，占用 1 个字节</li><li>而<font color="red">操作数栈的宽度是 4 个字节</font>，但是 10 仅占 1 个字节，因此操作数栈的长度会通过填 0/1 来补齐</li></ul></blockquote><p>类似的指令还有：</p><ul><li>sipush 将一个 short 压入操作数栈（其长度会补齐 4 个字节）</li><li>ldc 将一个 int 压入操作数栈</li><li>ldc2_w 将一个 long 压入操作数栈（<font color="red">分两次压入</font>，因为 long 是 8 个字节）</li><li><strong><font color="red">小的数字都是和字节码指令存在一起，超过 short 范围的数字存入了常量池，需要引用</font></strong></li></ul><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230927100649301.png" alt="image-20230927100649301"></p><h6 id="istore-1"><a class="anchor" href="#istore-1">#</a> istore 1</h6><p>将操作数栈的栈顶数据弹出，存入局部变量表的 slot 1</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230927113307176.png" alt="image-20230927113307176"></p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230927113312719.png" alt="image-20230927113312719"></p><h5 id="int-b-shortmax_value-1"><a class="anchor" href="#int-b-shortmax_value-1">#</a> int b = Short.MAX_VALUE + 1</h5><h6 id="ldc-3"><a class="anchor" href="#ldc-3">#</a> ldc #3</h6><p>从 **<font color="red">运行时常量池</font>** 加载 #3 数据到操作数栈</p><blockquote><p>注意 Short.MAX_VALUE 是 32767，所以 32768 = Short.MAX_VALUE + 1 实际是在编译期间计算好的（<font color="red">常量折叠</font>），<font color="red">因其超过了 Short 的范围，所以存入了常量池中，只能通过引用获取</font></p></blockquote><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230927113704346.png" alt="image-20230927113704346"></p><h6 id="istore-2"><a class="anchor" href="#istore-2">#</a> istore 2</h6><p>将操作数栈的栈顶数据弹出，存入局部变量表的 slot 2</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230927114136275.png" alt="image-20230927114136275"></p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230927114142111.png" alt="image-20230927114142111"></p><h5 id="int-c-a-b"><a class="anchor" href="#int-c-a-b">#</a> int c = a + b</h5><h6 id="iload_1"><a class="anchor" href="#iload_1">#</a> iload_1</h6><p>将局部变量表的 slot 1 数据压入操作数栈</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230927114708877.png" alt="image-20230927114708877"></p><h6 id="iload_2"><a class="anchor" href="#iload_2">#</a> iload_2</h6><p>将局部变量表的 slot 2 数据压入操作数栈</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230927114722537.png" alt="image-20230927114722537"></p><h6 id="iadd"><a class="anchor" href="#iadd">#</a> iadd</h6><p><strong><font color="red">在操作数栈中执行相加操作</font></strong></p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230927114742467.png" alt="image-20230927114742467"></p><p>将操作数弹出，将相加的结果压入栈</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230927114830526.png" alt="image-20230927114830526"></p><h6 id="istore_3"><a class="anchor" href="#istore_3">#</a> istore_3</h6><p>将操作数栈的栈顶数据（相加的结果）弹出，存入局部变量表的 slot 3</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230927114916175.png" alt="image-20230927114916175"></p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230927115059701.png" alt="image-20230927115059701"></p><h5 id="systemoutprintlnc"><a class="anchor" href="#systemoutprintlnc">#</a> System.out.println(c)</h5><h6 id="getstatic-4"><a class="anchor" href="#getstatic-4">#</a> getstatic #4</h6><p>从运行时常量池中找到 #4 项 —— 成员变量的引用，即 System 的 out 字段，找到堆中的 System.out 对象，将其<font color="red">引用</font>压入操作数栈中</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230927115229920.png" alt="image-20230927115229920"></p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230927115250117.png" alt="image-20230927115250117"></p><h6 id="iload_3"><a class="anchor" href="#iload_3">#</a> iload_3</h6><p>将局部变量表的 slot 3 数据压入操作数栈</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230927115414899.png" alt="image-20230927115414899"></p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230927115335556.png" alt="image-20230927115335556"></p><h6 id="invokevirtual-5"><a class="anchor" href="#invokevirtual-5">#</a> invokevirtual #5</h6><ul><li>找到运行时常量池中的 #5 项，即方法的引用</li><li>定位到方法区 java/io/PrintStream.println:(I) V 方法</li><li><strong>为新调用的方法生成新的栈帧</strong>（分配 locals、stack 等）</li><li>传递参数，执行新栈帧中的字节码</li></ul><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230927115523537.png" alt="image-20230927115523537"></p><ul><li><font color="red">执行完毕，弹出栈帧</font></li><li>清除 main 操作数栈内容</li></ul><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230927115635271.png" alt="image-20230927115635271"></p><h5 id="return"><a class="anchor" href="#return">#</a> return</h5><ul><li><p><font color="red">完成 main 方法调用，弹出 main 栈帧</font></p></li><li><p>程序结束</p></li></ul><h3 id="练习分析i"><a class="anchor" href="#练习分析i">#</a> 练习：分析 i++</h3><p>目的：从字节码的角度，分析 a++ 相关题目</p><p>源码：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token keyword">int</span> b <span class="token operator">=</span> a<span class="token operator">++</span> <span class="token operator">+</span> <span class="token operator">++</span>a <span class="token operator">+</span> a<span class="token operator">--</span><span class="token punctuation">;</span> <span class="token comment">//10 + 12 + 12</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">//11</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">//34</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>分析：</p><ul><li><p><font color="red">iinc 指令：直接在局部变量表的 slot 上进行运算</font></p></li><li><p><strong><font color="red">a++ 和 ++a 的区别：先执行 iload 还是 iinc</font></strong>，二者的字节码指令对应如下：</p><pre><code> 4 iload_1		//存入操作数栈
 5 iinc 1 by 1	//自增i++
 8 istore_3		//把操作数栈没有自增的数据的存入局部变量表
 
 9 iinc 2 by 1	//++i
12 iload_2		//加载到操作数栈
13 istore 4		//存入局部变量表，这个存入没有 _ 符号，_只能到3
</code></pre></li></ul><h4 id="int-a-10-2"><a class="anchor" href="#int-a-10-2">#</a> int a = 10</h4><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230927151854418.png" alt="image-20230927151854418"></p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230927151938029.png" alt="image-20230927151938029"></p><h4 id="int-b-a-a-a-"><a class="anchor" href="#int-b-a-a-a-">#</a> int b = a++ + ++a + a--</h4><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230927152108793.png" alt="image-20230927152108793"></p><p>对局部变量表中的 slot 1 数据自增 1</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230927152156880.png" alt="image-20230927152156880"></p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230927152325762.png" alt="image-20230927152325762"></p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230927152348727.png" alt="image-20230927152348727"></p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230927152414569.png" alt="image-20230927152414569"></p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230927152444354.png" alt="image-20230927152444354"></p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230927152449972.png" alt="image-20230927152449972"></p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230927152457700.png" alt="image-20230927152457700"></p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230927152544313.png" alt="image-20230927152544313"></p><h3 id="条件判断-指令"><a class="anchor" href="#条件判断-指令">#</a> 条件判断 指令</h3><table><thead><tr><th>指令</th><th>助记符</th><th>说明</th></tr></thead><tbody><tr><td>0x99</td><td>ifeq</td><td>equals，当栈顶 int 类型数值 == 0 时跳转</td></tr><tr><td>0x9a</td><td>ifne</td><td>not equals，当栈顶 int 类型数值！= 0 时跳转</td></tr><tr><td>0x9b</td><td>iflt</td><td>lower than，当栈顶 int 类型数值 &lt; 0 时跳转</td></tr><tr><td>0x9c</td><td>ifge</td><td>greater or equals，当栈顶 in 类型数值 &gt;= 0 时跳转</td></tr><tr><td>0x9d</td><td>ifgt</td><td>greater than，当栈顶 int 类型数组 &gt; 0 时跳转</td></tr><tr><td>0x9e</td><td>ifle</td><td>lower or equals，当栈顶 in 类型数值 &lt;= 0 时跳转</td></tr><tr><td>0x9f</td><td>if_icmpeq</td><td>两个 int == 时跳转</td></tr><tr><td>0xa0</td><td>if_icmpne</td><td>两个 int != 时跳转</td></tr><tr><td>0xa1</td><td>if_icmplt</td><td>两个 int &lt; 时跳转</td></tr><tr><td>0xa2</td><td>if_icmpge</td><td>两个 int &gt;= 时跳转</td></tr><tr><td>0xa3</td><td>if_icmpgt</td><td>两个 int &gt; 时跳转</td></tr><tr><td>0xa4</td><td>if_icmple</td><td>两个 int &lt;= 时跳转</td></tr><tr><td>0xa5</td><td>if_acmpeq</td><td>两个引用 == 时跳转</td></tr><tr><td>0xa6</td><td>if_acmpne</td><td>两个引用！= 时跳转</td></tr><tr><td>0xc6</td><td>ifnull</td><td>为 null 时跳转</td></tr><tr><td>0xc7</td><td>ifnonnull</td><td>不为 null 时跳转</td></tr></tbody></table><p>多条件分支跳转指令：</p><ul><li>tableswitch：用于 switch 条件跳转，case 值连续</li><li>lookupswitch：用于 switch 条件跳转，case 值不连续</li></ul><p>无条件跳转指令：</p><ul><li><strong>goto</strong>：用来进行跳转到指定行号的字节码</li><li>goto_w：无条件跳转（宽索引）</li></ul><p>例如，对于源码：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo3_3</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token keyword">if</span><span class="token punctuation">(</span>a <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        	a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        	a <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>对应字节码：</p><pre><code>0: iconst_0
1: istore_1
2: iload_1
3: ifne 12
6: bipush 10
8: istore_1
9: goto 15
12: bipush 20
14: istore_1
15: return
</code></pre><h3 id="循环控制-指令"><a class="anchor" href="#循环控制-指令">#</a> 循环控制 指令</h3><p>其实循环控制还是前面介绍的那些指令，例如 while 循环：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo3_4</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token keyword">while</span> <span class="token punctuation">(</span>a <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>            a<span class="token operator">++</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>字节码：</p><pre><code>0: iconst_0
1: istore_1
2: iload_1
3: bipush 10
5: if_icmpge 14
8: iinc 1, 1
11: goto 2
14: return
</code></pre><p>再比如 do while 循环：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo3_5</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token keyword">do</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>            a<span class="token operator">++</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token punctuation">&#125;</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>a <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>字节码：</p><pre><code>0: iconst_0
1: istore_1
2: iinc 1, 1
5: iload_1
6: bipush 10
8: if_icmplt 2
11: return
</code></pre><p>for 循环：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo3_6</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>字节码是：</p><pre><code>0: iconst_0
1: istore_1
2: iload_1
3: bipush 10
5: if_icmpge 14
8: iinc 1, 1
11: goto 2
14: return
</code></pre><blockquote><p>注意：比较 while 和 for 的字节码，你发现它们是一模一样的，殊途也能同归😊</p></blockquote><h3 id="练习判断结果"><a class="anchor" href="#练习判断结果">#</a> 练习：判断结果</h3><p>请从字节码角度分析，下列代码运行的结果：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo3_6_1</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// iconst_0 ; istore_1</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// bipush 0 ; istore_2</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">//iload_1 ; bipush 10; if_icmpge 跳过 while</span></pre></td></tr><tr><td data-num="6"></td><td><pre>            x <span class="token operator">=</span> x<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">//iload_1 （将 0 加载到操作数栈）; iinc 2 by 1 （对临时变量表中的 x 自增 1）; istore_2（将操作数栈的栈顶元素 0 赋给临时变量表中的 x，x 从 1 变成 0）</span></pre></td></tr><tr><td data-num="7"></td><td><pre>            i<span class="token operator">++</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 结果是 0</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id="构造方法"><a class="anchor" href="#构造方法">#</a> 构造方法</h3><h4 id="clinitv"><a class="anchor" href="#clinitv">#</a> &lt;clinit&gt;()V</h4><blockquote><p>cl 代表 class，意为<strong>整个类</strong>的构造方法</p></blockquote><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo3_8_1</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">static</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    </pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">static</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    	i <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="7"></td><td><pre>    </pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">static</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    	i <span class="token operator">=</span> <span class="token number">30</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><font color="red">编译器会按<strong>从上至下</strong>的顺序，收集所有静态代码块、静态成员赋值的代码，<strong>合并为一个特殊的方法 &lt;clinit&gt;() V</strong> </font>：</p><pre><code>0: bipush 10
2: putstatic #2 // Field i:I
5: bipush 20
7: putstatic #2 // Field i:I
10: bipush 30
12: putstatic #2 // Field i:I
15: return
</code></pre><p><font color="red">&lt;clinit&gt;() V 方法会在<strong>类加载的初始化阶段</strong>被调用</font>。</p><h4 id="initv"><a class="anchor" href="#initv">#</a> &lt;init&gt;()V</h4><blockquote><p><strong>每个实例对象</strong>的构造方法</p></blockquote><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo3_8_2</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">private</span> <span class="token class-name">String</span> a <span class="token operator">=</span> <span class="token string">"s1"</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    	b <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    	a <span class="token operator">=</span> <span class="token string">"s2"</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">Demo3_8_2</span><span class="token punctuation">(</span><span class="token class-name">String</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token operator">=</span> a<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token keyword">this</span><span class="token punctuation">.</span>b <span class="token operator">=</span> b<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token class-name">Demo3_8_2</span> d <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Demo3_8_2</span><span class="token punctuation">(</span><span class="token string">"s3"</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>d<span class="token punctuation">.</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>d<span class="token punctuation">.</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><font color="red">编译器会按<strong>从上至下</strong>的顺序，收集所有 {} 代码块、成员变量赋值的代码，<strong>形成新的构造方法</strong>，并<strong>将原始构造方法内的代码附加在最后</strong></font>。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230927163103068.png" alt="image-20230927163103068"></p><h3 id="方法调用-指令"><a class="anchor" href="#方法调用-指令">#</a> 方法调用 指令</h3><p>普通调用指令：</p><ul><li><code>invokestatic</code> ：调用<font color="red">静态方法</font></li><li><code>invokespecial</code> ：调用<font color="red">私有方法、构造器</font>，和父类的实例方法或构造器，以及所实现接口的默认方法</li><li><code>invokevirtual</code> ：调用所有<font color="red">虚方法（虚方法分派）</font></li><li><code>invokeinterface</code> ：调用接口方法</li></ul><p>动态调用指令：</p><ul><li><code>invokedynamic</code> ：动态解析出需要调用的方法<ul><li>Java7 为了实现动态类型语言支持而引入了该指令，但是并没有提供直接生成 invokedynamic 指令的方法，需要借助 ASM 这种底层字节码工具来产生 invokedynamic 指令</li><li>Java8 的 lambda 表达式的出现，invokedynamic 指令在 Java 中才有了直接生成方式</li></ul></li></ul><p>指令对比：</p><ul><li>普通调用指令固化在虚拟机内部，方法的调用执行不可干预，根据方法的符号引用链接到具体的目标方法</li><li>动态调用指令支持用户确定方法</li><li><font color="red">invokestatic 和 invokespecial 指令调用的方法称为<strong>非虚方法，虚拟机能够直接识别具体的目标方法</strong></font></li><li><font color="red">invokevirtual 和 invokeinterface 指令调用的方法称为<strong>虚方法，虚拟机需要在执行过程中根据调用者的动态类型来确定目标方法</strong></font></li></ul><p>指令说明：</p><ul><li>如果虚拟机能够确定目标方法有且仅有一个，比如说目标方法被标记为 final，那么可以不通过动态绑定，直接确定目标方法</li><li>普通成员方法是由 invokevirtual 调用，属于<strong>动态绑定</strong>，即支持多态</li></ul><p>举个例子，看一下几种不同的方法调用对应的字节码指令：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo3_9</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">Demo3_9</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">test1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">test2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test3</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">test4</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token class-name">Demo3_9</span> d <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Demo3_9</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        d<span class="token punctuation">.</span><span class="token function">test1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        d<span class="token punctuation">.</span><span class="token function">test2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        d<span class="token punctuation">.</span><span class="token function">test3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        d<span class="token punctuation">.</span><span class="token function">test4</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token class-name">Demo3_9</span><span class="token punctuation">.</span><span class="token function">test4</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>字节码：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token number">0</span><span class="token operator">:</span> <span class="token keyword">new</span> #<span class="token number">2</span> <span class="token comment">// class cn/itcast/jvm/t3/bytecode/Demo3_9</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token number">3</span><span class="token operator">:</span> dup</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token number">4</span><span class="token operator">:</span> invokespecial #<span class="token number">3</span> <span class="token comment">// Method "&lt;init>":()V</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token number">7</span><span class="token operator">:</span> astore_1</pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token number">8</span><span class="token operator">:</span> aload_1</pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token number">9</span><span class="token operator">:</span> invokespecial #<span class="token number">4</span> <span class="token comment">// Method test1:()V</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token number">12</span><span class="token operator">:</span> aload_1</pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token number">13</span><span class="token operator">:</span> invokespecial #<span class="token number">5</span> <span class="token comment">// Method test2:()V</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token number">16</span><span class="token operator">:</span> aload_1</pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token number">17</span><span class="token operator">:</span> invokevirtual #<span class="token number">6</span> <span class="token comment">// Method test3:()V</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token number">20</span><span class="token operator">:</span> aload_1</pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token number">21</span><span class="token operator">:</span> pop</pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token number">22</span><span class="token operator">:</span> invokestatic #<span class="token number">7</span> <span class="token comment">// Method test4:()V</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token number">25</span><span class="token operator">:</span> invokestatic #<span class="token number">7</span> <span class="token comment">// Method test4:()V</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token number">28</span><span class="token operator">:</span> <span class="token keyword">return</span></pre></td></tr></table></figure><ul><li><code>new</code> 是创建【对象】，给对象分配堆内存，执行成功 **<font color="red">会将【对象引用】压入操作数栈</font>**</li><li><code>dup</code> 是 **<font color="red">复制操作数栈栈顶的内容，并压入栈顶</font>**。本例即为复制一份【对象引用】，为什么需要两份引用呢，一个是要配合 invokespecial 调用该对象的构造方法 &quot;&lt;init&gt;&quot;😦)V （<font color="red">会消耗掉栈顶一个引用</font>），另一个要配合 astore_1 赋值给局部变量（<font color="red">又消耗栈顶一个引用</font>）</li><li>最终方法（final），私有方法（private），构造方法都是由 <code>invokespecial</code> 指令来调用，属于<strong>静态绑定</strong></li><li>普通成员方法是由 <code>invokevirtual</code> 调用，属于<strong>动态绑定</strong>，即支持多态</li><li>成员方法与静态方法调用的另一个区别是，执行方法前<font color="red">是否需要【对象引用】</font></li><li>比较有意思的是 d.test4 (); 是通过【对象引用】调用一个静态方法，可以看到在调用 invokestatic 之前执行了 pop 指令，把【对象引用】从操作数栈弹掉了😂</li><li>还有一个执行 invokespecial 的情况是通过 super 调用父类方法</li></ul><h3 id="多态的原理"><a class="anchor" href="#多态的原理">#</a> 多态的原理</h3><blockquote><p>详见 pdf</p></blockquote><p>当执行 <code>invokevirtual</code> 指令时，</p><ol><li>先通过栈帧中的对象引用找到对象</li><li>分析对象头，找到对象的实际 Class</li><li>Class 结构中有<font color="cornflowerblue">虚方法表 vtable</font>，它在类加载的链接阶段就已经根据方法的重写规则生成好了</li><li>查找虚方法表，得到方法的具体地址</li><li>执行方法的字节码</li></ol><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/20160812143114843" alt="img"></p><h3 id="异常处理"><a class="anchor" href="#异常处理">#</a> 异常处理</h3><h4 id="try-catch"><a class="anchor" href="#try-catch">#</a> try-catch</h4><p>源码：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo3_11_1</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        	i <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        	i <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>字节码（省略了不重要的部分）：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230928000437382.png" alt="image-20230928000437382"></p><ul><li>可以看到多出来一个 <strong>异常表 Exception table</strong> 的结构，[from, to) 是前闭后开的检测范围，一旦这个范围内的字节码执行出现异常，则通过 type 匹配异常类型，如果一致，进入 target 所指示行号</li><li>8 行的字节码指令 <strong>astore_2</strong> 是将<font color="red">异常对象引用</font> e 存入局部变量表的 slot 2 位置</li></ul><h4 id="多个-single-catch-块"><a class="anchor" href="#多个-single-catch-块">#</a> 多个 single-catch 块</h4><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo3_11_2</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        	i <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ArithmeticException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        	i <span class="token operator">=</span> <span class="token number">30</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">NullPointerException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        	i <span class="token operator">=</span> <span class="token number">40</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        	i <span class="token operator">=</span> <span class="token number">50</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>因为异常出现时，只能进入 Exception table 中一个分支，所以局部变量表 slot 2 位置被共用：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230928001745610.png" alt="image-20230928001745610"></p><h4 id="multi-catch"><a class="anchor" href="#multi-catch">#</a> multi-catch</h4><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo3_11_3</span> <span class="token punctuation">&#123;</span><span class="token keyword">finally</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        	<span class="token class-name">Method</span> test <span class="token operator">=</span> <span class="token class-name">Demo3_11_3</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        	test<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">NoSuchMethodException</span> <span class="token operator">|</span> <span class="token class-name">IllegalAccessException</span> <span class="token operator">|</span> <span class="token class-name">InvocationTargetException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        	e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>     <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>     <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"ok"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230928002232897.png" alt="image-20230928002232897"></p><h4 id="finally"><a class="anchor" href="#finally">#</a> finally</h4><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo3_11_4</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        	i <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        	i <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        	i <span class="token operator">=</span> <span class="token number">30</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><font color="red">可以看到 finally 中的代码被复制了 3 份，分别放入 try 流程，catch 流程、 <strong>catch 剩余的异常类型</strong> 的流程</font>。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230928003413523.png" alt="image-20230928003413523"></p><h3 id="练习finally面试题"><a class="anchor" href="#练习finally面试题">#</a> 练习：finally 面试题</h3><blockquote><p>总结：如果 finally 块中出现了 return，返回结果肯定以它为准。但此时就不会正常抛出异常了。因此，不建议在 finally 块中进行 return。</p></blockquote><h4 id="finally块中出现了return"><a class="anchor" href="#finally块中出现了return">#</a> finally 块中出现了 return</h4><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo3_12_2</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 20</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre>	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        	<span class="token keyword">return</span> <span class="token number">10</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        	<span class="token keyword">return</span> <span class="token number">20</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>对应的字节码：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230928111512962.png" alt="image-20230928111512962"></p><ul><li>由于 ﬁnally 中的 ireturn 被插入了所有可能的流程，因此<font color="red">返回结果肯定以ﬁnally 的为准</font></li><li>至于字节码中第 2 行，似乎没啥用，且留个伏笔，看下个例子</li><li>跟上例中的 ﬁnally 相比，发现没有 athrow 了，这告诉我们：<font color="red">如果在 ﬁnally 中出现了 return，会吞掉异常</font></li><li>所以<font color="red">不要在 finally 中进行返回操作</font></li></ul><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo3_12_1</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        	<span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token operator">/</span><span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        	<span class="token keyword">return</span> <span class="token number">10</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        	<span class="token keyword">return</span> <span class="token number">20</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>会发现打印结果为 20 ，并未抛出异常。</p><h4 id="finally块对返回值的影响"><a class="anchor" href="#finally块对返回值的影响">#</a> finally 块对返回值的影响</h4><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo3_12_2</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 10</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        	<span class="token keyword">return</span> i<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        	i <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230928111944576.png" alt="image-20230928111944576"></p><h3 id="同步控制-synchronized块"><a class="anchor" href="#同步控制-synchronized块">#</a> 同步控制 synchronized 块</h3><blockquote><p>当临界区中的代码出现异常时，如何确保正确地释放锁？</p></blockquote><p>方法内指定指令序列的同步：有 monitorenter 和 monitorexit 两条指令来支持 synchronized 关键字的语义</p><ul><li><code>montiorenter</code> ：进入并获取对象监视器，即为栈顶对象加锁</li><li><code>monitorexit</code> ：释放并退出对象监视器，即为栈顶对象解锁</li></ul><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230928114017078.png" alt="image-20230928114017078"></p><blockquote><p><font color="red">对于方法级的同步（即添加 synchronized 关键词到方法上），它是隐式的，无须通过字节码指令来控制</font>，它实现在方法调用和返回操作之中，虚拟机可以从方法常量池的方法表结构中的 ACC_SYNCHRONIZED 访问标志得知一个方法是否声明为同步方法。</p></blockquote><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo3_13</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token class-name">Object</span> lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>lock<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        	<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"ok"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    	<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230928124410943.png" alt="image-20230928124410943"></p><ul><li><code>new</code> 是创建【对象】，即 lock 对象，给对象分配堆内存，执行成功 **<font color="red">会将【对象引用】压入操作数栈</font>**</li><li><code>dup</code> 是 **<font color="red">复制操作数栈栈顶的内容，并压入栈顶</font>**。本例即为复制一份 lock 的【对象引用】：<ul><li>一份是要配合 invokespecial 调用其构造方法 &quot;&lt;init&gt;&quot;😦)V</li><li>另一份要配合 astore_1 赋值给局部变量表的 slot 1</li></ul></li><li><font color="red">25~27 指令旨在释放 lock，如若出现异常，会反复尝试，直至成功，然后抛出异常</font>。</li></ul><h2 id="3-编译期处理代码优化"><a class="anchor" href="#3-编译期处理代码优化">#</a> 3、编译期处理（代码优化）</h2><h3 id="语法糖"><a class="anchor" href="#语法糖">#</a> 语法糖</h3><p>指 Java 编译器把 <code>*.java</code> 源码编译为 <code>*.class</code> 字节码的过程中，<font color="red">自动生成和转换的一些代码</font>，主要是为了减轻程序员的负担。</p><blockquote><p>注意，以下代码的分析，借助了 javap 工具，idea 的反编译功能，idea 插件 jclasslib 等工具。另外，编译器转换的结果直接就是 class 字节码，只是为了便于阅读，给出了 几乎等价 的 java 源码方式，并不是编译器还会转换出中间的 java 源码，切记。</p></blockquote><h3 id="默认构造器"><a class="anchor" href="#默认构造器">#</a> 默认构造器</h3><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Candy1</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>编译成 class 后的等价代码：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Candy1</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 这个无参构造是编译器帮助我们加上的</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">Candy1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 即调用父类 Object 的无参构造方法，即调用 java/lang/Object."&lt;init>":() V</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id="自动拆装箱"><a class="anchor" href="#自动拆装箱">#</a> 自动拆装箱</h3><blockquote><p>在 JDK 5 引入</p></blockquote><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">Integer</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">int</span> y <span class="token operator">=</span> x<span class="token punctuation">;</span></pre></td></tr></table></figure><p>这段代码在 JDK 5 之前是无法编译通过的，必须改写为：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">Integer</span> x <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 装箱：基本类型 -> 包装类型</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">int</span> y <span class="token operator">=</span> x<span class="token punctuation">.</span><span class="token function">intValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 拆箱：包装类型 -> 基本类型</span></pre></td></tr></table></figure><p>JDK5 以后编译阶段自动转换成上述片段。</p><h3 id="泛型集合取值泛型擦除"><a class="anchor" href="#泛型集合取值泛型擦除">#</a> 泛型集合取值（泛型擦除）</h3><blockquote><p>泛型也是在 JDK 5 开始加入的特性</p></blockquote><p>Java 在编译泛型代码后会执行<strong>泛型擦除</strong>的动作，即<font color="red">泛型信息在编译为字节码之后就丢失了</font>，实际的类型都 **<font color="red">当做了 Object 类型</font>** 来处理：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 实际调用的是 List.add (Object e)，参数类型是 Object，而非 Integer，泛型信息 Integer 被擦除了</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token class-name">Integer</span> x <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 实际调用的是 Object obj = List.get (int index)，实际返回的是 Object，而非 Integer，泛型信息 Integer 被擦除了</span></pre></td></tr></table></figure><p>所以在取值时，编译器真正生成的字节码中，还要额外做一个<font color="red">类型转换</font>的操作：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 需要将 Object 转为 Integer</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name">Integer</span> x <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Integer</span><span class="token punctuation">)</span>list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>如果前面的 x 变量类型修改为 int 基本类型，那么还要额外做一个<font color="red">自动拆箱</font>的操作，最终生成的字节码是：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 需要将 Object 转为 Integer, 并执行拆箱操作</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">Integer</span><span class="token punctuation">)</span>list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">intValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>这些转换都是编译器帮我们做的。</p><h3 id="可变参数"><a class="anchor" href="#可变参数">#</a> 可变参数</h3><blockquote><p>JDK 5 引入的特性</p></blockquote><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Candy4</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array <span class="token operator">=</span> args<span class="token punctuation">;</span> <span class="token comment">// 直接赋值</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    	<span class="token function">foo</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">,</span> <span class="token string">"world"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><strong><font color="red">可变参数 <code>String... args</code> 其实是一个 <code>String[] args</code> </font></strong>，从代码中的赋值语句中就可以看出来。<br>同样 java 编译器会在编译期间将上述代码变换为：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Candy4</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    	<span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array <span class="token operator">=</span> args<span class="token punctuation">;</span> <span class="token comment">// 直接赋值</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    	<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    	<span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">&#123;</span><span class="token string">"hello"</span><span class="token punctuation">,</span> <span class="token string">"world"</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将参数包装成 String []</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>注意：如果调用的是无参 <code>foo()</code> 则等价代码为 <code>foo(new String[]&#123;&#125;)</code> ，创建了一个空的数组，而不会传递 null 进去</p></blockquote><h3 id="foreach-循环"><a class="anchor" href="#foreach-循环">#</a> foreach 循环</h3><blockquote><p>JDK 5</p></blockquote><p><font color="gree">数组</font>的循环：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token comment">// 语法糖 1：数组赋初值的简化写</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> e <span class="token operator">:</span> array<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 语法糖 2</span></pre></td></tr><tr><td data-num="3"></td><td><pre>	<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>对于语法糖 2，编译后为<font color="red">遍历下标取数</font>：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> array<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>	<span class="token keyword">int</span> e <span class="token operator">=</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>	<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><font color="gree">集合</font>的循环：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> list <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Integer</span> i <span class="token operator">:</span> list<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>	<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>编译后转换为<font color="red">对迭代器的调用</font>：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> list <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name">Iterator</span> iter <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">while</span><span class="token punctuation">(</span>iter<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token class-name">Integer</span> e <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Integer</span><span class="token punctuation">)</span>iter<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 因为泛型擦除，所以需要强转</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>注意：foreach 循环写法，能够配合以下结构一起使用：</p><ol><li>数组</li><li>实现了 Iterable 接口的集合类，其中 Iterable 用来获取集合的迭代器</li></ol></blockquote><h3 id="switch-字符串"><a class="anchor" href="#switch-字符串">#</a> switch 字符串</h3><blockquote><p>JDK 7</p></blockquote><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">switch</span> <span class="token punctuation">(</span>str<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">case</span> <span class="token string">"hello"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"h"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token keyword">break</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">case</span> <span class="token string">"world"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"w"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token keyword">break</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>注意：<strong>switch 配合 String 和枚举使用时，变量不能为 null，因为编译时会调用其 <code>hashCode()</code> 方法、 <code>equals()</code> 方法</strong>。</p></blockquote><p>会被编译器转换为：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">byte</span> x <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">switch</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 1. 先通过 hashCode () 来快速比较判断</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">case</span> <span class="token number">99162322</span><span class="token operator">:</span> <span class="token comment">//hello 的 hashCode</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 2. 再借助 equals () 比较，防止哈希冲突</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        	x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    	<span class="token keyword">break</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">case</span> <span class="token number">113318802</span><span class="token operator">:</span> <span class="token comment">//world 的 hashCode</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"world"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        	x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token keyword">switch</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token keyword">case</span> <span class="token number">0</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    	<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"h"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    	<span class="token keyword">break</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token keyword">case</span> <span class="token number">1</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    	<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"w"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>        <span class="token keyword">break</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>总结：</p><ul><li>执行了两遍 switch，第一遍是根据字符串的 hashCode 和 equals 将字符串的转换为相应 byte 类型，第二遍才是利用 byte 执行进行比较</li><li><font color="red">hashCode 是为了提高效率，减少可能的比较</font>；而 <font color="red">equals 是为了防止 hashCode 冲突</font></li></ul><h3 id="switch-枚举"><a class="anchor" href="#switch-枚举">#</a> switch 枚举</h3><blockquote><p>JDK 7</p></blockquote><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">enum</span> <span class="token class-name">Sex</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>	<span class="token constant">MALE</span><span class="token punctuation">,</span> <span class="token constant">FEMALE</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Candy7</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token class-name">Sex</span> sex<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token keyword">switch</span> <span class="token punctuation">(</span>sex<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>            <span class="token keyword">case</span> <span class="token constant">MALE</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="8"></td><td><pre>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"男"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="9"></td><td><pre>                <span class="token keyword">break</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>            <span class="token keyword">case</span> <span class="token constant">FEMALE</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="11"></td><td><pre>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"女"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="12"></td><td><pre>                <span class="token keyword">break</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>	<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>编译转换后的代码：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">/**</span></pre></td></tr><tr><td data-num="2"></td><td><pre>* 定义一个合成类（仅 jvm 使用，对我们不可见）</pre></td></tr><tr><td data-num="3"></td><td><pre>* 用来映射枚举的 ordinal 与数组元素的关系</pre></td></tr><tr><td data-num="4"></td><td><pre>* 枚举的 ordinal 表示枚举对象的序号，从 0 开始</pre></td></tr><tr><td data-num="5"></td><td><pre>* 即 MALE 的 ordinal ()=0，FEMALE 的 ordinal ()=1</pre></td></tr><tr><td data-num="6"></td><td><pre>*/</pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">static</span> <span class="token keyword">class</span> $<span class="token constant">MAP</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token comment">// 数组大小即为枚举元素个数，里面存储 case 用来对比的数字</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token keyword">static</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    	map<span class="token punctuation">[</span><span class="token class-name">Sex</span><span class="token punctuation">.</span><span class="token constant">MALE</span><span class="token punctuation">.</span><span class="token function">ordinal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    	map<span class="token punctuation">[</span><span class="token class-name">Sex</span><span class="token punctuation">.</span><span class="token constant">FEMALE</span><span class="token punctuation">.</span><span class="token function">ordinal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>	<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token class-name">Sex</span> sex<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token keyword">int</span> x <span class="token operator">=</span> $<span class="token constant">MAP</span><span class="token punctuation">.</span>map<span class="token punctuation">[</span>sex<span class="token punctuation">.</span><span class="token function">ordinal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token keyword">switch</span> <span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>        <span class="token keyword">case</span> <span class="token number">1</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="19"></td><td><pre>        	<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"男"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>        	<span class="token keyword">break</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>        <span class="token keyword">case</span> <span class="token number">2</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="22"></td><td><pre>        	<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"女"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>        	<span class="token keyword">break</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="25"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><strong><font color="red">编译器会为枚举类生成一个静态内部类（合成类），内置一个 static int []，数组代销即为枚举元素的个数</font></strong>。</p><h3 id="枚举类"><a class="anchor" href="#枚举类">#</a> 枚举类</h3><blockquote><p>JDK 7</p></blockquote><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">enum</span> <span class="token class-name">Sex</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>	<span class="token constant">MALE</span><span class="token punctuation">,</span> <span class="token constant">FEMALE</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>编译转换后：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Sex</span> <span class="token keyword">extends</span> <span class="token class-name">Enum</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Sex</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Sex</span> <span class="token constant">MALE</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Sex</span> <span class="token constant">FEMALE</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Sex</span><span class="token punctuation">[</span><span class="token punctuation">]</span> $<span class="token constant">VALUES</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">static</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token constant">MALE</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Sex</span><span class="token punctuation">(</span><span class="token string">"MALE"</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token constant">FEMALE</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Sex</span><span class="token punctuation">(</span><span class="token string">"FEMALE"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        $<span class="token constant">VALUES</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Sex</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">&#123;</span><span class="token constant">MALE</span><span class="token punctuation">,</span> <span class="token constant">FEMALE</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token keyword">private</span> <span class="token class-name">Sex</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">int</span> ordinal<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    	<span class="token keyword">super</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> ordinal<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Sex</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    	<span class="token keyword">return</span> $<span class="token constant">VALUES</span><span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Sex</span> <span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    	<span class="token keyword">return</span> <span class="token class-name">Enum</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token class-name">Sex</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id="try-with-resources"><a class="anchor" href="#try-with-resources">#</a> try-with-resources</h3><blockquote><p>JDK 7</p></blockquote><p>对需要关闭的资源处理的特殊语法 <code>try-with-resources</code> ，格式：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">try</span><span class="token punctuation">(</span>资源变量 <span class="token operator">=</span> 创建资源对象<span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#125;</span> <span class="token keyword">catch</span><span class="token punctuation">(</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>其中<font color="red">资源对象需要实现 <code>AutoCloseable</code> 接口</font>，例如 InputStream、OutputStream、Connection、Statement、ResultSet 等接口都实现了 AutoCloseable ，使用 try-with-resources<font color="red">可以不用写 finally 语句块，编译器会帮助生成关闭资源代码</font>：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">try</span><span class="token punctuation">(</span><span class="token class-name">InputStream</span> is <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token string">"d:\\1.txt"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>	<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>is<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>	e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>转换成：</p><p><code>addSuppressed(Throwable e)</code> ：<font color="red">添加<strong>被压制异常</strong>，防止异常信息的丢失</font>（fianlly 中如果抛出了异常）</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">try</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token class-name">InputStream</span> is <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token string">"d:\\1.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token class-name">Throwable</span> t <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    	<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>is<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> e1<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    	<span class="token comment">//t 是我们代码出现的异常</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    	t <span class="token operator">=</span> e1<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    	<span class="token keyword">throw</span> e1<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token comment">// 判断了资源不为空</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>is <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>            <span class="token comment">// 如果我们代码有异常</span></pre></td></tr><tr><td data-num="14"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>                <span class="token keyword">try</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>                	is<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>                <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> e2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>                    <span class="token comment">// 如果 close 出现异常，作为被压制异常添加</span></pre></td></tr><tr><td data-num="19"></td><td><pre>                    t<span class="token punctuation">.</span><span class="token function">addSuppressed</span><span class="token punctuation">(</span>e2<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>                <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>                <span class="token comment">// 如果我们代码没有异常，close 出现的异常就是最后 catch 块中的 e</span></pre></td></tr><tr><td data-num="23"></td><td><pre>                is<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>		<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>	<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="27"></td><td><pre><span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="29"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id="方法重写"><a class="anchor" href="#方法重写">#</a> 方法重写</h3><p>方法重写时对返回值分两种情况：</p><ul><li>父子类的返回值完全一致</li><li><strong><font color="red">子类返回值可以是父类返回值的子类</font></strong>（编译期优化）</li></ul><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">Number</span> <span class="token function">m</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>		<span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token keyword">extends</span> <span class="token class-name">A</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token annotation punctuation">@Override</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token comment">// 子类 m 方法的返回值是 Integer 是父类 m 方法返回值 Number 的子类</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">Integer</span> <span class="token function">m</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    	<span class="token keyword">return</span> <span class="token number">2</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>对于子类，Java 编译器会做如下处理：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token keyword">extends</span> <span class="token class-name">A</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">Integer</span> <span class="token function">m</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    	<span class="token keyword">return</span> <span class="token number">2</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>	<span class="token comment">// 桥接方法才是真正重写了父类 public Number m () 方法</span></pre></td></tr><tr><td data-num="6"></td><td><pre>	<span class="token keyword">public</span> synthetic bridge <span class="token class-name">Number</span> <span class="token function">m</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    	<span class="token comment">// 调用 public Integer m ()</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    	<span class="token keyword">return</span> <span class="token function">m</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><font color="red">其中 <code>桥接方法</code> 才是真正重写了父类方法的方法，仅对 Java 虚拟机可见</font>，并且与原来的 public Integer m () 没有命名冲突。</p><h3 id="匿名内部类"><a class="anchor" href="#匿名内部类">#</a> 匿名内部类</h3><p><strong><font color="red">会生成一个额外的类，并实现对应接口及内部方法</font></strong>。</p><h4 id="无参优化"><a class="anchor" href="#无参优化">#</a> 无参优化</h4><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Candy11</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token class-name">Runnable</span> runnable <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>            <span class="token annotation punctuation">@Override</span></pre></td></tr><tr><td data-num="5"></td><td><pre>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>            	<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"ok"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>转化后代码：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 额外生成的类</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Candy11</span>$<span class="token number">1</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token class-name">Candy11</span>$<span class="token function">1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    	<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"ok"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Candy11</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    	<span class="token class-name">Runnable</span> runnable <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Candy11</span>$<span class="token function">1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h4 id="带参优化"><a class="anchor" href="#带参优化">#</a> 带参优化</h4><p><font color="red">引用局部变量（必须是 final）</font>的匿名内部类，源代码：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Candy11</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token class-name">Runnable</span> runnable <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>            <span class="token annotation punctuation">@Override</span></pre></td></tr><tr><td data-num="5"></td><td><pre>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>            	<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"ok:"</span> <span class="token operator">+</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>转换后代码：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Candy11</span>$<span class="token number">1</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">int</span> val$x<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token class-name">Candy11</span>$<span class="token function">1</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    	<span class="token keyword">this</span><span class="token punctuation">.</span>val$x <span class="token operator">=</span> x<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    	<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"ok:"</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>val$x<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Candy11</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    	<span class="token class-name">Runnable</span> runnable <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Candy11</span>$<span class="token function">1</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>局部变量在底层创建为内部类的成员变量，必须是 final 的原因：</p><ul><li><p>在 Java 中方法调用是值传递的，在匿名内部类中对变量的操作都是基于原变量的副本，不会影响到原变量的值，所以<strong>原变量的值的改变也无法同步到副本中</strong></p></li><li><p>外部变量为 final 是在编译期以强制手段确保用户不会在内部类中做修改原变量值的操作，也是<strong>防止外部操作修改了变量而内部类无法随之变化</strong>出现的影响</p><p>在创建 <code>Candy11$1</code> 对象时，将 x 的值赋值给了 <code>Candy11$1</code> 对象的 val 属性，x 不应该再发生变化了，因为发生变化，this.val$x 属性没有机会再跟着变化</p></li></ul><h2 id="4-类加载"><a class="anchor" href="#4-类加载">#</a> 4、类加载</h2><h3 id="类的生命周期"><a class="anchor" href="#类的生命周期">#</a> 类的生命周期</h3><p>类是在运行期间<strong>第一次使用时动态加载</strong>的（不使用不加载），而不是一次性加载所有类，因为一次性加载会占用很多的内存，<strong>加载的类信息存放于方法区中</strong>。</p><p>类从被加载到虚拟机内存中开始，到卸载出内存为止，<strong><font color="red">类的生命周期可概括为 7 个阶段</font></strong>：</p><ul><li><font color="cornflowerblue">加载（Loading）</font></li><li><strong><font color="cornflowerblue">链接（Linking）</font></strong><ul><li><font color="cornflowerblue">验证（Verification）</font></li><li><font color="cornflowerblue">准备（Preparation）</font></li><li><font color="cornflowerblue">解析（Resolution）</font></li></ul></li><li><font color="cornflowerblue">初始化（Initialization）</font></li><li><font color="cornflowerblue">使用（Using）</font></li><li><font color="cornflowerblue">卸载（Unloading）</font></li></ul><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/lifecycle-of-a-class.png" alt="一个类的完整生命周期"></p><h3 id="类加载的过程"><a class="anchor" href="#类加载的过程">#</a> 类加载的过程</h3><p>虚拟机加载 Class 类型的文件主要三步：<strong>加载 -&gt; 链接 -&gt; 初始化</strong>。而链接过程又可分为三步：<strong><font color="red">验证 -&gt; 准备 -&gt; 解析</font></strong>。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/class-loading-procedure.png" alt="类加载过程"></p><h4 id="加载"><a class="anchor" href="#加载">#</a> 加载</h4><p>加载（Loading）是类加载过程的第一步，主要完成下面 3 件事情：</p><ol><li><p><font color="red">通过全类名获取定义此类的二进制字节流</font></p></li><li><p><font color="red">借助类加载器，将类的字节流加载到方法区（元空间）中</font></p></li><li><p><strong>在堆中生成一个代表该类的 <code>Class</code> 对象，作为该类在方法区中各种数据的访问入口</strong></p><blockquote><p>堆中的 <code>Class</code> 对象持有元空间中 <code>instanceKlass</code> 的地址，而 <code>instanceKlass</code> 中的 <code>_java_mirror</code> 持有 <code>Class</code> 对象的地址。</p></blockquote></li></ol><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230930153621614.png" alt="image-20230930153621614"></p><p>方法区的内部采用 C++ 的 <strong><code>instanceKlass</code> </strong>描述 Java 类的数据结构，有以下重要的 field：</p><ul><li><code>_java_mirror</code> ：<strong>Java 的类镜像，作用是把 Klass 暴露给 Java 使用</strong>，例如对 String 来说就是 String.class</li><li><code>_super</code> ：父类</li><li><code>_fields</code> ：成员变量</li><li><code>_methods</code> ：方法</li><li><code>_constants</code> ：常量池</li><li><code>_class_loader</code> ：类加载器</li><li><code>_vtable</code> ：<strong>虚方法表</strong></li><li><code>_itable</code> ：接口方法表</li></ul><blockquote><p>注意：</p><ul><li><code>instanceKlass</code> 这样的【元数据】是存储在方法区（1.8 后的元空间内），但 <code>_java_mirror</code> 是存储在堆中</li><li><strong>Java 实例对象无法直接访问 <code>instanceKlass</code> ，而是先找到 <code>_java_mirror</code> 指向的 <code>Class</code> 对象，进而才能访问 <code>instanceKlass</code> 中的数据</strong></li><li>如果这个类还有父类没有加载，<font color="red">先加载父类</font></li><li><font color="red">加载和链接可能是交替运行的</font></li></ul></blockquote><h4 id="链接"><a class="anchor" href="#链接">#</a> 链接</h4><h5 id="验证"><a class="anchor" href="#验证">#</a> 验证</h5><p><strong>验证 Class 文件的字节流中包含的信息是否符合 《Java 虚拟机规范》的全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身的安全。</strong></p><p>验证阶段这一步在整个类加载过程中<font color="red">耗费的资源相对较多，但很有必要</font>，可以有效防止恶意代码的执行。任何时候，程序安全都是第一位。</p><p>不过，验证阶段也<font color="red">不是必须要执行的阶段</font>。如果程序运行的全部代码 (包括自己编写的、第三方包中的、从外部加载的、动态生成的等所有代码) 都已经被反复使用和验证过，在生产环境的实施阶段就<font color="red">可以考虑使用 <code>-Xverify:none</code> 参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间</font>。</p><p>验证阶段主要由<font color="red">四个检验阶段</font>组成：</p><ol><li><p><font color="gree">文件格式验证</font>（Class 文件格式检查）：基于该类的二进制字节流进行，目的是保证输入的字节流能正确地解析并存储于<font color="red">方法区</font>之内，格式上符合描述一个 Java 类型信息的要求。</p><blockquote><p>除了这一阶段之外，其余三个验证阶段都是基于方法区的存储结构上进行的，不会再直接读取、操作字节流了。</p></blockquote></li><li><p><font color="gree">元数据验证</font>（语义检查）</p></li><li><p><font color="gree">字节码验证</font>（判断字节码是否可以被正确地执行）</p></li><li><p><font color="gree">符号引用验证</font>（验证类的正确性）：发生在类加载过程中的<font color="red">解析阶段</font>，具体点说是 JVM 将符号引用转化为直接引用的时候。目的是<font color="red">确保解析阶段能正常执行</font>，如果无法通过符号引用验证，JVM 会抛出异常，比如：</p><ul><li><code>java.lang.IllegalAccessError</code> ：当类试图访问或修改它没有权限访问的字段，或调用它没有权限访问的方法时，抛出该异常。</li><li><code>java.lang.NoSuchFieldError</code> ：当类试图访问或修改一个指定的对象字段，而该对象不再包含该字段时，抛出该异常。</li><li><code>java.lang.NoSuchMethodError</code> ：当类试图访问一个指定的方法，而该方法不存在时，抛出该异常。</li><li>......</li></ul></li></ol><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/class-loading-process-verification.png" alt="验证阶段示意图"></p><h5 id="准备"><a class="anchor" href="#准备">#</a> 准备</h5><p><strong>为 static 变量（类变量）分配内存，并设置初始值</strong></p><blockquote><p>说明：<font color="red">实例变量不会在这阶段分配内存</font>，它会在对象实例化时随着对象一起分配在 Java 堆中。类加载发生在所有实例化操作之前，并且类加载只进行一次，而实例化可以进行多次。</p></blockquote><ul><li><p>static 变量在 JDK 7 之前存储于永久代（ <code>instanceKlass</code> 末尾）中。从 JDK 7 开始，HotSpot 已经把原本放在永久代的字符串常量池、静态变量等移动到堆中，这个时候类变量则会随着 Class 对象一起存放在 Java 堆中（ <code>_java_mirror</code> 末尾）。</p></li><li><p>static 变量分配内存和赋值是两个步骤：<strong>分配内存在<u>准备阶段</u>完成，此时会将初始值设为数据类型默认的零值；而具体赋值是在<u>初始化阶段</u>完成的</strong>。</p><blockquote><p>初始默认值 ≠ 赋值</p><p><img data-src="https://oss.javaguide.cn/github/javaguide/java/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E9%9B%B6%E5%80%BC.png" alt="基本数据类型的零值"></p></blockquote><ul><li>如果 static 变量是 final 的<font color="red">基本类型或者字符串常量</font>，那么赋值发生在<font color="red">准备阶段</font></li><li>如果 static 变量是 final 的，但属于<font color="red">引用类型或者构造器方法的字符串</font>，那么赋值发生在<font color="red">初始化阶段</font></li></ul></li></ul><p>举例：</p><ul><li><p>初始值一般为 0 值，例如下面的类变量 value 被初始化为 0 而不是 123：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> value <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span></pre></td></tr></table></figure></li><li><p>常量 value 被初始化为 123 而不是 0：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> value <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span></pre></td></tr></table></figure></li><li><p>Java 并不支持 boolean 类型，对于 boolean 类型，内部实现是 int，由于 int 的默认值是 0，故 boolean 的默认值就是 false</p></li></ul><h5 id="解析"><a class="anchor" href="#解析">#</a> 解析</h5><p><strong>将常量池内的符号引用替换为直接引用（内存地址）的过程</strong>，也就是得到类或者字段、方法在内存中的指针或者偏移量。</p><ul><li><font color="gree">符号引用 (Symbolic References)</font>：以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。<font color="red">符号引用与虚拟机实现的内存布局无关，引用的目标并不一定是已经加载到虚拟机内存当中的内容</font>。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须都是一致的，因为符号引用的字面量形式明确定义在《Java 虚拟机规范》的 Class 文件格式中。<font color="red">主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符 7 类符号引用进行</font>。如：包括类和接口的全限名、字段的名称和描述符、方法的名称和方法描述符（因为类还没有加载完，很多方法是找不到的）。</li><li><font color="gree">直接引用 (Direct References)</font>：是可以直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄。<font color="red">直接引用是和虚拟机实现的内存布局直接相关的</font>，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那<font color="red">引用的目标必定已经在虚拟机的内存中存在</font>。</li></ul><p>举个例子：在程序执行方法时，系统需要明确知道这个方法所在的位置。Java 虚拟机为每个类都准备了一张方法表来存放类中所有的方法。当需要调用一个类的方法的时候，只要知道这个方法在方法表中的偏移量就可以直接调用该方法了。通过解析操作符号引用就可以直接转变为目标方法在类中方法表的位置，从而使得方法可以被调用。</p><h4 id="初始化"><a class="anchor" href="#初始化">#</a> 初始化</h4><p><strong><font color="red">简介</font></strong></p><p><strong>执行初始化方法 <code>&lt;clinit&gt; ()</code> 方法的过程，进行 static 变量初始化和执行 static 代码块</strong>，是类加载的最后一步，此时 JVM 才开始真正执行类中定义的 Java 程序代码 (字节码)。</p><blockquote><p>在编译生成 class 文件时，编译器会产生两个方法加于 class 文件中，一个是<strong>类的初始化方法</strong> <code>clinit</code> ，另一个是<strong>实例的初始化方法</strong> <code>init</code> 。</p><p>类构造器 () 与实例构造器 () 不同，它不需要程序员进行显式调用，在一个类的生命周期中，<strong>类构造器最多被虚拟机调用一次</strong>，而实例构造器则会被虚拟机调用多次，只要程序员创建对象。</p><p><strong>类只在第一次实例化时加载一次，把 class 读入内存</strong>，后续实例化不再加载，引用第一次加载的类。</p></blockquote><p><strong><font color="red">&lt;clinit&gt; ()</font></strong></p><p>类构造器，由编译器自动收集类中<strong>所有类变量的赋值动作和静态语句块</strong>中的语句合并产生的。</p><p>作用：是在类加载过程中的初始化阶段进行静态变量初始化和执行静态代码块</p><blockquote><p>静态语句块只能访问到定义在它之前的类变量，定义在它之后的类变量只能赋值，不能访问</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">static</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token comment">//i = 0;                // 给变量赋值可以正常编译通过</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>  	<span class="token comment">// 这句编译器会提示 “非法向前引用”</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">static</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure></blockquote><ul><li><p>如果类中没有静态变量或静态代码块，那么 clinit 方法将不会被生成</p></li><li><p>clinit 方法只执行一次，在执行 clinit 方法时，必须先执行父类的 clinit 方法</p></li><li><p>static 变量的赋值操作和静态代码块的合并顺序由源文件中出现的顺序决定【从上至下】</p></li><li><p>static 不加 final 的变量以及加 final 的引用类型或者构造器方法的字符串都在初始化环节赋值</p><blockquote><p>static 加 final 的基本类型或者字符串常量都在准备阶段复制</p></blockquote></li></ul><p>对于 <code>&lt;clinit&gt; ()</code> 方法的调用，虚拟机会自己确保其在多线程环境中的安全性。因为 <code>&lt;clinit&gt; ()</code> 方法是<font color="red">带锁线程安全</font>，所以在多线程环境下进行类初始化的话可能会引起多个线程阻塞，并且这种阻塞很难被发现。</p><p><strong><font color="red">初始化的时机</font></strong></p><p>对于初始化阶段，虚拟机严格规范了<font color="red">有且只有 6 种情况下，必须对类进行初始化 (类的初始化是【懒惰】的，只有在首次使用时才会被装载)</font>：</p><ol><li>当遇到 <code>new</code> 、 <code>getstatic</code> 、 <code>putstatic</code> 或 <code>invokestatic</code> 这 4 条字节码指令时，比如 <code>new</code> 一个类，读取一个静态字段 (未被 final 修饰)、或调用一个类的静态方法时。<ul><li>当 jvm 执行 <code>new</code> 指令时会初始化类。即当程序<font color="gree">创建一个类的实例对象</font>。</li><li>当 jvm 执行 <code>getstatic</code> 指令时会初始化类。即程序<font color="gree">首次访问类的静态变量</font>(不是静态常量，常量会被加载到运行时常量池)。</li><li>当 jvm 执行 <code>putstatic</code> 指令时会初始化类。即程序<font color="gree">给类的静态变量赋值</font>。</li><li>当 jvm 执行 <code>invokestatic</code> 指令时会初始化类。即程序<font color="gree">调用类的静态方法</font>。</li></ul></li><li>使用 <code>java.lang.reflect</code> 包的方法<font color="gree">对类进行反射调用时</font>如 <code>Class.forname(&quot;...&quot;)</code> , <code>newInstance()</code> 等等。如果类没初始化，需要触发其初始化。</li><li>初始化一个类，如果其父类还未初始化，则<font color="gree">先触发其父类的初始化</font>。</li><li>当虚拟机启动时，用户需要定义一个要执行的主类 (包含 <code>main</code> 方法的那个类)，虚拟机会<font color="gree">首先初始化 main 方法所在的类</font>。</li><li><code>MethodHandle</code> 和 <code>VarHandle</code> 可以看作是轻量级的反射调用机制，而要想使用这 2 个调用， 就必须先使用 <code>findStaticVarHandle</code> 来初始化要调用的类。</li><li><strong>「补充，来自<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1NuYWlsY2xpbWIvSmF2YUd1aWRlL2lzc3Vlcy83NDU="> issue745</span>」</strong> <font color="gree">当一个接口中定义了 JDK8 新加入的默认方法</font>（被 default 关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。</li></ol><p><strong><font color="red">不会导致初始化的情况</font></strong></p><ul><li>访问类中被 final 修饰的 static 常量（基本类型和字符串）时</li><li>类对象.class</li><li>创建该类的数组</li><li>类加载器的 loadClass 方法</li><li>Class.forName 的参数 2 为 false 时</li></ul><p><strong><font color="red">&lt;init&gt;()</font></strong></p><p>实例构造器，主要作用是在类实例化过程中执行，执行内容包括<font color="red">成员变量初始化和代码块的执行</font>。</p><p>类实例化过程：<strong>父类的类构造器 () -&gt; 子类的类构造器 () -&gt; 父类的成员变量和实例代码块 -&gt; 父类的构造函数 -&gt; 子类的成员变量和实例代码块 -&gt; 子类的构造函数</strong></p><h3 id="练习"><a class="anchor" href="#练习">#</a> 练习</h3><p>从字节码分析，使用 a，b，c 这三个常量是否会导致类 E 初始化：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Load2</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>       	<span class="token comment">//a、b 不会导致 E 类初始化，因为这两个 static 变量被 final 修饰，且为基本数据类型、字符串常量，在准备阶段就已经完成赋值</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">E</span><span class="token punctuation">.</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">E</span><span class="token punctuation">.</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token comment">// 会导致 E 类初始化，因为 Integer 是包装类，需要在初始化阶段完成赋值</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">E</span><span class="token punctuation">.</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">E</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> b <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Integer</span> c <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token keyword">static</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"E cinit"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>典型应用 - 完成懒惰初始化单例模式：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">&#125;</span> <span class="token comment">// 私有构造方法，确保只有自己能调用</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token comment">// 创建 static 内部类（好处是能访问外部类的资源，例如构造方法），并定义 static 成员变量，保存单例</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">LazyHolder</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Singleton</span> <span class="token constant">INSTANCE</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token comment">// 第一次调用 getInstance 方法，才会导致内部类加载和初始化其静态成员 </span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token keyword">return</span> <span class="token class-name">LazyHolder</span><span class="token punctuation">.</span><span class="token constant">INSTANCE</span><span class="token punctuation">;</span>  <span class="token comment">// 用到时才会加载 LazyHolder 类，从而才会触发初始化（此阶段会进行 static 变量的初始化，执行 static 代码块），从而实现【懒惰单例模式】</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>实现特点是：</p><ul><li>懒惰实例化</li><li>初始化时的线程安全是有保障的</li></ul><h3 id="类卸载"><a class="anchor" href="#类卸载">#</a> 类卸载</h3><p><strong>即该类的 Class 对象被 GC。</strong></p><p>类卸载的时机：</p><ul><li>执行了 System.exit () 方法</li><li>程序正常执行结束</li><li>程序在执行过程中遇到了异常或错误而异常终止</li><li>由于操作系统出现错误而导致 Java 虚拟机进程终止</li></ul><p>卸载类需要满足 3 个要求:</p><ol><li>该类的所有的<font color="gree">实例对象都已被 GC</font>，即堆中不存在该类的实例对象</li><li>该类<font color="gree">没有被引用</font></li><li>该类的<font color="gree">类加载器的实例已被 GC</font></li></ol><p>所以，在 JVM 生命周期内，<font color="red">由 JVM 自带的类加载器加载的类是不会被卸载的</font>。但是由我们<font color="red">自定义的类加载器加载的类是可能被卸载的</font>。因为 JVM 会始终引用启动类加载器、扩展类加载器、应用程序类加载器，这些类加载器始终引用它们所加载的类，这些类始终是可及的。<font color="red">JDK 自带的 <code>BootstrapClassLoader</code> , <code>ExtClassLoader</code> , <code>AppClassLoader</code> 负责加载 JDK 提供的类，所以它们 (类加载器的实例) 肯定不会被回收</font>。而我们自定义的类加载器的实例是可以被回收的，所以使用我们自定义加载器加载的类是可以被卸载掉的。</p><h2 id="5-类加载器"><a class="anchor" href="#5-类加载器">#</a> 5、类加载器</h2><h3 id="前置知识-3"><a class="anchor" href="#前置知识-3">#</a> 前置知识</h3><p><font color="gree">类加载方式</font>：</p><ul><li><font color="cornflowerblue">隐式加载</font>：不直接在代码中调用 ClassLoader 的方法加载类对象<ul><li>创建类对象、使用类的静态域、创建子类对象、使用子类的静态域</li><li>在 JVM 启动时，通过三大类加载器加载 class</li></ul></li><li><font color="cornflowerblue">显式加载</font>：<ul><li><code>ClassLoader.loadClass(className)</code> ：只加载和连接，<strong>不会进行初始化</strong></li><li><code>Class.forName(String name, boolean initialize, ClassLoader loader)</code> ：使用 loader 进行加载和连接，根据参数 initialize 决定是否初始化</li></ul></li></ul><p><font color="gree">类的唯一性</font>：</p><ul><li>在 JVM 中表示两个 class 对象判断为同一个类存在的两个必要条件：<ul><li><font color="red">类的完整类名必须一致</font>，包括包名</li><li>加载这个类的 <font color="red">ClassLoader（指 ClassLoader 实例对象）必须相同</font></li></ul></li><li>这里的相等，包括类的 Class 对象的 equals () 方法、isAssignableFrom () 方法、isInstance () 方法的返回结果为 true，也包括使用 instanceof 关键字做对象所属关系判定结果为 true</li></ul><p><font color="gree">命名空间</font>：</p><ul><li>每个类加载器都有自己的命名空间，<font color="red">命名空间由该加载器及所有的父加载器所加载的类组成</font></li><li>在同一命名空间中，不会出现类的完整名字（包括类的包名）相同的两个类</li></ul><p><font color="gree">类加载器的基本特征</font>：</p><ul><li><strong>可见性</strong>，子类加载器可以访问父加载器加载的类型，但是反过来是不允许的</li><li><strong>单一性</strong>，由于父加载器的类型对于子加载器是可见的，所以父加载器中加载过的类型，不会在子加载器中重复加载</li></ul><p><font color="gree">类加载规则</font>：</p><ul><li><p>JVM 启动的时候，并不会一次性加载所有的类，而是<font color="red">根据需要去动态加载</font>。也就是说，大部分类在具体用到的时候才会去加载，这样对内存更加友好。</p></li><li><p>对于已经加载的类会被放在 <code>ClassLoader</code> 中。在类加载的时候，系统会首先判断当前类是否被加载过。<font color="red">已经被加载的类会直接返回，否则才会尝试加载</font>。也就是说，<font color="red">对于一个类加载器来说，相同二进制名称的类只会被加载一次</font>。</p></li><li><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">ClassLoader</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">ClassLoader</span> parent<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>  <span class="token comment">// 由这个类加载器加载的类（Vector）</span></pre></td></tr><tr><td data-num="5"></td><td><pre>  <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Vector</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Class</span><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span><span class="token punctuation">></span></span> classes <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vector</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>  <span class="token comment">// 由 VM 调用，用此类加载器记录每个已加载类。</span></pre></td></tr><tr><td data-num="7"></td><td><pre>  <span class="token keyword">void</span> <span class="token function">addClass</span><span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> c<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        classes<span class="token punctuation">.</span><span class="token function">addElement</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>   <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure></li></ul><h3 id="概述-3"><a class="anchor" href="#概述-3">#</a> 概述</h3><ul><li><p>类加载器是一个负责加载类的对象，用于实现类加载过程中的加载这一步。</p></li><li><p><strong><font color="red">每个 Java 类都有一个引用，指向加载它的 <code>ClassLoader</code> 。</font></strong></p></li><li><p>数组类不是通过 <code>ClassLoader</code> 创建的（数组类没有对应的二进制字节流），是由 JVM 直接生成的。</p></li></ul><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">ClassLoader</span> classLoader<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>  <span class="token annotation punctuation">@CallerSensitive</span></pre></td></tr><tr><td data-num="5"></td><td><pre>  <span class="token keyword">public</span> <span class="token class-name">ClassLoader</span> <span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>     <span class="token comment">//...</span></pre></td></tr><tr><td data-num="7"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>简单来说，类加载器的主要作用就是 ** 奖 Java 类的字节码（ <code>.class</code> 文件）加载到 JVM 内存中（在堆中生成一个 <code>Class</code> 对象）。** 字节码可以是 Java 源程序（ <code>.java</code> 文件）经过 <code>javac</code> 编译得来，也可以是通过工具动态生成或者通过网络下载得来。</p><p>以 JDK 8 为例，类加载器包括：</p><table><thead><tr><th>名称</th><th>加载的类路径</th><th>说明</th></tr></thead><tbody><tr><td>Bootstrap ClassLoader（启动类加载器）</td><td>%JAVA_HOME%/jre/lib</td><td>由 c++ 编写，<font color="red">无法直接访问，显示为 null</font></td></tr><tr><td>Extension ClassLoader（扩展类加载器）</td><td>%JAVA_HOME%/jre/lib/ext</td><td>上级为 Bootstrap</td></tr><tr><td>Application ClassLoader（应用程序类加载器）</td><td>classpath</td><td>上级为 Extension</td></tr><tr><td>自定义类加载器</td><td>自定义</td><td><font color="red">上级为 Application</font></td></tr></tbody></table><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231002191558061.png" alt="类加载器的层次关系图（双亲委派模型）"></p><h3 id="内置的类加载器"><a class="anchor" href="#内置的类加载器">#</a> 内置的类加载器</h3><h4 id="启动类加载器"><a class="anchor" href="#启动类加载器">#</a> 启动类加载器</h4><blockquote><p>Bootstrap ClassLoader</p></blockquote><p><font color="red">最顶层</font>的加载类，<font color="red">由 C++ 实现</font>，通常表示为 <font color="red">null</font>，并且没有父级，<strong>用来加载 JDK 内部的核心类库</strong>（ <code>%JAVA_HOME%/jre/lib</code> 目录下的 <code>rt.jar</code> 、 <code>resources.jar</code> 、 <code>charsets.jar</code> 等 jar 包和类）以及被 <code>-Xbootclasspath</code> 参数指定的路径下的所有类。</p><blockquote><p><strong><code>rt.jar</code> </strong>：rt 代表 “RunTime”，<font color="red"> <code>rt.jar</code> 是 Java 基础类库，包含 Java doc 里面看到的所有的类的类文件</font>。也就是说，我们常用内置库 <code>java.xxx.*</code> 都在里面，比如 <code>java.util.*</code> 、 <code>java.io.*</code> 、 <code>java.nio.*</code> 、 <code>java.lang.*</code> 、 <code>java.sql.*</code> 、 <code>java.math.*</code> 。</p></blockquote><ul><li>出于安全考虑，Bootstrap 启动类加载器<font color="red">只加载包名的开头为 java、javax、sun 的类</font></li><li><font color="red">仅按照文件名识别</font>，如 rt.jar 名字不符合的类库即使放在 lib 目录中也不会被加载</li><li>启动类加载器<font color="red">无法被 Java 程序直接引用</font>，编写自定义类加载器时，如果要把加载请求委派给启动类加载器，直接使用 null 代替</li></ul><h4 id="扩展类加载器"><a class="anchor" href="#扩展类加载器">#</a> 扩展类加载器</h4><blockquote><p>Extension ClassLoader</p><p>Java 9 引入了模块系统，该加载器被改名为<font color="red">平台类加载器（platform class loader）</font>。</p><p>Java SE 中除了少数几个关键模块，比如说 <code>java.base</code> 是由启动类加载器加载之外，<font color="red">其他的模块均由平台类加载器所加载</font>。</p></blockquote><p>用来加载 <code>%JAVA_HOME%/jre/lib/ext</code> 目录下的 jar 包和类以及被 <code>java.ext.dirs</code> 系统变量所指定的路径下的所有类。</p><ul><li>由 <code>ExtClassLoader (sun.misc.Launcher$ExtClassLoader)</code> 实现，<font color="red">上级为 Bootstrap，显示为 null</font></li><li>将 <code>JAVA_HOME/jre/lib/ext</code> 或者被 <code>java.ext.dir</code> 系统变量所指定路径中的所有类库加载到内存中</li><li><strong><font color="red">开发者可以将创建的 JAR 放在此目录下，会由扩展类加载器自动加载</font></strong></li></ul><h4 id="应用程序类加载器"><a class="anchor" href="#应用程序类加载器">#</a> 应用程序类加载器</h4><blockquote><p>Application ClassLoader，也称为<font color="red">系统类加载器</font></p></blockquote><p><strong>面向用户</strong>的类加载器，负责加载当前应用 classpath 下的所有 jar 包和类。</p><ul><li>由 <code>AppClassLoader(sun.misc.Launcher$AppClassLoader)</code> 实现，<font color="red">上级为 Extension</font></li><li>负责加载环境变量 classpath 或系统属性 <code>java.class.path</code> 指定路径下的类库</li><li>这个类加载器<font color="red">是 ClassLoader 中的 getSystemClassLoader () 方法的返回值</font>，因此也称为系统类加载器</li><li>可以直接使用这个类加载器，如果应用程序中没有自定义类加载器，这个就是<font color="red">程序中默认的类加载器</font></li></ul><h4 id="小结-3"><a class="anchor" href="#小结-3">#</a> 小结</h4><p>如何获取各个类加载器：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 获取系统类加载器（应用程序类加载器）</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token class-name">ClassLoader</span> systemClassLoader <span class="token operator">=</span> <span class="token class-name">ClassLoader</span><span class="token punctuation">.</span><span class="token function">getSystemClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>systemClassLoader<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//sun.misc.Launcher$AppClassLoader@18b4aac2</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token comment">// 获取其上层：扩展类加载器</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token class-name">ClassLoader</span> extClassLoader <span class="token operator">=</span> systemClassLoader<span class="token punctuation">.</span><span class="token function">getParent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>extClassLoader<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//sun.misc.Launcher$ExtClassLoader@610455d6</span></pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token comment">// 获取其上层：获取不到启动类加载器，返回 null</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token class-name">ClassLoader</span> bootStrapClassLoader <span class="token operator">=</span> extClassLoader<span class="token punctuation">.</span><span class="token function">getParent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>bootStrapClassLoader<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//null</span></pre></td></tr><tr><td data-num="13"></td><td><pre></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token comment">// 对于用户自定义类来说：使用系统类加载器进行加载</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token class-name">ClassLoader</span> classLoader <span class="token operator">=</span> <span class="token class-name">ClassLoaderTest</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>classLoader<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//sun.misc.Launcher$AppClassLoader@18b4aac2</span></pre></td></tr><tr><td data-num="17"></td><td><pre></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token comment">//String 类使用引导类加载器进行加载的 --> java 核心类库都是使用启动类加载器加载的</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    <span class="token class-name">ClassLoader</span> classLoader1 <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>classLoader1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//null</span></pre></td></tr><tr><td data-num="21"></td><td><pre></pre></td></tr><tr><td data-num="22"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><strong>除了 <code>BootstrapClassLoader</code> 是 JVM 自身的一部分之外，其他所有的类加载器都是在 JVM 外部实现的，并且全都继承自 <code>ClassLoader</code> 抽象类</strong>。这样做的好处是用户可以自定义类加载器，以便让应用程序自己决定如何去获取所需的类。</p><p>每个 <code>ClassLoader</code> 可以通过 <code>getParent()</code> 获取其父 <code>ClassLoader</code> ，如果获取到 <code>ClassLoader</code> 为 <code>null</code> 的话，那么该类是通过 <code>BootstrapClassLoader</code> 加载的。</p><blockquote><p>因为 <code>BootstrapClassLoader</code> 由 C++ 实现，由于这个 C++ 实现的类加载器在 Java 中是没有与之对应的类的，所以拿到的结果是 null。</p></blockquote><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">ClassLoader</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token comment">// 父加载器</span></pre></td></tr><tr><td data-num="4"></td><td><pre>  <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">ClassLoader</span> parent<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>  <span class="token annotation punctuation">@CallerSensitive</span></pre></td></tr><tr><td data-num="6"></td><td><pre>  <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token class-name">ClassLoader</span> <span class="token function">getParent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>     <span class="token comment">//...</span></pre></td></tr><tr><td data-num="8"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>下面我们来看一个获取 <code>ClassLoader</code> 的小案例：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PrintClassLoaderTree</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token class-name">ClassLoader</span> classLoader <span class="token operator">=</span> <span class="token class-name">PrintClassLoaderTree</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token class-name">StringBuilder</span> split <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token string">"|--"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token keyword">boolean</span> needContinue <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token keyword">while</span> <span class="token punctuation">(</span>needContinue<span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>split<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> classLoader<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>            <span class="token keyword">if</span><span class="token punctuation">(</span>classLoader <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>                needContinue <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>            <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>                classLoader <span class="token operator">=</span> classLoader<span class="token punctuation">.</span><span class="token function">getParent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>                split<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">"\t"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="19"></td><td><pre></pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>输出结果 (JDK 8)：</p><figure class="highlight text"><figcaption data-lang="text"></figcaption><table><tr><td data-num="1"></td><td><pre>|--sun.misc.Launcher$AppClassLoader@18b4aac2</pre></td></tr><tr><td data-num="2"></td><td><pre>    |--sun.misc.Launcher$ExtClassLoader@53bd815b</pre></td></tr><tr><td data-num="3"></td><td><pre>        |--null</pre></td></tr></table></figure><p>从输出结果可以看出：</p><ul><li>我们编写的 Java 类 <code>PrintClassLoaderTree</code> 的 <code>ClassLoader</code> 是 <code>AppClassLoader</code> ；</li><li><code>AppClassLoader</code> 的父 <code>ClassLoader</code> 是 <code>ExtClassLoader</code> ；</li><li><code>ExtClassLoader</code> 的父 <code>ClassLoader</code> 是 <code>Bootstrap ClassLoader</code> ，因此输出结果为 null。</li></ul><h3 id="自定义类加载器"><a class="anchor" href="#自定义类加载器">#</a> 自定义类加载器</h3><h4 id="动机"><a class="anchor" href="#动机">#</a> 动机</h4><p>开发人员可以通过自定义类加载器来进行拓展，那么<font color="red">什么时候需要自定义类加载器呢？</font></p><ul><li><p>希望加载任意路径下的类文件</p></li><li><p>希望在框架设计时，通过接口使用不同的实现，达到解耦的目的</p></li><li><p>同一个类有多个版本，它们的包名、类名都一样，但字节码不一样，希望它们能够互相隔离、同时工作，不要冲突</p><blockquote><p>tomcat 容器</p></blockquote></li></ul><h4 id="介绍"><a class="anchor" href="#介绍">#</a> 介绍</h4><p><font color="red">自定义类加载器的上级是 Application</font>。前文说到，除了 <code>BootstrapClassLoader</code> ，其他类加载器均由 Java 实现且全部继承自 <code>java.lang.ClassLoader</code> 。所以如果我们要自定义自己的类加载器，很明显<font color="red">需要继承 <code>ClassLoader</code> 抽象类</font>。</p><p>而 <code>ClassLoader</code> 类有<font color="red">两个关键的方法</font>：</p><ul><li><code>protected Class loadClass(String name, boolean resolve)</code> ：<font color="gree">加载</font>指定二进制名称的类，实现了<font color="red">双亲委派机制</font>。<ul><li><code>name</code> 为类的二进制名称</li><li><code>resolve</code> 如果为 true，在加载时调用 <code>resolveClass(Class&lt;?&gt; c)</code> 方法解析该类。</li></ul></li><li><code>protected Class findClass(String name)</code> ：根据类的二进制名称来<font color="gree">查找</font>类，默认实现是空方法。</li></ul><blockquote><p>官方 API 文档中写到：建议 <code>ClassLoader</code> 的子类重写 <code>findClass(String name)</code> 方法而不是 <code>loadClass(String name, boolean resolve)</code> 方法。</p></blockquote><p><font color="red">如果我们不想打破双亲委派模型，就重写 <code>ClassLoader</code> 类中的 <code>findClass()</code> 方法即可</font>，无法被父类加载器加载的类最终会通过这个方法被加载。但是，<font color="red">如果想打破双亲委派模型则需要重写 <code>loadClass()</code> 方法</font>。</p><h4 id="步骤"><a class="anchor" href="#步骤">#</a> 步骤</h4><ol><li><p>继承 <code>ClassLoader</code> 父类</p></li><li><p>要遵从双亲委派机制，<strong>重写 <code>findClass()</code> 方法</strong></p><blockquote><p>不是重写 loadClass () 方法，否则会打破双亲委派机制</p></blockquote></li><li><p>读取类文件的字节码（byte []）</p></li><li><p>调用父类的 <code>defineClass()</code> 方法来加载类</p></li><li><p>使用者调用该类加载器的 <code>loadClass()</code> 方法</p></li></ol><p>举例：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231004155454908.png" alt="image-20231004155454908"></p><h3 id="双亲委派模型"><a class="anchor" href="#双亲委派模型">#</a> 双亲委派模型</h3><blockquote><p>一种加载类的策略</p></blockquote><h4 id="介绍-2"><a class="anchor" href="#介绍-2">#</a> 介绍</h4><p>类加载器有很多种，当我们想要加载某个类时，具体是使用哪个类加载器进行加载呢？这就需要提到双亲委派模型，就是指<strong>调用类加载器的 loadClass () 方法时，所采用的查找类的规则</strong>。</p><blockquote><p>这里的双亲，翻译为上级更合适，因为它们之间并没有继承关系</p></blockquote><ul><li><p><code>ClassLoader</code> 类使用<font color="red">委托模型</font>来搜索类、资源。</p></li><li><p>双亲委派模型<font color="red">要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器</font>。</p></li><li><p><code>ClassLoader</code> 实例会<font color="red">在试图亲自查找类或资源之前，将搜索类或资源的任务委托给其父类加载器</font>。</p></li></ul><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231002191558061.png" alt="类加载器的层次关系图（双亲委派模型）"></p><blockquote><p>⚠️注意：<font color="red">双亲委派模型并不是一种强制性的约束，只是 JDK 官方推荐的一种方式</font>。因为某些特殊需求，我们<font color="red">可以打破双亲委派模型</font>，后文会介绍具体的方法。</p></blockquote><p>另外，类加载器之间的父子关系一般不是以继承（Inheritance）的关系来实现的，而是通常<font color="red">使用组合关系（Composition）来复用父加载器的代码</font>。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">ClassLoader</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token comment">// 组合</span></pre></td></tr><tr><td data-num="4"></td><td><pre>  <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">ClassLoader</span> parent<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>  <span class="token keyword">protected</span> <span class="token class-name">ClassLoader</span><span class="token punctuation">(</span><span class="token class-name">ClassLoader</span> parent<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>       <span class="token keyword">this</span><span class="token punctuation">(</span><span class="token function">checkCreateClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> parent<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>在面向对象编程中，有一条非常经典的设计原则：<strong>组合优于继承，多用组合，少用继承。</strong></p><h4 id="执行流程"><a class="anchor" href="#执行流程">#</a> 执行流程</h4><p><strong>每当一个类加载器接收到加载请求时，它首先会判断当前类是否被加载过，若没加载过，则会先将加载请求转发给父类加载器。在父类加载器没有找到所请求的类的情况下，该类加载器才会尝试去加载。</strong></p><p>双亲委派模型的实现代码非常简单，逻辑非常清晰，都集中在 <code>java.lang.ClassLoader</code> 的 <code>loadClass()</code> 中，相关代码如下所示：</p><blockquote><p>调用父类加载器的 <code>loadClass()</code> 方法，调用自身类加载器的 <code>findClass()</code> 方法</p></blockquote><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">protected</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> <span class="token function">loadClass</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">boolean</span> resolve<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">throws</span> <span class="token class-name">ClassNotFoundException</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token function">getClassLoadingLock</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token comment">// 首先，检查该类是否已经加载过</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token class-name">Class</span> c <span class="token operator">=</span> <span class="token function">findLoadedClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>            <span class="token comment">// 如果 c 为 null，则说明该类没有被加载过</span></pre></td></tr><tr><td data-num="9"></td><td><pre>            <span class="token keyword">long</span> t0 <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>            <span class="token keyword">try</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>                <span class="token keyword">if</span> <span class="token punctuation">(</span>parent <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>                    <span class="token comment">// 当父类的加载器不为空，则通过父类的 loadClass 来加载该类</span></pre></td></tr><tr><td data-num="13"></td><td><pre>                    c <span class="token operator">=</span> parent<span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>                <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>                    <span class="token comment">// 当父类的加载器为空，则调用启动类加载器来加载该类</span></pre></td></tr><tr><td data-num="16"></td><td><pre>                    c <span class="token operator">=</span> <span class="token function">findBootstrapClassOrNull</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>                <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>            <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ClassNotFoundException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>                <span class="token comment">// 非空父类的类加载器无法找到相应的类，则抛出异常</span></pre></td></tr><tr><td data-num="20"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="21"></td><td><pre></pre></td></tr><tr><td data-num="22"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>                <span class="token comment">// 当父类加载器无法加载时，则调用 findClass 方法 (由类加载器自己扩展）来加载该类</span></pre></td></tr><tr><td data-num="24"></td><td><pre>                <span class="token comment">// 用户可通过覆写该方法，来自定义类加载器</span></pre></td></tr><tr><td data-num="25"></td><td><pre>                <span class="token keyword">long</span> t1 <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>                c <span class="token operator">=</span> <span class="token function">findClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre></pre></td></tr><tr><td data-num="28"></td><td><pre>                <span class="token comment">// 用于统计类加载器相关的信息</span></pre></td></tr><tr><td data-num="29"></td><td><pre>                <span class="token class-name"><span class="token namespace">sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span></span>PerfCounter</span><span class="token punctuation">.</span><span class="token function">getParentDelegationTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addTime</span><span class="token punctuation">(</span>t1 <span class="token operator">-</span> t0<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>                <span class="token class-name"><span class="token namespace">sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span></span>PerfCounter</span><span class="token punctuation">.</span><span class="token function">getFindClassTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addElapsedTimeFrom</span><span class="token punctuation">(</span>t1<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="31"></td><td><pre>                <span class="token class-name"><span class="token namespace">sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span></span>PerfCounter</span><span class="token punctuation">.</span><span class="token function">getFindClasses</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="33"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="34"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>resolve<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="35"></td><td><pre>            <span class="token comment">// 对类进行 link 操作</span></pre></td></tr><tr><td data-num="36"></td><td><pre>            <span class="token function">resolveClass</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="37"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="38"></td><td><pre>        <span class="token keyword">return</span> c<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="39"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="40"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>结合上面的源码，简单总结一下双亲委派模型的执行流程：</p><ul><li>在类加载的时候，系统会<font color="red">首先判断当前类是否被加载过</font>。已经被加载的类会直接返回，否则才会尝试加载（每个父类加载器都会走一遍这个流程）。</li><li>类加载器在进行类加载的时候，它首先不会自己去尝试加载这个类，而是<font color="red">把这个请求委派给父类加载器去完成</font>（调用父加载器 <strong><code>loadClass()</code> </strong>方法来加载类）。这样的话，所有的请求最终都会传送到顶层的启动类加载器 <code>BootstrapClassLoader</code> 中。</li><li>只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，<font color="red">子加载器才会尝试自己去加载</font>（调用自己的 <strong><code>findClass()</code> </strong>方法来加载类）。</li><li>如果子类加载器也无法加载这个类，那么它会抛出一个 <code>ClassNotFoundException</code> 异常。</li></ul><blockquote><p>🌈 拓展一下：</p><p><font color="red">JVM 判定两个 Java 类是否相同的具体规则</font>：<strong><font color="red">JVM 不仅要看类的全名是否相同，还要看加载此类的类加载器是否一样</font></strong>。只有两者都相同的情况，才认为两个类是相同的。即使两个类来源于同一个 <code>Class</code> 文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相同。</p></blockquote><h4 id="优缺点-2"><a class="anchor" href="#优缺点-2">#</a> 优缺点</h4><p>双亲委派机制的优点：</p><ul><li><p><font color="red">可以避免某一个类被重复加载</font>，当父类加载器已经加载后则无需重复加载，保证全局唯一性</p></li><li><p>保护程序安全，<font color="red">防止类库的核心 API 被随意篡改</font></p><blockquote><p>例如：在工程中新建 java.lang 包，接着在该包下新建 String 类，并定义 main 函数</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">String</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"demo info"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>此时执行 main 函数会出现异常，在类 java.lang.String 中找不到 main 方法。因为双亲委派的机制，java.lang.String 在启动类加载器（Bootstrap）得到加载，启动类加载器优先级更高，在核心 jre 库中有其相同名字的类文件，但该类中并没有 main 方法。</p></blockquote></li></ul><p>双亲委派机制的缺点：</p><ul><li>检查类是否加载的委托过程是单向的，这个方式虽然从结构上看比较清晰，使各个 ClassLoader 的职责非常明确，但<strong>顶层的 ClassLoader 无法访问底层的 ClassLoader 所加载的类</strong>（可见性）</li></ul><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/68747470733a2f2f7365617a65616e2e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f696d672f4a6176612f4a564d2de58f8ce4bab2e5a794e6b4bee6a8a1e59e8b2e706e67" alt="img"></p><h4 id="打破双亲委派模型"><a class="anchor" href="#打破双亲委派模型">#</a> 打破双亲委派模型</h4><p><font color="red">双亲委派模型并不是一种强制性的约束，只是 JDK 官方推荐的一种类加载器实现方式</font>。因为某些特殊需求，我们<font color="red">可以打破双亲委派模型</font>。</p><h5 id="方式1自定义类加载器"><a class="anchor" href="#方式1自定义类加载器">#</a> 方式 1：自定义类加载器</h5><p>如果想要避免双亲委派机制，可以<strong>自定义一个类加载器，继承 <code>ClassLoader</code> ，重写 <code>loadClass()</code> 方法</strong>。</p><ul><li>如果不想破坏双亲委派模型，继承 ClassLoader 后，只需要重写 findClass () 方法</li><li>如果想要破坏双亲委派模型，继承 CLassLoader 后，需要重写 loadClass () 方法</li></ul><p>举个例子，Tomcat 服务器为了能够优先加载 Web 应用目录下的类，然后再加载其他目录下的类，就自定义了类加载器 <code>WebAppClassLoader</code> 来打破双亲委托机制。这也是 Tomcat 下 Web 应用之间的类实现隔离的具体原理。</p><p>Tomcat 的类加载器的层次结构如下：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/tomcat-class-loader-parents-delegation-model.png" alt="Tomcat 的类加载器的层次结构"></p><p>Tomcat 这四个自定义的类加载器对应的目录如下：</p><ul><li><code>CommonClassLoader</code> 对应 <code>&lt;Tomcat&gt;/common/*</code></li><li><code>CatalinaClassLoader</code> 对应 <code>&lt;Tomcat &gt;/server/*</code></li><li><code>SharedClassLoader</code> 对应 <code>&lt;Tomcat &gt;/shared/*</code></li><li><code>WebAppClassloader</code> 对应 <code>&lt;Tomcat &gt;/webapps/&lt;app&gt;/WEB-INF/*</code></li></ul><p>从图中的委派关系中可以看出：</p><ul><li><code>CommonClassLoader</code> 作为 <code>CatalinaClassLoader</code> 和 <code>SharedClassLoader</code> 的父加载器。 <code>CommonClassLoader</code> 能加载的类都可以被 <code>CatalinaClassLoader</code> 和 <code>SharedClassLoader</code> 使用。因此， <code>CommonClassLoader</code> 是为了实现公共类库（可以被所有 Web 应用和 Tomcat 内部组件使用的类库）的共享和隔离。</li><li><code>CatalinaClassLoader</code> 和 <code>SharedClassLoader</code> 能加载的类则与对方相互隔离。 <code>CatalinaClassLoader</code> 用于加载 Tomcat 自身的类，为了隔离 Tomcat 本身的类和 Web 应用的类。 <code>SharedClassLoader</code> 作为 <code>WebAppClassLoader</code> 的父加载器，专门来加载 Web 应用之间共享的类比如 Spring、Mybatis。</li><li>每个 Web 应用都会创建一个单独的 <code>WebAppClassLoader</code> ，并在启动 Web 应用的线程里设置线程上下文类加载器为 <code>WebAppClassLoader</code> 。各个 <code>WebAppClassLoader</code> 实例之间相互隔离，进而实现 Web 应用之间的类隔。</li></ul><h5 id="方式2线程上下文类加载器"><a class="anchor" href="#方式2线程上下文类加载器">#</a> 方式 2：线程上下文类加载器</h5><p><font color="red">单纯依靠自定义类加载器没办法满足某些场景的要求</font>，例如，有些情况下，<font color="red">高层的类加载器需要加载低层的加载器才能加载的类</font>。</p><p>Java 提供了很多 <code>服务提供者接口（Service Provider Interface，SPI）</code> ，允许第三方为这些接口提供实现。常见的有 JDBC、JCE、JNDI 等。这些 SPI 接口由 Java 核心库来提供，而 SPI 的实现代码则是作为 Java 应用所依赖的 jar 包被包含进类路径 classpath 里，<font color="gree">SPI 接口中的代码需要加载具体的实现类</font>：</p><ul><li><font color="gree">SPI 的接口是 Java 核心库的一部分，由 BootstrapClassloader 加载</font></li><li><font color="gree">SPI 的实现类是由 ApplicationClassLoader 加载</font>，BootstrapClassloader 是无法找到 SPI 的实现类，因为双亲委派模型中 BootstrapClassloader 无法委派 ApplicationClassLoader 来加载类</li></ul><p>JDK 开发人员引入了 <code>线程上下文类加载器（Thread Context ClassLoader）</code> ，这种类加载器可以通过 Thread 类的 setContextClassLoader 方法进行设置线程上下文类加载器，<strong>在执行线程中抛弃双亲委派加载模式，使程序可以逆向委派类加载器，使 BootstrapClassloader 拿到了 ApplicationClassLoader 加载的类，破坏了双亲委派模型</strong>。</p><p>原理：<strong>将一个类加载器保存在线程私有数据里，跟线程绑定，然后在需要的时候取出来使用</strong>。这个类加载器通常是由应用程序或者容器（如 Tomcat）设置的。</p><blockquote><p><code>Java.lang.Thread</code> 中的 <code>getContextClassLoader()</code> 和 <code>setContextClassLoader(ClassLoader cl)</code> 分别用来获取和设置线程的上下文类加载器。如果没有通过 <code>setContextClassLoader(ClassLoader cl)</code> 进行设置的话，线程将<font color="red">默认继承其父线程的上下文类加载器</font>。</p></blockquote><p>Spring 获取线程上下文类加载器的代码如下：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre>cl <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getContextClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h2 id="6-运行期优化"><a class="anchor" href="#6-运行期优化">#</a> 6、运行期优化</h2><blockquote><p>在解释执行时，JVM 会对热点代码进行优化</p></blockquote><h3 id="即时编译jit"><a class="anchor" href="#即时编译jit">#</a> 即时编译（JIT）</h3><blockquote><p>Just-in-time Compilation</p></blockquote><p>即时编译（JIT）通过<strong>在运行时将<u>运行次数多的热点字节码</u>编译成机器码，从而改善性能</strong>。HotSpot 内嵌了两个 JIT 编译器，分别为 Client Compiler 和 Server Compiler，简称 C1 编译器和 C2 编译器。</p><p><strong>C1 编译器</strong>会对字节码进行<font color="red">简单的优化，耗时短，编译速度快</font>，具体的优化方法如下：</p><ul><li><p><font color="cornflowerblue">方法内联</font>：<strong><font color="red">将调用的函数代码编译到调用点处</font></strong>，这样可以减少栈帧的生成，减少参数传递以及跳转过程。</p><blockquote><p><font color="cornflowerblue">常量折叠</font></p></blockquote></li><li><p><font color="cornflowerblue">冗余消除</font>：根据运行时状况进行代码折叠或削除</p></li><li><p><font color="cornflowerblue">内联缓存</font>：是一种加快动态绑定的优化技术（方法调用部分详解）</p></li></ul><p><strong>C2 编译器</strong>会对字节码进行<font color="red">激进的优化，耗时长，编译速度慢，但优化后的代码执行效率更高</font>，当激进优化的假设不成立时，再退回使用 C1 编译，这也是使用分层编译的原因。C2 的优化主要是在全局层面，逃逸分析是优化的基础：</p><ul><li><font color="cornflowerblue">同步锁消除</font></li><li><font color="cornflowerblue">标量替换</font></li><li><font color="cornflowerblue">栈上分配</font></li></ul><p>HotSpot 在实现 JIT 时有三种选择： <code>C1</code> 、 <code>C2</code> 和 <code>C1+C2</code> （分层编译）</p><ul><li>C1：编译速度快，优化方式比较保守</li><li>C2：编译速度慢，优化方式比较激进</li><li>C1+C2：<font color="red">在开始阶段采用 C1 编译，当代码运行到一定热度之后采用 C2 重新编译</font></li></ul><p>对应的 VM 参数设置：</p><ul><li>-client：指定 Java 虚拟机运行在 Client 模式下，并使用 C1 编译器</li><li>-server：指定 Java 虚拟机运行在 Server 模式下，并使用 C2 编译器</li><li><code>-server -XX:+TieredCompilation</code> ：在 1.8 之前，分层编译默认是关闭的，可以添加该参数开启</li></ul><h4 id="分层编译"><a class="anchor" href="#分层编译">#</a> 分层编译</h4><blockquote><p>Tiered Compilation</p></blockquote><p><strong>分层编译策略 (Tiered Compilation)</strong>：程序解释执行可以触发 C1 编译，将字节码编译成机器码，加上性能监控，C2 编译会根据性能监控信息进行激进优化，JVM 将执行状态分成了 5 个层次：</p><ul><li>0 层，使用<font color="cornflowerblue">解释器（Interpreter）</font>进行<font color="gree">解释执行</font></li><li>1 层，使用 C1 <font color="cornflowerblue">即时编译器</font>进行<font color="gree">编译执行</font>（不带 profiling）</li><li>2 层，使用 C1 即时编译器编译执行（带基本的 profiling）</li><li>3 层，使用 C1 即时编译器编译执行（带完全的 profiling）</li><li>4 层，使用 C2 即时编译器编译执行（C1 和 C2 协作运行）</li></ul><blockquote><p>说明：profiling 是指在运行过程中收集一些程序执行状态的数据，例如【方法的调用次数】，【循环的回边次数】等</p></blockquote><p>解释器（Interpreter）v.s 即时编译器（JIT Compiler）：</p><ul><li>解释器<ul><li>将字节码<font color="gree">解释</font>为机器码，下次即使遇到相同的字节码，仍会执行重复的解释</li><li>是将字节码<font color="red">解释为所有平台通用的机器码</font></li></ul></li><li>即时编译器<ul><li>将一些<font color="red">热点的</font>字节码<font color="gree">编译</font>为机器码，并<font color="red">存入 Code Cache</font>，下次遇到相同的代码，直接执行，无需再编译</li><li>根据平台类型，<font color="red">生成平台特定的机器码</font></li></ul></li></ul><blockquote><p>总的目标是<strong>发现热点代码，并优化</strong></p><ul><li>对于大部分的不常用代码，采取解释执行的方式运行</li><li>对于小部分的热点代码，可以将其编译成机器码，以达到理想的运行速度</li></ul></blockquote><p>下面介绍 JIT 的几种优化手段：逃逸分析、方法内联、字段优化。</p><h4 id="逃逸分析"><a class="anchor" href="#逃逸分析">#</a> 逃逸分析</h4><blockquote><p>Escape Analysis</p></blockquote><p>Java Hotspot 虚拟机可以<strong>分析新创建对象的作用域（判断是否逃逸），并决定是否在堆上分配内存</strong>。</p><p>逃逸分析的 JVM 参数如下：</p><ul><li>开启逃逸分析： <code>-XX:+DoEscapeAnalysis</code></li><li>关闭逃逸分析： <code>-XX:-DoEscapeAnalysis</code></li><li>显示分析结果： <code>-XX:+PrintEscapeAnalysis</code></li></ul><p>有两种逃逸情况：</p><ul><li>方法逃逸：当一个对象在方法中定义之后，被外部方法引用<ul><li><font color="cornflowerblue">全局逃逸</font>：一个对象的作用范围逃出了当前方法或者当前线程<ul><li>对象是一个静态变量</li><li>对象是一个全局变量赋值</li><li>对象是一个已经发生逃逸的对象</li><li>对象作为当前方法的返回值</li></ul></li><li><font color="cornflowerblue">参数逃逸</font>：一个对象被作为方法参数传递或者被参数引用</li></ul></li><li>线程逃逸：如类变量或实例变量，可能被其它线程访问到</li></ul><p>如果不存在逃逸行为，则可以对该对象进行如下优化：</p><ul><li><font color="cornflowerblue">同步锁消除</font>：</li><li><font color="cornflowerblue">标量替换</font>：</li><li><font color="cornflowerblue">栈上分配</font>：</li></ul><h4 id="方法内联"><a class="anchor" href="#方法内联">#</a> 方法内联</h4><blockquote><p>In Lining</p></blockquote><p>如果 JVM 监测到一些小方法被频繁执行，它会<strong>把方法的调用替换成方法体本身</strong>。方法内联<font color="red">能够消除方法调用的固定开销</font>，任何方法除非被内联，否则调用都会有固定开销，来源于保存程序在该方法中的执行位置，以及新建、压入和弹出新方法所使用的栈帧。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">square</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>	<span class="token keyword">return</span> i <span class="token operator">*</span> i<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token function">square</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>square 是热点方法，会进行内联，<font color="red">把方法内代码拷贝粘贴到调用者的位置</font>：</p><pre><code>System.out.println(9 * 9);
</code></pre><p>还能够进行<font color="cornflowerblue">常量折叠（constant folding）</font>的优化：</p><pre><code>System.out.println(81);
</code></pre><h4 id="字段优化"><a class="anchor" href="#字段优化">#</a> 字段优化</h4><p>尽可能减少对成员变量的读取次数，考虑使用局部变量作缓存来代替。</p><p>可以手动优化，也可以借助方法内联自动优化。</p><h3 id="反射优化"><a class="anchor" href="#反射优化">#</a> 反射优化</h3><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Reflect1</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    	<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"foo..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token comment">// 通过反射调用 static 方法 foo ()</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token class-name">Method</span> foo <span class="token operator">=</span> <span class="token class-name">Reflect1</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token string">"foo"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">16</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\t"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>            <span class="token comment">// 因为是 static 方法，所以对象参数为 null</span></pre></td></tr><tr><td data-num="11"></td><td><pre>            foo<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>foo.invoke 在 0 ~ 15 次调用的是 MethodAccessor 的实现类 <code>NativeMethodAccessorImpl.invoke0()</code> ，本地方法执行速度慢。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">invoke</span><span class="token punctuation">(</span><span class="token class-name">Object</span> obj<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">//inflationThreshold 膨胀阈值，默认 15</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>numInvocations <span class="token operator">></span> <span class="token class-name">ReflectionFactory</span><span class="token punctuation">.</span><span class="token function">inflationThreshold</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token class-name">ReflectUtil</span><span class="token punctuation">.</span><span class="token function">isVMAnonymousClass</span><span class="token punctuation">(</span>method<span class="token punctuation">.</span><span class="token function">getDeclaringClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token comment">// 使用 ASM 动态生成的新实现类代替本地实现，速度较本地实现快 20 倍左右</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token class-name">MethodAccessorImpl</span> generatedMethodAccessor <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">MethodAccessorImpl</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre>            <span class="token keyword">new</span> <span class="token class-name">MethodAccessorGenerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="8"></td><td><pre>            <span class="token function">generateMethod</span><span class="token punctuation">(</span>method<span class="token punctuation">.</span><span class="token function">getDeclaringClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="9"></td><td><pre>                           method<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="10"></td><td><pre>                           method<span class="token punctuation">.</span><span class="token function">getParameterTypes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="11"></td><td><pre>                           method<span class="token punctuation">.</span><span class="token function">getReturnType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="12"></td><td><pre>                           method<span class="token punctuation">.</span><span class="token function">getExceptionTypes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="13"></td><td><pre>                           method<span class="token punctuation">.</span><span class="token function">getModifiers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        parent<span class="token punctuation">.</span><span class="token function">setDelegate</span><span class="token punctuation">(</span>generatedMethodAccessor<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token comment">// 【调用本地方法实现】</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token keyword">return</span> <span class="token function">invoke0</span><span class="token punctuation">(</span>method<span class="token punctuation">,</span> obj<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">native</span> <span class="token class-name">Object</span> <span class="token function">invoke0</span><span class="token punctuation">(</span><span class="token class-name">Method</span> m<span class="token punctuation">,</span> <span class="token class-name">Object</span> obj<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>当调用到 16 次时，会采用运行时生成的类 <code>sun.reflect.GeneratedMethodAccessor1</code> 代替。</p><blockquote><p>可以使用阿里的 arthas 工具进行反编译</p></blockquote><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">package</span> <span class="token namespace">sun<span class="token punctuation">.</span>reflect</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">import</span> <span class="token import"><span class="token namespace">cn<span class="token punctuation">.</span>itcast<span class="token punctuation">.</span>jvm<span class="token punctuation">.</span>t3<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span></span><span class="token class-name">Reflect1</span></span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span></span><span class="token class-name">InvocationTargetException</span></span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">import</span> <span class="token import"><span class="token namespace">sun<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span></span><span class="token class-name">MethodAccessorImpl</span></span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GeneratedMethodAccessor1</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">extends</span> <span class="token class-name">MethodAccessorImpl</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token comment">/*</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    * Loose catch block</pre></td></tr><tr><td data-num="9"></td><td><pre>    * Enabled aggressive block sorting</pre></td></tr><tr><td data-num="10"></td><td><pre>    * Enabled unnecessary exception pruning</pre></td></tr><tr><td data-num="11"></td><td><pre>    * Enabled aggressive exception aggregation</pre></td></tr><tr><td data-num="12"></td><td><pre>    * Lifted jumps to return sites</pre></td></tr><tr><td data-num="13"></td><td><pre>    */</pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">invoke</span><span class="token punctuation">(</span><span class="token class-name">Object</span> object<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arrobject<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InvocationTargetException</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token comment">// 比较奇葩的做法，如果有参数，那么抛非法参数异常</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        block4 <span class="token operator">:</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>arrobject <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> arrobject<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">break</span> block4<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>        <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="20"></td><td><pre>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>            <span class="token comment">// 可以看到，已经是直接调用了😱😱😱</span></pre></td></tr><tr><td data-num="22"></td><td><pre>            <span class="token class-name">Reflect1</span><span class="token punctuation">.</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>            <span class="token comment">// 没有返回值</span></pre></td></tr><tr><td data-num="24"></td><td><pre>            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>        <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="26"></td><td><pre>        <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> throwable<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>        	<span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">InvocationTargetException</span><span class="token punctuation">(</span>throwable<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>        <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="29"></td><td><pre>        <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ClassCastException</span> <span class="token operator">|</span> <span class="token class-name">NullPointerException</span> runtimeException<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>        	<span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">.</span><span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="31"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="33"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>通过查看 ReflectionFactory 源码可知：</p><ul><li><code>sun.reflect.noInflation</code> 可以用来禁用膨胀，直接生成 GeneratedMethodAccessor1，但首次生成比较耗时，如果仅反射调用一次，不划算</li><li><code>sun.reflect.inflationThreshold</code> 可以修改膨胀阈值</li></ul><h1 id="第五章jvm-内存模型jmm"><a class="anchor" href="#第五章jvm-内存模型jmm">#</a> 第五章：JVM 内存模型（JMM）</h1><h2 id="0-前置知识"><a class="anchor" href="#0-前置知识">#</a> 0、前置知识</h2><h3 id="cpu-缓存模型"><a class="anchor" href="#cpu-缓存模型">#</a> CPU 缓存模型</h3><p>为什么要弄一个 CPU 高速缓存呢？类比我们开发网站后台系统使用的缓存（比如 Redis）是为了解决程序处理速度和访问常规关系型数据库速度不对等的问题。<font color="red">CPU 缓存是为了解决 CPU 处理速度和内存处理速度不对等的问题</font>。</p><p>我们甚至<font color="red">可以把内存看作外存的高速缓存</font>，程序运行的时候我们把外存的数据复制到内存，由于内存的处理速度远远高于外存，这样提高了处理速度。</p><p>总结：<strong> <code>CPU Cache</code> 缓存的是内存数据，用于解决 CPU 处理速度和内存处理速度不匹配的问题； <code>内存</code> 缓存的是硬盘数据，用于解决硬盘访问速度过慢的问题。</strong></p><p>为了更好地理解，我画了一个简单的 CPU Cache 示意图如下所示：</p><blockquote><p>现代的 CPU Cache 通常分为三层，分别叫 L1、L2 和 L3 Cache</p></blockquote><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231005092754737.png" alt="CPU 缓存模型示意图"></p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231005093509524.png" alt="CPU三级缓存架构"></p><p><font color="red">CPU Cache 的工作方式</font>： 先复制一份数据到 CPU Cache 中，当 CPU 需要用到的时候就可以直接从 CPU Cache 中读取数据，当运算完成后，再将运算得到的数据写回 Main Memory 中。但是，这样存在 <strong>内存缓存不一致性的问题</strong> ！比如我执行一个 i++ 操作的话，如果两个线程同时执行的话，假设两个线程从 CPU Cache 中读取的 i=1，两个线程做了 i++ 运算完之后再写回 Main Memory 之后 i=2，而正确结果应该是 i=3。</p><p>**CPU 为了解决内存缓存不一致性问题，可以通过制定 <code>缓存一致协议</code> （比如 <span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvTUVTSSVFNSU4RCU4RiVFOCVBRSVBRQ==">MESI 协议</span>）或者其他手段来解决。** 这个缓存一致性协议指的是<font color="red">在 CPU Cache 与主内存交互的时候需要遵守的原则和规范</font>。不同的 CPU 中，使用的缓存一致性协议通常也会有所不同。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231005094116722.png" alt="缓存一致性协议"></p><p>我们的程序运行在操作系统之上，操作系统屏蔽了底层硬件的操作细节，将各种硬件资源虚拟化。于是，操作系统也就同样需要解决内存缓存不一致性问题。</p><p>操作系统通过 ** 内存模型（Memory Model）** 定义一系列规范来解决这个问题。无论是 Windows 系统，还是 Linux 系统，它们都有特定的内存模型。</p><h3 id="指令重排序"><a class="anchor" href="#指令重排序">#</a> 指令重排序</h3><p>为了提升执行速度 / 性能，计算机在执行程序代码的时候，会对指令进行重排序。</p><p>什么是指令重排序？简单来说就是<strong>系统在执行代码的时候并不一定是按照你写的代码的顺序依次执行</strong>。</p><p>常见的指令重排序有下面 2 种情况：</p><ul><li><strong>编译器优化重排</strong>：编译器（包括 JVM、JIT 编译器等）在不改变单线程程序语义的前提下，重新安排语句的执行顺序。</li><li><strong>指令并行重排</strong>：现代处理器采用了指令级并行技术 (Instruction-Level Parallelism，ILP) 来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</li></ul><p>另外，内存系统也会有 “重排序”，但又不是真正意义上的重排序。在 JMM 里表现为主存和本地内存的内容可能不一致，进而导致程序在多线程下执行可能出现问题。</p><p>Java 源代码会经历 <strong>编译器优化重排 —&gt; 指令并行重排 —&gt; 内存系统重排</strong> 的过程，最终才变成操作系统可执行的指令序列。</p><p><strong>指令重排序可以保证串行语义一致，但是没有义务保证多线程间的语义也一致</strong> ，所以在多线程下，指令重排序可能会导致一些问题。</p><p>编译器和处理器的指令重排序的处理方式不一样。</p><ul><li>编译器：通过禁止特定类型的编译器重排序的方式来禁止重排序。</li><li>处理器：通过插入 <code>内存屏障（Memory Barrier）</code> 的方式来禁止特定类型的处理器重排序。指令并行重排和内存系统重排都属于是处理器级别的指令重排序。</li></ul><blockquote><p>内存屏障（Memory Barrier，或有时叫做内存栅栏，Memory Fence）是一种 CPU 指令，用来禁止处理器指令发生重排序（像屏障一样），从而保障指令执行的有序性。另外，为了达到屏障的效果，它也会使处理器写入、读取值之前，将主内存的值写入高速缓存，清空无效队列，从而保障变量的可见性。</p></blockquote><h2 id="1-jmmjava-memory-model"><a class="anchor" href="#1-jmmjava-memory-model">#</a> 1、JMM（Java Memory Model）</h2><h3 id="简介"><a class="anchor" href="#简介">#</a> 简介</h3><p>一般来说，编程语言也可以直接复用操作系统层面的内存模型。不过，<font color="red">不同的操作系统内存模型不同</font>。如果直接复用操作系统层面的内存模型，就可能会导致同样一套代码换了一个操作系统就无法执行了。<font color="red">Java 语言是跨平台的，它需要自己提供一套内存模型以屏蔽系统差异</font>。</p><p>简单的说，<strong>JMM 定义了一套在<u>多线程</u>读写共享数据（成员变量、数组）时，对数据的可见性、有序性、和原子性的规则和保障</strong>。可以把 JMM 看作是 Java 定义的并发编程相关的一组规范，除了抽象了线程和主内存之间的关系之外，其还规定了从 Java 源代码到 CPU 可执行指令的这个转化过程要遵守哪些和并发相关的原则和规范，<font color="red">JMM 主要目的是为了简化多线程并发编程，增强程序可移植性的</font>。</p><p>为什么要遵守这些并发相关的原则和规范呢？这是因为<font color="red">并发编程下，像 CPU 多级缓存和指令重排序这类设计可能会导致程序运行出现一些问题</font>。就比如说我们上面提到的指令重排序就可能会让多线程程序的执行出现问题，为此，<strong>JMM 抽象了 happens-before 原则来解决多线程下的指令重排序问题</strong>。</p><p>JMM 说白了就是定义了一些规范来解决这些问题，开发者可以利用 JMM 规范更方便地开发多线程程序。对于 Java 开发者说，你不需要了解底层原理，直接使用并发相关的一些关键字和类（比如 <code>volatile</code> 、 <code>synchronized</code> 、各种 <code>Lock</code> ）即可开发出并发安全的程序。</p><h3 id="对线程-主内存的抽象"><a class="anchor" href="#对线程-主内存的抽象">#</a> 对线程、主内存的抽象</h3><p>Java 内存模型（JMM）抽象了线程和主内存之间的关系，就比如说线程之间的共享变量必须存储在主内存中。</p><p>在 JDK1.2 之前，Java 的内存模型实现总是从 <font color="red">主内存（即共享内存）</font>读取变量，是不需要进行特别的注意的。而在当前的 Java 内存模型下，线程可以把变量保存 <font color="red">本地内存（比如机器的寄存器）</font>中，而不是直接在主存中进行读写。这就可能造成一个线程在主存中修改了一个变量的值，而另外一个线程还继续使用它在寄存器中的变量值的拷贝，造成数据的不一致。这和我们上面讲到的 CPU 缓存模型非常相似。</p><p>什么是主内存？什么是本地内存？</p><ul><li><strong>主内存</strong>：<font color="red">所有线程</font>创建的实例对象都存放在主内存中，不管该实例对象是成员变量还是方法中的本地变量 (也称局部变量)</li><li><strong>本地内存</strong>：每个<font color="red">线程私有</font>的本地内存，存储<font color="red">共享变量的副本</font>，并且，每个线程只能访问自己的本地内存，无法访问其他线程的本地内存。</li></ul><p>Java 内存模型的抽象示意图如下：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/jmm.png" alt="JMM(Java 内存模型)"></p><p>从上图来看，线程 1 与线程 2 之间如果要进行通信的话，必须要经历下面 2 个步骤：</p><ol><li>线程 1 把本地内存中修改过的共享变量副本的值同步到主内存中去。</li><li>线程 2 到主内存中读取对应的共享变量的值。</li></ol><p>也就是说，<strong>JMM 为共享变量提供了可见性的保障</strong>。</p><p>不过，多线程下，对主内存中的一个共享变量进行操作有可能诱发<font color="red">线程安全问题</font>。举个例子：</p><ol><li>线程 1 和线程 2 分别对同一个共享变量进行操作，一个执行修改，一个执行读取。</li><li>线程 2 读取到的是线程 1 修改之前的值还是修改后的值并不确定，都有可能，因为线程 1 和线程 2 都是先将共享变量从主内存拷贝到对应线程的工作内存中。</li></ol><p>关于<font color="red">主内存与工作内存之间的具体交互协议</font>，即一个变量如何从主内存拷贝到工作内存，如何从工作内存同步到主内存之间的实现细节，Java 内存模型定义来以下<font color="red">八种同步操作</font>（了解即可，无需死记硬背）：</p><ul><li><strong>锁定（lock）</strong>: 作用于主内存中的变量，将他标记为一个线程独享变量。</li><li><strong>解锁（unlock）</strong>: 作用于主内存中的变量，解除变量的锁定状态，被解除锁定状态的变量才能被其他线程锁定。</li><li><strong>read（读取）</strong>：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的 load 动作使用。</li><li><strong>load (载入)</strong>：把 read 操作从主内存中得到的变量值放入工作内存的变量的副本中。</li><li><strong>use (使用)</strong>：把工作内存中的一个变量的值传给执行引擎，每当虚拟机遇到一个使用到变量的指令时都会使用该指令。</li><li><strong>assign（赋值）</strong>：作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。</li><li><strong>store（存储）</strong>：作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的 write 操作使用。</li><li><strong>write（写入）</strong>：作用于主内存的变量，它把 store 操作从工作内存中得到的变量的值放入主内存的变量中。</li></ul><p>除了这 8 种同步操作之外，还规定了下面这些<font color="red">同步规则</font>来保证这些同步操作的正确执行（了解即可，无需死记硬背）：</p><ul><li><p>不允许一个线程无原因地（没有发生过任何 assign 操作）把数据从线程的工作内存同步回主内存中。</p></li><li><p>一个新的变量只能在主内存中 “诞生”，不允许在工作内存中直接使用一个未被初始化（load 或 assign）的变量，换句话说就是对一个变量实施 use 和 store 操作之前，必须先执行过了 assign 和 load 操作。</p></li><li><p>一个变量在同一个时刻只允许一条线程对其进行 lock 操作，但 lock 操作可以被同一条线程重复执行多次，多次执行 lock 后，只有执行相同次数的 unlock 操作，变量才会被解锁。</p></li><li><p>如果对一个变量执行 lock 操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行 load 或 assign 操作初始化变量的值。</p></li><li><p>如果一个变量事先没有被 lock 操作锁定，则不允许对它执行 unlock 操作，也不允许去 unlock 一个被其他线程锁定住的变量。</p></li><li><p>......</p></li></ul><h3 id="与java-内存区域的区别"><a class="anchor" href="#与java-内存区域的区别">#</a> 与 Java 内存区域的区别</h3><p>这是一个比较常见的问题，很多初学者非常容易搞混。Java 内存区域和内存模型是完全不一样的两个东西：</p><ul><li><font color="cornflowerblue">Java 内存结构</font>：与 JVM 的<font color="red">运行时区域</font>相关，定义了 JVM 在运行时如何分区存储程序数据，就比如说堆主要用于存放对象实例。</li><li><font color="cornflowerblue">Java 内存模型（JMM）</font>：与 Java 的<font color="red">并发编程</font>相关，抽象了线程和主内存之间的关系，就比如说线程之间的共享变量必须存储在主内存中，规定了从 Java 源代码到 CPU 可执行指令的这个转化过程要遵守哪些和并发相关的原则和规范，其主要目的是<font color="red">为了简化多线程编程，增强程序可移植性的</font>。</li></ul><h2 id="2-并发编程的三大特性"><a class="anchor" href="#2-并发编程的三大特性">#</a> 2、并发编程的三大特性</h2><h3 id="原子性"><a class="anchor" href="#原子性">#</a> 原子性</h3><p><strong>对于一次操作或者多次操作，要么所有的操作全部都得到执行并且不会受到任何因素的干扰而中断，要么都不执行</strong>。</p><p>在 Java 中，对原子性的实现可以借助：</p><ul><li><code>synchronized</code> ：可以保证任一时刻只有一个线程访问该代码块，因此可以保障原子性</li><li>各种 <code>Lock</code> ：可以保证任一时刻只有一个线程访问该代码块，因此可以保障原子性</li><li>各种原子类：利用 CAS (compare and swap) 操作（可能也会用到 <code>volatile</code> 或者 <code>final</code> 关键字）来保证原子操作。</li></ul><h4 id="问题分析static变量的自增-自减"><a class="anchor" href="#问题分析static变量的自增-自减">#</a> 问题分析：static 变量的自增、自减</h4><blockquote><p>Java 中对 static 变量的自增、自减并不是原子操作，而是由 4 条 JVM 字节码指令组成。</p></blockquote><p>问题提出：两个线程对初始值为 0 的 static 变量一个做自增，一个做自减，各做 5000 次，结果是 0 吗？</p><p>答：以上的结果可能是正数、负数、零。<strong><font color="red">因为 Java 中对 static 变量的自增、自减并不是原子操作，在多线程下 JVM 字节码指令可能交错执行</font></strong>。</p><p>例如对于 i++ 而言（i 为静态变量），实际会产生如下的 JVM 字节码指令：</p><pre><code>getstatic i 	// 获取静态变量i的值（压入栈顶）
iconst_1 		// 准备常量1（压入栈顶）
iadd 			// 加法（对栈顶两个元素执行）
putstatic i 	// 将修改后的值存入静态变量i
</code></pre><p>而对应 i-- 也是类似：</p><pre><code>getstatic i 	// 获取静态变量i的值（压入栈顶）
iconst_1 		// 准备常量1（压入栈顶）
isub 			// 减法（对栈顶两个元素执行）
putstatic i 	// 将修改后的值存入静态变量i
</code></pre><p>而 Java 的内存模型如下，完成静态变量的自增、自减需要在主内存和线程私有的工作内存中进行数据交换：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/JMM%EF%BC%88%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%EF%BC%89.png" alt="JMM（内存模型）"></p><p>如果是单线程以上 8 行代码是顺序执行（不会交错）没有问题。<font color="red">但多线程下这 8 行代码可能交错运行，导致结果出现正数 / 负数。</font></p><h4 id="解决方法synchronized"><a class="anchor" href="#解决方法synchronized">#</a> 解决方法：synchronized</h4><p><code>synchronized</code> （同步关键字），语法如下：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">synchronized</span><span class="token punctuation">(</span>对象<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>	原子操作的代码</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>利用它来解决并发编程中的原子性问题：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">static</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">static</span> <span class="token class-name">Object</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token class-name">Thread</span> t1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">5000</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 同步锁</span></pre></td></tr><tr><td data-num="7"></td><td><pre>            	i<span class="token operator">++</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        	<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    	<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    </pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token class-name">Thread</span> t2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">5000</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 同步锁</span></pre></td></tr><tr><td data-num="15"></td><td><pre>            	i<span class="token operator">--</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    </pre></td></tr><tr><td data-num="20"></td><td><pre>    t1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>    t2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>    </pre></td></tr><tr><td data-num="23"></td><td><pre>    t1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>    t2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>注意：</p><ol><li><strong>尽可能增大 synchronized 加锁的粒度</strong>，这样能减少 <code>montiorenter</code> 和 <code>montiorexit</code> 指令的执行次数，避免重复地加锁与解锁。</li><li>上例中 t1 和 t2 线程<strong>必须用 synchronized 锁住同一个 obj 对象</strong>，如果 t1 锁住的是 m1 对象，t2 锁住的是 m2 对象，就好比两个人分别进入了两个不同的房间，没法起到同步的效果。</li></ol></blockquote><h3 id="可见性"><a class="anchor" href="#可见性">#</a> 可见性</h3><p><strong>当一个线程对<u>共享变量</u>进行了修改，那么另外的线程都可以立即看到修改后的最新值</strong>。不能保证原子性，仅用在一个写线程，多个读线程的情况。</p><p>在 Java 中，对可见性的实现，可以借助：</p><ul><li><code>synchronized</code></li><li>各种 <code>Lock</code></li><li><code>volatile</code> ：如果我们将变量声明为 <code>volatile</code> ，这就指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。</li></ul><h4 id="问题分析退不出的循环"><a class="anchor" href="#问题分析退不出的循环">#</a> 问题分析：退不出的循环</h4><p>先来看一个现象，main 线程对 run 变量的修改对于 t 线程不可见，导致了 t 线程无法停止：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">static</span> <span class="token keyword">boolean</span> run <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token class-name">Thread</span> t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-></span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token keyword">while</span><span class="token punctuation">(</span>run<span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>            <span class="token comment">// ....</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    </pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    run <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">// 线程 t 不会如预想的停下来</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><ol><li><p>初始状态下，t 线程刚开始从<font color="gree">主内存</font>读取静态变量 run 的值到 t 线程私有的<font color="gree">工作内存（本地内存）</font>：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231005211810258.png" alt="image-20231005211810258"></p></li><li><p>因为 t 线程要频繁从主内存中读取 run 的值，JIT 编译器会将 run 的值缓存至自己<font color="gree">工作内存中的高速缓存</font>中，减少对主存中 run 的访问，提高效率：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231005212027650.png" alt="image-20231005212027650"></p></li><li><p>1 秒之后，main 线程读取并修改了 run 的值，最后同步至主内存。而 t 是从自己工作内存中的高速缓存中读取这个变量的值，结果永远是旧值</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231005212320605.png" alt="image-20231005212320605"></p></li></ol><h4 id="解决方法volatile"><a class="anchor" href="#解决方法volatile">#</a> 解决方法：volatile</h4><p>volatile（易变）关键字：可以<strong>用来修饰成员变量、静态成员变量，可以避免线程从自己工作内存的高速缓存中查找变量的值，必须到主存中获取变量的值</strong>，线程操作 volatile 变量都是直接操作主存。</p><blockquote><p>如果在前面示例的死循环中加入 System.out.println () 会发现即使不加 volatile 修饰符，线程 t 也能正确看到对 run 变量的修改了。这是因为<strong> println () 底层使用了 synchronized 关键字，它也强制要求当前线程只能从主存中获取变量的值！</strong></p></blockquote><h3 id="有序性"><a class="anchor" href="#有序性">#</a> 有序性</h3><p><strong>【指令重排】：JVM 为了优化，会在不影响正确性的前提下，调整代码的执行顺序，但在<font color="red">多线程下</font>指令重排会影响正确性！</strong></p><p>在 Java 中（JDK 5 以上）， <code>volatile</code> 关键字可以禁止指令进行重排序优化。</p><h4 id="问题分析诡异的求和结果"><a class="anchor" href="#问题分析诡异的求和结果">#</a> 问题分析：诡异的求和结果</h4><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">boolean</span> ready <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment">// 线程 1 执行此方法</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">actor1</span><span class="token punctuation">(</span><span class="token class-name">I_Result</span> r<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">if</span><span class="token punctuation">(</span>ready<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    	r<span class="token punctuation">.</span>r1 <span class="token operator">=</span> num <span class="token operator">+</span> num<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    	r<span class="token punctuation">.</span>r1 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="12"></td><td><pre></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token comment">// 线程 2 执行此方法</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">actor2</span><span class="token punctuation">(</span><span class="token class-name">I_Result</span> r<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>	num <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>	ready <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>I_Result 是一个对象，有一个属性 r1 用来保存结果，请问可能的结果有几种？</p><ul><li>情况 1：线程 1 先执行，这时 ready = false，所以进入 else 分支结果为 1</li><li>情况 2：线程 2 先执行 num = 2，但没来得及执行 ready = true，线程 1 执行，还是进入 else 分支，结果为 1</li><li>情况 3：线程 2 执行到 ready = true，线程 1 执行，这回进入 if 分支，结果为 4（因为 num 已经执行过了）</li><li>但我告诉你，结果还有可能是 0 😁😁😁，信不信吧！这种情况下是：线程 2 执行 ready = true，切换到线程 1，进入 if 分支，相加为 0，再切回线程 2 执行 num = 2。这种现象叫做<font color="red">【指令重排】</font>，是 JIT 编译器在运行时的一些优化。</li></ul><h4 id="解决方法volatile-2"><a class="anchor" href="#解决方法volatile-2">#</a> 解决方法：volatile</h4><p><strong><code>volatile</code> 修饰的变量，可以禁用指令重排</strong>。</p><h2 id="3-三大特性的实现方法"><a class="anchor" href="#3-三大特性的实现方法">#</a> 3、三大特性的实现方法</h2><h3 id="synchronized-关键字"><a class="anchor" href="#synchronized-关键字">#</a> synchronized 关键字</h3><blockquote><p>针对：<strong>原子性、可见性</strong></p></blockquote><h4 id="简介-2"><a class="anchor" href="#简介-2">#</a> 简介</h4><p><code>synchronized</code> 是 Java 中的一个关键字，翻译成中文是同步的意思，<strong>确保多个线程之间访问资源的同步性，可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行</strong>。</p><p>在 Java 早期版本中， <code>synchronized</code> 属于<font color="red">重量级锁</font>，效率低下。这是因为监视器锁（monitor）是依赖于底层的操作系统的 <code>Mutex Lock</code> 来实现的，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高。</p><p>不过，在 Java 6 之后， <code>synchronized</code> <font color="red">引入了大量的优化</font>，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术，来减少锁操作的开销，这些优化让 <code>synchronized</code> 锁的效率提升了很多。因此， <code>synchronized</code> 还是可以在实际项目中使用的，像 JDK 源码、很多开源框架都大量使用了 <code>synchronized</code> 。</p><h4 id="如何使用"><a class="anchor" href="#如何使用">#</a> 如何使用</h4><p>Java 中的每个对象都可以作为锁，具体变现为以下 3 种形式：</p><ol><li>对于普通同步方法，锁是当前实例对象</li><li>对于静态同步方法，锁是当前类的 Class 对象</li><li>对于同步方法块，锁是 synchronized 括号里配置的对象</li></ol><p>一个线程试图访问同步代码块时，必须获取锁，在退出或者抛出异常时，必须释放锁。</p><p><code>synchronized</code> 关键字的使用方式主要有下面 3 种：</p><p><strong>1、修饰实例方法</strong> （锁是当前对象实例）</p><p>给当前对象实例加锁，进入同步代码前要获得 <strong>当前对象实例的锁</strong> 。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 业务代码</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><strong>2、修饰静态方法</strong> （锁是当前类）</p><p>给当前类加锁，会作用于类的所有对象实例 ，进入同步代码前要获得 <strong>当前 class 的锁</strong>。</p><p>这是因为静态成员不属于任何一个实例对象，归整个类所有，不依赖于类的特定实例，被类的所有实例共享。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">synchronized</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 业务代码</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><font color="red">静态 <code>synchronized</code> 方法和非静态 <code>synchronized</code> 方法之间的调用并不互斥，因为二者的锁对象不同！</font>如果一个线程 A 调用一个实例对象的非静态 <code>synchronized</code> 方法，而线程 B 需要调用这个实例对象所属类的静态 <code>synchronized</code> 方法，是允许的，不会发生互斥现象，因为访问静态 <code>synchronized</code> 方法占用的锁是当前类的锁，而访问非静态 <code>synchronized</code> 方法占用的锁是当前实例对象锁。</p><p><strong>3、修饰代码块</strong> （锁是指定对象 / 类）</p><p>对括号里指定的对象 / 类加锁：</p><ul><li><code>synchronized(object)</code> 表示进入同步代码库前要获得 <strong>给定对象的锁</strong>。</li><li><code>synchronized(类.class)</code> 表示进入同步代码前要获得 <strong>给定 Class 的锁</strong></li></ul><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">synchronized</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 业务代码</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><strong>总结：</strong></p><ul><li><code>synchronized</code> 关键字加到 <code>static</code> 静态方法和 <code>synchronized(class)</code> 代码块上都是是给 Class 类上锁；</li><li><code>synchronized</code> 关键字加到实例方法上是给对象实例上锁；</li><li>尽量不要使用 <code>synchronized(String a)</code> 因为 JVM 中，字符串常量池具有缓存功能。</li></ul><h4 id="无法修饰构造方法"><a class="anchor" href="#无法修饰构造方法">#</a> 无法修饰构造方法</h4><p>先说结论：<strong>构造方法不能使用 synchronized 关键字修饰。</strong></p><p><font color="red">构造方法本身就属于线程安全的</font>，不存在同步的构造方法一说。</p><h4 id="底层原理获取-monitor"><a class="anchor" href="#底层原理获取-monitor">#</a> 底层原理：获取 Monitor</h4><h5 id="monitor-工作流程"><a class="anchor" href="#monitor-工作流程">#</a> Monitor 工作流程</h5><p><font color="cornflowerblue">Monitor（监视器 / 管程）</font>：每个 Java 对象都可以关联一个 Monitor 对象，<font color="red">Monitor 也是 class，其实例存储在堆中</font>。<strong><font color="red">如果使用 synchronized 给对象上锁（重量级），该对象的对象头中的 Mark Word 中就被设置指向 Monitor 对象的指针。</font></strong></p><p>在 HotSpot 虚拟机中，Monitor 是基于 C++ 的 <strong>ObjectMonitor 类</strong> 实现的，其主要成员包括：</p><ul><li>_owner：指向持有 ObjectMonitor 对象的线程</li><li>_WaitSet：存放处于 wait 状态的线程队列，即调用 wait () 方法的线程</li><li>_EntryList：存放处于等待锁 block 状态的线程队列</li><li>_count：约为_WaitSet 和 _EntryList 的节点数之和</li><li>_cxq: 多个线程争抢锁，会先存入这个单向链表</li><li>_recursions: 记录重入次数</li></ul><p>ObjectMonitor 的基本工作机制：</p><ul><li><p>开始时 Monitor 中 Owner 为 null</p></li><li><p>当 Thread-2 执行 synchronized (obj) 就会将 Monitor 的所有者 Owner 置为 Thread-2，Monitor 中只能有一个 Owner，<strong>obj 对象的 Mark Word 指向 Monitor</strong>，把<strong>对象原有的 MarkWord 存入线程栈中的锁记录</strong>中（轻量级锁部分详解）</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/68747470733a2f2f7365617a65616e2e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f696d672f4a6176612f4a55432d4d6f6e69746f72e5b7a5e4bd9ce58e9fe79086312e706e67" alt="img"></p></li><li><p>在 Thread-2 上锁的过程，Thread-3、Thread-4、Thread-5 也执行 synchronized (obj)，就会进入 EntryList BLOCKED（双向链表）</p></li><li><p>Thread-2 执行完同步代码块的内容，根据 obj 对象头中 Monitor 地址寻找，设置 Owner 为空，把线程栈的锁记录中的对象头的值设置回 MarkWord</p></li><li><p>唤醒 EntryList 中等待的线程来竞争锁，竞争是<strong>非公平的</strong>，如果这时有新的线程想要获取锁，可能直接就抢占到了，阻塞队列的线程就会继续阻塞</p></li><li><p>WaitSet 中的 Thread-0，是以前获得过锁，但条件不满足进入 WAITING 状态的线程（wait-notify 机制）</p></li></ul><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/68747470733a2f2f7365617a65616e2e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f696d672f4a6176612f4a55432d4d6f6e69746f72254535254237254135254534254244253943254535253845253946254537253930253836322e706e67" alt=""></p><p>注意：</p><ul><li>synchronized 必须是进入同一个对象的 Monitor 才有上述的效果</li><li>不加 synchronized 的对象不会关联监视器，不遵从以上规则</li></ul><h5 id="代码块同步"><a class="anchor" href="#代码块同步">#</a> 代码块同步</h5><p>JVM 基于进入和退出 Monitor 对象来实现代码块同步和方法同步，但是两者的实现细节不一样。</p><ol><li><strong>代码块同步：通过使用 <code>monitorenter</code> 和 <code>monitorexit</code> 指令实现的</strong></li><li><strong>同步方法： <code>ACC_SYNCHRONIZED</code> 修饰</strong></li></ol><p><strong>不过两者的本质都是对对象监视器 monitor 的获取。</strong></p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SynchronizedDemo</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"synchronized 代码块"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>通过 JDK 自带的 <code>javap</code> 命令查看 <code>SynchronizedDemo</code> 类的相关字节码信息：首先切换到类的对应目录执行 <code>javac SynchronizedDemo.java</code> 命令生成编译后的 .class 文件，然后执行 <code>javap -c -s -v -l SynchronizedDemo.class</code> 。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231005173458355.png" alt="synchronized关键字原理"></p><p>从上面我们可以看出：<strong> <code>synchronized</code> 同步语句块的实现使用的是 <code>monitorenter</code> 和 <code>monitorexit</code> 指令，其中 <code>monitorenter</code> 指令指向同步代码块的开始位置， <code>monitorexit</code> 指令则指明同步代码块的结束、异常位置。</strong></p><p>上面的字节码中包含一个 <code>monitorenter</code> 指令以及两个 <code>monitorexit</code> 指令，这是为了保证锁在同步代码块代码正常执行，以及出现异常的这两种情况下都能被正确释放。</p><p>当执行 <code>monitorenter</code> 指令时，线程试图获取锁也就是获取 <strong>对象监视器 <code>monitor</code> </strong>的持有权。</p><blockquote><p>在 Java 虚拟机 (HotSpot) 中，Monitor 是基于 C++ 实现的，由<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL29wZW5qZGstbWlycm9yL2pkazd1LWhvdHNwb3QvYmxvYi81MGJkZWZjM2FmZTk0NGNhNzRjMzA5M2U3NDQ4ZDZiODg5Y2QyMGQxL3NyYy9zaGFyZS92bS9ydW50aW1lL29iamVjdE1vbml0b3IuY3Bw"> ObjectMonitor</span> 实现的。每个对象中都内置了一个 <code>ObjectMonitor</code> 对象。</p><p>另外， <code>wait/notify</code> 等方法也依赖于 <code>monitor</code> 对象，这就是为什么只有在同步的块或者方法中才能调用 <code>wait/notify</code> 等方法，否则会抛出 <code>java.lang.IllegalMonitorStateException</code> 的异常的原因。</p></blockquote><p>在执行 <code>monitorenter</code> 时，会尝试获取对象的锁，如果锁的计数器为 0 则表示锁可以被获取，获取后将锁计数器设为 1 也就是加 1。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/synchronized-get-lock-code-block.png" alt="执行 monitorenter 获取锁"></p><p>对象锁的的拥有者线程才可以执行 <code>monitorexit</code> 指令来释放锁。在执行 <code>monitorexit</code> 指令后，将锁计数器设为 0，表明锁被释放，其他线程可以尝试获取锁。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231005173807293.png" alt="执行 monitorexit 释放锁"></p><p>如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止。</p><h5 id="方法同步"><a class="anchor" href="#方法同步">#</a> 方法同步</h5><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SynchronizedDemo2</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"synchronized 方法"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231005173909852.png" alt="synchronized关键字原理"></p><p><strong><code>synchronized</code> 修饰的方法并没有 <code>monitorenter</code> 指令和 <code>monitorexit</code> 指令，取而代之的是 <code>ACC_SYNCHRONIZED</code> 标识，指明了该方法是一个同步方法</strong>。JVM 通过该 <code>ACC_SYNCHRONIZED</code> 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。</p><p>如果是实例方法，JVM 会尝试获取<font color="gree">实例对象的锁</font>。如果是静态方法，JVM 会尝试获取<font color="gree">当前 class 的锁</font>。</p><h5 id="小结-4"><a class="anchor" href="#小结-4">#</a> 小结</h5><p><code>synchronized</code> 同步语句块的实现使用的是 <code>monitorenter</code> 和 <code>monitorexit</code> 指令，其中 <code>monitorenter</code> 指令指向同步代码块的开始位置， <code>monitorexit</code> 指令则指明同步代码块的结束位置。</p><p><code>synchronized</code> 同步方法的实现使用的是 <code>ACC_SYNCHRONIZED</code> 标识，该标识指明了该方法是一个同步方法。</p><p><strong>不过两者的本质都是对对象监视器 monitor 的获取。</strong></p><h4 id="jdk-16-后的优化"><a class="anchor" href="#jdk-16-后的优化">#</a> <mark>JDK 1.6 后的优化</mark></h4><h5 id="概述-4"><a class="anchor" href="#概述-4">#</a> 概述</h5><p>在多线程并发编程中 <code>synchronized</code> 一直是元老级角色，很多人都会称呼它为<strong>重量级锁</strong>。但是，随着 Java SE 1.6 对 synchronized 进行了各种优化之后，有些情况下它就并不那么重了。</p><p>JDK 1.6 对锁的实现引入了大量的优化，如<font color="red"><strong>偏向锁、轻量级锁</strong>、自旋锁、适应性自旋锁、锁粗化、锁消除</font>等技术来减少锁操作的开销。</p><p>锁主要存在四种状态，依次是：<font color="red">无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态</font>，他们会随着竞争的激烈而逐渐升级。注意<font color="red">锁可以升级不可降级</font>，这种策略是为了提高获得锁和释放锁的效率。</p><blockquote><p>关于这几种优化的详细信息可以查看下面这篇文章：<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vd3VxaW5nbG9uZy9wLzk5NDU2MTguaHRtbA==">Java6 及以上版本对 synchronized 的优化</span>。</p></blockquote><h5 id="java对象头"><a class="anchor" href="#java对象头">#</a> Java 对象头</h5><p>在 HotSpot 虚拟机中，对象在内存中的布局分为三块区域：</p><ul><li><font color="cornflowerblue">对象头</font></li><li><font color="cornflowerblue">实例数据</font></li><li><font color="cornflowerblue">对齐填充</font></li></ul><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231009112425668.png" alt="image-20231009112425668" style="zoom:67%"><p>其中，对象头中包含两部分：</p><blockquote><p>如果是数组对象的话，对象头还有一部分是存储<font color="gree">数组长度</font>。</p></blockquote><ul><li><p><font color="gree">Mark Word</font>：<font color="red">平时存储对象自身的运行时数据</font>，如 HashCode、GC 分代年龄；<font color="red">当加锁时，就替换为锁信息</font>，例如线程 ID、偏向锁标志、锁标志、锁记录的地址、锁监视器的地址等。</p><blockquote><p>Mark Word 所占用的内存大小与虚拟机的位长一致。</p></blockquote></li><li><p><font color="gree">class 指针</font>：虚拟机通过这个指针<font color="red">确定该对象是哪个类的实例</font>。</p></li></ul><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/20210130134419113.png" alt="普通对象的对象头"></p><center>（普通对象的对象头）</center><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231009112651734.png" alt="数组对象的对象头"></p><center>（数组对象的对象头）</center><p>多线程下 synchronized 的加锁就是对同一个对象的对象头中的 MarkWord 中的变量进行 CAS 操作。</p><h5 id="锁的升级"><a class="anchor" href="#锁的升级">#</a> 锁的升级</h5><p><strong>JDK 1.6 前的 synchronized 是可重入、不公平的重量级锁</strong>，所以可以对其进行优化。</p><blockquote><p>可重入：指一个线程首次获得了这把锁后，它有权利再次获取这把锁。<font color="red">如果是不可重入锁，那么第二次获得锁时，自己也会被锁挡住</font>。</p><p>不公平：等待锁的线程不会排队，而是可抢占的。</p></blockquote><p>级别从低到高依次是，随着竞争的激烈而逐渐升级：</p><ol><li><font color="cornflowerblue">无锁状态</font></li><li><font color="cornflowerblue">偏向锁状态</font></li><li><font color="cornflowerblue">轻量级锁状态</font></li><li><font color="cornflowerblue">重量级锁状态</font></li></ol><p><strong><font color="red">锁只能升级，不能降级</font></strong>，这种策略是为了提高获得锁和释放锁的效率。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231009130158308.png" alt="image-20231009130158308"></p><p>以 32 位系统为例，对于不同的锁状态，对象头中的 MarkWord 的内容如下：</p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231009111747426.png" alt="image-20231009111747426"><h6 id="无锁normal"><a class="anchor" href="#无锁normal">#</a> 无锁（Normal）</h6><table><thead><tr><th>25bit（对象的 hashCode）</th><th>4bit（age，对象的分代年龄）</th><th>1bit (是否是偏向锁)</th><th>2bit (锁标志位)</th></tr></thead><tbody><tr><td></td><td></td><td>0</td><td>01</td></tr></tbody></table><p>对象的 hashCode 是指 Object#hashCode 或者 System#identityHashCode 计算出来的值，不是用户覆盖产生的 hashCode。</p><h6 id="偏向锁biased"><a class="anchor" href="#偏向锁biased">#</a> 偏向锁（Biased）</h6><blockquote><p>偏向锁是三种锁中<strong>加锁消耗最小的，不需要操作系统的介入</strong>。经验表明大部分情况下，都会是同一个线程进入同一块同步代码块。即<strong>大多数情况下锁不存在竞争关系，而是总会被一个线程持有，因此不需要反复获取锁</strong>。</p></blockquote><table><thead><tr><th>23bit（线程 ID）</th><th>2bit（epoch）</th><th>4bit（age，对象的分代年龄）</th><th>1bit (是否是偏向锁)</th><th>2bit (锁标志位)</th></tr></thead><tbody><tr><td></td><td></td><td></td><td>1</td><td>01</td></tr></tbody></table><p><font color="gree">a、偏向锁的思想</font>：<font color="red">偏向于第一个获取锁对象的线程，该线程获得锁后就不会再有解锁操作了，之后重新获取该锁不需要同步操作，可以节省很多开销</font>。假如有两个线程来竞争锁的话，那么偏向锁就失效了，进而升级成轻量级锁了。</p><ul><li>当锁对象第一次被线程获得的时候进入偏向状态，<strong>JVM 使用 CAS 操作将线程 ID 记录到锁对象的对象头的 Mark Word 中</strong>。于是该线程就获得了锁，可以执行 synchronized 同步的代码。当这个线程再次进入这个锁对象相关的同步块时，先查看这个线程 ID 是不是自己，是则就表示没有竞争，不需要再次获得锁</li><li>当有另外一个线程也尝试去获取这个锁对象时，偏向状态就宣告结束，此时 ** 撤销偏向（Revoke Bias）** 后恢复到无锁状态 / 轻量级锁状态</li></ul><p><font color="gree">b、偏向锁对象的创建</font>：</p><ul><li><font color="red">偏向锁默认是开启的</font>，那么对象创建后，处于一个可偏向而未偏向的状态，其对象头中的 Mark Word 值为 0x05 ，即 **<font color="red">线程 ID、epoch、age 都为 0，后 3 位标识为 101</font>**<ul><li>线程 ID = 0 表示未加锁</li><li>添加 VM 参数 <code>-XX:-UseBiasedLocking</code> 可以禁用偏向锁</li></ul></li><li><font color="red">偏向锁默认是延迟的，不会在程序启动时立即生效</font><ul><li>可以加 VM 参数 <code>-XX:BiasedLockingStartupDelay=0</code> 来禁用延迟</li><li><font color="red">JDK 8 延迟 4s 开启偏向锁</font>的原因：刚开始执行代码时，会有很多线程来抢锁，如果一开始就开启偏向锁，效率反而降低</li></ul></li><li><font color="red">当一个对象已经计算过 hashCode，就再也无法进入偏向状态了，因为线程 ID、epoch 占用的是 hashCode 的位置</font><ul><li>对象什么时候会计算其 HashCode 呢？比如：将该对象作为 Map 的 Key 时。</li><li>但大部分情况不会触发计算 hashCode，比如：List，日常创建一个对象，持久化到库里，进行 json 序列化，或者作为临时对象等。</li></ul></li><li>反过来，如果对象处于偏向锁状态，并且需要计算其 identityHashCode 的话，则偏向锁会被撤销，升级为重量级锁</li></ul><p><font color="gree">c、偏向锁对象的加锁</font>：</p><ul><li><p>如果锁对象是未偏向状态（MarkWord 中的线程 ID=0），使用 CAS 操作将线程 ID 设置为自己的线程 ID，</p><ul><li><p>如果 CAS 操作成功，则成功获取偏向锁</p></li><li><p>如果 CAS 操作失败，说明该锁对象被其他线程竞争获取了，则需要进行锁升级（撤销）</p></li></ul></li><li><p>如果锁对象是已偏向状态（MarkWord 中的线程 ID≠0）</p><ul><li><p>如果 MarkWord 中的线程 ID 是自己的线程 ID，则成功获取偏向锁</p></li><li><p>如果 MarkWord 中的线程 ID 不是自己的线程 ID，则需要进行<strong>锁升级</strong>（撤销）</p></li></ul></li></ul><p><font color="gree">d、偏向锁对象的撤销</font>：</p><blockquote><p><strong><font color="red">偏向锁的锁升级需要进行偏向锁的撤销</font></strong>。</p></blockquote><p><strong>撤销的原因：</strong></p><ul><li>调用对象的 hashCode 方法</li><li>当有其它线程使用偏向锁对象时，会将偏向锁升级为轻量级锁</li><li>调用了 wait/notify 方法，需要申请 Monitor，进入 WaitSet。（调用 wait 方法会导致锁膨胀而使用重量级锁）</li></ul><p><strong>撤销的时机：全局安全点</strong>（GC 运行之前所有线程需要在安全点阻塞暂停，这就 GC 过程中常说的 <code>Stop The World</code> ），<strong>将偏向状态改为 0</strong>，验证已获取锁的线程是否存活，</p><ul><li>如果死亡，将锁标志位恢复到无锁状态，重新加锁</li><li>如果存活，将锁标志位升级为轻量级锁（00）</li></ul><p><strong>撤销的前提：锁对象处于已偏向状态（MarkWord 中的线程 ID≠0）</strong></p><p><strong>撤销的步骤：只有当偏向锁对象的 MarkWord 中指向的线程仍存活，且仍拥有锁时，才需要升级为轻量级锁。否则，根据是否允许重偏向（ <code>rebiasing</code> ），让锁对象变为可偏向但未偏向的状态。</strong></p><ul><li>如果 MarkWord 中指向的线程已死亡<ul><li>允许重偏向（ <code>rebiasing</code> ）：<strong>退回到可偏向但未偏向的状态（线程 ID 置为 0，后 3 位置为 101）</strong></li><li>不允许重偏向：<strong>变为无锁状态（前 29 位清空，后 3 位置为 001），重新加偏向锁（后 3 位置为 101）</strong></li></ul></li><li>如果 MarkWord 中指向的线程仍存活<ul><li>如果该线程不再拥有锁<ul><li>允许重偏向：退回到可偏向但未偏向的状态（线程 ID 置为 0，后 3 位置为 101）</li><li>不允许重偏向：变为无锁状态（前 29 位清空，后 3 位置为 001），重新加偏向锁（后 3 位置为 101）</li></ul></li><li>如果该线程仍然拥有锁<ul><li><strong>升级为轻量级锁</strong></li></ul></li></ul></li></ul><p><font color="gree">e、小结</font>：</p><p><strong>偏向级锁就是为了消除资源在无竞争情况下的同步原语</strong>，进一步提高了程序的运行性能。</p><p>我们假设线程 A 曾经拥有锁（不确定是否释放锁），线程 B 来竞争锁对象。</p><ul><li>如果线程 A 仍然存活，且仍然拥有锁，那么偏向锁升级为轻量级锁，线程 B 自旋请求获得锁</li><li>如果线程 A 已死亡，或者线程 A 不再拥有锁，线程 B 直接去尝试获得锁</li></ul><p>偏向锁的获取、撤销过程如下图：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/883454-20211126170433124-96869961.png" alt="img"></p><h6 id="轻量级锁lightweight-locked"><a class="anchor" href="#轻量级锁lightweight-locked">#</a> 轻量级锁（LightWeight Locked）</h6><blockquote><p>当一个线程运行同步代码块时，另一个线程也加入想要运行这个同步代码块时，偏向锁就会升级为轻量级锁。</p><p>之所以是轻量级，是因为它<strong>仅仅使用 CAS 进行操作，实现获取锁</strong>。</p></blockquote><table><thead><tr><th>30bit（指针，指向线程栈帧中的<strong>锁记录（Lock Record）</strong>）</th><th>2bit (锁标志位)</th></tr></thead><tbody><tr><td></td><td>00</td></tr></tbody></table><p><font color="gree">a、轻量级锁的思想</font>：采用 <strong>CAS 自旋锁</strong>的方式来完成加锁，相对于重量级锁加锁的代价相对小一些。如果一直获取不到锁状态，自旋占用的资源会超过重量级锁，所以<strong>轻量级锁膨胀为重量级锁的条件就是自旋达超过一定次数</strong>（默认为 10，可以修改 <code>PreBlockSpin</code> 参数调整）。</p><p><font color="gree">b、轻量级锁的加锁</font>：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231012104146340.png" alt="image-20231012104146340"></p><ul><li><p>首先，JVM 会在参与竞争的各个线程的栈帧中各自分配一块空间，称为<strong>锁记录（ <code>Lock Record</code> ）</strong>，并将锁对象的 Mark Word 拷贝到其中，称为 <code>Displaced Mark Word</code> ，用于记录原始的 Mark Word，便于后续的 CAS 操作。</p><blockquote><p>Lock Record 中除了 Displaced Mark Word，还有 <code>owner</code> （指向锁对象）。</p></blockquote></li><li><p>然后一个线程尝试获取锁：<strong>尝试通过 CAS，将锁对象的 Mark Word 中的锁记录指针，指向自身栈帧中的 Lock Record</strong>。</p><ul><li><p>如果 CAS 成功，再<font color="red">将锁对象中 MarkWord 的锁标识位设置为 00</font>，则当前线程成功获得轻量级锁</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/68747470733a2f2f7365617a65616e2e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f696d672f4a6176612f4a55432d254538254244254242254539253837253846254537254241254137254539253934253831254535253845253946254537253930253836322e706e67" alt="img"></p></li><li><p>如果 CAS 失败，有两种情况：</p><ul><li><p>如果是其他线程已经持有了该轻量级锁对象，则当前线程也不会阻塞，而是通过<strong>自旋</strong>的方式，重新等待尝试获取锁。当自旋达到一定次数（默认为 10）仍然未能获取锁，那么轻量级锁会<strong>膨胀成重量级锁</strong>。</p></li><li><p>如果是线程自身执行了 synchronized <strong>锁重入</strong>，就添加一条 Lock Record 作为重入的计数</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/68747470733a2f2f7365617a65616e2e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f696d672f4a6176612f4a55432d254538254244254242254539253837253846254537254241254137254539253934253831254535253845253946254537253930253836332e706e67" alt="img"></p></li></ul></li></ul></li><li><p>当持有锁的线程退出 synchronized 代码块时（解锁，即<font color="gree">轻量级锁的撤销</font>）</p><ul><li>如果有取值为 null 的锁记录，表示有重入，这时重置锁记录，表示重入计数减 1</li><li>如果锁记录的值不为 null，这时通过 CAS 将该线程栈中的 Displaced Mark Word 恢复给锁对象的 Mark Word，<ul><li>如果 CAS 成功，则解锁成功，此时其它线程可以尝试获取锁</li><li>如果 CAS 失败，说明轻量级锁进行了<strong>锁膨胀</strong>，此时进入重量级锁解锁流程</li></ul></li></ul></li></ul><p><font color="gree">c、小结</font>：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/v2-5e1e8fcf33123c8f189095ea4554fa35_720w.webp" alt="img"></p><h6 id="重量级锁heavyweight-locked"><a class="anchor" href="#重量级锁heavyweight-locked">#</a> 重量级锁（HeavyWeight Locked）</h6><blockquote><p>上面提到，当多个线程竞争同一个锁时，会导致除锁的拥有者外，其余线程都会自旋，这将导致自旋次数过多，cpu 效率下降，所以会将锁升级为重量级锁。</p></blockquote><table><thead><tr><th>30bit（指针，指向<strong>锁监视器（Monitor）</strong>）</th><th>2bit (锁标志位)</th></tr></thead><tbody><tr><td></td><td>10</td></tr></tbody></table><p><font color="gree">a、重量级锁的思想</font>：重量级锁是使用操作系统底层的<strong>互斥量（ <code>mutex</code> ）<strong>来实现的传统锁，会让抢占锁的线程</strong>从用户态转变为内核态，开销很大</strong>。与轻量级锁不同，<font color="red">竞争的线程不再通过自旋来等待获取锁，而是进入<strong> BLOCKED（锁阻塞）状态</strong>，此时不消耗 CPU，然后等待持有锁的线程释放锁，唤醒阻塞的线程，再次竞争锁</font>。</p><p><font color="gree">b、重量级锁的加锁</font>：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231012123713960.png" alt="image-20231012123713960"></p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231012124053959.png" alt="image-20231012124053959"></p><ul><li>当 Thread-1 尝试进行轻量级加锁时，发现 Thread-0 已经对该对象加了轻量级锁</li></ul><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/68747470733a2f2f7365617a65616e2e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f696d672f4a6176612f4a55432d254539253837253844254539253837253846254537254241254137254539253934253831254535253845253946254537253930253836312e706e67" alt="img"></p><center>（轻量级锁的锁标识位为00）</center><ul><li><p>Thread-1 加轻量级锁失败，进入 BLOCKED 状态，开始锁膨胀流程。首先，JVM 会<strong>为锁对象创建一个 Monitor 对象</strong>，</p><ul><li><font color="red">让锁对象的 MarkWord 指向 Monitor 对象的地址</font></li><li><font color="red">让 Monitor 对象的 Owner 指向当前持有锁的线程（Thread-0）</font></li><li><font color="red">将处于 BLOCKED（锁阻塞）状态的线程（Thread-1）添加到 Monitor 对象的 EntryList 中</font></li></ul><p><img data-src="https://camo.githubusercontent.com/2e4146030a4adc0d564145629706fd3baef75cb0d12142fe3f1cff6a6aa97e86/68747470733a2f2f7365617a65616e2e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f696d672f4a6176612f4a55432d254539253837253844254539253837253846254537254241254137254539253934253831254535253845253946254537253930253836322e706e67" alt="img"></p><center>（轻量级锁膨胀为重量级锁，锁标识位为10）</center></li><li><p>当 Thread-0 退出同步块解锁时，</p><ul><li>此时<font color="red">先尝试轻量级锁的撤销</font>（因为 Thread-0 还不知道锁已膨胀，锁标识位已经由 00 变为了 10），即尝试通过 CAS 操作将其栈中的 Displaced Mark Word 恢复给锁对象的 Mark Word，发现 CAS 失败，这时进入<font color="gree">重量级锁的解锁</font>流程</li><li>将 Monitor 对象的 <strong>Owner 设置为 null</strong>，同时<strong>唤醒 EntryList 中的 BLOCKED 线程</strong></li></ul></li></ul><h6 id="小结-5"><a class="anchor" href="#小结-5">#</a> 小结</h6><p>引入这些锁是为了提高获取锁的效率，要明白每种锁的使用场景。</p><ul><li>偏向锁适合一个线程对一个锁的多次获取的情况</li><li>轻量级锁适合锁执行体比较简单 (即减少锁粒度或时间)，自旋一会儿就可以成功获取锁的情况</li></ul><p><font color="cornflowerblue">偏向锁</font>：针对一个线程来说的，主要作用是<strong>优化同一个线程多次获取一个锁的情况</strong>。当一个线程执行了一个 synchronized 方法的时候，肯定能得到对象的 monitor ，这个方法所在的对象就会在 Mark Work 处设为偏向锁标记，还会有一个字段指向拥有锁的这个线程的线程 ID 。当这个线程再次访问同一个 synchronized 方法的时候，如果按照通常的方法，这个线程还是要尝试获取这个对象的 monitor ，再执行这个 synchronized 方法。但是由于 Mark Word 的存在，当第二个线程再次来访问的时候，就会检查这个对象的 Mark Word 的偏向锁标记，再判断一下这个字段记录的线程 ID 是不是跟第二个线程的 ID 是否相同的。如果相同，就<font color="red">无需再获取 monitor 了，直接进入方法体中</font>。</p><blockquote><p>如果是另一个线程访问这个 synchronized 方法，那么偏向锁就会被撤销，进而升级成轻量级锁。</p></blockquote><p><font color="cornflowerblue">轻量级锁</font>：若第一个线程已经获取到了当前对象的锁，这是第二个线程又开始尝试争抢该对象的锁，由于该对象的锁已经被第一个线程获取到，因此它是偏向锁。而第二个线程再争抢时，会发现该对象头中的 Mark Word 已经是偏向锁，但里面储存的线程 ID 并不是自己（是第一个线程），那么她会进行 CAS，从而获取到锁，这里面存在两种情况：</p><ul><li>获取到锁成功（一共只有两个线程）：那么它会将 Mark Word 中的线程 ID 由第一个线程变成自己 (偏向锁标记位保持不表)，这样该对象依然会保持偏向锁的状态</li><li>获取锁失败（一共不止两个线程）：则表示这时可能会有多个线程同时再尝试争抢该对象的锁，那么这是偏向锁就会进行升级，升级为轻量级锁<br>旋锁。若自旋失败，那么锁就会转化为重量级锁。在这种情况下，无法获取到锁的线程都会进入到 moniter (即内核态)，自旋最大的特点是避免了线程从用户态进入到内核态。</li></ul><h5 id="其他优化"><a class="anchor" href="#其他优化">#</a> 其他优化</h5><ol><li><p><font color="gree">减少上锁时间</font>：同步代码块中尽量短</p></li><li><p><font color="gree">减少锁的粒度</font>，将一个锁拆分为多个锁提高并发度，例如：</p><ul><li>ConcurrentHashMap</li><li>LongAdder 分为 base 和 cells 两部分。没有并发争用的时候或者是 cells 数组正在初始化的时候，会使用 CAS 来累加值到 base，有并发争用，会初始化 cells 数组，数组有多少个 cell，就允许有多少线程并行修改，最后将数组中每个 cell 累加，再加上 base 就是最终的值</li><li>LinkedBlockingQueue 入队和出队使用不同的锁，相对于 LinkedBlockingArray 只有一个锁效率要高</li></ul></li><li><p><font color="gree">读写分离</font>：</p><ul><li>CopyOnWriteArrayList</li><li>ConyOnWriteSet</li></ul></li></ol><h6 id="自旋锁"><a class="anchor" href="#自旋锁">#</a> 自旋锁</h6><p>多个线程竞争锁时，线程不会立即阻塞，可以使用<strong>自旋</strong>（默认 10 次）来进行优化，采用循环的方式去尝试获取锁。</p><ul><li><font color="red">Java 6 之后自旋锁是自适应的</font>。比如对象刚刚的一次自旋操作成功过，那么认为这次自旋成功的可能性会高，就多自旋几次；反之，就少自旋甚至不自旋，比较智能。</li><li><font color="red">Java 7 之后不能控制是否开启自旋功能</font>，由 JVM 控制。</li></ul><blockquote><p>注意：<strong>自旋占用 CPU 时间</strong>，单核 CPU 自旋就是浪费时间，因为同一时刻只能运行一个线程，多核 CPU 自旋才能发挥优势</p></blockquote><p>优点：<strong>不会进入阻塞状态，减少线程上下文切换的消耗</strong></p><p>缺点：当自旋的线程越来越多时，<strong>会不断的消耗 CPU 资源</strong></p><p>自旋锁情况：</p><ul><li><p>自旋成功的线程会获得锁，执行同步块：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/20210130175411285.png" alt="在这里插入图片描述"></p></li><li><p><strong>自旋失败的线程会进入 BLOCKED (锁阻塞) 状态</strong>：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/20210130175500716.png" alt="在这里插入图片描述"></p></li></ul><h6 id="锁消除"><a class="anchor" href="#锁消除">#</a> 锁消除</h6><p>对于被检测出不可能存在竞争的共享数据的锁进行消除，这是 JVM <strong>即时编译器的优化</strong>。</p><p>锁消除主要是通过<strong>逃逸分析</strong>来支持，如果堆上的共享数据不可能逃逸出去被其它线程访问到，那么就可以把它们当成私有数据对待，也就可以将它们的锁进行消除（同步消除：JVM 逃逸分析）。</p><h6 id="锁粗化"><a class="anchor" href="#锁粗化">#</a> 锁粗化</h6><p>对相同对象多次加锁，会导致线程发生多次重入，频繁的加锁操作就会导致性能损耗，可以使用锁粗化方式优化。</p><p>如果虚拟机探测到一串的操作都对同一个对象加锁，将会<strong>把加锁的范围扩展（粗化）到整个操作序列的外部</strong>。</p><p>举例：</p><ul><li><p>多次循环进入同步块，不如同步块内多次循环</p></li><li><p>另外 JVM 可能会做如下优化，把多次 append 的加锁操作粗化为一次（因为都是对同一个对象加锁，没必要重入多次）</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">new</span> <span class="token class-name">StringBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"c"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure></li></ul><h4 id="与-volatile-的区别"><a class="anchor" href="#与-volatile-的区别">#</a> 与 volatile 的区别</h4><p><code>synchronized</code> 关键字和 <code>volatile</code> 关键字是两个<strong>互补</strong>的存在，而不是对立的存在！</p><ul><li><code>volatile</code> 关键字是<font color="red">线程同步的轻量级实现</font>，所以 <code>volatile</code> 性能肯定比 <code>synchronized</code> 关键字要好。</li><li><code>volatile</code> 关键字<font color="red">只能用于变量</font>，而 <code>synchronized</code> 关键字可以修饰方法以及代码块。</li><li><code>volatile</code> 关键字<font color="red">能保证数据的可见性，但不能保证数据的原子性</font>。 <code>synchronized</code> 关键字两者都能保证。</li><li><code>volatile</code> 关键字<font color="red">主要用于解决变量在多个线程之间的可见性</font>，而 <code>synchronized</code> 关键字解决的是多个线程之间访问资源的同步性。</li></ul><h3 id="volatile-关键字"><a class="anchor" href="#volatile-关键字">#</a> volatile 关键字</h3><blockquote><p>针对：<strong>可见性、有序性（禁止指令重排）</strong></p></blockquote><h4 id="保证变量的可见性"><a class="anchor" href="#保证变量的可见性">#</a> 保证变量的可见性</h4><p>在 Java 中， <code>volatile</code> 关键字可以保证变量的可见性，如果我们将变量声明为 <strong><code>volatile</code> </strong>，<strong>表明这个变量是共享且不稳定的，每次使用它都到主存中进行读取</strong>。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/jmm2.png" alt="JMM(Java 内存模型)强制在主存中进行读取"></p><p><code>volatile</code> 关键字其实并非是 Java 语言特有的，在 C 语言里也有，<font color="red">它最原始的意义就是禁用 CPU 缓存</font>。</p><p><code>volatile</code> 关键字能保证数据的可见性，但不能保证数据的原子性。 <code>synchronized</code> 关键字两者都能保证。</p><h4 id="禁止指令重排"><a class="anchor" href="#禁止指令重排">#</a> 禁止指令重排</h4><blockquote><p>在 JDK 5 以上， <code>volatile</code> 关键字可以禁止指令重排。</p></blockquote><p>** 在 Java 中， <code>volatile</code> 关键字除了可以保证变量的可见性，还有一个重要的作用就是防止 JVM 的指令重排。** 当一个变量被 <code>volatile</code> 修饰时，编译器和处理器会通过插入特定的【内存屏障】的方式，禁止对其进行指令重排序，从而保证程序的正确性。</p><p>在 Java 中， <code>Unsafe</code> 类提供了三个开箱即用的<font color="red">内存屏障相关的方法</font>，屏蔽了操作系统底层的差异：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">loadFence</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">storeFence</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">fullFence</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>理论上来说，你通过这个三个方法也可以实现和 <code>volatile</code> 禁止重排序一样的效果，只是会麻烦一些。</p><hr><p>下面我以一个常见的面试题为例讲解一下 <code>volatile</code> 关键字<font color="red">禁止指令重排序的效果</font>。</p><p>面试中面试官经常会说：“单例模式了解吗？来给我手写一下！给我解释一下双重检验锁方式实现单例模式的原理呗！”</p><p><strong><code>double-checked locking</code> （双重校验锁）实现对象单例（线程安全）</strong>：</p><ul><li>懒惰实例化</li><li>首次使用 getUniqueInstance () 才使用 synchronized 加锁，后续无需加锁</li></ul><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 用 volatile 修饰，预防多线程下【指令重排】带来的不正确性</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> uniqueInstance<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    </pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getUniqueInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>       <span class="token comment">// 第一重校验：先判断对象是否已经实例过，没有实例化过才进入加锁代码</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>uniqueInstance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>            <span class="token comment">// 类对象加锁</span></pre></td></tr><tr><td data-num="12"></td><td><pre>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token class-name">Singleton</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>                <span class="token comment">// 第二重校验：也许其他线程已创建实例，故再判断一次</span></pre></td></tr><tr><td data-num="14"></td><td><pre>                <span class="token keyword">if</span> <span class="token punctuation">(</span>uniqueInstance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>                    uniqueInstance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 非原子操作，可能发生【指令重排】</span></pre></td></tr><tr><td data-num="16"></td><td><pre>                <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>        <span class="token keyword">return</span> uniqueInstance<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="21"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><strong><code>uniqueInstance</code> 采用 <code>volatile</code> 关键字修饰也是很有必要的</strong>，因为 <code>uniqueInstance = new Singleton();</code> 这段代码其实是分为三步执行：</p><ol><li>为 <code>uniqueInstance</code> 分配内存空间</li><li>初始化 <code>uniqueInstance</code></li><li>将 <code>uniqueInstance</code> 指向分配的内存地址</li></ol><p>由于 JVM 具有指令重排的特性，执行顺序有可能变成 1-&gt;3-&gt;2。<font color="red">指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例</font>。例如，线程 T1 执行了 1 和 3，此时 T2 调用 <code>getUniqueInstance</code> () 后发现 <code>uniqueInstance</code> 不为空，因此返回 <code>uniqueInstance</code> ，但此时 <code>uniqueInstance</code> 还未被初始化。</p><p>对应的字节码为：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token number">0</span><span class="token operator">:</span> <span class="token keyword">new</span> #<span class="token number">2</span> 			<span class="token comment">// 分配内存：class cn/itcast/jvm/t4/Singleton</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token number">3</span><span class="token operator">:</span> dup</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token number">4</span><span class="token operator">:</span> invokespecial #<span class="token number">3</span> <span class="token comment">// 初始化：Method "&lt;init>":() V</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token number">7</span><span class="token operator">:</span> putstatic #<span class="token number">4</span> 	<span class="token comment">// 赋值：Field INSTANCE:Lcn/itcast/jvm/t4/Singleton;</span></pre></td></tr></table></figure><p><font color="red">其中 4 7 两步的顺序不是固定的，也许 jvm 会优化为：先将引用地址赋值给 INSTANCE 变量后，再执行构造方法</font>，如果两个线程 t1，t2 按如下时间序列执行：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre>时间<span class="token number">1</span> t1 线程执行到 <span class="token constant">INSTANCE</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>时间<span class="token number">2</span> t1 线程分配空间，为<span class="token class-name">Singleton</span>对象生成了引用地址（<span class="token number">0</span> 处）</pre></td></tr><tr><td data-num="3"></td><td><pre>时间<span class="token number">3</span> t1 线程将引用地址赋值给 <span class="token constant">INSTANCE</span>，这时 <span class="token constant">INSTANCE</span> <span class="token operator">!=</span> <span class="token keyword">null</span>（<span class="token number">7</span> 处）</pre></td></tr><tr><td data-num="4"></td><td><pre>时间<span class="token number">4</span> t2 线程进入 <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 方法，发现 <span class="token constant">INSTANCE</span> <span class="token operator">!=</span> <span class="token keyword">null</span>（<span class="token keyword">synchronized</span>块外），直接返回 <span class="token constant">INSTANCE</span></pre></td></tr><tr><td data-num="5"></td><td><pre>时间<span class="token number">5</span> t1 线程执行<span class="token class-name">Singleton</span>的构造方法（<span class="token number">4</span> 处）</pre></td></tr></table></figure><p>这时 t1 还未完全将构造方法执行完毕，如果在构造方法中要执行很多初始化操作，那么 t2 拿到的是将是一个未初始化完毕的单例。</p><p>对 INSTANCE 使用 <code>volatile</code> 修饰即可，可以禁用指令重排。</p><h4 id="无法保证原子性"><a class="anchor" href="#无法保证原子性">#</a> 无法保证原子性</h4><p><strong><code>volatile</code> 关键字能保证变量的可见性，但不能保证对变量的操作是原子性的。</strong></p><p>我们通过下面的代码即可证明：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">/**</span></pre></td></tr><tr><td data-num="2"></td><td><pre> * 微信搜 JavaGuide 回复 "面试突击" 即可免费领取个人原创的 Java 面试手册</pre></td></tr><tr><td data-num="3"></td><td><pre> *</pre></td></tr><tr><td data-num="4"></td><td><pre> * @author Guide 哥</pre></td></tr><tr><td data-num="5"></td><td><pre> * @date 2022/08/03 13:40</pre></td></tr><tr><td data-num="6"></td><td><pre> **/</pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">VolatoleAtomicityDemo</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">volatile</span> <span class="token keyword">static</span> <span class="token keyword">int</span> inc <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">increase</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        inc<span class="token operator">++</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token class-name">ExecutorService</span> threadPool <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token class-name">VolatoleAtomicityDemo</span> volatoleAtomicityDemo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VolatoleAtomicityDemo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>            threadPool<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">500</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>                    volatoleAtomicityDemo<span class="token punctuation">.</span><span class="token function">increase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>                <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>            <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>        <span class="token comment">// 等待 1.5 秒，保证上面程序执行完成</span></pre></td></tr><tr><td data-num="25"></td><td><pre>        <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1500</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>inc<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>        threadPool<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="29"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>正常情况下，运行上面的代码理应输出 <code>2500</code> 。但你真正运行了上面的代码之后，你会发现每次输出结果都小于 <code>2500</code> 。</p><p>为什么会出现这种情况呢？不是说好了， <code>volatile</code> 可以保证变量的可见性嘛！</p><p>也就是说，如果 <code>volatile</code> 能保证 <code>inc++</code> 操作的原子性的话。每个线程中对 <code>inc</code> 变量自增完之后，其他线程可以立即看到修改后的值。5 个线程分别进行了 500 次操作，那么最终 inc 的值应该是 5*500=2500。</p><p>很多人会误认为自增操作 <code>inc++</code> 是原子性的，实际上，<strong> <code>inc++</code> 其实是一个复合操作</strong>，包括三步：</p><ol><li>读取 inc 的值。</li><li>对 inc 加 1。</li><li>将 inc 的值写回内存。</li></ol><p><font color="red"><code>volatile</code> 是无法保证这三个操作是具有原子性的</font>，有可能导致下面这种情况出现：</p><ol><li>线程 1 对 <code>inc</code> 进行读取操作之后，还未对其进行修改。线程 2 又读取了 <code>inc</code> 的值并对其进行修改（+1），再将 <code>inc</code> 的值写回内存。</li><li>线程 2 操作完毕后，线程 1 对 <code>inc</code> 的值进行修改（+1），再将 <code>inc</code> 的值写回内存。</li></ol><p>这也就导致两个线程分别对 <code>inc</code> 进行了一次自增操作后， <code>inc</code> 实际上只增加了 1。</p><p>其实，如果想要保证上面的代码运行正确也非常简单，使用 <code>synchronized</code> 改进：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">increase</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    inc<span class="token operator">++</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id="happens-before-原则"><a class="anchor" href="#happens-before-原则">#</a> happens-before 原则</h3><blockquote><p>针对：<strong>可见性、有序性（指令重排）</strong></p></blockquote><h4 id="设计思想"><a class="anchor" href="#设计思想">#</a> 设计思想</h4><p><strong>happens-before 规定了哪些写操作对其它线程的读操作可见</strong>，它是可见性与有序性的一套规则总结。</p><p>JSR 133 引入了 happens-before 这个概念来<font color="red">描述两个操作之间的内存可见性</font>。</p><p>为什么需要 happens-before 原则？happens-before 原则的诞生是<font color="red">为了程序员和编译器、处理器之间的平衡</font>。程序员追求的是易于理解和编程的强内存模型，遵守既定规则编码即可。编译器和处理器追求的是较少约束的弱内存模型，让它们尽己所能地去优化性能，让性能最大化。<font color="gree">happens-before 原则的设计思想</font>其实非常简单：</p><ul><li>为了对编译器和处理器的约束尽可能少，<font color="red">只要不改变程序的执行结果（单线程程序和正确执行的多线程程序），编译器和处理器怎么进行重排序优化都行</font>。</li><li><font color="red">对于会改变程序执行结果的重排序，JMM 要求编译器和处理器必须禁止这种重排序</font>。</li></ul><p>下面这张是 《Java 并发编程的艺术》这本书中的一张 JMM 设计思想的示意图：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231005150335213.png" alt="image-20231005150335213"></p><p>了解了 happens-before 原则的设计思想，我们再来看看 JSR-133 对 <font color="gree">happens-before 原则的定义</font>：</p><ul><li>如果一个操作 happens-before 另一个操作，那么第一个操作的执行结果将对第二个操作可见，并且第一个操作的执行顺序排在第二个操作之前。</li><li>两个操作之间存在 happens-before 关系，并不意味着 Java 平台的具体实现必须要按照 happens-before 关系指定的顺序来执行。<font color="red">如果重排序之后的执行结果，与按 happens-before 关系来执行的结果一致，那么 JMM 也允许这样的重排序</font>。</li></ul><p>我们看下面这段代码：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> userNum <span class="token operator">=</span> <span class="token function">getUserNum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 	<span class="token comment">// 1</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">int</span> teacherNum <span class="token operator">=</span> <span class="token function">getTeacherNum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	 <span class="token comment">// 2</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">int</span> totalNum <span class="token operator">=</span> userNum <span class="token operator">+</span> teacherNum<span class="token punctuation">;</span>	<span class="token comment">// 3</span></pre></td></tr></table></figure><ul><li>1 happens-before 2</li><li>2 happens-before 3</li><li>1 happens-before 3</li></ul><p>虽然 1 happens-before 2，但对 1 和 2 进行重排序不会影响代码的执行结果，所以 JMM 是允许编译器和处理器执行这种重排序的。但 1 和 2 必须是在 3 执行之前，也就是说 1,2 happens-before 3 。</p><p>happens-before 原则表达的意义其实并不是一个操作发生在另外一个操作的前面，虽然这从程序员的角度上来说也并无大碍。更准确地来说，它更想表达的意义是<strong>前一个操作的结果对于后一个操作是可见的，无论这两个操作是否在同一个线程里。</strong></p><p>举个例子：操作 1 happens-before 操作 2，即使操作 1 和操作 2 不在同一个线程内，JMM 也会保证操作 1 的结果对操作 2 是可见的。</p><h4 id="常见规则"><a class="anchor" href="#常见规则">#</a> 常见规则</h4><p><font color="red">若违反以下 happens-before 规则，JMM 就不能保证一个线程对共享变量的写，对于其它线程对该共享变量的读可见</font>。</p><blockquote><p>也就是说，<strong>happens-before 是用于确保可见性的</strong>。</p></blockquote><p>happens-before 的规则就 8 条，说多不多，重点了解下面列举的 5 条即可。</p><ol><li><p><strong>程序顺序规则</strong>：一个线程内，按照代码顺序，书写在前面的操作 happens-before 于书写在后面的操作；</p></li><li><p><strong>解锁规则</strong>：解锁 happens-before 于加锁。线程解锁 m 之前对变量的写，对于接下来对 m 加锁的其它线程对该变量的读可见</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">static</span> <span class="token keyword">int</span> x<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">static</span> <span class="token class-name">Object</span> m <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-></span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">synchronized</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    	x <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token string">"t1"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-></span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token keyword">synchronized</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    	<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token string">"t2"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure></li><li><p><strong>volatile 变量规则</strong>：对一个 volatile 变量的写操作 happens-before 于后面对这个 volatile 变量的读操作。说白了就是一个线程对 volatile 变量的写操作的结果，对于发生于其后的其它线程对该变量的任何操作都是可见的。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">volatile</span> <span class="token keyword">static</span> <span class="token keyword">int</span> x<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-></span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>	x <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token string">"t1"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-></span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>	<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token string">"t2"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure></li><li><p><strong>传递规则</strong>：如果 A happens-before B，且 B happens-before C，那么 A happens-before C；</p></li><li><p><strong>线程启动规则</strong>：</p><ol><li>Thread 对象的 <code>start()</code> 方法 happens-before 于此线程的每一个动作。</li><li>线程 start 前对变量的写，对该线程开始后对该变量的读可见。</li></ol><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">static</span> <span class="token keyword">int</span> x<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre>x <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-></span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>	<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token string">"t2"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><ol start="3"><li>线程结束前对变量的写，对其它线程得知它结束后的读可见（比如其它线程调用 t1.isAlive () 或 t1.join () 等待它结束）</li></ol><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">static</span> <span class="token keyword">int</span> x<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token class-name">Thread</span> t1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-></span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>	x <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token string">"t1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre>t1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre>t1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><ol start="4"><li>线程 t1 打断 t2（interrupt）前对变量的写，对于其他线程得知 t2 被打断后对变量的读可见（通过 t2.interrupted 或 t2.isInterrupted）</li></ol><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">static</span> <span class="token keyword">int</span> x<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token class-name">Thread</span> t2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-></span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isInterrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>                <span class="token keyword">break</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token string">"t2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    t2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    </pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-></span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        	<span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        	e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>        <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="19"></td><td><pre>        x<span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>        t2<span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 打断 t2</span></pre></td></tr><tr><td data-num="21"></td><td><pre>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token string">"t1"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>    </pre></td></tr><tr><td data-num="23"></td><td><pre>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>t2<span class="token punctuation">.</span><span class="token function">isInterrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>    	<span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token keyword">yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure></li></ol><p><strong><font color="red">如果两个操作不满足上述任意一个 happens-before 规则，那么这两个操作就没有顺序的保障，JVM 可以对这两个操作进行重排序</font></strong>。</p><h4 id="与-jmm-是什么关系"><a class="anchor" href="#与-jmm-是什么关系">#</a> 与 JMM 是什么关系</h4><p>happens-before 与 JMM 的关系用《Java 并发编程的艺术》这本书中的一张图就可以非常好的解释清楚。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20220731084604667.png" alt="happens-before 与 JMM 的关系"></p><h3 id="乐观锁与悲观锁"><a class="anchor" href="#乐观锁与悲观锁">#</a> 乐观锁与悲观锁</h3><blockquote><p>针对：<strong>原子性</strong></p></blockquote><p>在程序世界中，<font color="red">乐观锁和悲观锁的最终目的都是为了保证线程安全，避免在并发场景下的资源竞争问题</font>。但是，相比于乐观锁，<font color="red">悲观锁对性能的影响更大</font>！</p><h4 id="悲观锁"><a class="anchor" href="#悲观锁">#</a> 悲观锁</h4><blockquote><p>悲观锁像是一位比较悲观（也可以说是未雨绸缪）的人，总是会假设最坏的情况，避免出现问题。</p></blockquote><p>悲观锁总是假设最坏的情况，认为共享资源每次被访问的时候就会出现问题 (比如共享数据被修改)，所以每次在获取资源操作的时候都会上锁，这样其他线程想拿到这个资源就会阻塞直到锁被上一个持有者释放。也就是说，<strong>共享资源每次只给一个线程使用（无论读写），其它线程阻塞，用完后再把资源转让给其它线程</strong>。</p><p>像 Java 中 <code>synchronized</code> 和 <code>ReentrantLock</code> 等独占锁就是悲观锁思想的实现。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">performSynchronisedTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token comment">// 需要同步的操作</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">private</span> <span class="token class-name">Lock</span> lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">try</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>   <span class="token comment">// 需要同步的操作</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>高并发的场景下，激烈的锁竞争会造成线程阻塞，<font color="red">大量阻塞线程会导致系统的上下文切换，增加系统的性能开销</font>。并且，悲观锁还可能会<font color="red">存在死锁问题</font>，影响代码的正常运行。</p><h4 id="乐观锁"><a class="anchor" href="#乐观锁">#</a> 乐观锁</h4><blockquote><p>乐观锁像是一位比较乐观的人，总是会假设最好的情况，在要出现问题之前快速解决问题。</p></blockquote><p>乐观锁总是假设最好的情况，认为共享资源每次被访问的时候不会出现问题，线程可以不停地执行，<strong>无需加锁也不会阻塞，只在提交修改时验证对应资源是否被其它线程修改了，若被其它线程修改了，则重新尝试</strong>（具体方法可以使用版本号机制或 CAS 算法）。</p><p>像 Java 中 <code>java.util.concurrent.atomic</code> 包下面的<font color="red">原子变量类</font>（比如 <code>AtomicInteger</code> 、 <code>LongAdder</code> ）就是使用了乐观锁的一种实现方式 <strong>CAS</strong> 实现的。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231006144157570.png" alt="JUC原子类概览"></p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// LongAdder 在高并发场景下会比 AtomicInteger 和 AtomicLong 的性能更好</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment">// 代价就是会消耗更多的内存空间（空间换时间）</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token class-name">LongAdder</span> longAdder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LongAdder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment">// 自增</span></pre></td></tr><tr><td data-num="5"></td><td><pre>longAdder<span class="token punctuation">.</span><span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token comment">// 获取结果</span></pre></td></tr><tr><td data-num="7"></td><td><pre>longAdder<span class="token punctuation">.</span><span class="token function">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>高并发的场景下，相比悲观锁来说，<font color="red">乐观锁<strong>不存在锁竞争，不会造成线程阻塞</strong>，也不会有死锁的问题，在性能上往往会更胜一筹</font>。但是，<font color="red">如果冲突频繁发生（写占比非常多的情况），会<strong>频繁失败和重试</strong>（悲观锁的开销是固定的），这样同样会非常影响性能，导致 CPU 飙升</font>。</p><p>不过，大量失败重试的问题也是可以解决的，像我们前面提到的 <code>LongAdder</code> 以空间换时间的方式就解决了这个问题。</p><p>理论上来说：</p><ul><li><strong>悲观锁通常多用于写比较多的情况下</strong>（多写场景，竞争激烈），这样可以避免频繁失败和重试影响性能，悲观锁的开销是固定的。不过，如果乐观锁解决了频繁失败和重试这个问题的话（比如 <code>LongAdder</code> ），也是可以考虑使用乐观锁的，要视实际情况而定。</li><li><strong>乐观锁通常多于写比较少的情况下</strong>（多读场景，竞争较少），这样可以避免频繁加锁影响性能。不过，乐观锁主要针对的对象是单个共享变量（参考 <code>java.util.concurrent.atomic</code> 包下面的原子变量类）。</li></ul><h4 id="如何实现乐观锁"><a class="anchor" href="#如何实现乐观锁">#</a> 如何实现乐观锁？</h4><p>乐观锁一般会使用<font color="cornflowerblue">版本号机制</font>或<font color="cornflowerblue"> CAS 算法</font>实现，CAS 算法相对来说更多一些，这里需要格外注意。</p><h5 id="版本号机制"><a class="anchor" href="#版本号机制">#</a> 版本号机制</h5><p>一般是在数据表中加上一个数据版本号 <code>version</code> 字段，表示数据被修改的次数。<strong>当数据被修改时， <code>version</code> 字段的值会加 1</strong> 。当线程 A 要更新数据值时，在读取数据的同时也会读取 <code>version</code> 值，<strong>在提交更新时，若刚才读取到的 <code>version</code> 值与当前数据库中的 <code>version</code> 值相等时才更新，否则重试更新操作，直到更新成功</strong>。</p><hr><p>举一个简单的例子：假设数据库中帐户信息表中有一个 version 字段，当前值为 1 ；而当前帐户余额字段（ <code>balance</code> ）为 $100 。</p><ol><li>操作员 A 此时将其读出（ <code>version</code> =1 ），并从其帐户余额中扣除 $50（ $100-$50 ）。</li><li>在操作员 A 操作的过程中，操作员 B 也读入此用户信息（ <code>version</code> =1 ），并从其帐户余额中扣除 $20 （ $100-$20 ）。</li><li>操作员 A 完成了修改工作，将数据版本号（ <code>version</code> =1 ），连同帐户扣除后余额（ <code>balance</code> =$50 ），提交至数据库更新，此时由于提交数据版本等于数据库记录当前版本，数据被更新，数据库记录 <code>version</code> 更新为 2 。</li><li>操作员 B 完成了操作，也将版本号（ <code>version</code> =1 ）试图向数据库提交数据（ <code>balance</code> =$80 ），但此时比对数据库记录版本时发现，操作员 B 提交的数据版本号为 1 ，数据库记录当前版本也为 2 ，不满足 <strong>“提交版本必须等于当前版本才能执行更新” 的乐观锁策略</strong>，因此，操作员 B 的提交被驳回。</li></ol><p>这样就避免了操作员 B 用基于 <code>version</code> =1 的旧数据修改的结果覆盖操作员 A 的操作结果的可能。</p><h5 id="cas-算法"><a class="anchor" href="#cas-算法">#</a> CAS 算法</h5><blockquote><p>乐观锁思想：不怕别的线程来修改共享变量，就算改了也没关系，我吃亏点再重试呗。</p><p>JDK 已经为开发人员封装好了 CAS ，即原子类！</p></blockquote><p>CAS 的全称是 <code>Compare And Swap（比较与交换）</code> ，经常搭配 <code>volatile</code> 用于实现乐观锁，思想很简单，就是<strong>用一个预期值和要更新的变量值进行比较，两值相等才会进行更新</strong>。</p><p><font color="red">CAS 是一个原子操作</font>，底层依赖于一条 CPU 的原子指令。</p><blockquote><p><strong>原子操作</strong> 即最小不可拆分的操作，也就是说操作一旦开始，就不能被打断，直到操作完成。</p></blockquote><p>CAS 涉及到三个操作数：</p><ul><li><strong>V</strong>：要更新的变量值 (Var)</li><li><strong>E</strong>：预期值 (Expected)</li><li><strong>N</strong>：拟写入的新值 (New)</li></ul><p><strong>当且仅当 V 的值等于 E 时，CAS 通过原子方式用新值 N 来更新 V 的值。如果不等，说明已经有其它线程更新了 V，则当前线程放弃更新。</strong></p><hr><p>举一个简单的例子：线程 A 要修改变量 i 的值为 6，i 原值为 1（V = 1，E=1，N=6，假设不存在 ABA 问题）。</p><ol><li>i 与 1 进行比较，如果相等，则说明没被其他线程修改，可以被设置为 6 。</li><li>i 与 1 进行比较，如果不相等，则说明被其他线程修改，当前线程被告知失败。</li></ol><p>当多个线程同时使用 CAS 操作一个变量时，只有一个会胜出，并成功更新，其余均会失败，<font color="red">但失败的线程并不会被挂起，仅是被告知失败，并且允许再次尝试，当然也允许放弃操作</font>。</p><p>Java 语言并没有直接实现 CAS，CAS 相关的实现是通过 C++ 内联汇编的形式实现的（JNI 调用）。因此，CAS 的具体实现和操作系统以及 CPU 都有关系。</p><p><code>sun.misc</code> 包下的 <code>Unsafe</code> 类提供了 <code>compareAndSwapObject</code> 、 <code>compareAndSwapInt</code> 、 <code>compareAndSwapLong</code> 方法来实现的对 <code>Object</code> 、 <code>int</code> 、 <code>long</code> 类型的 CAS 操作：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">/**</span></pre></td></tr><tr><td data-num="2"></td><td><pre>	*  CAS</pre></td></tr><tr><td data-num="3"></td><td><pre>  * @param o         包含要修改 field 的对象</pre></td></tr><tr><td data-num="4"></td><td><pre>  * @param offset    对象中某 field 的偏移量</pre></td></tr><tr><td data-num="5"></td><td><pre>  * @param expected  期望值</pre></td></tr><tr><td data-num="6"></td><td><pre>  * @param update    更新值</pre></td></tr><tr><td data-num="7"></td><td><pre>  * @return          true | false</pre></td></tr><tr><td data-num="8"></td><td><pre>  */</pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">native</span> <span class="token keyword">boolean</span> <span class="token function">compareAndSwapObject</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">,</span> <span class="token keyword">long</span> offset<span class="token punctuation">,</span>  <span class="token class-name">Object</span> expected<span class="token punctuation">,</span> <span class="token class-name">Object</span> update<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">native</span> <span class="token keyword">boolean</span> <span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">,</span> <span class="token keyword">long</span> offset<span class="token punctuation">,</span> <span class="token keyword">int</span> expected<span class="token punctuation">,</span><span class="token keyword">int</span> update<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">native</span> <span class="token keyword">boolean</span> <span class="token function">compareAndSwapLong</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">,</span> <span class="token keyword">long</span> offset<span class="token punctuation">,</span> <span class="token keyword">long</span> expected<span class="token punctuation">,</span> <span class="token keyword">long</span> update<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>关于 <code>Unsafe</code> 类的详细介绍可以看这篇文章：<span class="exturl" data-url="aHR0cHM6Ly9qYXZhZ3VpZGUuY24vamF2YS9iYXNpcy91bnNhZmUuaHRtbA==">Java 魔法类 Unsafe 详解 - JavaGuide - 2022</span> 。</p><h4 id="乐观锁存在哪些问题"><a class="anchor" href="#乐观锁存在哪些问题">#</a> 乐观锁存在哪些问题？</h4><h5 id="aba-问题"><a class="anchor" href="#aba-问题">#</a> ABA 问题</h5><p>如果一个变量 V 初次读取的时候是 A 值，并且在准备赋值的时候检查到它仍然是 A 值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为<font color="red">在这段时间它的值可能被改为其他值，然后又改回 A，那 CAS 操作就会误认为它从来没有被修改过</font>。这个问题被称为 CAS 操作的 &quot;ABA&quot; 问题 。</p><p>ABA 问题的<strong>解决思路是在变量前面追加上版本号或者时间戳</strong>。JDK 1.5 以后的 <code>AtomicStampedReference</code> 类就是用来解决 ABA 问题的，其中的 <code>compareAndSet()</code> 方法就是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">compareAndSet</span><span class="token punctuation">(</span><span class="token class-name">V</span>   expectedReference<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="2"></td><td><pre>                             <span class="token class-name">V</span>   newReference<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="3"></td><td><pre>                             <span class="token keyword">int</span> expectedStamp<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="4"></td><td><pre>                             <span class="token keyword">int</span> newStamp<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token class-name">Pair</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">V</span><span class="token punctuation">></span></span> current <span class="token operator">=</span> pair<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">return</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        expectedReference <span class="token operator">==</span> current<span class="token punctuation">.</span>reference <span class="token operator">&amp;&amp;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        expectedStamp <span class="token operator">==</span> current<span class="token punctuation">.</span>stamp <span class="token operator">&amp;&amp;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token punctuation">(</span><span class="token punctuation">(</span>newReference <span class="token operator">==</span> current<span class="token punctuation">.</span>reference <span class="token operator">&amp;&amp;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>          newStamp <span class="token operator">==</span> current<span class="token punctuation">.</span>stamp<span class="token punctuation">)</span> <span class="token operator">||</span></pre></td></tr><tr><td data-num="11"></td><td><pre>         <span class="token function">casPair</span><span class="token punctuation">(</span>current<span class="token punctuation">,</span> <span class="token class-name">Pair</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>newReference<span class="token punctuation">,</span> newStamp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h5 id="循环时间长-开销大"><a class="anchor" href="#循环时间长-开销大">#</a> 循环时间长、开销大</h5><p><font color="red">CAS 经常会用到<strong>自旋操作</strong>来进行重试，也就是不成功就一直循环执行直到成功</font>。如果长时间不成功，会给 CPU 带来非常大的执行开销。</p><p>如果 JVM 能支持处理器提供的 <code>pause</code> 指令，那么效率会有一定的提升，pause 指令有两个作用：</p><ol><li>可以延迟流水线执行指令，使 CPU 不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。</li><li>可以避免在退出循环的时候因内存顺序冲而引起 CPU 流水线被清空，从而提高 CPU 的执行效率。</li></ol><h5 id="只能保证一个共享变量的原子操作"><a class="anchor" href="#只能保证一个共享变量的原子操作">#</a> 只能保证一个共享变量的原子操作</h5><p><font color="red">CAS 只对单个共享变量有效</font>，当操作涉及跨多个共享变量时 CAS 无效。但是<font color="red">从 JDK 1.5 开始，提供了  <code>AtomicReference</code> 类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行 CAS 操作</font>。所以我们可以使用锁或者利用 <code>AtomicReference</code> 类把多个共享变量合并成一个共享变量来操作。</p><h4 id="小结-6"><a class="anchor" href="#小结-6">#</a> 小结</h4><ul><li>高并发的场景下，激烈的锁竞争会造成线程阻塞，大量阻塞线程会导致系统的上下文切换，增加系统的性能开销。并且，悲观锁还可能会存在死锁问题，影响代码的正常运行。乐观锁相比悲观锁来说，不存在锁竞争造成线程阻塞，也不会有死锁的问题，在性能上往往会更胜一筹。不过，如果冲突频繁发生（写占比非常多的情况），会频繁失败和重试，这样同样会非常影响性能，导致 CPU 飙升。</li><li>乐观锁一般会使用版本号机制或 CAS 算法实现，CAS 算法相对来说更多一些。</li><li>CAS 的全称是 <strong>Compare And Swap（比较与交换）</strong>，用于实现乐观锁，被广泛应用于各大框架中。CAS 的思想很简单，就是用一个预期值和要更新的变量值进行比较，两值相等才会进行更新。</li><li>乐观锁的问题：ABA 问题、循环时间长开销大、只能保证一个共享变量的原子操作。</li></ul><h3 id="atomic-原子类"><a class="anchor" href="#atomic-原子类">#</a> Atomic 原子类</h3><p><code>juc（java.util.concurrent）</code> 中提供了原子操作类，可以提供<font color="red">线程安全</font>的操作，例如：AtomicInteger、AtomicBoolean 等，它们底层就是采用 <strong>CAS 技术 + volatile</strong> 来实现的。<br>可以使用 AtomicInteger 改写之前的例子：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 创建原子整数对象</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">AtomicInteger</span> i <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token class-name">Thread</span> t1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">5000</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>            i<span class="token punctuation">.</span><span class="token function">getAndIncrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 获取并且自增 i++</span></pre></td></tr><tr><td data-num="8"></td><td><pre>            <span class="token comment">//i.incrementAndGet (); // 自增并且获取 ++i</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    </pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token class-name">Thread</span> t2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">5000</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        	i<span class="token punctuation">.</span><span class="token function">getAndDecrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 获取并且自减 i--</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    </pre></td></tr><tr><td data-num="18"></td><td><pre>    t1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    t2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    t1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>    t2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h2 id="总结-2"><a class="anchor" href="#总结-2">#</a> 总结</h2><ul><li><p>Java 是最早尝试提供内存模型的语言，<font color="red">JMM 的主要目的是为了简化多线程编程，增强程序可移植性的</font>。</p></li><li><p>CPU 可以通过制定<font color="red">缓存一致协议</font>（比如<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvTUVTSSVFNSU4RCU4RiVFOCVBRSVBRQ=="> MESI 协议</span>）来解决内存缓存不一致性问题。</p></li><li><p>为了提升执行速度 / 性能，计算机在执行程序代码的时候，会对指令进行重排序。 简单来说就是系统在执行代码的时候并不一定是按照你写的代码的顺序依次执行。<strong>指令重排序可以保证串行语义一致，但是没有义务保证多线程间的语义也一致</strong>，所以在多线程下，指令重排序可能会导致一些问题。</p></li><li><p><strong>可以把 JMM 看作是 Java 定义的并发编程相关的一组规范，目的就是解决指令重排序在多线程环境下的问题</strong>，除了<font color="gree">抽象了线程和主内存之间的关系</font>之外，其还<font color="gree">规定了从 Java 源代码到 CPU 可执行指令的这个转化过程要遵守哪些和并发相关的原则和规范</font>，其主要目的是为了简化多线程编程，增强程序可移植性的。</p></li><li><p>JSR 133 引入了 <code>happens-before</code> 这个概念来<font color="red">描述两个操作之间的内存可见性</font>。</p></li></ul><h1 id="重要的-jvm-参数"><a class="anchor" href="#重要的-jvm-参数">#</a> 重要的 JVM 参数</h1><h2 id="1-堆内存"><a class="anchor" href="#1-堆内存">#</a> 1、堆内存</h2><blockquote><p>堆是 Java 虚拟机所管理的内存中最大的一块，是所有线程共享的一块内存区域，在虚拟机启动时创建。<strong>此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。</strong></p></blockquote><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231007152608099.png" alt="内存区域常见配置参数"></p><h3 id="显式指定堆内存"><a class="anchor" href="#显式指定堆内存">#</a> 显式指定堆内存</h3><p>与性能有关的最常见实践之一是根据应用程序要求初始化堆内存。如果我们需要指定堆大小的最小值与最大值（推荐显示指定大小），以下参数可以帮助你实现：</p><figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre>-Xms<span class="token operator">&lt;</span>heap size<span class="token operator">></span><span class="token punctuation">[</span>unit<span class="token punctuation">]</span> <span class="token comment"># 堆的最小值</span></pre></td></tr><tr><td data-num="2"></td><td><pre>-Xmx<span class="token operator">&lt;</span>heap size<span class="token operator">></span><span class="token punctuation">[</span>unit<span class="token punctuation">]</span> <span class="token comment"># 堆的最大值</span></pre></td></tr></table></figure><ul><li><strong>heap size</strong>：表示要初始化内存的具体大小。</li><li><strong>unit</strong>：表示要初始化内存的单位。单位为 <em><strong>“ g”</strong></em> (GB)、<em><strong>“ m”</strong></em>（MB）、<em><strong>“ k”</strong></em>（KB）。</li></ul><p>举个栗子 🌰，如果我们要为 JVM 分配最小 2 GB 和最大 5 GB 的堆内存大小，我们的参数应该这样来写：</p><figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token parameter variable">-Xms2G</span> <span class="token parameter variable">-Xmx5G</span></pre></td></tr></table></figure><h3 id="显式指定新生代内存"><a class="anchor" href="#显式指定新生代内存">#</a> 显式指定新生代内存</h3><p>根据<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vamF2YXNlLzgvZG9jcy90ZWNobm90ZXMvZ3VpZGVzL3ZtL2djdHVuaW5nL3NpemluZy5odG1s"> Oracle 官方文档</span>，在堆总可用内存配置完成之后，第二大影响因素是为 <code>Young Generation</code> 在堆内存所占的比例。默认情况下，YG 的最小大小为 1310 <em>MB</em>，最大大小为<em>无限制</em>。</p><p>一共有两种指定新生代内存 (Young Generation) 大小的方法：</p><p><strong>1. 通过 <code>-XX:NewSize</code> 和 <code>-XX:MaxNewSize</code> 指定</strong></p><figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token parameter variable">-XX:NewSize</span><span class="token operator">=</span><span class="token operator">&lt;</span>young size<span class="token operator">></span><span class="token punctuation">[</span>unit<span class="token punctuation">]</span> <span class="token comment"># 新生代的最小值</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token parameter variable">-XX:MaxNewSize</span><span class="token operator">=</span><span class="token operator">&lt;</span>young size<span class="token operator">></span><span class="token punctuation">[</span>unit<span class="token punctuation">]</span> <span class="token comment"># 新生代的最大值</span></pre></td></tr></table></figure><p>举个栗子 🌰，如果我们要为 新生代分配 最小 256m 的内存，最大 1024m 的内存我们的参数应该这样来写：</p><figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token parameter variable">-XX:NewSize</span><span class="token operator">=</span>256m</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token parameter variable">-XX:MaxNewSize</span><span class="token operator">=</span>1024m</pre></td></tr></table></figure><p><strong>2. 通过 <code>-Xmn&lt;young size&gt;[unit]</code> 指定</strong></p><p>举个栗子 🌰，如果我们要为 新生代分配 256m 的内存（NewSize 与 MaxNewSize 设为一致），我们的参数应该这样来写：</p><figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token parameter variable">-Xmn256m</span> <span class="token comment"># 新生代的大小（最小值 = 最大值）</span></pre></td></tr></table></figure><p>GC 调优策略中很重要的一条经验总结是这样说的：</p><blockquote><p>将新对象预留在新生代，由于 Full GC 的成本远高于 Minor GC，因此<font color="red">尽可能将对象分配在新生代是明智的做法</font>，实际项目中根据 GC 日志分析新生代空间大小分配是否合理，<font color="red">适当通过 “-Xmn” 命令调节新生代大小，最大限度降低新对象直接进入老年代的情况</font>。</p></blockquote><p>另外，你还可以<strong>通过 <code>-XX:NewRatio=&lt;int&gt;</code> 来设置老年代与新生代内存的比值</strong>。</p><p>比如下面的参数就是设置老年代与新生代内存的比值为 1。也就是说老年代和新生代所占比值为 1：1，新生代占整个堆栈的 1/2。</p><figure class="highlight text"><figcaption data-lang="text"></figcaption><table><tr><td data-num="1"></td><td><pre>-XX:NewRatio=1</pre></td></tr></table></figure><h3 id="显式指定方法区的大小"><a class="anchor" href="#显式指定方法区的大小">#</a> 显式指定方法区的大小</h3><p><strong>从 Java 8 开始，如果我们没有指定 Metaspace（元空间） 的大小，随着更多类的创建，虚拟机会耗尽所有可用的系统内存（永久代并不会出现这种情况）。</strong></p><p>JDK 1.8 之前永久代还没被彻底移除的时候通常通过下面这些参数来调节方法区大小</p><figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token parameter variable">-XX:PermSize</span><span class="token operator">=</span>N <span class="token comment">#方法区 (永久代) 初始大小</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token parameter variable">-XX:MaxPermSize</span><span class="token operator">=</span>N <span class="token comment">#方法区 (永久代) 最大大小，超过这个值将会抛出 OutOfMemoryError 异常:java.lang.OutOfMemoryError: PermGen</span></pre></td></tr></table></figure><p>相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入方法区后就 “永久存在” 了。</p><p><strong>JDK 1.8 的时候，方法区（HotSpot 的永久代）被彻底移除了（JDK1.7 就已经开始了），取而代之是元空间，元空间使用的是本地内存。</strong></p><p>下面是一些常用参数：</p><figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token parameter variable">-XX:MetaspaceSize</span><span class="token operator">=</span>N <span class="token comment">#设置 Metaspace 的初始大小（其实这是一个常见的误区，Metaspace 的初始容量是固定的）</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token parameter variable">-XX:MaxMetaspaceSize</span><span class="token operator">=</span>N <span class="token comment">#设置 Metaspace 的最大大小，表示 Metaspace 使用过程中触发 Full GC 的阈值</span></pre></td></tr></table></figure><h2 id="2-gc"><a class="anchor" href="#2-gc">#</a> 2、GC</h2><h3 id="垃圾回收器"><a class="anchor" href="#垃圾回收器">#</a> 垃圾回收器</h3><p>为了提高应用程序的稳定性，选择正确的<span class="exturl" data-url="aHR0cDovL3d3dy5vcmFjbGUuY29tL3dlYmZvbGRlci90ZWNobmV0d29yay90dXRvcmlhbHMvb2JlL2phdmEvZ2MwMS9pbmRleC5odG1s">垃圾收集</span>算法至关重要。</p><p>JVM 具有四种类型的 GC 实现：</p><ul><li>串行垃圾收集器</li><li>并行垃圾收集器</li><li>CMS 垃圾收集器</li><li>G1 垃圾收集器</li></ul><p>可以使用以下参数声明这些实现：</p><figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token parameter variable">-XX:+UseSerialGC</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token parameter variable">-XX:+UseParallelGC</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token parameter variable">-XX:+UseParNewGC</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token parameter variable">-XX:+UseG1GC</span></pre></td></tr></table></figure><p>有关<em>垃圾回收</em>实施的更多详细信息，请参见<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1NuYWlsY2xpbWIvSmF2YUd1aWRlL2Jsb2IvbWFzdGVyL2RvY3MvamF2YS9qdm0vSlZNJUU1JTlFJTgzJUU1JTlDJUJFJUU1JTlCJTlFJUU2JTk0JUI2Lm1k">此处</span>。</p><h3 id="gc日志记录"><a class="anchor" href="#gc日志记录">#</a> GC 日志记录</h3><p>生产环境上，或者其他要测试 GC 问题的环境上，一定会配置上打印 GC 日志的参数，便于分析 GC 相关的问题。</p><figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment"># 必选</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment"># 打印基本 GC 信息</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token parameter variable">-XX:+PrintGCDetails</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token parameter variable">-XX:+PrintGCDateStamps</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token comment"># 打印对象分布</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token parameter variable">-XX:+PrintTenuringDistribution</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token comment"># 打印堆数据</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token parameter variable">-XX:+PrintHeapAtGC</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token comment"># 打印 Reference 处理信息</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token comment"># 强引用 / 弱引用 / 软引用 / 虚引用 /finalize 相关的方法</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token parameter variable">-XX:+PrintReferenceGC</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token comment"># 打印 STW 时间</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token parameter variable">-XX:+PrintGCApplicationStoppedTime</span></pre></td></tr><tr><td data-num="14"></td><td><pre></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token comment"># 可选</span></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token comment"># 打印 safepoint 信息，进入 STW 阶段之前，需要要找到一个合适的 safepoint</span></pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token parameter variable">-XX:+PrintSafepointStatistics</span></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token parameter variable">-XX:PrintSafepointStatisticsCount</span><span class="token operator">=</span><span class="token number">1</span></pre></td></tr><tr><td data-num="19"></td><td><pre></pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token comment"># GC 日志输出的文件路径</span></pre></td></tr><tr><td data-num="21"></td><td><pre>-Xloggc:/path/to/gc-%t.log</pre></td></tr><tr><td data-num="22"></td><td><pre><span class="token comment"># 开启日志文件分割</span></pre></td></tr><tr><td data-num="23"></td><td><pre><span class="token parameter variable">-XX:+UseGCLogFileRotation</span></pre></td></tr><tr><td data-num="24"></td><td><pre><span class="token comment"># 最多分割几个文件，超过之后从头文件开始写</span></pre></td></tr><tr><td data-num="25"></td><td><pre><span class="token parameter variable">-XX:NumberOfGCLogFiles</span><span class="token operator">=</span><span class="token number">14</span></pre></td></tr><tr><td data-num="26"></td><td><pre><span class="token comment"># 每个文件上限大小，超过就触发分割</span></pre></td></tr><tr><td data-num="27"></td><td><pre><span class="token parameter variable">-XX:GCLogFileSize</span><span class="token operator">=</span>50M</pre></td></tr></table></figure><h2 id="3-oom"><a class="anchor" href="#3-oom">#</a> 3、OOM</h2><p>对于大型应用程序来说，面对内存不足错误是非常常见的，这反过来会导致应用程序崩溃。这是一个非常关键的场景，很难通过复制来解决这个问题。</p><p>这就是为什么 JVM 提供了一些参数，这些参数<font color="red">将堆内存转储到一个物理文件中，以后可以用来查找泄漏</font>:</p><figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token parameter variable">-XX:+HeapDumpOnOutOfMemoryError</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token parameter variable">-XX:HeapDumpPath</span><span class="token operator">=</span>./java_pid<span class="token operator">&lt;</span>pid<span class="token operator">></span>.hprof</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token parameter variable">-XX:OnOutOfMemoryError</span><span class="token operator">=</span><span class="token string">"&lt; cmd args >;&lt; cmd args >"</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token parameter variable">-XX:+UseGCOverheadLimit</span></pre></td></tr></table></figure><p>这里有几点需要注意:</p><ul><li><strong>HeapDumpOnOutOfMemoryError</strong> 指示 JVM 在遇到 <strong>OutOfMemoryError</strong> 错误时将 heap 转储到物理文件中。</li><li><strong>HeapDumpPath</strong> 表示要写入文件的路径；可以给出任何文件名；但是，如果 JVM 在名称中找到一个 <code>&lt;pid&gt;</code> 标记，则当前进程的进程 id 将附加到文件名中，并使用 <code>.hprof</code> 格式</li><li><strong>OnOutOfMemoryError</strong> 用于发出紧急命令，以便在内存不足的情况下执行；应该在 <code>cmd args</code> 空间中使用适当的命令。例如，如果我们想在内存不足时重启服务器，我们可以设置参数: <code>-XX:OnOutOfMemoryError=&quot;shutdown -r&quot;</code> 。</li><li><strong>UseGCOverheadLimit</strong> 是一种策略，它限制在抛出 OutOfMemory 错误之前在 GC 中花费的 VM 时间的比例</li></ul><h2 id="4-其他"><a class="anchor" href="#4-其他">#</a> 4、其他</h2><ul><li><p><code>-server</code> : 启用 “Server Hotspot VM”; 此参数默认用于 64 位 JVM</p></li><li><p><code>-XX:+UseStringDeduplication</code> : <em>Java 8u20</em> 引入了这个 JVM 参数，通过创建太多相同 String 的实例来减少不必要的内存使用；这通过<font color="red">将重复 String 值减少为单个全局 <code>char []</code> 数组来优化堆内存</font>。</p></li><li><p><code>-XX:+UseLWPSynchronization</code> : 设置基于 LWP (轻量级进程) 的同步策略，而不是基于线程的同步。</p></li><li><p><code>-XX:LargePageSizeInBytes</code> : 设置用于 Java 堆的较大页面大小；它采用 GB/MB/KB 的参数；页面大小越大，我们可以更好地利用虚拟内存硬件资源；然而，这可能会导致 PermGen 的空间大小更大，这反过来又会迫使 Java 堆空间的大小减小。</p></li><li><p><code>-XX:MaxHeapFreeRatio</code> : 设置 GC 后，堆空闲的最大百分比，以避免收缩。</p></li><li><p><code>-XX:SurvivorRatio</code> : eden/survivor 空间的比例，例如 <code>-XX:SurvivorRatio=6</code> 设置每个 survivor 和 eden 之间的比例为 1:6。</p></li><li><p><code>-XX:+UseLargePages</code> : 如果系统支持，则使用大页面内存；请注意，如果使用这个 JVM 参数，OpenJDK 7 可能会崩溃。</p></li><li><p><code>-XX:+UseStringCache</code> : 启用 String 池中可用的常用分配字符串的缓存。</p></li><li><p><code>-XX:+UseCompressedStrings</code> : 对 String 对象使用 <code>byte []</code> 类型，该类型可以用纯 ASCII 格式表示。</p></li><li><p><code>-XX:+OptimizeStringConcat</code> : 它尽可能优化字符串串联操作。</p></li></ul><h1 id="jdk监控和故障处理工具"><a class="anchor" href="#jdk监控和故障处理工具">#</a> JDK 监控和故障处理工具</h1><h2 id="1-jdk-命令行工具"><a class="anchor" href="#1-jdk-命令行工具">#</a> 1、JDK 命令行工具</h2><p>这些命令在 JDK 安装目录下的 bin 目录下：</p><ul><li><strong><code>jps</code> </strong>(JVM Process Status）: 类似 UNIX 的 <code>ps</code> 命令。用于<font color="red">查看所有 Java 进程</font>的启动类、传入参数和 Java 虚拟机参数等信息；</li><li><strong><code>jstat</code> </strong>（JVM Statistics Monitoring Tool）: 用于<font color="red">收集 HotSpot 虚拟机的各种运行状态数据</font>;</li><li><strong><code>jinfo</code> </strong>(Configuration Info for Java) : Configuration Info for Java，用于<font color="red">查看、调整虚拟机的各项配置信息</font>;</li><li><strong><code>jmap</code> </strong>(Memory Map for Java) : <font color="red">生成堆转储快照</font>;</li><li><strong><code>jhat</code> </strong>(JVM Heap Dump Browser) : 用于<font color="red">分析 heapdump 文件</font>，它会建立一个 HTTP/HTML 服务器，让用户可以在浏览器上查看分析结果；</li><li><strong><code>jstack</code> </strong>(Stack Trace for Java) : <font color="red">生成虚拟机当前时刻的线程快照</font>，线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合。</li></ul><h2 id="2-jdk-可视化分析工具"><a class="anchor" href="#2-jdk-可视化分析工具">#</a> 2、JDK 可视化分析工具</h2><ul><li><strong><code>JConsole</code> </strong>：Java 监视与管理控制台，可以很方便地<font color="red">监视本地及远程服务器的 java 进程的内存使用情况</font>。</li><li><strong><code>Visual VM</code> </strong>：多合一故障处理工具，可以方便地<font color="red">查看多个 Java 应用程序的相关信息</font>。</li></ul><h1 id="jvm线上问题排查与性能调优的案例"><a class="anchor" href="#jvm线上问题排查与性能调优的案例">#</a> JVM 线上问题排查与性能调优的案例</h1><p><span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC83MjA1MTQxNDkyMjY0OTc2NDQ1">一次线上 OOM 问题分析 - 艾小仙 - 2023</span></p><ul><li><strong>现象</strong>：线上某个服务有接口非常慢，通过监控链路查看发现，中间的 GAP 时间非常大，实际接口并没有消耗很多时间，并且在那段时间里有很多这样的请求。</li><li><strong>分析</strong>：使用 JDK 自带的 <code>jvisualvm</code> 分析 dump 文件 (MAT 也能分析)。</li><li><strong>建议</strong>：对于 SQL 语句，如果监测到没有 <code>where</code> 条件的全表查询应该默认增加一个合适的 <code>limit</code> 作为限制，防止这种问题拖垮整个系统</li><li><strong>资料</strong>：<span class="exturl" data-url="aHR0cHM6Ly9oZWFwZHVtcC5jbi9hcnRpY2xlLzM0ODkwNTA=">实战案例：记一次 dump 文件分析历程转载 - HeapDump - 2022</span>。</li></ul><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbXlsaWJzL3AvcHJvZHVjdGlvbi1hY2NpZGVudC0wMDAyLmh0bWw=">生产事故 - 记一次特殊的 OOM 排查 - 程语有云 - 2023</span></p><ul><li><strong>现象</strong>：网络没有问题的情况下，系统某开放接口从 2023 年 3 月 10 日 14 时许开始无法访问和使用。</li><li><strong>临时解决办法</strong>：紧急回滚至上一稳定版本。</li><li><strong>分析</strong>：使用 <code>MAT (Memory Analyzer Tool)</code> 工具分析 dump 文件。</li><li><strong>建议</strong>：正常情况下， <code>-Xmn</code> 参数（控制 Young 区的大小）总是应当小于 <code>-Xmx</code> 参数（控制堆内存的最大大小），否则就会触发 OOM 错误。</li><li><strong>资料</strong>：<span class="exturl" data-url="aHR0cHM6Ly9qYXZhZ3VpZGUuY24vamF2YS9qdm0vanZtLXBhcmFtZXRlcnMtaW50cm8uaHRtbA==">最重要的 JVM 参数总结 - JavaGuide - 2023</span></li></ul><p><span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC83MDc4NjI0OTMxODI2Nzk0NTAz">一次大量 JVM Native 内存泄露的排查分析（64M 问题） - 掘金 - 2022</span></p><ul><li><strong>现象</strong>：线上项目刚启动完使用 top 命令查看 RES 占用了超过 1.5G。</li><li><strong>分析</strong>：整个分析流程用到了较多工作，可以跟着作者思路一步一步来，值得学习借鉴。</li><li><strong>建议</strong>：远离 Hibernate。</li><li><strong>资料</strong>：<span class="exturl" data-url="aHR0cHM6Ly9saWFtLnBhZ2UvMjAyMC8wNy8xNy9tZW1vcnktc3RhdC1pbi1UT1Av">Linux top 命令里的内存相关字段（VIRT, RES, SHR, CODE, DATA）</span></li></ul><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuaGVhcGR1bXAuY24vYXJ0aWNsZS8xNjYxNDk3">YGC 问题排查，又让我涨姿势了！ - IT 人的职场进阶 - 2021</span></p><ul><li><strong>现象</strong>：广告服务在新版本上线后，收到了大量的服务超时告警。</li><li><strong>分析</strong>：使用 <code>MAT (Memory Analyzer Tool)</code> 工具分析 dump 文件。</li><li><strong>建议</strong>：学会 YGC（Young GC） 问题的排查思路，掌握 YGC 的相关知识点。</li></ul><p><span class="exturl" data-url="aHR0cHM6Ly9zaHV5aS50ZWNoL2FyY2hpdmVzL2hhdmUtYS10cnktaW4tanZtLWNvbWJhdA==">听说 JVM 性能优化很难？今天我小试了一把！ - 陈树义 - 2021</span></p><p>通过观察 GC 频率和停顿时间，来进行 JVM 内存空间调整，使其达到最合理的状态。调整过程记得小步快跑，避免内存剧烈波动影响线上服务。这其实是最为简单的一种 JVM 性能调优方式了，可以算是粗调吧。</p><p><span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvZGYxdXhIV1VYemhFcnhXMXNaNk92UQ==">你们要的线上 GC 问题案例来啦 - 编了个程 - 2021</span></p><ul><li><strong>案例 1</strong>：使用 guava cache 的时候，没有设置最大缓存数量和弱引用，导致频繁触发 Young GC</li><li><strong>案例 2</strong>： 对于一个查询和排序分页的 SQL，同时这个 SQL 需要 join 多张表，在分库分表下，直接调用 SQL 性能很差。于是，查单表，再在内存排序分页，用了一个 List 来保存数据，而有些数据量大，造成了这个现象。</li></ul><p><span class="exturl" data-url="aHR0cHM6Ly90ZWNoLm1laXR1YW4uY29tLzIwMjAvMTEvMTIvamF2YS05LWNtcy1nYy5odG1s">Java 中 9 种常见的 CMS GC 问题分析与解决 - 美团技术团 - 2020</span></p><p>这篇文章共 2w+ 字，详细介绍了 GC 基础，总结了 CMS GC 的一些常见问题分析与解决办法。</p></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2023-11-11 16:58:39" itemprop="dateModified" datetime="2023-11-11T16:58:39+08:00">2023-11-11</time> </span><span id="java/jvm/JVM笔记/" class="item leancloud_visitors" data-flag-title="JVM笔记" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>范特东东东 <i class="ic i-at"><em>@</em></i>水文 & 摄影</li><li class="link"><strong>本文链接：</strong> <a href="http://example.com/java/jvm/JVM%E7%AC%94%E8%AE%B0/" title="JVM笔记">http://example.com/java/jvm/JVM笔记/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/java/java-se/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E5%AE%8B%E7%BA%A2%E5%BA%B7_%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;hjx159&#x2F;picture-bed&#x2F;main&#x2F;img&#x2F;cover.jpg" title="宋红康_第01章_Java语言概述"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> Java基础</span><h3>宋红康_第01章_Java语言概述</h3></a></div><div class="item right"><a href="/database/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;hjx159&#x2F;picture-bed&#x2F;main&#x2F;img&#x2F;sql-nosql-tushi.png" title="数据库总结"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> 数据库</span><h3>数据库总结</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0jvm-%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">第一章：JVM 概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-jvm%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.1.</span> <span class="toc-text">1、JVM 是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-jvm%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.</span> <span class="toc-text">2、JVM 结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-jvm%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">1.3.</span> <span class="toc-text">3、JVM 生命周期</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0jvm-%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84"><span class="toc-number">2.</span> <span class="toc-text">第二章：JVM 内存结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#0-%E6%A6%82%E8%BF%B0"><span class="toc-number">2.1.</span> <span class="toc-text">0、概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#java7%E7%9A%84%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E5%9B%BE"><span class="toc-number">2.1.1.</span> <span class="toc-text">Java7 的内存结构图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java8%E7%9A%84%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E5%9B%BE"><span class="toc-number">2.1.2.</span> <span class="toc-text">Java8 的内存结构图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81-oom-%E9%94%99%E8%AF%AF"><span class="toc-number">2.1.3.</span> <span class="toc-text">常见 OOM 错误</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="toc-number">2.2.</span> <span class="toc-text">1、程序计数器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88"><span class="toc-number">2.3.</span> <span class="toc-text">2、虚拟机栈</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-number">2.3.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E8%BE%A8%E6%9E%90"><span class="toc-number">2.3.2.</span> <span class="toc-text">问题辨析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA"><span class="toc-number">2.3.3.</span> <span class="toc-text">栈内存溢出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E8%BF%90%E8%A1%8C%E8%AF%8A%E6%96%AD"><span class="toc-number">2.3.4.</span> <span class="toc-text">线程运行诊断</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88"><span class="toc-number">2.4.</span> <span class="toc-text">3、本地方法栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%A0%86"><span class="toc-number">2.5.</span> <span class="toc-text">4、堆</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-2"><span class="toc-number">2.5.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BA%A2%E5%87%BA"><span class="toc-number">2.5.2.</span> <span class="toc-text">溢出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E5%86%85%E5%AD%98%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7"><span class="toc-number">2.5.3.</span> <span class="toc-text">堆内存诊断工具</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java7%E4%B8%AD%E7%9A%84%E5%A0%86%E5%86%85%E5%AD%98%E7%BB%84%E6%88%90%E5%88%86%E4%BB%A3"><span class="toc-number">2.5.4.</span> <span class="toc-text">Java7 中的堆内存组成（分代）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java8%E4%B8%AD%E7%9A%84%E5%A0%86%E5%86%85%E5%AD%98%E7%BB%84%E6%88%90%E5%88%86%E4%BB%A3"><span class="toc-number">2.5.5.</span> <span class="toc-text">Java8 中的堆内存组成（分代）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E6%96%B9%E6%B3%95%E5%8C%BA"><span class="toc-number">2.6.</span> <span class="toc-text">5、方法区</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-3"><span class="toc-number">2.6.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E6%88%90"><span class="toc-number">2.6.2.</span> <span class="toc-text">组成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BA%A2%E5%87%BA-2"><span class="toc-number">2.6.3.</span> <span class="toc-text">溢出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="toc-number">2.6.4.</span> <span class="toc-text">运行时常量池</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E6%B1%A0%E8%A1%A8"><span class="toc-number">2.6.4.1.</span> <span class="toc-text">常量池表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0-2"><span class="toc-number">2.6.4.2.</span> <span class="toc-text">运行时常量池</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#stringtable"><span class="toc-number">2.6.5.</span> <span class="toc-text">StringTable</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#stringtable%E4%B8%8E%E5%B8%B8%E9%87%8F%E6%B1%A0%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">2.6.5.1.</span> <span class="toc-text">StringTable 与常量池的关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5%E5%8E%9F%E7%90%86"><span class="toc-number">2.6.5.2.</span> <span class="toc-text">字符串拼接原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#stringtable%E5%A6%82%E4%BD%95%E6%B7%BB%E5%8A%A0%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.6.5.3.</span> <span class="toc-text">StringTable 如何添加字符串对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#stringtable-%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">2.6.5.4.</span> <span class="toc-text">StringTable 面试题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#stringtable-%E4%BD%8D%E7%BD%AE"><span class="toc-number">2.6.5.5.</span> <span class="toc-text">StringTable 位置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#stringtable-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-number">2.6.5.6.</span> <span class="toc-text">StringTable 垃圾回收</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#stringtable-%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98"><span class="toc-number">2.6.5.7.</span> <span class="toc-text">StringTable 性能调优</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98"><span class="toc-number">2.7.</span> <span class="toc-text">6、直接内存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-4"><span class="toc-number">2.7.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-number">2.7.2.</span> <span class="toc-text">直接内存的好处</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99%E6%B5%81%E7%A8%8B"><span class="toc-number">2.7.2.1.</span> <span class="toc-text">文件读写流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E4%BA%86-directbuffer-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E6%B5%81%E7%A8%8B"><span class="toc-number">2.7.2.2.</span> <span class="toc-text">使用了 DirectBuffer 文件读取流程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98%E7%9A%84%E5%9B%9E%E6%94%B6%E5%8E%9F%E7%90%86"><span class="toc-number">2.7.3.</span> <span class="toc-text">直接内存的回收原理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6gc"><span class="toc-number">3.</span> <span class="toc-text">第三章：垃圾回收（GC）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%9E%83%E5%9C%BE%E5%88%A4%E6%96%AD%E6%A0%87%E8%AE%B0"><span class="toc-number">3.1.</span> <span class="toc-text">1、垃圾判断（标记）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%B3%95"><span class="toc-number">3.1.1.</span> <span class="toc-text">引用计数法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95"><span class="toc-number">3.1.2.</span> <span class="toc-text">可达性分析算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#gc-roots-%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.1.2.1.</span> <span class="toc-text">GC Roots 对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86"><span class="toc-number">3.1.2.2.</span> <span class="toc-text">算法原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E7%AE%97%E6%B3%95"><span class="toc-number">3.1.2.3.</span> <span class="toc-text">三色标记算法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0%E7%AE%97%E6%B3%95"><span class="toc-number">3.1.2.3.1.</span> <span class="toc-text">标记算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E6%A0%87%E8%AE%B0"><span class="toc-number">3.1.2.3.2.</span> <span class="toc-text">并发标记</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%A4%9A%E6%A0%87%E6%83%85%E5%86%B5"><span class="toc-number">3.1.2.3.2.1.</span> <span class="toc-text">多标情况</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%BC%8F%E6%A0%87%E6%83%85%E5%86%B5"><span class="toc-number">3.1.2.3.2.2.</span> <span class="toc-text">漏标情况</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E7%A7%8D%E5%BC%95%E7%94%A8"><span class="toc-number">3.1.3.</span> <span class="toc-text">五种引用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%BA%E5%BC%95%E7%94%A8"><span class="toc-number">3.1.3.1.</span> <span class="toc-text">强引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AF%E5%BC%95%E7%94%A8softreference"><span class="toc-number">3.1.3.2.</span> <span class="toc-text">软引用（SoftReference）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%BC%94%E7%A4%BA"><span class="toc-number">3.1.3.2.1.</span> <span class="toc-text">演示</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%B1%E5%BC%95%E7%94%A8weakreference"><span class="toc-number">3.1.3.3.</span> <span class="toc-text">弱引用（WeakReference）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%BC%94%E7%A4%BA-2"><span class="toc-number">3.1.3.3.1.</span> <span class="toc-text">演示</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E5%BC%95%E7%94%A8phantomreference"><span class="toc-number">3.1.3.4.</span> <span class="toc-text">虚引用（PhantomReference）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%88%E7%BB%93%E5%99%A8%E5%BC%95%E7%94%A8finalization"><span class="toc-number">3.1.3.5.</span> <span class="toc-text">终结器引用（finalization）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-gc%E7%AE%97%E6%B3%95"><span class="toc-number">3.2.</span> <span class="toc-text">2、GC 算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4-%E7%AE%97%E6%B3%95"><span class="toc-number">3.2.1.</span> <span class="toc-text">标记 - 清除 算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86-%E7%AE%97%E6%B3%95"><span class="toc-number">3.2.2.</span> <span class="toc-text">标记 - 整理 算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0-%E5%A4%8D%E5%88%B6-%E7%AE%97%E6%B3%95"><span class="toc-number">3.2.3.</span> <span class="toc-text">标记 - 复制 算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">3.2.4.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%88%86%E4%BB%A3gc"><span class="toc-number">3.3.</span> <span class="toc-text">3、分代 GC</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86"><span class="toc-number">3.3.1.</span> <span class="toc-text">前置知识</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A0%86%E5%86%85%E5%AD%98%E6%98%AF%E5%A6%82%E4%BD%95%E5%88%86%E4%BB%A3%E7%9A%84"><span class="toc-number">3.3.1.1.</span> <span class="toc-text">堆内存是如何分代的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E4%BB%A3%E7%9A%84gc%E7%AE%97%E6%B3%95"><span class="toc-number">3.3.1.2.</span> <span class="toc-text">不同代的 GC 算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#minor-gc-major-gc%E5%92%8Cfull-gc"><span class="toc-number">3.3.1.3.</span> <span class="toc-text">Minor GC、Major GC 和 Full GC</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6"><span class="toc-number">3.3.2.</span> <span class="toc-text">工作机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B0%E7%94%9F%E4%BB%A3%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5"><span class="toc-number">3.3.2.1.</span> <span class="toc-text">新生代的内存分配策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%80%81%E5%B9%B4%E4%BB%A3%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5"><span class="toc-number">3.3.2.2.</span> <span class="toc-text">老年代的内存分配策略</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-vm-%E5%8F%82%E6%95%B0"><span class="toc-number">3.3.3.</span> <span class="toc-text">相关 VM 参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gc%E6%BC%94%E7%A4%BA%E4%B8%8E%E5%88%86%E6%9E%90"><span class="toc-number">3.3.4.</span> <span class="toc-text">GC 演示与分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-gc%E5%99%A8"><span class="toc-number">3.4.</span> <span class="toc-text">4、GC 器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86-2"><span class="toc-number">3.4.1.</span> <span class="toc-text">前置知识</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#gc%E5%99%A8%E5%A6%82%E4%BD%95%E5%88%86%E7%B1%BB"><span class="toc-number">3.4.1.1.</span> <span class="toc-text">GC 器如何分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#gc%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87"><span class="toc-number">3.4.1.2.</span> <span class="toc-text">GC 性能指标</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#gc%E5%99%A8%E7%9A%84%E7%BB%84%E5%90%88%E4%BD%BF%E7%94%A8%E5%85%B3%E7%B3%BB"><span class="toc-number">3.4.1.3.</span> <span class="toc-text">GC 器的组合使用关系</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%B2%E8%A1%8C"><span class="toc-number">3.4.2.</span> <span class="toc-text">串行</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#serial-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">3.4.2.1.</span> <span class="toc-text">Serial 收集器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#serial-old-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">3.4.2.2.</span> <span class="toc-text">Serial Old 收集器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">3.4.2.3.</span> <span class="toc-text">优缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#parnew-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">3.4.2.4.</span> <span class="toc-text">ParNew 收集器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%9E%E5%90%90%E9%87%8F%E4%BC%98%E5%85%88"><span class="toc-number">3.4.3.</span> <span class="toc-text">吞吐量优先</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#parallel-scavenge-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">3.4.3.1.</span> <span class="toc-text">Parallel Scavenge 收集器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#parallel-old-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">3.4.3.2.</span> <span class="toc-text">Parallel Old 收集器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-vm-%E5%8F%82%E6%95%B0-2"><span class="toc-number">3.4.3.3.</span> <span class="toc-text">相关 VM 参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-2"><span class="toc-number">3.4.3.4.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%81%9C%E9%A1%BF%E6%97%B6%E9%97%B4%E4%BC%98%E5%85%88%E4%BD%8E%E5%BB%B6%E6%97%B6"><span class="toc-number">3.4.4.</span> <span class="toc-text">停顿时间优先（低延时）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#cms-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">3.4.4.1.</span> <span class="toc-text">CMS 收集器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#cms-%E7%89%B9%E7%82%B9"><span class="toc-number">3.4.4.1.1.</span> <span class="toc-text">CMS 特点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#cms-%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B"><span class="toc-number">3.4.4.1.2.</span> <span class="toc-text">CMS 工作过程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-vm-%E5%8F%82%E6%95%B0-3"><span class="toc-number">3.4.4.1.3.</span> <span class="toc-text">相关 VM 参数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#cms-%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">3.4.4.1.4.</span> <span class="toc-text">CMS 优缺点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#g1-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">3.4.4.2.</span> <span class="toc-text">G1 收集器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#g1-%E7%89%B9%E7%82%B9"><span class="toc-number">3.4.4.2.1.</span> <span class="toc-text">G1 特点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AE%B0%E5%BF%86%E9%9B%86rset"><span class="toc-number">3.4.4.2.2.</span> <span class="toc-text">记忆集（Rset）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8D%A1%E8%A1%A8card-table"><span class="toc-number">3.4.4.2.3.</span> <span class="toc-text">卡表（Card Table）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#g1-%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B"><span class="toc-number">3.4.4.2.4.</span> <span class="toc-text">G1 工作过程</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">3.4.4.2.4.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#young-gc"><span class="toc-number">3.4.4.2.4.2.</span> <span class="toc-text">Young GC</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#concurrent-mark"><span class="toc-number">3.4.4.2.4.3.</span> <span class="toc-text">Concurrent Mark</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#mixed-gc"><span class="toc-number">3.4.4.2.4.4.</span> <span class="toc-text">Mixed GC</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#full-gc"><span class="toc-number">3.4.4.2.4.5.</span> <span class="toc-text">Full GC</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-vm-%E5%8F%82%E6%95%B0-4"><span class="toc-number">3.4.4.2.5.</span> <span class="toc-text">相关 VM 参数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#g1-%E4%BC%98%E5%8C%96"><span class="toc-number">3.4.4.2.6.</span> <span class="toc-text">G1 优化</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8E%BB%E9%87%8D"><span class="toc-number">3.4.4.2.6.1.</span> <span class="toc-text">字符串去重</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E6%A0%87%E8%AE%B0%E6%97%B6%E7%9A%84%E7%B1%BB%E5%8D%B8%E8%BD%BD"><span class="toc-number">3.4.4.2.6.2.</span> <span class="toc-text">并发标记时的类卸载</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%9B%9E%E6%94%B6%E5%B7%A8%E5%9E%8B%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.4.4.2.6.3.</span> <span class="toc-text">回收巨型对象</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E6%A0%87%E8%AE%B0%E7%9A%84%E8%B5%B7%E5%A7%8B%E6%97%B6%E9%97%B4%E7%9A%84%E8%B0%83%E6%95%B4"><span class="toc-number">3.4.4.2.6.4.</span> <span class="toc-text">并发标记的起始时间的调整</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#g1-%E8%B0%83%E4%BC%98"><span class="toc-number">3.4.4.2.7.</span> <span class="toc-text">G1 调优</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#zgc-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">3.4.4.3.</span> <span class="toc-text">ZGC 收集器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#zgc-%E7%89%B9%E7%82%B9"><span class="toc-number">3.4.4.3.1.</span> <span class="toc-text">ZGC 特点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E-region-%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="toc-number">3.4.4.3.2.</span> <span class="toc-text">基于 Region 的内存布局</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%AF%E5%B9%B6%E5%8F%91%E7%9A%84%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95"><span class="toc-number">3.4.4.3.3.</span> <span class="toc-text">可并发的标记 - 整理算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#zgc-%E7%9B%AE%E6%A0%87"><span class="toc-number">3.4.4.3.4.</span> <span class="toc-text">ZGC 目标</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#zgc-%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B"><span class="toc-number">3.4.4.3.5.</span> <span class="toc-text">ZGC 工作过程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#zgc-%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">3.4.4.3.6.</span> <span class="toc-text">ZGC 优缺点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">3.4.5.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-gc%E8%B0%83%E4%BC%98"><span class="toc-number">3.5.</span> <span class="toc-text">5、GC 调优</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">3.5.1.</span> <span class="toc-text">前言</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86"><span class="toc-number">3.5.1.1.</span> <span class="toc-text">预备知识</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E4%BC%98%E9%A2%86%E5%9F%9F"><span class="toc-number">3.5.1.2.</span> <span class="toc-text">调优领域</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A1%AE%E5%AE%9A%E7%9B%AE%E6%A0%87"><span class="toc-number">3.5.1.3.</span> <span class="toc-text">确定目标</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E5%BF%AB%E7%9A%84gc"><span class="toc-number">3.5.1.4.</span> <span class="toc-text">最快的 GC</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B0%E7%94%9F%E4%BB%A3%E8%B0%83%E4%BC%98"><span class="toc-number">3.5.2.</span> <span class="toc-text">新生代调优</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%80%81%E5%B9%B4%E4%BB%A3%E8%B0%83%E4%BC%98"><span class="toc-number">3.5.3.</span> <span class="toc-text">老年代调优</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B"><span class="toc-number">3.5.4.</span> <span class="toc-text">案例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%B1%BB%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%AD%97%E8%8A%82%E7%A0%81%E6%8A%80%E6%9C%AF"><span class="toc-number">4.</span> <span class="toc-text">第四章：类加载与字节码技术</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%B1%BB%E6%96%87%E4%BB%B6%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">4.1.</span> <span class="toc-text">1、类文件的结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-2"><span class="toc-number">4.1.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AD%94%E6%95%B0"><span class="toc-number">4.1.2.</span> <span class="toc-text">魔数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%88%E6%9C%AC"><span class="toc-number">4.1.3.</span> <span class="toc-text">版本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E6%B1%A0%E8%A1%A8-2"><span class="toc-number">4.1.4.</span> <span class="toc-text">常量池 (表)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E6%A0%87%E8%AF%86"><span class="toc-number">4.1.5.</span> <span class="toc-text">访问标识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E4%BF%A1%E6%81%AF%E7%B4%A2%E5%BC%95%E9%9B%86%E5%90%88"><span class="toc-number">4.1.6.</span> <span class="toc-text">继承信息（索引集合）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E6%AE%B5%E8%A1%A8"><span class="toc-number">4.1.7.</span> <span class="toc-text">字段表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E8%A1%A8"><span class="toc-number">4.1.8.</span> <span class="toc-text">方法表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E8%A1%A8"><span class="toc-number">4.1.9.</span> <span class="toc-text">属性表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4"><span class="toc-number">4.2.</span> <span class="toc-text">2、字节码指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#javac-%E5%B7%A5%E5%85%B7"><span class="toc-number">4.2.1.</span> <span class="toc-text">javac 工具</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#javap-%E5%B7%A5%E5%85%B7"><span class="toc-number">4.2.2.</span> <span class="toc-text">javap 工具</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E8%A7%A3%E6%96%B9%E6%B3%95%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-number">4.2.3.</span> <span class="toc-text">图解：方法的执行流程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E5%8E%9F%E5%A7%8B-java-%E4%BB%A3%E7%A0%81"><span class="toc-number">4.2.3.1.</span> <span class="toc-text">1）原始 java 代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E7%BC%96%E8%AF%91%E5%90%8E%E7%9A%84%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6"><span class="toc-number">4.2.3.2.</span> <span class="toc-text">2）编译后的字节码文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E5%B8%B8%E9%87%8F%E6%B1%A0%E8%BD%BD%E5%85%A5%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="toc-number">4.2.3.3.</span> <span class="toc-text">3）常量池载入运行时常量池</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E6%96%B9%E6%B3%95%E5%AD%97%E8%8A%82%E7%A0%81%E8%BD%BD%E5%85%A5%E6%96%B9%E6%B3%95%E5%8C%BA"><span class="toc-number">4.2.3.4.</span> <span class="toc-text">4）方法字节码载入方法区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5main-%E7%BA%BF%E7%A8%8B%E5%BC%80%E5%A7%8B%E8%BF%90%E8%A1%8C%E5%88%86%E9%85%8D%E6%A0%88%E5%B8%A7%E5%86%85%E5%AD%98"><span class="toc-number">4.2.3.5.</span> <span class="toc-text">5）main 线程开始运行，分配栈帧内存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E%E5%BC%80%E5%A7%8B%E6%89%A7%E8%A1%8C%E5%AD%97%E8%8A%82%E7%A0%81"><span class="toc-number">4.2.3.6.</span> <span class="toc-text">6）执行引擎开始执行字节码</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#int-a-10"><span class="toc-number">4.2.3.6.1.</span> <span class="toc-text">int a &#x3D; 10</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#bipush-10"><span class="toc-number">4.2.3.6.1.1.</span> <span class="toc-text">bipush 10</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#istore-1"><span class="toc-number">4.2.3.6.1.2.</span> <span class="toc-text">istore 1</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#int-b-shortmax_value-1"><span class="toc-number">4.2.3.6.2.</span> <span class="toc-text">int b &#x3D; Short.MAX_VALUE + 1</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#ldc-3"><span class="toc-number">4.2.3.6.2.1.</span> <span class="toc-text">ldc #3</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#istore-2"><span class="toc-number">4.2.3.6.2.2.</span> <span class="toc-text">istore 2</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#int-c-a-b"><span class="toc-number">4.2.3.6.3.</span> <span class="toc-text">int c &#x3D; a + b</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#iload_1"><span class="toc-number">4.2.3.6.3.1.</span> <span class="toc-text">iload_1</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#iload_2"><span class="toc-number">4.2.3.6.3.2.</span> <span class="toc-text">iload_2</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#iadd"><span class="toc-number">4.2.3.6.3.3.</span> <span class="toc-text">iadd</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#istore_3"><span class="toc-number">4.2.3.6.3.4.</span> <span class="toc-text">istore_3</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#systemoutprintlnc"><span class="toc-number">4.2.3.6.4.</span> <span class="toc-text">System.out.println(c)</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#getstatic-4"><span class="toc-number">4.2.3.6.4.1.</span> <span class="toc-text">getstatic #4</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#iload_3"><span class="toc-number">4.2.3.6.4.2.</span> <span class="toc-text">iload_3</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#invokevirtual-5"><span class="toc-number">4.2.3.6.4.3.</span> <span class="toc-text">invokevirtual #5</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#return"><span class="toc-number">4.2.3.6.5.</span> <span class="toc-text">return</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0%E5%88%86%E6%9E%90i"><span class="toc-number">4.2.4.</span> <span class="toc-text">练习：分析 i++</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#int-a-10-2"><span class="toc-number">4.2.4.1.</span> <span class="toc-text">int a &#x3D; 10</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#int-b-a-a-a-"><span class="toc-number">4.2.4.2.</span> <span class="toc-text">int b &#x3D; a++ + ++a + a--</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD-%E6%8C%87%E4%BB%A4"><span class="toc-number">4.2.5.</span> <span class="toc-text">条件判断 指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E6%8E%A7%E5%88%B6-%E6%8C%87%E4%BB%A4"><span class="toc-number">4.2.6.</span> <span class="toc-text">循环控制 指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0%E5%88%A4%E6%96%AD%E7%BB%93%E6%9E%9C"><span class="toc-number">4.2.7.</span> <span class="toc-text">练习：判断结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">4.2.8.</span> <span class="toc-text">构造方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#clinitv"><span class="toc-number">4.2.8.1.</span> <span class="toc-text">&lt;clinit&gt;()V</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#initv"><span class="toc-number">4.2.8.2.</span> <span class="toc-text">&lt;init&gt;()V</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8-%E6%8C%87%E4%BB%A4"><span class="toc-number">4.2.9.</span> <span class="toc-text">方法调用 指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">4.2.10.</span> <span class="toc-text">多态的原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">4.2.11.</span> <span class="toc-text">异常处理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#try-catch"><span class="toc-number">4.2.11.1.</span> <span class="toc-text">try-catch</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E4%B8%AA-single-catch-%E5%9D%97"><span class="toc-number">4.2.11.2.</span> <span class="toc-text">多个 single-catch 块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#multi-catch"><span class="toc-number">4.2.11.3.</span> <span class="toc-text">multi-catch</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#finally"><span class="toc-number">4.2.11.4.</span> <span class="toc-text">finally</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0finally%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">4.2.12.</span> <span class="toc-text">练习：finally 面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#finally%E5%9D%97%E4%B8%AD%E5%87%BA%E7%8E%B0%E4%BA%86return"><span class="toc-number">4.2.12.1.</span> <span class="toc-text">finally 块中出现了 return</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#finally%E5%9D%97%E5%AF%B9%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="toc-number">4.2.12.2.</span> <span class="toc-text">finally 块对返回值的影响</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E6%8E%A7%E5%88%B6-synchronized%E5%9D%97"><span class="toc-number">4.2.13.</span> <span class="toc-text">同步控制 synchronized 块</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E7%BC%96%E8%AF%91%E6%9C%9F%E5%A4%84%E7%90%86%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96"><span class="toc-number">4.3.</span> <span class="toc-text">3、编译期处理（代码优化）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%E7%B3%96"><span class="toc-number">4.3.1.</span> <span class="toc-text">语法糖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-number">4.3.2.</span> <span class="toc-text">默认构造器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E6%8B%86%E8%A3%85%E7%AE%B1"><span class="toc-number">4.3.3.</span> <span class="toc-text">自动拆装箱</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E9%9B%86%E5%90%88%E5%8F%96%E5%80%BC%E6%B3%9B%E5%9E%8B%E6%93%A6%E9%99%A4"><span class="toc-number">4.3.4.</span> <span class="toc-text">泛型集合取值（泛型擦除）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0"><span class="toc-number">4.3.5.</span> <span class="toc-text">可变参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#foreach-%E5%BE%AA%E7%8E%AF"><span class="toc-number">4.3.6.</span> <span class="toc-text">foreach 循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#switch-%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">4.3.7.</span> <span class="toc-text">switch 字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#switch-%E6%9E%9A%E4%B8%BE"><span class="toc-number">4.3.8.</span> <span class="toc-text">switch 枚举</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E7%B1%BB"><span class="toc-number">4.3.9.</span> <span class="toc-text">枚举类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#try-with-resources"><span class="toc-number">4.3.10.</span> <span class="toc-text">try-with-resources</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99"><span class="toc-number">4.3.11.</span> <span class="toc-text">方法重写</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">4.3.12.</span> <span class="toc-text">匿名内部类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A0%E5%8F%82%E4%BC%98%E5%8C%96"><span class="toc-number">4.3.12.1.</span> <span class="toc-text">无参优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%A6%E5%8F%82%E4%BC%98%E5%8C%96"><span class="toc-number">4.3.12.2.</span> <span class="toc-text">带参优化</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E7%B1%BB%E5%8A%A0%E8%BD%BD"><span class="toc-number">4.4.</span> <span class="toc-text">4、类加载</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">4.4.1.</span> <span class="toc-text">类的生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">4.4.2.</span> <span class="toc-text">类加载的过程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD"><span class="toc-number">4.4.2.1.</span> <span class="toc-text">加载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%93%BE%E6%8E%A5"><span class="toc-number">4.4.2.2.</span> <span class="toc-text">链接</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%AA%8C%E8%AF%81"><span class="toc-number">4.4.2.2.1.</span> <span class="toc-text">验证</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%87%86%E5%A4%87"><span class="toc-number">4.4.2.2.2.</span> <span class="toc-text">准备</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90"><span class="toc-number">4.4.2.2.3.</span> <span class="toc-text">解析</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">4.4.2.3.</span> <span class="toc-text">初始化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0"><span class="toc-number">4.4.3.</span> <span class="toc-text">练习</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%8D%B8%E8%BD%BD"><span class="toc-number">4.4.4.</span> <span class="toc-text">类卸载</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">4.5.</span> <span class="toc-text">5、类加载器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86-3"><span class="toc-number">4.5.1.</span> <span class="toc-text">前置知识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-3"><span class="toc-number">4.5.2.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E7%BD%AE%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">4.5.3.</span> <span class="toc-text">内置的类加载器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">4.5.3.1.</span> <span class="toc-text">启动类加载器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">4.5.3.2.</span> <span class="toc-text">扩展类加载器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">4.5.3.3.</span> <span class="toc-text">应用程序类加载器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-3"><span class="toc-number">4.5.3.4.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">4.5.4.</span> <span class="toc-text">自定义类加载器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%9C%BA"><span class="toc-number">4.5.4.1.</span> <span class="toc-text">动机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D"><span class="toc-number">4.5.4.2.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4"><span class="toc-number">4.5.4.3.</span> <span class="toc-text">步骤</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B"><span class="toc-number">4.5.5.</span> <span class="toc-text">双亲委派模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-2"><span class="toc-number">4.5.5.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-number">4.5.5.2.</span> <span class="toc-text">执行流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9-2"><span class="toc-number">4.5.5.3.</span> <span class="toc-text">优缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%93%E7%A0%B4%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B"><span class="toc-number">4.5.5.4.</span> <span class="toc-text">打破双亲委派模型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F1%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">4.5.5.4.1.</span> <span class="toc-text">方式 1：自定义类加载器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F2%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">4.5.5.4.2.</span> <span class="toc-text">方式 2：线程上下文类加载器</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E8%BF%90%E8%A1%8C%E6%9C%9F%E4%BC%98%E5%8C%96"><span class="toc-number">4.6.</span> <span class="toc-text">6、运行期优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%B3%E6%97%B6%E7%BC%96%E8%AF%91jit"><span class="toc-number">4.6.1.</span> <span class="toc-text">即时编译（JIT）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%B1%82%E7%BC%96%E8%AF%91"><span class="toc-number">4.6.1.1.</span> <span class="toc-text">分层编译</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90"><span class="toc-number">4.6.1.2.</span> <span class="toc-text">逃逸分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%86%85%E8%81%94"><span class="toc-number">4.6.1.3.</span> <span class="toc-text">方法内联</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E6%AE%B5%E4%BC%98%E5%8C%96"><span class="toc-number">4.6.1.4.</span> <span class="toc-text">字段优化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E4%BC%98%E5%8C%96"><span class="toc-number">4.6.2.</span> <span class="toc-text">反射优化</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0jvm-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8Bjmm"><span class="toc-number">5.</span> <span class="toc-text">第五章：JVM 内存模型（JMM）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#0-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86"><span class="toc-number">5.1.</span> <span class="toc-text">0、前置知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#cpu-%E7%BC%93%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="toc-number">5.1.1.</span> <span class="toc-text">CPU 缓存模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E5%BA%8F"><span class="toc-number">5.1.2.</span> <span class="toc-text">指令重排序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-jmmjava-memory-model"><span class="toc-number">5.2.</span> <span class="toc-text">1、JMM（Java Memory Model）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">5.2.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E7%BA%BF%E7%A8%8B-%E4%B8%BB%E5%86%85%E5%AD%98%E7%9A%84%E6%8A%BD%E8%B1%A1"><span class="toc-number">5.2.2.</span> <span class="toc-text">对线程、主内存的抽象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8Ejava-%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">5.2.3.</span> <span class="toc-text">与 Java 内存区域的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7"><span class="toc-number">5.3.</span> <span class="toc-text">2、并发编程的三大特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E6%80%A7"><span class="toc-number">5.3.1.</span> <span class="toc-text">原子性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90static%E5%8F%98%E9%87%8F%E7%9A%84%E8%87%AA%E5%A2%9E-%E8%87%AA%E5%87%8F"><span class="toc-number">5.3.1.1.</span> <span class="toc-text">问题分析：static 变量的自增、自减</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95synchronized"><span class="toc-number">5.3.1.2.</span> <span class="toc-text">解决方法：synchronized</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="toc-number">5.3.2.</span> <span class="toc-text">可见性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%E9%80%80%E4%B8%8D%E5%87%BA%E7%9A%84%E5%BE%AA%E7%8E%AF"><span class="toc-number">5.3.2.1.</span> <span class="toc-text">问题分析：退不出的循环</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95volatile"><span class="toc-number">5.3.2.2.</span> <span class="toc-text">解决方法：volatile</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E5%BA%8F%E6%80%A7"><span class="toc-number">5.3.3.</span> <span class="toc-text">有序性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%E8%AF%A1%E5%BC%82%E7%9A%84%E6%B1%82%E5%92%8C%E7%BB%93%E6%9E%9C"><span class="toc-number">5.3.3.1.</span> <span class="toc-text">问题分析：诡异的求和结果</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95volatile-2"><span class="toc-number">5.3.3.2.</span> <span class="toc-text">解决方法：volatile</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95"><span class="toc-number">5.4.</span> <span class="toc-text">3、三大特性的实现方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">5.4.1.</span> <span class="toc-text">synchronized 关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-2"><span class="toc-number">5.4.1.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8"><span class="toc-number">5.4.1.2.</span> <span class="toc-text">如何使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A0%E6%B3%95%E4%BF%AE%E9%A5%B0%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">5.4.1.3.</span> <span class="toc-text">无法修饰构造方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E8%8E%B7%E5%8F%96-monitor"><span class="toc-number">5.4.1.4.</span> <span class="toc-text">底层原理：获取 Monitor</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#monitor-%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-number">5.4.1.4.1.</span> <span class="toc-text">Monitor 工作流程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%9D%97%E5%90%8C%E6%AD%A5"><span class="toc-number">5.4.1.4.2.</span> <span class="toc-text">代码块同步</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%90%8C%E6%AD%A5"><span class="toc-number">5.4.1.4.3.</span> <span class="toc-text">方法同步</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-4"><span class="toc-number">5.4.1.4.4.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#jdk-16-%E5%90%8E%E7%9A%84%E4%BC%98%E5%8C%96"><span class="toc-number">5.4.1.5.</span> <span class="toc-text">JDK 1.6 后的优化</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-4"><span class="toc-number">5.4.1.5.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#java%E5%AF%B9%E8%B1%A1%E5%A4%B4"><span class="toc-number">5.4.1.5.2.</span> <span class="toc-text">Java 对象头</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%94%81%E7%9A%84%E5%8D%87%E7%BA%A7"><span class="toc-number">5.4.1.5.3.</span> <span class="toc-text">锁的升级</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%97%A0%E9%94%81normal"><span class="toc-number">5.4.1.5.3.1.</span> <span class="toc-text">无锁（Normal）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%81%8F%E5%90%91%E9%94%81biased"><span class="toc-number">5.4.1.5.3.2.</span> <span class="toc-text">偏向锁（Biased）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81lightweight-locked"><span class="toc-number">5.4.1.5.3.3.</span> <span class="toc-text">轻量级锁（LightWeight Locked）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81heavyweight-locked"><span class="toc-number">5.4.1.5.3.4.</span> <span class="toc-text">重量级锁（HeavyWeight Locked）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-5"><span class="toc-number">5.4.1.5.3.5.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E4%BC%98%E5%8C%96"><span class="toc-number">5.4.1.5.4.</span> <span class="toc-text">其他优化</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%87%AA%E6%97%8B%E9%94%81"><span class="toc-number">5.4.1.5.4.1.</span> <span class="toc-text">自旋锁</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%94%81%E6%B6%88%E9%99%A4"><span class="toc-number">5.4.1.5.4.2.</span> <span class="toc-text">锁消除</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%94%81%E7%B2%97%E5%8C%96"><span class="toc-number">5.4.1.5.4.3.</span> <span class="toc-text">锁粗化</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8E-volatile-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">5.4.1.6.</span> <span class="toc-text">与 volatile 的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#volatile-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">5.4.2.</span> <span class="toc-text">volatile 关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%9D%E8%AF%81%E5%8F%98%E9%87%8F%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="toc-number">5.4.2.1.</span> <span class="toc-text">保证变量的可见性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A6%81%E6%AD%A2%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92"><span class="toc-number">5.4.2.2.</span> <span class="toc-text">禁止指令重排</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A0%E6%B3%95%E4%BF%9D%E8%AF%81%E5%8E%9F%E5%AD%90%E6%80%A7"><span class="toc-number">5.4.2.3.</span> <span class="toc-text">无法保证原子性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#happens-before-%E5%8E%9F%E5%88%99"><span class="toc-number">5.4.3.</span> <span class="toc-text">happens-before 原则</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3"><span class="toc-number">5.4.3.1.</span> <span class="toc-text">设计思想</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E8%A7%84%E5%88%99"><span class="toc-number">5.4.3.2.</span> <span class="toc-text">常见规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8E-jmm-%E6%98%AF%E4%BB%80%E4%B9%88%E5%85%B3%E7%B3%BB"><span class="toc-number">5.4.3.3.</span> <span class="toc-text">与 JMM 是什么关系</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%90%E8%A7%82%E9%94%81%E4%B8%8E%E6%82%B2%E8%A7%82%E9%94%81"><span class="toc-number">5.4.4.</span> <span class="toc-text">乐观锁与悲观锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%82%B2%E8%A7%82%E9%94%81"><span class="toc-number">5.4.4.1.</span> <span class="toc-text">悲观锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B9%90%E8%A7%82%E9%94%81"><span class="toc-number">5.4.4.2.</span> <span class="toc-text">乐观锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B9%90%E8%A7%82%E9%94%81"><span class="toc-number">5.4.4.3.</span> <span class="toc-text">如何实现乐观锁？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%89%88%E6%9C%AC%E5%8F%B7%E6%9C%BA%E5%88%B6"><span class="toc-number">5.4.4.3.1.</span> <span class="toc-text">版本号机制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#cas-%E7%AE%97%E6%B3%95"><span class="toc-number">5.4.4.3.2.</span> <span class="toc-text">CAS 算法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B9%90%E8%A7%82%E9%94%81%E5%AD%98%E5%9C%A8%E5%93%AA%E4%BA%9B%E9%97%AE%E9%A2%98"><span class="toc-number">5.4.4.4.</span> <span class="toc-text">乐观锁存在哪些问题？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#aba-%E9%97%AE%E9%A2%98"><span class="toc-number">5.4.4.4.1.</span> <span class="toc-text">ABA 问题</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E6%97%B6%E9%97%B4%E9%95%BF-%E5%BC%80%E9%94%80%E5%A4%A7"><span class="toc-number">5.4.4.4.2.</span> <span class="toc-text">循环时间长、开销大</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%AA%E8%83%BD%E4%BF%9D%E8%AF%81%E4%B8%80%E4%B8%AA%E5%85%B1%E4%BA%AB%E5%8F%98%E9%87%8F%E7%9A%84%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C"><span class="toc-number">5.4.4.4.3.</span> <span class="toc-text">只能保证一个共享变量的原子操作</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-6"><span class="toc-number">5.4.4.5.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#atomic-%E5%8E%9F%E5%AD%90%E7%B1%BB"><span class="toc-number">5.4.5.</span> <span class="toc-text">Atomic 原子类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-2"><span class="toc-number">5.5.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%87%8D%E8%A6%81%E7%9A%84-jvm-%E5%8F%82%E6%95%B0"><span class="toc-number">6.</span> <span class="toc-text">重要的 JVM 参数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%A0%86%E5%86%85%E5%AD%98"><span class="toc-number">6.1.</span> <span class="toc-text">1、堆内存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%BE%E5%BC%8F%E6%8C%87%E5%AE%9A%E5%A0%86%E5%86%85%E5%AD%98"><span class="toc-number">6.1.1.</span> <span class="toc-text">显式指定堆内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%BE%E5%BC%8F%E6%8C%87%E5%AE%9A%E6%96%B0%E7%94%9F%E4%BB%A3%E5%86%85%E5%AD%98"><span class="toc-number">6.1.2.</span> <span class="toc-text">显式指定新生代内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%BE%E5%BC%8F%E6%8C%87%E5%AE%9A%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="toc-number">6.1.3.</span> <span class="toc-text">显式指定方法区的大小</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-gc"><span class="toc-number">6.2.</span> <span class="toc-text">2、GC</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="toc-number">6.2.1.</span> <span class="toc-text">垃圾回收器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gc%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95"><span class="toc-number">6.2.2.</span> <span class="toc-text">GC 日志记录</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-oom"><span class="toc-number">6.3.</span> <span class="toc-text">3、OOM</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%85%B6%E4%BB%96"><span class="toc-number">6.4.</span> <span class="toc-text">4、其他</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#jdk%E7%9B%91%E6%8E%A7%E5%92%8C%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7"><span class="toc-number">7.</span> <span class="toc-text">JDK 监控和故障处理工具</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-jdk-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7"><span class="toc-number">7.1.</span> <span class="toc-text">1、JDK 命令行工具</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-jdk-%E5%8F%AF%E8%A7%86%E5%8C%96%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7"><span class="toc-number">7.2.</span> <span class="toc-text">2、JDK 可视化分析工具</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#jvm%E7%BA%BF%E4%B8%8A%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5%E4%B8%8E%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E7%9A%84%E6%A1%88%E4%BE%8B"><span class="toc-number">8.</span> <span class="toc-text">JVM 线上问题排查与性能调优的案例</span></a></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li class="active"><a href="/java/jvm/JVM%E7%AC%94%E8%AE%B0/" rel="bookmark" title="JVM笔记">JVM笔记</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="范特东东东" data-src="/images/avatar.jpg"><p class="name" itemprop="name">范特东东东</p><div class="description" itemprop="description"></div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">5</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">8</span> <span class="name">分类</span></a></div></nav><div class="social"></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于我</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmFpZHUuY29tLw=="><i class="ic i-photography"></i>摄影</span></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/java/java-se/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E5%AE%8B%E7%BA%A2%E5%BA%B7_%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/database/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/java/" title="分类于 Java">Java</a> <i class="ic i-angle-right"></i> <a href="/categories/java/jvm/" title="分类于 JVM">JVM</a></div><span><a href="/java/jvm/JVM%E7%AC%94%E8%AE%B0/" title="JVM笔记">JVM笔记</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/java/" title="分类于 Java">Java</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/" title="分类于 Java基础">Java基础</a></div><span><a href="/java/java-se/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E5%AE%8B%E7%BA%A2%E5%BA%B7_%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/" title="宋红康_第01章_Java语言概述">宋红康_第01章_Java语言概述</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/leetcode/" title="分类于 LeetCode">LeetCode</a> <i class="ic i-angle-right"></i> <a href="/categories/leetcode/carl/" title="分类于 代码随想录">代码随想录</a></div><span><a href="/leetcode/carl/%E7%AC%94%E8%AE%B0%E9%9A%8F%E6%83%B3%E5%BD%95/" title="代码随想录-笔记">代码随想录-笔记</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/framework/" title="分类于 常用框架">常用框架</a> <i class="ic i-angle-right"></i> <a href="/categories/framework/spring/" title="分类于 Spring">Spring</a></div><span><a href="/framework/spring/spring6/" title="尚硅谷 Spring6">尚硅谷 Spring6</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/database/" title="分类于 数据库">数据库</a></div><span><a href="/database/%E6%95%B0%E6%8D%AE%E5%BA%93/" title="数据库总结">数据库总结</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2023</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">范特东东东 @ phantasy</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">615k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">9:19</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"java/jvm/JVM笔记/",favicon:{show:"(●´3｀●)欢迎回来",hide:"(〃＞皿＜)你快回来"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hrmmi -->