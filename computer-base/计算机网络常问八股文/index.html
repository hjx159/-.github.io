<!-- build time:Sun May 26 2024 21:27:13 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="水文 & 摄影" href="http://example.com/rss.xml"><link rel="alternate" type="application/atom+xml" title="水文 & 摄影" href="http://example.com/atom.xml"><link rel="alternate" type="application/json" title="水文 & 摄影" href="http://example.com/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><link rel="canonical" href="http://example.com/computer-base/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%B8%B8%E9%97%AE%E5%85%AB%E8%82%A1%E6%96%87/"><title>计算机网络常问八股文 - 计算机网络 - 计算机基础 | fantedong = 水文 & 摄影 = 为了能更好地查看图片，你需要一点魔法</title><meta name="generator" content="Hexo 6.3.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">计算机网络常问八股文</h1><div class="meta"><span class="item" title="创建时间：2024-05-24 15:18:50"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2024-05-24T15:18:50+08:00">2024-05-24</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>36k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>33 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">fantedong</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://pic.imgdb.cn/item/65e332b89f345e8d03173937.jpg"></li><li class="item" data-background-image="https://pic.imgdb.cn/item/6553a275c458853aef40b256.jpg"></li><li class="item" data-background-image="https://pic.imgdb.cn/item/6553a0aac458853aef3aa386.jpg"></li><li class="item" data-background-image="https://pic.imgdb.cn/item/6554c7d9c458853aefd857b8.jpg"></li><li class="item" data-background-image="https://pic.imgdb.cn/item/657b3571c458853aef5fbdad.jpg"></li><li class="item" data-background-image="https://pic.imgdb.cn/item/656f27bac458853aef5f729f.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/computer-base/" itemprop="item" rel="index" title="分类于 计算机基础"><span itemprop="name">计算机基础</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/computer-base/computer-network/" itemprop="item" rel="index" title="分类于 计算机网络"><span itemprop="name">计算机网络</span></a><meta itemprop="position" content="2"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://example.com/computer-base/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%B8%B8%E9%97%AE%E5%85%AB%E8%82%A1%E6%96%87/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="范特东东东"><meta itemprop="description" content="为了能更好地查看图片，你需要一点魔法, "></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="水文 & 摄影"></span><div class="body md" itemprop="articleBody"><h1 id="网络分层模型"><a class="anchor" href="#网络分层模型">#</a> 网络分层模型</h1><h2 id="osi-七层模型"><a class="anchor" href="#osi-七层模型">#</a> OSI 七层模型</h2><p><strong>OSI 七层模型</strong> 是国际标准化组织提出的一个网络分层模型，其大体结构以及每一层提供的功能如下图所示：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/20240524185217.png" alt="image.png"></p><p>每一层都专注做一件事情，并且<font color="red">每一层都需要使用下一层提供的功能</font>。比如传输层需要使用网络层提供的路由和寻址功能，这样传输层才知道把数据传输到哪里去。</p><p><font color="red">OSI 的七层体系结构概念清楚，理论也很完整，但是它比较复杂而且不实用，而且有些功能在多个层中重复出现</font>。</p><p>上面这种图可能比较抽象，再来一个比较生动的图片。下面这个图片是我在国外的一个网站上看到的，非常赞！</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/20240524190930.png" alt="image.png"></p><p>既然 OSI 七层模型这么厉害，为什么干不过 TCP/IP 四层模型呢？OSI 七层模型虽然失败了，但是却提供了很多不错的理论基础。为了更好地去了解网络分层，OSI 七层模型还是非常有必要学习的。</p><p>最后再分享一个关于 OSI 七层模型非常不错的总结图片！</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/20240524193712.png" alt="image.png"></p><h2 id="tcpip-四层模型"><a class="anchor" href="#tcpip-四层模型">#</a> TCP/IP 四层模型</h2><p><strong>TCP/IP 四层模型</strong> 是目前被广泛采用的一种模型，我们可以将 TCP / IP 模型看作是 OSI 七层模型的精简版本，由以下 4 层组成：</p><ol><li>应用层</li><li>传输层</li><li>网络层</li><li>网络接口层</li></ol><p>需要注意的是，我们并不能将 TCP/IP 四层模型 和 OSI 七层模型完全精确地匹配起来，不过可以简单将两者对应起来，如下图所示：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/20240524191118.png" alt="image.png"></p><h3 id="应用层application"><a class="anchor" href="#应用层application">#</a> 应用层（Application）</h3><p>应用层位于传输层之上，<strong>提供两个终端设备上的<em>应用程序</em>之间信息交换的服务</strong>，它定义了信息交换的格式，消息会交给下一层的传输层来传输。 我们把应用层交互的数据单元称为<font color="gree">报文</font>。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/20240524195003.png" alt="image.png"></p><p>应用层协议定义了网络通信规则，<font color="red">对于不同的网络应用需要不同的应用层协议</font>。在互联网中应用层协议很多，如支持 Web 应用的 HTTP 协议，支持电子邮件的 SMTP 协议等等。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/20240524195212.png" alt="image.png"></p><h4 id="http超文本传输协议"><a class="anchor" href="#http超文本传输协议">#</a> HTTP：超文本传输协议</h4><p><strong>超文本传输协议（HTTP，HyperText Transfer Protocol)</strong> 是一种用于传输<font color="red">超文本和多媒体内容</font>的协议，主要是为 <font color="red">Web</font> 浏览器与 Web 服务器之间的通信而设计的。当我们使用浏览器浏览网页的时候，我们网页就是通过 HTTP 请求进行加载的。</p><p>HTTP 使用<font color="red">客户端 - 服务器模型</font>，客户端向服务器发送 HTTP Request（请求），服务器响应请求并返回 HTTP Response（响应），整个过程如下图所示。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/20240524195656.png" alt="image.png"></p><p>HTTP 协议<font color="red">基于 TCP 协议</font>，发送 HTTP 请求之前首先要建立 TCP 连接也就是要经历 3 次握手。目前使用的 HTTP 协议<font color="red">大部分都是 HTTP 1.1</font>。在 1.1 的协议里面，默认是开启了 Keep-Alive 的，这样的话建立的连接就可以在多次请求中被复用了。</p><p>另外， HTTP 协议是” 无状态” 的协议，<font color="red">它无法记录客户端用户的状态</font>，一般我们都是通过 Session 来记录客户端用户的状态。</p><p>详见<a href="#HTTP"> HTTP</a>。</p><h4 id="websocket全双工通信协议"><a class="anchor" href="#websocket全双工通信协议">#</a> Websocket：全双工通信协议</h4><p>WebSocket 是一种<font color="red">基于 TCP 协议</font>的<font color="red">全双工</font>通信协议，即客户端和服务器可以同时发送和接收数据。</p><p>WebSocket 协议在 2008 年诞生，2011 年成为国际标准，几乎所有主流较新版本的浏览器都支持该协议。不过，WebSocket 不止能在基于浏览器的应用程序中使用，很多编程语言、框架和服务器都提供了 WebSocket 支持。</p><p>WebSocket 协议本质上是应用层的协议，<strong>用于弥补 HTTP 协议在持久通信能力上的不足</strong>。客户端和服务器仅需一次握手，两者之间就直接可以创建<font color="red">持久性的连接</font>，并进行<font color="red">双向数据传输</font>。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/20240524200123.png" alt="image.png"></p><p>下面是 WebSocket 的常见应用场景：</p><ul><li>视频弹幕</li><li>实时消息推送，详见<span class="exturl" data-url="aHR0cHM6Ly9qYXZhZ3VpZGUuY24vc3lzdGVtLWRlc2lnbi93ZWItcmVhbC10aW1lLW1lc3NhZ2UtcHVzaC5odG1s"> Web 实时消息推送详解</span>这篇文章</li><li>实时游戏对战</li><li>多用户协同编辑</li><li>社交聊天</li><li>……</li></ul><p>WebSocket 的工作过程可以分为以下几个步骤：</p><ol><li>客户端向服务器发送一个 HTTP 请求，请求头中包含 <code>Upgrade: websocket</code> 和 <code>Sec-WebSocket-Key</code> 等字段，表示<font color="red">要求升级协议为 WebSocket</font>；</li><li>服务器收到这个请求后，会进行升级协议的操作，如果支持 WebSocket，它将回复一个 HTTP 101 状态码，响应头中包含 ， <code>Connection: Upgrade</code> 和 <code>Sec-WebSocket-Accept: xxx</code> 等字段、表示<font color="red">成功升级</font>到 WebSocket 协议。</li><li>客户端和服务器之间<font color="red">建立了一个 WebSocket 连接</font>，可以进行双向的数据传输。数据以<font color="red">帧（frames）</font>的形式进行传送，WebSocket 的每条消息可能会被切分成多个数据帧（最小单位）。发送端会将消息切割成多个帧发送给接收端，接收端接收消息帧，并将关联的帧重新组装成完整的消息。</li><li>客户端或服务器可以<font color="red">主动发送一个关闭帧</font>，表示要断开连接。另一方收到后，也会回复一个关闭帧，然后<font color="red">双方关闭 TCP 连接</font>。</li></ol><p>另外，建立 WebSocket 连接之后，通过<font color="red">心跳机制</font>来保持 WebSocket 连接的稳定性和活跃性。</p><h4 id="smtp简单邮件传输发送协议"><a class="anchor" href="#smtp简单邮件传输发送协议">#</a> SMTP：简单邮件传输（发送）协议</h4><p>简单邮件传输（发送）协议（SMTP，Simple Mail Transfer Protocol） <font color="red">基于 TCP 协议</font>，是一种<strong>用于<u>发送</u>电子邮件</strong>的协议。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/20240524200959.png" alt="image.png"></p><p>注意 ⚠️：<strong><u>接收</u>邮件的协议不是 SMTP，而是 POP3/IMAP 协议。</strong></p><p>SMTP 协议这块涉及的内容比较多，下面这两个问题比较重要：</p><ol><li>电子邮件的发送过程</li><li>如何判断邮箱是真正存在的？</li></ol><h5 id="电子邮件的发送过程"><a class="anchor" href="#电子邮件的发送过程">#</a> 电子邮件的发送过程</h5><p>比如我的邮箱是 “<span class="exturl" data-url="bWFpbHRvOmRhYmFpQGNzemhpbmFuLmNvbQ==">dabai@cszhinan.com</span>”，我要向 “<span class="exturl" data-url="bWFpbHRvOnhpYW9tYUBxcS5jb20=">xiaoma@qq.com</span>” 发送邮件，整个过程可以简单分为下面几步：</p><ol><li>通过 <strong>SMTP</strong> 协议，我将我写好的邮件交给 <font color="red">163 邮箱服务器（邮局）</font>。</li><li>163 邮箱服务器发现我发送的邮箱是 qq 邮箱，然后它使用 SMTP 协议将我的邮件<font color="red">转发到 qq 邮箱服务器</font>。</li><li>qq 邮箱服务器接收邮件之后就通知邮箱为 “<span class="exturl" data-url="bWFpbHRvOnhpYW9tYUBxcS5jb20=">xiaoma@qq.com</span>” 的用户来收邮件，然后用户就通过 <strong>POP3/IMAP</strong> 协议将邮件取出。</li></ol><h5 id="判断邮箱是否有效"><a class="anchor" href="#判断邮箱是否有效">#</a> 判断邮箱是否有效</h5><p>很多场景 (比如邮件营销) 下面我们需要判断我们要发送的邮箱地址是否真的存在，这个时候我们可以利用 SMTP 协议来检测：</p><ol><li>查找邮箱域名对应的 SMTP 服务器地址</li><li>尝试与服务器建立连接</li><li>连接成功后尝试向需要验证的邮箱发送邮件</li><li>根据返回结果判定邮箱地址的真实性</li></ol><p>推荐几个在线邮箱是否有效检测工具：</p><ol><li><span class="exturl" data-url="aHR0cHM6Ly92ZXJpZnktZW1haWwub3JnLw==">https://verify-email.org/open in new window</span></li><li><span class="exturl" data-url="aHR0cDovL3Rvb2wuY2hhY3VvLm5ldC9tYWlsdmVyaWZ5">http://tool.chacuo.net/mailverifyopen in new window</span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuZW1haWxjYW1lbC5jb20v">https://www.emailcamel.com/</span></li></ol><h4 id="pop3imap邮件接收的协议"><a class="anchor" href="#pop3imap邮件接收的协议">#</a> POP3/IMAP：邮件接收的协议</h4><p>这两个协议没必要多做阐述，只需要了解 POP3 和 IMAP 两者都是负责接收邮件的协议即可（二者也是基于 TCP 协议）。另外，需要注意不要将这两者和 SMTP 协议搞混淆了。<strong>SMTP 协议只负责邮件的发送，真正负责接收邮件的协议是 POP3/IMAP</strong>。</p><p><font color="red">IMAP 协议是比 POP3 更新的协议</font>，它在功能和性能上都更加强大。IMAP 支持邮件搜索、标记、分类、归档等高级功能，而且可以在多个设备之间同步邮件状态。几乎所有现代电子邮件客户端和服务器都支持 IMAP。</p><h4 id="ftp文件传输协议"><a class="anchor" href="#ftp文件传输协议">#</a> FTP：文件传输协议</h4><p>FTP 协议<font color="red">基于 TCP 协议</font>，是一种<strong>用于在计算机之间传输文件</strong>的协议，可以屏蔽操作系统和文件存储方式。</p><p>FTP 是基于<font color="red">客户 — 服务器（C/S）模型</font>而设计的，在客户端与 FTP 服务器之间建立两个连接。如果我们要基于 FTP 协议开发一个文件传输的软件的话，首先需要搞清楚 FTP 的原理。关于 FTP 的原理，很多书籍上已经描述的非常详细了：</p><blockquote><p>FTP 的独特的优势同时也是与其它客户服务器程序最大的不同点就在于，<strong><font color="red">它在两台通信的主机之间使用了两条 TCP 连接</font></strong>（其它客户服务器应用程序一般只有一条 TCP 连接）：</p><ol><li><font color="red">控制连接</font>：用于传送控制信息（命令和响应）；</li><li><font color="red">数据连接</font>：用于数据传送；</li></ol><p>这种<strong>将命令和数据分开传送</strong>的思想大大提高了 FTP 的效率。</p></blockquote><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/20240525185622.png" alt="image.png"></p><p>注意 ⚠️：FTP 是一种<font color="red">不安全</font>的协议，因为它在传输过程中不会对数据进行加密。因此，FTP 传输的文件可能会被窃听或篡改。建议在传输敏感数据时使用更安全的协议，如 <strong>SFTP</strong>（一种基于 SSH 协议的安全文件传输协议，用于在网络上安全地传输文件）。</p><h4 id="telnet远程登陆协议"><a class="anchor" href="#telnet远程登陆协议">#</a> Telnet：远程登陆协议</h4><p>Telnet 协议<font color="red">基于 TCP 协议</font>，<strong>用于通过一个终端登陆到其他服务器</strong>。Telnet 协议的最大缺点之一是所有数据（包括用户名和密码）均以<font color="red">明文</font>形式发送，这有潜在的安全风险。这就是为什么如今<font color="red">很少使用</font> Telnet，而是使用一种称为 <strong>SSH</strong> 的非常安全的网络传输协议的主要原因。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/20240525185955.png" alt="image.png"></p><h4 id="ssh安全的网络传输协议"><a class="anchor" href="#ssh安全的网络传输协议">#</a> SSH：安全的网络传输协议</h4><p><strong>SSH（Secure Shell）</strong> <font color="red">基于 TCP 协议</font>，<strong>通过加密和认证机制实现安全的访问和文件传输等业务</strong>。</p><p>SSH 的经典用途是<font color="red">登录到远程电脑中执行命令</font>。除此之外，SSH 也支持隧道协议、端口映射和 X11 连接。借助 SFTP 或 SCP 协议，SSH 还可以传输文件。</p><p>SSH 使用<font color="red">客户端 - 服务器模型</font>，默认端口是 22。SSH 是一个守护进程，负责实时监听客户端请求，并进行处理。大多数现代操作系统都提供了 SSH。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/20240525190212.png" alt="image.png"></p><h4 id="rtp实时传输协议"><a class="anchor" href="#rtp实时传输协议">#</a> RTP：实时传输协议</h4><p><strong>RTP（Real-time Transport Protocol，实时传输协议）</strong> <font color="red">通常基于 UDP 协议，但也支持 TCP 协议</font>。它提供了端到端的实时传输数据的功能，但不包含资源预留存、不保证实时传输质量，这些功能由 WebRTC 实现。</p><p>RTP 协议分为两种子协议：</p><ul><li><strong>RTP（Real-time Transport Protocol，实时传输协议）</strong>：传输具有实时特性的数据。</li><li><strong>RTCP（RTP Control Protocol，RTP 控制协议）</strong>：提供实时传输过程中的统计信息（如网络延迟、丢包率等），WebRTC 正是根据这些信息处理丢包</li></ul><h4 id="dns域名系统"><a class="anchor" href="#dns域名系统">#</a> DNS：域名系统</h4><p>DNS（Domain Name System，域名管理系统）<font color="red">基于 UDP 协议</font>，<strong>用于解决域名和 IP 地址的映射问题</strong>。详见<a href="#DNS"> DNS</a>。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/20240524171841.png" alt="image.png"></p><h3 id="传输层transport"><a class="anchor" href="#传输层transport">#</a> 传输层（Transport）</h3><p><strong>负责向两台终端设备的<em>应用进程</em>之间的通信提供通用的数据传输服务</strong> 。应用进程利用该服务传送应用层报文。“通用的” 是指并不针对某一个特定的网络应用，而是多种应用可以使用同一个传输层服务。</p><p>传输层常见协议：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/20240525191256.png" alt="image.png"></p><ul><li><font color="cornflowerblue">TCP（Transmission Control Protocol，传输控制协议 ）</font>：提供 <strong>面向连接</strong> 的，<strong>可靠</strong> 的数据传输服务。</li><li><font color="cornflowerblue">UDP（User Datagram Protocol，用户数据协议）</font>：提供 <strong>无连接</strong> 的，<strong>尽最大努力</strong> 的数据传输服务（不保证数据传输的可靠性），简单高效。</li></ul><h3 id="网络层network"><a class="anchor" href="#网络层network">#</a> 网络层（Network）</h3><p><strong>负责为分组交换网上的不同主机提供通信服务</strong>。 在发送数据时，网络层把传输层产生的报文段（segment）或用户数据报（UDP）<strong>封装成分组和包，进行传送</strong>。在 TCP/IP 体系结构中，由于网络层使用 IP 协议，因此<font color="red">分组也叫 IP 数据报，简称数据报</font>。</p><blockquote><p>⚠️ 注意：不要把运输层的 “用户数据报 UDP” 和网络层的 “IP 数据报” 弄混。</p></blockquote><p>网络层的还有一个任务就是<strong>选择合适的路由</strong>，使源主机运输层所传下来的分组，能通过网络层中的路由器找到目的主机。</p><p>这里强调指出，网络层中的 “网络” 二字已经不是我们通常谈到的具体网络，而是指计算机网络体系结构模型中第三层的名称。</p><p>互联网是由大量的异构（heterogeneous）网络通过路由器（router）相互连接起来的。互联网使用的网络层协议是无连接的网际协议（Internet Protocol）和许多路由选择协议，因此互联网的网络层也叫做 <font color="red">网际层 或 IP 层</font>。</p><p>网络层常见协议：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/20240525191830.png" alt="image.png"></p><ul><li><strong>IP（Internet Protocol，网际协议）</strong>：TCP/IP 协议中最重要的协议之一，主要作用是<font color="red">定义数据包的格式、对数据包进行路由和寻址</font>，以便它们可以跨网络传播并到达正确的目的地。目前 IP 协议主要分为两种，一种是过去的 <font color="cornflowerblue">IPv4</font>，另一种是较新的 <font color="cornflowerblue">IPv6</font>，目前这两种协议都在使用，但后者已经被提议来取代前者。</li><li><strong>ARP（Address Resolution Protocol，地址解析协议）</strong>：ARP 协议解决的是<font color="red">网络层地址和链路层地址之间的转换问题</font>。因为一个 IP 数据报在物理上传输的过程中，总是需要知道下一跳（物理上的下一个目的地）该去往何处，<font color="red">但 IP 地址属于逻辑地址，而 MAC 地址才是物理地址，ARP 协议解决了 IP 地址转 MAC 地址的一些问题</font>。</li><li><strong>ICMP（Internet Control Message Protocol，互联网控制报文协议）</strong>：一种<font color="red">用于传输网络状态和错误消息</font>的协议，常用于网络诊断和故障排除。例如，Ping 工具就使用了 ICMP 协议来测试网络连通性。</li><li><strong>NAT（Network Address Translation，网络地址转换协议）</strong>：NAT 协议的应用场景如同它的名称 ——<font color="red">网络地址转换，应用于内部网到外部网的地址转换过程中</font>。具体地说，在一个小的子网（局域网，LAN）内，各主机使用的是同一个 LAN 下的 IP 地址，但在该 LAN 以外，在广域网（WAN）中，需要一个统一的 IP 地址来标识该 LAN 在整个 Internet 上的位置。</li><li><strong>OSPF（Open Shortest Path First，开放式最短路径优先）</strong>：一种<font color="red">内部网关协议（Interior Gateway Protocol，IGP）</font>，也是广泛使用的一种<font color="red">动态路由协议</font>，基于<em>链路状态算法</em>，考虑了链路的带宽、延迟等因素来选择最佳路径。</li><li><strong>RIP (Routing Information Protocol，路由信息协议）</strong>：一种<font color="red">内部网关协议（Interior Gateway Protocol，IGP）</font>，也是一种<font color="red">动态路由协议</font>，基于<em>距离向量算法</em>，使用固定的跳数作为度量标准，选择跳数最少的路径作为最佳路径。</li><li><strong>BGP（Border Gateway Protocol，边界网关协议）</strong>：一种<font color="red">用来在路由选择域之间交换网络层可达性信息（Network Layer Reachability Information，NLRI）</font>的路由选择协议，具有高度的灵活性和可扩展性。</li></ul><h3 id="网络接口层network-interface"><a class="anchor" href="#网络接口层network-interface">#</a> 网络接口层（Network interface）</h3><p>我们可以把网络接口层看作以下两层的合体：</p><ol><li><font color="cornflowerblue">数据链路层（data link layer）</font>：通常简称为链路层（ 两台主机之间的数据传输，总是在一段一段的链路上传送的），其作用是<strong>将网络层交下来的 IP 数据报组装成帧（frame），在两个相邻节点间的链路上传送帧</strong>。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。</li><li><font color="cornflowerblue">物理层</font>：其作用是<strong>实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异</strong>。</li></ol><p>网络接口层重要功能和协议如下图所示：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/20240525192814.png" alt="image.png"></p><h3 id="小结"><a class="anchor" href="#小结">#</a> 小结</h3><p>简单总结一下每一层包含的协议和核心技术：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/20240525192844.png" alt="image.png"></p><center>TCP/IP 各层协议概览</center><p><strong>应用层协议</strong> :</p><ul><li>HTTP（HyperText Transfer Protocol，超文本传输协议）</li><li>SMTP（Simple Mail Transfer Protocol，简单邮件发送协议）</li><li>POP3/IMAP（邮件接收协议）</li><li>FTP（File Transfer Protocol，文件传输协议）</li><li>Telnet（远程登陆协议）</li><li>SSH（Secure Shell Protocol，安全的网络传输协议）</li><li>RTP（Real-time Transport Protocol，实时传输协议）</li><li>DNS（Domain Name System，域名管理系统）</li><li>……</li></ul><p><strong>传输层协议</strong> :</p><ul><li>TCP 协议<ul><li>报文段结构</li><li>面向连接</li><li>可靠数据传输</li><li>流量控制</li><li>拥塞控制</li></ul></li><li>UDP 协议<ul><li>报文段结构</li><li>无连接</li><li>RDT（可靠数据传输协议）</li></ul></li></ul><p><strong>网络层协议</strong> :</p><ul><li>IP（Internet Protocol，网际协议）</li><li>ARP（Address Resolution Protocol，地址解析协议）</li><li>ICMP 协议（控制报文协议，用于发送控制消息）</li><li>NAT（Network Address Translation，网络地址转换协议）</li><li>OSPF（Open Shortest Path First，开放式最短路径优先）</li><li>RIP (Routing Information Protocol，路由信息协议）</li><li>BGP（Border Gateway Protocol，边界网关协议）</li><li>……</li></ul><p><strong>网络接口层</strong> :</p><ul><li>差错检测技术</li><li>多路访问协议（信道复用技术）</li><li>CSMA/CD 协议</li><li>MAC 协议</li><li>以太网技术</li><li>……</li></ul><h2 id="网络分层的原因"><a class="anchor" href="#网络分层的原因">#</a> 网络分层的原因</h2><p>“网络为什么要分层？”</p><p>说到分层，我们先从我们平时使用框架开发一个后台程序来说，我们往往会按照每一层做不同的事情的原则将系统分为三层（复杂的系统分层会更多）：</p><ol><li>Repository（数据库操作）</li><li>Service（业务操作）</li><li>Controller（前后端数据交互）</li></ol><p>复杂的系统需要分层，因为每一层都需要专注于一类事情。网络分层的原因也是一样，<font color="red">每一层只专注于做一类事情</font>。</p><p>好了，再来说回：“为什么网络要分层？”。我觉得主要有 3 方面的原因：</p><ol><li><strong>各层之间相互独立</strong>：各层之间相互独立，各层之间不需要关心其他层是如何实现的，<font color="red">只需要知道自己如何调用下层提供好的功能就可以了（可以简单理解为接口调用）</font>。这个和我们对开发时系统进行分层是一个道理。</li><li><strong>提高了整体灵活性</strong>：每一层都可以使用最适合的技术来实现，你只需要保证你提供的功能以及暴露的接口的规则没有改变就行了。这个和我们平时开发系统的时候要求的<font color="red">高内聚、低耦合的原则</font>也是可以对应上的。</li><li><strong>大问题化小</strong>：分层可以将复杂的网络问题分解为许多比较小的、界线比较清晰简单的小问题来处理和解决。这样使得复杂的计算机网络系统变得易于设计，实现和标准化。 这个和我们平时开发的时候，一般会将系统功能分解，然后将复杂的问题分解为容易理解的更小的问题是相对应的，<font color="red">这些较小的问题具有更好的边界（目标和接口）定义</font>。</li></ol><p>我想到了计算机世界非常非常有名的一句话，这里分享一下：</p><blockquote><p>计算机科学领域的任何问题都可以通过增加一个<font color="red">间接的中间层</font>来解决，计算机整个体系从上到下都是按照严格的层次结构设计的。</p></blockquote><h1 id="http"><a class="anchor" href="#http">#</a> HTTP</h1><h2 id="http-是什么"><a class="anchor" href="#http-是什么">#</a> HTTP 是什么</h2><p>关于 HTTP 的简介见<a href="#HTTP%EF%BC%9A%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE"> HTTP：超文本传输协议</a>。</p><h2 id="http-状态码"><a class="anchor" href="#http-状态码">#</a> HTTP 状态码</h2><p>HTTP 状态码用于描述 HTTP 请求的结果，常见的如下：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/20240525204823.png" alt="image.png"></p><h3 id="1xx-informational信息性状态码"><a class="anchor" href="#1xx-informational信息性状态码">#</a> 1xx Informational（信息性状态码）</h3><p>相比于其他类别状态码来说，1xx 平时大概率不会碰到，所以这里直接跳过。</p><h3 id="2xx-success成功状态码"><a class="anchor" href="#2xx-success成功状态码">#</a> 2xx Success（成功状态码）</h3><ul><li><strong>200 OK</strong>：请求被成功处理。比如我们发送一个查询用户数据的 HTTP 请求到服务端，服务端正确返回了用户数据。这个是我们平时最常见的一个 HTTP 状态码。</li><li><strong>201 Created</strong>：请求被成功处理并且在服务端创建了一个新的资源。比如我们通过 POST 请求创建一个新的用户。</li><li><strong>202 Accepted</strong>：服务端已经接收到了请求，但是还未处理。</li><li><strong>204 No Content</strong>：服务端已经成功处理了请求，但是没有返回任何内容。</li></ul><p>这里格外提一下 204 状态码，平时学习 / 工作中见到的次数并不多。简单来说，<font color="red">204 状态码描述的是我们向服务端发送 HTTP 请求之后，只关注处理结果是否成功的场景</font>。也就是说我们需要的就是一个结果：true/false。</p><p>举个例子：你要追一个女孩子，你问女孩子：“我能追你吗？”，女孩子回答：“好！”。我们把这个女孩子当做是服务端就很好理解 204 状态码了。</p><h3 id="3xx-redirection重定向状态码"><a class="anchor" href="#3xx-redirection重定向状态码">#</a> 3xx Redirection（重定向状态码）</h3><ul><li><strong>301 Moved Permanently</strong>：资源被<font color="red">永久</font>重定向了。比如你的网站的网址更换了。</li><li><strong>302 Found</strong>：资源被<font color="red">临时</font>重定向了。比如你的网站的某些资源被暂时转移到另外一个网址。</li></ul><h3 id="4xx-client-error客户端错误状态码"><a class="anchor" href="#4xx-client-error客户端错误状态码">#</a> 4xx Client Error（客户端错误状态码）</h3><ul><li><strong>400 Bad Request</strong>：发送的 HTTP 请求存在问题。比如请求参数不合法、请求方法错误。</li><li><strong>401 Unauthorized</strong>：未认证却请求需要认证之后才能访问的资源。</li><li><strong>403 Forbidden</strong>：直接拒绝 HTTP 请求，不处理。一般用来针对非法请求。</li><li><strong>404 Not Found</strong>：你请求的资源未在服务端找到。比如你请求某个用户的信息，服务端并没有找到指定的用户。</li><li><strong>409 Conflict</strong>：表示请求的资源与服务端当前的状态存在冲突，请求无法被处理。</li></ul><h3 id="5xx-server-error服务端错误状态码"><a class="anchor" href="#5xx-server-error服务端错误状态码">#</a> 5xx Server Error（服务端错误状态码）</h3><ul><li><strong>500 Internal Server Error</strong>：服务端出问题了（通常是服务端出 Bug 了）。比如你服务端处理请求的时候突然抛出异常，但是异常并未在服务端被正确处理。</li><li><strong>502 Bad Gateway</strong>：我们的网关将请求转发到服务端，但是服务端返回的却是一个错误的响应。</li></ul><h2 id="http-header"><a class="anchor" href="#http-header">#</a> HTTP Header</h2><table><thead><tr><th>请求头字段名</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td>Accept</td><td>能够接受的响应内容类型（Content-Types）</td><td>Accept: text/plain</td></tr><tr><td>Accept-Charset</td><td>能够接受的字符集</td><td>Accept-Charset: utf-8</td></tr><tr><td>Accept-Datetime</td><td>能够接受的按照时间来表示的版本</td><td>Accept-Datetime: Thu, 31 May 2007 20:35:00 GMT</td></tr><tr><td>Accept-Encoding</td><td>能够接受的编码方式列表。参考 HTTP 压缩</td><td>Accept-Encoding: gzip, deflate</td></tr><tr><td>Accept-Language</td><td>能够接受的回应内容的自然语言列表。</td><td>Accept-Language: en-US</td></tr><tr><td>Authorization</td><td>用于超文本传输协议的认证的认证信息</td><td>Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==</td></tr><tr><td>Cache-Control</td><td>用来指定在这次的请求 / 响应链中的所有缓存机制 都必须 遵守的指令</td><td>Cache-Control: no-cache</td></tr><tr><td>Connection</td><td>该浏览器想要优先使用的连接类型</td><td>Connection: keep-alive Connection: Upgrade</td></tr><tr><td>Content-Length</td><td>以 八位字节数组 （8 位的字节）表示的请求体的长度</td><td>Content-Length: 348</td></tr><tr><td>Content-MD5</td><td>请求体的内容的二进制 MD5 散列值，以 Base64 编码的结果</td><td>Content-MD5: Q2hlY2sgSW50ZWdyaXR5IQ==</td></tr><tr><td>Content-Type</td><td>请求体的 多媒体类型 （用于 POST 和 PUT 请求中）</td><td>Content-Type: application/x-www-form-urlencoded</td></tr><tr><td>Cookie</td><td>之前由服务器通过 Set- Cookie （下文详述）发送的一个 超文本传输协议 Cookie</td><td>Cookie: $Version=1; Skin=new;</td></tr><tr><td>Date</td><td>发送该消息的日期和时间 (按照 RFC 7231 中定义的 &quot;超文本传输协议日期&quot; 格式来发送)</td><td>Date: Tue, 15 Nov 1994 08:12:31 GMT</td></tr><tr><td>Expect</td><td>表明客户端要求服务器做出特定的行为</td><td>Expect: 100-continue</td></tr><tr><td>From</td><td>发起此请求的用户的邮件地址</td><td>From: <a href="mailto:user@example.com">user@example.com</a></td></tr><tr><td>Host</td><td>服务器的域名 (用于虚拟主机)，以及服务器所监听的传输控制协议端口号。如果所请求的端口是对应的服务的标准端口，则端口号可被省略。</td><td>Host: <span class="exturl" data-url="aHR0cDovL2VuLndpa2lwZWRpYS5vcmcv">en.wikipedia.org:80open in new window</span></td></tr><tr><td>If-Match</td><td>仅当客户端提供的实体与服务器上对应的实体相匹配时，才进行对应的操作。主要作用时，用作像 PUT 这样的方法中，仅当从用户上次更新某个资源以来，该资源未被修改的情况下，才更新该资源。</td><td>If-Match: “737060cd8c284d8af7ad3082f209582d”</td></tr><tr><td>If-Modified-Since</td><td>允许在对应的内容未被修改的情况下返回 304 未修改（ 304 Not Modified ）</td><td>If-Modified-Since: Sat, 29 Oct 1994 19:43:31 GMT</td></tr><tr><td>If-None-Match</td><td>允许在对应的内容未被修改的情况下返回 304 未修改（ 304 Not Modified ）</td><td>If-None-Match: “737060cd8c284d8af7ad3082f209582d”</td></tr><tr><td>If-Range</td><td>如果该实体未被修改过，则向我发送我所缺少的那一个或多个部分；否则，发送整个新的实体</td><td>If-Range: “737060cd8c284d8af7ad3082f209582d”</td></tr><tr><td>If-Unmodified-Since</td><td>仅当该实体自某个特定时间已来未被修改的情况下，才发送回应。</td><td>If-Unmodified-Since: Sat, 29 Oct 1994 19:43:31 GMT</td></tr><tr><td>Max-Forwards</td><td>限制该消息可被代理及网关转发的次数。</td><td>Max-Forwards: 10</td></tr><tr><td>Origin</td><td>发起一个针对 跨来源资源共享 的请求。</td><td>Origin: <span class="exturl" data-url="aHR0cDovL3d3dy5leGFtcGxlLXNvY2lhbC1uZXR3b3JrLmNvbS8=">http://www.example-social-network.comopen in new window</span></td></tr><tr><td>Pragma</td><td>与具体的实现相关，这些字段可能在请求 / 回应链中的任何时候产生多种效果。</td><td>Pragma: no-cache</td></tr><tr><td>Proxy-Authorization</td><td>用来向代理进行认证的认证信息。</td><td>Proxy-Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==</td></tr><tr><td>Range</td><td>仅请求某个实体的一部分。字节偏移以 0 开始。参见字节服务。</td><td>Range: bytes=500-999</td></tr><tr><td>Referer</td><td>表示浏览器所访问的前一个页面，正是那个页面上的某个链接将浏览器带到了当前所请求的这个页面。</td><td>Referer: <span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTWFpbl9QYWdl">http://en.wikipedia.org/wiki/Main_Pageopen in new window</span></td></tr><tr><td>TE</td><td>浏览器预期接受的传输编码方式：可使用回应协议头 Transfer-Encoding 字段中的值；</td><td>TE: trailers, deflate</td></tr><tr><td>Upgrade</td><td>要求服务器升级到另一个协议。</td><td>Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11</td></tr><tr><td>User-Agent</td><td>浏览器的浏览器身份标识字符串</td><td>User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:12.0) Gecko/20100101 Firefox/21.0</td></tr><tr><td>Via</td><td>向服务器告知，这个请求是由哪些代理发出的。</td><td>Via: 1.0 fred, 1.1 <a href="http://example.com/">example.comopen in new window</a><br><br>(Apache/1.1)</td></tr><tr><td>Warning</td><td>一个一般性的警告，告知，在实体内容体中可能存在错误。</td><td>Warning: 199 Miscellaneous warning</td></tr></tbody></table><h2 id="http-和-https-的区别"><a class="anchor" href="#http-和-https-的区别">#</a> HTTP 和 HTTPS 的区别</h2><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/20240525210528.png" alt="image.png"></p><ul><li><strong>端口号</strong>：HTTP 默认是 80，HTTPS 默认是 443。</li><li><strong>URL 前缀</strong>：HTTP 的 URL 前缀是 <code>http://</code> ，HTTPS 的 URL 前缀是 <code>https://</code> 。</li><li><strong>安全性、资源消耗</strong>：<ul><li>HTTP 协议运行在 TCP 之上，所有传输的内容都是<font color="red">明文</font>，客户端和服务器端都无法验证对方的身份。</li><li>HTTPS 是运行在 SSL/TLS 之上的 HTTP 协议，SSL/TLS 运行在 TCP 之上，所有传输的内容都经过<font color="red">加密</font>，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。</li><li>所以说，<font color="red">HTTP 安全性没有 HTTPS 高，但是 HTTPS 比 HTTP 耗费更多服务器资源</font>。</li></ul></li><li><strong>SEO（搜索引擎优化）</strong>：搜索引擎通常会更青睐使用 HTTPS 协议的网站，因为 HTTPS 能够提供更高的安全性和用户隐私保护。<font color="red">使用 HTTPS 协议的网站在搜索结果中可能会被优先显示</font>，从而对 SEO 产生影响。</li></ul><p>关于 HTTP 和 HTTPS 更详细的对比总结，可以看这篇文章：<a href="/cs-basics/network/http-vs-https.html">HTTP vs HTTPS（应用层）</a> 。</p><h2 id="http-10-和-11-的区别"><a class="anchor" href="#http-10-和-11-的区别">#</a> HTTP 1.0 和 1.1 的区别</h2><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/20240525211528.png" alt="image.png"></p><ul><li><strong>连接方式</strong> : HTTP/1.0 为短连接，HTTP/1.1 支持长连接。HTTP 协议的长连接和短连接，<font color="red">实质上是 TCP 协议的长连接和短连接</font>。</li><li><strong>状态响应码</strong> : <font color="red">HTTP/1.1 中新加入了大量的状态码</font>，光是错误响应状态码就新增了 24 种。比如说， <code>100 (Continue)</code> —— 在请求大资源前的预热请求， <code>206 (Partial Content)</code> —— 范围请求的标识码， <code>409 (Conflict)</code> —— 请求与当前资源的规定冲突， <code>410 (Gone)</code> —— 资源已被永久转移，而且没有任何已知的转发地址。</li><li><strong>缓存机制</strong>：在 HTTP/1.0 中主要使用 Header 里的 If-Modified-Since,Expires 来做为缓存判断的标准，<font color="red">HTTP/1.1 则引入了更多的缓存控制策略</font>，例如 Entity tag，If-Unmodified-Since, If-Match, If-None-Match 等更多可供选择的缓存头来控制缓存策略。</li><li><strong>带宽优化</strong>：HTTP/1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，<font color="red">HTTP/1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分</font>，即返回码是 206（Partial Content），这样就方便了开发者自由的选择以<font color="red">便于充分利用带宽和连接</font>。</li><li><strong>Host Header 处理</strong> : <font color="red">HTTP/1.1 引入了 Host Header 字段，允许在同一 IP 地址上托管多个域名，从而支持虚拟主机的功能</font>。而 HTTP/1.0 没有 Host Header 字段，无法实现虚拟主机。</li></ul><p>关于 HTTP/1.0 和 HTTP/1.1 更详细的对比总结，可以看我写的这篇文章：<a href="/cs-basics/network/http1.0-vs-http1.1.html">HTTP/1.0 vs HTTP/1.1（应用层）</a> 。</p><h2 id="http-11-和-20-的区别"><a class="anchor" href="#http-11-和-20-的区别">#</a> HTTP 1.1 和 2.0 的区别</h2><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/20240525213149.png" alt="image.png"></p><ul><li><strong>多路复用（Multiplexing）</strong>：<strong><font color="red">HTTP/2.0 在同一连接上可以同时传输多个请求和响应，互不干扰</font></strong>（可以看作是 HTTP/1.1 中长链接的升级版本）。HTTP/1.1 则使用串行方式，每个请求和响应都需要独立的连接，而浏览器为了控制资源会有 6-8 个 TCP 连接都限制。这使得 <font color="red">HTTP/2.0 在处理多个请求时更加高效</font>，减少了网络延迟和提高了性能。</li><li><strong>二进制帧（Binary Frames）</strong>：<font color="red">HTTP/2.0 使用二进制帧进行数据传输</font>，而 HTTP/1.1 则使用文本格式的报文。二进制帧<font color="red">更加紧凑和高效</font>，减少了传输的数据量和带宽消耗。</li><li><strong>头部压缩（Header Compression）</strong>：HTTP/1.1 支持 <code>Body</code> 压缩， <code>Header</code> 不支持压缩。<font color="red">HTTP/2.0 支持对 <code>Header</code> 压缩</font>，使用了专门为 <code>Header</code> 压缩而设计的 HPACK 算法，减少了网络开销。</li><li><strong>服务器推送（Server Push）</strong>：<font color="red">HTTP/2.0 支持服务器推送，可以在客户端请求一个资源时，将其他相关资源一并推送给客户端，从而减少了客户端的请求次数和延迟</font>。而 HTTP/1.1 需要客户端自己发送请求来获取相关资源。</li></ul><p>HTTP/2.0 多路复用效果图（图源： <span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNsb3VkZmxhcmUuY29tL2h0dHAtMi1mb3Itd2ViLWRldmVsb3BlcnMv">HTTP/2 For Web Developers</span>）：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/20240525213801.png" alt="image.png"></p><p>可以看到，HTTP/2.0 的多路复用使得<strong>不同的请求可以共用同一个 TCP 连接</strong>，避免建立多个连接带来不必要的额外开销，<font color="red">而 HTTP/1.1 中的每个请求都会建立一个单独的连接</font>。</p><h2 id="http-20-和-30-的区别"><a class="anchor" href="#http-20-和-30-的区别">#</a> HTTP 2.0 和 3.0 的区别</h2><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/20240525214041.png" alt="image.png"></p><ul><li><strong>传输协议</strong>：HTTP/2.0 是基于 TCP 协议实现的，<font color="red">HTTP/3.0 新增了 QUIC（Quick UDP Internet Connections） 协议来实现可靠的传输</font>，提供与 TLS/SSL 相当的安全性，具有较低的连接和传输延迟。你<font color="red">可以将 QUIC 看作是 UDP 的升级版本</font>，在其基础上新增了很多功能比如<font color="red">加密、重传</font>等等。HTTP/3.0 之前名为 HTTP-over-QUIC，从这个名字中我们也可以发现，HTTP/3 最大的改造就是使用了 QUIC。</li><li><strong>连接建立</strong>：HTTP/2.0 需要经过经典的 TCP 三次握手过程（由于安全的 HTTPS 连接建立还需要 TLS 握手，共需要大约 3 个 RTT）。由于 QUIC 协议的特性（TLS 1.3，TLS 1.3 除了支持 1 个 RTT 的握手，还支持 0 个 RTT 的握手）<font color="red">连接建立仅需 0-RTT 或者 1-RTT</font>。这意味着 <font color="red">QUIC 在最佳情况下不需要任何的额外往返时间就可以建立新连接</font>。</li><li><strong>队头阻塞</strong>：HTTP/2.0 多请求复用一个 TCP 连接，一旦发生丢包，就会阻塞住所有的 HTTP 请求。由于 QUIC 协议的特性，<font color="red">HTTP/3.0 在一定程度上解决了队头阻塞（Head-of-Line blocking, 简写：HOL blocking）问题</font>，一个连接建立多个不同的数据流，这些数据流之间独立互不影响，某个数据流发生丢包了，其数据流不受影响（本质上是<font color="red">多路复用 + 轮询</font>）。</li><li><strong>错误恢复</strong>：HTTP/3.0 具有更好的错误恢复机制，<font color="red">当出现丢包、延迟等网络问题时，可以更快地进行恢复和重传</font>。而 HTTP/2.0 则需要依赖于 TCP 的错误恢复机制。</li><li><strong>安全性</strong>：HTTP/2.0 和 HTTP/3.0 在安全性上都有较高的要求，支持加密通信，但在实现上有所不同。<font color="red">HTTP/2.0 使用 TLS 协议进行加密</font>，而 <font color="red">HTTP/3.0 基于 QUIC 协议</font>，包含了内置的加密和身份验证机制，可以提供更强的安全性。</li></ul><p>HTTP/1.0、HTTP/2.0 和 HTTP/3.0 的协议栈比较：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/20240525214125.png" alt="image.png"></p><p>关于 HTTP/1.0 -&gt; HTTP/3.0 更详细的演进介绍，推荐阅读<span class="exturl" data-url="aHR0cHM6Ly9kYnd1LnRlY2gvcG9zdHMvaHR0cF9ldm9sdXRpb24v"> HTTP1 到 HTTP3 的工程优化</span>。</p><h2 id="http-如何保存用户状态"><a class="anchor" href="#http-如何保存用户状态">#</a> HTTP 如何保存用户状态</h2><p>HTTP 是一种不保存状态，即<font color="red">无状态（stateless）协议</font>。也就是说 HTTP 协议自身不对请求和响应之间的通信状态进行保存。那么我们如何保存用户状态呢？</p><p><strong>Session 机制</strong>的存在就是为了解决这个问题，Session 的主要作用就是<font color="red">作为用户标识，在服务端记录用户的状态</font>。典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后，就可以标识这个用户并且跟踪这个用户了。一般情况下，服务器会在一定时间内保存这个 Session，过了时间限制，就会销毁这个 Session。</p><p>在服务端保存 Session 的方法很多，最常用的就是<font color="red">内存数据库</font>(比如是使用内存数据库 redis 保存)。既然 Session 存放在服务器端，那么我们如何实现 Session 跟踪呢？大部分情况下，我们都是通过在 Cookie 中附加一个 Session ID 来方式来跟踪。</p><p>Cookie 被禁用怎么办？最常用的就是利用 URL 重写把 Session ID 直接附加在 URL 路径的后面。</p><h2 id="cookie-和-session-的区别"><a class="anchor" href="#cookie-和-session-的区别">#</a> Cookie 和 Session 的区别</h2><p>Cookie 和 Session 对比：</p><ul><li><strong>Cookie</strong> 是存储在<font color="red">客户端（浏览器）</font>上的小型文本文件。它包含了一些信息，比如你的登录状态、偏好设置等，这些信息可以被发送回服务器，以便服务器识别你。</li><li><strong>Session</strong> 是<font color="red">服务器端</font>用来存储用户状态信息的一种机制。当用户登录网站时，服务器会创建一个 session，并生成一个唯一的 session ID。这个 session ID 会通过 cookie 发送给用户的浏览器，浏览器在每次请求时都会发送这个 session ID 给服务器。这样，服务器就可以通过 session ID 找到对应的 session，并获取用户的登录状态和其它信息。</li></ul><p>简而言之，<strong>cookie 是客户端（用户浏览器）用来存储 session 信息的一种方式，而 session 是服务器用来跟踪用户状态的一种机制</strong>。cookie 通常存储 session ID，而 session 存储了用户的详细信息。两者一起工作，使得用户在浏览网站时能够有一个连续的体验。</p><h2 id="uri-和-url-的区别"><a class="anchor" href="#uri-和-url-的区别">#</a> URI 和 URL 的区别</h2><ul><li><strong>URI(Uniform Resource Identifier)</strong> 是统一资源<font color="red">标志符</font>，可以唯一标识一个资源。</li><li><strong>URL(Uniform Resource Locator)</strong> 是统一资源<font color="red">定位符</font>，可以提供该资源的路径。</li></ul><p>URI 的作用像身份证号一样，URL 的作用更像家庭住址一样。<strong>URL 是一种具体的 URI，它不仅唯一标识资源，而且还提供了定位该资源的信息</strong>。</p><h2 id="get-和-post-的区别"><a class="anchor" href="#get-和-post-的区别">#</a> GET 和 POST 的区别</h2><p>这个问题在知乎上被讨论的挺火热的，地址：<span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzI4NTg2Nzkx">https://www.zhihu.com/question/28586791</span> 。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/20240525220000.png" alt="image.png"></p><p>GET 和 POST 是 HTTP 协议中两种常用的请求方法，它们在不同的场景和目的下有不同的特点和用法。一般来说，可以从以下几个方面来区分二者（重点搞清两者在语义上的区别即可）：</p><ul><li><strong>语义（主要区别）</strong>：<ul><li>**GET 通常用于获取或查询资源</li><li><strong>POST 通常用于创建或修改资源</strong></li></ul></li><li><strong>幂等</strong>：<ul><li>GET 请求是幂等的，即多次重复执行不会改变资源的状态</li><li>POST 请求是不幂等的，即每次执行可能会产生不同的结果或影响资源的状态。</li></ul></li><li><strong>格式</strong>：<ul><li>GET 请求的参数通常放在 URL 中，形成查询字符串（querystring），此外，<font color="red">GET 请求的 URL 长度受到浏览器和服务器的限制</font>。</li><li><font color="red">POST 请求的参数通常放在请求体（body）中，可以有多种编码格式</font>，如 application/x-www-form-urlencoded、multipart/form-data、application/json 等。 <font color="red">POST 请求的 body 大小则没有明确的限制</font>。</li></ul></li><li><strong>缓存</strong>：<ul><li>由于 GET 请求是幂等的，它可以被浏览器或其他中间节点（如代理、网关）缓存起来，以提高性能和效率。</li><li><font color="red">POST 请求则不适合被缓存，因为它可能有副作用，每次执行可能需要实时的响应</font>。</li></ul></li><li><strong>安全性</strong>：<ul><li>GET 请求和 POST 请求如果使用 HTTP 协议的话，那都不安全，因为 HTTP 协议本身是明文传输的，<font color="red">二者都必须使用 HTTPS 协议来加密传输数据</font>。</li><li>另外，<font color="red">GET 请求相比 POST 请求更容易泄露敏感数据，因为 GET 请求的参数通常放在 URL 中</font>。</li></ul></li></ul><p>再次提示，重点搞清两者在语义上的区别即可，实际使用过程中，也是通过语义来区分使用 GET 还是 POST。不过，<font color="red">也有一些项目所有的请求都用 POST</font>，这个并不是固定的，项目组达成共识即可。</p><h1 id="websocket"><a class="anchor" href="#websocket">#</a> WebSocket</h1><h2 id="websocket-是什么"><a class="anchor" href="#websocket-是什么">#</a> WebSocket 是什么</h2><p>关于 WebSocket 的简介见<a href="#Websocket%EF%BC%9A%E5%85%A8%E5%8F%8C%E5%B7%A5%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE"> Websocket：全双工通信协议</a>。</p><h2 id="websocket-和-http-的区别"><a class="anchor" href="#websocket-和-http-的区别">#</a> WebSocket 和 HTTP 的区别</h2><p><font color="red">WebSocket 和 HTTP 两者都是基于 TCP 的应用层协议，都可以在网络中传输数据</font>。</p><p>下面是二者的主要区别：</p><ul><li><strong>全双工通信</strong>：WebSocket 是一种<font color="red">双向实时</font>通信协议，而 HTTP 是一种单向通信协议，只能由客户端发起，服务器无法主动通知客户端。</li><li><strong>协议前缀</strong>：WebSocket 使用 <font color="red">ws:// 或 wss://</font>（使用 SSL/TLS 加密后的协议，类似于 HTTP 和 HTTPS 的关系） 作为协议前缀，HTTP 使用 http:// 或 https:// 作为协议前缀。</li><li><strong>支持拓展</strong>：WebSocket 可以支持扩展，用户可以扩展协议，实现部分自定义的子协议，如支持压缩、加密等。</li><li><strong>数据轻量</strong>：<font color="red">WebSocket 通信数据格式比较轻量，用于协议控制的数据包头部相对较小，网络开销小</font>。而 HTTP 通信每次都要携带完整的头部，网络开销较大（HTTP/2.0 使用二进制帧进行数据传输，还支持头部压缩，减少了网络开销）。</li></ul><h2 id="websocket-工作过程"><a class="anchor" href="#websocket-工作过程">#</a> WebSocket 工作过程</h2><p>WebSocket 的工作过程可以分为以下几个步骤：</p><ol><li>客户端向服务器发送一个 HTTP 请求，请求头中包含 <code>Upgrade: websocket</code> 和 <code>Sec-WebSocket-Key</code> 等字段，表示<font color="red">要求升级协议为 WebSocket</font>；</li><li>服务器收到这个请求后，会进行升级协议的操作，如果支持 WebSocket，它将回复一个 HTTP 101 状态码，响应头中包含 ， <code>Connection: Upgrade</code> 和 <code>Sec-WebSocket-Accept: xxx</code> 等字段、表示<font color="red">成功升级</font>到 WebSocket 协议。</li><li>客户端和服务器之间<font color="red">建立了一个 WebSocket 连接</font>，可以进行双向的数据传输。数据以<font color="red">帧（frames）</font>的形式进行传送，WebSocket 的每条消息可能会被切分成多个数据帧（最小单位）。发送端会将消息切割成多个帧发送给接收端，接收端接收消息帧，并将关联的帧重新组装成完整的消息。</li><li>客户端或服务器可以<font color="red">主动发送一个关闭帧</font>，表示要断开连接。另一方收到后，也会回复一个关闭帧，然后<font color="red">双方关闭 TCP 连接</font>。</li></ol><p>另外，建立 WebSocket 连接之后，通过<font color="red">心跳机制</font>来保持 WebSocket 连接的稳定性和活跃性。</p><h2 id="websocket-和-sse-的区别"><a class="anchor" href="#websocket-和-sse-的区别">#</a> WebSocket 和 SSE 的区别</h2><p>摘自<span class="exturl" data-url="aHR0cHM6Ly9qYXZhZ3VpZGUuY24vc3lzdGVtLWRlc2lnbi93ZWItcmVhbC10aW1lLW1lc3NhZ2UtcHVzaC5odG1s"> Web 实时消息推送详解</span>。</p><p>SSE 与 WebSocket 作用相似，<font color="red">二者都可以建立服务端与浏览器之间的通信，实现服务端向客户端推送消息</font>，但还是有些许不同：</p><ul><li>SSE 是<font color="red">基于 HTTP 协议</font>的，它们不需要特殊的协议或服务器实现即可工作；WebSocket 需单独服务器来处理协议。</li><li>SSE 单向通信，<strong><font color="red">只能由服务端向客户端单向通信</font></strong>；WebSocket 全双工通信，即通信的双方可以同时发送和接受信息。</li><li>SSE 实现简单<font color="red">开发成本低</font>，无需引入其他组件；WebSocket 传输数据需做二次解析，开发门槛高一些。</li><li>SSE <font color="red">默认支持断线重连</font>；WebSocket 则需要自己实现。</li><li>SSE <font color="red">只能传送文本消息</font>，二进制数据需要经过编码后传送；WebSocket 默认支持传送二进制数据。</li></ul><p>SSE 与 WebSocket 该如何选择？</p><p>SSE 好像一直不被大家所熟知，一部分原因是出现了 WebSocket，这个提供了更丰富的协议来执行双向、全双工通信。对于游戏、即时通信以及需要双向近乎实时更新的场景，拥有双向通道更具吸引力。</p><p>但是，<font color="red">在某些情况下，不需要从客户端发送数据，而是只需要一些服务器操作的更新</font>。比如：站内信、未读消息数、状态更新、股票行情、监控数量等场景，SEE 不管是从实现的难易和成本上都更加有优势。此外，SSE 具有 WebSocket 在设计上缺乏的多种功能，例如：自动重新连接、事件 ID 和发送任意事件的能力。</p><h1 id="ping"><a class="anchor" href="#ping">#</a> PING</h1><h2 id="ping-命令的作用"><a class="anchor" href="#ping-命令的作用">#</a> PING 命令的作用</h2><p>PING 命令是一种常用的<font color="red">网络诊断工具</font>，经常<strong>用来测试网络中主机之间的连通性和网络延迟</strong>。</p><p>这里简单举一个例子，我们来 PING 一下百度。</p><pre><code class="language-PlainText"># 发送4个PING请求数据包到 www.baidu.com
❯ ping -c 4 www.baidu.com

PING www.a.shifen.com (14.119.104.189): 56 data bytes
64 bytes from 14.119.104.189: icmp_seq=0 ttl=54 time=27.867 ms
64 bytes from 14.119.104.189: icmp_seq=1 ttl=54 time=28.732 ms
64 bytes from 14.119.104.189: icmp_seq=2 ttl=54 time=27.571 ms
64 bytes from 14.119.104.189: icmp_seq=3 ttl=54 time=27.581 ms

--- www.a.shifen.com ping statistics ---
4 packets transmitted, 4 packets received, 0.0% packet loss
round-trip min/avg/max/stddev = 27.571/27.938/28.732/0.474 ms
</code></pre><p>PING 命令的输出结果通常包括以下几部分信息：</p><ol><li><strong>目标主机的域名或 IP 地址</strong>：输出结果的第一行。</li><li><strong>ICMP Echo Request（请求报文）信息</strong>：序列号、TTL（Time to Live）值。</li><li><strong>往返时间（RTT，Round-Trip Time）</strong>：从发送 ICMP Echo Request（请求报文）到接收到 ICMP Echo Reply（响应报文）的总时间，用来衡量网络连接的延迟。</li><li><strong>统计结果（Statistics）</strong>：包括发送的 ICMP 请求数据包数量、接收到的 ICMP 响应数据包数量、丢包率、往返时间（RTT）的最小、平均、最大和标准偏差值。</li></ol><p>如果 PING 对应的目标主机无法得到正确的响应，则表明这两个主机之间的连通性存在问题（有些主机或网络管理员可能禁用了对 ICMP 请求的回复，这样也会导致无法得到正确的响应）。如果往返时间（RTT）过高，则表明网络延迟过高。</p><h2 id="ping-命令的工作原理"><a class="anchor" href="#ping-命令的工作原理">#</a> PING 命令的工作原理</h2><p>PING 基于网络层的 <strong>ICMP（Internet Control Message Protocol，互联网控制报文协议）</strong>，其主要原理就是<font color="red">通过在网络上发送和接收 ICMP 报文实现的</font>。</p><p>ICMP 报文中包含了类型字段，用于标识 ICMP 报文类型。ICMP 报文的类型有很多种，但大致可以分为两类：</p><ul><li><strong>查询报文类型</strong>：向目标主机发送请求并期望得到响应。</li><li><strong>差错报文类型</strong>：向源主机发送错误信息，用于报告网络中的错误情况。</li></ul><p>PING 用到的 ICMP Echo Request（类型为 8 ） 和 ICMP Echo Reply（类型为 0） 属于查询报文类型 。</p><ul><li>PING 命令会向目标主机发送 ICMP Echo Request。</li><li>如果两个主机的连通性正常，目标主机会返回一个对应的 ICMP Echo Reply。</li></ul><h1 id="dns"><a class="anchor" href="#dns">#</a> DNS</h1><h2 id="dns-作用"><a class="anchor" href="#dns-作用">#</a> DNS 作用</h2><p><code>DNS（Domain Name System）</code> 域名系统，是当用户使用浏览器访问网址之后，使用的第一个重要协议。DNS 要解决的是<strong>域名和 IP 地址的映射问题</strong>。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/20240524171841.png" alt="image.png"></p><p>在实际使用中，有一些情况下，浏览器是可以不必动用 DNS 就可以获知域名和 IP 地址的映射的。<font color="red">在一台电脑上，可能存在浏览器 DNS 缓存，操作系统 DNS 缓存，路由器 DNS 缓存。如果以上缓存都查询不到，那么 DNS 就闪亮登场了</font>。例如，浏览器在本地会维护一个 <code>hosts</code> 列表，一般来说浏览器要先查看要访问的域名是否在 <code>hosts</code> 列表中，如果有的话，直接提取对应的 IP 地址记录，就好了。如果本地 <code>hosts</code> 列表内没有 域名 - IP 对应记录的话，那么 DNS 就闪亮登场了。</p><p>目前 DNS 的设计采用的是分布式、层次数据库结构，<strong>DNS 是应用层协议，基于 UDP 协议之上，端口为 53</strong> 。</p><h2 id="dns-服务器"><a class="anchor" href="#dns-服务器">#</a> DNS 服务器</h2><p>DNS 服务器自底向上可以依次分为以下四个层级（所有 DNS 服务器都属于以下四个类别之一），<font color="red">面对一个 DNS 请求时进行依次查询</font>:</p><ul><li><font color="cornflowerblue">本地 DNS 服务器</font>。每个 ISP（互联网服务提供商）都有一个自己的本地 DNS 服务器。当主机发出 DNS 请求时，该请求被发往本地 DNS 服务器，它起着<font color="red">代理</font>的作用，并将该请求<font color="red">转发</font>到 DNS 层次结构中。严格说来，不属于 DNS 层级结构。</li><li><font color="cornflowerblue">根 DNS 服务器</font>。根 DNS 服务器<font color="red">提供 TLD 服务器的 IP 地址</font>。目前世界上只有 <strong>13 组</strong>根服务器，我国境内目前仍没有根服务器。</li><li><font color="cornflowerblue">顶级域 DNS 服务器（TLD 服务器）</font>。顶级域是指<font color="red">域名的后缀</font>，如 <code>com</code> 、 <code>org</code> 、 <code>net</code> 和 <code>edu</code> 等。国家也有自己的顶级域，如 <code>uk</code> 、 <code>fr</code> 和 <code>ca</code> 。TLD 服务器<font color="red">提供了权威 DNS 服务器的 IP 地址</font>。</li><li><font color="cornflowerblue">权威 DNS 服务器</font>。在因特网上具有公共可访问主机的每个组织机构必须提供<font color="red">公共可访问的 DNS 记录</font>，这些记录将这些主机的名字映射为 IP 地址。</li></ul><p>世界上并不是只有 13 台根服务器，这是很多人普遍的误解，网上很多文章也是这么写的。实际上，现在根服务器数量远远超过这个数量。最初确实是为 DNS 根服务器分配了 13 个 IP 地址，每个 IP 地址对应一个不同的根 DNS 服务器。然而，由于互联网的快速发展和增长，这个原始的架构变得不太适应当前的需求。为了提高 DNS 的可靠性、安全性和性能，<strong>目前 DNS 根服务器的这 13 个 IP 地址中的每一个，都有多个服务器</strong>，截止到 2023 年底，所有根服务器之和达到了 600 多台，未来还会继续增加。</p><h2 id="dns-解析过程"><a class="anchor" href="#dns-解析过程">#</a> DNS 解析过程</h2><p>DNS 的查询解析过程分为两种模式：</p><ul><li><strong>迭代</strong></li><li><strong>递归</strong></li></ul><h3 id="dns-迭代解析过程"><a class="anchor" href="#dns-迭代解析过程">#</a> DNS 迭代解析过程</h3><p>以下图为例，介绍 DNS 的查询解析过程。<font color="red">从请求主机到本地 DNS 服务器的查询是递归的，其余的查询时迭代的</font>。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/20240524172728.png" alt="image.png"></p><p>该过程如下，主机 <code>cis.poly.edu</code> 想知道 <code>gaia.cs.umass.edu</code> 的 IP 地址。假设主机 <code>cis.poly.edu</code> 的本地 DNS 服务器为 <code>dns.poly.edu</code> ，并且 <code>gaia.cs.umass.edu</code> 的权威 DNS 服务器为 <code>dns.cs.umass.edu</code> 。</p><ol><li>首先，<font color="red">主机</font> <code>cis.poly.edu</code> 向<font color="red">本地 DNS 服务器</font> <code>dns.poly.edu</code> 发送一个 DNS 请求，该查询报文包含被转换的域名 <code>gaia.cs.umass.edu</code> 。</li><li>本地 DNS 服务器 <code>dns.poly.edu</code> 检查<font color="red">本机缓存</font>，发现并无记录，也不知道 <code>gaia.cs.umass.edu</code> 的 IP 地址该在何处，不得不向<font color="red">根 DNS 服务器</font>发送请求。</li><li>根 DNS 服务器注意到请求报文中含有 <code>edu</code> <font color="red">顶级域</font>，因此告诉本地 DNS，你可以向 <code>edu</code> 的 <font color="red">TLD DNS 服务器</font>发送请求，因为目标域名的 IP 地址很可能在那里。</li><li>本地 DNS 获取到了 <code>edu</code> 的 TLD DNS 服务器地址，向其发送请求，询问 <code>gaia.cs.umass.edu</code> 的 IP 地址。</li><li><code>edu</code> 的 TLD DNS 服务器仍不清楚请求域名的 IP 地址，但是它注意到该域名有 <code>umass.edu</code> <font color="red">前缀</font>，因此返回告知本地 DNS， <code>umass.edu</code> 的<font color="red">权威 DNS 服务器</font>可能记录了目标域名的 IP 地址。</li><li>这一次，本地 DNS 服务器将请求发送给权威 DNS 服务器 <code>dns.cs.umass.edu</code> 。</li><li>终于，<font color="red">由于 <code>gaia.cs.umass.edu</code> 向权威 DNS 服务器备案过，在这里有它的 IP 地址记录</font>，权威 DNS 成功地将 IP 地址返回给本地 DNS。</li><li>最后，本地 DNS 获取到了目标域名的 IP 地址，将其返回给请求主机。</li></ol><h3 id="dns-递归解析过程"><a class="anchor" href="#dns-递归解析过程">#</a> DNS 递归解析过程</h3><p>除了迭代式查询，还有一种<font color="red">递归式查询</font>如下图，具体过程和上述类似，只是顺序有所不同。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/20240524174352.png" alt="image.png"></p><hr><p>另外，DNS 的缓存位于本地 DNS 服务器。由于全世界的根 DNS 服务器甚少，只有 600 多台，分为 13 组，且顶级域的数量也在一个可数的范围内，因此本地 DNS 通常已经缓存了很多 TLD DNS 服务器，所以在实际查找过程中，无需访问根服务器。<strong>根 DNS 服务器通常是被跳过的，不请求的</strong>。这样可以提高 DNS 查询的效率和速度，减少对根 DNS 服务器和 TLD 服务器的负担。</p><h2 id="dns-报文格式"><a class="anchor" href="#dns-报文格式">#</a> DNS 报文格式</h2><p>DNS 的报文格式如下图所示：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/20240524174724.png" alt="image.png"></p><p>DNS 报文分为<font color="cornflowerblue">查询报文</font>和<font color="cornflowerblue">回答报文</font>，两种形式的报文结构相同。</p><ul><li><strong>标识符</strong>。16 比特，用于标识该查询。这个标识符会被复制到对查询的回答报文中，以便让客户用它来<font color="red">匹配</font>发送的请求和接收到回答。</li><li><strong>标志</strong>。1 比特的<font color="red">” 查询 / 回答 “标识位</font>， <code>0</code> 表示查询报文， <code>1</code> 表示回答报文；1 比特的<font color="red">” 权威的 “标志位</font>（当某 DNS 服务器是所请求名字的权威 DNS 服务器时，且是回答报文，使用” 权威的 “标志）；1 比特的<font color="red">” 希望递归 “标志位</font>，显式地要求执行递归查询；1 比特的<font color="red">” 递归可用 “标志位</font>，用于回答报文中，表示 DNS 服务器支持递归查询。</li><li><strong>问题数、回答 RR 数、权威 RR 数、附加 RR 数</strong>。分别指示了后面 <font color="red">4 类数据区域出现的数量</font>。</li><li><strong>问题区域</strong>。包含正在被查询的主机名字，以及正被询问的问题类型。</li><li><strong>回答区域</strong>。包含了对最初请求的名字的资源记录。<font color="red">在回答报文的回答区域中可以包含多条 RR，因此一个主机名能够有多个 IP 地址</font>。</li><li><strong>权威区域</strong>。包含了其他权威服务器的记录。</li><li><strong>附加区域</strong>。包含了其他有帮助的记录。</li></ul><h2 id="dns-资源记录rr"><a class="anchor" href="#dns-资源记录rr">#</a> DNS 资源记录（RR）</h2><p>DNS 服务器在响应查询时，需要查询自己的数据库，数据库中的条目被称为<font color="cornflowerblue">资源记录</font> <code>（Resource Record，RR）</code> 。RR 提供了主机名到 IP 地址的映射。RR 是一个包含了 <code>Name</code> , <code>Value</code> , <code>Type</code> , <code>TTL</code> 四个字段的四元组。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/20240524175439.png" alt="image.png"></p><p><code>TTL</code> 是该记录还能生存的时间，它决定了资源记录应当从缓存中删除的时间。</p><p><code>Name</code> 和 <code>Value</code> 字段的取值取决于 <code>Type</code> ：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/20240524175544.png" alt="image.png"></p><ul><li>如果 <code>Type=A</code> ，则 <code>Name</code> 是主机名信息， <code>Value</code> 是该主机名对应的 IP 地址。这样的 RR 记录了一条主机名到 IP 地址的映射。</li><li>如果 <code>Type=AAAA</code> （与 <code>A</code> 记录非常相似），唯一的区别是 A 记录使用的是 IPv4，而 <code>AAAA</code> 记录使用的是 IPv6。</li><li>如果 <code>Type=CNAME</code> (Canonical Name Record, 真实名称记录) ，则 <code>Value</code> 是别名为 <code>Name</code> 的主机对应的规范主机名。 <code>Value</code> 值才是规范主机名。 <code>CNAME</code> 记录将一个主机名映射到另一个主机名。 <code>CNAME</code> 记录用于为现有的 <code>A</code> 记录创建别名。下文有示例。</li><li>如果 <code>Type=NS</code> ，则 <code>Name</code> 是个域，而 <code>Value</code> 是个知道如何获得该域中主机 IP 地址的权威 DNS 服务器的主机名。通常这样的 RR 是由 TLD 服务器发布的。</li><li>如果 <code>Type=MX</code> ，则 <code>Value</code> 是个别名为 <code>Name</code> 的邮件服务器的规范主机名。既然有了 <code>MX</code> 记录，那么邮件服务器可以和其他服务器使用相同的别名。为了获得邮件服务器的规范主机名，需要请求 <code>MX</code> 记录；为了获得其他服务器的规范主机名，需要请求 <code>CNAME</code> 记录。</li></ul><p><strong><code>CNAME</code> 记录是将一个主机域名映射到另一个主机域名（别名），而非 IP 地址</strong>。假设有下述 DNS zone：</p><pre><code>NAME                    TYPE   VALUE
--------------------------------------------------
bar.example.com.        CNAME  foo.example.com.
foo.example.com.        A      192.0.2.23
</code></pre><p>当用户查询 <code>bar.example.com</code> 的时候，DNS Server 实际返回的是 <code>foo.example.com</code> 的 IP 地址。</p><h2 id="dns-劫持"><a class="anchor" href="#dns-劫持">#</a> DNS 劫持</h2><p>DNS 劫持是一种网络攻击，<strong>它通过修改 DNS 服务器的解析结果，使得用户访问的域名指向错误的 IP 地址</strong>，从而导致用户无法访问正常的网站，或者被引导到恶意的网站。DNS 劫持有时也被称为 <font color="red">DNS 重定向、DNS 欺骗或 DNS 污染</font>。DNS 劫持详细介绍可以参考：<span class="exturl" data-url="aHR0cHM6Ly9jbG91ZC50ZW5jZW50LmNvbS9kZXZlbG9wZXIvYXJ0aWNsZS8xMTk3NDc0">黑客技术？没你想象的那么难！——DNS 劫持篇</span>。</p><h2 id="参考"><a class="anchor" href="#参考">#</a> 参考</h2><ul><li>《图解 HTTP》</li><li>《计算机网络自顶向下方法》（第七版）</li><li>详解 HTTP/2.0 及 HTTPS 协议：<span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC83MDM0NjY4NjcyMjYyMjQyMzE4">https://juejin.cn/post/7034668672262242318open in new window</span></li><li>HTTP 请求头字段大全 | HTTP Request Headers：<span class="exturl" data-url="aHR0cHM6Ly93d3cuZmx5c25vdy5vcmcvdG9vbHMvdGFibGUvaHR0cC1yZXF1ZXN0LWhlYWRlcnMv">https://www.flysnow.org/tools/table/http-request-headers/open in new window</span></li><li>HTTP1、HTTP2、HTTP3：<span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC82ODU1NDcwMzU2NjU3MzA3NjYy">https://juejin.cn/post/6855470356657307662open in new window</span></li><li>如何看待 HTTP/3 ？ - 车小胖的回答 - 知乎: <span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzMwMjQxMjA1OS9hbnN3ZXIvNTMzMjIzNTMw">https://www.zhihu.com/question/302412059/answer/533223530open in new window</span></li><li>DNS 服务器类型：<span class="exturl" data-url="aHR0cHM6Ly93d3cuY2xvdWRmbGFyZS5jb20vemgtY24vbGVhcm5pbmcvZG5zL2Rucy1zZXJ2ZXItdHlwZXMv">https://www.cloudflare.com/zh-cn/learning/dns/dns-server-types/</span></li><li>DNS Message Resource Record Field Formats：<span class="exturl" data-url="aHR0cDovL3d3dy50Y3BpcGd1aWRlLmNvbS9mcmVlL3RfRE5TTWVzc2FnZVJlc291cmNlUmVjb3JkRmllbGRGb3JtYXRzLTIuaHRt">http://www.tcpipguide.com/free/t_DNSMessageResourceRecordFieldFormats-2.htm</span></li><li>Understanding Different Types of Record in DNS Server：<span class="exturl" data-url="aHR0cHM6Ly93d3cubXVzdGJlZ2Vlay5jb20vdW5kZXJzdGFuZGluZy1kaWZmZXJlbnQtdHlwZXMtb2YtcmVjb3JkLWluLWRucy1zZXJ2ZXIv">https://www.mustbegeek.com/understanding-different-types-of-record-in-dns-server/</span></li></ul><h1 id="tcp-与-udp"><a class="anchor" href="#tcp-与-udp">#</a> TCP 与 UDP</h1><h2 id="tcp-与-udp-的区别"><a class="anchor" href="#tcp-与-udp-的区别">#</a> TCP 与 UDP 的区别</h2><ol><li><strong>是否面向连接</strong>：<ul><li>TCP 提供<font color="red">面向连接</font>的服务，在传送数据之前必须先建立连接，数据传送结束后要释放连接。</li><li>UDP 在传送数据之前不需要先建立连接。</li></ul></li><li><strong>是否可靠传输</strong>：<ul><li>TCP 提供可靠的传输服务，TCP 在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有<font color="red">确认、窗口、重传、拥塞控制</font>机制。通过 TCP 连接传输的数据，<font color="red">无差错、不丢失、不重复、按序到达</font>。</li><li>远地主机在收到 UDP 报文后，不需要给出任何确认，并且不保证数据不丢失，不保证是否顺序到达。</li></ul></li><li><strong>是否有状态</strong>：这个和上面的 “是否可靠传输” 相对应。<ul><li>TCP 传输是有状态的，这个有状态说的是 <font color="red">TCP 会去记录自己发送消息的状态</font>，比如消息是否发送了、是否被接收了等等。为此 ，<font color="red">TCP 需要维持复杂的连接状态表</font>。</li><li>UDP 是无状态服务，简单来说就是不管发出去之后的事情了。</li></ul></li><li><strong>传输效率</strong>：由于使用 TCP 进行传输的时候多了连接、确认、重传等机制，所以 <font color="red">TCP 的传输效率要比 UDP 低很多</font>。</li><li><strong>传输形式</strong>：<ul><li><font color="red">TCP 是面向字节流的</font></li><li><font color="red">UDP 是面向数据报文段的</font></li></ul></li><li><strong>首部开销</strong>：TCP 首部开销（20 ～ 60 字节）比 UDP 首部开销（8 字节）要大。</li><li><strong>是否提供广播或多播服务</strong>：<ul><li><font color="red">TCP 只支持点对点通信</font></li><li>UDP 支持一对一、一对多、多对一、多对多</li></ul></li></ol><p>我把上面总结的内容通过表格形式展示出来了！确定不点个赞嘛？</p><table><thead><tr><th>对比内容</th><th>TCP</th><th>UDP</th></tr></thead><tbody><tr><td>是否面向连接</td><td>是</td><td>否</td></tr><tr><td>是否可靠</td><td>是</td><td>否</td></tr><tr><td>是否有状态</td><td>是</td><td>否</td></tr><tr><td>传输效率</td><td>较慢</td><td>较快</td></tr><tr><td>传输形式</td><td>字节流</td><td>数据报文段</td></tr><tr><td>首部开销</td><td>20 ～ 60 bytes</td><td>8 bytes</td></tr><tr><td>是否提供广播或多播服务</td><td>否</td><td>是</td></tr></tbody></table><h2 id="tcp-和-udp-选型"><a class="anchor" href="#tcp-和-udp-选型">#</a> TCP 和 UDP 选型</h2><ul><li><strong>TCP 用于对传输准确性要求特别高的场景</strong>。比如文件传输、发送和接收邮件、远程登录等等。</li><li><strong>UDP 一般用于实时通信</strong>。比如：语音、 视频、直播等等。这些场景对传输数据的准确性要求不是特别高，比如你看视频即使少个一两帧，实际给人的感觉区别也不大。</li></ul><h2 id="http-基于-tcp-还是-udp"><a class="anchor" href="#http-基于-tcp-还是-udp">#</a> HTTP 基于 TCP 还是 UDP？</h2><p><s><strong>HTTP 协议是基于 TCP 协议的</strong>，所以发送 HTTP 请求之前首先要建立 TCP 连接也就是要经历 3 次握手。</s></p><p>🐛 修正（参见 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1NuYWlsY2xpbWIvSmF2YUd1aWRlL2lzc3Vlcy8xOTE1">issue#1915</span>）：</p><p><strong>HTTP/3.0 之前是基于 TCP 协议的，而 HTTP/3.0 将弃用 TCP，改用基于 UDP 的 QUIC 协议</strong> 。</p><p><font color="red">此变化解决了 HTTP/2.0 中存在的队头阻塞问题</font>。队头阻塞是指在 HTTP/2.0 中，多个 HTTP 请求和响应共享一个 TCP 连接，如果其中一个请求或响应因为网络拥塞或丢包而被阻塞，那么后续的请求或响应也无法发送，导致整个连接的效率降低。这是由于 <font color="red">HTTP/2.0 在单个 TCP 连接上使用了多路复用</font>，受到 TCP 拥塞控制的影响，少量的丢包就可能导致整个 TCP 连接上的所有流被阻塞。</p><p>HTTP/3.0 在一定程度上解决了队头阻塞问题，一个连接建立多个不同的数据流，这些数据流之间独立互不影响，某个数据流发生丢包了，其数据流不受影响（本质上是<strong>多路复用 + 轮询</strong>）。</p><p>除了解决队头阻塞问题，<font color="red">HTTP/3.0 还可以减少握手过程的延迟</font>。在 HTTP/2.0 中，如果要建立一个安全的 HTTPS 连接，需要经过 TCP 三次握手和 TLS 握手：</p><ol><li>TCP 三次握手：客户端和服务器交换 SYN 和 ACK 包，建立一个 TCP 连接。这个过程需要 1.5 个 RTT（round-trip time），即一个数据包从发送到接收的时间。</li><li>TLS 握手：客户端和服务器交换密钥和证书，建立一个 TLS 加密层。这个过程需要至少 1 个 RTT（TLS 1.3）或者 2 个 RTT（TLS 1.2）。</li></ol><p>所以，HTTP/2.0 的连接建立就至少需要 2.5 个 RTT（TLS 1.3）或者 3.5 个 RTT（TLS 1.2）。<font color="red">而在 HTTP/3.0 中，使用的 QUIC 协议（TLS 1.3，TLS 1.3 除了支持 1 个 RTT 的握手，还支持 0 个 RTT 的握手）连接建立仅需 0-RTT 或者 1-RTT</font>。这意味着 QUIC 在最佳情况下不需要任何的额外往返时间就可以建立新连接。</p><p>相关证明可以参考下面这两个链接：</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3poL0hUVFAvMw==">https://zh.wikipedia.org/zh/HTTP/3</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvcmZjOTExNC8=">https://datatracker.ietf.org/doc/rfc9114/</span></li></ul><h2 id="使用-tcpudp-的协议有哪些"><a class="anchor" href="#使用-tcpudp-的协议有哪些">#</a> 使用 TCP/UDP 的协议有哪些？</h2><p>运行于 TCP 协议之上的协议：</p><ol><li><strong>HTTP 协议（HTTP/3.0 之前）</strong>：超文本传输协议（HTTP，HyperText Transfer Protocol) 是一种用于<font color="red">传输超文本和多媒体内容</font>的协议，主要是为 Web 浏览器与 Web 服务器之间的通信而设计的。当我们使用浏览器浏览网页的时候，我们网页就是通过 HTTP 请求进行加载的。</li><li><strong>HTTPS 协议</strong>：更安全的超文本传输协议 (HTTPS,Hypertext Transfer Protocol Secure)，<font color="red">身披 SSL 外衣</font>的 HTTP 协议</li><li><strong>FTP 协议</strong>：文件传输协议 FTP（File Transfer Protocol）是一种用于在计算机之间<font color="red">传输文件</font>的协议，可以屏蔽操作系统和文件存储方式。注意 ⚠️：FTP 是一种<font color="red">不安全</font>的协议，因为它在传输过程中不会对数据进行加密。建议在传输敏感数据时使用更安全的协议，如 SFTP。</li><li><strong>SMTP 协议</strong>：简单邮件传输协议（SMTP，Simple Mail Transfer Protocol）的缩写，是一种用于<font color="red">发送电子邮件</font>的协议。注意 ⚠️：SMTP 协议只负责邮件的发送，而不是接收。要从邮件服务器接收邮件，需要使用 POP3 或 IMAP 协议。</li><li><strong>POP3/IMAP 协议</strong>：两者都是负责<font color="red">接收电子邮件</font>的协议。IMAP 协议是比 POP3 更新的协议，它在功能和性能上都更加强大。IMAP 支持邮件搜索、标记、分类、归档等高级功能，而且可以在多个设备之间同步邮件状态。几乎所有现代电子邮件客户端和服务器都支持 IMAP。</li><li><strong>Telnet 协议</strong>：<font color="red">用于通过一个终端登陆到其他服务器</font>。Telnet 协议的最大缺点之一是所有数据（包括用户名和密码）均以<font color="red">明文</font>形式发送，这有潜在的安全风险。这就是为什么如今很少使用 Telnet，而是使用一种称为 SSH 的非常安全的网络传输协议的主要原因。</li><li><strong>SSH 协议</strong> : SSH（ Secure Shell）是目前较可靠，<font color="red">专为远程登录会话和其他网络服务提供安全性的协议</font>。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。SSH 建立在可靠的传输协议 TCP 之上。</li><li>……</li></ol><p>运行于 UDP 协议之上的协议：</p><ol><li><strong>HTTP 协议（HTTP/3.0 ）</strong>： HTTP/3.0 弃用 TCP，改用<font color="red">基于 UDP 的 QUIC 协议</font> 。</li><li><strong>DHCP 协议</strong>：动态主机配置协议，<font color="red">动态配置 IP 地址</font></li><li><strong>DNS</strong>：域名系统（DNS，Domain Name System）<font color="red">将人类可读的域名转换为机器可读的 IP 地址</font>。 我们可以将其理解为专为互联网设计的电话薄。实际上，<strong>DNS 同时支持 UDP 和 TCP 协议</strong>。</li><li>……</li></ol><h2 id="tcp-三次握手和四次挥手"><a class="anchor" href="#tcp-三次握手和四次挥手">#</a> TCP 三次握手和四次挥手</h2><blockquote><p>相关面试题：</p><ul><li>为什么要三次握手？为什么不是二次或者四次？</li><li>第 2 次握手传回了 ACK，为什么还要传回 SYN？</li><li>三次握手过程中可以携带数据吗？</li><li>三次握手过程中的半连接队列和全连接队列是什么？</li><li>为什么要四次挥手？</li><li>为什么不能把服务器发送的 ACK 和 FIN 合并起来，变成三次挥手？</li><li>如果第二次挥手时服务器的 ACK 没有送达客户端，会怎样？</li><li>为什么第四次挥手客户端需要等待 2*MSL（报文段最长寿命）时间后才进入 CLOSED 状态？</li></ul></blockquote><h3 id="tcp-建立连接三次握手"><a class="anchor" href="#tcp-建立连接三次握手">#</a> TCP 建立连接 —— 三次握手</h3><h4 id="三次握手过程"><a class="anchor" href="#三次握手过程">#</a> 三次握手过程</h4><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/20240526161455.png" alt="image.png"></p><center>TCP 三次握手图解</center><p>建立一个 TCP 连接需要 “三次握手”，缺一不可：</p><ol><li><strong>SYN（同步序列编号）发送</strong>：客户端将发送一个<font color="red"> SYN 标志位设置为 1</font>，同时 <font color="red">序列号字段 seq 初始化为 x</font> 的 TCP 段给服务器，表示客户端希望建立连接。然后，客户端进入 <code>SYN_SENT</code> 状态，等待服务端的确认；</li><li><strong>SYN+ACK（同步确认）响应</strong>：服务器接收到客户端的 SYN 段后，会发送一个带有 <font color="red">SYN 和 ACK 标志位都设置为 1</font>，同时 <font color="red">seq 字段初始化为 y，ack 字段设置为客户端初始序列号加 1</font> 的 TCP 段作为响应。然后，服务端进入 <code>SYN_RCVD</code> 状态；</li><li><strong>ACK（确认）发送</strong>：客户端接收到服务器的 SYN+ACK 段后，会发送一个带有 <font color="red">ACK 标志位设置为 1</font>，同时<font color="red"> seq 字段设置为 x + 1，ack 字段设置为服务端初始序列号加 1</font> 的 TCP 段作为最终响应。然后，客户端和服务端都进入 <code>ESTABLISHED</code> 状态，完成 TCP 三次握手。</li></ol><p>至此，TCP 连接正式建立，客户端和服务器可以开始数据传输。</p><h4 id="为什么要三次握手"><a class="anchor" href="#为什么要三次握手">#</a> 为什么要三次握手？</h4><h5 id="让双方都能确认自己与对方的收发功能正常"><a class="anchor" href="#让双方都能确认自己与对方的收发功能正常">#</a> 让双方都能确认自己与对方的收发功能正常</h5><p>三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手的主要目的是：<strong>让双方都能确认自己与对方的收发功能均正常（通过判断对方是否收到了自己的数据原点的序列号）</strong>。</p><center>Client、Server确认双方发送与接收功能正常的时机</center><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">发送功能</th><th style="text-align:center">接收功能</th></tr></thead><tbody><tr><td style="text-align:center">Client 视角看自己</td><td style="text-align:center">第二次握手</td><td style="text-align:center">第二次握手</td></tr><tr><td style="text-align:center">Client 视角看 Server</td><td style="text-align:center">第二次握手</td><td style="text-align:center">第二次握手</td></tr><tr><td style="text-align:center">Server 视角看自己</td><td style="text-align:center">第三次握手</td><td style="text-align:center">第一次握手</td></tr><tr><td style="text-align:center">Server 视角看 Client</td><td style="text-align:center">第一次握手</td><td style="text-align:center">第三次握手</td></tr></tbody></table><ol><li>第一次握手：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常；</li><li>第二次握手：Client 确认了自己发送、接收正常，对方发送、接收正常；</li><li>第三次握手：Server 确认了自己发送，对方接收正常；</li></ol><p>由此可见，三次握手是建立 TCP 连接的最小必要步骤，它解决了以下问题：</p><ul><li><strong>确认双方的发送和接收能力</strong>：通过三次握手，双方都能确认对方的发送和接收通道都是开放的。</li><li><strong>防止重复连接</strong>：三次握手机制可以防止旧的连接请求被错误地接受。</li><li><strong>交换初始序列号</strong>：三次握手允许双方交换初始序列号，为数据传输提供同步。</li></ul><p>因此，三次握手是 TCP 连接建立过程中的一个平衡点，既确保了连接的可靠性，又避免了不必要的复杂性和资源浪费。</p><h5 id="为什么不是两次握手"><a class="anchor" href="#为什么不是两次握手">#</a> 为什么不是两次握手？</h5><p>如果只有二次握手，那么在 TCP 连接建立过程中可能会出现一些问题：</p><ol><li><p><strong>服务端无法确认自己的发送能力，以及客户端的接收能力</strong>：</p><ul><li>第一次握手时，客户端发送 SYN，服务器收到后发送 SYN-ACK 确认。但是，如果只有两次握手，服务器无法确认自己的数据发送能力，以及客户端是否能够接收数据。第三次握手确保了客户端能够接收服务器的数据。</li></ul></li><li><p><strong>已失效的连接请求突然激活，导致连接混乱</strong>：</p><ul><li>三次握手可以防止一些旧的或重复的连接请求被错误地接受。如果使用二次握手，<font color="red">一个过时的连接请求可能会被错误地认为是新的，导致连接混乱</font>。</li></ul></li><li><p><strong>双方无法交换初始序列号，这是 TCP 可靠传输的基础</strong>：</p><ul><li>三次握手允许双方交换初始序列号，<font color="red">这是 TCP 可靠传输的基础</font>。如果只有两次握手，可能无法完成这一交换。</li></ul></li></ol><h5 id="为什么不是四次握手"><a class="anchor" href="#为什么不是四次握手">#</a> 为什么不是四次握手？</h5><p>如果增加到四次握手，可能会带来以下问题：</p><ol><li><p><strong>不必要的复杂性和延迟</strong>：</p><ul><li>额外的握手会增加建立连接的时间，导致通信延迟。</li></ul></li><li><p><strong>资源浪费</strong>：</p><ul><li>每次握手都需要消耗网络资源和处理能力。不必要的额外握手会浪费这些资源。</li></ul></li><li><p><strong>效率降低</strong>：</p><ul><li>TCP 设计的目标之一是高效地建立和维护连接。增加握手次数会降低这一效率。</li></ul></li></ol><h4 id="第-2-次握手服务端传回了-ack为什么还要额外传回-syn"><a class="anchor" href="#第-2-次握手服务端传回了-ack为什么还要额外传回-syn">#</a> 第 2 次握手服务端传回了 ACK，为什么还要额外传回 SYN？</h4><p>服务端传回发送端所发送的 ACK 是为了告诉客户端：“我接收到的信息确实就是你所发送的信号了”，这表明从客户端到服务端的通信是正常的。回传 SYN 则是<strong>为了建立并确认从服务端到客户端的通信</strong>。</p><blockquote><p>SYN 同步序列编号 (Synchronize Sequence Numbers) 是 TCP/IP 建立连接时使用的握手信号。在客户机和服务端之间建立正常的 TCP 网络连接时，客户机首先发出一个 SYN 消息，服务端使用 SYN-ACK 应答表示接收到了这个消息，最后客户机再以 ACK (Acknowledgement）消息响应。<font color="red">这样在客户机和服务端之间才能建立起可靠的 TCP 连接，数据才可以在客户机和服务端之间传递</font>。</p></blockquote><h4 id="三次握手过程中可以携带数据吗"><a class="anchor" href="#三次握手过程中可以携带数据吗">#</a> 三次握手过程中可以携带数据吗？</h4><p>在 TCP 三次握手过程中，<strong>第三次握手是可以携带数据的（客户端发送完 ACK 确认包之后就进入 ESTABLISHED 状态了）</strong>，这一点在 RFC 793 文档中有提到。也就是说，一旦完成了前两次握手，TCP 协议允许数据在第三次握手时开始传输。</p><p>如果第三次握手的 ACK 确认包丢失，但是客户端已经开始发送携带数据的包，那么服务端在收到这个携带数据的包时，如果该包中包含了 ACK 标记，服务端会将其视为有效的第三次握手确认。这样，连接就被认为是建立的，服务端会处理该数据包，并继续正常的数据传输流程。</p><h4 id="半连接队列和全连接队列"><a class="anchor" href="#半连接队列和全连接队列">#</a> 半连接队列和全连接队列</h4><p>在 TCP 三次握手过程中，Linux 内核会维护两个队列来管理连接请求：</p><ol><li><strong>半连接队列</strong>（也称 SYN Queue）：当服务端收到客户端的 SYN 请求时，此时双方还没有完全建立连接，它会把<font color="red">半连接状态的连接</font>放在半连接队列。</li><li><strong>全连接队列</strong>（也称 Accept Queue）：当服务端收到客户端对 ACK 响应时，意味着三次握手成功完成，服务端会<font color="red">将该连接从半连接队列移动到全连接队列</font>。如果未收到客户端的 ACK 响应，会进行重传，重传的等待时间通常是指数增长的。<font color="red">如果重传次数超过系统规定的最大重传次数，系统将从半连接队列中删除该连接信息</font>。</li></ol><p>这两个队列的存在是<strong>为了处理并发连接请求，确保服务端能够有效地管理新的连接请求</strong>。另外，新的连接请求被拒绝或忽略除了和每个队列的大小限制有关系之外，还和很多其他因素有关系，这里就不详细介绍了，整体逻辑比较复杂。</p><h3 id="tcp-断开连接四次挥手"><a class="anchor" href="#tcp-断开连接四次挥手">#</a> TCP 断开连接 —— 四次挥手</h3><h4 id="四次挥手过程"><a class="anchor" href="#四次挥手过程">#</a> 四次挥手过程</h4><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/20240526163025.png" alt="image.png"></p><p><strong>由于 TCP 连接是全双工的，因此每个方向都必须单独进行关闭</strong>。这个原则是<font color="red">当一方完成它的数据发送任务后，就能发送一个 FIN 来终止这个方向的连接</font>。收到一个 FIN 只意味着这一方向上没有数据流动，一个 TCP 连接在收到一个 FIN 后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。</p><p>断开一个 TCP 连接则需要 “四次挥手”，缺一不可：</p><ol><li><strong>FIN（结束）发送</strong>：当一方（假设为客户端）完成数据传输并准备关闭连接时，它发送一个带有 <font color="red">FIN 标志位设置为 1</font>，同时 <font color="red">seq 字段初始化为 u</font> 的 TCP 段给另一方（服务器），表示关闭客户端到服务端的数据传送。然后，客户端进入 <code>FIN-WAIT-1</code> 状态。</li><li><strong>ACK（确认）响应</strong>：服务器接收到 FIN 段后，会发送一个带有 <font color="red">ACK 标志位设置为 1</font>，同时 <font color="red">seq 字段初始化为 v，ack 字段设置为客户端初始序列号加 1</font> 的 TCP 段作为响应，表示确认客户端的断开请求。然后，服务端进入 <code>CLOSE-WAIT</code> 状态，客户端进入 <code>FIN-WAIT-2</code> 状态。</li><li><strong>FIN（结束）发送</strong>：此时，服务器可能还有未完成的数据传输。当服务器也准备关闭连接时，它会发送一个带有 <font color="red">FIN 标志位设置为 1</font> ，同时 <font color="red">seq 字段初始化为 w，ack 字段设置为客户端初始序列号加 1</font> 的 TCP 段给客户端，请求关闭连接。然后，服务端进入 <code>LAST-ACK</code> 状态。</li><li><strong>ACK（确认）发送</strong>：客户端接收到服务器的 FIN 段后，会发送最后一个带有 <font color="red">ACK 标志位设置为 1</font>，同时 <font color="red">seq 字段设置 u + 1，ack 字段设置为服务端初始序列号加 1</font> 的 TCP 段作为响应，确认服务器的断开请求。然后，客户端进入 <code>TIME-WAIT</code> 状态，服务端在收到该数据包后进入 <code>CLOSE</code> 状态。此时，如果<font color="red">客户端等待 2MSL</font> 后依然没有收到回复，就证明服务端已正常关闭，随后客户端也可以关闭连接了。</li></ol><p><strong>只要四次挥手没有结束，客户端和服务端就可以继续传输数据！</strong> 完成这四次挥手后，TCP 连接被正式终止。</p><h4 id="为什么要四次挥手"><a class="anchor" href="#为什么要四次挥手">#</a> 为什么要四次挥手？</h4><ul><li>TCP 是<strong>全双工通信</strong>的，即数据可以在两个方向上独立传输。</li><li><strong>每个方向都可以独立关闭</strong>。当一方完成数据传输并发送 FIN 请求关闭连接时，<font color="red">另一方可能还有数据要发送</font>。因此，需要四次挥手来<strong>确保双方都清楚连接即将关闭，并且都有机会完成剩余的数据传输</strong>。</li></ul><p>举个例子：A 和 B 打电话，通话即将结束后。</p><ol><li><strong>第一次挥手</strong>：A 说 “我没啥要说的了”</li><li><strong>第二次挥手</strong>：B 回答 “我知道了”，但是 B 可能还会有要说的话，A 不能要求 B 跟着自己的节奏结束通话</li><li><strong>第三次挥手</strong>：于是 B 可能又巴拉巴拉说了一通，最后 B 说 “我说完了”</li><li><strong>第四次挥手</strong>：A 回答 “知道了”，这样通话才算结束。</li></ol><h4 id="为什么不能把服务端发送的-ack-和-fin-合并变为三次挥手"><a class="anchor" href="#为什么不能把服务端发送的-ack-和-fin-合并变为三次挥手">#</a> 为什么不能把服务端发送的 ACK 和 FIN 合并，变为三次挥手？</h4><p>因为服务端收到客户端断开连接的请求时，<font color="red">可能还有一些数据没有发完</font>，这时先回复 ACK，表示接收到了断开连接的请求。等到数据发完之后再发 FIN，断开服务端到客户端的数据传送。</p><h4 id="如果第二次挥手时服务端的-ack-没有送达到客户端会怎样"><a class="anchor" href="#如果第二次挥手时服务端的-ack-没有送达到客户端会怎样">#</a> 如果第二次挥手时服务端的 ACK 没有送达到客户端，会怎样？</h4><p><font color="red">客户端没有收到 ACK 确认，会重新发送 FIN 请求</font>。</p><h4 id="为什么第四次挥手后客户端还需要等待2msl报文段的最长寿命的时间后才能进入-closed-状态"><a class="anchor" href="#为什么第四次挥手后客户端还需要等待2msl报文段的最长寿命的时间后才能进入-closed-状态">#</a> 为什么第四次挥手后，客户端还需要等待 2*MSL（报文段的最长寿命）的时间后，才能进入 CLOSED 状态？</h4><p>第四次挥手时，客户端发送给服务端的 ACK 有可能丢失，如果服务端因为某些原因而没有收到 ACK 的话，服务端就会重发 FIN。因此，如果客户端在 2*MSL 的时间内收到了 FIN，就会重新发送 ACK 并再次等待 2MSL，<strong>防止 Server 没有收到 ACK 而不断重发 FIN</strong>。</p><p><code>MSL(Maximum Segment Lifetime，报文段的最长寿命)</code> : 一个片段在网络中最大的存活时间，2MSL 就是一个发送和一个回复所需的最大时间。<strong>如果直到 2MSL，Client 都没有再次收到 FIN，那么 Client 推断 ACK 已经被服务端成功接收，则结束 TCP 连接</strong>。</p><h3 id="参考-2"><a class="anchor" href="#参考-2">#</a> 参考</h3><ul><li>《计算机网络（第 7 版）》</li><li>《图解 HTTP》</li><li>TCP and UDP Tutorial：<span class="exturl" data-url="aHR0cHM6Ly93d3cuOXR1dC5jb20vdGNwLWFuZC11ZHAtdHV0b3JpYWw=">https://www.9tut.com/tcp-and-udp-tutorial</span></li><li>从一次线上问题说起，详解 TCP 半连接队列、全连接队列：<span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvWXBTbFUxeWFvd1RzLXBGNlI0M2hNdw==">https://mp.weixin.qq.com/s/YpSlU1yaowTs-pF6R43hMw</span></li></ul><h2 id="tcp-传输可靠性"><a class="anchor" href="#tcp-传输可靠性">#</a> TCP 传输可靠性</h2><h3 id="tcp-传输可靠性概览"><a class="anchor" href="#tcp-传输可靠性概览">#</a> TCP 传输可靠性概览</h3><ol><li><strong>基于数据块传输</strong>：应用数据被分割成 TCP 认为最适合发送的数据块，再传输给网络层，数据块被称为<font color="red">报文段或段</font>。</li><li><strong>对失序数据包重新排序、去重</strong>：TCP 为了保证不发生丢包，就给每个包一个<font color="red">序列号</font>，有了序列号能够将接收到的数据根据序列号排序，并且去掉重复序列号的数据就可以实现数据包去重。</li><li><strong>校验和</strong> : TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，<font color="red">目的是检测数据在传输过程中的任何变化、差错</font>。如果收到段的检验和有差错，TCP 将丢弃这个报文段，不确认收到此报文段。</li><li><strong>重传机制</strong>：在数据包丢失或延迟的情况下，重新发送数据包，直到收到对方的确认应答（ACK）。TCP 重传机制主要有：<font color="cornflowerblue">基于计时器的重传</font>（也就是超时重传）、<font color="cornflowerblue">快速重传</font>（基于接收端的反馈信息来引发重传）、<font color="cornflowerblue">SACK</font>（在快速重传的基础上，<font color="red">返回最近收到的报文段的序列号范围</font>，这样客户端就知道，哪些数据包已经到达服务器了）、<font color="cornflowerblue">D-SACK</font>（重复 SACK，在 SACK 的基础上，<font color="red">额外携带信息</font>，告知发送方有哪些数据包自己重复接收了）。关于重传机制的详细介绍，可以查看<span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8xMDE3MDIzMTI=">详解 TCP 超时与重传机制</span>这篇文章。</li><li><strong>流量控制</strong> : TCP 连接的每一方都有固定大小的缓冲空间，<font color="red">TCP 的接收端只允许发送端发送接收端缓冲区能接纳的数据</font>。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议（TCP 利用<font color="red">滑动窗口</font>实现流量控制）。</li><li><strong>拥塞控制</strong>：当网络拥塞时，减少数据的发送。TCP 在发送数据的时候，需要考虑两个因素：一是接收方的接收能力，二是网络的拥塞程度。接收方的接收能力由<font color="red">滑动窗口</font>表示，表示接收方还有多少缓冲区可以用来接收数据。网络的拥塞程度由<font color="red">拥塞窗口</font>表示，它是发送方根据网络状况自己维护的一个值，表示发送方认为可以在网络中传输的数据量。<font color="red">发送方发送数据的大小是滑动窗口和拥塞窗口的最小值</font>，这样可以保证发送方既不会超过接收方的接收能力，也不会造成网络的过度拥塞。</li></ol><h3 id="tcp-流量控制"><a class="anchor" href="#tcp-流量控制">#</a> TCP 流量控制</h3><p><strong>TCP 利用滑动窗口实现流量控制，即控制发送方发送速率，保证接收方来得及接收。</strong> 接收方发送的确认报文中的<font color="red">滑动窗口字段</font>可以用来控制发送方窗口大小，从而影响发送方的发送速率。将滑动窗口字段设置为 0，则发送方不能发送数据。</p><p>为什么需要流量控制？这是因为双方在通信的时候，<font color="red">发送方的速率与接收方的速率是不一定相等</font>，如果发送方的发送速率太快，会导致接收方处理不过来。如果接收方处理不过来的话，就只能把处理不过来的数据存在 <code>接收缓冲区(Receiving Buffers)</code> 里（失序的数据包也会被存放在缓存区里）。<font color="red">如果缓存区满了发送方还在狂发数据的话，接收方只能把收到的数据包丢掉</font>。出现丢包问题的同时又疯狂浪费着珍贵的网络资源。因此，我们需要控制发送方的发送速率，让接收方与发送方处于一种动态平衡才好。</p><p>这里需要注意的是（常见误区）：</p><ul><li>发送端不等同于客户端</li><li>接收端不等同于服务端</li></ul><p>TCP 为全双工（Full-Duplex, FDX）通信，双方可以进行双向通信，客户端和服务端既可能是发送端又可能是服务端。因此，<font color="red">客户端和服务端各有一个发送缓冲区与接收缓冲区，两端都各自维护一个发送窗口和一个接收窗口</font>。接收窗口大小取决于应用、系统、硬件的限制（TCP 传输速率不能大于应用的数据处理速率）。通信双方的发送窗口和接收窗口的要求相同。</p><h4 id="tcp-发送窗口"><a class="anchor" href="#tcp-发送窗口">#</a> TCP 发送窗口</h4><p>TCP 发送窗口可以划分成四个部分：</p><ol><li><strong>已发送且已确认</strong>：已经发送并且确认的 TCP 段；</li><li><strong>已发送但还未确认</strong>：已经发送但是没有确认的 TCP 段；</li><li><strong>即将发送 / 可以发送</strong>：未发送但是接收方准备接收的 TCP 段；</li><li><strong>（滑动窗口移动前）不能发送</strong>：未发送并且接收方也并未准备接受的 TCP 段。</li></ol><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/20240526173202.png" alt="image.png"></p><blockquote><ul><li><strong>SND.WND</strong>：发送窗口大小。</li><li><strong>SND.UNA</strong>： <code>Send Unacknowledged</code> 指针，指向发送窗口的第一个字节。</li><li><strong>SND.NXT</strong>： <code>Send Next</code> 指针，指向可发送窗口的第一个字节。</li></ul><p><strong>可用窗口大小</strong> = <code>SND.UNA + SND.WND - SND.NXT</code> 。</p></blockquote><h4 id="tcp-接收窗口"><a class="anchor" href="#tcp-接收窗口">#</a> TCP 接收窗口</h4><p>TCP 接收窗口可以划分成三个部分：</p><ol><li><strong>已接收且已确认</strong>：已经接收并且已经确认的 TCP 段；</li><li><strong>等待接收 / 可以接收但未确认</strong>：等待接收且允许发送方发送的 TCP 段；</li><li><strong>（滑动窗口移动前）不能接收</strong>：不可接收且不允许发送方发送的 TCP 段。</li></ol><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/20240526173213.png" alt="image.png"></p><p><strong>接收窗口的大小是根据接收端处理数据的速度动态调整的。</strong> 如果接收端读取数据快，接收窗口可能会扩大。 否则，它可能会缩小。</p><p>另外，这里的滑动窗口大小只是为了演示使用，实际窗口大小通常会远远大于这个值。</p><h3 id="tcp-拥塞控制"><a class="anchor" href="#tcp-拥塞控制">#</a> TCP 拥塞控制</h3><p>在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫拥塞。拥塞控制就是<strong>为了防止过多的数据注入到网络中</strong>，这样就可以使网络中的路由器或链路不致过载。</p><p>拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。拥塞控制是一个<font color="red">全局性的过程</font>，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。相反，流量控制往往是点对点通信量的控制，是个端到端的问题。<font color="red">流量控制所要做到的就是抑制发送端发送数据的速率</font>，以便使接收端来得及接收。</p><p><img data-src="https://cdn.nlark.com/yuque/0/2024/png/35359700/1716715497409-5a73ee3f-251f-4c58-a93f-e75a2e76f5a7.png" alt=""></p><center>TCP 拥塞控制</center><p>为了进行拥塞控制，TCP 发送方要维持一个 <strong>拥塞窗口（cwnd）</strong> 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的<font color="red">发送窗口取值为拥塞窗口和接收方的接收窗口中的较小值</font>。</p><p>TCP 的拥塞控制采用了四种算法：</p><ul><li><font color="cornflowerblue">慢开始</font>： 思想是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。经验表明，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是<strong>由小到大逐渐增大拥塞窗口</strong>，cwnd 初始值为 1，每经过一个传播轮次，cwnd 加倍。</li><li><font color="cornflowerblue">拥塞避免</font>： 思路是<strong>线性增大拥塞窗口</strong>，即每经过一个往返时间 RTT 就把发送方的 cwnd 加 1。</li><li><font color="cornflowerblue">快重传</font>与<font color="cornflowerblue">快恢复</font>： 在 TCP/IP 中， <code>快速重传和恢复（fast retransmit and recovery，FRR）</code> 是一种拥塞控制算法，它能快速恢复丢失的数据包。没有 FRR，如果数据包丢失了，TCP 将会使用定时器来要求暂停传输。在暂停的这段时间内，没有新的或复制的数据包被发送。<ul><li>有了 FRR，如果接收机接收到一个不按顺序的数据段，它会立即给发送机发送一个重复确认。<strong>如果发送机累积接收到三个重复确认，它就会假定确认中指出的数据段丢失了，并立即重传这些丢失的数据段</strong>。</li><li>有了 FRR，就不会因为重传时要求的暂停被耽误。 当有单独的数据包丢失时，快速重传和恢复（FRR）能最有效地工作。当有多个数据信息包在某一段很短的时间内丢失时，它则不能很有效地工作。</li></ul></li></ul><h3 id="arq-协议"><a class="anchor" href="#arq-协议">#</a> ARQ 协议</h3><p><strong>自动重传请求（Automatic Repeat-reQuest，ARQ）协议</strong>是 OSI 模型中数据链路层和传输层的<font color="red">错误纠正协议</font>之一。它通过使用<font color="cornflowerblue">确认</font>和<font color="cornflowerblue">超时</font>这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送方在发送后一段时间之内没有收到确认信息，它通常会重新发送，直到收到确认或者重试超过一定的次数。</p><p>ARQ 包括<font color="cornflowerblue">停止等待 ARQ 协议</font>和<font color="cornflowerblue">连续 ARQ 协议</font>，略过。</p><h4 id="停止等待-arq-协议"><a class="anchor" href="#停止等待-arq-协议">#</a> 停止等待 ARQ 协议</h4><p>停止等待协议是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认（回复 ACK）。如果过了一段时间（超时时间后），还是没有收到 ACK 确认，说明没有发送成功，需要重新发送，直到收到确认后再发下一个分组；</p><p>在停止等待协议中，若接收方收到重复分组，就丢弃该分组，但同时还要发送确认。</p><p><strong>1) 无差错情况:</strong></p><p>发送方发送分组，接收方在规定时间内收到，并且回复确认。发送方再次发送。</p><p><strong>2) 出现差错情况（超时重传）:</strong></p><p>停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重传时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为 <strong>自动重传请求 ARQ</strong> 。另外在停止等待协议中若收到重复分组，就丢弃该分组，但同时还要发送确认。</p><p><strong>3) 确认丢失和确认迟到</strong></p><ul><li><strong>确认丢失</strong>：确认消息在传输过程丢失。当 A 发送 M1 消息，B 收到后，B 向 A 发送了一个 M1 确认消息，但却在传输过程中丢失。而 A 并不知道，在超时计时过后，A 重传 M1 消息，B 再次收到该消息后采取以下两点措施：1. 丢弃这个重复的 M1 消息，不向上层交付。 2. 向 A 发送确认消息。（不会认为已经发送过了，就不再发送。A 能重传，就证明 B 的确认消息丢失）。</li><li><strong>确认迟到</strong>：确认消息在传输过程中迟到。A 发送 M1 消息，B 收到并发送确认。在超时时间内没有收到确认消息，A 重传 M1 消息，B 仍然收到并继续发送确认消息（B 收到了 2 份 M1）。此时 A 收到了 B 第二次发送的确认消息。接着发送其他数据。过了一会，A 收到了 B 第一次发送的对 M1 的确认消息（A 也收到了 2 份确认消息）。处理如下：1. A 收到重复的确认后，直接丢弃。2. B 收到重复的 M1 后，也直接丢弃重复的 M1。</li></ul><h4 id="连续-arq-协议"><a class="anchor" href="#连续-arq-协议">#</a> 连续 ARQ 协议</h4><p>连续 ARQ 协议可提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。</p><ul><li><strong>优点：</strong> 信道利用率高，容易实现，即使确认丢失，也不必重传。</li><li><strong>缺点：</strong> 不能向发送方反映出接收方已经正确收到的所有分组的信息。 比如：发送方发送了 5 条 消息，中间第三条丢失（3 号），这时接收方只能对前两个发送确认。发送方无法知道后三个分组的下落，而只好把后三个全部重传一次。这也叫 Go-Back-N（回退 N），表示需要退回来重传已经发送过的 N 个消息。</li></ul><h3 id="tcp-超时重传"><a class="anchor" href="#tcp-超时重传">#</a> TCP 超时重传</h3><p>当发送方发送数据之后，它启动一个定时器，等待接收端确认收到这个报文段。接收端实体对已成功收到的包发回一个相应的确认信息（ACK）。<strong>如果发送端在合理的往返时延（RTT）内未收到确认消息，那么对应的数据包就被假设为<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU0JUI4JUEyJUU1JThDJTg1">已丢失</span>，并进行重传</strong>。</p><ul><li><code>RTT（Round Trip Time）</code> ：<font color="red">往返时间</font>，也就是数据包从发出去到收到对应 ACK 的时间。</li><li><code>RTO（Retransmission Time Out）</code> ：<font color="red">重传超时时间</font>，即从数据发送时刻算起，超过这个时间便执行重传。</li></ul><p>RTO 的确定是一个关键问题，因为它直接影响到 TCP 的性能和效率。如果 RTO 设置得太小，会导致不必要的重传，增加网络负担；如果 RTO 设置得太大，会导致数据传输的延迟，降低吞吐量。因此，RTO 应该根据网络的实际状况，动态地进行调整。</p><p>RTT 的值会随着网络的波动而变化，所以 TCP 不能直接使用 RTT 作为 RTO。为了动态地调整 RTO，TCP 协议采用了一些算法，如加权移动平均（EWMA）算法，Karn 算法，Jacobson 算法等，这些算法都是<font color="red">根据往返时延（RTT）的测量和变化来估计 RTO 的值</font>。</p><h3 id="参考-3"><a class="anchor" href="#参考-3">#</a> 参考</h3><ol><li>《计算机网络（第 7 版）》</li><li>《图解 HTTP》</li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuOXR1dC5jb20vdGNwLWFuZC11ZHAtdHV0b3JpYWw=">https://www.9tut.com/tcp-and-udp-tutoria</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3dvbHZlcmlubi9XYWtpbmctVXAvYmxvYi9tYXN0ZXIvQ29tcHV0ZXIlMjBOZXR3b3JrLm1k">https://github.com/wolverinn/Waking-Up/blob/master/Computer%20Network.md</span></li><li>TCP Flow Control—<span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJpYW5zdG9ydGkuY29tL3RjcC1mbG93LWNvbnRyb2wv">https://www.brianstorti.com/tcp-flow-control/</span></li><li>TCP 流量控制 (Flow Control)：<span class="exturl" data-url="aHR0cHM6Ly9ub3RmYWxzZS5uZXQvMjQvdGNwLWZsb3ctY29udHJvbA==">https://notfalse.net/24/tcp-flow-control</span></li><li>TCP 之滑动窗口原理 : <span class="exturl" data-url="aHR0cHM6Ly9jbG91ZC50ZW5jZW50LmNvbS9kZXZlbG9wZXIvYXJ0aWNsZS8xODU3MzYz">https://cloud.tencent.com/developer/article/1857363</span></li></ol><h1 id="ip"><a class="anchor" href="#ip">#</a> IP</h1><h2 id="ip-作用"><a class="anchor" href="#ip-作用">#</a> IP 作用</h2><p><code>IP（Internet Protocol，网际协议）</code> 是 TCP/IP 协议中最重要的协议之一，属于<font color="red">网络层</font>的协议，主要作用是<strong>定义数据包的格式、对数据包进行路由和寻址</strong>，以便它们可以跨网络传播并到达正确的目的地。</p><p>目前 IP 协议主要分为两种，一种是过去的 <font color="cornflowerblue">IPv4</font>，另一种是较新的 <font color="cornflowerblue">IPv6</font>，目前这两种协议都在使用，但后者已经被提议来取代前者。</p><h2 id="ip-地址"><a class="anchor" href="#ip-地址">#</a> IP 地址</h2><p>每个连入互联网的设备或域（如计算机、服务器、路由器等）都被分配一个 <code>IP 地址（Internet Protocol address）</code> ，作为唯一标识符。每个 IP 地址都是一个字符序列，如 192.168.1.1（IPv4）、2001:0db8:85a3:0000:0000:8a2e:0370:7334（IPv6） 。</p><p>当网络设备发送 IP 数据包时，数据包中包含了 <strong>源 IP 地址</strong> 和 <strong>目的 IP 地址</strong> 。源 IP 地址用于标识数据包的发送方设备或域，而目的 IP 地址则用于标识数据包的接收方设备或域。这类似于一封邮件中同时包含了目的地地址和回邮地址。</p><p>网络设备根据目的 IP 地址来判断数据包的目的地，并将数据包转发到正确的目的地网络或子网络，从而实现了设备间的通信。</p><p>这种基于 IP 地址的寻址方式是互联网通信的基础，它允许数据包在不同的网络之间传递，从而实现了全球范围内的网络互联互通。IP 地址的唯一性和全局性保证了网络中的每个设备都可以通过其独特的 IP 地址进行标识和寻址。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/20240526182855.png" alt="image.png"></p><center>IP 地址使数据包到达其目的地</center><h1 id="重要知识点"><a class="anchor" href="#重要知识点">#</a> 重要知识点</h1><h2 id="在浏览器地址栏输入-url-并按下回车键到页面展示背后发生了什么"><a class="anchor" href="#在浏览器地址栏输入-url-并按下回车键到页面展示背后发生了什么">#</a> 在浏览器地址栏输入 URL 并按下回车键到页面展示，背后发生了什么？</h2><blockquote><p>类似的问题：打开一个网页，整个过程会使用哪些协议？</p></blockquote><p>开发岗中总是会考很多计算机网络的知识点，但如果让面试官只靠一道题，便涵盖最多的计网知识点，那可能就是 <strong>网页浏览的全过程</strong> 了。本篇文章将带大家从头到尾过一遍这道被考烂的面试题，必会！！！</p><p>总的来说，<font color="cornflowerblue">网络通信模型</font>可以用下图来表示，也就是大家只要熟记网络结构五层模型，按照这个体系，很多知识点都能顺出来了。访问网页的过程也是如此。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/20240524154400.png" alt="image.png"></p><p>先来看《图解 HTTP》中的一张图，其中有一个错误需要注意：是 OSPF 不是 OPSF。 OSPF（Open Shortest Path First，ospf）开放最短路径优先协议，是由 Internet 工程任务组开发的路由选择协议。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/20240525200751.png" alt="image.png"></p><p>开始之前，先简单过一遍完整流程：</p><ol><li><strong>DNS 解析</strong>：浏览器首先需要<font color="red">将输入的域名解析为 IP 地址</font>。这通过查询 <font color="cornflowerblue">DNS</font> 服务器完成，DNS 服务器将域名映射到服务器的 <font color="cornflowerblue">IP</font> 地址。</li><li><strong>建立 TCP 连接</strong>：浏览器根据 IP 地址和端口号，向目标服务器发起一个 <font color="cornflowerblue">TCP 连接请求</font>。</li><li><strong>发送 HTTP 请求</strong>：浏览器在 TCP 连接上，向服务器发送一个 <font color="cornflowerblue">HTTP 请求报文</font>，请求获取网页的内容。如果是安全连接，则使用 HTTPS，该协议在 HTTP 上增加了 SSL/TLS 加密层。</li><li><strong>SSL/TLS 握手（如果使用 HTTPS）</strong>：在数据传输之前，如果使用 HTTPS，浏览器和服务器会进行 <font color="cornflowerblue">SSL/TLS</font> 握手，以建立一个加密的通信通道。</li><li><strong>服务器处理 HTTP 请求并响应</strong>：服务器收到 HTTP 请求报文后，处理请求，并返回 <font color="cornflowerblue">HTTP 响应报文</font>给浏览器。响应中包含了请求的网页内容，如 HTML、CSS、JavaScript 文件等。</li><li><strong>浏览器渲染页面</strong>：浏览器收到服务器的 HTTP 响应报文后，会开始<font color="red">解析</font>响应体中的 HTML 代码，并根据 HTML、CSS 和 JavaScript 文件<font color="red">渲染</font>网页的结构和样式。同时，浏览器可能会加载其他资源，根据 HTML 中的其他资源的 URL（如图片、CSS、JS 等），<font color="red">再次发起 HTTP 请求</font>，获取这些资源的内容，直到网页完全加载显示。</li><li><strong>TCP 连接关闭</strong>：一旦数据传输完成，浏览器就不需要和服务器通信了，可以<font color="cornflowerblue">主动关闭 TCP 连接</font>，或者等待服务器的关闭请求。</li></ol><h3 id="应用层"><a class="anchor" href="#应用层">#</a> 应用层</h3><p>一切的开始 —— 打开浏览器，在地址栏输入 URL，回车确认。那么，什么是 URL？访问 URL 有什么用？</p><h4 id="url"><a class="anchor" href="#url">#</a> URL</h4><p><code>URL（Uniform Resource Locators）</code> ，即<font color="cornflowerblue">统一资源定位器</font>。网络上的所有资源都靠 URL 来定位，<font color="red">每一个文件就对应着一个 URL</font>，就像是路径地址。理论上，文件资源和 URL 一一对应。实际上也有例外，比如某些 URL 指向的文件已经被重定位到另一个位置，这样就有多个 URL 指向同一个文件。</p><h4 id="url-的组成结构"><a class="anchor" href="#url-的组成结构">#</a> URL 的组成结构</h4><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/20240524165625.png" alt="image.png"></p><ol><li><strong>协议</strong>。URL 的前缀通常表示了该网址采用了何种<font color="red">应用层协议</font>，通常有两种 ——HTTP 和 HTTPS。当然也有一些不太常见的前缀头，比如文件传输时用到的 <code>ftp:</code> 。</li><li><strong>域名</strong>。域名便是访问网址的通用名，这里也有可能是网址的 IP 地址，域名可以理解为<font color="red"> IP 地址的可读版本</font>，毕竟绝大部分人都不会选择记住一个网址的 IP 地址。</li><li><strong>端口</strong>。如果指明了访问网址的端口的话，端口会紧跟在域名后面，并用一个冒号隔开。</li><li><strong>资源路径</strong>。域名（端口）后紧跟的就是资源路径，从第一个 <code>/</code> 开始，表示<font color="red">从服务器上根目录开始进行索引到的文件路径</font>，上图中要访问的文件就是服务器根目录下 <code>/path/to/myfile.html</code> 。早先的设计是该文件通常物理存储于服务器主机上，但现在随着网络技术的进步，该文件不一定会物理存储在服务器主机上，<font color="red">有可能存放在云上</font>，而文件路径也有可能是虚拟的（遵循某种规则）。</li><li><strong>参数</strong>。参数是浏览器在向服务器提交请求时，在 URL 中附带的参数。服务器解析请求时，会提取这些参数。参数采用<font color="red">键值对</font>的形式 <code>key=value</code> ，每一个键值对使用 <code>&amp;</code> 隔开。参数的具体含义和请求操作的具体方法有关。</li><li><strong>锚点</strong>。顾名思义，是在要访问的页面上的一个锚。要访问的页面大部分都多于一页，如果指定了锚点，那么在客户端显示该网页是就会<font color="red">定位到锚点处</font>，相当于一个小书签。值得一提的是，在 URL 中，锚点以 <code>#</code> 开头，并且<font color="red">不会</font>作为请求的一部分发送给服务端。</li></ol><h4 id="dns-协议"><a class="anchor" href="#dns-协议">#</a> DNS 协议</h4><p>键入了 URL 之后，第一个重头戏登场 ——DNS 服务器解析。 <code>DNS（Domain Name System）</code> <font color="cornflowerblue">域名系统</font>，它要解决的是 <strong>域名和 IP 地址的映射问题</strong> 。毕竟，域名只是一个网址便于记住的名字，而网址真正存在的地址其实是 IP 地址。</p><p>传送门：<a href="#DNS">DNS</a></p><h4 id="httphttps"><a class="anchor" href="#httphttps">#</a> HTTP/HTTPS</h4><p>利用 DNS 拿到了目标主机的 IP 地址之后，浏览器便可以<font color="red">向目标 IP 地址发送 HTTP 报文，请求需要的资源</font>了。在这里，根据目标网站的不同，请求报文可能是 HTTP 协议或安全性增强的 HTTPS 协议。</p><p>传送门：</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3M/X19iaXo9TXpnMk9UQTBOamswT0E9PSZhbXA7bWlkPTIyNDc1MzY4MjMmYW1wO2lkeD0xJmFtcDtzbj0yODk0NzQ3NTgyMTM2NWIzOWJjM2JlMTZjYTY1NDk0ZCZhbXA7c2NlbmU9MjEjd2VjaGF0X3JlZGlyZWN0">HTTPS 是如何保证传输安全的？</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3M/X19iaXo9TXpnMk9UQTBOamswT0E9PSZhbXA7bWlkPTIyNDc1MjUyNjMmYW1wO2lkeD0yJmFtcDtzbj0yM2EyYmI0MDJiOTNiZmUwNzMwM2UxYjM1M2MyMTY0NCZhbXA7c2NlbmU9MjEjd2VjaGF0X3JlZGlyZWN0">HTTP 常见的状态码有哪些？</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3M/X19iaXo9TXpnMk9UQTBOamswT0E9PSZhbXA7bWlkPTIyNDc1MjgzNzcmYW1wO2lkeD0yJmFtcDtzbj0zODJiNzU0MTc5MmRiMmE2NDYxOWQzNzcxNGU4YjYxMyZhbXA7c2NlbmU9MjEjd2VjaGF0X3JlZGlyZWN0">HTTP 1.0 和 HTTP 1.1 有什么区别？</span></li></ul><h3 id="传输层"><a class="anchor" href="#传输层">#</a> 传输层</h3><p>由于 HTTP 协议是基于 <font color="cornflowerblue">TCP 协议</font>的，在应用层的数据封装好以后，要交给传输层，经 TCP 协议继续封装。</p><p><font color="red">TCP 协议保证了数据传输的可靠性，是数据包传输的主力协议</font>。</p><p>传送门：</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3M/X19iaXo9TXpnMk9UQTBOamswT0E9PSZhbXA7bWlkPTIyNDc1MzgzNzUmYW1wO2lkeD0yJmFtcDtzbj1hOWZlYWE1MmZkYWVkMDg3NjE2M2JkYWQyZmIxNjM4MSZhbXA7c2NlbmU9MjEjd2VjaGF0X3JlZGlyZWN0">TCP 为什么要三次握手和四次挥手？</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3M/X19iaXo9TXpnMk9UQTBOamswT0E9PSZhbXA7bWlkPTIyNDc1Mjc5NzUmYW1wO2lkeD0yJmFtcDtzbj0zMWNhZTllZDhlMDY4NGFiNTMxYTZmYTJmY2FhZmEwMSZhbXA7c2NlbmU9MjEjd2VjaGF0X3JlZGlyZWN0">TCP 与 UDP 的区别？</span></li></ul><h3 id="网络层"><a class="anchor" href="#网络层">#</a> 网络层</h3><p>终于，来到网络层，此时我们的主机不再是和另一台主机进行交互了，而是在和中间系统进行交互。也就是说，<font color="red">应用层和传输层都是端到端的协议，而网络层及以下都是中间件的协议了</font>。</p><p>网络层的的核心功能 ——<strong> 转发与路由</strong>，必会！！！如果面试官问到了网络层，而你恰好又什么都不会的话，最最起码要说出这五个字。</p><ul><li><strong>转发</strong>：将分组从路由器的输入端口转移到合适的输出端口。</li><li><strong>路由</strong>：确定分组从源到目的经过的路径。</li></ul><p>所以到目前为止，我们的数据包经过了应用层、传输层的封装，来到了网络层，终于开始准备在物理层面传输了，第一个要解决的问题就是 —— 往哪里传输？或者说，<strong>要把数据包发到哪个路由器上？</strong> 这便是 <font color="cornflowerblue">BGP 协议</font>要解决的问题。</p></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2024-05-26 18:29:39" itemprop="dateModified" datetime="2024-05-26T18:29:39+08:00">2024-05-26</time> </span><span id="computer-base/计算机网络常问八股文/" class="item leancloud_visitors" data-flag-title="计算机网络常问八股文" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>范特东东东 <i class="ic i-at"><em>@</em></i>水文 & 摄影</li><li class="link"><strong>本文链接：</strong> <a href="http://example.com/computer-base/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%B8%B8%E9%97%AE%E5%85%AB%E8%82%A1%E6%96%87/" title="计算机网络常问八股文">http://example.com/computer-base/计算机网络常问八股文/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/database/redis/%E5%B0%9A%E7%A1%85%E8%B0%B7-%E5%91%A8%E9%98%B3-Redis7/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;hjx159&#x2F;picture-bed&#x2F;main&#x2F;img&#x2F;4590329fa2854869612bbee0cd018e9c192a7f0f.jpg" title="Redis7-尚硅谷-周阳"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> Redis</span><h3>Redis7-尚硅谷-周阳</h3></a></div><div class="item right"></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.</span> <span class="toc-text">网络分层模型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#osi-%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.1.</span> <span class="toc-text">OSI 七层模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tcpip-%E5%9B%9B%E5%B1%82%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.2.</span> <span class="toc-text">TCP&#x2F;IP 四层模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%B1%82application"><span class="toc-number">1.2.1.</span> <span class="toc-text">应用层（Application）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#http%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">HTTP：超文本传输协议</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#websocket%E5%85%A8%E5%8F%8C%E5%B7%A5%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">Websocket：全双工通信协议</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#smtp%E7%AE%80%E5%8D%95%E9%82%AE%E4%BB%B6%E4%BC%A0%E8%BE%93%E5%8F%91%E9%80%81%E5%8D%8F%E8%AE%AE"><span class="toc-number">1.2.1.3.</span> <span class="toc-text">SMTP：简单邮件传输（发送）协议</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6%E7%9A%84%E5%8F%91%E9%80%81%E8%BF%87%E7%A8%8B"><span class="toc-number">1.2.1.3.1.</span> <span class="toc-text">电子邮件的发送过程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E9%82%AE%E7%AE%B1%E6%98%AF%E5%90%A6%E6%9C%89%E6%95%88"><span class="toc-number">1.2.1.3.2.</span> <span class="toc-text">判断邮箱是否有效</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pop3imap%E9%82%AE%E4%BB%B6%E6%8E%A5%E6%94%B6%E7%9A%84%E5%8D%8F%E8%AE%AE"><span class="toc-number">1.2.1.4.</span> <span class="toc-text">POP3&#x2F;IMAP：邮件接收的协议</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ftp%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE"><span class="toc-number">1.2.1.5.</span> <span class="toc-text">FTP：文件传输协议</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#telnet%E8%BF%9C%E7%A8%8B%E7%99%BB%E9%99%86%E5%8D%8F%E8%AE%AE"><span class="toc-number">1.2.1.6.</span> <span class="toc-text">Telnet：远程登陆协议</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ssh%E5%AE%89%E5%85%A8%E7%9A%84%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE"><span class="toc-number">1.2.1.7.</span> <span class="toc-text">SSH：安全的网络传输协议</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#rtp%E5%AE%9E%E6%97%B6%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE"><span class="toc-number">1.2.1.8.</span> <span class="toc-text">RTP：实时传输协议</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#dns%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.2.1.9.</span> <span class="toc-text">DNS：域名系统</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E8%BE%93%E5%B1%82transport"><span class="toc-number">1.2.2.</span> <span class="toc-text">传输层（Transport）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%B1%82network"><span class="toc-number">1.2.3.</span> <span class="toc-text">网络层（Network）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E6%8E%A5%E5%8F%A3%E5%B1%82network-interface"><span class="toc-number">1.2.4.</span> <span class="toc-text">网络接口层（Network interface）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">1.2.5.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">1.3.</span> <span class="toc-text">网络分层的原因</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#http"><span class="toc-number">2.</span> <span class="toc-text">HTTP</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#http-%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">2.1.</span> <span class="toc-text">HTTP 是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#http-%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-number">2.2.</span> <span class="toc-text">HTTP 状态码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1xx-informational%E4%BF%A1%E6%81%AF%E6%80%A7%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-number">2.2.1.</span> <span class="toc-text">1xx Informational（信息性状态码）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2xx-success%E6%88%90%E5%8A%9F%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-number">2.2.2.</span> <span class="toc-text">2xx Success（成功状态码）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3xx-redirection%E9%87%8D%E5%AE%9A%E5%90%91%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-number">2.2.3.</span> <span class="toc-text">3xx Redirection（重定向状态码）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4xx-client-error%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%94%99%E8%AF%AF%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-number">2.2.4.</span> <span class="toc-text">4xx Client Error（客户端错误状态码）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5xx-server-error%E6%9C%8D%E5%8A%A1%E7%AB%AF%E9%94%99%E8%AF%AF%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-number">2.2.5.</span> <span class="toc-text">5xx Server Error（服务端错误状态码）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#http-header"><span class="toc-number">2.3.</span> <span class="toc-text">HTTP Header</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#http-%E5%92%8C-https-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.4.</span> <span class="toc-text">HTTP 和 HTTPS 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#http-10-%E5%92%8C-11-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.5.</span> <span class="toc-text">HTTP 1.0 和 1.1 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#http-11-%E5%92%8C-20-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.6.</span> <span class="toc-text">HTTP 1.1 和 2.0 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#http-20-%E5%92%8C-30-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.7.</span> <span class="toc-text">HTTP 2.0 和 3.0 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#http-%E5%A6%82%E4%BD%95%E4%BF%9D%E5%AD%98%E7%94%A8%E6%88%B7%E7%8A%B6%E6%80%81"><span class="toc-number">2.8.</span> <span class="toc-text">HTTP 如何保存用户状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cookie-%E5%92%8C-session-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.9.</span> <span class="toc-text">Cookie 和 Session 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#uri-%E5%92%8C-url-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.10.</span> <span class="toc-text">URI 和 URL 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#get-%E5%92%8C-post-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.11.</span> <span class="toc-text">GET 和 POST 的区别</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#websocket"><span class="toc-number">3.</span> <span class="toc-text">WebSocket</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#websocket-%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">3.1.</span> <span class="toc-text">WebSocket 是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#websocket-%E5%92%8C-http-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.2.</span> <span class="toc-text">WebSocket 和 HTTP 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#websocket-%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B"><span class="toc-number">3.3.</span> <span class="toc-text">WebSocket 工作过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#websocket-%E5%92%8C-sse-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.4.</span> <span class="toc-text">WebSocket 和 SSE 的区别</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ping"><span class="toc-number">4.</span> <span class="toc-text">PING</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ping-%E5%91%BD%E4%BB%A4%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">4.1.</span> <span class="toc-text">PING 命令的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ping-%E5%91%BD%E4%BB%A4%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">4.2.</span> <span class="toc-text">PING 命令的工作原理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#dns"><span class="toc-number">5.</span> <span class="toc-text">DNS</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#dns-%E4%BD%9C%E7%94%A8"><span class="toc-number">5.1.</span> <span class="toc-text">DNS 作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#dns-%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">5.2.</span> <span class="toc-text">DNS 服务器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#dns-%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B"><span class="toc-number">5.3.</span> <span class="toc-text">DNS 解析过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#dns-%E8%BF%AD%E4%BB%A3%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B"><span class="toc-number">5.3.1.</span> <span class="toc-text">DNS 迭代解析过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dns-%E9%80%92%E5%BD%92%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B"><span class="toc-number">5.3.2.</span> <span class="toc-text">DNS 递归解析过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#dns-%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F"><span class="toc-number">5.4.</span> <span class="toc-text">DNS 报文格式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#dns-%E8%B5%84%E6%BA%90%E8%AE%B0%E5%BD%95rr"><span class="toc-number">5.5.</span> <span class="toc-text">DNS 资源记录（RR）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#dns-%E5%8A%AB%E6%8C%81"><span class="toc-number">5.6.</span> <span class="toc-text">DNS 劫持</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">5.7.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#tcp-%E4%B8%8E-udp"><span class="toc-number">6.</span> <span class="toc-text">TCP 与 UDP</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#tcp-%E4%B8%8E-udp-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">6.1.</span> <span class="toc-text">TCP 与 UDP 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tcp-%E5%92%8C-udp-%E9%80%89%E5%9E%8B"><span class="toc-number">6.2.</span> <span class="toc-text">TCP 和 UDP 选型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#http-%E5%9F%BA%E4%BA%8E-tcp-%E8%BF%98%E6%98%AF-udp"><span class="toc-number">6.3.</span> <span class="toc-text">HTTP 基于 TCP 还是 UDP？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-tcpudp-%E7%9A%84%E5%8D%8F%E8%AE%AE%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">6.4.</span> <span class="toc-text">使用 TCP&#x2F;UDP 的协议有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tcp-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-number">6.5.</span> <span class="toc-text">TCP 三次握手和四次挥手</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#tcp-%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="toc-number">6.5.1.</span> <span class="toc-text">TCP 建立连接 —— 三次握手</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B"><span class="toc-number">6.5.1.1.</span> <span class="toc-text">三次握手过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="toc-number">6.5.1.2.</span> <span class="toc-text">为什么要三次握手？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AE%A9%E5%8F%8C%E6%96%B9%E9%83%BD%E8%83%BD%E7%A1%AE%E8%AE%A4%E8%87%AA%E5%B7%B1%E4%B8%8E%E5%AF%B9%E6%96%B9%E7%9A%84%E6%94%B6%E5%8F%91%E5%8A%9F%E8%83%BD%E6%AD%A3%E5%B8%B8"><span class="toc-number">6.5.1.2.1.</span> <span class="toc-text">让双方都能确认自己与对方的收发功能正常</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%98%AF%E4%B8%A4%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="toc-number">6.5.1.2.2.</span> <span class="toc-text">为什么不是两次握手？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%98%AF%E5%9B%9B%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="toc-number">6.5.1.2.3.</span> <span class="toc-text">为什么不是四次握手？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC-2-%E6%AC%A1%E6%8F%A1%E6%89%8B%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%BC%A0%E5%9B%9E%E4%BA%86-ack%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81%E9%A2%9D%E5%A4%96%E4%BC%A0%E5%9B%9E-syn"><span class="toc-number">6.5.1.3.</span> <span class="toc-text">第 2 次握手服务端传回了 ACK，为什么还要额外传回 SYN？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%8F%AF%E4%BB%A5%E6%90%BA%E5%B8%A6%E6%95%B0%E6%8D%AE%E5%90%97"><span class="toc-number">6.5.1.4.</span> <span class="toc-text">三次握手过程中可以携带数据吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%8A%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97%E5%92%8C%E5%85%A8%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97"><span class="toc-number">6.5.1.5.</span> <span class="toc-text">半连接队列和全连接队列</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tcp-%E6%96%AD%E5%BC%80%E8%BF%9E%E6%8E%A5%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-number">6.5.2.</span> <span class="toc-text">TCP 断开连接 —— 四次挥手</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E8%BF%87%E7%A8%8B"><span class="toc-number">6.5.2.1.</span> <span class="toc-text">四次挥手过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-number">6.5.2.2.</span> <span class="toc-text">为什么要四次挥手？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E6%8A%8A%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%8F%91%E9%80%81%E7%9A%84-ack-%E5%92%8C-fin-%E5%90%88%E5%B9%B6%E5%8F%98%E4%B8%BA%E4%B8%89%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-number">6.5.2.3.</span> <span class="toc-text">为什么不能把服务端发送的 ACK 和 FIN 合并，变为三次挥手？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%8C%A5%E6%89%8B%E6%97%B6%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%9A%84-ack-%E6%B2%A1%E6%9C%89%E9%80%81%E8%BE%BE%E5%88%B0%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BC%9A%E6%80%8E%E6%A0%B7"><span class="toc-number">6.5.2.4.</span> <span class="toc-text">如果第二次挥手时服务端的 ACK 没有送达到客户端，会怎样？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%AC%AC%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E5%90%8E%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%BF%98%E9%9C%80%E8%A6%81%E7%AD%89%E5%BE%852msl%E6%8A%A5%E6%96%87%E6%AE%B5%E7%9A%84%E6%9C%80%E9%95%BF%E5%AF%BF%E5%91%BD%E7%9A%84%E6%97%B6%E9%97%B4%E5%90%8E%E6%89%8D%E8%83%BD%E8%BF%9B%E5%85%A5-closed-%E7%8A%B6%E6%80%81"><span class="toc-number">6.5.2.5.</span> <span class="toc-text">为什么第四次挥手后，客户端还需要等待 2*MSL（报文段的最长寿命）的时间后，才能进入 CLOSED 状态？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83-2"><span class="toc-number">6.5.3.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tcp-%E4%BC%A0%E8%BE%93%E5%8F%AF%E9%9D%A0%E6%80%A7"><span class="toc-number">6.6.</span> <span class="toc-text">TCP 传输可靠性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#tcp-%E4%BC%A0%E8%BE%93%E5%8F%AF%E9%9D%A0%E6%80%A7%E6%A6%82%E8%A7%88"><span class="toc-number">6.6.1.</span> <span class="toc-text">TCP 传输可靠性概览</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tcp-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6"><span class="toc-number">6.6.2.</span> <span class="toc-text">TCP 流量控制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#tcp-%E5%8F%91%E9%80%81%E7%AA%97%E5%8F%A3"><span class="toc-number">6.6.2.1.</span> <span class="toc-text">TCP 发送窗口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#tcp-%E6%8E%A5%E6%94%B6%E7%AA%97%E5%8F%A3"><span class="toc-number">6.6.2.2.</span> <span class="toc-text">TCP 接收窗口</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tcp-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="toc-number">6.6.3.</span> <span class="toc-text">TCP 拥塞控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#arq-%E5%8D%8F%E8%AE%AE"><span class="toc-number">6.6.4.</span> <span class="toc-text">ARQ 协议</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%81%9C%E6%AD%A2%E7%AD%89%E5%BE%85-arq-%E5%8D%8F%E8%AE%AE"><span class="toc-number">6.6.4.1.</span> <span class="toc-text">停止等待 ARQ 协议</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9E%E7%BB%AD-arq-%E5%8D%8F%E8%AE%AE"><span class="toc-number">6.6.4.2.</span> <span class="toc-text">连续 ARQ 协议</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tcp-%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0"><span class="toc-number">6.6.5.</span> <span class="toc-text">TCP 超时重传</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83-3"><span class="toc-number">6.6.6.</span> <span class="toc-text">参考</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ip"><span class="toc-number">7.</span> <span class="toc-text">IP</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ip-%E4%BD%9C%E7%94%A8"><span class="toc-number">7.1.</span> <span class="toc-text">IP 作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ip-%E5%9C%B0%E5%9D%80"><span class="toc-number">7.2.</span> <span class="toc-text">IP 地址</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="toc-number">8.</span> <span class="toc-text">重要知识点</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9C%B0%E5%9D%80%E6%A0%8F%E8%BE%93%E5%85%A5-url-%E5%B9%B6%E6%8C%89%E4%B8%8B%E5%9B%9E%E8%BD%A6%E9%94%AE%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA%E8%83%8C%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88"><span class="toc-number">8.1.</span> <span class="toc-text">在浏览器地址栏输入 URL 并按下回车键到页面展示，背后发生了什么？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%B1%82"><span class="toc-number">8.1.1.</span> <span class="toc-text">应用层</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#url"><span class="toc-number">8.1.1.1.</span> <span class="toc-text">URL</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#url-%E7%9A%84%E7%BB%84%E6%88%90%E7%BB%93%E6%9E%84"><span class="toc-number">8.1.1.2.</span> <span class="toc-text">URL 的组成结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#dns-%E5%8D%8F%E8%AE%AE"><span class="toc-number">8.1.1.3.</span> <span class="toc-text">DNS 协议</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#httphttps"><span class="toc-number">8.1.1.4.</span> <span class="toc-text">HTTP&#x2F;HTTPS</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E8%BE%93%E5%B1%82"><span class="toc-number">8.1.2.</span> <span class="toc-text">传输层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%B1%82"><span class="toc-number">8.1.3.</span> <span class="toc-text">网络层</span></a></li></ol></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li class="active"><a href="/computer-base/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%B8%B8%E9%97%AE%E5%85%AB%E8%82%A1%E6%96%87/" rel="bookmark" title="计算机网络常问八股文">计算机网络常问八股文</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="范特东东东" data-src="/images/avatar.jpg"><p class="name" itemprop="name">范特东东东</p><div class="description" itemprop="description"></div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">64</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">23</span> <span class="name">分类</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hqeDE1OQ==" title="https:&#x2F;&#x2F;github.com&#x2F;hjx159"><i class="ic i-github"></i></span> <span class="exturl item email" data-url="bWFpbHRvOjgxMjE0MzI4MEBxcS5jb20=" title="mailto:812143280@qq.com"><i class="ic i-envelope"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><a href="/categories/photography/" rel="section"><i class="ic i-photography"></i>摄影</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于我</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/java/" title="分类于 Java">Java</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/" title="分类于 Java基础">Java基础</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/java-knowledge/" title="分类于 Java基础-知识点">Java基础-知识点</a></div><span><a href="/java/java-se/java-knowledge/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E5%AE%8B%E7%BA%A2%E5%BA%B7_%E7%AC%AC06%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/" title="宋红康_第06章_面向对象编程（基础）">宋红康_第06章_面向对象编程（基础）</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/java/" title="分类于 Java">Java</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/" title="分类于 Java基础">Java基础</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/java-excise/" title="分类于 Java基础-真题">Java基础-真题</a></div><span><a href="/java/java-se/java-excise/%E7%AC%AC11%E7%AB%A0%EF%BC%9A%E9%9A%8F%E5%A0%82%E5%A4%8D%E4%B9%A0%E4%B8%8E%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%A2%98%EF%BC%88%E5%B8%B8%E7%94%A8%E7%B1%BB%E4%B8%8E%E5%9F%BA%E7%A1%80API%EF%BC%89/" title="宋红康_第11章：常用类与基础API">宋红康_第11章：常用类与基础API</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/database/" title="分类于 数据库">数据库</a> <i class="ic i-angle-right"></i> <a href="/categories/database/redis/" title="分类于 Redis">Redis</a></div><span><a href="/database/redis/Redis-JavaGuide/" title="Redis-JavaGuide">Redis-JavaGuide</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/photography/" title="分类于 摄影">摄影</a></div><span><a href="/photography/%E8%88%B9%E5%A4%AB%E8%9C%80%E9%BB%8D/" title="船夫蜀黍">船夫蜀黍</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/java/" title="分类于 Java">Java</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/" title="分类于 Java基础">Java基础</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/java-knowledge/" title="分类于 Java基础-知识点">Java基础-知识点</a></div><span><a href="/java/java-se/java-knowledge/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E5%AE%8B%E7%BA%A2%E5%BA%B7_%E7%AC%AC15%E7%AB%A0_File%E7%B1%BB%E4%B8%8EIO%E6%B5%81/" title="宋红康_第15章_File类与IO流">宋红康_第15章_File类与IO流</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/java/" title="分类于 Java">Java</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/" title="分类于 Java基础">Java基础</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/java-excise/" title="分类于 Java基础-真题">Java基础-真题</a></div><span><a href="/java/java-se/java-excise/%E7%AC%AC10%E7%AB%A0%EF%BC%9A%E9%9A%8F%E5%A0%82%E5%A4%8D%E4%B9%A0%E4%B8%8E%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%A2%98%EF%BC%88%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%89/" title="宋红康_第10章：多线程">宋红康_第10章：多线程</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/java/" title="分类于 Java">Java</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/" title="分类于 Java基础">Java基础</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/java-knowledge/" title="分类于 Java基础-知识点">Java基础-知识点</a></div><span><a href="/java/java-se/java-knowledge/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E5%AE%8B%E7%BA%A2%E5%BA%B7_%E7%AC%AC08%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89/" title="宋红康_第08章_面向对象编程(高级)">宋红康_第08章_面向对象编程(高级)</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/java/" title="分类于 Java">Java</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/" title="分类于 Java基础">Java基础</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/java-knowledge/" title="分类于 Java基础-知识点">Java基础-知识点</a></div><span><a href="/java/java-se/java-knowledge/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E5%AE%8B%E7%BA%A2%E5%BA%B7_%E7%AC%AC13%E7%AB%A0_%E6%B3%9B%E5%9E%8B/" title="宋红康_第13章_泛型(Generic)">宋红康_第13章_泛型(Generic)</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/java/" title="分类于 Java">Java</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/" title="分类于 Java基础">Java基础</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/java-excise/" title="分类于 Java基础-真题">Java基础-真题</a></div><span><a href="/java/java-se/java-excise/%E7%AC%AC18%E7%AB%A0%EF%BC%9A%E9%9A%8F%E5%A0%82%E5%A4%8D%E4%B9%A0%E4%B8%8E%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%A2%98%EF%BC%88JDK8-17%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%89/" title="宋红康_第18章：JDK8-17新特性">宋红康_第18章：JDK8-17新特性</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/distributed-microservices/" title="分类于 分布式微服务">分布式微服务</a></div><span><a href="/distributed-microservices/ShardingSphere/" title="ShardingSphere">ShardingSphere</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">范特东东东 @ fantedong</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">1.9m 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">29:26</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"computer-base/计算机网络常问八股文/",favicon:{show:"(●´3｀●)欢迎回来",hide:"(〃＞皿＜)你快回来"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hrmmi -->