<!-- build time:Sun Jun 02 2024 14:10:43 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="水文 & 摄影" href="http://example.com/rss.xml"><link rel="alternate" type="application/atom+xml" title="水文 & 摄影" href="http://example.com/atom.xml"><link rel="alternate" type="application/json" title="水文 & 摄影" href="http://example.com/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><link rel="canonical" href="http://example.com/computer-base/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%B8%B8%E9%97%AE%E5%85%AB%E8%82%A1%E6%96%87/"><title>操作系统常问八股文 - 操作系统 - 计算机基础 | fantedong = 水文 & 摄影 = 为了能更好地查看图片，你需要一点魔法</title><meta name="generator" content="Hexo 6.3.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">操作系统常问八股文</h1><div class="meta"><span class="item" title="创建时间：2024-05-26 22:09:53"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2024-05-26T22:09:53+08:00">2024-05-26</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>25k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>23 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">fantedong</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://pic.imgdb.cn/item/6554c7d9c458853aefd85660.jpg"></li><li class="item" data-background-image="https://pic.imgdb.cn/item/656f27bac458853aef5f729f.jpg"></li><li class="item" data-background-image="https://pic.imgdb.cn/item/656f2723c458853aef5c1279.jpg"></li><li class="item" data-background-image="https://pic.imgdb.cn/item/657b3571c458853aef5fbdad.jpg"></li><li class="item" data-background-image="https://pic.imgdb.cn/item/6554c7d9c458853aefd857b8.jpg"></li><li class="item" data-background-image="https://pic.imgdb.cn/item/6553a0abc458853aef3aa4f3.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/computer-base/" itemprop="item" rel="index" title="分类于 计算机基础"><span itemprop="name">计算机基础</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/computer-base/operating-system/" itemprop="item" rel="index" title="分类于 操作系统"><span itemprop="name">操作系统</span></a><meta itemprop="position" content="2"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://example.com/computer-base/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%B8%B8%E9%97%AE%E5%85%AB%E8%82%A1%E6%96%87/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="范特东东东"><meta itemprop="description" content="为了能更好地查看图片，你需要一点魔法, "></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="水文 & 摄影"></span><div class="body md" itemprop="articleBody"><p>这篇文章总结了一些我觉得比较重要的操作系统相关的问题比如 <strong>用户态和内核态、系统调用、进程和线程、死锁、内存管理、虚拟内存、文件系统</strong>等等。</p><p>这篇文章只是对一些操作系统比较重要概念的一个概览，深入学习的话，建议大家还是老老实实地去看书。另外， 这篇文章的很多内容参考了《现代操作系统》第三版这本书，非常感谢。</p><p>开始本文的内容之前，我们先聊聊为什么要学习操作系统。</p><ul><li>从对个人能力方面提升来说：操作系统中的很多思想、很多经典的算法，你都可以在我们日常开发使用的各种工具或者框架中找到它们的影子。比如说我们开发的系统使用的缓存（比如 Redis）和操作系统的<font color="cornflowerblue">高速缓存</font>就很像。CPU 中的高速缓存有很多种，不过大部分都是为了<font color="red">解决 CPU 处理速度和内存处理速度不对等的问题</font>。我们还可以把内存看作外存的高速缓存，程序运行的时候我们把外存的数据复制到内存，由于内存的处理速度远远高于外存，这样提高了处理速度。同样地，我们使用的 <font color="cornflowerblue">Redis 缓存</font>就是为了<font color="red">解决程序处理速度和访问常规关系型数据库速度不对等的问题</font>。高速缓存一般会按照<font color="red">局部性原理（2-8 原则）</font>根据相应的<font color="red">淘汰算法</font>保证缓存中的数据是经常会被访问的。我们平常使用的 Redis 缓存很多时候也会按照 2-8 原则去做，很多淘汰算法都和操作系统中的类似。既说了 2-8 原则，那就不得不提<font color="red">命中率</font>了，这是所有缓存概念都通用的。简单来说也就是你要访问的数据有多少能直接在缓存中直接找到。命中率高的话，一般表明你的缓存设计比较合理，系统处理速度也相对较快。</li><li>从面试角度来说：尤其是校招，对于操作系统方面知识的考察是非常非常多的。</li></ul><p><strong>简单来说，学习操作系统能够提高自己思考的深度以及对技术的理解力，并且，操作系统方面的知识也是面试必备。</strong></p><h1 id="操作系统基础"><a class="anchor" href="#操作系统基础">#</a> 操作系统基础</h1><h2 id="操作系统的概念"><a class="anchor" href="#操作系统的概念">#</a> 操作系统的概念</h2><p>通过以下四点可以概括操作系统（Operating System，简称 OS）到底是什么：</p><ol><li>操作系统是管理计算机硬件与软件资源的程序，是计算机的基石。</li><li><strong>操作系统本质上是一个运行在计算机上的软件程序 ，主要用于管理计算机硬件和软件资源。</strong> 举例：运行在你电脑上的所有应用程序都通过操作系统来调用系统内存以及磁盘等等硬件。</li><li>操作系统的存在屏蔽了硬件层的复杂性。 操作系统就像是硬件使用的负责人，统筹着各种相关事项。</li><li><font color="red">操作系统的内核（Kernel）是核心，它负责系统的内存管理，硬件设备的管理，文件系统的管理以及应用程序的管理。</font> 内核是连接应用程序和硬件的桥梁，决定着系统的性能和稳定性。</li></ol><p>很多人容易把操作系统的内核（Kernel）和中央处理器（CPU，Central Processing Unit）弄混。你可以简单从下面两点来区别：</p><ol><li>操作系统的内核（Kernel）属于操作系统层面，而 CPU 属于硬件。</li><li><font color="red">CPU 主要提供运算，处理各种指令的能力</font>。<font color="red">内核（Kernel）主要负责系统管理，比如内存管理，它屏蔽了对硬件的操作</font>。</li></ol><p>下图清晰说明了应用程序、内核、CPU 这三者的关系。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/20240527155756.png" alt="image.png"></p><h2 id="操作系统的功能"><a class="anchor" href="#操作系统的功能">#</a> 操作系统的功能</h2><p>从资源管理的角度来看，操作系统有 6 大功能：</p><ol><li><strong>进程和线程的管理</strong>：进程的创建、撤销、阻塞、唤醒，进程间的通信等。</li><li><strong>存储管理</strong>：内存的分配和管理、外存（磁盘等）的分配和管理等。</li><li><strong>文件管理</strong>：文件的读、写、创建及删除等。</li><li><strong>设备管理</strong>：完成设备（输入输出设备和外部存储设备等）的请求或释放，以及设备启动等功能。</li><li><strong>网络管理</strong>：操作系统负责管理计算机网络的使用。网络是计算机系统中连接不同计算机的方式，操作系统需要管理计算机网络的配置、连接、通信和安全等，以提供高效可靠的网络服务。</li><li><strong>安全管理</strong>：用户的身份认证、访问控制、文件加密等，以防止非法用户对系统资源的访问和操作。</li></ol><h2 id="用户态和内核态"><a class="anchor" href="#用户态和内核态">#</a> ☆用户态和内核态</h2><h3 id="用户态和内核态是什么"><a class="anchor" href="#用户态和内核态是什么">#</a> 用户态和内核态是什么</h3><p>根据进程访问资源的特点，我们可以把进程在系统上的运行分为两个级别：</p><ul><li><font color="cornflowerblue">用户态（User Mode）</font> : 用户态运行的进程可以直接<font color="red">读取用户程序的数据，拥有较低的权限</font>。当应用程序需要执行某些需要特殊权限的操作，例如读写磁盘、网络通信等，就需要向操作系统发起<strong>系统调用请求</strong>，进入内核态。</li><li><font color="cornflowerblue">内核态（Kernel Mode）</font>：内核态运行的进程几乎可以<font color="red">访问计算机的任何资源</font>，包括系统的内存空间、设备、驱动程序等，不受限制，<font color="red">拥有非常高的权限</font>。</li></ul><p>当操作系统接收到进程的系统调用请求时，就会从用户态切换到内核态，执行相应的系统调用，并将结果返回给进程，最后再从内核态切换回用户态。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/20240527161117.png" alt="image.png"></p><p><strong>内核态相比用户态拥有更高的特权级别，因此能够执行更底层、更敏感的操作</strong>。不过，由于进入内核态需要付出较高的开销（需要进行一系列的上下文切换和权限检查），应该尽量减少进入内核态的次数，以提高系统的性能和稳定性。</p><h3 id="为什么要划分用户态和内核态"><a class="anchor" href="#为什么要划分用户态和内核态">#</a> 为什么要划分用户态和内核态</h3><p>只有一个内核态不行吗？</p><ul><li>在 CPU 的所有指令中，有一些指令是比较危险的。比如<font color="red">内存分配、设置时钟、IO 处理</font>等，如果所有的程序都能使用这些指令的话，会对系统的正常运行造成灾难性地影响。因此，我们<strong>需要限制这些危险指令只能内核态中运行</strong>。这些只能由操作系统内核态执行的指令也被叫做<font color="red">特权指令</font>。</li><li>如果计算机系统中只有一个内核态，那么所有程序或进程都必须共享系统资源，例如<font color="red">内存、CPU、硬盘</font>等，这<strong>将导致共享的系统资源的竞争和冲突</strong>，从而影响系统性能和效率。</li><li>并且，这样也<strong>会让系统的安全性降低</strong>，毕竟所有程序或进程都具有相同的特权级别和访问权限。</li></ul><p>因此，同时具有用户态和内核态主要是为了保证计算机系统的安全性、稳定性和性能。</p><h3 id="用户态和内核态是如何切换的"><a class="anchor" href="#用户态和内核态是如何切换的">#</a> 用户态和内核态是如何切换的</h3><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/20240527161918.png" alt="image.png"></p><p>用户态切换到内核态的 3 种方式：</p><ol><li><strong>系统调用（Trap）</strong>：用户态进程<font color="red">主动要求</font>切换到内核态的一种方式，主要是为了使用内核态才能做的事情，比如读取磁盘资源。系统调用的机制，其核心还是使用了操作系统为用户特别开放的一个中断来实现。</li><li><strong>中断（Interrupt）</strong>：当外围设备完成用户请求的操作后，会向 CPU 发出相应的中断信号，这时 CPU 会暂停执行下一条即将要执行的指令，转而去<font color="red">执行与中断信号对应的处理程序</font>。如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。</li><li><strong>异常（Exception）</strong>：当 CPU 在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切<font color="red">换到处理此异常的内核相关程序中</font>，也就转到了内核态，比如缺页异常。</li></ol><p>在系统的处理上，中断和异常类似，都是通过<font color="red">中断向量表</font>来找到相应的处理程序进行处理。区别在于，中断来自处理器外部，不是由任何一条专门的指令造成，而异常是执行当前指令的结果。</p><h2 id="系统调用"><a class="anchor" href="#系统调用">#</a> 系统调用</h2><h3 id="系统调用的概念"><a class="anchor" href="#系统调用的概念">#</a> 系统调用的概念</h3><p>我们运行的程序基本都是运行在用户态，如果我们调用操作系统提供的内核态级别的子功能咋办呢？那就需要系统调用了！</p><p>也就是说，<strong>在我们运行的用户（态）程序中，凡是与内核态级别的资源有关的操作（如设备管理、文件管理、进程控制、内存管理等)，都必须通过系统调用方式向操作系统提出服务请求，并由操作系统代为完成</strong>。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/20240527195611.png" alt="image.png"></p><p>这些系统调用按功能大致可分为如下几类：</p><ul><li><strong>设备管理</strong>：完成设备（输入输出设备和外部存储设备等）的请求或释放，以及设备启动等功能。</li><li><strong>文件管理</strong>：完成文件的读、写、创建及删除等功能。</li><li><strong>进程管理</strong>：进程的创建、撤销、阻塞、唤醒，进程间的通信等功能。</li><li><strong>内存管理</strong>：完成内存的分配、回收以及获取作业占用内存区大小及地址等功能。</li></ul><p>系统调用和普通库函数调用非常相似，只是<font color="red">系统调用由操作系统内核提供，运行于内核态</font>，而普通的库函数调用由函数库或用户自己提供，运行于用户态。</p><p>总结：<strong>系统调用是应用程序与操作系统之间进行交互的一种方式，通过系统调用，应用程序可以访问操作系统底层资源，例如设备、文件、网络等</strong>。</p><h3 id="系统调用的过程"><a class="anchor" href="#系统调用的过程">#</a> 系统调用的过程</h3><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/20240527200311.png" alt="image.png"></p><p>系统调用的过程可以简单分为以下几个步骤：</p><ol><li><strong>用户程序中断</strong>：用户态的程序发起系统调用，因为系统调用中涉及一些特权指令（只能由操作系统内核态执行的指令），用户态程序权限不足，因此会中断执行，也就是 Trap（Trap 是一种中断）。</li><li><strong>切换至内核态，执行系统调用</strong>：发生中断后，当前 CPU 执行的程序会中断，跳转到内核中的中断处理程序。内核程序开始执行，也就是开始处理系统调用。</li><li><strong>系统调用返回，切换回用户态</strong>：内核处理完成后，主动触发 Trap，这样会再次中断，切换回用户态工作。</li></ol><h1 id="进程和线程"><a class="anchor" href="#进程和线程">#</a> 进程和线程</h1><h2 id="进程和线程的概念"><a class="anchor" href="#进程和线程的概念">#</a> 进程和线程的概念</h2><ul><li><font color="cornflowerblue">进程（Process）</font>是指<strong>计算机中正在运行的一个程序实例</strong>。举例：你打开的微信就是一个进程。</li><li><font color="cornflowerblue">线程（Thread）</font>也被称为<font color="red">轻量级进程</font>，更加轻量。<strong>多个线程可以在同一个进程中同时执行，并且共享进程的资源，比如内存空间、文件句柄、网络连接等</strong>。举例：你打开的微信里就有一个线程专门用来拉取别人发你的最新的消息。</li></ul><h2 id="进程和线程的关系区别"><a class="anchor" href="#进程和线程的关系区别">#</a> ☆进程和线程的关系 / 区别</h2><p>下图是 Java 8 及之后的 JVM 内存结构，我们从 JVM 的角度来说一下线程和进程之间的关系吧！</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/68747470733a2f2f7365617a65616e2e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f696d672f4a6176612f4a564d2d4a617661382545352538362538352545352541442539382545372542422539332545362539452538342545352539422542452e706e67" alt="img"></p><center>Java 运行时数据区域（JDK1.8 之后）</center><p>从上图可以看出：一个进程中可以有多个线程，多个线程共享进程的<strong>堆</strong>和<strong>方法区</strong> (JDK1.8 之后的元空间) 资源，但是每个线程有自己的<strong>程序计数器</strong>、<strong>虚拟机栈</strong> 和 <strong>本地方法栈</strong>。</p><p>总结：</p><ul><li><strong>线程是进程划分成的更小的运行单位</strong>，一个进程在其执行的过程中可以产生多个线程。</li><li>线程和进程最大的不同在于，<strong>各进程基本上是独立的，而各线程则不一定</strong>，因为同一进程中的线程极有可能会相互影响。</li><li><strong>线程执行开销小，但不利于资源的管理和保护</strong>；而进程正相反。</li></ul><h2 id="线程的必要性"><a class="anchor" href="#线程的必要性">#</a> 线程的必要性</h2><ul><li>进程的切换开销大，<strong>线程切换的成本较低</strong>。</li><li><strong>线程更轻量</strong>，一个进程可以创建多个线程。</li><li><strong>多个线程可以并发处理不同的任务</strong>，更有效地利用了多处理器和多核计算机。而进程只能在一个时间干一件事，如果在执行过程中遇到阻塞问题，比如 IO 阻塞，就会挂起直到结果返回。</li><li><strong>同一进程内的线程共享内存和文件，且线程之间的通信无需调用内核</strong>。</li></ul><h2 id="多线程的必要性"><a class="anchor" href="#多线程的必要性">#</a> 多线程的必要性</h2><p>先从总体上来说：</p><ul><li>从计算机底层来说：线程可以比作是轻量级的进程，是程序执行的最小单位，<strong>线程间的切换和调度的成本远远小于进程</strong>。另外，多核 CPU 时代意味着<strong>多个线程可以同时运行，这减少了线程上下文切换的开销</strong>。</li><li>从当代互联网发展趋势来说：现在的系统动不动就要求百万级甚至千万级的并发量，而多线程并发编程正是开发高并发系统的基础，利用好多线程机制可以大大<strong>提高系统整体的并发能力以及性能</strong>。</li></ul><p>再深入到计算机底层来探讨：</p><ul><li>单核时代：在单核时代多线程主要是为了<strong>提高单进程利用 CPU 和 IO 系统的效率</strong>。 假设只运行了一个 Java 进程的情况，当我们请求 IO 的时候，如果 Java 进程中只有一个线程，此线程被 IO 阻塞，则整个进程被阻塞。CPU 和 IO 设备只有一个在运行，那么可以简单地说系统整体效率只有 50%。当使用多线程的时候，一个线程被 IO 阻塞，其他线程还可以继续使用 CPU。从而提高了 Java 进程利用系统资源的整体效率。</li><li>多核时代：多核时代多线程主要是为了<strong>提高进程利用多核 CPU 的能力</strong>。举个例子：假如我们要计算一个复杂的任务，我们只用一个线程的话，不论系统有几个 CPU 核心，都只会有一个 CPU 核心被利用到。而创建多个线程，这些线程可以被映射到底层多个 CPU 上执行，在任务中的多个线程没有资源竞争的情况下，任务执行的效率会有显著性的提高，约等于（单核时执行时间 / CPU 核心数）。</li></ul><h2 id="线程间的同步方式"><a class="anchor" href="#线程间的同步方式">#</a> 线程间的同步方式</h2><p>线程同步是两个或多个共享关键资源的线程的并发执行。应该同步线程，<font color="red">以避免共享关键资源的使用冲突</font>。</p><p>下面是几种常见的线程同步的方式：</p><ol><li><strong>互斥锁（Mutex）</strong>：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。<font color="red">比如 Java 中的 <code>synchronized</code> 关键词和各种 <code>Lock</code> </font>。</li><li><strong>读写锁（Read-Write Lock）</strong>：允许多个线程同时读取共享资源，但只有一个线程可以对共享资源进行写操作。</li><li><strong>信号量 (Semaphore)</strong>：它允许同一时刻多个线程访问同一资源，但是需要<font color="red">控制同一时刻访问此资源的最大线程数量</font>。</li><li><strong>屏障（Barrier）</strong>：屏障是一种同步原语，用于<font color="red">等待多个线程到达某个点再一起继续执行</font>。当一个线程到达屏障时，它会停止执行并等待其他线程到达屏障，直到所有线程都到达屏障后，它们才会一起继续执行。<font color="red">比如 Java 中的 <code>CyclicBarrier</code> </font>。</li><li><strong>事件 (Event)</strong> ：Wait/Notify：通过<font color="red">通知操作</font>的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作。</li></ol><h2 id="pcb进程控制块"><a class="anchor" href="#pcb进程控制块">#</a> PCB：进程控制块</h2><p><code>PCB（Process Control Block）</code> 即<font color="cornflowerblue">进程控制块</font>，是操作系统中<strong>用来管理和跟踪进程的数据结构</strong>，<font color="red">每个进程都对应着一个独立的 PCB</font>。你可以将 PCB 视为进程的大脑。</p><p>当操作系统创建一个新进程时，会为该进程分配一个唯一的进程 ID，并且为该进程创建一个对应的进程控制块。当进程执行时，PCB 中的信息会不断变化，操作系统会根据这些信息来管理和调度进程。</p><p>PCB 主要包含下面几部分的内容：</p><ul><li><strong>进程的描述信息</strong>：包括进程的名称、标识符等等；</li><li><strong>进程的调度信息</strong>：包括进程阻塞原因、进程状态（就绪、运行、阻塞等）、进程优先级（标识进程的重要程度）等等；</li><li><strong>进程对资源的需求情况</strong>：包括 CPU 时间、内存空间、I/O 设备等等。</li><li><strong>进程打开的文件信息</strong>：包括文件描述符、文件类型、打开模式等等。</li><li><strong>处理机的状态信息</strong>（由处理机的各种寄存器中的内容组成的）：包括通用寄存器、指令计数器、程序状态字 PSW、用户栈指针。</li><li>……</li></ul><h2 id="进程的生命周期和状态"><a class="anchor" href="#进程的生命周期和状态">#</a> 进程的生命周期和状态</h2><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/20240527205030.png" alt="image.png"></p><p>一般把进程大致分为 5 种状态：</p><ul><li><strong>新建 (new)</strong>：进程正在被创建，尚未到就绪状态。</li><li><strong>就绪 (ready)</strong>：进程已处于准备运行状态，即<font color="red">进程获得了除了处理器之外的一切所需资源</font>，一旦得到处理器资源（处理器分配的时间片）即可运行。</li><li><strong>运行 (running)</strong>：进程正在处理器上运行 (单核 CPU 下任意时刻只有一个进程处于运行状态)。</li><li><strong>阻塞 (waiting)</strong>：又称为等待状态，进程正在<font color="red">等待某一事件</font>而暂停运行。如等待某资源为可用或等待 IO 操作完成。即使处理器空闲，该进程也不能运行。</li><li><strong>结束 (terminated)</strong>：进程正在从系统中消失。可能是进程正常结束或其他原因中断退出运行。</li></ul><h2 id="线程的生命周期和状态"><a class="anchor" href="#线程的生命周期和状态">#</a> ☆线程的生命周期和状态</h2><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20220524203355448.png" alt="image-20220524203355448"></p><p>一般把线程大致分为 6 种状态：</p><table><thead><tr><th>线程状态</th><th>导致状态发生条件</th></tr></thead><tbody><tr><td><font color="cornflowerblue">NEW（新建）</font></td><td>线程刚被创建，但还没有调用 <code>start()</code> 。只有线程对象，没有线程特征。</td></tr><tr><td><font color="cornflowerblue">RUNNABLE（运行）</font></td><td>线程调用了 <code>start()</code> ，可能正在<font color="cornflowerblue">RUNNING（运行中）</font>，也可能在<font color="cornflowerblue">READY（准备）</font>，这取决于操作系统处理器。</td></tr><tr><td><font color="cornflowerblue">BLOCKED（锁阻塞）</font></td><td>需要等待锁释放。当一个线程试图获取一个对象锁，而该对象锁被其他的线程持有，则该线程进入 Blocked 状态；当该线程持有锁时，该线程将变成 Runnable 状态。</td></tr><tr><td><font color="cornflowerblue">WAITING（无限等待）</font></td><td>表示该线程需要等待其他线程做出一些特定动作（通知或中断）。一个线程在等待另一个线程时，该线程进入 Waiting 状态，进入这个状态后不能自动唤醒，必须等待另一个线程调用 notify 或者 notifyAll 方法才能唤醒。</td></tr><tr><td><font color="cornflowerblue">TIME_WAITING（计时等待）</font></td><td>可以在指定的时间后自行返回，而不是像 WAITING 那样一直等待。有几个方法有超时参数，调用将进入 Timed Waiting 状态，这一状态将一直保持到超时期满或者接收到唤醒通知。带有超时参数的常用方法有 Thread.sleep 、Object.wait</td></tr><tr><td><font color="cornflowerblue">TERMINATED（结束）</font></td><td>表示该线程已经运行完毕。run 方法正常退出而死亡，或者因为没有捕获的异常终止了 run 方法而死亡。</td></tr></tbody></table><h2 id="进程间的通信方式"><a class="anchor" href="#进程间的通信方式">#</a> 进程间的通信方式</h2><blockquote><p>下面这部分总结参考了:<span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC9jMTAxNWY1ZmZhNzQ=">《进程间通信 IPC (InterProcess Communication)》</span> 这篇文章，推荐阅读，总结的非常不错。</p></blockquote><ol><li><strong>管道 / 匿名管道 (Pipes)</strong>：用于具有亲缘关系的<font color="red">父子进程间 / 兄弟进程间</font>的通信，只存在于<font color="red">内存</font>中的文件。</li><li><strong>有名管道 (Named Pipes)</strong> : 匿名管道由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道。有名管道严格遵循 <font color="red">先进先出 (First In First Out)</font> 。有名管道以<font color="red">磁盘文件</font>的方式存在，可以实现<font color="red">本机任意两个进程</font>通信。</li><li><strong>信号 (Signal)</strong>：信号是一种比较复杂的通信方式，用于<font color="red">通知接收进程某个事件已经发生</font>；</li><li><strong>消息队列 (Message Queuing)</strong>：消息队列是消息的链表，具有特定的格式，存放在内存中并由消息队列标识符标识。与管道（无名管道：只存在于内存中的文件；命名管道：存在于实际的磁盘介质或者文件系统）不同的是，消息队列存放在<font color="red">内核</font>中，只有在内核重启 (即，操作系统重启) 或者显式地删除一个消息队列时，该消息队列才会被真正的删除。消息队列可以实现<font color="red">消息的随机查询</font>，消息不一定要以先进先出的次序读取，也可以按消息的类型读取，比 FIFO 更有优势。<strong>消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。</strong></li><li><strong>信号量 (Semaphores)</strong>：信号量是一个<font color="red">计数器</font>，用于多进程对共享数据的访问，信号量的意图在于进程间同步。这种通信方式主要用于解决与同步相关的问题并避免竞争条件。</li><li><strong>共享内存 (Shared memory)</strong>：使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。<font color="red">可以说这是最有用的进程间通信方式</font>。</li><li><strong>套接字 (Sockets)</strong> : 此方法主要<font color="red">用于在客户端和服务器之间通过网络进行通信</font>。套接字是支持 TCP/IP 的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。</li></ol><h2 id="进程调度算法"><a class="anchor" href="#进程调度算法">#</a> ☆进程调度算法</h2><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/20240527211319.png" alt="image.png"></p><p>这是一个很重要的知识点！为了确定首先执行哪个进程以及最后执行哪个进程，<strong>目的是实现最大的 CPU 利用率</strong>，计算机科学家已经定义了一些算法，它们是：</p><ul><li><font color="cornflowerblue">先到先服务调度算法（FCFS，First Come, First Served）</font>：从就绪队列中选择一个<font color="red">最先进入该队列的进程</font>，为之分配资源，使它立即执行直到完成，或者发生某事件而被阻塞放弃占用 CPU 时再重新调度。</li><li><font color="cornflowerblue">短作业优先的调度算法（SJF，Shortest Job First）</font>：从就绪队列中选出一个<font color="red">估计运行时间最短的进程</font>，为之分配资源，使它立即执行直到完成，或者发生某事件而被阻塞放弃占用 CPU 时再重新调度。</li><li><font color="cornflowerblue">时间片轮转调度算法（RR，Round-Robin）</font>：时间片轮转调度是一种<font color="red">最古老，最简单，最公平，使用最广</font>的算法。<font color="red">每个进程被分配一个时间片段</font>，称作它的时间片，即该进程允许运行的时间。</li><li><font color="cornflowerblue">多级反馈队列调度算法（MFQ，Multi-level Feedback Queue）</font>：前面介绍的几种进程调度的算法都有一定的局限性。如短进程优先的调度算法，仅照顾了短进程而忽略了长进程。多级反馈队列调度算法<font color="red">既能使高优先级的作业得到响应，又能使短作业（进程）迅速完成</font>，因而它是目前<font color="red">被公认的一种较好的进程调度算法</font>，UNIX 操作系统采取的便是这种调度算法。</li><li><font color="cornflowerblue">优先级调度算法（Priority）</font>：为每个流程分配优先级，首先执行<font color="red">具有最高优先级的进程</font>，依此类推。具有相同优先级的进程以 FCFS 方式执行。可以根据内存要求，时间要求或任何其他资源要求来确定优先级。</li></ul><h2 id="僵尸进程和孤儿进程"><a class="anchor" href="#僵尸进程和孤儿进程">#</a> 僵尸进程和孤儿进程</h2><p>在 Unix/Linux 系统中，子进程通常是通过 <code>fork()</code> 系统调用<strong>创建</strong>的，该调用会创建一个新的进程，该进程是原有进程的一个<font color="red">副本</font>。子进程和父进程的运行是<font color="red">相互独立</font>的，它们各自拥有自己的 PCB，<font color="red">即使父进程结束了，子进程仍然可以继续运行</font>。</p><p>当一个进程调用 <code>exit()</code> 系统调用<strong>结束</strong>自己的生命时，内核会<font color="red">释放该进程的所有资源</font>，包括打开的文件、占用的内存等。但是，该进程对应的 <font color="red">PCB 依然存在</font>于系统中，这些信息只有在父进程调用 <code>wait()</code> 或 <code>waitpid()</code> 系统调用时才会被释放，以便让父进程得到子进程的状态信息。</p><p>这样的设计可以<strong>让父进程在子进程结束时仍能得到子进程的状态信息，并且可以防止出现 “僵尸进程”</strong>。</p><ul><li><font color="cornflowerblue">僵尸进程（zombie）</font>：子进程已经终止，但是<font color="red">其父进程仍在运行，且没有调用 <code>wait()</code> 或 <code>waitpid()</code> 等系统调用</font>来获取子进程的状态信息，释放子进程占用的资源，<strong>导致子进程的 PCB 依然存在于系统中，但无法被进一步使用</strong>。这种情况下，子进程被称为 “僵尸进程”。避免僵尸进程的产生，父进程需要及时调用 <code>wait()</code> 或 <code>waitpid()</code> 系统调用来回收子进程。</li><li><font color="cornflowerblue">孤儿进程</font>：<font color="red">其父进程已经终止或者不存在，但是该子进程仍在运行</font>。这种情况下，该进程就是孤儿进程。孤儿进程通常是由于父进程意外终止或未及时调用 <code>wait()</code> 或 <code>waitpid()</code> 等系统调用来回收子进程导致的。为了避免孤儿进程占用系统资源，<strong>操作系统会将孤儿进程的父进程设置为 <font color="cornflowerblue">init 进程</font>（进程号为 1），由它来回收孤儿进程的资源</strong>。</li></ul><p>Linux 下可以使用 Top 命令查找僵尸进程， <code>zombie</code> 值表示僵尸进程的数量，为 0 则代表没有僵尸进程。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/20240529162110.png" alt="image.png"></p><p>下面这个命令可以定位僵尸进程以及该僵尸进程的父进程：</p><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">ps</span> <span class="token parameter variable">-A</span> -ostat,ppid,pid,cmd <span class="token operator">|</span><span class="token function">grep</span> <span class="token parameter variable">-e</span> <span class="token string">'^[Zz]'</span></pre></td></tr></table></figure><h1 id="死锁"><a class="anchor" href="#死锁">#</a> 死锁</h1><h2 id="死锁的概念"><a class="anchor" href="#死锁的概念">#</a> 死锁的概念</h2><p><strong><font color="cornflowerblue">死锁（Deadlock）</font>是指两个（多个）进程 / 线程相互等待对方所占用的资源，进而导致同时阻塞的过程。死锁的产生会导致程序卡死，不解锁程序将永远无法进行下去。</strong></p><h2 id="死锁产生举例"><a class="anchor" href="#死锁产生举例">#</a> 死锁产生举例</h2><p>假设有两个进程 A 和 B，以及两个资源 1 和 2，它们的分配情况如下：</p><table><thead><tr><th>进程</th><th>占用资源</th><th>需求资源</th></tr></thead><tbody><tr><td>A</td><td>1</td><td>2</td></tr><tr><td>B</td><td>2</td><td>1</td></tr></tbody></table><p>如下图所示，进程 A 占用资源 1 并且请求资源 2，而进程 B 已经占用了资源 2 并请求资源 1。<font color="red">两个进程都在等待对方释放资源</font>，无法继续执行，陷入了死锁状态。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/20240530103117.png" alt="image.png"></p><h2 id="死锁产生举例的模拟代码"><a class="anchor" href="#死锁产生举例的模拟代码">#</a> 死锁产生举例的模拟代码</h2><p>以<a href="#%E6%AD%BB%E9%94%81%E4%B8%BE%E4%BE%8B">死锁举例</a>为例：线程 A 通过 <code>synchronized (resource1)</code> 获得 <code>resource1</code> 的监视器锁，然后通过 <code>Thread.sleep(1000);</code> 让线程 A 休眠 1s 为的是让线程 B 得到执行然后获取到 <code>resource2</code> 的监视器锁。线程 A 和线程 B 休眠结束了都开始企图请求获取对方的资源，然后这两个线程就会陷入互相等待的状态，这也就产生了死锁。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DeadLockDemo</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Object</span> resource1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 资源 1</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Object</span> resource2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 资源 2</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>resource1<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"get resource1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>                <span class="token keyword">try</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>                    <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>                <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>                <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"waiting get resource2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>                <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>resource2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"get resource2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>                <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token string">"线程 1"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre></pre></td></tr><tr><td data-num="21"></td><td><pre>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>resource2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"get resource2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>                <span class="token keyword">try</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>                    <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>                <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>                <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"waiting get resource1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>                <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>resource1<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="31"></td><td><pre>                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"get resource1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>                <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="33"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="34"></td><td><pre>        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token string">"线程 2"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="35"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="36"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>输出：</p><pre><code>Thread[线程 1,5,main]get resource1
Thread[线程 2,5,main]get resource2
Thread[线程 1,5,main]waiting get resource2
Thread[线程 2,5,main]waiting get resource1
</code></pre><h2 id="死锁产生的四个必要条件"><a class="anchor" href="#死锁产生的四个必要条件">#</a> ☆死锁产生的四个必要条件</h2><ol><li><strong>互斥</strong>：该资源必须处于非共享模式，即任意时刻只有一个进程可以使用。</li><li><strong>占有并等待</strong>：一个进程在等待一个被其他进程所占有的资源时，对自身已占有的资源保持不放。</li><li><strong>非抢占</strong>：资源不能被抢占。只能在持有资源的进程完成任务后，该资源才会被释放。</li><li><strong>循环等待</strong>：若干进程之间形成一种头尾相接的循环等待资源的关系。</li></ol><blockquote><p>例如，有一组等待进程 <code>&#123;P0, P1,..., Pn&#125;</code> 。 <code>P0</code> 等待的资源被 <code>P1</code> 占有， <code>P1</code> 等待的资源被 <code>P2</code> 占有，……， <code>Pn-1</code> 等待的资源被 <code>Pn</code> 占有， <code>Pn</code> 等待的资源被 <code>P0</code> 占有。</p></blockquote><p>注意 ⚠️：这四个条件是产生死锁的必要条件 ，也就是说只要系统发生死锁，这些条件必然成立，而<strong>只要上述条件任一不满足，就不会发生死锁</strong>。</p><h2 id="死锁的解决方法"><a class="anchor" href="#死锁的解决方法">#</a> ☆死锁的解决方法</h2><p>解决死锁的方法可以从多个角度去分析，一般的情况下，有<strong>预防，避免，检测和解除四种</strong>。</p><ul><li><strong>预防</strong>：采用某种策略，限制并发进程对资源的请求，<font color="red">使得死锁的 4 个必要条件在系统执行的任何时间上都不同时满足</font>。</li><li><strong>避免</strong>：在分配资源时，根据资源的使用情况<font color="red">提前做出预测</font>，从而避免死锁的发生</li><li><strong>检测</strong>：系统设有<font color="red">专门的死锁检测机构</font>，当死锁发生时，该机构能够检测死锁的发生，并精确地确定与死锁有关的进程和资源。</li><li><strong>解除</strong>：是与检测相配套的一种措施，用于<font color="red">将进程从死锁状态下解脱出来</font>。</li></ul><h3 id="死锁的预防"><a class="anchor" href="#死锁的预防">#</a> 死锁的预防</h3><p>死锁四大必要条件上面都已经列出来了，很显然，只要<font color="red">破坏四个必要条件中的任何一个</font>就能够预防死锁的发生。</p><ul><li><font color="cornflowerblue">破坏互斥条件</font>：使得资源是可以同时访问的，这是种简单的方法，磁盘就可以用这种方法管理，但是我们要知道，<strong>很多资源往往是不能同时访问的，所以破坏互斥条件是行不通的</strong>。</li><li><font color="cornflowerblue">破坏非抢占条件</font>：即采用抢占式调度算法，但该算法一般仅适用于主存资源和处理器资源的分配，<strong>并不适用于所有的资源，会导致资源利用率下降，所以破坏非抢占条件是行不通的</strong>。</li></ul><p>所以，<font color="red">一般比较实用的预防死锁的方法，是通过考虑破坏占有并等待条件和破坏循环等待条件</font>。</p><h4 id="静态分配策略破坏占有并等待条件"><a class="anchor" href="#静态分配策略破坏占有并等待条件">#</a> 静态分配策略（破坏占有并等待条件）</h4><p>静态分配策略<font color="cornflowerblue">破坏了占有并等待条件</font>。所谓静态分配策略，就是指<strong>一个进程必须在执行前就申请到了它所需要的全部资源</strong>，即只有当它所需要的资源都得到满足之后才开始执行。<font color="red">进程要么占有所有需要的资源然后开始执行，要么不占有资源</font>，不会出现占有一些资源等待一些资源的情况。</p><p>静态分配策略逻辑简单，实现也很容易，但这种策略<strong>严重地降低了资源利用率</strong>，因为在每个进程所占有的资源中，有些资源是在比较靠后的执行时间里采用的，甚至有些资源是在额外的情况下才使用的，这样就可能造成<font color="red">一个进程占有了一些几乎不用的资源，而使其他需要该资源的进程产生等待</font>的情况。</p><h4 id="层次分配策略破坏循环等待条件"><a class="anchor" href="#层次分配策略破坏循环等待条件">#</a> 层次分配策略（破坏循环等待条件）</h4><p>层次分配策略<font color="cornflowerblue">破坏了循环等待条件</font>。在层次分配策略下，<strong>所有的资源被分成了多个层次，一个进程得到某层的某一资源后，它只能再申请较高一层的资源；当一个进程要释放某层的某一资源时，必须先释放所占用的较高层的资源</strong>。按这种策略，是<font color="red">不可能出现循环等待链</font>的，因为那样的话，就出现了已经申请了较高层的资源，反而去申请了较低层的资源，不符合层次分配策略，证明略。</p><h3 id="死锁的避免银行家算法"><a class="anchor" href="#死锁的避免银行家算法">#</a> 死锁的避免（银行家算法）</h3><blockquote><p>上面提到的破坏死锁产生的四个必要条件之一就可以成功预防系统发生死锁，但是会导致<font color="red">低效的进程运行和资源使用率</font> 。</p></blockquote><p>死锁的避免相反，它的角度是<font color="red">允许系统中同时存在四个死锁必要条件</font> ，只要<font color="red">掌握并发进程中与每个进程有关的资源动态申请情况，做出明智和合理的资源分配选择</font>，仍然可以避免死锁，因为四大条件仅仅是产生死锁的必要条件。</p><p>我们将系统的状态分为<font color="cornflowerblue">安全状态</font>和<font color="cornflowerblue">不安全状态</font>，如果操作系统能够保证所有的进程在有限的时间内得到需要的全部资源，则称系统处于安全状态，否则说系统是不安全的。<strong>每当在为申请者分配资源前先测试系统状态，若把系统资源分配给申请者会产生死锁，则拒绝分配，否则接受申请，并为它分配资源</strong>。很显然，系统处于安全状态则不会发生死锁，系统若处于不安全状态则可能发生死锁。</p><p>那么如何保证系统保持在安全状态呢？最具有代表性的避免死锁算法就是 <strong><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNDE0MjcxL2FydGljbGUvZGV0YWlscy84MDI0NTcxNQ==">Dijkstra 的银行家算法</span></strong>，银行家算法用一句话表达就是：</p><blockquote><p>当一个进程申请使用资源的时候，银行家算法通过先<font color="red">试探分配</font>给该进程资源，然后通过<font color="red">安全性算法</font>判断分配后系统是否处于安全状态（即分配后的剩余资源是否能满足其他进程）。若不安全则<font color="red">试探分配作废</font>，让该进程继续等待；若能够进入到安全的状态，则就<font color="red">真的分配</font>资源给该进程。</p></blockquote><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/20240530123356.png" alt="image.png"></p><p>死锁的避免（银行家算法）<font color="red">改善了资源使用率低的问题</font> ，但是它<font color="red">要不断地检测每个进程对各类资源的占用和申请情况</font>，以及做<font color="red">安全性检查</font>，需要花费较多的时间。</p><h3 id="死锁的检测"><a class="anchor" href="#死锁的检测">#</a> 死锁的检测</h3><blockquote><p>对资源的分配加以限制可以预防和避免死锁的发生，但是<font color="red">二者都不利于各进程对系统资源的<strong>充分共享</strong></font>。</p></blockquote><p>解决死锁问题的另一条途径是<strong>死锁检测和解除</strong>。</p><blockquote><p>这里突然联想到了乐观锁和悲观锁：</p><ul><li>死锁的<font color="red">检测和解除就像是乐观锁</font>，分配资源时不去提前管会不会发生死锁了，等到真的死锁出现了再来解决</li><li>死锁的<font color="red">预防和避免更像是悲观锁</font>，总是觉得死锁会出现，所以在分配资源的时候就很谨慎</li></ul></blockquote><p>这种方法对资源的分配不加以任何限制，也不采取死锁避免措施，但系统 <font color="red">定时地运行一个 “死锁检测” 的程序</font>，判断系统内是否出现死锁，如果检测到系统发生了死锁，再采取措施去解除它。</p><h4 id="进程-资源分配图"><a class="anchor" href="#进程-资源分配图">#</a> 进程 - 资源分配图</h4><p>操作系统中的每一刻时刻的系统状态都可以用<strong>进程 - 资源分配图</strong>来表示，这是<font color="red">描述进程和资源申请及分配关系</font>的一种有向图，<font color="red">用于检测系统是否处于死锁状态</font>。</p><p>用一个方框表示每一个资源类，方框中的黑点表示该资源类中的各个资源，每个键进程用一个圆圈表示，用有向边来表示进程申请资源和资源被分配的情况。</p><p>图中 2-21 是进程 - 资源分配图的一个例子，其中共有三个资源类，每个进程的资源占有和申请情况已清楚地表示在图中。在这个例子中，由于<font color="red">存在占有和等待资源的环路</font> ，导致一组进程永远处于等待资源的状态，发生了死锁。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/20240601125708.png" alt="image.png"></p><p>进程 - 资源分配图中<strong>存在环路并不一定是发生了死锁（因为循环等待只是死锁的必要条件，而非充分条件）</strong>。图 2-22 便是一个有环路而无死锁的例子。虽然进程 P1 和进程 P3 分别占用了一个资源 R1 和一个资源 R2，并且因为等待另一个资源 R2 和另一个资源 R1 形成了环路，但进程 P2 和进程 P4 分别占有了一个资源 R1 和一个资源 R2，它们申请的资源得到了满足，在有限的时间里会归还资源，于是进程 P1 或 P3 都能获得另一个所需的资源，环路自动解除，系统也就不存在死锁状态了。</p><h4 id="死锁检测步骤"><a class="anchor" href="#死锁检测步骤">#</a> 死锁检测步骤</h4><p>知道了死锁检测的原理，我们可以利用下列死锁检测步骤编写一个死锁检测程序，检测系统是否产生了死锁。</p><ol><li><strong>无环路，无死锁</strong>：如果进程 - 资源分配图中无环路，则此时系统没有发生死锁。</li><li><strong>有环路，单资源，有死锁</strong>：如果进程 - 资源分配图中有环路，且每个资源类仅有一个资源，则系统中已经发生了死锁。</li><li><strong>有环路，多资源，未必死锁</strong>：如果进程 - 资源分配图中有环路，且涉及到的资源类有多个资源，此时系统未必会发生死锁。如果能在进程 - 资源分配图中找出一个<font color="red">既不阻塞又非独立的进程</font> ，该进程能够在有限的时间内归还占有的资源，也就是把边给消除掉了，重复此过程，直到能在有限的时间内<font color="red">消除所有的边</font> ，则不会发生死锁，否则会发生死锁。（消除边的过程类似于拓扑排序）。</li></ol><h3 id="死锁的解除"><a class="anchor" href="#死锁的解除">#</a> 死锁的解除</h3><p>当死锁检测程序检测到存在死锁发生时，应设法让其解除，让系统从死锁状态中恢复过来，常用的有以下<font color="red">四种</font>死锁的解除方法：</p><ol><li><strong>（不推荐）立即结束所有进程的执行，重新启动操作系统</strong>：这种方法简单，但以前所在的<font color="red">工作全部作废，损失很大</font>。</li><li><strong>（不推荐）撤销涉及死锁的所有进程，解除死锁后继续运行</strong>：这种方法<font color="red">能彻底打破死锁的循环等待条件，但将付出很大代价</font>。例如有些进程可能已经计算了很长时间，由于被撤销而使产生的部分结果也被消除了，再重新执行时还要再次进行计算。</li><li><strong>逐个撤销涉及死锁的进程，回收其资源直至死锁解除</strong>。</li><li><strong>抢占资源</strong>：从涉及死锁的一个或几个进程中抢占资源，把夺得的资源再分配给涉及死锁的进程直至死锁解除。</li></ol><h1 id="内存管理"><a class="anchor" href="#内存管理">#</a> 内存管理</h1><h2 id="内存管理的任务"><a class="anchor" href="#内存管理的任务">#</a> 内存管理的任务</h2><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/20240601131906.png" alt="image.png"></p><p>操作系统的内存管理非常重要，主要负责下面这些事情：</p><ul><li><strong>内存的分配与回收</strong>：对进程所需的内存进行分配和释放， <code>malloc</code> 函数：申请内存， <code>free</code> 函数：释放内存。</li><li><strong>地址转换</strong>：将程序中的虚拟地址转换成内存中的物理地址。</li><li><strong>内存扩充</strong>：当系统没有足够的内存时，利用<font color="red">虚拟内存技术</font>或<font color="red">自动覆盖技术</font>，从逻辑上扩充内存。</li><li><strong>内存映射</strong>：<font color="red">将一个文件直接映射到进程的进程空间中</font>，这样可以通过内存指针用读写内存的办法直接存取文件内容，速度更快。</li><li><strong>内存优化</strong>：通过调整<font color="red">内存分配策略和回收算法</font>来优化内存使用效率。</li><li><strong>内存安全</strong>：<font color="red">保证进程之间使用内存互不干扰</font>，避免一些恶意程序通过修改内存来破坏系统的安全性。</li><li>……</li></ul><h2 id="内存碎片"><a class="anchor" href="#内存碎片">#</a> 内存碎片</h2><p>内存碎片是由内存的申请和释放产生的，通常分为下面两种：</p><ul><li><strong>内部碎片</strong>：<font color="red">分配给进程，但未被使用的内存</font>。导致内部内存碎片的主要原因是，当采用固定比例比如 2 的幂次方进行内存分配时，进程所分配的内存可能会比其实际所需要的大。举个例子，一个进程只需要 65 字节的内存，但为其分配了 128（2^7） 大小的内存，那 63 字节的内存就成为了内部内存碎片。</li><li><strong>外部碎片</strong>：由于未分配的连续内存区域太小，以至于不能满足任意进程所需要的内存分配请求，<font color="red">这些小片段且不连续的内存空间</font>被称为外部碎片。也就是说，外部内存碎片指的是那些并未分配给进程但又不能使用的内存。我们后面介绍的<font color="red">分段机制</font>就会导致外部内存碎片。</li></ul><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/20240601132922.png" alt="image.png"></p><center>内部碎片、外部碎片</center><p>内存碎片会导致内存利用率下降，如何减少内存碎片是内存管理要非常重视的一件事情。</p><h2 id="内存管理的常见方式"><a class="anchor" href="#内存管理的常见方式">#</a> 内存管理的常见方式</h2><p>内存管理方式可以简单分为下面两种：</p><ul><li><strong>连续内存管理</strong>：为一个用户程序分配一个连续的内存空间，<font color="red">内存利用率一般不高</font>。</li><li><strong>非连续内存管理</strong>：允许一个程序使用的内存分布在离散或者说不相邻的内存中，相对<font color="red">更加灵活一些</font>。</li></ul><h3 id="连续内存管理"><a class="anchor" href="#连续内存管理">#</a> 连续内存管理</h3><p><strong>块式管理</strong> 是早期计算机操作系统的一种连续内存管理方式，会<font color="red">将内存分为几个固定大小的块，每个块中只包含一个进程</font>，存在严重的<font color="red">内存碎片问题</font>。如果程序运行需要内存的话，操作系统就分配给它一块，如果程序运行只需要很小的空间的话，分配的这块内存很大一部分几乎被浪费了。这些在每个块中未被利用的空间，我们称之为内部内存碎片。除了内部内存碎片之外，由于两个内存块之间可能还会有外部内存碎片，这些不连续的外部内存碎片由于太小了无法再进行分配。</p><p>在 Linux 系统中，连续内存管理采用了 <strong>伙伴系统（Buddy System）算法</strong> 来实现，这是一种经典的连续内存分配算法，可以有效解决外部内存碎片的问题。伙伴系统的主要思想是<font color="red">将内存按 2 的幂次划分</font>（每一块内存大小都是 2 的幂次比如 2^6=64 KB），<font color="red">并将相邻的内存块组合成一对伙伴</font>（注意：必须是相邻的才是伙伴）。</p><p>当进行内存分配时，伙伴系统会尝试找到大小最合适的内存块。<font color="red">如果找到的内存块过大，就将其一分为二</font>，分成两个大小相等的伙伴块。如果还是大的话，就继续切分，直到到达合适的大小为止。</p><p><font color="red">假设两块相邻的内存块都被释放，系统会将这两个内存块合并</font>，进而形成一个更大的内存块，以便后续的内存分配。这样就可以减少内存碎片的问题，提高内存利用率。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/20240601133740.png" alt="image.png"></p><center>伙伴系统（Buddy System）内存管理</center><p>虽然<font color="red">解决了外部碎片的问题</font>，但伙伴系统仍然<font color="red">存在内存利用率不高的问题（内部碎片）</font>。这主要是因为伙伴系统只能分配大小为 2^n 的内存块，因此当需要分配的内存大小不是 2^n 的整数倍时，会浪费一定的内存空间。举个例子：如果要分配 65 大小的内存快，依然需要分配 2^7=128 大小的内存块。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/20240601133807.png" alt="image.png"></p><center>伙伴系统内存浪费问题</center><p>对于内部内存碎片的问题，Linux 采用 <strong>SLAB</strong> 进行解决。由于这部分内容不是本篇文章的重点，这里就不详细介绍了。</p><h3 id="非连续内存管理"><a class="anchor" href="#非连续内存管理">#</a> 非连续内存管理</h3><p>非连续内存管理存在下面 3 种方式：</p><ul><li><strong><a href="#%E5%88%86%E6%AE%B5%E6%9C%BA%E5%88%B6">段式管理</a></strong>：以段（— 段连续的物理内存）的形式管理 / 分配物理内存。应用程序的<font color="red">虚拟地址空间被分为大小不等的<font color="cornflowerblue">段</font></font>。段是有实际意义的，每个段定义了一组逻辑信息，例如有主程序段 MAIN、子程序段 X、数据段 D 及栈段 S 等。</li><li><strong><a href="#%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B6">页式管理</a></strong>：<font color="red">把物理内存分为连续等长的<font color="cornflowerblue">物理页</font>，应用程序的虚拟地址空间也被划分为连续等长的<font color="cornflowerblue">虚拟页</font></font>，是现代操作系统广泛使用的一种内存管理方式。</li><li><strong><a href="#%E6%AE%B5%E9%A1%B5%E6%9C%BA%E5%88%B6">段页式管理（段 + 页）</a></strong>：结合了段式管理和页式管理的一种内存管理机制，<font color="red">把物理内存先分成若干段，每个段又继续分成若干大小相等的页</font>。</li></ul><h2 id="虚拟内存"><a class="anchor" href="#虚拟内存">#</a> 虚拟内存</h2><h3 id="虚拟内存的概念"><a class="anchor" href="#虚拟内存的概念">#</a> 虚拟内存的概念</h3><p><strong>虚拟内存（Virtual Memory）</strong> 是计算机系统内存管理非常重要的一个技术，本质上来说它只是<font color="red">逻辑存在</font>的，是一个假想出来的内存空间，主要作用是<font color="red">作为进程访问主存（物理内存）的桥梁</font>，并简化内存管理。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/20240601135605.png" alt="image.png"></p><h3 id="虚拟内存的作用"><a class="anchor" href="#虚拟内存的作用">#</a> 虚拟内存的作用</h3><p>总结来说，虚拟内存主要提供了下面这些能力：</p><ul><li><strong>隔离进程</strong>：<font color="red">物理内存通过虚拟地址空间访问，虚拟地址空间与进程一一对应</font>。每个进程都认为自己拥有了整个物理内存，进程之间彼此隔离，一个进程中的代码无法更改正在由另一进程或操作系统使用的物理内存。</li><li><strong>提升物理内存利用率</strong>：有了虚拟地址空间后，操作系统只需要将进程当前正在使用的部分数据或指令加载入物理内存。</li><li><strong>简化内存管理</strong>：进程都有一个一致且私有的虚拟地址空间，程序员不用和真正的物理内存打交道，而是借助虚拟地址空间访问物理内存，从而简化了内存管理。</li><li><strong>多个进程共享物理内存</strong>：进程在运行过程中，会加载许多操作系统的动态库。这些库对于每个进程而言都是公用的，它们在内存中实际只会加载一份，这部分称为<font color="red">共享内存</font>。</li><li><strong>提高内存使用安全性</strong>：控制进程对物理内存的访问，隔离不同进程的访问权限，提高系统的安全性。</li><li><strong>提供更大的可使用内存空间</strong>：可以让程序拥有超过系统物理内存大小的可用内存空间。这是<font color="red">因为当物理内存不够用时，可以利用磁盘充当</font>。将物理内存页（通常大小为 4 KB）保存到磁盘文件（会影响读写速度），数据或代码页会根据需要在物理内存与磁盘之间移动。</li></ul><h3 id="没有虚拟内存会出现什么问题"><a class="anchor" href="#没有虚拟内存会出现什么问题">#</a> 没有虚拟内存会出现什么问题？</h3><p><font color="red">如果没有虚拟内存的话，程序直接访问和操作的都是物理内存</font>，看似少了一层中介，但多了很多问题。</p><p>具体有什么问题呢？这里举几个例子说明（参考虚拟内存的作用回答这个问题）：</p><ol><li><strong>用户程序可以访问任意物理内存</strong>，可能会不小心操作到系统运行必需的内存，进而造成操作系统崩溃，严重影响系统的安全。</li><li><strong>同时运行多个程序容易崩溃</strong>。比如你想同时运行一个微信和一个 QQ 音乐，微信在运行的时候给内存地址 1xxx 赋值后，QQ 音乐也同样给内存地址 1xxx 赋值，那么 QQ 音乐对内存的赋值就会覆盖微信之前所赋的值，这就可能会造成微信这个程序会崩溃。</li><li>程序运行过程中使用的所有<strong>数据或指令都要载入物理内存</strong>，根据局部性原理，其中很大一部分可能都不会用到，白白占用了宝贵的物理内存资源。</li><li>……</li></ol><h3 id="虚拟地址和物理地址"><a class="anchor" href="#虚拟地址和物理地址">#</a> 虚拟地址和物理地址</h3><p><font color="cornflowerblue">虚拟地址（Virtual Address）</font>是<strong>程序中访问的内存地址</strong>。</p><p><font color="cornflowerblue">物理地址（Physical Address）</font> 是真正的物理内存中地址，更具体点来说是<strong>内存地址寄存器中的地址</strong>。</p><p>也就是说，<font color="red">编程开发的时候实际就是在和虚拟地址打交道</font>。比如在 C 语言中，指针里面存储的数值就可以理解成为内存里的一个地址，这个地址也就是我们说的虚拟地址。</p><p>操作系统一般通过 CPU 芯片中的一个重要组件 <code>MMU（Memory Management Unit，内存管理单元）</code> <font color="red">将虚拟地址转换为物理地址</font>，这个过程被称为 <strong>地址转换（Address Translation）</strong>。通过 MMU 将虚拟地址转换为物理地址后，再通过总线传到物理内存设备，进而完成相应的物理内存读写请求。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/20240601140728.png" alt="image.png"></p><center>地址转换过程</center><h3 id="虚拟地址空间和物理地址空间"><a class="anchor" href="#虚拟地址空间和物理地址空间">#</a> 虚拟地址空间和物理地址空间</h3><ul><li>虚拟地址空间是虚拟地址的集合，是虚拟内存的范围。<font color="red">每一个进程都有一个一致且私有的虚拟地址空间</font>。</li><li>物理地址空间是物理地址的集合，是物理内存的范围。</li></ul><h3 id="虚拟地址与物理地址之间的转换机制"><a class="anchor" href="#虚拟地址与物理地址之间的转换机制">#</a> 虚拟地址与物理地址之间的转换机制</h3><p>前文提到的 MMU ，其将虚拟地址转换为物理地址的主要机制有 3 种:</p><ol><li><strong>分段机制</strong></li><li><strong>（常用）分页机制</strong></li><li><strong>段页机制</strong></li></ol><p>其中，现代操作系统广泛采用分页机制，需要重点关注！</p><h2 id="分段机制segmentation"><a class="anchor" href="#分段机制segmentation">#</a> 分段机制（Segmentation）</h2><p>以段（— 段连续的物理内存）的形式管理 / 分配物理内存。应用程序的虚拟地址空间被分为<strong>大小不等</strong>的段。段是有实际意义的，<font color="red">每个段定义了一组逻辑信息</font>，例如有主程序段 MAIN、子程序段 X、数据段 D 及栈段 S 等。</p><h3 id="段表segment-table"><a class="anchor" href="#段表segment-table">#</a> 段表（Segment Table）</h3><p>分段管理通过<strong>段表（段号、物理起始地址）</strong> 映射虚拟地址和物理地址。</p><p>分段机制下的<strong>虚拟地址</strong>由两部分组成：</p><ul><li><strong>段号</strong>：标识着该虚拟地址属于整个虚拟地址空间中的哪一个段。</li><li><strong>段内偏移量</strong>：相对于该段起始地址的偏移量。</li></ul><h3 id="分段机制下的地址转换过程"><a class="anchor" href="#分段机制下的地址转换过程">#</a> 分段机制下的地址转换过程</h3><p>具体的地址转换过程如下：</p><ol><li>MMU 首先解析得到虚拟地址中的<font color="red">段号</font>；</li><li>通过段号去该应用程序的段表中取出对应的段信息（找到对应的<font color="red">段表项</font>）；</li><li>从段信息中取出该段的<font color="red">起始地址（物理地址）</font>加上虚拟地址中的<font color="red">段内偏移量</font>得到<font color="red">最终的物理地址</font>。</li></ol><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/20240601143653.png" alt="image.png"></p><center>分段机制下的地址翻译过程</center><p>段表中还存有诸如<font color="red">段长</font>(可用于检查虚拟地址是否超出合法范围)、<font color="red">段类型</font>（该段的类型，例如代码段、数据段等）等信息。</p><p>通过段号一定要找到对应的段表项吗？得到最终的物理地址后对应的物理内存一定存在吗？不一定。<font color="red">段表项可能并不存在</font>：</p><ul><li><strong>段表项被删除</strong>：软件错误、软件恶意行为等情况可能会导致段表项被删除。</li><li><strong>段表项还未创建</strong>：如果系统内存不足或者无法分配到连续的物理内存块就会导致段表项无法被创建。</li></ul><h3 id="分段机制下的外部碎片"><a class="anchor" href="#分段机制下的外部碎片">#</a> 分段机制下的外部碎片</h3><p>分段机制容易出现外部碎片，即<font color="red">在段与段之间留下碎片空间（不足以映射给虚拟地址空间中的段）</font>，从而造成物理内存资源利用率的降低。</p><p>举个例子：假设可用物理内存为 5G 的系统使用分段机制分配内存。现在有 4 个进程，每个进程的内存占用情况如下：</p><ul><li>进程 1：0~1G（第 1 段）</li><li>进程 2：1~3G（第 2 段）</li><li>进程 3：3~4.5G（第 3 段）</li><li>进程 4：4.5~5G（第 4 段）</li></ul><p>此时，我们关闭了进程 1 和进程 4，则第 1 段和第 4 段的内存会被释放，空闲物理内存还有 1.5G。由于这 1.5G 物理内存并不是连续的，导致没办法将空闲的物理内存分配给一个需要 1.5G 物理内存的进程。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/20240601205948.png" alt="image.png"></p><center>分段机制导致外部碎片</center><h2 id="分页机制paging"><a class="anchor" href="#分页机制paging">#</a> 分页机制（Paging）</h2><p>把主存（物理内存）分为连续<strong>等长</strong>的物理页，应用程序的虚拟地址空间划也被分为连续等长的虚拟页。<strong>现代操作系统广泛采用分页机制</strong>。</p><blockquote><p>注意：这里的页是连续等长的，不同于分段机制下不同长度的段。</p></blockquote><p><strong>分页机制可以有效解决外部碎片问题</strong>。</p><blockquote><p>分页机制通过将虚拟内存划分为固定大小的页，并通过页表来管理虚拟地址和物理地址之间的映射，从而简化了内存管理。<font color="red">由于页面在物理内存中不需要连续存储，操作系统可以独立地管理每个页面，将它们分配到物理内存中的任何位置，有效避免外部碎片的产生</font>。同时，操作系统能够<font color="red">动态地回收和重新分配不再使用的页面</font>，进一步减少内存碎片的积累。此外，现代操作系统还可能采用<font color="red">页面交换</font>和<font color="red">内存压缩技术</font>，进一步优化内存使用，降低碎片的影响。因此，分页机制能够有效解决外部内存碎片问题，提高内存使用效率。</p></blockquote><h3 id="页表page-table"><a class="anchor" href="#页表page-table">#</a> 页表（Page Table）</h3><p>分页管理通过 <strong>页表（虚拟页号、物理页号）</strong> 映射虚拟地址和物理地址。</p><p>我这里画了一张基于<font color="red">单级页表</font>进行地址转换的示意图。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/20240601210517.png" alt="image.png"></p><center>单级页表</center><p>在分页机制下，<strong>每个应用程序都会有一个对应的页表</strong>。</p><p>分页机制下的<strong>虚拟地址</strong>由两部分组成：</p><ul><li><strong>虚拟页号</strong>：通过虚拟页号可以从页表中取出对应的物理页号；</li><li><strong>页内偏移量</strong>：物理页起始地址 + 页内偏移量 = 物理内存地址。</li></ul><h3 id="分页机制下的地址转换过程"><a class="anchor" href="#分页机制下的地址转换过程">#</a> 分页机制下的地址转换过程</h3><p>具体的地址翻译过程如下：</p><ol><li>MMU 首先解析得到虚拟地址中的<font color="red">虚拟页号</font>；</li><li>通过虚拟页号去该应用程序的页表中取出对应的物理页号（找到对应的<font color="red">页表项</font>）；</li><li>用该<font color="red">物理页号（对应的物理页起始地址（物理地址））</font>加上虚拟地址中的<font color="red">页内偏移量</font>得到最终的<font color="red">物理地址</font>。</li></ol><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/20240601211734.png" alt="image.png"></p><p>页表中还存有诸如<font color="red">访问标志</font>（标识该页面有没有被访问过）、<font color="red">脏数据标识位</font>等信息。</p><p>通过虚拟页号一定要找到对应的物理页号吗？找到了物理页号得到最终的物理地址后对应的物理页一定存在吗？不一定！<font color="red">可能会存在页缺失</font> 。也就是说，物理内存中没有对应的物理页或者物理内存中有对应的物理页但虚拟页还未和物理页建立映射（对应的页表项不存在）。关于页缺失的内容，后面会详细介绍到。</p><h3 id="多级页表"><a class="anchor" href="#多级页表">#</a> 多级页表</h3><p>以 32 位的环境为例，虚拟地址空间范围共有 2^32（4G）。假设一个页的大小是 2^12（4KB），那页表项共有 4G / 4K = 2^20 个。每个页表项为一个地址，占用 4 字节， <code>2^20 * 2^2 / 1024 * 1024= 4MB</code> 。也就是说一个程序啥都不干，页表大小就得占用 4M。</p><p><font color="red">系统运行的应用程序多起来的话，页表的开销还是非常大的</font>。而且，绝大部分应用程序可能只能用到页表中的几项，其他的白白浪费了。</p><p>为了解决这个问题，操作系统引入了<strong>多级页表</strong>，多级页表对应多个页表，<font color="red">每个页表与前一个页表相关联</font>。32 位系统一般为二级页表，64 位系统一般为四级页表。</p><p>这里以二级页表为例进行介绍：二级页表分为一级页表和二级页表。一级页表共有 1024 个页表项，一级页表又关联二级页表，二级页表同样共有 1024 个页表项。二级页表中的一级页表项是一对多的关系，二级页表按需加载（只会用到很少一部分二级页表），进而节省空间占用。</p><p>假设只需要 2 个二级页表，那两级页表的内存占用情况为：4KB（一级页表占用） + 4KB * 2（二级页表占用） = 12 KB。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/20240601212642.png" alt="image.png"></p><center>二级页表</center><p>多级页表属于<font color="red">时间换空间</font>的典型场景，利用增加页表查询的次数，减少页表占用的空间。</p><h3 id="tlb快表转址旁路缓存"><a class="anchor" href="#tlb快表转址旁路缓存">#</a> TLB（快表 / 转址旁路缓存）</h3><p><font color="red">为了提高虚拟地址到物理地址的转换速度</font>，操作系统在页表方案基础之上引入了 <code>转址旁路缓存(Translation Lookaside Buffer，TLB，也被称为快表)</code> 。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/20240601213142.png" alt="image.png"></p><center>加入 TLB 之后的地址转换</center><p>在主流的 AArch64 和 x86-64 体系结构下，TLB 属于 (Memory Management Unit，内存管理单元) 内部的单元，<font color="red">本质上就是一块高速缓存（Cache），缓存了虚拟页号到物理页号的映射关系</font>，你可以将其简单看作是存储着键（虚拟页号）值（物理页号）对的哈希表。</p><p>使用 TLB 之后的地址翻译流程是这样的：</p><ol><li>用虚拟地址中的<font color="red">虚拟页号</font>作为 key 去 <font color="red">TLB</font> 中查询；</li><li>如果能查到对应的物理页号的话，就不用再查询页表了，这种情况称为 <font color="red">TLB 命中（TLB hit）</font>。</li><li>如果不能查到对应的物理页号的话，还是需要去查询主存中的<font color="red">页表</font>，同时将页表中的该映射表项添加到 TLB 中，这种情况称为 <font color="red">TLB 未命中（TLB miss）</font>。</li><li>当 TLB 填满后，又要登记新页时，就按照一定的<font color="red">淘汰策略</font>淘汰掉 TLB 中的一个页。</li></ol><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/20240601213550.png" alt="image.png"></p><center>分页机制使用 TLB 后的地址转换流程</center><p>由于页表也在主存中，因此在没有 TLB 之前，每次读写内存数据时 CPU 要访问两次主存。有了 TLB 之后，对于存在于 TLB 中的页表数据只需要访问一次主存即可。</p><p>TLB 的设计思想非常简单，但<font color="red">命中率往往非常高，效果很好</font>。这就是因为被频繁访问的页就是其中的很小一部分。</p><p>看完了之后你会发现快表和我们平时经常在开发系统中使用的缓存（比如 Redis）很像，的确是这样的，操作系统中的很多思想、很多经典的算法，你都可以在我们日常开发使用的各种工具或者框架中找到它们的影子。</p><h3 id="换页机制"><a class="anchor" href="#换页机制">#</a> 换页机制</h3><p>换页机制的思想是，<strong>当物理内存不够用的时候，操作系统选择将一些物理页的内容放到磁盘上去，等要用到的时候再将它们从磁盘读取到物理内存中</strong>。也就是说，换页机制利用磁盘这种较低廉的存储设备来扩展物理内存。</p><p>这也就解释了一个日常使用电脑常见的问题：为什么操作系统中所有进程运行所需的物理内存即使比真实的物理内存要大一些，这些进程也是可以正常运行的，只是运行速度会变慢。</p><p>这同样是一种<font color="red">时间换空间</font>的策略，你用 CPU 的计算时间，页的调入调出花费的时间，换来了一个虚拟的更大的物理内存空间来支持程序的运行。</p><h3 id="页缺失page-fault"><a class="anchor" href="#页缺失page-fault">#</a> 页缺失（Page Fault）</h3><p>根据维基百科：</p><p><code>页缺失（Page Fault，又名硬错误、硬中断、分页错误、寻页缺失、缺页中断、页故障等）</code> 指的是<strong>当软件试图访问已映射在虚拟地址空间中，但是目前并未被加载在物理内存中的一个分页时，由 MMU 所发出的中断</strong>。</p><p>常见的页缺失有下面这两种：</p><ul><li><font color="cornflowerblue">硬性页缺失（Hard Page Fault）</font>：<font color="red">物理内存中没有对应的物理页</font>。于是，Page Fault Handler 会指示 CPU 从已经打开的磁盘文件中读取相应的内容到物理内存，而后交由 MMU 建立相应的虚拟页和物理页的映射关系。</li><li><font color="cornflowerblue">软性页缺失（Soft Page Fault）</font>：<font color="red">物理内存中有对应的物理页，但虚拟页还未和物理页建立映射</font>。于是，Page Fault Handler 会指示 MMU 建立相应的虚拟页和物理页的映射关系。</li></ul><p>发生上面这两种缺页错误的时候，应用程序访问的是有效的物理内存，只是出现了物理页缺失或者虚拟页和物理页的映射关系未建立的问题。如果应用程序访问的是无效的物理内存的话，还会出现<font color="cornflowerblue">无效缺页错误（Invalid Page Fault）</font> 。</p><h3 id="页面置换算法"><a class="anchor" href="#页面置换算法">#</a> ☆页面置换算法</h3><h4 id="常见的页面置换算法"><a class="anchor" href="#常见的页面置换算法">#</a> 常见的页面置换算法</h4><p><font color="red">当发生硬性页缺失时</font>，如果物理内存中没有空闲的物理页面可用的话，操作系统就必须将物理内存中的一个物理页淘汰出去，这样就可以腾出空间来加载新的页面了。</p><p>用来选择淘汰哪一个物理页的规则叫做 <strong>页面置换算法</strong> ，我们可以把页面置换算法看成是<font color="red">淘汰物理页的规则</font>。</p><p>页缺失太频繁的发生会非常影响性能，<font color="red">一个好的页面置换算法应该是可以减少页缺失出现的次数（评判算法好坏的标准）</font>。</p><p>常见的页面置换算法有下面这 5 种（其他还有很多页面置换算法都是基于这些算法改进得来的）：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/20240602115944.png" alt="image.png"></p><ol><li><font color="cornflowerblue">先进先出（FIFO，First In First Out）页面置换算法</font>：最简单的一种页面置换算法，总是淘汰<font color="red">最先进入内存的页面</font>，即选择在内存中驻留时间最久的页面进行淘汰。该算法易于实现和理解，一般只需要通过一个 FIFO 队列即可需求。不过，它的性能并不是很好。</li><li><font color="cornflowerblue">最佳（OPT，Optimal）页面置换算法</font>：优先选择淘汰的是<font color="red">以后永不使用的页面</font>，或者是<font color="red">在最长时间内不再被访问的页面</font>，这样可以保证获得最低的缺页率。但由于人们目前<strong>无法预知</strong>进程在内存下的若干页面中哪个是未来最长时间内不再被访问的，因而该算法<strong>无法实现</strong>，只是理论最优的页面置换算法，可以作为衡量其他置换算法优劣的标准。</li><li><font color="cornflowerblue">最近最久未使用（LRU ，Least Recently Used）页面置换算法</font>：LRU 算法赋予每个页面一个访问字段，用来<font color="red">记录一个页面自上次被访问以来所经历的时间 T，当须淘汰一个页面时，选择现有页面中其 T 值最大的，即最近最久未使用的页面</font>予以淘汰。LRU 算法是根据各页之前的访问情况来实现，因此是<strong>易于实现</strong>的。OPT 算法是根据各页未来的访问情况来实现，因此是不可实现的。</li><li><font color="cornflowerblue">最少使用（LFU，Least Frequently Used）页面置换算法</font> : 和 LRU 算法比较像，不过该置换算法选择的是<font color="red">之前一段时间内使用最少的页面</font>作为淘汰页。</li><li><font color="cornflowerblue">时钟（Clock）页面置换算法</font>：可以认为是一种最近未使用算法，即逐出的都是<font color="red">最近没有使用的页面</font>。</li></ol><h4 id="fifo-的性能为何不好"><a class="anchor" href="#fifo-的性能为何不好">#</a> FIFO 的性能为何不好</h4><p>主要原因主要有二：</p><ol><li><strong>经常访问或者需要长期存在的页面会被频繁调入调出</strong>：较早调入的页往往是经常被访问或者需要长期存在的页，这些页会被反复调入和调出。</li><li><strong>存在 Belady 现象</strong>：被置换的页面并不是进程不会访问的，有时就会出现<font color="red">分配的页面数增多，但缺页率反而提高</font>的异常现象。出现该异常的原因是因为 FIFO 算法只考虑了页面进入内存的顺序，而没有考虑页面访问的频率和紧迫性。</li></ol><h4 id="实际使用较多的是哪一种页面置换算法"><a class="anchor" href="#实际使用较多的是哪一种页面置换算法">#</a> 实际使用较多的是哪一种页面置换算法？</h4><p><strong>LRU 算法是实际使用中应用的比较多，也被认为是最接近 OPT 的页面置换算法</strong>。</p><p>不过，需要注意的是，实际应用中这些算法会被做<font color="red">一些改进</font>，就比如 InnoDB Buffer Pool（ InnoDB 缓冲池，MySQL 数据库中用于管理缓存页面的机制）就改进了传统的 LRU 算法，使用了一种称为 &quot;Adaptive LRU&quot; 的算法（同时结合了 LRU 和 LFU 算法的思想）。</p><h2 id="分段机制和分页机制的异同"><a class="anchor" href="#分段机制和分页机制的异同">#</a> 分段机制和分页机制的异同</h2><h3 id="分段机制和分页机制的共同点"><a class="anchor" href="#分段机制和分页机制的共同点">#</a> 分段机制和分页机制的共同点</h3><ul><li>都是<strong>非连续内存管理</strong>的方式。</li><li>都采用了<strong>地址转换映射</strong>的方法，将虚拟地址映射到物理地址，以实现对内存的管理和保护。</li></ul><h3 id="分段机制和分页机制的区别"><a class="anchor" href="#分段机制和分页机制的区别">#</a> 分段机制和分页机制的区别</h3><ul><li><strong>内存管理单位</strong>：<ul><li>分段机制以<font color="red">段</font>为单位进行内存管理。<font color="red">段的大小不固定</font>，取决于我们当前运行的程序。</li><li>分页机制以<font color="red">页</font>为单位进行内存管理。<font color="red">页的大小是固定的</font>，由操作系统决定，通常为 2 的幂次方。</li></ul></li><li><strong>逻辑单位 / 物理单位</strong>：<ul><li><font color="red">段是逻辑单位</font>，是为了满足程序对内存空间的逻辑需求而设计的，通常根据程序中数据和代码的逻辑结构来划分。</li><li><font color="red">页是物理单位</font>，即操作系统将物理内存划分成固定大小的页面，每个页面的大小通常是 2 的幂次方，例如 4KB、8KB 等等。</li></ul></li><li><strong>内存碎片问题</strong>：<ul><li><font color="red">分段机制容易出现外部碎片</font>，即在段与段之间留下碎片空间（不足以映射给虚拟地址空间中的段）。</li><li><font color="red">分页机制解决了外部碎片的问题，但仍然可能会出现内部碎片</font>。</li></ul></li><li><strong>地址转换机制</strong>：<ul><li>分段机制则采用了<font color="red">段表</font>来完成虚拟地址到物理地址的映射，每个段表项中记录了该段的<font color="red">段号和起始地址</font>。</li><li>分页机制采用了<font color="red">页表</font>来完成虚拟地址到物理地址的映射，每个页表项中记录了该页的<font color="red">虚拟页号和物理页号</font>。页表通过一级页表和二级页表来实现多级映射。</li></ul></li><li><strong>程序是否划分</strong>：<ul><li><font color="red">分段机制需要将程序分为多个段</font>，并且显式地使用段寄存器来访问不同的段。</li><li>分页机制对程序没有任何要求，程序只需要按照虚拟地址进行访问即可。</li></ul></li></ul><h2 id="段页机制"><a class="anchor" href="#段页机制">#</a> 段页机制</h2><p>结合了段式管理和页式管理的一种内存管理机制，<strong>把物理内存先分成若干大小不等的段，每个段又继续分成若干大小相等的页</strong>。</p><p>在段页式机制下，地址翻译的过程分为两个步骤：</p><ol><li><font color="red">段式地址映射</font>。</li><li><font color="red">页式地址映射</font>。</li></ol><h2 id="局部性原理locality-principle"><a class="anchor" href="#局部性原理locality-principle">#</a> 局部性原理（Locality Principle）</h2><p>要想更好地理解虚拟内存技术，必须要知道计算机中著名的 <code>局部性原理（Locality Principle）</code> 。另外，局部性原理既适用于程序结构，也适用于数据结构，是非常重要的一个概念。</p><p>局部性原理是指<strong>在程序执行过程中，数据和指令的访问存在一定的空间和时间上的局部性特点</strong>。</p><ul><li>时间局部性：是指一个数据项或指令<font color="red">在一段时间内被反复使用</font>的特点</li><li>空间局部性：是指一个数据项或指令<font color="red">在一段时间内与其相邻的数据项或指令被反复使用</font>的特点</li></ul><p>在分页机制中，页表的作用是将虚拟地址转换为物理地址，从而完成内存访问。在这个过程中，局部性原理的作用体现在两个方面：</p><ul><li><strong>时间局部性</strong>：由于程序中存在一定的循环或者重复操作，因此会<font color="red">反复访问同一个页或一些特定的页</font>，这就体现了时间局部性的特点。为了利用时间局部性，分页机制中通常采用<strong>缓存机制</strong>来提高页面的命中率，即将最近访问过的一些页放入缓存中，如果下一次访问的页已经在缓存中，就不需要再次访问内存，而是直接从缓存中读取。</li><li><strong>空间局部性</strong>：由于程序中数据和指令的访问通常是具有一定的空间连续性的，因此<font color="red">当访问某个页时，往往会顺带访问其相邻的一些页</font>。为了利用空间局部性，分页机制中通常采用<strong>预取技术</strong>来预先将相邻的一些页读入内存缓存中，以便在未来访问时能够直接使用，从而提高访问速度。</li></ul><p>总之，局部性原理是计算机体系结构设计的重要原则之一，也是许多优化算法的基础。<strong>在分页机制中，利用时间局部性和空间局部性，采用缓存机制和预取技术，可以提高页面的命中率，从而提高内存访问效率</strong>。</p><h1 id="文件系统"><a class="anchor" href="#文件系统">#</a> 文件系统</h1><h2 id="文件系统的功能"><a class="anchor" href="#文件系统的功能">#</a> 文件系统的功能</h2><p>文件系统主要负责管理和组织计算机存储设备上的文件和目录，其功能包括以下几个方面：</p><ol><li><strong>存储管理</strong>：将文件数据存储到物理存储介质中，并且管理空间分配，以确保每个文件都有足够的空间存储，并避免文件之间发生冲突。</li><li><strong>文件管理</strong>：文件的创建、删除、移动、重命名、压缩、加密、共享等等。</li><li><strong>目录管理</strong>：目录的创建、删除、移动、重命名等等。</li><li><strong>文件访问控制</strong>：管理不同用户或进程对文件的访问权限，以确保用户只能访问其被授权访问的文件，以保证文件的安全性和保密性。</li></ol><h2 id="硬链接和软链接"><a class="anchor" href="#硬链接和软链接">#</a> 硬链接和软链接</h2><p>在 Linux / 类 Unix 系统上， <code>文件链接（File Link）</code> 是一种特殊的文件类型，可以在文件系统中指向另一个文件。常见的文件链接类型有两种：</p><p>1、<font color="cornflowerblue">硬链接（Hard Link）</font></p><ul><li>在 Linux / 类 Unix 文件系统中，每个文件和目录都有一个唯一的索引节点（inode）号，用来标识该文件或目录。<font color="red">硬链接通过 inode 节点号建立连接，硬链接和源文件的 inode 节点号相同，两者对文件系统来说是完全平等的（可以看作是互为硬链接，源头是同一份文件），删除其中任何一个对另外一个没有影响，可以通过给文件设置硬链接文件来防止重要文件被误删</font>。</li><li><font color="red">只有删除了源文件和所有对应的硬链接文件，该文件才会被真正删除</font>。</li><li>硬链接具有一些限制，不能对目录以及不存在的文件创建硬链接，并且，<font color="red">硬链接也不能跨越文件系统</font>。</li><li><code>ln</code> 命令用于创建硬链接。</li></ul><p>2、<font color="cornflowerblue">软链接（Symbolic Link 或 Symlink）</font></p><ul><li><font color="red">软链接和源文件的 inode 节点号不同，而是指向一个文件路径</font>。</li><li>源文件删除后，软链接依然存在，但是指向的是一个无效的文件路径。</li><li>软连接类似于 Windows 系统中的<font color="red">快捷方式</font>。</li><li>不同于硬链接，可以对目录或者不存在的文件创建软链接，并且，<font color="red">软链接可以跨越文件系统</font>。</li><li><code>ln -s</code> 命令用于创建软链接。</li></ul><h2 id="硬链接为什么不能跨文件系统"><a class="anchor" href="#硬链接为什么不能跨文件系统">#</a> 硬链接为什么不能跨文件系统？</h2><p>我们之前提到过，<font color="red">硬链接是通过 inode 节点号建立连接的</font>，而硬链接和源文件共享相同的 inode 节点号。</p><p>然而，<strong>每个文件系统都有自己的独立 inode 表，且每个 inode 表只维护该文件系统内的 inode</strong>。如果在不同的文件系统之间创建硬链接，可能会导致 <font color="red">inode 节点号冲突</font>的问题，即目标文件的 inode 节点号已经在该文件系统中被使用。</p><h2 id="文件系统的性能提高方式"><a class="anchor" href="#文件系统的性能提高方式">#</a> 文件系统的性能提高方式</h2><ul><li><strong>优化硬件</strong>：使用高速硬件设备（如 SSD、NVMe）替代传统的机械硬盘，使用 RAID（Redundant Array of Inexpensive Disks）等技术提高磁盘性能。</li><li><strong>选择合适的文件系统</strong>：不同的文件系统具有不同的特性，对于不同的应用场景选择合适的文件系统可以提高系统性能。</li><li><strong>应用缓存</strong>：访问磁盘的效率比较低，可以运用缓存来减少磁盘的访问次数。不过，需要注意缓存命中率，缓存命中率过低的话，效果太差。</li><li><strong>避免磁盘过度使用</strong>：注意磁盘的使用率，避免将磁盘用满，尽量留一些剩余空间，以免对文件系统的性能产生负面影响。</li><li><strong>对磁盘进行合理的分区</strong>：合理的磁盘分区方案，能够使文件系统在不同的区域存储文件，从而减少文件碎片，提高文件读写性能。</li></ul><h2 id="磁盘调度算法"><a class="anchor" href="#磁盘调度算法">#</a> ☆磁盘调度算法</h2><blockquote><p>与<a href="#%E2%98%86%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95">进程调度算法</a>类似</p></blockquote><p>磁盘调度算法是操作系统中对磁盘访问请求进行排序和调度的算法，其目的是提高磁盘的访问效率。</p><p><font color="red">一次磁盘读写操作的时间 = 磁盘寻道时间 + 延迟时间 + 传输时间</font>。磁盘调度算法可以<strong>通过改变到达磁盘请求的处理顺序，减少磁盘寻道时间和延迟时间</strong>。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/20240602130909.png" alt="image.png"></p><p>常见的磁盘调度算法有下面这 6 种（其他还有很多磁盘调度算法都是基于这些算法改进得来的）：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/20240602130044.png" alt="image.png"></p><ol><li><strong>先来先服务算法（First-Come First-Served，FCFS）</strong>：按照请求到达磁盘调度器的顺序进行处理，先到达的请求的先被服务。FCFS 算法实现起来比较简单，不存在算法开销。不过，<font color="red">由于没有考虑磁头移动的路径和方向，平均寻道时间较长</font>。同时，该算法容易出现<font color="red">饥饿问题</font>，即一些后到的磁盘请求可能需要等待很长时间才能得到服务。</li><li><strong>最短寻道时间优先算法（Shortest Seek Time First，SSTF）</strong>：也被称为最佳服务优先（Shortest Service Time First，SSTF）算法，<font color="red">优先选择距离当前磁头位置最近的请求进行服务</font>。SSTF 算法能够最小化磁头的寻道时间，但容易出现<font color="red">饥饿问题</font>，即磁头附近的请求不断被服务，远离磁头的请求长时间得不到响应。实际应用中，需要优化一下该算法的实现，避免出现饥饿问题。</li><li><strong>扫描算法（SCAN）</strong>：也被称为电梯（Elevator）算法，基本思想和电梯非常类似。<font color="red">磁头沿着一个方向扫描磁盘，如果经过的磁道有请求就处理，直到到达磁盘的边界，然后改变移动方向，依此往复</font>。SCAN 算法能够保证所有的请求得到服务，解决了饥饿问题。但是，如果磁头从一个方向刚扫描完，请求才到的话。这个请求就需要等到磁头从相反方向过来之后才能得到处理。</li><li><strong>循环扫描算法（Circular Scan，C-SCAN）</strong>：SCAN 算法的变体，<font color="red">只在磁盘的一侧进行扫描，并且只按照一个方向扫描，直到到达磁盘边界，然后回到磁盘起点，重新开始循环</font>。</li><li><strong>边扫描边观察算法（LOOK）</strong>：SCAN 算法中磁头到了磁盘的边界才改变移动方向，这样可能会做很多无用功，因为磁头移动方向上可能已经没有请求需要处理了。LOOK 算法<font color="red">对 SCAN 算法进行了改进，如果磁头移动方向上已经没有别的请求，就可以立即改变磁头移动方向，依此往复</font>。也就是边扫描边观察指定方向上还有无请求，因此叫 LOOK。</li><li><strong>均衡循环扫描算法（C-LOOK）</strong>：C-SCAN 只有到达磁盘边界时才能改变磁头移动方向，并且磁头返回时也需要返回到磁盘起点，这样可能会做很多无用功。C-LOOK 算法<font color="red">对 C-SCAN 算法进行了改进，如果磁头移动的方向上已经没有磁道访问请求了，就可以立即让磁头返回，并且磁头只需要返回到有磁道访问请求的位置即可</font>。</li></ol><h1 id="参考"><a class="anchor" href="#参考">#</a> 参考</h1><ul><li>《计算机操作系统 — 汤小丹》第四版</li><li>《深入理解计算机系统》</li><li>《重学操作系统》</li><li>操作系统为什么要分用户态和内核态：<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoZW4xMzQyMjUvYXJ0aWNsZS9kZXRhaWxzLzgxNzgzOTgw">https://blog.csdn.net/chen134225/article/details/81783980</span></li><li>从根上理解用户态与内核态：<span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC82OTIzODYzNjcwMTMyODUwNzAx">https://juejin.cn/post/6923863670132850701</span></li><li>什么是僵尸进程与孤儿进程：<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2E3NDUyMzM3MDAvYXJ0aWNsZS9kZXRhaWxzLzEyMDcxNTM3MQ==">https://blog.csdn.net/a745233700/article/details/120715371</span></li><li>《现代操作系统原理与实现》</li><li>王道考研操作系统知识点整理：<span class="exturl" data-url="aHR0cHM6Ly93aXphcmRmb3JjZWwuZ2l0Ym9va3MuaW8vd2FuZ2Rhb2thb3lhbi1vcy9jb250ZW50LzEzLmh0bWw=">https://wizardforcel.gitbooks.io/wangdaokaoyan-os/content/13.html</span></li><li>内存管理之伙伴系统与 SLAB：<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MjcyNjgxL2FydGljbGUvZGV0YWlscy8xMjQxOTkwNjg=">https://blog.csdn.net/qq_44272681/article/details/124199068</span></li><li>为什么 Linux 需要虚拟内存：<span class="exturl" data-url="aHR0cHM6Ly9kcmF2ZW5lc3MubWUvd2h5cy10aGUtZGVzaWduLW9zLXZpcnR1YWwtbWVtb3J5Lw==">https://draveness.me/whys-the-design-os-virtual-memory/</span></li><li>程序员的自我修养（七）：内存缺页错误：<span class="exturl" data-url="aHR0cHM6Ly9saWFtLnBhZ2UvMjAxNy8wOS8wMS9wYWdlLWZhdWx0Lw==">https://liam.page/2017/09/01/page-fault/</span></li><li>虚拟内存的那点事儿：<span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC82ODQ0OTAzNTA3NTk0NTc1ODg2">https://juejin.cn/post/6844903507594575886</span></li></ul></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2024-06-02 13:12:29" itemprop="dateModified" datetime="2024-06-02T13:12:29+08:00">2024-06-02</time> </span><span id="computer-base/操作系统常问八股文/" class="item leancloud_visitors" data-flag-title="操作系统常问八股文" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>范特东东东 <i class="ic i-at"><em>@</em></i>水文 & 摄影</li><li class="link"><strong>本文链接：</strong> <a href="http://example.com/computer-base/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%B8%B8%E9%97%AE%E5%85%AB%E8%82%A1%E6%96%87/" title="操作系统常问八股文">http://example.com/computer-base/操作系统常问八股文/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/computer-base/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%B8%B8%E9%97%AE%E5%85%AB%E8%82%A1%E6%96%87/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;pic.imgdb.cn&#x2F;item&#x2F;6554c7d9c458853aefd857b8.jpg" title="计算机网络常问八股文"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> 计算机网络</span><h3>计算机网络常问八股文</h3></a></div><div class="item right"></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80"><span class="toc-number">1.</span> <span class="toc-text">操作系统基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.</span> <span class="toc-text">操作系统的概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="toc-number">1.2.</span> <span class="toc-text">操作系统的功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81"><span class="toc-number">1.3.</span> <span class="toc-text">☆用户态和内核态</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.3.1.</span> <span class="toc-text">用户态和内核态是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%88%92%E5%88%86%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81"><span class="toc-number">1.3.2.</span> <span class="toc-text">为什么要划分用户态和内核态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81%E6%98%AF%E5%A6%82%E4%BD%95%E5%88%87%E6%8D%A2%E7%9A%84"><span class="toc-number">1.3.3.</span> <span class="toc-text">用户态和内核态是如何切换的</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">1.4.</span> <span class="toc-text">系统调用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">1.4.1.</span> <span class="toc-text">系统调用的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">1.4.2.</span> <span class="toc-text">系统调用的过程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B"><span class="toc-number">2.</span> <span class="toc-text">进程和线程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">2.1.</span> <span class="toc-text">进程和线程的概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%85%B3%E7%B3%BB%E5%8C%BA%E5%88%AB"><span class="toc-number">2.2.</span> <span class="toc-text">☆进程和线程的关系 &#x2F; 区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%BF%85%E8%A6%81%E6%80%A7"><span class="toc-number">2.3.</span> <span class="toc-text">线程的必要性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%BF%85%E8%A6%81%E6%80%A7"><span class="toc-number">2.4.</span> <span class="toc-text">多线程的必要性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E9%97%B4%E7%9A%84%E5%90%8C%E6%AD%A5%E6%96%B9%E5%BC%8F"><span class="toc-number">2.5.</span> <span class="toc-text">线程间的同步方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pcb%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97"><span class="toc-number">2.6.</span> <span class="toc-text">PCB：进程控制块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E7%8A%B6%E6%80%81"><span class="toc-number">2.7.</span> <span class="toc-text">进程的生命周期和状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E7%8A%B6%E6%80%81"><span class="toc-number">2.8.</span> <span class="toc-text">☆线程的生命周期和状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><span class="toc-number">2.9.</span> <span class="toc-text">进程间的通信方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">2.10.</span> <span class="toc-text">☆进程调度算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B"><span class="toc-number">2.11.</span> <span class="toc-text">僵尸进程和孤儿进程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%AD%BB%E9%94%81"><span class="toc-number">3.</span> <span class="toc-text">死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">3.1.</span> <span class="toc-text">死锁的概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E4%BA%A7%E7%94%9F%E4%B8%BE%E4%BE%8B"><span class="toc-number">3.2.</span> <span class="toc-text">死锁产生举例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E4%BA%A7%E7%94%9F%E4%B8%BE%E4%BE%8B%E7%9A%84%E6%A8%A1%E6%8B%9F%E4%BB%A3%E7%A0%81"><span class="toc-number">3.3.</span> <span class="toc-text">死锁产生举例的模拟代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E4%BA%A7%E7%94%9F%E7%9A%84%E5%9B%9B%E4%B8%AA%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6"><span class="toc-number">3.4.</span> <span class="toc-text">☆死锁产生的四个必要条件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95"><span class="toc-number">3.5.</span> <span class="toc-text">☆死锁的解决方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E9%A2%84%E9%98%B2"><span class="toc-number">3.5.1.</span> <span class="toc-text">死锁的预防</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5%E7%A0%B4%E5%9D%8F%E5%8D%A0%E6%9C%89%E5%B9%B6%E7%AD%89%E5%BE%85%E6%9D%A1%E4%BB%B6"><span class="toc-number">3.5.1.1.</span> <span class="toc-text">静态分配策略（破坏占有并等待条件）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%82%E6%AC%A1%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5%E7%A0%B4%E5%9D%8F%E5%BE%AA%E7%8E%AF%E7%AD%89%E5%BE%85%E6%9D%A1%E4%BB%B6"><span class="toc-number">3.5.1.2.</span> <span class="toc-text">层次分配策略（破坏循环等待条件）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E9%81%BF%E5%85%8D%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95"><span class="toc-number">3.5.2.</span> <span class="toc-text">死锁的避免（银行家算法）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E6%A3%80%E6%B5%8B"><span class="toc-number">3.5.3.</span> <span class="toc-text">死锁的检测</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B-%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E5%9B%BE"><span class="toc-number">3.5.3.1.</span> <span class="toc-text">进程 - 资源分配图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B%E6%AD%A5%E9%AA%A4"><span class="toc-number">3.5.3.2.</span> <span class="toc-text">死锁检测步骤</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E8%A7%A3%E9%99%A4"><span class="toc-number">3.5.4.</span> <span class="toc-text">死锁的解除</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">4.</span> <span class="toc-text">内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E4%BB%BB%E5%8A%A1"><span class="toc-number">4.1.</span> <span class="toc-text">内存管理的任务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87"><span class="toc-number">4.2.</span> <span class="toc-text">内存碎片</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E5%B8%B8%E8%A7%81%E6%96%B9%E5%BC%8F"><span class="toc-number">4.3.</span> <span class="toc-text">内存管理的常见方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9E%E7%BB%AD%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">4.3.1.</span> <span class="toc-text">连续内存管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E8%BF%9E%E7%BB%AD%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">4.3.2.</span> <span class="toc-text">非连续内存管理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98"><span class="toc-number">4.4.</span> <span class="toc-text">虚拟内存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">4.4.1.</span> <span class="toc-text">虚拟内存的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">4.4.2.</span> <span class="toc-text">虚拟内存的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B2%A1%E6%9C%89%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E4%BC%9A%E5%87%BA%E7%8E%B0%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98"><span class="toc-number">4.4.3.</span> <span class="toc-text">没有虚拟内存会出现什么问题？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E5%92%8C%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80"><span class="toc-number">4.4.4.</span> <span class="toc-text">虚拟地址和物理地址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E5%92%8C%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4"><span class="toc-number">4.4.5.</span> <span class="toc-text">虚拟地址空间和物理地址空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E4%B8%8E%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2%E6%9C%BA%E5%88%B6"><span class="toc-number">4.4.6.</span> <span class="toc-text">虚拟地址与物理地址之间的转换机制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%AE%B5%E6%9C%BA%E5%88%B6segmentation"><span class="toc-number">4.5.</span> <span class="toc-text">分段机制（Segmentation）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AE%B5%E8%A1%A8segment-table"><span class="toc-number">4.5.1.</span> <span class="toc-text">段表（Segment Table）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%AE%B5%E6%9C%BA%E5%88%B6%E4%B8%8B%E7%9A%84%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E8%BF%87%E7%A8%8B"><span class="toc-number">4.5.2.</span> <span class="toc-text">分段机制下的地址转换过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%AE%B5%E6%9C%BA%E5%88%B6%E4%B8%8B%E7%9A%84%E5%A4%96%E9%83%A8%E7%A2%8E%E7%89%87"><span class="toc-number">4.5.3.</span> <span class="toc-text">分段机制下的外部碎片</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B6paging"><span class="toc-number">4.6.</span> <span class="toc-text">分页机制（Paging）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B5%E8%A1%A8page-table"><span class="toc-number">4.6.1.</span> <span class="toc-text">页表（Page Table）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B6%E4%B8%8B%E7%9A%84%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E8%BF%87%E7%A8%8B"><span class="toc-number">4.6.2.</span> <span class="toc-text">分页机制下的地址转换过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8"><span class="toc-number">4.6.3.</span> <span class="toc-text">多级页表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tlb%E5%BF%AB%E8%A1%A8%E8%BD%AC%E5%9D%80%E6%97%81%E8%B7%AF%E7%BC%93%E5%AD%98"><span class="toc-number">4.6.4.</span> <span class="toc-text">TLB（快表 &#x2F; 转址旁路缓存）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8D%A2%E9%A1%B5%E6%9C%BA%E5%88%B6"><span class="toc-number">4.6.5.</span> <span class="toc-text">换页机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B5%E7%BC%BA%E5%A4%B1page-fault"><span class="toc-number">4.6.6.</span> <span class="toc-text">页缺失（Page Fault）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-number">4.6.7.</span> <span class="toc-text">☆页面置换算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-number">4.6.7.1.</span> <span class="toc-text">常见的页面置换算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#fifo-%E7%9A%84%E6%80%A7%E8%83%BD%E4%B8%BA%E4%BD%95%E4%B8%8D%E5%A5%BD"><span class="toc-number">4.6.7.2.</span> <span class="toc-text">FIFO 的性能为何不好</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%99%85%E4%BD%BF%E7%94%A8%E8%BE%83%E5%A4%9A%E7%9A%84%E6%98%AF%E5%93%AA%E4%B8%80%E7%A7%8D%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-number">4.6.7.3.</span> <span class="toc-text">实际使用较多的是哪一种页面置换算法？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%AE%B5%E6%9C%BA%E5%88%B6%E5%92%8C%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B6%E7%9A%84%E5%BC%82%E5%90%8C"><span class="toc-number">4.7.</span> <span class="toc-text">分段机制和分页机制的异同</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%AE%B5%E6%9C%BA%E5%88%B6%E5%92%8C%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B6%E7%9A%84%E5%85%B1%E5%90%8C%E7%82%B9"><span class="toc-number">4.7.1.</span> <span class="toc-text">分段机制和分页机制的共同点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%AE%B5%E6%9C%BA%E5%88%B6%E5%92%8C%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B6%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.7.2.</span> <span class="toc-text">分段机制和分页机制的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AE%B5%E9%A1%B5%E6%9C%BA%E5%88%B6"><span class="toc-number">4.8.</span> <span class="toc-text">段页机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E6%80%A7%E5%8E%9F%E7%90%86locality-principle"><span class="toc-number">4.9.</span> <span class="toc-text">局部性原理（Locality Principle）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">5.</span> <span class="toc-text">文件系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="toc-number">5.1.</span> <span class="toc-text">文件系统的功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A1%AC%E9%93%BE%E6%8E%A5%E5%92%8C%E8%BD%AF%E9%93%BE%E6%8E%A5"><span class="toc-number">5.2.</span> <span class="toc-text">硬链接和软链接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A1%AC%E9%93%BE%E6%8E%A5%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E8%B7%A8%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">5.3.</span> <span class="toc-text">硬链接为什么不能跨文件系统？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%80%A7%E8%83%BD%E6%8F%90%E9%AB%98%E6%96%B9%E5%BC%8F"><span class="toc-number">5.4.</span> <span class="toc-text">文件系统的性能提高方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">5.5.</span> <span class="toc-text">☆磁盘调度算法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">6.</span> <span class="toc-text">参考</span></a></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li class="active"><a href="/computer-base/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%B8%B8%E9%97%AE%E5%85%AB%E8%82%A1%E6%96%87/" rel="bookmark" title="操作系统常问八股文">操作系统常问八股文</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="范特东东东" data-src="/images/avatar.jpg"><p class="name" itemprop="name">范特东东东</p><div class="description" itemprop="description"></div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">65</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">24</span> <span class="name">分类</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hqeDE1OQ==" title="https:&#x2F;&#x2F;github.com&#x2F;hjx159"><i class="ic i-github"></i></span> <span class="exturl item email" data-url="bWFpbHRvOjgxMjE0MzI4MEBxcS5jb20=" title="mailto:812143280@qq.com"><i class="ic i-envelope"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><a href="/categories/photography/" rel="section"><i class="ic i-photography"></i>摄影</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于我</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/java/" title="分类于 Java">Java</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/" title="分类于 Java基础">Java基础</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/java-excise/" title="分类于 Java基础-真题">Java基础-真题</a></div><span><a href="/java/java-se/java-excise/%E7%AC%AC11%E7%AB%A0%EF%BC%9A%E9%9A%8F%E5%A0%82%E5%A4%8D%E4%B9%A0%E4%B8%8E%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%A2%98%EF%BC%88%E5%B8%B8%E7%94%A8%E7%B1%BB%E4%B8%8E%E5%9F%BA%E7%A1%80API%EF%BC%89/" title="宋红康_第11章：常用类与基础API">宋红康_第11章：常用类与基础API</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/java/" title="分类于 Java">Java</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/" title="分类于 Java基础">Java基础</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/java-knowledge/" title="分类于 Java基础-知识点">Java基础-知识点</a></div><span><a href="/java/java-se/java-knowledge/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E5%AE%8B%E7%BA%A2%E5%BA%B7_%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/" title="宋红康_第01章_Java语言概述">宋红康_第01章_Java语言概述</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/java/" title="分类于 Java">Java</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/" title="分类于 Java基础">Java基础</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/java-excise/" title="分类于 Java基础-真题">Java基础-真题</a></div><span><a href="/java/java-se/java-excise/%E7%AC%AC04%E7%AB%A0%EF%BC%9A%E9%9A%8F%E5%A0%82%E5%A4%8D%E4%B9%A0%E4%B8%8E%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%A2%98%EF%BC%88IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%89/" title="宋红康_第04章：IDEA安装与使用">宋红康_第04章：IDEA安装与使用</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/photography/" title="分类于 摄影">摄影</a></div><span><a href="/photography/%E8%93%9D%E4%B8%8E%E9%BB%84/" title="蓝与黄">蓝与黄</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/java/" title="分类于 Java">Java</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/" title="分类于 Java基础">Java基础</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/java-knowledge/" title="分类于 Java基础-知识点">Java基础-知识点</a></div><span><a href="/java/java-se/java-knowledge/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E5%AE%8B%E7%BA%A2%E5%BA%B7_%E7%AC%AC16%E7%AB%A0_%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" title="宋红康_第16章_网络编程">宋红康_第16章_网络编程</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/java/" title="分类于 Java">Java</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/" title="分类于 Java基础">Java基础</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/java-excise/" title="分类于 Java基础-真题">Java基础-真题</a></div><span><a href="/java/java-se/java-excise/%E7%AC%AC02%E7%AB%A0%EF%BC%9A%E9%9A%8F%E5%A0%82%E5%A4%8D%E4%B9%A0%E4%B8%8E%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%A2%98%EF%BC%88%E5%8F%98%E9%87%8F%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%89/" title="宋红康_第02章：变量与运算符">宋红康_第02章：变量与运算符</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/java/" title="分类于 Java">Java</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/" title="分类于 Java基础">Java基础</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/java-excise/" title="分类于 Java基础-真题">Java基础-真题</a></div><span><a href="/java/java-se/java-excise/%E7%AC%AC15%E7%AB%A0%EF%BC%9A%E9%9A%8F%E5%A0%82%E5%A4%8D%E4%B9%A0%E4%B8%8E%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%A2%98%EF%BC%88File%E7%B1%BB%E4%B8%8EIO%E6%B5%81%EF%BC%89/" title="宋红康_第15章：File类与IO流">宋红康_第15章：File类与IO流</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/distributed-microservices/" title="分类于 分布式微服务">分布式微服务</a></div><span><a href="/distributed-microservices/%E5%88%86%E5%B8%83%E5%BC%8FID&%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81&%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1&%E5%88%86%E5%B8%83%E5%BC%8F%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/" title="分布式ID&amp;分布式锁&amp;分布式事务&amp;分布式配置中心">分布式ID&分布式锁&分布式事务&分布式配置中心</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/distributed-microservices/" title="分类于 分布式微服务">分布式微服务</a></div><span><a href="/distributed-microservices/%E5%88%86%E5%B8%83%E5%BC%8F%E7%90%86%E8%AE%BA&%E7%AE%97%E6%B3%95&%E5%8D%8F%E8%AE%AE/" title="分布式理论&amp;算法&amp;协议">分布式理论&算法&协议</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer-base/" title="分类于 计算机基础">计算机基础</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-base/operating-system/" title="分类于 操作系统">操作系统</a></div><span><a href="/computer-base/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%B8%B8%E9%97%AE%E5%85%AB%E8%82%A1%E6%96%87/" title="操作系统常问八股文">操作系统常问八股文</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">范特东东东 @ fantedong</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">2m 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">29:55</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"computer-base/操作系统常问八股文/",favicon:{show:"(●´3｀●)欢迎回来",hide:"(〃＞皿＜)你快回来"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hrmmi -->