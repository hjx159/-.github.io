<!-- build time:Sun Mar 17 2024 22:17:44 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="水文 & 摄影" href="http://example.com/rss.xml"><link rel="alternate" type="application/atom+xml" title="水文 & 摄影" href="http://example.com/atom.xml"><link rel="alternate" type="application/json" title="水文 & 摄影" href="http://example.com/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><link rel="canonical" href="http://example.com/leetcode/carl/%E7%AC%94%E8%AE%B0%E9%9A%8F%E6%83%B3%E5%BD%95/"><title>代码随想录-笔记 - 代码随想录 - LeetCode | fantedong = 水文 & 摄影 = 为了能更好地查看图片，你需要一点魔法</title><meta name="generator" content="Hexo 6.3.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">代码随想录-笔记</h1><div class="meta"><span class="item" title="创建时间：2023-11-11 12:03:35"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2023-11-11T12:03:35+08:00">2023-11-11</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>272k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>4:07</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">fantedong</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><img src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/v2-81c0a6d129291c018656915d7cb66ec5_720w.jpg"></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/leetcode/" itemprop="item" rel="index" title="分类于 LeetCode"><span itemprop="name">LeetCode</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/leetcode/carl/" itemprop="item" rel="index" title="分类于 代码随想录"><span itemprop="name">代码随想录</span></a><meta itemprop="position" content="2"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://example.com/leetcode/carl/%E7%AC%94%E8%AE%B0%E9%9A%8F%E6%83%B3%E5%BD%95/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="范特东东东"><meta itemprop="description" content="为了能更好地查看图片，你需要一点魔法, "></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="水文 & 摄影"></span><div class="body md" itemprop="articleBody"><h1 id="笔记随想录"><a class="anchor" href="#笔记随想录">#</a> 笔记随想录</h1><h2 id="速查手册"><a class="anchor" href="#速查手册">#</a> 速查手册</h2><h3 id="java中stack-queue的接口函数"><a class="anchor" href="#java中stack-queue的接口函数">#</a> java 中 Stack、Queue 的接口函数</h3><h4 id="stack类"><a class="anchor" href="#stack类">#</a> Stack 类</h4><p>Stack 的声明如下，可以看到 Stack 继承了 Vector，因此 Stack 可以使用 Vector 中的方法，如 size () 等。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> <span class="token keyword">extends</span> <span class="token class-name">Vector</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">方法</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">boolean empty()</td><td style="text-align:center">判断栈是否为空</td></tr><tr><td style="text-align:center">E <strong>peek()</strong></td><td style="text-align:center">返回栈顶部的对象，但不从栈中移除它</td></tr><tr><td style="text-align:center">E <strong>pop()</strong></td><td style="text-align:center">移除栈顶部的对象，并作为此函数的值返回该对象</td></tr><tr><td style="text-align:center">E <strong>push(<strong>E item</strong>)</strong></td><td style="text-align:center">把对象压入栈顶部</td></tr><tr><td style="text-align:center">int search(Object o)</td><td style="text-align:center">返回对象在堆栈中的位置，若不存在则返回 - 1</td></tr></tbody></table><h4 id="queue接口"><a class="anchor" href="#queue接口">#</a> Queue 接口</h4><p>与 Stack 不同，Java 里的 Queue 不是一个类，而是一个接口，它的声明为</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> <span class="token keyword">extends</span> <span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span></pre></td></tr></table></figure><p>定义了 6 个方法：<strong>add、element、remove 为一组，他们均在出错时抛出异常；offer、peek、poll 为一组，他们在出错时返回特定的值</strong></p><table><thead><tr><th style="text-align:center">方法</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">boolean add(E e)</td><td style="text-align:center">在队列<strong>尾部插入</strong>一个元素</td></tr><tr><td style="text-align:center">boolean <strong>offer</strong>(E e)</td><td style="text-align:center">入队：在队列<strong>尾部插入</strong>一个元素</td></tr><tr><td style="text-align:center">E element()</td><td style="text-align:center">返回队列头部的对象，但不从栈中移除它</td></tr><tr><td style="text-align:center">E <strong>peek</strong>()</td><td style="text-align:center">返回队列头部的对象，但不从栈中移除它</td></tr><tr><td style="text-align:center">E remove()</td><td style="text-align:center">返回队列头部的对象，并从栈中移除它</td></tr><tr><td style="text-align:center">E <strong>poll</strong>()</td><td style="text-align:center">出队：返回队列头部的对象，并从栈中移除它</td></tr></tbody></table><blockquote><p>add () 和 offer () 向队列尾部中添加一个元素。他们的不同在于：当使用有容量限制的队列（如 ArrayBlockingQueue）时，若队列已满，调用 add 会抛出一个 IllegalStateException，而调用 offer 不会抛出异常，只会返回 false。</p><p>与 add () 和 offer () 类似，element () 和 peek () 的区别在于：当队列为空时，调用 element () 抛出一个 NoSuchElementException 异常，而 peek () 返回 null。</p><p>remove () 和 poll () 方法都是从队列中删除第一个元素。如果队列元素为空，调用 remove () 的行为与 Collection 接口相似，会抛出 NoSuchElementException 异常，而是新的 poll () 方法在用空集合调用时只是返回 null。</p></blockquote><h2 id="递归算法的时间-空间复杂度"><a class="anchor" href="#递归算法的时间-空间复杂度">#</a> 递归算法的时间、空间复杂度</h2><ul><li><p>时间：<strong>递归的次数 * 每次递归的时间复杂度</strong></p><blockquote><p>递归的次数其实就是二叉树中的节点的个数，按至多计算。</p><p>一棵深度（按根节点深度为 1）为 k 的二叉树最多可以有 2^k - 1 个节点。</p></blockquote></li><li><p>空间：<strong>递归深度 * 每次递归的空间复杂度</strong></p><blockquote><p>这里是递归的深度，而不是递归的次数。因为每次递归所需的空间都被压到调用栈里（这是内存管理里面的数据结构，和算法里的栈原理是一样的），一次递归结束，这个栈就是就是把本次递归的数据弹出去。所以这个栈最大的长度就是递归的深度。</p></blockquote></li></ul><h2 id="数组"><a class="anchor" href="#数组">#</a> 数组</h2><h3 id="理论基础"><a class="anchor" href="#理论基础">#</a> 理论基础</h3><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/%25E7%25AE%2597%25E6%25B3%2595%25E9%2580%259A%25E5%2585%25B3%25E6%2595%25B0%25E7%25BB%2584.png" alt="算法通关数组"></p><p>定义：<strong>数组是存放在<u>连续内存空间</u>上的<u>相同类型</u>数据的集合。</strong></p><p>注意：</p><ul><li><p>在<strong>删除或者增添</strong>元素的时候，就难免<strong>要移动其他元素的地址</strong>。</p></li><li><p><strong>数组的元素是不能删的，只能覆盖。</strong></p></li><li><p><strong>在 C++ 中二维数组在地址空间上是连续的。</strong></p></li></ul><h3 id="704-二分查找"><a class="anchor" href="#704-二分查找">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iaW5hcnktc2VhcmNoLw==">704. 二分查找</span></h3><p>使用二分法的 **<u>前提条件</u>**：</p><ul><li><p>数组是<strong>有序</strong>的</p></li><li><p>数组中<strong>无重复</strong>元素</p><blockquote><p>否则返回的元素下标可能不是唯一的</p></blockquote></li></ul><p>难点：<u>边界条件</u>如何确定，需要坚持根据 **<u>区间的定义</u>**（不变量），即<u>循环不变量</u>规则</p><ul><li><p>左闭右闭 <strong>[left, right]</strong></p><blockquote><ol><li>初始化 right = <code>nums.length - 1</code></li><li>while(left <code>&lt;=</code> right)，因为 left == right 是有意义的，对 [left,right] 有效</li><li>if (nums [middle] &gt; target) 时 right 要赋值为 <code>middle - 1</code></li></ol></blockquote></li><li><p>左闭右开 <strong>[left, right)</strong></p><blockquote><ol><li>初始化 right = <code>nums.length</code></li><li>while (left <code>&lt;</code> right)，因为 left == right 在区间 [left, right) 是没有意义的</li><li>if (nums [middle] &gt; target) 时 right 更新为 <code>middle</code> ，因为当前 nums [middle] 不等于 target，去左区间继续寻找，而寻找<strong>区间是左闭右开</strong>区间，所以 right 更新为 middle，即：下一个查询区间不会去比较 nums [middle]</li></ol></blockquote></li></ul><p>代码：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 左闭右闭区间</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">search</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>target <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">||</span> target <span class="token operator">></span> nums<span class="token punctuation">[</span>nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">// 如果目标值小于数组中最小值或者大于数组中最大值，直接返回 - 1，目的是为了减少循环次数</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> right <span class="token operator">=</span> nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 注意这里是 & lt;=，因为当 left==right 时区间 [left,right] 依然有效，如果是 & lt;，那么最后一次循环时，left=right，此时区间 [left,right] 中只有一个元素，如果此时 target=nums [left]，那么就会漏掉这个元素</span></pre></td></tr><tr><td data-num="9"></td><td><pre>            <span class="token keyword">int</span> mid <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 为什么不用 (left+right)/2，因为这样可能会溢出，即 left+right 的值可能会大于 int 的最大值，所以用位运算，>>1 相当于除以 2</span></pre></td></tr><tr><td data-num="10"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="11"></td><td><pre>                <span class="token keyword">return</span> mid<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> target<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="13"></td><td><pre>                left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">//target 在右区间，所以 [mid+1,right]</span></pre></td></tr><tr><td data-num="14"></td><td><pre>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">></span> target<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="15"></td><td><pre>                right <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">//target 在左区间，所以 [left,mid-1]</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// 如果没有找到，返回 - 1</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 左闭右开区间：[left, right)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">search</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>target <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">||</span> target <span class="token operator">></span> nums<span class="token punctuation">[</span>nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> right <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>  <span class="token comment">// 注意这里是 nums.length，因为是左闭右开区间</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 注意这里是 & lt;，因为当 left==right 时区间 [left,right) 无效，如果是 & lt;=，那么最后一次循环时，left=right，此时区间 [left,right) 中没有元素</span></pre></td></tr><tr><td data-num="9"></td><td><pre>            <span class="token keyword">int</span> mid <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="11"></td><td><pre>                <span class="token keyword">return</span> mid<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> target<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="13"></td><td><pre>                left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">></span> target<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="15"></td><td><pre>                right <span class="token operator">=</span> mid<span class="token punctuation">;</span>  <span class="token comment">//target 在左区间，所以 [left,mid)，因为右边是开区间，所以不用 mid-1</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h4 id="35-搜索插入位置"><a class="anchor" href="#35-搜索插入位置">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zZWFyY2gtaW5zZXJ0LXBvc2l0aW9uLw==">35. 搜索插入位置</span></h4><p>很容易判断该题符合 **“二分查找” 方法的两个前提条件：有序数组、无重复元素 **。</p><p>因此要解决 **“二分查找” 的难点：区间的确定 **（左闭右闭 / 左闭右开）。</p><p>与 [704. 二分查找] 不同的是，该题要求在数组中找不到目标值时，需要返回它将会被按顺序插入的位置下标，无非<strong>四种情况</strong>：</p><ul><li>目标值在数组所有元素之前</li><li>目标值等于数组中某一个元素（直接返回下标）</li><li>目标值插入数组中的位置</li><li>目标值在数组所有元素之后</li></ul><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/20201216232148471.png" alt="35_搜索插入位置3"></p><h5 id="暴力解法"><a class="anchor" href="#暴力解法">#</a> 暴力解法</h5><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">/* 一共四种情况：</span></pre></td></tr><tr><td data-num="3"></td><td><pre>      ①目标值在数组所有元素之前</pre></td></tr><tr><td data-num="4"></td><td><pre>      ②目标值等于数组中某一个元素</pre></td></tr><tr><td data-num="5"></td><td><pre>      ③目标值插入数组中的位置</pre></td></tr><tr><td data-num="6"></td><td><pre>      ④目标值在数组所有元素之后</pre></td></tr><tr><td data-num="7"></td><td><pre>    */</pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token comment">// 暴力解法</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">searchInsert</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>            <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">>=</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>                <span class="token keyword">return</span> i<span class="token punctuation">;</span>  <span class="token comment">// ①②③</span></pre></td></tr><tr><td data-num="13"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token keyword">return</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>  <span class="token comment">// ④</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><ul><li>时间复杂度：O (n)</li><li>空间复杂度：当参数 nums 为首地址时为 O (1)，当参数 nums 为拷贝数组时为 O (n)</li></ul><p>效率如下：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20221207155315649.png" alt="image-20221207155315649"></p><h5 id="二分查找法"><a class="anchor" href="#二分查找法">#</a> 二分查找法</h5><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 二分查找法（左闭右闭）</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token comment">/* 一共四种情况：</span></pre></td></tr><tr><td data-num="4"></td><td><pre>      ①目标值在数组所有元素之前</pre></td></tr><tr><td data-num="5"></td><td><pre>      ②目标值等于数组中某一个元素</pre></td></tr><tr><td data-num="6"></td><td><pre>      ③目标值插入数组中的位置</pre></td></tr><tr><td data-num="7"></td><td><pre>      ④目标值在数组所有元素之后</pre></td></tr><tr><td data-num="8"></td><td><pre>    */</pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">searchInsert</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> right <span class="token operator">=</span> nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>            <span class="token keyword">int</span> mid <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>                <span class="token keyword">return</span> mid<span class="token punctuation">;</span>  <span class="token comment">// ②</span></pre></td></tr><tr><td data-num="15"></td><td><pre>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>                left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">></span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>                right <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>        <span class="token comment">// ①[0, -1]</span></pre></td></tr><tr><td data-num="22"></td><td><pre>        <span class="token comment">// ③[left, right]，return  right + 1</span></pre></td></tr><tr><td data-num="23"></td><td><pre>        <span class="token comment">// ④[left, right]，因为是右闭区间，所以 return right + 1</span></pre></td></tr><tr><td data-num="24"></td><td><pre>        <span class="token keyword">return</span> right <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="26"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><ul><li>时间复杂度：O (log n)</li><li>空间复杂度：O (1)</li></ul><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20221207162150733.png" alt="image-20221207162150733"></p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 二分查找法（左闭右开）</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token comment">/* 一共四种情况：</span></pre></td></tr><tr><td data-num="4"></td><td><pre>      ①目标值在数组所有元素之前</pre></td></tr><tr><td data-num="5"></td><td><pre>      ②目标值等于数组中某一个元素</pre></td></tr><tr><td data-num="6"></td><td><pre>      ③目标值插入数组中的位置</pre></td></tr><tr><td data-num="7"></td><td><pre>      ④目标值在数组所有元素之后</pre></td></tr><tr><td data-num="8"></td><td><pre>    */</pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">searchInsert</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> right <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>            <span class="token keyword">int</span> mid <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>                <span class="token keyword">return</span> mid<span class="token punctuation">;</span>  <span class="token comment">// ②</span></pre></td></tr><tr><td data-num="15"></td><td><pre>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>                left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">></span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>                right <span class="token operator">=</span> mid<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>        <span class="token comment">// ① [0,0)</span></pre></td></tr><tr><td data-num="22"></td><td><pre>        <span class="token comment">// ③ [left, right) ，return right 即可</span></pre></td></tr><tr><td data-num="23"></td><td><pre>        <span class="token comment">// ④ [left, right)，因为是右开区间，所以 return right</span></pre></td></tr><tr><td data-num="24"></td><td><pre>        <span class="token keyword">return</span> right<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="26"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><ul><li>时间复杂度：O (log n)</li><li>空间复杂度：O (1)</li></ul><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20221207162255427.png" alt="image-20221207162255427"></p><h3 id="27-移除元素"><a class="anchor" href="#27-移除元素">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yZW1vdmUtZWxlbWVudC8=">27. 移除元素</span></h3><p>首先明确：<strong>数组的元素在内存地址中是连续的，不能单独删除数组中的某个元素，只能覆盖。</strong></p><h4 id="暴力解法-2"><a class="anchor" href="#暴力解法-2">#</a> 暴力解法</h4><p>两层 for 循环，一个 for 循环遍历数组元素 ，第二个 for 循环将后面的元素集体往前移动一位。删除过程如下：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/008eGmZEly1gntrc7x9tjg30du09m1ky.gif" alt="27.移除元素-暴力解法"></p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">removeElement</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token comment">// 暴力解法，时间复杂度 O (n^2)，空间复杂度 O (1)</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token keyword">int</span> size <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 找到了要删除的元素</span></pre></td></tr><tr><td data-num="7"></td><td><pre>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 将后面的元素往前移动一位</span></pre></td></tr><tr><td data-num="8"></td><td><pre>                    nums<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>                <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>                i<span class="token operator">--</span><span class="token punctuation">;</span> <span class="token comment">// 因为 i 后面的元素都往前移动了一位，所以 i 也要往前移动一位</span></pre></td></tr><tr><td data-num="11"></td><td><pre>                size<span class="token operator">--</span><span class="token punctuation">;</span> <span class="token comment">// 数组长度减一</span></pre></td></tr><tr><td data-num="12"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token keyword">return</span> size<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20221207171156373.png" alt="image-20221207171156373"></p><h4 id="双指针法"><a class="anchor" href="#双指针法">#</a> 双指针法</h4><p>双指针法（快慢指针法）： ** 通过一个<u>快指针</u>和<u>慢指针</u>在一个 for 循环下完成两个 for 循环的工作。** 对整个数组 nums 重新赋一遍值。</p><blockquote><p>在数组和链表的操作中是非常常见的，很多考察<strong>数组、链表、字符串</strong>等操作的面试题，都使用双指针法。</p></blockquote><ul><li>快指针：寻找新数组的元素 ，新数组就是不含有目标元素的数组</li><li>慢指针：指向更新 新数组下标的位置</li></ul><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/008eGmZEly1gntrds6r59g30du09mnpd.gif" alt="27.移除元素-双指针法"></p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">removeElement</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token comment">// 双指针，时间复杂度 O (n)，空间复杂度 O (1)</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token keyword">int</span> slow <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> fast <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">//slow 指向新数组的更新位置，fast 指向新数组的元素</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> fast <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> fast<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>fast<span class="token punctuation">]</span> <span class="token operator">!=</span> val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>                nums<span class="token punctuation">[</span>slow<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>fast<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>                slow<span class="token operator">++</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token keyword">return</span> slow<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>以上两种方法都没有改变元素的相对位置。</p><h4 id="相向双指针"><a class="anchor" href="#相向双指针">#</a> 相向双指针</h4><blockquote><p>不懂</p></blockquote><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">removeElement</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token comment">// 相向双指针，基于元素顺序可以改变的条件，改变了元素相对位置，确保了移动最少元素</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token comment">// 时间复杂度：O (n)，空间复杂度：O (1)</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">int</span> leftIndex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> rightIndex <span class="token operator">=</span> nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token keyword">while</span><span class="token punctuation">(</span>rightIndex<span class="token operator">>=</span><span class="token number">0</span> <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>rightIndex<span class="token punctuation">]</span> <span class="token operator">==</span> val<span class="token punctuation">)</span> rightIndex<span class="token operator">--</span><span class="token punctuation">;</span>  <span class="token comment">// 将 rightIndex 移动到右数第一个不等于 val 的位置</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token keyword">while</span><span class="token punctuation">(</span>leftIndex <span class="token operator">&lt;=</span> rightIndex<span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>            <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>leftIndex<span class="token punctuation">]</span> <span class="token operator">==</span> val<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token comment">//leftIndex 位置的元素需要移除</span></pre></td></tr><tr><td data-num="9"></td><td><pre>                <span class="token comment">// 将 rightIndex 位置的元素移到 leftIndex（覆盖），rightIndex 位置移除</span></pre></td></tr><tr><td data-num="10"></td><td><pre>                nums<span class="token punctuation">[</span>leftIndex<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>rightIndex<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>                rightIndex<span class="token operator">--</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>            leftIndex<span class="token operator">++</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>            <span class="token keyword">while</span><span class="token punctuation">(</span>rightIndex<span class="token operator">>=</span><span class="token number">0</span> <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>rightIndex<span class="token punctuation">]</span> <span class="token operator">==</span> val<span class="token punctuation">)</span> rightIndex<span class="token operator">--</span><span class="token punctuation">;</span>  <span class="token comment">// 将 rightIndex 移动到右数第一个不等于 val 的位置</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token keyword">return</span> leftIndex<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20221207175618200.png" alt="image-20221207175618200"></p><h3 id="977-有序数组的平方"><a class="anchor" href="#977-有序数组的平方">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zcXVhcmVzLW9mLWEtc29ydGVkLWFycmF5Lw==">977. 有序数组的平方</span></h3><blockquote><p>双指针风骚起来，也是无敌</p></blockquote><h4 id="暴力排序"><a class="anchor" href="#暴力排序">#</a> 暴力排序</h4><p>每个数平方之后，排个序，美滋滋！</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">sortedSquares</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token comment">// 暴力解法，对数组进行平方，然后排序</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token comment">// 时间复杂度 O (n + nlogn)，空间复杂度 O (1)</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>            nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">*=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// Arrays.sort () 为快速排序，时间复杂度为 O (nlogn)</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><ul><li>时间复杂度：O (n + nlogn)</li><li>空间复杂度：O (1)</li></ul><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20221207180842460.png" alt="image-20221207180842460"></p><h4 id="双指针法-2"><a class="anchor" href="#双指针法-2">#</a> 双指针法</h4><p>数组其实是有序的， 只不过负数平方之后可能成为最大数了。</p><p>那么<strong>数组平方的最大值就在数组的两端</strong>，不是最左边就是最右边，不可能是根。</p><p>此时可以考虑<strong>双指针法，i 指向起始位置，j 指向终止位置</strong>。</p><p>定义一个<strong>新数组 result</strong>，和 A 数组一样的大小，让<strong> k 指向 result 数组终止位置</strong>。</p><p>如果 <code>A[i] * A[i] &lt; A[j] * A[j]</code> 那么 <code>result[k--] = A[j] * A[j];</code> 。</p><p>如果 <code>A[i] * A[i] &gt;= A[j] * A[j]</code> 那么 <code>result[k--] = A[i] * A[i];</code> 。</p><p>如动画所示：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/977.%25E6%259C%2589%25E5%25BA%258F%25E6%2595%25B0%25E7%25BB%2584%25E7%259A%2584%25E5%25B9%25B3%25E6%2596%25B9.gif" alt="img"></p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">sortedSquares</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token comment">// 双指针法，时间复杂度 O (n)</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token keyword">int</span> k <span class="token operator">=</span> nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">//k 指向最后一个元素</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>nums<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 结果数组</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token comment">//i 指向第一个元素，j 指向最后一个元素</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> j<span class="token punctuation">;</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">*</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">*</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>                res<span class="token punctuation">[</span>k<span class="token operator">--</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">*</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>                i<span class="token operator">++</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>                res<span class="token punctuation">[</span>k<span class="token operator">--</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">*</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>                j<span class="token operator">--</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token keyword">return</span> res<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><ul><li>时间复杂度：O (n)。比暴力解法的 O (n+nlog n) 要好。</li></ul><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20221207184259345.png" alt="image-20221207184259345"></p><h3 id="209-长度最小的子数组"><a class="anchor" href="#209-长度最小的子数组">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9taW5pbXVtLXNpemUtc3ViYXJyYXktc3VtLw==">209. 长度最小的子数组</span></h3><h4 id="暴力解法-3"><a class="anchor" href="#暴力解法-3">#</a> 暴力解法</h4><p>两层 for 循环，外层遍历起始位置，内层遍历终止位置，枚举出所有子数组情况，找出最小的长度即可。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">minSubArrayLen</span><span class="token punctuation">(</span><span class="token keyword">int</span> target<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token comment">// 暴力解法</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token constant">MAX_VALUE</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token keyword">int</span> subLength <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>            sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span> j <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>                sum <span class="token operator">+=</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>                <span class="token keyword">if</span> <span class="token punctuation">(</span>sum <span class="token operator">>=</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 找到了满足条件的子数组</span></pre></td></tr><tr><td data-num="12"></td><td><pre>                    subLength <span class="token operator">=</span> j <span class="token operator">-</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>                    result <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>result<span class="token punctuation">,</span> subLength<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 更新最小长度</span></pre></td></tr><tr><td data-num="14"></td><td><pre>                    <span class="token keyword">break</span><span class="token punctuation">;</span>  <span class="token comment">// 直接退出内层循环，因为要寻找的是最小长度的子数组，所以不需要再往后找了</span></pre></td></tr><tr><td data-num="15"></td><td><pre>                <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>        <span class="token keyword">return</span> result <span class="token operator">==</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token constant">MAX_VALUE</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> result<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>时间复杂度：O (n^2)。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20221208131701222.png" alt="image-20221208131701222"></p><h4 id="滑动窗口"><a class="anchor" href="#滑动窗口">#</a> 滑动窗口</h4><p>所谓滑动窗口，<strong>就是不断的调节子序列的起始位置和终止位置，从而得出我们要想的结果</strong>。</p><p><strong>滑动窗口用<u>一个 for 循环</u>来完成</strong>。</p><p>首先要思考如果用一个 for 循环，那么应该表示滑动窗口的起始位置，还是终止位置？</p><ul><li>如果只用一个 for 循环来表示 滑动窗口的起始位置，那么如何遍历剩下的终止位置？此时难免再次陷入 暴力解法的怪圈。</li><li>所以 <strong>只用一个 for 循环，那么这个循环的索引，一定是表示 滑动窗口的<u>终止位置</u></strong>。</li></ul><p>那么问题来了， 滑动窗口的<strong>起始位置如何移动呢</strong>？可以看如下动画，假设 s=7。</p><p><img data-src="https://code-thinking.cdn.bcebos.com/gifs/209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.gif" alt="209.长度最小的子数组"></p><p>可以发现<strong>滑动窗口也可以理解为双指针法的一种！</strong></p><p>在本题中实现滑动窗口，主要确定如下三点：</p><ul><li><strong>窗口内</strong>是什么：满足其和 ≥ s 的长度最小的 连续 子数组。</li><li>窗口的<strong>起始位置</strong>：如果当前窗口的值大于 s 了，起始位置就要向前移动了（也就是窗口该缩小了）</li><li>窗口的<strong>结束位置</strong>：即 for 循环里的索引</li></ul><p>解题的关键在于 <strong>窗口的起始位置如何移动</strong>，如图所示：</p><p><img data-src="https://img-blog.csdnimg.cn/20210312160441942.png" alt="leetcode_209"></p><p>可以发现<strong>滑动窗口的精妙之处在于根据当前子序列和大小的情况，不断调节子序列的起始位置。从而将 O (n^2) 暴力解法降为 O (n)。</strong></p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">minSubArrayLen</span><span class="token punctuation">(</span><span class="token keyword">int</span> target<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token comment">// 滑动窗口，时间复杂度 O (n)</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token constant">MAX_VALUE</span><span class="token punctuation">;</span> <span class="token comment">// 最小长度</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 窗口内的和</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token keyword">int</span> subLength <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 窗口的长度</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 起始位置</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 结束位置</span></pre></td></tr><tr><td data-num="9"></td><td><pre>            sum <span class="token operator">+=</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>            <span class="token keyword">while</span> <span class="token punctuation">(</span>sum <span class="token operator">>=</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 如果窗口内的和大于等于 target，就缩小窗口，争取找到最小的窗口</span></pre></td></tr><tr><td data-num="11"></td><td><pre>                subLength <span class="token operator">=</span> j <span class="token operator">-</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>                result <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>result<span class="token punctuation">,</span> subLength<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>                sum <span class="token operator">-=</span> nums<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 滑动窗口的精髓：起始位置如何移动</span></pre></td></tr><tr><td data-num="14"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token keyword">return</span> result <span class="token operator">==</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token constant">MAX_VALUE</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> result<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><ul><li>时间复杂度：O (n)</li><li>空间复杂度：O (1)</li></ul><p><strong>一些录友会疑惑为什么时间复杂度是 O (n)</strong>。</p><p>不要以为 for 里放一个 while 就以为是 O (n^2) 啊， 主要是<strong>看每一个元素被操作的次数</strong>，每个元素在滑动窗后进来操作一次，出去操作一次，<strong>每个元素都是被操作两次</strong>，所以时间复杂度是 2 × n 也就是 O (n)。</p><h3 id="59-螺旋矩阵-ii"><a class="anchor" href="#59-螺旋矩阵-ii">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zcGlyYWwtbWF0cml4LWlpLw==">59. 螺旋矩阵 II</span></h3><p>例如：</p><p><img data-src="https://assets.leetcode.com/uploads/2020/11/13/spiraln.jpg" alt="img"></p><pre><code>输入：n = 3
输出：[[1,2,3],[8,9,4],[7,6,5]]
</code></pre><p>本体并不涉及什么算法，就是模拟过程。</p><p>前面在<u>二分查找法</u>中提到一定要坚持<strong>循环不变量原则</strong>，本题亦如此。</p><p>模拟顺时针画矩阵的过程:</p><ul><li>填充上行从左到右</li><li>填充右列从上到下</li><li>填充下行从右到左</li><li>填充左列从下到上</li></ul><p>由外向内一圈一圈这么画下去。</p><p>可以发现这里的<strong>边界条件非常多</strong>，在一个循环中，如此多的边界条件，必须坚持<strong>按照固定规则来遍历</strong>。</p><p>这里一圈下来，我们要画每四条边，这四条边怎么画，<strong>每画一条边都要坚持一致的原则（左闭右开，或者左开右闭）</strong>，这样这一圈才能按照统一的规则画下来。</p><p>那么我按照左闭右开 [left,right) 的原则，来画一圈，大家看一下：</p><p><img data-src="https://code-thinking-1253855093.file.myqcloud.com/pics/20220922102236.png" alt="img"></p><p>这里每一种颜色，代表一条边，我们遍历的长度，可以看出每一个拐角处的处理规则，拐角处让给新的一条边来继续画。这也是坚持了每条边左闭右开的原则。</p><p>代码如下，已经详细注释了每一步的目的，可以看出 while 循环里判断的情况是很多的，代码里处理的原则也是统一的左闭右开。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">generateMatrix</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token keyword">int</span> start <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 每次循环一个圈的起始位置：(start, start)</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">int</span> loop <span class="token operator">=</span> n <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">// 循环圈数</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token keyword">int</span> mid <span class="token operator">=</span> n <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">// 当 n 为奇数时，需要对中间位置额外处理赋值</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 赋值计数器</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token keyword">int</span> offset <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 需要控制每一条边遍历的长度，每次循环右边界收缩一位</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token keyword">int</span> i<span class="token punctuation">,</span> j<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token keyword">while</span> <span class="token punctuation">(</span>loop<span class="token operator">--</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>            i <span class="token operator">=</span> start<span class="token punctuation">;</span> <span class="token comment">// 行索引</span></pre></td></tr><tr><td data-num="12"></td><td><pre>            j <span class="token operator">=</span> start<span class="token punctuation">;</span> <span class="token comment">// 列索引</span></pre></td></tr><tr><td data-num="13"></td><td><pre>            <span class="token comment">// 下面开始模拟螺旋矩阵的赋值过程</span></pre></td></tr><tr><td data-num="14"></td><td><pre>            <span class="token comment">// 模拟填充上行从左到右 (左闭右开)</span></pre></td></tr><tr><td data-num="15"></td><td><pre>            <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> start<span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n <span class="token operator">-</span> offset<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>                result<span class="token punctuation">[</span>start<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> count<span class="token operator">++</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>            <span class="token comment">// 模拟填充右列从上到下 (左闭右开)</span></pre></td></tr><tr><td data-num="19"></td><td><pre>            <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> start<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token operator">-</span> offset<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>                result<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> count<span class="token operator">++</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>            <span class="token comment">// 模拟填充下行从右到左 (左闭右开)</span></pre></td></tr><tr><td data-num="23"></td><td><pre>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> j <span class="token operator">></span> start<span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>                result<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> count<span class="token operator">++</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>            <span class="token comment">// 模拟填充左列从下到上 (左闭右开)</span></pre></td></tr><tr><td data-num="27"></td><td><pre>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> i <span class="token operator">></span> start<span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>                result<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> count<span class="token operator">++</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="30"></td><td><pre></pre></td></tr><tr><td data-num="31"></td><td><pre>            <span class="token comment">// 每次循环右边界收缩一位</span></pre></td></tr><tr><td data-num="32"></td><td><pre>            offset<span class="token operator">++</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="33"></td><td><pre>            <span class="token comment">// 每次循环起始位置向内移动一位</span></pre></td></tr><tr><td data-num="34"></td><td><pre>            start<span class="token operator">++</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="35"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="36"></td><td><pre>        <span class="token comment">// 当 n 为奇数时，需要对中间位置额外处理赋值</span></pre></td></tr><tr><td data-num="37"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="38"></td><td><pre>            result<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">=</span> count<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="39"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="40"></td><td><pre>        <span class="token keyword">return</span> result<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="41"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="42"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id="总结"><a class="anchor" href="#总结">#</a> 总结</h3><ul><li><p><strong>二维数组在内存的空间地址是连续的么？</strong></p><p>我们来举一个 Java 的例子，例如： <code>int[][] rating = new int[3][4];</code> ， 这个二维数组在内存空间可不是一个 <code>3*4</code> 的连续地址空间</p><p>看了下图，就应该明白了：</p><p><img data-src="https://code-thinking.cdn.bcebos.com/pics/%E7%AE%97%E6%B3%95%E9%80%9A%E5%85%B3%E6%95%B0%E7%BB%843.png" alt="img"></p><p>所以<strong> Java 的二维数组在内存中不是 <code>3*4</code> 的连续地址空间，而是四条连续的地址空间组成！</strong></p></li><li><p>二分法</p><ul><li>暴力解法时间复杂度：O (n)</li><li>二分法时间复杂度：<strong>O(logn)</strong></li></ul><p><strong>循环不变量原则</strong>，只有在循环中坚持对<u>区间的定义</u>，才能清楚的把握循环中的各种细节。</p></li><li><p>双指针法</p><ul><li>暴力解法时间复杂度：O (n^2)</li><li>双指针时间复杂度：<strong>O(n)</strong></li></ul><p><strong>通过一个快指针和慢指针在<u>一个 for 循环</u>下完成两个 for 循环的工作。</strong></p><p><strong>数组中的元素为什么不能删除</strong>，主要是因为以下两点：</p><ul><li>数组在内存中是<strong>连续的地址空间</strong>，不能释放单一元素，如果要释放，就是全释放（程序运行结束，回收内存栈空间）。</li><li>C++ 中 vector 和 array 的区别一定要弄清楚，vector 的底层实现是 array，封装后使用更友好。</li></ul><p>双指针法（快慢指针法）在数组和链表的操作中是非常常见的，很多考察数组和链表操作的面试题，都使用双指针法。</p></li><li><p>滑动窗口</p><ul><li>暴力解法时间复杂度：O (n^2)</li><li>滑动窗口时间复杂度：<strong>O(n)</strong></li></ul><p>主要要理解滑动窗口<strong>如何移动窗口起始位置</strong>，达到动态更新窗口大小的，从而得出长度最小的符合条件的长度。</p><p>滑动窗口的精妙之处在于<strong>根据当前子序列和大小的情况，不断调节子序列的起始位置</strong>。从而将 O (n^2) 的暴力解法降为 O (n)。</p></li><li><p>模拟行为</p><p><strong>循环不变量原则</strong>，需要明确边界条件，明确区间的定义，其实这也是写程序中的重要原则。</p></li><li><p>小结</p></li></ul><p><img data-src="https://code-thinking-1253855093.file.myqcloud.com/pics/%E6%95%B0%E7%BB%84%E6%80%BB%E7%BB%93.png" alt="img"></p><h2 id="链表"><a class="anchor" href="#链表">#</a> 链表</h2><h3 id="链表理论基础"><a class="anchor" href="#链表理论基础">#</a> 链表理论基础</h3><h4 id="类型"><a class="anchor" href="#类型">#</a> 类型</h4><ul><li>单链表</li></ul><blockquote><p><img data-src="https://img-blog.csdnimg.cn/20200806194529815.png" alt="链表1"></p><p>一种通过指针串联在一起的线性结构，每一个节点由两部分组成，一个是<strong>数据域</strong>，一个是<strong>指针域</strong>（存放指向下一个节点的指针)。</p><p>最后一个节点的指针域指向 <code>null</code> （空指针的意思）。链表的入口节点称为链表的头结点也就是 <code>head</code> 。</p></blockquote><ul><li>双链表</li></ul><blockquote><p><img data-src="https://img-blog.csdnimg.cn/20200806194559317.png" alt="链表2"></p><p>每一个节点有<strong>两个指针域</strong>，一个指向下一个节点，一个指向上一个节点。</p><p>双链表既可以向前查询也可以向后查询。</p></blockquote><ul><li>循环链表</li></ul><blockquote><p><img data-src="https://img-blog.csdnimg.cn/20200806194629603.png" alt="链表4"></p><p>链表<strong>首尾相连</strong>。</p><p>可以用来解决<u>约瑟夫环问题</u>。</p></blockquote><h4 id="存储方式"><a class="anchor" href="#存储方式">#</a> 存储方式</h4><p>数组是在内存中是连续分布的，但是链表在内存中可<strong>不是连续分布的</strong>。</p><p>链表是通过指针域的<strong>指针</strong>链接在内存中各个节点。</p><p>所以<strong>链表中的节点在内存中不是连续分布的 ，而是散乱分布在内存中的某地址上，分配机制取决于操作系统的内存管理</strong>。</p><p><img data-src="https://img-blog.csdnimg.cn/20200806194613920.png" alt="链表3"></p><p>这个链表起始节点为 2， 终止节点为 7， 各个节点分布在内存的不同地址空间上，通过指针串联在一起。</p><h4 id="节点的定义"><a class="anchor" href="#节点的定义">#</a> 节点的定义</h4><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ListNode</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 结点的值</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">int</span> val<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token comment">// 下一个结点</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token class-name">ListNode</span> next<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    </pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token comment">// 节点的构造函数 (无参)</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token comment">// 节点的构造函数 (有一个参数)</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token keyword">this</span><span class="token punctuation">.</span>val <span class="token operator">=</span> val<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token comment">// 节点的构造函数 (有两个参数)</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> val<span class="token punctuation">,</span> <span class="token class-name">ListNode</span> next<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token keyword">this</span><span class="token punctuation">.</span>val <span class="token operator">=</span> val<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token keyword">this</span><span class="token punctuation">.</span>next <span class="token operator">=</span> next<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h4 id="操作"><a class="anchor" href="#操作">#</a> 操作</h4><ul><li>删除节点</li></ul><blockquote><p>删除 D 节点，如图所示：</p><p><img data-src="https://img-blog.csdnimg.cn/20200806195114541.png" alt="链表-删除节点"></p><p><strong>只要将 C 节点的 next 指针 指向 E 节点就可以了</strong>。</p><p>那有同学说了，D 节点不是依然存留在内存里么？只不过是没有在这个链表里而已。</p><p>是这样的，所以<strong>在 C++ 里最好是再手动释放这个 D 节点</strong>，释放这块内存。</p><p>其他语言例如<strong> Java、Python，就有自己的内存回收机制，就不用自己手动释放了</strong>。</p></blockquote><ul><li>添加节点</li></ul><blockquote><p>如图所示：</p><p><img data-src="https://img-blog.csdnimg.cn/20200806195134331.png" alt="链表-添加节点"></p><p>可以看出链表的<strong>增添和删除都是 O (1) 操作</strong>，也不会影响到其他节点。</p><p>但是要注意，要是删除第五个节点，需要从头节点查找到第四个节点通过 next 指针进行删除操作，<strong>查找的时间复杂度是 O (n)</strong>。</p></blockquote><h4 id="性能分析与数组做对比"><a class="anchor" href="#性能分析与数组做对比">#</a> 性能分析（与数组做对比）</h4><p><img data-src="https://img-blog.csdnimg.cn/20200806195200276.png" alt="链表-链表与数据性能对比"></p><h3 id="203-移除链表元素"><a class="anchor" href="#203-移除链表元素">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yZW1vdmUtbGlua2VkLWxpc3QtZWxlbWVudHMv">203. 移除链表元素</span></h3><blockquote><p>链表操作中，可以使用原链表来直接进行删除操作，也可以设置一个<strong>虚拟头结点</strong>在进行删除操作，接下来看一看哪种方式更方便。</p></blockquote><p>如果使用 C，C++ 编程语言的话，不要忘了还要从内存中删除这两个移除的节点。<strong>当然如果使用 java ，python 的话就不用手动管理内存了。</strong></p><ul><li>如果移除的不是头结点，直接让节点的 next 指针指向下下一个节点就行了。</li></ul><blockquote><p><img data-src="https://img-blog.csdnimg.cn/20210316095351161.png" alt="203_链表删除元素1"></p></blockquote><ul><li><p>如果删除的是头结点，有两种链表操作方式：</p><blockquote><p><strong>移除头结点和移除其他节点的操作是不一样的</strong>。</p><p>因为链表的 **<u>其他节点</u>都是通过前一个节点来移除当前节点，而<u>头结点</u>没有前一个节点 **。</p></blockquote><ul><li><strong>直接使用原来的链表来进行删除操作。</strong></li></ul><blockquote><p><img data-src="https://img-blog.csdnimg.cn/2021031609544922.png" alt="203_链表删除元素3"></p><p>只要<strong>将头结点向后移动一位</strong>就可以，这样就从链表中移除了一个头结点。</p><p><img data-src="https://img-blog.csdnimg.cn/20210316095512470.png" alt="203_链表删除元素4"></p><p>依然别忘<strong>将原头结点从内存中删掉</strong>。</p><p><img data-src="https://img-blog.csdnimg.cn/20210316095543775.png" alt="203_链表删除元素5"></p></blockquote><ul><li><strong>设置一个虚拟头结点在进行删除操作。</strong></li></ul><blockquote><p>如果采用上面那种方法来移除头结点的话，会发现在写代码的时候也会发现，<strong>需要单独写一段逻辑来处理移除头结点</strong>的情况。</p><p>其实<strong>可以设置一个虚拟头结点</strong>，以一种<strong>统一的逻辑</strong>来移除链表的节点。</p><p>来看看如何设置一个虚拟头。依然还是在这个链表中，移除元素 1。</p><p><img data-src="https://img-blog.csdnimg.cn/20210316095619221.png" alt="203_链表删除元素6"></p><p>这里来给链表<strong>添加一个虚拟头结点为新的头结点</strong>，此时要移除这个旧头结点元素 1。</p><p>这样是不是就可以使用和移除链表其他节点的方式统一了呢？</p><p>来看一下，如何移除元素 1 呢，<strong>让虚拟头结点的 next 指针指向下一个元素</strong>，然后<strong>从内存中删除元素 1</strong>。</p><p>最后呢在题目中，<strong>return 头结点的时候，别忘了 <code>return dummyNode-&gt;next;</code> ， 这才是新的头结点</strong>。</p></blockquote></li></ul><p>代码如下：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 不设置虚拟头结点</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">ListNode</span> <span class="token function">removeElements</span><span class="token punctuation">(</span><span class="token class-name">ListNode</span> head<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token keyword">while</span> <span class="token punctuation">(</span>head <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> head<span class="token punctuation">.</span>val <span class="token operator">==</span> val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 链表非空，且要删除的是头结点</span></pre></td></tr><tr><td data-num="5"></td><td><pre>            head <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span> <span class="token comment">// 将头结点向后移一位</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 链表为空，或者仅有一个头结点，且已经被删除</span></pre></td></tr><tr><td data-num="8"></td><td><pre>            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// 直接返回空</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token comment">// 链表至少有两个节点，且头结点不是要删除的节点</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token class-name">ListNode</span> prev <span class="token operator">=</span> head<span class="token punctuation">;</span> <span class="token comment">// 设置前驱节点</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token keyword">while</span> <span class="token punctuation">(</span>prev<span class="token punctuation">.</span>next <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 遍历链表</span></pre></td></tr><tr><td data-num="13"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>prev<span class="token punctuation">.</span>next<span class="token punctuation">.</span>val <span class="token operator">==</span> val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 如果当前节点的下一个节点是要删除的节点</span></pre></td></tr><tr><td data-num="14"></td><td><pre>                prev<span class="token punctuation">.</span>next <span class="token operator">=</span> prev<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span> <span class="token comment">// 将当前节点的下一个节点指向下下个节点</span></pre></td></tr><tr><td data-num="15"></td><td><pre>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 如果当前节点的下一个节点不是要删除的节点</span></pre></td></tr><tr><td data-num="16"></td><td><pre>                prev <span class="token operator">=</span> prev<span class="token punctuation">.</span>next<span class="token punctuation">;</span> <span class="token comment">// 将前驱节点向后移一位</span></pre></td></tr><tr><td data-num="17"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>        <span class="token keyword">return</span> head<span class="token punctuation">;</span> <span class="token comment">// 返回头结点</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="21"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 设置虚拟头结点</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">ListNode</span> <span class="token function">removeElements</span><span class="token punctuation">(</span><span class="token class-name">ListNode</span> head<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 如果链表为空，直接返回</span></pre></td></tr><tr><td data-num="5"></td><td><pre>            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token class-name">ListNode</span> dummyHead <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 虚拟头结点</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        dummyHead<span class="token punctuation">.</span>next <span class="token operator">=</span> head<span class="token punctuation">;</span>  <span class="token comment">// 虚拟头结点指向 head</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token class-name">ListNode</span> cur <span class="token operator">=</span> dummyHead<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token keyword">while</span> <span class="token punctuation">(</span>cur<span class="token punctuation">.</span>next <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>cur<span class="token punctuation">.</span>next<span class="token punctuation">.</span>val <span class="token operator">==</span> val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>                cur<span class="token punctuation">.</span>next <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>                cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token keyword">return</span> dummyHead<span class="token punctuation">.</span>next<span class="token punctuation">;</span> <span class="token comment">// 返回虚拟头结点的下一个节点</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id="707-设计链表"><a class="anchor" href="#707-设计链表">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9kZXNpZ24tbGlua2VkLWxpc3Qv">707. 设计链表</span></h3><blockquote><p>听说这道题目把链表常见的五个操作都覆盖了？</p></blockquote><p>删除链表节点： <img data-src="https://img-blog.csdnimg.cn/20200806195114541.png" alt="链表-删除节点"></p><p>添加链表节点： <img data-src="https://img-blog.csdnimg.cn/20200806195134331.png" alt="链表-添加节点"></p><p>这道题目设计链表的五个接口：</p><ul><li>获取链表第 index 个节点的数值</li><li>在链表的最前面插入一个节点</li><li>在链表的最后面插入一个节点</li><li>在链表第 index 个节点前面插入一个节点</li><li>删除链表的第 index 个节点</li></ul><p>可以说这五个接口，已经覆盖了链表的常见操作，是练习链表操作非常好的一道题目</p><p><strong>链表操作的两种方式：</strong></p><ol><li>直接使用原来的链表来进行操作。</li><li>设置一个虚拟头结点在进行操作。</li></ol><p>下面采用的<strong>设置一个虚拟头结点</strong>（这样更方便一些，大家看代码就会感受出来）。</p><p>代码如下，分别是实现单链表、双链表：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 单链表节点</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">ListNode</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">int</span> val<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token class-name">ListNode</span> next<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token keyword">this</span><span class="token punctuation">.</span>val <span class="token operator">=</span> val<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token comment">// 单链表</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">MyLinkedList</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token keyword">int</span> size<span class="token punctuation">;</span>  <span class="token comment">// 链表长度</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token class-name">ListNode</span> dummyHead<span class="token punctuation">;</span>  <span class="token comment">// 虚拟头节点</span></pre></td></tr><tr><td data-num="18"></td><td><pre></pre></td></tr><tr><td data-num="19"></td><td><pre>    <span class="token comment">// 初始化链表</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">MyLinkedList</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>        size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>        dummyHead <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="24"></td><td><pre></pre></td></tr><tr><td data-num="25"></td><td><pre>    <span class="token comment">// 获取链表中第 index 个节点的值。如果索引无效，则返回 - 1。</span></pre></td></tr><tr><td data-num="26"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> index <span class="token operator">>=</span> size<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>        <span class="token class-name">ListNode</span> cur <span class="token operator">=</span> dummyHead<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 包含一个虚拟头节点，所以查找第 index+1 个节点</span></pre></td></tr><tr><td data-num="30"></td><td><pre>            cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="31"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>        <span class="token keyword">return</span> cur<span class="token punctuation">.</span>val<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="33"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="34"></td><td><pre></pre></td></tr><tr><td data-num="35"></td><td><pre>    <span class="token comment">// 在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。</span></pre></td></tr><tr><td data-num="36"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addAtHead</span><span class="token punctuation">(</span><span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="37"></td><td><pre>        <span class="token function">addAtIndex</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="38"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="39"></td><td><pre></pre></td></tr><tr><td data-num="40"></td><td><pre>    <span class="token comment">// 将值为 val 的节点追加到链表的最后一个元素。</span></pre></td></tr><tr><td data-num="41"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addAtTail</span><span class="token punctuation">(</span><span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="42"></td><td><pre>        <span class="token function">addAtIndex</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="43"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="44"></td><td><pre></pre></td></tr><tr><td data-num="45"></td><td><pre>    <span class="token comment">// 在链表中的第 index 个节点之前添加值为 val 的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。</span></pre></td></tr><tr><td data-num="46"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addAtIndex</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="47"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">></span> size<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="48"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="49"></td><td><pre>        size<span class="token operator">++</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="50"></td><td><pre>        <span class="token class-name">ListNode</span> prev <span class="token operator">=</span> dummyHead<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="51"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> index<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="52"></td><td><pre>            prev <span class="token operator">=</span> prev<span class="token punctuation">.</span>next<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="53"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="54"></td><td><pre>        <span class="token class-name">ListNode</span> toAdd <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="55"></td><td><pre>        toAdd<span class="token punctuation">.</span>next <span class="token operator">=</span> prev<span class="token punctuation">.</span>next<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="56"></td><td><pre>        prev<span class="token punctuation">.</span>next <span class="token operator">=</span> toAdd<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="57"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="58"></td><td><pre></pre></td></tr><tr><td data-num="59"></td><td><pre>    <span class="token comment">// 如果索引 index 有效，则删除链表中的第 index 个节点。</span></pre></td></tr><tr><td data-num="60"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">deleteAtIndex</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="61"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> index <span class="token operator">>=</span> size<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="62"></td><td><pre>        size<span class="token operator">--</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="63"></td><td><pre>        <span class="token class-name">ListNode</span> prev <span class="token operator">=</span> dummyHead<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="64"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> index<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="65"></td><td><pre>            prev <span class="token operator">=</span> prev<span class="token punctuation">.</span>next<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="66"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="67"></td><td><pre>        prev<span class="token punctuation">.</span>next <span class="token operator">=</span> prev<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="68"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="69"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 双链表节点</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">ListNode</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">int</span> val<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token class-name">ListNode</span> prev<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token class-name">ListNode</span> next<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token keyword">this</span><span class="token punctuation">.</span>val <span class="token operator">=</span> val<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token comment">// 双链表</span></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">MyLinkedList</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token keyword">int</span> size<span class="token punctuation">;</span>  <span class="token comment">// 链表长度</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token class-name">ListNode</span> dummyHead<span class="token punctuation">,</span> tail<span class="token punctuation">;</span>  <span class="token comment">// 虚拟头节点，尾节点</span></pre></td></tr><tr><td data-num="19"></td><td><pre></pre></td></tr><tr><td data-num="20"></td><td><pre>    <span class="token comment">// 初始化链表</span></pre></td></tr><tr><td data-num="21"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">MyLinkedList</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>        size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>        dummyHead <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>        tail <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>        <span class="token comment">// 这一步很重要，不然在 addAtHead 时，会出现空指针异常，即 null.next 错误</span></pre></td></tr><tr><td data-num="26"></td><td><pre>        dummyHead<span class="token punctuation">.</span>next <span class="token operator">=</span> tail<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>        tail<span class="token punctuation">.</span>prev <span class="token operator">=</span> dummyHead<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="29"></td><td><pre></pre></td></tr><tr><td data-num="30"></td><td><pre>    <span class="token comment">// 获取链表中第 index 个节点的值。如果索引无效，则返回 - 1。</span></pre></td></tr><tr><td data-num="31"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> index <span class="token operator">>=</span> size<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="33"></td><td><pre>        <span class="token class-name">ListNode</span> cur <span class="token operator">=</span> dummyHead<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="34"></td><td><pre>        <span class="token comment">// 判断 index 在前半段还是后半段，从而使遍历时间更短</span></pre></td></tr><tr><td data-num="35"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">>=</span> size <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 使用 tail 遍历</span></pre></td></tr><tr><td data-num="36"></td><td><pre>            cur <span class="token operator">=</span> tail<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="37"></td><td><pre>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> size<span class="token punctuation">;</span> i <span class="token operator">></span> index<span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="38"></td><td><pre>                cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>prev<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="39"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="40"></td><td><pre>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 使用 dummyHead 遍历</span></pre></td></tr><tr><td data-num="41"></td><td><pre>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> index<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="42"></td><td><pre>                cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="43"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="44"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="45"></td><td><pre>        <span class="token keyword">return</span> cur<span class="token punctuation">.</span>val<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="46"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="47"></td><td><pre></pre></td></tr><tr><td data-num="48"></td><td><pre>    <span class="token comment">// 在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。</span></pre></td></tr><tr><td data-num="49"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addAtHead</span><span class="token punctuation">(</span><span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="50"></td><td><pre>        <span class="token function">addAtIndex</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="51"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="52"></td><td><pre></pre></td></tr><tr><td data-num="53"></td><td><pre>    <span class="token comment">// 将值为 val 的节点追加到链表的最后一个元素。</span></pre></td></tr><tr><td data-num="54"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addAtTail</span><span class="token punctuation">(</span><span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="55"></td><td><pre>        <span class="token function">addAtIndex</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="56"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="57"></td><td><pre></pre></td></tr><tr><td data-num="58"></td><td><pre>    <span class="token comment">// 在链表中的第 index 个节点之前添加值为 val 的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。</span></pre></td></tr><tr><td data-num="59"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addAtIndex</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="60"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">></span> size<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="61"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="62"></td><td><pre>        size<span class="token operator">++</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="63"></td><td><pre>        <span class="token class-name">ListNode</span> pre <span class="token operator">=</span> dummyHead<span class="token punctuation">;</span>  <span class="token comment">// 找到前驱节点</span></pre></td></tr><tr><td data-num="64"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> index<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="65"></td><td><pre>            pre <span class="token operator">=</span> pre<span class="token punctuation">.</span>next<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="66"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="67"></td><td><pre>        <span class="token class-name">ListNode</span> toAdd <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="68"></td><td><pre>        toAdd<span class="token punctuation">.</span>next <span class="token operator">=</span> pre<span class="token punctuation">.</span>next<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="69"></td><td><pre>        toAdd<span class="token punctuation">.</span>prev <span class="token operator">=</span> pre<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="70"></td><td><pre>        pre<span class="token punctuation">.</span>next<span class="token punctuation">.</span>prev <span class="token operator">=</span> toAdd<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="71"></td><td><pre>        pre<span class="token punctuation">.</span>next <span class="token operator">=</span> toAdd<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="72"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="73"></td><td><pre></pre></td></tr><tr><td data-num="74"></td><td><pre>    <span class="token comment">// 如果索引 index 有效，则删除链表中的第 index 个节点。</span></pre></td></tr><tr><td data-num="75"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">deleteAtIndex</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="76"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> index <span class="token operator">>=</span> size<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="77"></td><td><pre>        size<span class="token operator">--</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="78"></td><td><pre>        <span class="token class-name">ListNode</span> pre <span class="token operator">=</span> dummyHead<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="79"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> index<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="80"></td><td><pre>            pre <span class="token operator">=</span> pre<span class="token punctuation">.</span>next<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="81"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="82"></td><td><pre>        pre<span class="token punctuation">.</span>next <span class="token operator">=</span> pre<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="83"></td><td><pre>        pre<span class="token punctuation">.</span>next<span class="token punctuation">.</span>prev <span class="token operator">=</span> pre<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="84"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="85"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id="206-反转链表"><a class="anchor" href="#206-反转链表">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yZXZlcnNlLWxpbmtlZC1saXN0Lw==">206. 反转链表</span></h3><blockquote><p>反转链表的写法很简单，一些同学甚至可以背下来但过一阵就忘了该咋写，主要是因为没有理解真正的反转过程。</p></blockquote><p>不需要再浪费内存去定义一个新的链表来实现反转，<strong>只需要改变链表的 next 指针的指向</strong>，直接将链表反转：</p><p><img data-src="https://img-blog.csdnimg.cn/20210218090901207.png" alt="206_反转链表"></p><h4 id="双指针法-3"><a class="anchor" href="#双指针法-3">#</a> 双指针法</h4><p>举例，如动画所示：（纠正：动画应该是先移动 pre，在移动 cur）</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/206.%25E7%25BF%25BB%25E8%25BD%25AC%25E9%2593%25BE%25E8%25A1%25A8.gif" alt="img"></p><p>首先定义一个<strong> cur 指针</strong>，指向头结点，再定义一个<strong> pre 指针</strong>，初始化为 null。</p><p>然后就要开始反转了，首先要把 cur-&gt;next 节点用 tmp 指针保存一下，也就是保存一下这个节点。</p><p>为什么要保存一下这个节点呢，因为接下来要改变 cur-&gt;next 的指向了，将 cur-&gt;next 指向 pre ，此时已经反转了第一个节点了。</p><p>接下来，就是循环走如下代码逻辑了，继续移动 pre 和 cur 指针。</p><p>最后，cur 指针已经指向了 null，循环结束，链表也反转完毕了。 此时我们<strong> return pre 指针</strong>就可以了，pre 指针就指向了新的头结点。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 双指针法</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">ListNode</span> <span class="token function">reverseList</span><span class="token punctuation">(</span><span class="token class-name">ListNode</span> head<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token class-name">ListNode</span> pre <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token class-name">ListNode</span> cur <span class="token operator">=</span> head<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token keyword">while</span> <span class="token punctuation">(</span>cur <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>            <span class="token class-name">ListNode</span> tmp <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span> <span class="token comment">// 暂存下一个节点</span></pre></td></tr><tr><td data-num="8"></td><td><pre>            cur<span class="token punctuation">.</span>next <span class="token operator">=</span> pre<span class="token punctuation">;</span> <span class="token comment">// 反转操作</span></pre></td></tr><tr><td data-num="9"></td><td><pre>            <span class="token comment">// 更新 pre、cur（指针后移）</span></pre></td></tr><tr><td data-num="10"></td><td><pre>            pre <span class="token operator">=</span> cur<span class="token punctuation">;</span> <span class="token comment">// 先更新 pre，否则当 cur.next = null 时会出错</span></pre></td></tr><tr><td data-num="11"></td><td><pre>            cur <span class="token operator">=</span> tmp<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token keyword">return</span> pre<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h4 id="递归法"><a class="anchor" href="#递归法">#</a> 递归法</h4><p>递归法相对抽象一些，但是其实和双指针法是一样的逻辑，同样是当 cur 为空的时候循环结束，不断将 cur 指向 pre 的过程。</p><p>关键是初始化的地方，可能有的同学会不理解， 可以看到双指针法中初始化 cur = head，pre = NULL，在递归法中可以从如下代码看出<strong>初始化的逻辑也是一样的</strong>，只不过写法变了。</p><p>具体可以看代码，<strong>双指针法写出来之后，理解如下递归写法就不难了，代码逻辑都是一样的。</strong></p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 递归：从前往后</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">ListNode</span> <span class="token function">reverseList</span><span class="token punctuation">(</span><span class="token class-name">ListNode</span> head<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token keyword">return</span> <span class="token function">reverse</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> head<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将参数 prev 初始化为 null，参数 cur 初始化为 head。与双指针法一样。</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">private</span> <span class="token class-name">ListNode</span> <span class="token function">reverse</span><span class="token punctuation">(</span><span class="token class-name">ListNode</span> prev<span class="token punctuation">,</span> <span class="token class-name">ListNode</span> cur<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>cur <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> prev<span class="token punctuation">;</span> <span class="token comment">// 递归终止条件</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token class-name">ListNode</span> tmp <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span> <span class="token comment">// 暂存下一个节点</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        cur<span class="token punctuation">.</span>next <span class="token operator">=</span> prev<span class="token punctuation">;</span> <span class="token comment">// 反转</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token keyword">return</span> <span class="token function">reverse</span><span class="token punctuation">(</span>cur<span class="token punctuation">,</span> tmp<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 递归</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id="24-两两交换链表中的节点"><a class="anchor" href="#24-两两交换链表中的节点">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zd2FwLW5vZGVzLWluLXBhaXJzLw==">24. 两两交换链表中的节点</span></h3><p><img data-src="https://code-thinking.cdn.bcebos.com/pics/24.%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9-%E9%A2%98%E6%84%8F.jpg" alt="24.两两交换链表中的节点-题意"></p><p>这道题目<strong>正常模拟</strong>就可以了。</p><p>建议使用<strong>虚拟头结点</strong>，这样会方便很多，要不然每次针对头结点（没有前一个指针指向头结点），还要单独处理。</p><p>接下来就是交换相邻两个元素了，此时一定要<strong>画图</strong>，不画图，操作多个指针很容易乱，而且要操作的先后顺序初始时，<strong>cur 指向虚拟头结点</strong>，然后进行如下<strong>三步</strong>：</p><p><img data-src="https://code-thinking.cdn.bcebos.com/pics/24.%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B91.png" alt="24.两两交换链表中的节点1"></p><p>操作之后，链表如下：</p><p><img data-src="https://code-thinking.cdn.bcebos.com/pics/24.%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B92.png" alt="24.两两交换链表中的节点2"></p><p>看这个可能就更直观一些了：</p><p><img data-src="https://code-thinking.cdn.bcebos.com/pics/24.%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B93.png" alt="24.两两交换链表中的节点3"></p><p>代码如下：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 虚拟头结点</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">ListNode</span> <span class="token function">swapPairs</span><span class="token punctuation">(</span><span class="token class-name">ListNode</span> head<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token comment">// 初始化虚拟头节点</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token class-name">ListNode</span> dummyNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        dummyNode<span class="token punctuation">.</span>next <span class="token operator">=</span> head<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token comment">//cur 指向当前需要交换的两个节点的前一个节点</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token class-name">ListNode</span> cur <span class="token operator">=</span> dummyNode<span class="token punctuation">;</span>  <span class="token comment">// 这里的 = 的拷贝类型是浅拷贝，所以 cur 和 dummyNode 指向的是同一个对象</span></pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token keyword">while</span> <span class="token punctuation">(</span>cur<span class="token punctuation">.</span>next <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 链表中至少有两个节点，确保需要交换</span></pre></td></tr><tr><td data-num="11"></td><td><pre>            <span class="token class-name">ListNode</span> tmp <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span> <span class="token comment">// 暂存第三个节点</span></pre></td></tr><tr><td data-num="12"></td><td><pre>            cur<span class="token punctuation">.</span>next <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span> <span class="token comment">// 步骤 1</span></pre></td></tr><tr><td data-num="13"></td><td><pre>            head<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next <span class="token operator">=</span> head<span class="token punctuation">;</span> <span class="token comment">// 步骤 2</span></pre></td></tr><tr><td data-num="14"></td><td><pre>            head<span class="token punctuation">.</span>next <span class="token operator">=</span> tmp<span class="token punctuation">;</span> <span class="token comment">// 步骤 3</span></pre></td></tr><tr><td data-num="15"></td><td><pre>            cur <span class="token operator">=</span> head<span class="token punctuation">;</span>  <span class="token comment">// 步进 1 个节点，即交换后的第二个节点</span></pre></td></tr><tr><td data-num="16"></td><td><pre>            head <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>  <span class="token comment">// 步进 1 个节点</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>        <span class="token keyword">return</span> dummyNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 递归</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">ListNode</span> <span class="token function">swapPairs</span><span class="token punctuation">(</span><span class="token class-name">ListNode</span> head<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token comment">// 递归终止条件：链表为空或者链表只有一个节点</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> head<span class="token punctuation">.</span>next <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>            <span class="token keyword">return</span> head<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token comment">// 获取要交换的两个节点在交换前的第二个节点</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token class-name">ListNode</span> cur <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token comment">// 进行递归</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token class-name">ListNode</span> newHead <span class="token operator">=</span> <span class="token function">swapPairs</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token comment">// 交换</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        cur<span class="token punctuation">.</span>next <span class="token operator">=</span> head<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        head<span class="token punctuation">.</span>next <span class="token operator">=</span> newHead<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token keyword">return</span> cur<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id="19-删除链表的倒数第-n-个结点"><a class="anchor" href="#19-删除链表的倒数第-n-个结点">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yZW1vdmUtbnRoLW5vZGUtZnJvbS1lbmQtb2YtbGlzdC8=">19. 删除链表的倒数第 n 个结点</span></h3><p><strong>双指针</strong>的经典应用</p><ul><li>一个注意的地方：<strong>操作指针需指向欲删除结点的上一个结点</strong>。</li><li>一个难点：** 如何找到倒数第 n 个结点？** 下面围绕该问题展开。</li></ul><p>分为如下几步：</p><ul><li>首先这里我推荐大家使用<strong>虚拟头结点</strong>，这样方便处理删除实际头结点的逻辑</li><li>定义<strong> fast 指针和 slow 指针，初始值为虚拟头结点</strong>，如图：</li></ul><p><img data-src="https://code-thinking.cdn.bcebos.com/pics/19.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9.png" alt="img"></p><ul><li><strong>fast 首先走 n + 1 步</strong> ，为什么是 n+1 呢，因为只有这样同时移动的时候<u>slow 才能指向删除节点的上一个节点</u>（方便做删除操作），如图： <img data-src="https://code-thinking.cdn.bcebos.com/pics/19.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B91.png" alt="img"></li><li><strong>fast 和 slow 同时移动，直到 fast 指向 null</strong>，如题： <img data-src="https://code-thinking.cdn.bcebos.com/pics/19.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B92.png" alt="img"></li><li><strong>删除 slow 指向的下一个节点</strong>，如图： <img data-src="https://code-thinking.cdn.bcebos.com/pics/19.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B93.png" alt="img"></li></ul><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">ListNode</span> <span class="token function">removeNthFromEnd</span><span class="token punctuation">(</span><span class="token class-name">ListNode</span> head<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token class-name">ListNode</span> dummyHead <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> head<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 虚拟头节点</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token class-name">ListNode</span> slowNode <span class="token operator">=</span> dummyHead<span class="token punctuation">;</span>  <span class="token comment">// 慢指针</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token class-name">ListNode</span> fastNode <span class="token operator">=</span> dummyHead<span class="token punctuation">;</span>  <span class="token comment">// 快指针</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token comment">// 快指针先走 n+1 步</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>            fastNode <span class="token operator">=</span> fastNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token comment">// 快、慢指针同时移动，直至快指针到达链表尾部</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token keyword">while</span> <span class="token punctuation">(</span>fastNode <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>            slowNode <span class="token operator">=</span> slowNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>            fastNode <span class="token operator">=</span> fastNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token comment">// 此时慢指针指向待删除节点的前一个节点，执行删除操作</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        slowNode<span class="token punctuation">.</span>next <span class="token operator">=</span> slowNode<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token keyword">return</span> dummyHead<span class="token punctuation">.</span>next<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id="面试题-0207-链表相交"><a class="anchor" href="#面试题-0207-链表相交">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9pbnRlcnNlY3Rpb24tb2YtdHdvLWxpbmtlZC1saXN0cy1sY2NpLw==">面试题 02.07. 链表相交</span></h3><p>简单来说，就是求两个链表交点节点的指针。 这里同学们要注意，<strong>交点不是数值相等，而是指针相等</strong>（为了方便举例，下图中假设节点元素数值相等，则节点指针相等）。</p><p>看如下两个链表，目前 curA 指向链表 A 的头结点，curB 指向链表 B 的头结点：</p><p><img data-src="https://code-thinking.cdn.bcebos.com/pics/%E9%9D%A2%E8%AF%95%E9%A2%9802.07.%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4_1.png" alt="面试题02.07.链表相交_1"></p><p>我们求出两个链表的长度，并<strong>求出两个链表长度的差值</strong>，然后<strong>让 curA 移动到，和 curB 末尾对齐的位置</strong>，如图：</p><p><img data-src="https://code-thinking.cdn.bcebos.com/pics/%E9%9D%A2%E8%AF%95%E9%A2%9802.07.%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4_2.png" alt="面试题02.07.链表相交_2"></p><p>此时我们就可以<strong>比较 curA 和 curB 是否相同</strong></p><ul><li>如果<strong>不相同，同时向后移动 curA 和 curB</strong></li><li>如果<strong>遇到 curA == curB，则找到交点</strong></li></ul><p>否则循环退出返回空指针。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">ListNode</span> <span class="token function">getIntersectionNode</span><span class="token punctuation">(</span><span class="token class-name">ListNode</span> headA<span class="token punctuation">,</span> <span class="token class-name">ListNode</span> headB<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token class-name">ListNode</span> curA <span class="token operator">=</span> headA<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token class-name">ListNode</span> curB <span class="token operator">=</span> headB<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">int</span> lenA <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> lenB <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token keyword">while</span> <span class="token punctuation">(</span>curA <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 计算链表 A 的长度</span></pre></td></tr><tr><td data-num="8"></td><td><pre>            lenA<span class="token operator">++</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>            curA <span class="token operator">=</span> curA<span class="token punctuation">.</span>next<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token keyword">while</span> <span class="token punctuation">(</span>curB <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 计算链表 B 的长度</span></pre></td></tr><tr><td data-num="12"></td><td><pre>            lenB<span class="token operator">++</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>            curB <span class="token operator">=</span> curB<span class="token punctuation">.</span>next<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre></pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token comment">// 重置 curA 和 curB</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        curA <span class="token operator">=</span> headA<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>        curB <span class="token operator">=</span> headB<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre></pre></td></tr><tr><td data-num="20"></td><td><pre>        <span class="token comment">// 令 curA 指向较长的链表，curB 指向较短的链表</span></pre></td></tr><tr><td data-num="21"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>lenA <span class="token operator">&lt;</span> lenB<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>            <span class="token comment">// 交换 lenA 和 lenB</span></pre></td></tr><tr><td data-num="23"></td><td><pre>            <span class="token keyword">int</span> tmpLen <span class="token operator">=</span> lenA<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>            lenA <span class="token operator">=</span> lenB<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>            lenB <span class="token operator">=</span> tmpLen<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>            <span class="token comment">// 交换 curA 和 curB</span></pre></td></tr><tr><td data-num="27"></td><td><pre>            <span class="token class-name">ListNode</span> tmpNode <span class="token operator">=</span> curA<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>            curA <span class="token operator">=</span> curB<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>            curB <span class="token operator">=</span> tmpNode<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="31"></td><td><pre></pre></td></tr><tr><td data-num="32"></td><td><pre>        <span class="token comment">// 计算长度差</span></pre></td></tr><tr><td data-num="33"></td><td><pre>        <span class="token keyword">int</span> gap <span class="token operator">=</span> lenA <span class="token operator">-</span> lenB<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="34"></td><td><pre>        <span class="token comment">//curA 先走 gap 步，保证 curA 和 curB 的末尾对齐</span></pre></td></tr><tr><td data-num="35"></td><td><pre>        <span class="token keyword">while</span> <span class="token punctuation">(</span>gap <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="36"></td><td><pre>            curA <span class="token operator">=</span> curA<span class="token punctuation">.</span>next<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="37"></td><td><pre>            gap<span class="token operator">--</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="38"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="39"></td><td><pre></pre></td></tr><tr><td data-num="40"></td><td><pre>        <span class="token comment">// 同时遍历 curA 和 curB，寻找相交的节点</span></pre></td></tr><tr><td data-num="41"></td><td><pre>        <span class="token keyword">while</span> <span class="token punctuation">(</span>curA <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> curB <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="42"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>curA <span class="token operator">==</span> curB<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="43"></td><td><pre>                <span class="token keyword">return</span> curA<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="44"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="45"></td><td><pre>            curA <span class="token operator">=</span> curA<span class="token punctuation">.</span>next<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="46"></td><td><pre>            curB <span class="token operator">=</span> curB<span class="token punctuation">.</span>next<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="47"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="48"></td><td><pre></pre></td></tr><tr><td data-num="49"></td><td><pre>        <span class="token comment">// 未找到相交节点，返回 null</span></pre></td></tr><tr><td data-num="50"></td><td><pre>        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="51"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="52"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id="142-环形链表-ii"><a class="anchor" href="#142-环形链表-ii">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9saW5rZWQtbGlzdC1jeWNsZS1paS8=">142. 环形链表 II</span></h3><blockquote><p>找到有没有环已经很不容易了，还要让我找到环的入口？</p></blockquote><p>主要考察两知识点：</p><ul><li>判断链表是否环</li><li>如果有环，如何找到这个环的入口</li></ul><h4 id="判断链表是否有环"><a class="anchor" href="#判断链表是否有环">#</a> 判断链表是否有环</h4><p>可以使用<strong>快慢指针法</strong>，分别定义 fast 和 slow 指针，从头结点出发，fast 指针每次移动两个节点，slow 指针每次移动一个节点，如果 fast 和 slow 指针在途中相遇 ，说明这个链表有环。</p><p>为什么 fast 走两个节点，slow 走一个节点，有环的话，一定会在环内相遇呢，而不是永远的错开呢</p><p>首先第一点：<strong>fast 指针一定先进入环中，如果 fast 指针和 slow 指针相遇的话，一定是在环中相遇，这是毋庸置疑的。</strong></p><p>那么来看一下，<strong>为什么 fast 指针和 slow 指针一定会相遇呢？</strong></p><p>可以画一个环，然后让 fast 指针在任意一个节点开始追赶 slow 指针。</p><p>会发现最终都是这种情况， 如下图：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/20210318162236720.png" alt="142环形链表1"></p><p>fast 和 slow 各自再走一步， fast 和 slow 就相遇了</p><p>这是因为 fast 是走两步，slow 是走一步，<strong>其实相对于 slow 来说，fast 是一个节点一个节点的靠近 slow 的</strong>，所以 fast 一定可以和 slow 重合。</p><p>动画如下：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/141.%25E7%258E%25AF%25E5%25BD%25A2%25E9%2593%25BE%25E8%25A1%25A8.gif" alt="141.环形链表"></p><h4 id="如果有环如何找到这个环的入口"><a class="anchor" href="#如果有环如何找到这个环的入口">#</a> 如果有环，如何找到这个环的入口</h4><p><strong>此时已经可以判断链表是否有环了，那么接下来要找这个环的入口了。</strong></p><p>假设从头结点到环形入口节点 的节点数为 x。 环形入口节点到 fast 指针与 slow 指针相遇节点 节点数为 y。 从相遇节点 再到环形入口节点节点数为 z。 如图所示：</p><p><img data-src="https://code-thinking-1253855093.file.myqcloud.com/pics/20220925103433.png" alt="img"></p><p>那么相遇时： slow 指针走过的节点数为: <code>x + y</code> ， fast 指针走过的节点数： <code>x + y + n (y + z)</code> ，n 为 fast 指针在环内走了 n 圈才遇到 slow 指针， （y+z）为 一圈内节点的个数 A。</p><p>因为 fast 指针是一步走两个节点，slow 指针一步走一个节点， 所以 fast 指针走过的节点数 = slow 指针走过的节点数 * 2：</p><pre><code>(x + y) * 2 = x + y + n (y + z)
</code></pre><p>两边消掉一个（x+y）: <code>x + y = n (y + z)</code></p><p>因为要找环形的入口，那么要求的是 x，因为 x 表示 头结点到 环形入口节点的的距离。</p><p>所以要求 x ，将 x 单独放在左面： <code>x = n (y + z) - y</code> ,</p><p>再从 n (y+z) 中提出一个 （y+z）来，整理公式之后为如下公式：<strong> <code>x = (n - 1) (y + z) + z</code> </strong>注意这里 n 一定是大于等于 1 的，因为 fast 指针至少要多走一圈才能相遇 slow 指针。</p><p>这个公式说明什么呢？</p><p>先拿 n 为 1 的情况来举例，意味着 fast 指针在环形里转了一圈之后，就遇到了 slow 指针了。</p><p>当 n 为 1 的时候，公式就化解为 <code>x = z</code> ，</p><p>这就意味着，<strong>从头结点出发一个指针，从相遇节点 也出发一个指针，这两个指针每次只走一个节点， 那么当这两个指针相遇的时候就是 环形入口的节点</strong>。</p><p>也就是在相遇节点处，定义一个指针 index1，在头结点处定一个指针 index2。</p><p>让 index1 和 index2 同时移动，每次移动一个节点， 那么他们相遇的地方就是 环形入口的节点。</p><p>动画如下：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/142.%25E7%258E%25AF%25E5%25BD%25A2%25E9%2593%25BE%25E8%25A1%25A8II%25EF%25BC%2588%25E6%25B1%2582%25E5%2585%25A5%25E5%258F%25A3%25EF%25BC%2589.gif" alt="142.环形链表II（求入口）"></p><p>那么 n 如果大于 1 是什么情况呢，就是 fast 指针在环形转 n 圈之后才遇到 slow 指针。</p><p>其实这种情况和 n 为 1 的时候 效果是一样的，一样可以通过这个方法找到 环形的入口节点，只不过，index1 指针在环里 多转了 (n-1) 圈，然后再遇到 index2，相遇点依然是环形的入口节点。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">ListNode</span> <span class="token function">detectCycle</span><span class="token punctuation">(</span><span class="token class-name">ListNode</span> head<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token class-name">ListNode</span> fast <span class="token operator">=</span> head<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token class-name">ListNode</span> slow <span class="token operator">=</span> head<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token keyword">while</span> <span class="token punctuation">(</span>fast <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> fast<span class="token punctuation">.</span>next <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 确保 fast 可以大胆走两步</span></pre></td></tr><tr><td data-num="7"></td><td><pre>            fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>            slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>fast <span class="token operator">==</span> slow<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 此时 fast 追上 slow 相遇，说明有环</span></pre></td></tr><tr><td data-num="11"></td><td><pre>                <span class="token class-name">ListNode</span> index1 <span class="token operator">=</span> head<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>                <span class="token class-name">ListNode</span> index2 <span class="token operator">=</span> slow<span class="token punctuation">;</span>  <span class="token comment">// 相遇点，也可以是 fast，因为 fast==slow</span></pre></td></tr><tr><td data-num="13"></td><td><pre></pre></td></tr><tr><td data-num="14"></td><td><pre>                <span class="token keyword">while</span> <span class="token punctuation">(</span>index1 <span class="token operator">!=</span> index2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 两个指针同时走，相遇的地方就是环的入口</span></pre></td></tr><tr><td data-num="15"></td><td><pre>                    index1 <span class="token operator">=</span> index1<span class="token punctuation">.</span>next<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>                    index2 <span class="token operator">=</span> index2<span class="token punctuation">.</span>next<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>                <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>                <span class="token keyword">return</span> index1<span class="token punctuation">;</span>  <span class="token comment">// 返回环的入口，也可以返回 index2</span></pre></td></tr><tr><td data-num="19"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>  <span class="token comment">// 链表为空，或者链表无环</span></pre></td></tr><tr><td data-num="22"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="23"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h4 id="补充"><a class="anchor" href="#补充">#</a> 补充</h4><p>在推理过程中，大家可能有一个疑问就是：<strong>为什么第一次在环中相遇，slow 的 步数 是 x+y 而不是 x + 若干环的长度 + y 呢？</strong></p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/20210318165123581.png" alt="142环形链表5"></p><p>首先 slow 进环的时候，fast 一定是先进环来了。</p><p>如果 slow 进环入口，fast 也在环入口，那么把这个环展开成直线，就是如下图的样子：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/2021031816503266.png" alt="142环形链表3"></p><p>可以看出如果 slow 和 fast 同时在环入口开始走，一定会在环入口 3 相遇，slow 走了一圈，fast 走了两圈。</p><p>重点来了，slow 进环的时候，fast 一定是在环的任意一个位置，如图：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/2021031816515727.png" alt="142环形链表4"></p><p>那么 fast 指针走到环入口 3 的时候，已经走了 k + n 个节点，slow 相应的应该走了 (k + n) / 2 个节点。</p><p>因为 k 是小于 n 的（图中可以看出），所以 (k + n) / 2 一定小于 n。</p><p><strong>也就是说 slow 一定没有走到环入口 3，而 fast 已经到环入口 3 了</strong>。</p><p>这说明什么呢？</p><p><strong>在 slow 开始走的那一环已经和 fast 相遇了</strong>。</p><p>那有同学又说了，为什么 fast 不能跳过去呢？ 在刚刚已经说过一次了，<strong>fast 相对于 slow 是一次移动一个节点，所以不可能跳过去</strong>。</p><p>好了，这次把为什么第一次在环中相遇，slow 的 步数 是 x+y 而不是 x + 若干环的长度 + y ，用数学推理了一下，算是对<span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVyY2FybC5jb20vMDE0Mi4lRTclOEUlQUYlRTUlQkQlQTIlRTklOTMlQkUlRTglQTElQThJSS5odG1s">链表：环找到了，那入口呢？</span>的补充。</p><h3 id="链表总结篇"><a class="anchor" href="#链表总结篇">#</a> 链表总结篇</h3><h4 id="链表的理论基础"><a class="anchor" href="#链表的理论基础">#</a> 链表的理论基础</h4><p>在这篇文章<a href="#%E9%93%BE%E8%A1%A8%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80">链表理论基础</a>中，介绍了如下几点：</p><ul><li>链表的种类主要为：单链表，双链表，循环链表</li><li>链表的存储方式：链表的节点在内存中是<strong>分散存储</strong>的，通过指针连在一起。</li><li>链表是如何进行增删改查的。</li><li>数组和链表在不同场景下的性能分析。</li></ul><p><strong>可以说把链表基础的知识都概括了，但又不像教科书那样的繁琐</strong>。</p><h4 id="链表经典题目"><a class="anchor" href="#链表经典题目">#</a> 链表经典题目</h4><h5 id="虚拟头节点"><a class="anchor" href="#虚拟头节点">#</a> 虚拟头节点</h5><p>在 [203. 移除链表元素](#203. 移除链表元素) 中，我们讲解了链表操作中一个非常总要的技巧：虚拟头节点。</p><p>链表的一大问题就是<strong>操作当前节点必须要找前一个节点才能操作</strong>。这就造成了，头结点的尴尬，因为头结点没有前一个节点了。</p><p><strong>每次对应头结点的情况都要单独处理，所以使用虚拟头结点的技巧，就可以解决这个问题</strong>。</p><p>在 [203. 移除链表元素](#203. 移除链表元素) 中，我给出了用虚拟头结点和没用虚拟头结点的代码，大家对比一下就会发现，使用虚拟头结点的好处。</p><h5 id="链表的基本操作"><a class="anchor" href="#链表的基本操作">#</a> 链表的基本操作</h5><p>在 [707. 设计链表](#707. 设计链表) 中，我们通设计链表把链表常见的五个操作练习了一遍。</p><p>这是练习链表基础操作的非常好的一道题目，考察了：</p><ul><li>获取链表第 index 个节点的数值</li><li>在链表的最前面插入一个节点</li><li>在链表的最后面插入一个节点</li><li>在链表第 index 个节点前面插入一个节点</li><li>删除链表的第 index 个节点的数值</li></ul><p><strong>可以说把这道题目做了，链表基本操作就 OK 了，再也不用担心链表增删改查整不明白了</strong>。</p><p>这里我依然使用了虚拟头结点的技巧，大家复习的时候，可以去看一下代码。</p><h5 id="反转链表"><a class="anchor" href="#反转链表">#</a> 反转链表</h5><p>在 [206. 反转链表](#206. 反转链表) 中，讲解了如何反转链表。</p><p>因为反转链表的代码相对简单，有的同学可能直接背下来了，但一写还是容易出问题。</p><p>反转链表是面试中高频题目，很考察面试者对链表操作的熟练程度。</p><p>我在 [206. 反转链表](#206. 反转链表) 中，给出了两种反转的方式，迭代法和递归法。</p><p>建议大家先学透迭代法，然后再看递归法，因为递归法比较绕，如果迭代还写不明白，递归基本也写不明白了。</p><p><strong>可以先通过迭代法，彻底弄清楚链表反转的过程！</strong></p><h5 id="删除倒数第n个节点"><a class="anchor" href="#删除倒数第n个节点">#</a> 删除倒数第 N 个节点</h5><p>在 [19. 删除链表的倒数第 n 个结点](#19. 删除链表的倒数第 n 个结点) 中我们结合<strong>虚拟头结点</strong> 和 <strong>双指针法</strong>来移除链表倒数第 N 个节点。</p><h5 id="链表相交"><a class="anchor" href="#链表相交">#</a> 链表相交</h5><p>[面试题 02.07. 链表相交](# 面试题 02.07. 链表相交) 使用<strong>双指针</strong>来找到两个链表的交点（引用完全相同，即：内存地址完全相同的交点）</p><h4 id="环形链表"><a class="anchor" href="#环形链表">#</a> 环形链表</h4><p>在 [142. 环形链表 II](#142. 环形链表 II) 中，讲解了在链表如何找环，以及如何找环的入口位置。</p><p>这道题目可以说是链表的比较难的题目了。 但代码却十分简洁，主要在于一些数学证明。</p><p><img data-src="https://code-thinking-1253855093.file.myqcloud.com/pics/%E9%93%BE%E8%A1%A8%E6%80%BB%E7%BB%93.png" alt="img"></p><h2 id="哈希表"><a class="anchor" href="#哈希表">#</a> 哈希表</h2><h3 id="理论基础-2"><a class="anchor" href="#理论基础-2">#</a> 理论基础</h3><h4 id="哈希表-2"><a class="anchor" href="#哈希表-2">#</a> 哈希表</h4><blockquote><p>hash table，又称散列表</p></blockquote><p>是<strong>根据关键码的值而直接进行访问</strong>的数据结构。</p><p>直白来讲其实<strong>数组就是一张哈希表</strong>。</p><p>哈希表中<strong>关键码就是数组的索引下标</strong>，然后通过下标直接访问数组中的元素，如下图所示：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/20210104234805168.png" alt="哈希表1"></p><p>那么哈希表能解决什么问题呢，<strong>一般哈希表都是用来快速判断一个元素是否出现集合里。</strong></p><p>例如要<strong>查询</strong>一个名字是否在这所学校里。</p><p>要枚举的话时间复杂度是 O (n)，但如果 ** 使用哈希表的话， 只需要 O (1)** 就可以做到。</p><p>我们只需要初始化把这所学校里学生的名字都存在哈希表里，在查询的时候通过索引直接就可以知道这位同学在不在这所学校里了。</p><p>将学生姓名映射到哈希表上就涉及到了<strong>哈希函数</strong>。</p><h4 id="哈希函数"><a class="anchor" href="#哈希函数">#</a> 哈希函数</h4><p>哈希函数，把学生的姓名<strong>直接映射为哈希表上的索引</strong>，然后就可以通过查询索引下标快速知道这位同学是否在这所学校里了。</p><p>哈希函数如下图所示，通过 hashCode 把名字转化为数值，一般<strong> hashcode 是通过特定编码方式，可以将其他数据格式转化为不同的数值</strong>，这样就把学生名字映射为哈希表上的索引数字了。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/2021010423484818.png" alt="哈希表2"></p><p><strong>如果 hashCode 得到的数值大于 哈希表的大小</strong>了，也就是大于 tableSize 了，怎么办呢？</p><p>此时为了保证映射出来的索引数值都落在哈希表上，我们会在再次对数值做一个<strong>取模</strong>的操作，就要我们就保证了学生姓名一定可以映射到哈希表上了。</p><h4 id="哈希碰撞"><a class="anchor" href="#哈希碰撞">#</a> 哈希碰撞</h4><p><strong>同时映射到哈希表同一索引下标的位置</strong>的现象，称为哈希碰撞。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/2021010423494884.png" alt="哈希表3"></p><h5 id="拉链法"><a class="anchor" href="#拉链法">#</a> 拉链法</h5><p>刚刚小李和小王在索引 1 的位置发生了冲突，<strong>发生冲突的元素都被存储在<u>链表</u>中</strong>。 这样我们就可以通过索引找到小李和小王了</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/20210104235015226.png" alt="哈希表4"></p><p>（数据规模是 dataSize， 哈希表的大小为 tableSize）</p><p>其实拉链法就是要选择适当的哈希表的大小，这样既不会因为数组空值而浪费大量内存，也不会因为链表太长而在查找上浪费太多时间。</p><h5 id="线性探测法"><a class="anchor" href="#线性探测法">#</a> 线性探测法</h5><p>使用线性探测法，一定<strong>要保证 tableSize 大于 dataSize</strong>。 我们需要<strong>依靠哈希表中的<u>空位</u>来解决碰撞问题</strong>。</p><p>例如冲突的位置，放了小李，那么就向下找一个空位放置小王的信息。所以要求 tableSize 一定要大于 dataSize ，要不然哈希表上就没有空置的位置来存放冲突的数据了。如图所示：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/20210104235109950.png" alt="哈希表5"></p><p>其实关于哈希碰撞还有非常多的细节，感兴趣的同学可以再好好研究一下，这里我就不再赘述了。</p><h4 id="常见的三种哈希结构"><a class="anchor" href="#常见的三种哈希结构">#</a> 常见的三种哈希结构</h4><h5 id="数组-2"><a class="anchor" href="#数组-2">#</a> 数组</h5><blockquote><p>没啥可说的</p></blockquote><h5 id="set集合"><a class="anchor" href="#set集合">#</a> set（集合）</h5><p>在 C++ 中，set 和 map 分别提供以下三种数据结构，其底层实现以及优劣如下表所示：</p><table><thead><tr><th>集合</th><th>底层实现</th><th>是否有序</th><th>数值是否可以重复</th><th>能否更改数值</th><th>查询效率</th><th>增删效率</th></tr></thead><tbody><tr><td>std::set</td><td>红黑树</td><td>有序</td><td>否</td><td>否</td><td>O(log n)</td><td>O(log n)</td></tr><tr><td>std::multiset</td><td>红黑树</td><td>有序</td><td>是</td><td>否</td><td>O(logn)</td><td>O(logn)</td></tr><tr><td>std::unordered_set</td><td>哈希表</td><td>无序</td><td>否</td><td>否</td><td>O(1)</td><td>O(1)</td></tr></tbody></table><p>std::unordered_set 底层实现为哈希表，std::set 和 std::multiset 的底层实现是红黑树，<strong>红黑树是一种平衡二叉搜索树，所以 key 值是有序的</strong>，但 key 不可以修改，改动 key 值会导致整棵树的错乱，所以只能删除和增加。</p><h5 id="map映射"><a class="anchor" href="#map映射">#</a> map（映射）</h5><table><thead><tr><th>映射</th><th>底层实现</th><th>是否有序</th><th>数值是否可以重复</th><th>能否更改数值</th><th>查询效率</th><th>增删效率</th></tr></thead><tbody><tr><td>std::map</td><td>红黑树</td><td>key 有序</td><td>key 不可重复</td><td>key 不可修改</td><td>O(logn)</td><td>O(logn)</td></tr><tr><td>std::multimap</td><td>红黑树</td><td>key 有序</td><td>key 可重复</td><td>key 不可修改</td><td>O(log n)</td><td>O(log n)</td></tr><tr><td>std::unordered_map</td><td>哈希表</td><td>key 无序</td><td>key 不可重复</td><td>key 不可修改</td><td>O(1)</td><td>O(1)</td></tr></tbody></table><p>std::unordered_map 底层实现为哈希表，std::map 和 std::multimap 的底层实现是红黑树。同理，std::map 和 std::multimap 的 key 也是有序的（这个问题也经常作为面试题，考察对语言容器底层的理解）。</p><p>当我们要使用<u>集合</u>来解决哈希问题的时候，优先使用<strong> unordered_set</strong>，因为它的查询和增删效率是最优的，如果需要集合是有序的，那么就用<strong> set</strong>，如果要求不仅有序还要有重复数据的话，那么就用<strong> multiset</strong>。</p><p>那么再来看一下<u>map</u> ，在 map 是一个 key value 的数据结构，map 中，对 key 是有限制，对 value 没有限制的，因为 key 的存储方式使用红黑树实现的。</p><p>其他语言例如：java 里的<strong> HashMap ，TreeMap</strong> 都是一样的原理。可以灵活贯通。</p><p>虽然 std::set、std::multiset 的底层实现是红黑树，不是哈希表，std::set、std::multiset 使用红黑树来索引和存储，不过给我们的使用方式，还是哈希法的使用方式，即 key 和 value。所以<strong>使用这些数据结构来解决映射问题的方法，我们依然称之为哈希法</strong>。 map 也是一样的道理。</p><p>这里在说一下，一些 C++ 的经典书籍上 例如 STL 源码剖析，说到了 hash_set hash_map，这个与 unordered_set，unordered_map 又有什么关系呢？</p><p>实际上功能都是一样一样的， 但是 unordered_set 在 C<ins>11 的时候被引入标准库了，而 hash_set 并没有，所以建议还是使用 unordered_set 比较好，这就好比一个是官方认证的，hash_set，hash_map 是 C</ins>11 标准之前民间高手自发造的轮子。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/20210104235134572.png" alt="哈希表6"></p><h4 id="总结-2"><a class="anchor" href="#总结-2">#</a> 总结</h4><p>总结一下，<strong>当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法</strong>。</p><p>但是哈希法也是<strong>牺牲了空间换取了时间</strong>，因为我们要使用额外的数组，set 或者是 map 来存放数据，才能实现快速的查找。</p><p>如果在做面试题目的时候遇到需要判断一个元素是否出现过的场景也应该第一时间想到哈希法！</p><h3 id="242-有效的字母异位词"><a class="anchor" href="#242-有效的字母异位词">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy92YWxpZC1hbmFncmFtLw==">242. 有效的字母异位词</span></h3><blockquote><p>数组就是简单的哈希表，但是数组的大小可不是无限开辟的</p></blockquote><p>先看暴力的解法，两层 for 循环，同时还要记录字符是否重复出现，很明显时间复杂度是 O (n^2)。</p><p>暴力的方法这里就不做介绍了，直接看一下有没有更优的方式。</p><p><strong>数组其实就是一个简单哈希表</strong>，而且这道题目中字符串只有小写字符，那么就<strong>可以定义一个数组，来记录字符串 s 里字符出现的次数</strong>。</p><p>需要定义一个多大的数组呢，<strong>定一个数组叫做 record，大小为 26</strong> 就可以了，初始化为 0，因为字符 a 到字符 z 的 ASCII 也是 26 个连续的数值。</p><p>为了方便举例，判断一下字符串 s= &quot;aee&quot;, t = &quot;eae&quot;。</p><p>操作动画如下：</p><p><img data-src="https://code-thinking.cdn.bcebos.com/gifs/242.%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D.gif" alt="242.有效的字母异位词"></p><p>定义一个数组叫做 record 用来记录字符串 s 里字符出现的次数。</p><p>需要把字符映射到数组也就是哈希表的索引下标上，<strong>因为字符 a 到字符 z 的 ASCII 是 26 个连续的数值，所以字符 a 映射为下标 0，相应的字符 z 映射为下标 25。</strong></p><p>再遍历 字符串 s 的时候，<strong>只需要将 s [i] - ‘a’ 所在的元素做 + 1 操作即可，并不需要记住字符 a 的 ASCII，只要求出一个相对数值就可以了。</strong> 这样就将字符串 s 中字符出现的次数，统计出来了。</p><p>那看一下如何检查字符串 t 中是否出现了这些字符，同样在遍历字符串 t 的时候，对 t 中出现的字符映射哈希表索引上的数值再做 - 1 的操作。</p><p>那么最后检查一下，<strong>record 数组如果有的元素不为零 0，说明字符串 s 和 t 一定是谁多了字符或者谁少了字符，return false。</strong></p><p>最后如果 record 数组所有元素都为零 0，说明字符串 s 和 t 是字母异位词，return true。</p><p>时间复杂度为 O (n)，<strong>空间上因为定义是的一个常量大小的辅助数组，所以空间复杂度为 O (1)</strong>。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 时间复杂度：O (n)，空间复杂度：O (1)</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isAnagram</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">,</span> <span class="token class-name">String</span> t<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> record <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">26</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>            record<span class="token punctuation">[</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token char">'a'</span><span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>  <span class="token comment">// 记录 s 中每个字符出现的次数</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> t<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>            record<span class="token punctuation">[</span>t<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token char">'a'</span><span class="token punctuation">]</span><span class="token operator">--</span><span class="token punctuation">;</span>  <span class="token comment">// 记录 t 中每个字符出现的次数</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> count <span class="token operator">:</span> record<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 如果 s 和 t 中每个字符出现的次数都相同，则 count 数组中每个元素都为 0</span></pre></td></tr><tr><td data-num="15"></td><td><pre>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h4 id="383-赎金信"><a class="anchor" href="#383-赎金信">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yYW5zb20tbm90ZS8=">383. 赎金信</span></h4><blockquote><p>在哈希法中有一些场景就是为<strong>数组</strong>量身定做的。</p></blockquote><h5 id="暴力解法-4"><a class="anchor" href="#暴力解法-4">#</a> 暴力解法</h5><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 暴力解法，时间复杂度 O (n^2)，空间复杂度 O (1)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">canConstruct</span><span class="token punctuation">(</span><span class="token class-name">String</span> ransomNote<span class="token punctuation">,</span> <span class="token class-name">String</span> magazine<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> magazine<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> ransomNote<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>                <span class="token keyword">if</span> <span class="token punctuation">(</span>ransomNote<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span> <span class="token operator">==</span> magazine<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>                    ransomNote <span class="token operator">=</span> ransomNote<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> j<span class="token punctuation">)</span> <span class="token operator">+</span> ransomNote<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 从字符串中删除该字符，substring (0,j) 表示从 0 到 j-1 的字符串，substring (j+1) 表示从 j+1 到最后的字符串，要头不要尾</span></pre></td></tr><tr><td data-num="8"></td><td><pre>                    <span class="token keyword">break</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>                <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token keyword">return</span> ransomNote<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h5 id="哈希解法"><a class="anchor" href="#哈希解法">#</a> 哈希解法</h5><p>因为题目所只有小写字母，那可以采用空间换取时间的哈希策略， <strong>用一个长度为 26 的数组还记录 magazine 里字母出现的次数</strong>。</p><p>然后<strong>再用 ransomNote 去验证这个数组是否包含了 ransomNote 所需要的所有字母</strong>。</p><p>依然是数组在哈希法中的应用。</p><p>一些同学可能想，用数组干啥，都用 map 完事了，<strong>其实在本题的情况下，使用 map 的空间消耗要比数组大一些的，因为 map 要维护红黑树或者哈希表，而且还要做哈希函数，是费时的！数据量大的话就能体现出来差别了。 所以数组更加简单直接有效！</strong></p><p>代码如下：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 哈希解法，时间复杂度 O (n)，空间复杂度 O (1)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">canConstruct</span><span class="token punctuation">(</span><span class="token class-name">String</span> ransomNote<span class="token punctuation">,</span> <span class="token class-name">String</span> magazine<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> record <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">26</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">char</span> c <span class="token operator">:</span> magazine<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>            record<span class="token punctuation">[</span>c <span class="token operator">-</span> <span class="token char">'a'</span><span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">// 记录 magazine 中每个字符出现的次数</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">char</span> c <span class="token operator">:</span> ransomNote<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>            record<span class="token punctuation">[</span>c <span class="token operator">-</span> <span class="token char">'a'</span><span class="token punctuation">]</span><span class="token operator">--</span><span class="token punctuation">;</span> <span class="token comment">//ransomNote 中每个字符出现的次数减一</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">:</span> record<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 如果出现次数小于 0，说明 magazine 中没有 ransomNote 中的某个字符</span></pre></td></tr><tr><td data-num="16"></td><td><pre>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="21"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 哈希解法，时间复杂度 O (n)，空间复杂度 O (1)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">canConstruct</span><span class="token punctuation">(</span><span class="token class-name">String</span> ransomNote<span class="token punctuation">,</span> <span class="token class-name">String</span> magazine<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> record <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">26</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">char</span> c <span class="token operator">:</span> magazine<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>            record<span class="token punctuation">[</span>c <span class="token operator">-</span> <span class="token char">'a'</span><span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">// 记录 magazine 中每个字符出现的次数</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">char</span> c <span class="token operator">:</span> ransomNote<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>record<span class="token punctuation">[</span>c <span class="token operator">-</span> <span class="token char">'a'</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>            record<span class="token punctuation">[</span>c <span class="token operator">-</span> <span class="token char">'a'</span><span class="token punctuation">]</span><span class="token operator">--</span><span class="token punctuation">;</span> <span class="token comment">// 减去 ransomNote 中每个字符出现的次数</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="16"></td><td><pre></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id="349-两个数组的交集"><a class="anchor" href="#349-两个数组的交集">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9pbnRlcnNlY3Rpb24tb2YtdHdvLWFycmF5cy8=">349. 两个数组的交集</span></h3><blockquote><p>如果哈希值比较少、特别分散、跨度非常大，使用数组就造成空间的极大浪费！</p></blockquote><p>这道题目，主要要学会使用一种哈希数据结构：<strong>unordered_set</strong>，这个数据结构可以解决很多类似的问题。</p><p>注意题目特意说明：<strong>输出结果中的每个元素一定是唯一的，也就是说输出的结果的去重的， 同时可以不考虑输出结果的顺序</strong></p><p>这道题用暴力的解法时间复杂度是 O (n^2)，那来看看使用哈希法进一步优化。</p><p>那么用数组来做哈希表也是不错的选择，例如<span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVyY2FybC5jb20vMDI0Mi4lRTYlOUMlODklRTYlOTUlODglRTclOUElODQlRTUlQUQlOTclRTYlQUYlOEQlRTUlQkMlODIlRTQlQkQlOEQlRTglQUYlOEQuaHRtbA=="> 242. 有效的字母异位词</span></p><p>但是要注意，<strong>使用数组来做哈希的题目，是因为题目都限制了数值的大小。</strong></p><p>而这道题目没有限制数值的大小，就无法使用数组来做哈希表了。</p><p><strong>而且如果哈希值比较少、特别分散、跨度非常大，使用数组就造成空间的极大浪费。</strong></p><p>此时就要使用另一种结构体了，set ，关于 set，C++ 给提供了如下三种可用的数据结构：</p><ul><li>std::set</li><li>std::multiset</li><li>std::unordered_set</li></ul><p>std::set 和 std::multiset 底层实现都是红黑树，std::unordered_set 的底层实现是哈希表， 使用 unordered_set 读写效率是最高的，并不需要对数据进行排序，而且还不要让数据重复，所以选择 unordered_set。</p><p>思路如图所示：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/20220707173513.png" alt="set哈希法"></p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">//set，时间复杂度 O (n+m)，空间复杂度 O (n+m)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">intersection</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums1<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums1 <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> nums1<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> nums2 <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> nums2<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 两个数组有一个为空，直接返回空数组</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> set <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> num <span class="token operator">:</span> nums1<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>            set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将 nums1 中的元素添加到 set 中</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> num <span class="token operator">:</span> nums2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>set<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 如果 nums2 中的元素在 set 中存在，说明是交集，添加到 res 中</span></pre></td></tr><tr><td data-num="15"></td><td><pre>                res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="18"></td><td><pre></pre></td></tr><tr><td data-num="19"></td><td><pre>        <span class="token comment">// 将 res 转换为数组</span></pre></td></tr><tr><td data-num="20"></td><td><pre>        <span class="token keyword">return</span> res<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">mapToInt</span><span class="token punctuation">(</span><span class="token class-name">Integer</span><span class="token operator">::</span><span class="token function">valueOf</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//stream () 将集合转换为流，mapToInt () 将流中的元素转换为 int 类型，toArray () 将流转换为数组</span></pre></td></tr><tr><td data-num="21"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="22"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h4 id="拓展"><a class="anchor" href="#拓展">#</a> 拓展</h4><p>那有同学可能问了，遇到哈希问题我直接都用 set 不就得了，用什么数组啊。</p><p><strong>直接使用 set 不仅占用空间比数组大，而且速度要比数组慢，set 把数值映射到 key 上都要做 hash 计算的</strong>。</p><p>不要小瞧 这个耗时，在数据量大的情况，差距是很明显的。</p><h4 id="后记"><a class="anchor" href="#后记">#</a> 后记</h4><p>本题后面 力扣改了 题目描述 和 后台测试数据，增添了 数值范围：</p><ul><li>1 &lt;= nums1.length, nums2.length &lt;= 1000</li><li>0 &lt;= nums1[i], nums2[i] &lt;= 1000</li></ul><p>所以就可以 使用数组来做哈希表了， 因为数组都是 1000 以内的。</p><h3 id="202-快乐数"><a class="anchor" href="#202-快乐数">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9oYXBweS1udW1iZXIvZGVzY3JpcHRpb24v">202. 快乐数</span></h3><blockquote><p>该用 set 的时候，还是得用 set</p></blockquote><p>这道题目看上去貌似一道数学问题，其实并不是！</p><p>题目中说了会 <strong>无限循环</strong>，那么也就是说<strong>求和的过程中，sum 会重复出现，这对解题很重要！</strong></p><p><strong>当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法了。</strong></p><p>所以这道题目使用哈希法，来<strong>判断这个 sum 是否重复出现，如果重复了就是 return false， 否则一直找到 sum 为 1 为止</strong>。</p><p>判断 sum 是否重复出现就可以使用 unordered_set。</p><p><strong>还有一个难点就是求和的过程，如果对取数值各个位上的单数操作不熟悉的话，做这道题也会比较艰难。</strong></p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isHappy</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> record <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token keyword">while</span> <span class="token punctuation">(</span>n <span class="token operator">!=</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>record<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 当 n 不为 1 且 n 不在 record 中时，循环</span></pre></td></tr><tr><td data-num="5"></td><td><pre>            record<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>            n <span class="token operator">=</span> <span class="token function">getNext</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token punctuation">&#125;</span> <span class="token comment">// 当 n 为 1（可确定输入的 n 是快乐数），或 n 在 record 中（求和结果重复循环出现）时，跳出循环</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token keyword">return</span> n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">getNext</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token keyword">int</span> totalSum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token keyword">while</span> <span class="token punctuation">(</span>n <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>            <span class="token keyword">int</span> d <span class="token operator">=</span> n <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token comment">// 取 n 的个位数</span></pre></td></tr><tr><td data-num="15"></td><td><pre>            n <span class="token operator">=</span> n <span class="token operator">/</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token comment">// 去掉 n 的个位数</span></pre></td></tr><tr><td data-num="16"></td><td><pre>            totalSum <span class="token operator">+=</span> d <span class="token operator">*</span> d<span class="token punctuation">;</span> <span class="token comment">// 平方和</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>        <span class="token keyword">return</span> totalSum<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id="1-两数之和"><a class="anchor" href="#1-两数之和">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy90d28tc3VtLw==">1. 两数之和</span></h3><p>很明显暴力的解法是两层 for 循环查找，时间复杂度是 O (n^2)。</p><p>首先我在强调一下 <strong>什么时候使用哈希法</strong>，当我们需要查询一个元素是否出现过，或者一个元素是否在集合里的时候，就要第一时间想到哈希法。</p><p>本题呢，我就需要一个集合来存放我们遍历过的元素，然后在遍历数组的时候去询问这个集合，某元素是否遍历过，也就是 是否出现在这个集合。</p><p>那么我们就应该想到使用哈希法了。</p><p>再来看一下<strong>使用数组和 set 来做哈希法的局限</strong>。</p><ul><li>数组：大小是受限制的，而且如果元素很少，而哈希值太大会造成内存空间的浪费。</li><li>set：是一个集合，里面放的元素只能是一个 key，而两数之和这道题目，不仅要判断 y 是否存在而且还要记录 y 的下标位置，因为要返回 x 和 y 的下标。所以 set 也不能用。</li></ul><p>因为本地，我们不仅要知道<u>元素</u>有没有遍历过，还有知道这个元素<u>对应的下标</u>，<strong>需要使用 key value 结构来存放，key 来存元素，value 来存下标，那么使用 map 正合适</strong>。</p><p>此时就要选择另一种数据结构：map ，map 是一种 key value 的存储结构，可以用 key 保存数值，用 value 在保存数值所在的下标。</p><p>C++ 中 map，有三种类型：</p><table><thead><tr><th>映射</th><th>底层实现</th><th>是否有序</th><th>数值是否可以重复</th><th>能否更改数值</th><th>查询效率</th><th>增删效率</th></tr></thead><tbody><tr><td>std::map</td><td>红黑树</td><td>key 有序</td><td>key 不可重复</td><td>key 不可修改</td><td>O(log n)</td><td>O(log n)</td></tr><tr><td>std::multimap</td><td>红黑树</td><td>key 有序</td><td>key 可重复</td><td>key 不可修改</td><td>O(log n)</td><td>O(log n)</td></tr><tr><td>std::unordered_map</td><td>哈希表</td><td>key 无序</td><td>key 不可重复</td><td>key 不可修改</td><td>O(1)</td><td>O(1)</td></tr></tbody></table><p>std::unordered_map 底层实现为哈希表，std::map 和 std::multimap 的底层实现是红黑树。</p><p>同理，std::map 和 std::multimap 的 key 也是有序的（这个问题也经常作为面试题，考察对语言容器底层的理解）。 更多哈希表的理论知识请看<span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLyVFNSU5MyU4OCVFNSVCOCU4QyVFOCVBMSVBOCVFNyU5MCU4NiVFOCVBRSVCQSVFNSU5RiVCQSVFNyVBMSU4MC5odG1s">关于哈希表，你该了解这些！</span>。</p><p><strong>这道题目中并不需要 key 有序，选择 std::unordered_map 效率更高！</strong> 使用其他语言的录友注意了解一下自己所用语言的数据结构就行。</p><p>接下来需要明确两点：</p><ul><li><strong>map 用来做什么</strong></li><li><strong>map 中 key 和 value 分别表示什么</strong></li></ul><p><strong>map 目的用来存放我们访问过的元素</strong>，因为遍历数组的时候，需要记录我们之前遍历过哪些元素和对应的下表，这样才能找到与当前元素相匹配的（也就是相加等于 target）</p><p>接下来是 map 中 key 和 value 分别表示什么。</p><p>这道题 我们需要 给出一个元素，判断这个元素是否出现过，如果出现过，返回这个元素的下标。</p><p>那么判断元素是否出现，这个元素就要作为 key，所以数组中的元素作为 key，有 key 对应的就是 value，value 用来存下标。</p><p>所以 <strong>map 中的存储结构为 {key：数据元素，value：数组元素对应的下表}</strong>。</p><p>在遍历数组的时候，只需要向 map 去查询是否有和目前遍历元素比配的数值，如果有，就找到的匹配对，如果没有，就把目前遍历的元素放进 map 中，因为 map 存放的就是我们访问过的元素。</p><p>过程如下：</p><p><img data-src="https://code-thinking-1253855093.file.myqcloud.com/pics/20220711202638.png" alt="过程一"></p><p><img data-src="https://code-thinking-1253855093.file.myqcloud.com/pics/20220711202708.png" alt="过程二"></p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">twoSum</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token comment">// 输出：符合条件的两个正数的下标，故用一个大小为 2 的数组来存储</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token comment">// 特判，如果数组为空，直接返回空数组</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> nums<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>            <span class="token keyword">return</span> result<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token comment">// 用一个 map 来存储数组中访问过的元素，key 为元素值，value 为元素下标</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">></span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token comment">// 遍历数组</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>            <span class="token comment">// 判断 target-nums [i] 是否访问过（即 map 的 key 中是否存在）</span></pre></td></tr><tr><td data-num="15"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>target <span class="token operator">-</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>                <span class="token comment">// 找到了符合条件的两个数，将下标存入 result 数组中</span></pre></td></tr><tr><td data-num="17"></td><td><pre>                result<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target <span class="token operator">-</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>                result<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>                <span class="token keyword">break</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>            <span class="token comment">// 将当前元素存入 map 中</span></pre></td></tr><tr><td data-num="22"></td><td><pre>            map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>        <span class="token comment">// 没有找到符合条件的两个数，返回空数组</span></pre></td></tr><tr><td data-num="25"></td><td><pre>        <span class="token keyword">return</span> result<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="27"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h4 id="总结-3"><a class="anchor" href="#总结-3">#</a> 总结</h4><p>本题其实有四个重点：</p><ul><li>为什么会想到用哈希表</li></ul><blockquote><p>因为题目要求<strong>找到</strong>符合条件的元素</p></blockquote><ul><li>哈希表为什么用 map</li></ul><blockquote><p>因为题目不仅要求找到符合条件的元素，还要返回<strong>对应的下标索引</strong></p></blockquote><ul><li>本题 map 是用来存什么的</li></ul><blockquote><p>遍历过的元素，及其下标</p></blockquote><ul><li>map 中的 key 和 value 用来存什么的</li></ul><blockquote><p>key：元素的数值，value：元素的下标</p></blockquote><p>把这四点想清楚了，本题才算是理解透彻了。</p><p>很多录友把这道题目 通过了，但都没想清楚 map 是用来做什么的，以至于对代码的理解其实是 一知半解的。</p><h3 id="454-四数相加-ii"><a class="anchor" href="#454-四数相加-ii">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy80c3VtLWlpLw==">454. 四数相加 II</span></h3><blockquote><p>需要哈希的地方都能找到 map 的身影</p></blockquote><p>本题咋眼一看好像和<span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVyY2FybC5jb20vMDAxNS4lRTQlQjglODklRTYlOTUlQjAlRTQlQjklOEIlRTUlOTIlOEMuaHRtbA=="> 0015. 三数之和 </span>，<span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVyY2FybC5jb20vMDAxOC4lRTUlOUIlOUIlRTYlOTUlQjAlRTQlQjklOEIlRTUlOTIlOEMuaHRtbA==">0018. 四数之和 </span>差不多，其实差很多。</p><p><strong>本题是使用哈希法的经典题目，而<span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVyY2FybC5jb20vMDAxNS4lRTQlQjglODklRTYlOTUlQjAlRTQlQjklOEIlRTUlOTIlOEMuaHRtbA=="> 0015. 三数之和</span>，<span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVyY2FybC5jb20vMDAxOC4lRTUlOUIlOUIlRTYlOTUlQjAlRTQlQjklOEIlRTUlOTIlOEMuaHRtbA==">0018. 四数之和 </span>并不合适使用哈希法</strong>，因为三数之和和四数之和这两道题目使用哈希法在不超时的情况下做到对结果去重是很困难的，很有多细节需要处理。</p><p><strong>而这道题目是四个独立的数组，只要找到 A [i] + B [j] + C [k] + D [l] = 0 就可以，不用考虑有重复的四个元素相加等于 0 的情况，所以相对于题目 18. 四数之和，题目 15. 三数之和，还是简单了不少！</strong></p><p>如果本题想难度升级：就是给出一个数组（而不是四个数组），在这里找出四个元素相加等于 0，答案中不可以包含重复的四元组，大家可以思考一下，后续的文章我也会讲到的。</p><p>本题解题步骤：</p><ol><li>首先定义 一个 unordered_map，key 放 a 和 b 两数之和，value 放 a 和 b 两数之和出现的次数。</li><li>遍历大 A 和大 B 数组，统计两个数组元素之和，和出现的次数，放到 map 中。</li><li>定义 int 变量 count，用来统计 a+b+c+d = 0 出现的次数。</li><li>在遍历大 C 和大 D 数组，找到如果 0-(c+d) 在 map 中出现过的话，就用 count 把 map 中 key 对应的 value 也就是出现次数统计出来。</li><li>最后返回统计值 count 就可以了</li></ol><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">fourSumCount</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums1<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums2<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums3<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums4<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token comment">// 输出：符合条件的四元组的个数</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">></span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//key：a+b 的数值，value：a+b 数值出现的次数</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token comment">// 遍历 A、B 数组，统计两个数组元素之和 a+b，和出现的次数，放到 map 中</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums1<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> nums2<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>                <span class="token keyword">int</span> sum <span class="token operator">=</span> nums1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> nums2<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>                map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>sum<span class="token punctuation">,</span> map<span class="token punctuation">.</span><span class="token function">getOrDefault</span><span class="token punctuation">(</span>sum<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//map.getOrDefault (sum, 0)：如果 map 中没有 sum 这个 key，就返回 0，否则返回 sum 对应的 value</span></pre></td></tr><tr><td data-num="12"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token comment">// 遍历 C、D 数组，记录两个数组元素之和 c+d，查询 map 中是否存在 -(c+d)，如果存在，就把 map 中 -(c+d) 对应的 value 值加到 count 中</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums3<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> nums4<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>                <span class="token keyword">int</span> sum <span class="token operator">=</span> nums3<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> nums4<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>                <span class="token keyword">if</span> <span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span><span class="token operator">-</span>sum<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 如果 map 中有 - sum 这个 key，即存在两个数的和为 - sum</span></pre></td></tr><tr><td data-num="20"></td><td><pre>                    count <span class="token operator">+=</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token operator">-</span>sum<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将两个数的和为 - sum 的次数加到 count 中，即为符合条件的四元组的个数</span></pre></td></tr><tr><td data-num="21"></td><td><pre>                <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="24"></td><td><pre></pre></td></tr><tr><td data-num="25"></td><td><pre>        <span class="token keyword">return</span> count<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="27"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id="15-三数之和"><a class="anchor" href="#15-三数之和">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy8zc3VtLw==">15. 三数之和</span></h3><blockquote><p>用哈希表解决了<span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVyY2FybC5jb20vMDAwMS4lRTQlQjglQTQlRTYlOTUlQjAlRTQlQjklOEIlRTUlOTIlOEMuaHRtbA==">两数之和</span>，那么三数之和呢？</p></blockquote><h4 id="哈希解法-2"><a class="anchor" href="#哈希解法-2">#</a> 哈希解法</h4><h4 id="双指针"><a class="anchor" href="#双指针">#</a> 双指针</h4><p><strong>其实这道题目使用哈希法并不十分合适</strong>，因为在去重的操作中有很多细节需要注意，在面试中很难直接写出没有 bug 的代码。</p><p>而且使用哈希法 在使用两层 for 循环的时候，能做的剪枝操作很有限，虽然时间复杂度是 O (n^2)，也是可以在 leetcode 上通过，但是程序的执行时间依然比较长 。</p><p>接下来我来介绍另一个解法：双指针法，<strong>这道题目使用双指针法要比哈希法高效一些</strong>，那么来讲解一下具体实现的思路。</p><p>动画效果如下：</p><p><img data-src="https://code-thinking.cdn.bcebos.com/gifs/15.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C.gif" alt="15.三数之和"></p><p>拿这个 nums 数组来举例，<strong>首先将数组排序</strong>，然后有<strong>一层 for 循环</strong></p><ul><li>i 从下标 0 的地方开始</li><li>定义一个下标 left 定义在 i+1 的位置上</li><li>定义下标 right 在数组结尾的位置上</li></ul><p>依然还是在数组中找到 abc 使得 a + b +c =0，我们这里相当于 a = nums [i]，b = nums [left]，c = nums [right]。</p><p>接下来<strong>如何移动 left 和 right 呢？</strong></p><ul><li>如果 nums [i] + nums [left] + nums [right] &gt; 0 就说明 此时三数之和大了，因为数组是排序后了，所以 right 下标就应该向左移动，这样才能让三数之和小一些</li><li>如果 nums [i] + nums [left] + nums [right] &lt; 0 说明 此时 三数之和小了，left 就向右移动，才能让三数之和大一些</li><li>直到 left 与 right 相遇为止。</li></ul><p>时间复杂度：O (n^2)</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 双指针法，先排序，然后固定一个数，然后双指针。时间复杂度 O (n^2)，空间复杂度 O (1)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span><span class="token punctuation">></span></span> <span class="token function">threeSum</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token comment">// 输出：一个二维数组，每个元素是一个三元数组</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span><span class="token punctuation">></span></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token comment">// 1. 排序</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token comment">// 2. 遍历</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>            <span class="token comment">// 2.1 剪枝：如果当前数字大于 0，则三数之和一定大于 0，所以结束循环</span></pre></td></tr><tr><td data-num="11"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>                <span class="token keyword">break</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>            <span class="token comment">// 2.2 去重（对 a）：如果和前一个数相同，则跳过</span></pre></td></tr><tr><td data-num="15"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>                <span class="token keyword">continue</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>            <span class="token comment">// 2.3 定义左右指针</span></pre></td></tr><tr><td data-num="19"></td><td><pre>            <span class="token keyword">int</span> left <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>            <span class="token keyword">int</span> right <span class="token operator">=</span> nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>            <span class="token comment">// 2.4 遍历</span></pre></td></tr><tr><td data-num="22"></td><td><pre>            <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>                <span class="token comment">// 2.4.1 计算 a+b+c</span></pre></td></tr><tr><td data-num="24"></td><td><pre>                <span class="token keyword">int</span> sum <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>                <span class="token comment">// 2.4.2 如果 a+b+c>0，则 right 左移</span></pre></td></tr><tr><td data-num="26"></td><td><pre>                <span class="token keyword">if</span> <span class="token punctuation">(</span>sum <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>                    right<span class="token operator">--</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>                <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>                <span class="token comment">// 2.4.3 如果 a+b+c&lt;0，则 left 右移</span></pre></td></tr><tr><td data-num="30"></td><td><pre>                <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>sum <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="31"></td><td><pre>                    left<span class="token operator">++</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>                <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="33"></td><td><pre>                <span class="token comment">// 2.4.4 如果 a+b+c=0，则将结果加入 res</span></pre></td></tr><tr><td data-num="34"></td><td><pre>                <span class="token keyword">else</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="35"></td><td><pre>                    res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="36"></td><td><pre>                    <span class="token comment">// 2.4.4.1 对 b 去重：如果和左边的数相同，则 left 右移</span></pre></td></tr><tr><td data-num="37"></td><td><pre>                    <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="38"></td><td><pre>                        left<span class="token operator">++</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="39"></td><td><pre>                    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="40"></td><td><pre>                    <span class="token comment">// 2.4.4.2 对 c 去重：如果和右边的数相同，则 right 左移</span></pre></td></tr><tr><td data-num="41"></td><td><pre>                    <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>right <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="42"></td><td><pre>                        right<span class="token operator">--</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="43"></td><td><pre>                    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="44"></td><td><pre>                    left<span class="token operator">++</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="45"></td><td><pre>                    right<span class="token operator">--</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="46"></td><td><pre>                <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="47"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="48"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="49"></td><td><pre>        <span class="token keyword">return</span> res<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="50"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="51"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h4 id="去重逻辑的思考"><a class="anchor" href="#去重逻辑的思考">#</a> 去重逻辑的思考</h4><p>说道去重，其实主要考虑三个数的去重。 a, b ,c, 对应的就是 nums [i]，nums [left]，nums [right]。</p><h5 id="a的去重"><a class="anchor" href="#a的去重">#</a> a 的去重</h5><p>a 如果重复了怎么办，a 是 nums 里遍历的元素，那么应该直接跳过去。</p><p>但这里有一个问题，<strong>是判断 nums [i] 与 nums [i + 1] 是否相同，还是判断 nums [i] 与 nums [i-1] 是否相同</strong>。</p><p>有同学可能想，这不都一样吗。</p><p>其实不一样！</p><p>都是和 nums [i] 进行比较，是比较它的前一个，还是比较他的后一个。</p><p>如果我们的写法是 这样：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 去重操作</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">continue</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>那就我们就把三元组中出现重复元素的情况直接 pass 掉了。 例如 {-1, -1 ,2} 这组数据，当遍历到第一个 - 1 的时候，判断 下一个也是 - 1，那这组数据就 pass 了。</p><p><strong>我们要做的是 不能有重复的三元组，但三元组内的元素是可以重复的！</strong></p><p>所以这里是有两个重复的维度。</p><p>那么应该这么写：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">continue</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>这么写就是当前使用 nums [i]，我们判断前一位是不是一样的元素，在看 {-1, -1 ,2} 这组数据，当遍历到 第一个 -1 的时候，只要前一位没有 - 1，那么 {-1, -1 ,2} 这组数据一样可以收录到 结果集里。</p><p>这是一个非常细节的思考过程。</p><h5 id="b-c的去重"><a class="anchor" href="#b-c的去重">#</a> b、c 的去重</h5><p>很多同学写本题的时候，去重的逻辑多加了 对 right 和 left 的去重：（代码中注释部分）</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">while</span> <span class="token punctuation">(</span>right <span class="token operator">></span> left<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        right<span class="token operator">--</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token comment">// 去重 right</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>right <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> right<span class="token operator">--</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        left<span class="token operator">++</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token comment">// 去重 left</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>left <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> left<span class="token operator">++</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>但细想一下，<strong>这种去重其实对提升程序运行效率是没有帮助的</strong>。</p><p>拿 right 去重为例，即使不加这个去重逻辑，依然根据 <code>while (right &gt; left)</code> 和 <code>if (nums[i] + nums[left] + nums[right] &gt; 0)</code> 去完成 right-- 的操作。</p><p>多加了 <code>while (left &lt; right &amp;&amp; nums[right] == nums[right + 1]) right--;</code> 这一行代码，其实就是把 需要执行的逻辑提前执行了，但并没有减少 判断的逻辑。</p><p>最直白的思考过程，就是 right 还是一个数一个数的减下去的，所以在哪里减的都是一样的。</p><p>所以<strong>这种去重 是可以不加的。 仅仅是 把去重的逻辑提前了而已</strong>。</p><h4 id="思考"><a class="anchor" href="#思考">#</a> 思考</h4><p>既然三数之和可以使用双指针法，我们之前讲过的<span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVyY2FybC5jb20vMDAwMS4lRTQlQjglQTQlRTYlOTUlQjAlRTQlQjklOEIlRTUlOTIlOEMuaHRtbA=="> 1. 两数之和</span>，可不可以使用双指针法呢？</p><p>如果不能，题意如何更改就可以使用双指针法呢？</p><p><strong>两数之和就不能使用双指针法，因为<span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVyY2FybC5jb20vMDAwMS4lRTQlQjglQTQlRTYlOTUlQjAlRTQlQjklOEIlRTUlOTIlOEMuaHRtbA=="> 1. 两数之和</span>要求返回的是索引下标， 而双指针法一定要排序，一旦排序之后原数组的索引就被改变了。</strong></p><p><strong>如果<span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVyY2FybC5jb20vMDAwMS4lRTQlQjglQTQlRTYlOTUlQjAlRTQlQjklOEIlRTUlOTIlOEMuaHRtbA=="> 1. 两数之和</span>要求返回的是数值的话，就可以使用双指针法了。</strong></p><h3 id="18-四数之和"><a class="anchor" href="#18-四数之和">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy80c3VtLw==">18. 四数之和</span></h3><blockquote><p>一样的道理，能解决四数之和 那么五数之和、六数之和、N 数之和呢？</p></blockquote><p><strong>四数之和，和<span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVyY2FybC5jb20vMDAxNS4lRTQlQjglODklRTYlOTUlQjAlRTQlQjklOEIlRTUlOTIlOEMuaHRtbA=="> 15. 三数之和</span>是一个思路，都是使用双指针法，基本解法就是在<span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVyY2FybC5jb20vMDAxNS4lRTQlQjglODklRTYlOTUlQjAlRTQlQjklOEIlRTUlOTIlOEMuaHRtbA=="> 15. 三数之和</span>的基础上再套一层 for 循环。</strong></p><p>但是要注意<strong>剪枝、去重的操作不一样了</strong>。</p><p>但是有一些细节需要注意，例如： <strong>不要判断 <code>nums[k] &gt; target</code> 就返回了</strong>，三数之和 可以通过 <code>nums[i] &gt; 0</code> 就返回了，因为 0 已经是确定的数了，四数之和这道题目 <strong>target 是任意值</strong>。比如：数组是 <code>[-4, -3, -2, -1]</code> ， <code>target</code> 是 <code>-10</code> ，不能因为 <code>-4 &gt; -10</code> 而跳过。但是我们依旧可以去做剪枝，** 逻辑变成 <code>nums[i] &gt; target &amp;&amp; (nums[i] &gt;=0 || target &gt;= 0)</code> ** 就可以了。</p><p><span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVyY2FybC5jb20vMDAxNS4lRTQlQjglODklRTYlOTUlQjAlRTQlQjklOEIlRTUlOTIlOEMuaHRtbA==">15. 三数之和</span>的双指针解法是一层 for 循环 num [i] 为确定值，然后循环内有 left 和 right 下标作为双指针，找到 nums [i] + nums [left] + nums [right] == 0。</p><p>四数之和的双指针解法是<strong>两层 for 循环 nums [k] + nums [i] 为确定值，依然是循环内有 left 和 right 下标作为双指针</strong>，找出 nums [k] + nums [i] + nums [left] + nums [right] == target 的情况，<strong>三数之和的时间复杂度是 O (n^2)，四数之和的时间复杂度是 O (n^3)</strong> 。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span><span class="token punctuation">></span></span> <span class="token function">fourSum</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token comment">// 输出：一个二维数组，每个元素是一个三元数组</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span><span class="token punctuation">></span></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token comment">// 1. 排序</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token comment">// 2. 遍历</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>            <span class="token comment">// 一级剪枝</span></pre></td></tr><tr><td data-num="10"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> target <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="11"></td><td><pre>                <span class="token keyword">break</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>            <span class="token comment">// 一级去重</span></pre></td></tr><tr><td data-num="13"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="14"></td><td><pre>                <span class="token keyword">continue</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre></pre></td></tr><tr><td data-num="16"></td><td><pre>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>                <span class="token comment">// 二级剪枝</span></pre></td></tr><tr><td data-num="18"></td><td><pre>                <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> target <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="19"></td><td><pre>                    <span class="token keyword">break</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>                <span class="token comment">// 二级去重（对 a+b）</span></pre></td></tr><tr><td data-num="21"></td><td><pre>                <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">></span> i <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>                    <span class="token keyword">continue</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>                <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="24"></td><td><pre></pre></td></tr><tr><td data-num="25"></td><td><pre>                <span class="token comment">// 2.3 定义左右指针</span></pre></td></tr><tr><td data-num="26"></td><td><pre>                <span class="token keyword">int</span> left <span class="token operator">=</span> j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>                <span class="token keyword">int</span> right <span class="token operator">=</span> nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>                <span class="token comment">// 2.4 遍历</span></pre></td></tr><tr><td data-num="29"></td><td><pre>                <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>                    <span class="token comment">// 2.4.1 计算 a+b+c+d</span></pre></td></tr><tr><td data-num="31"></td><td><pre>                    <span class="token keyword">int</span> sum <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>                    <span class="token comment">// 2.4.2 如果 a+b+c+d>target，则 right 左移</span></pre></td></tr><tr><td data-num="33"></td><td><pre>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>sum <span class="token operator">></span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="34"></td><td><pre>                        right<span class="token operator">--</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="35"></td><td><pre>                    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="36"></td><td><pre>                    <span class="token comment">// 2.4.3 如果 a+b+c+d&lt;target，则 left 右移</span></pre></td></tr><tr><td data-num="37"></td><td><pre>                    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>sum <span class="token operator">&lt;</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="38"></td><td><pre>                        left<span class="token operator">++</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="39"></td><td><pre>                    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="40"></td><td><pre>                    <span class="token comment">// 2.4.4 如果 a+b+c+d=target，则将结果加入 res</span></pre></td></tr><tr><td data-num="41"></td><td><pre>                    <span class="token keyword">else</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="42"></td><td><pre>                        res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="43"></td><td><pre>                        <span class="token comment">// 2.4.4.1 对 c 去重：如果和左边的数相同，则 left 右移</span></pre></td></tr><tr><td data-num="44"></td><td><pre>                        <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="45"></td><td><pre>                            left<span class="token operator">++</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="46"></td><td><pre>                        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="47"></td><td><pre>                        <span class="token comment">// 2.4.4.2 对 d 去重：如果和右边的数相同，则 right 左移</span></pre></td></tr><tr><td data-num="48"></td><td><pre>                        <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>right <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="49"></td><td><pre>                            right<span class="token operator">--</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="50"></td><td><pre>                        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="51"></td><td><pre>                        left<span class="token operator">++</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="52"></td><td><pre>                        right<span class="token operator">--</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="53"></td><td><pre>                    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="54"></td><td><pre>                <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="55"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="56"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="57"></td><td><pre>        <span class="token keyword">return</span> res<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="58"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="59"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>那么一样的道理，<strong>五数之和、六数之和等等都采用这种解法</strong>。</p><p>对于<span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVyY2FybC5jb20vMDAxNS4lRTQlQjglODklRTYlOTUlQjAlRTQlQjklOEIlRTUlOTIlOEMuaHRtbA=="> 15. 三数之和</span>双指针法就是将原本暴力 O (n^3) 的解法，降为 O (n^2) 的解法，<strong>四数之和的双指针解法就是将原本暴力 O (n^4) 的解法，降为 O (n^3) 的解法</strong>。</p><p>之前我们讲过哈希表的经典题目：<span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVyY2FybC5jb20vMDQ1NC4lRTUlOUIlOUIlRTYlOTUlQjAlRTclOUIlQjglRTUlOEElQTBJSS5odG1s">454. 四数相加 II </span>，相对于本题简单很多，因为本题是要求在一个集合中找出四个数相加等于 target，同时四元组不能重复。</p><p>而<span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVyY2FybC5jb20vMDQ1NC4lRTUlOUIlOUIlRTYlOTUlQjAlRTclOUIlQjglRTUlOEElQTBJSS5odG1s"> 454. 四数相加 II </span>是四个独立的数组，只要找到 A [i] + B [j] + C [k] + D [l] = 0 就可以，不用考虑有重复的四个元素相加等于 0 的情况，所以相对于本题还是简单了不少！</p><p>我们来回顾一下，几道题目使用了双指针法。</p><p><strong><u>双指针法</u>将时间复杂度：O (n^2) 的解法优化为 O (n) 的解法。也就是降一个数量级</strong>，题目如下：</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVyY2FybC5jb20vMDAyNy4lRTclQTclQkIlRTklOTklQTQlRTUlODUlODMlRTclQjQlQTAuaHRtbA==">27. 移除元素</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVyY2FybC5jb20vMDAxNS4lRTQlQjglODklRTYlOTUlQjAlRTQlQjklOEIlRTUlOTIlOEMuaHRtbA==">15. 三数之和</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVyY2FybC5jb20vMDAxOC4lRTUlOUIlOUIlRTYlOTUlQjAlRTQlQjklOEIlRTUlOTIlOEMuaHRtbA==">18. 四数之和</span></li></ul><p>链表相关双指针题目：</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVyY2FybC5jb20vMDIwNi4lRTclQkYlQkIlRTglQkQlQUMlRTklOTMlQkUlRTglQTElQTguaHRtbA==">206. 反转链表</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVyY2FybC5jb20vMDAxOS4lRTUlODglQTAlRTklOTklQTQlRTklOTMlQkUlRTglQTElQTglRTclOUElODQlRTUlODAlOTIlRTYlOTUlQjAlRTclQUMlQUNOJUU0JUI4JUFBJUU4JThBJTgyJUU3JTgyJUI5Lmh0bWw=">19. 删除链表的倒数第 N 个节点</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVyY2FybC5jb20vJUU5JTlEJUEyJUU4JUFGJTk1JUU5JUEyJTk4MDIuMDcuJUU5JTkzJUJFJUU4JUExJUE4JUU3JTlCJUI4JUU0JUJBJUE0Lmh0bWw=">面试题 02.07. 链表相交</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVyY2FybC5jb20vMDE0Mi4lRTclOEUlQUYlRTUlQkQlQTIlRTklOTMlQkUlRTglQTElQThJSS5odG1s">142 题。环形链表 II</span></li></ul><p>双指针法在字符串题目中还有很多应用，后面还会介绍到。</p><h3 id="总结-4"><a class="anchor" href="#总结-4">#</a> 总结</h3><h4 id="理论基础-3"><a class="anchor" href="#理论基础-3">#</a> 理论基础</h4><p>在<span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVyY2FybC5jb20vJUU1JTkzJTg4JUU1JUI4JThDJUU4JUExJUE4JUU3JTkwJTg2JUU4JUFFJUJBJUU1JTlGJUJBJUU3JUExJTgwLmh0bWw=">关于哈希表，你该了解这些！ </span>中，我们介绍了哈希表的基础理论知识，不同于枯燥的讲解，这里介绍了都是对刷题有帮助的理论知识点。</p><p><strong>一般来说哈希表都是用来快速判断一个元素是否出现集合里</strong>。</p><p>对于哈希表，要知道<strong>哈希函数</strong>和<strong>哈希碰撞</strong>在哈希表中的作用.</p><p>哈希函数是把传入的 key 映射到符号表的索引上。</p><p>哈希碰撞处理有多个 key 映射到相同索引上时的情景，处理碰撞的普遍方式是拉链法和线性探测法。</p><p>接下来是常见的三种哈希结构：</p><ul><li>数组</li><li>set（集合）</li><li>map（映射）</li></ul><p>在 C++ 语言中，set 和 map 都分别提供了三种数据结构，每种数据结构的底层实现和用途都有所不同，在<span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVyY2FybC5jb20vJUU1JTkzJTg4JUU1JUI4JThDJUU4JUExJUE4JUU3JTkwJTg2JUU4JUFFJUJBJUU1JTlGJUJBJUU3JUExJTgwLmh0bWw=">关于哈希表，你该了解这些！ </span>中我给出了详细分析，这一知识点很重要！</p><p>例如什么时候用 std::set，什么时候用 std::multiset，什么时候用 std::unordered_set，都是很有考究的。</p><p><strong>只有对这些数据结构的底层实现很熟悉，才能灵活使用，否则很容易写出效率低下的程序</strong>。</p><h4 id="经典题目"><a class="anchor" href="#经典题目">#</a> 经典题目</h4><h5 id="u数组u作为哈希表"><a class="anchor" href="#u数组u作为哈希表">#</a> <u>数组</u>作为哈希表</h5><p>一些应用场景就是为数组量身定做的。</p><p>在<span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVyY2FybC5jb20vMDI0Mi4lRTYlOUMlODklRTYlOTUlODglRTclOUElODQlRTUlQUQlOTclRTYlQUYlOEQlRTUlQkMlODIlRTQlQkQlOEQlRTglQUYlOEQuaHRtbA=="> 242. 有效的字母异位词 </span>中，我们提到了数组就是简单的哈希表，但是<strong>数组的大小是受限的</strong>！</p><p>这道题目包含小写字母，那么使用数组来做哈希最合适不过。</p><p>在<span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVyY2FybC5jb20vMDM4My4lRTglQjUlOEUlRTklODclOTElRTQlQkYlQTEuaHRtbA=="> 383. 赎金信 </span>中同样要求只有小写字母，那么就给我们浓浓的暗示，用数组！本题和<span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVyY2FybC5jb20vMDI0Mi4lRTYlOUMlODklRTYlOTUlODglRTclOUElODQlRTUlQUQlOTclRTYlQUYlOEQlRTUlQkMlODIlRTQlQkQlOEQlRTglQUYlOEQuaHRtbA=="> 242. 有效的字母异位词 </span>很像，<span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVyY2FybC5jb20vMDI0Mi4lRTYlOUMlODklRTYlOTUlODglRTclOUElODQlRTUlQUQlOTclRTYlQUYlOEQlRTUlQkMlODIlRTQlQkQlOEQlRTglQUYlOEQuaHRtbA==">242. 有效的字母异位词 </span>是求 字符串 a 和 字符串 b 是否可以相互组成，在<span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVyY2FybC5jb20vMDM4My4lRTglQjUlOEUlRTklODclOTElRTQlQkYlQTEuaHRtbA=="> 383. 赎金信 </span>中是求字符串 a 能否组成字符串 b，而不用管字符串 b 能不能组成字符串 a。</p><p>一些同学可能想，用数组干啥，都用 map 不就完事了。</p><p><strong>上面两道题目用 map 确实可以，但使用 map 的空间消耗要比数组大一些，因为 map 要维护红黑树或者符号表，而且还要做哈希函数的运算。所以数组更加简单直接有效！</strong></p><h5 id="usetu作为哈希表"><a class="anchor" href="#usetu作为哈希表">#</a> <u>set</u>作为哈希表</h5><p>在<span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVyY2FybC5jb20vMDM0OS4lRTQlQjglQTQlRTQlQjglQUElRTYlOTUlQjAlRTclQkIlODQlRTclOUElODQlRTQlQkElQTQlRTklOUIlODYuaHRtbA=="> 349. 两个数组的交集 </span>中我们给出了什么时候用数组就不行了，需要用 set。</p><p>这道题目<strong>没有限制数值的大小</strong>，就无法使用数组来做哈希表了。</p><p><strong>主要因为如下两点：</strong></p><ul><li>数组的大小是有限的，受到系统栈空间（不是数据结构的栈）的限制。</li><li><strong>如果数组空间够大，但哈希值比较少、特别分散、跨度非常大，使用数组就造成空间的极大浪费。</strong></li></ul><p>所以此时一样的做映射的话，就可以使用 set 了。</p><p>关于 set，C++ 给提供了如下三种可用的数据结构：（详情请看<span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVyY2FybC5jb20vJUU1JTkzJTg4JUU1JUI4JThDJUU4JUExJUE4JUU3JTkwJTg2JUU4JUFFJUJBJUU1JTlGJUJBJUU3JUExJTgwLmh0bWw=">关于哈希表，你该了解这些！ </span>）</p><ul><li>std::set</li><li>std::multiset</li><li>std::unordered_set</li></ul><p>std::set 和 std::multiset 底层实现都是红黑树，std::unordered_set 的底层实现是哈希， 使用 unordered_set 读写效率是最高的，本题并不需要对数据进行排序，而且还不要让数据重复，所以选择 unordered_set。</p><p>在<span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVyY2FybC5jb20vMDIwMi4lRTUlQkYlQUIlRTQlQjklOTAlRTYlOTUlQjAuaHRtbA=="> 202. 快乐数 </span>中，我们再次使用了 unordered_set 来判断一个数是否重复出现过。</p><h5 id="umapu作为哈希表"><a class="anchor" href="#umapu作为哈希表">#</a> <u>map</u>作为哈希表</h5><p>在<span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVyY2FybC5jb20vMDAwMS4lRTQlQjglQTQlRTYlOTUlQjAlRTQlQjklOEIlRTUlOTIlOEMuaHRtbA=="> 1. 两数之和 </span>中 map 正式登场。</p><p>来说一说：使用数组和 set 来做哈希法的局限。</p><ul><li><strong>数组的大小是受限制的</strong>，而且如果元素很少，而哈希值太大会造成内存空间的浪费。</li><li><strong>set 是一个集合，里面放的元素只能是一个 key</strong>，而两数之和这道题目，不仅要判断 y 是否存在而且还要记录 y 的下标位置，因为要返回 x 和 y 的下标。所以 set 也不能用。</li></ul><p><strong>map 是一种 <code>&lt;key, value&gt;</code> 的结构</strong>，本题可以用 key 保存数值，用 value 在保存数值所在的下标。所以使用 map 最为合适。</p><p>C++ 提供如下三种 map：：（详情请看<span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVyY2FybC5jb20vJUU1JTkzJTg4JUU1JUI4JThDJUU4JUExJUE4JUU3JTkwJTg2JUU4JUFFJUJBJUU1JTlGJUJBJUU3JUExJTgwLmh0bWw=">关于哈希表，你该了解这些！ </span>）</p><ul><li>std::map</li><li>std::multimap</li><li>std::unordered_map</li></ul><p>std::unordered_map 底层实现为哈希，std::map 和 std::multimap 的底层实现是红黑树。</p><p>同理，std::map 和 std::multimap 的 key 也是有序的（这个问题也经常作为面试题，考察对语言容器底层的理解），<span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVyY2FybC5jb20vMDAwMS4lRTQlQjglQTQlRTYlOTUlQjAlRTQlQjklOEIlRTUlOTIlOEMuaHRtbA==">1. 两数之和 </span>中并不需要 key 有序，选择 std::unordered_map 效率更高！</p><p>在<span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVyY2FybC5jb20vMDQ1NC4lRTUlOUIlOUIlRTYlOTUlQjAlRTclOUIlQjglRTUlOEElQTBJSS5odG1s"> 454. 四数相加 </span>中我们提到了其实需要哈希的地方都能找到 map 的身影。</p><p>本题咋眼一看好像和<span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVyY2FybC5jb20vMDAxOC4lRTUlOUIlOUIlRTYlOTUlQjAlRTQlQjklOEIlRTUlOTIlOEMuaHRtbA=="> 18. 四数之和 </span>，<span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVyY2FybC5jb20vMDAxNS4lRTQlQjglODklRTYlOTUlQjAlRTQlQjklOEIlRTUlOTIlOEMuaHRtbA==">15. 三数之和 </span>差不多，其实差很多！</p><p><strong>关键差别是本题为四个独立的数组，只要找到 A [i] + B [j] + C [k] + D [l] = 0 就可以，不用考虑重复问题，而<span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVyY2FybC5jb20vMDAxOC4lRTUlOUIlOUIlRTYlOTUlQjAlRTQlQjklOEIlRTUlOTIlOEMuaHRtbA=="> 18. 四数之和 </span>，<span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVyY2FybC5jb20vMDAxNS4lRTQlQjglODklRTYlOTUlQjAlRTQlQjklOEIlRTUlOTIlOEMuaHRtbA==">15. 三数之和 </span>是一个数组（集合）里找到和为 0 的组合，可就难很多了！</strong></p><p>用哈希法解决了两数之和，很多同学会感觉用哈希法也可以解决三数之和，四数之和。</p><p>其实是可以解决，但是非常麻烦，需要去重导致代码效率很低。</p><p>在<span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVyY2FybC5jb20vMDAxNS4lRTQlQjglODklRTYlOTUlQjAlRTQlQjklOEIlRTUlOTIlOEMuaHRtbA=="> 15. 三数之和 </span>中我给出了<strong>哈希法</strong>和<strong>双指针</strong>两个解法，大家就可以体会到，使用哈希法还是比较麻烦的。</p><p>所以 18. 四数之和，15. 三数之和都推荐使用双指针法！</p><h4 id="总结-5"><a class="anchor" href="#总结-5">#</a> 总结</h4><p>对于哈希表的知识相信很多同学都知道，但是没有成体系。</p><p>本篇我们从哈希表的理论基础到数组、set 和 map 的经典应用，把哈希表的整个全貌完整的呈现给大家。</p><p><strong>同时也强调虽然 map 是万能的，详细介绍了什么时候用数组，什么时候用 set</strong>。</p><p>相信通过这个总结篇，大家可以对哈希表有一个全面的了解。</p><h2 id="字符串"><a class="anchor" href="#字符串">#</a> 字符串</h2><h3 id="344-反转字符串"><a class="anchor" href="#344-反转字符串">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yZXZlcnNlLXN0cmluZy8=">344. 反转字符串</span></h3><blockquote><p>打基础的时候，不要太迷恋于库函数。</p></blockquote><p>在反转链表中，使用了<strong>双指针</strong>的方法。</p><p>那么反转字符串依然是使用双指针的方法，只不过<strong>对于字符串的反转，其实要比链表简单一些</strong>。</p><blockquote><p>因为（单）链表只能借助<strong> next 指针</strong>进行反转，所以两个指针必须同向运动，而对字符串的反转，直接<strong>交换</strong>两侧对应位置的字符即可</p></blockquote><p>因为字符串也是一种数组，所以元素在内存中是连续分布，这就决定了反转链表和反转字符串方式上还是有所差异的。</p><p>对于字符串，我们<strong>定义两个指针（也可以说是索引下标），一个从字符串前面，一个从字符串后面，两个指针同时向中间移动，并交换元素</strong>。</p><p>以字符串 <code>hello</code> 为例，过程如下：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/008eGmZEly1gp0fvi91pfg30de0akwnq.gif" alt="344.反转字符串"></p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 双指针法</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">reverseString</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 指向头</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">int</span> right <span class="token operator">=</span> s<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 指向尾</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> left <span class="token operator">&lt;</span> right<span class="token punctuation">;</span> left<span class="token operator">++</span><span class="token punctuation">,</span> right<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 交换</span></pre></td></tr><tr><td data-num="7"></td><td><pre>            <span class="token keyword">char</span> temp <span class="token operator">=</span> s<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>            s<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">=</span> s<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>            s<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>交换的两种实现方式</p><ul><li>交换数值</li></ul><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">char</span> temp <span class="token operator">=</span> s<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>s<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">=</span> s<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>s<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span></pre></td></tr></table></figure><ul><li>位运算</li></ul><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre>s<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">^=</span> s<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 这里的 ^ 是异或运算，相同为 0，不同为 1。</span></pre></td></tr><tr><td data-num="2"></td><td><pre>s<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">^=</span> s<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>s<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">^=</span> s<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h3 id="541-反转字符串-ii"><a class="anchor" href="#541-反转字符串-ii">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yZXZlcnNlLXN0cmluZy1paS8=">541. 反转字符串 II</span></h3><blockquote><p>简单的反转还不够，我要花式反转</p></blockquote><p>这道题目其实也是模拟，实现题目中规定的反转规则就可以了。</p><p>一些同学可能为了处理逻辑：每隔 2k 个字符的前 k 的字符，写了一堆逻辑代码或者再搞一个计数器，来统计 2k，再统计前 k 个字符。</p><p>其实在遍历字符串的过程中，只要让 ** <code>i += (2 * k)</code> **，i 每次移动 2 * k 就可以了，然后判断是否需要有反转的区间。</p><p>因为要找的也就是每 2 * k 区间的起点，这样写，程序会高效很多。</p><p><strong>所以当需要固定规律一段一段去处理字符串的时候，要想想在在 for 循环的表达式上做做文章。</strong></p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">reverseStr</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">+=</span> <span class="token number">2</span> <span class="token operator">*</span> k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>            <span class="token comment">// 1. 每隔 2k 个字符的前 k 个字符进行反转 [i,i+k)</span></pre></td></tr><tr><td data-num="5"></td><td><pre>            <span class="token comment">// 2. 剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符   [i,i+k)</span></pre></td></tr><tr><td data-num="6"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">+</span> k <span class="token operator">&lt;=</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>                s <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> i <span class="token operator">+</span> k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> s<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>i <span class="token operator">+</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>                <span class="token comment">// 3. 剩余字符少于 k 个，则将剩余字符全部反转 [i,s.length ())</span></pre></td></tr><tr><td data-num="10"></td><td><pre>                s <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token keyword">return</span> s<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">reverseStr</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">+=</span> <span class="token number">2</span> <span class="token operator">*</span> k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>            <span class="token comment">// 1. 每隔 2k 个字符的前 k 个字符进行反转 [i,i+k)</span></pre></td></tr><tr><td data-num="5"></td><td><pre>            <span class="token comment">// 2. 剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符   [i,i+k)</span></pre></td></tr><tr><td data-num="6"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">+</span> k <span class="token operator">&lt;=</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>                s <span class="token operator">=</span> <span class="token function">reverse</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> i<span class="token punctuation">,</span> i <span class="token operator">+</span> k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>                <span class="token comment">// 3. 剩余字符少于 k 个，则将剩余字符全部反转 [i,s.length ())</span></pre></td></tr><tr><td data-num="10"></td><td><pre>                s <span class="token operator">=</span> <span class="token function">reverse</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> i<span class="token punctuation">,</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token keyword">return</span> s<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token keyword">private</span> <span class="token class-name">String</span> <span class="token function">reverse</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> chars <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> start<span class="token punctuation">,</span> j <span class="token operator">=</span> end<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> j<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">,</span> j<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>            <span class="token keyword">char</span> temp <span class="token operator">=</span> chars<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>            chars<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> chars<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>            chars<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>chars<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="25"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id="剑指-offer-05-替换空格"><a class="anchor" href="#剑指-offer-05-替换空格">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy90aS1odWFuLWtvbmctZ2UtbGNvZi8=">剑指 Offer 05. 替换空格</span></h3><h4 id="暴力法"><a class="anchor" href="#暴力法">#</a> 暴力法</h4><blockquote><p>粗鄙！太粗鄙了！</p></blockquote><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 暴力法</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">replaceSpace</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token class-name">StringBuilder</span> sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token char">' '</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>                sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"%20"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>                sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token keyword">return</span> sb<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><ul><li>时间复杂度：O (n^2)</li><li>空间复杂度：O (n)</li></ul><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20221212103839226.png" alt="image-20221212103839226"></p><h4 id="双指针法-4"><a class="anchor" href="#双指针法-4">#</a> 双指针法</h4><p>如果想把这道题目做到极致，就<strong>不要用额外的辅助空间了！</strong></p><p>首先<strong>扩充数组</strong>到每个空格替换成 &quot;%20&quot; 之后的大小。</p><p>然后<strong>从后向前替换</strong>空格，也就是 **<u>双指针法</u>**，过程如下：</p><p><strong>i 指向新长度的末尾，j 指向旧长度的末尾</strong>。</p><p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1go6qmevhgpg20du09m4qp.gif" alt="替换空格"></p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 双指针法，从后往前填充，时间复杂度 O (n)，空间复杂度 O (1)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">replaceSpace</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token comment">// 统计空格数</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token char">' '</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>                count<span class="token operator">++</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token comment">// 扩充字符串</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> chars <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">char</span><span class="token punctuation">[</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> count <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token comment">// 双指针，从后往前填充</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token keyword">int</span> i <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 指向旧字符串的尾</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token keyword">int</span> j <span class="token operator">=</span> chars<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 指向新字符串的尾</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token char">' '</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>                chars<span class="token punctuation">[</span>j<span class="token operator">--</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'0'</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>                chars<span class="token punctuation">[</span>j<span class="token operator">--</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'2'</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>                chars<span class="token punctuation">[</span>j<span class="token operator">--</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'%'</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>                chars<span class="token punctuation">[</span>j<span class="token operator">--</span><span class="token punctuation">]</span> <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>chars<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="27"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><ul><li>时间复杂度：O (n)</li><li>空间复杂度：O (n)</li></ul><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20221212103802214.png" alt="image-20221212103802214"></p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 双指针法，从后往前填充，时间复杂度 O (n)，空间复杂度 O (1)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token comment">// 方式二：双指针法</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">replaceSpace</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token comment">// 特判：空串</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>            <span class="token keyword">return</span> s<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token comment">// 扩充的额外空间：空格数量的 2 倍</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token class-name">StringBuilder</span> sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token char">' '</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>                sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"  "</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token comment">// 特判：非空串，但没有空格直接返回</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>sb<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>            <span class="token keyword">return</span> s<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>        <span class="token comment">// 有空格情况 定义两个指针</span></pre></td></tr><tr><td data-num="21"></td><td><pre>        <span class="token keyword">int</span> left <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">// 左指针：指向旧字符串最后一个位置</span></pre></td></tr><tr><td data-num="22"></td><td><pre>        s <span class="token operator">+=</span> sb<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 扩充字符串</span></pre></td></tr><tr><td data-num="23"></td><td><pre>        <span class="token keyword">int</span> right <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">// 右指针：指向新字符串的最后一个位置</span></pre></td></tr><tr><td data-num="24"></td><td><pre>        <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> chars <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> left <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> left<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>chars<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">' '</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>                chars<span class="token punctuation">[</span>right<span class="token operator">--</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'0'</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>                chars<span class="token punctuation">[</span>right<span class="token operator">--</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'2'</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>                chars<span class="token punctuation">[</span>right<span class="token operator">--</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'%'</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="31"></td><td><pre>                chars<span class="token punctuation">[</span>right<span class="token operator">--</span><span class="token punctuation">]</span> <span class="token operator">=</span> chars<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="33"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="34"></td><td><pre>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>chars<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="35"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="36"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>有同学问了，为什么要从后向前填充，从前向后填充不行么？</p><p><strong>从前向后填充就是 O (n^2) 的算法了，因为每次添加元素都要将添加元素之后的所有元素向后移动</strong>。</p><p><strong>其实很多数组填充类的问题，都可以先预先给数组扩容带填充后的大小，然后在从后向前进行操作。</strong></p><p>这么做有两个好处：</p><ol><li>不用申请新数组。</li><li>从后向前填充元素，避免了从前向后填充元素时，每次添加元素都要将添加元素之后的所有元素向后移动的问题。</li></ol><p>时间复杂度，空间复杂度均超过 100% 的用户。</p><h3 id="151-反转字符串中的单词"><a class="anchor" href="#151-反转字符串中的单词">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yZXZlcnNlLXdvcmRzLWluLWEtc3RyaW5nLw==">151. 反转字符串中的单词</span></h3><blockquote><p>综合考察字符串操作的好题。</p></blockquote><p>提高一下本题的难度：<strong>不要使用辅助空间，空间复杂度要求为 O (1)。</strong></p><p>不能使用辅助空间之后，那么只能在原字符串上下功夫了。</p><p>想一下，我们将整个字符串都反转过来，那么单词的顺序指定是倒序了，只不过单词本身也倒序了，那么再把单词反转一下，单词不就正过来了。</p><p>举个例子，源字符串为：&quot;the sky is blue&quot;</p><ul><li>移除多余空格 : &quot;the sky is blue&quot;</li><li>字符串反转：&quot;eulb si yks eht&quot;</li><li>单词反转：&quot;blue is sky the&quot;</li></ul><p>所以<strong>解题思路</strong>如下：</p><ul><li><p>移除多余空格</p><blockquote><p>这部分和<span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVyY2FybC5jb20vMDAyNy4lRTclQTclQkIlRTklOTklQTQlRTUlODUlODMlRTclQjQlQTAuaHRtbA=="> 27. 移除元素</span>使用<strong>双指针法</strong>的逻辑是一样一样的，本题是移除空格，而 27. 移除元素 就是移除元素。</p><p>可以做到 O (n) 的时间复杂度。</p></blockquote><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 双指针（快慢指针），移除多余空格</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">removeExtraSpace</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> chars<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 去除所有空格，并在相邻单词间添加空格</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">int</span> slow <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">int</span> fast <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> fast <span class="token operator">&lt;</span> chars<span class="token punctuation">.</span>length<span class="token punctuation">;</span> fast<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>chars<span class="token punctuation">[</span>fast<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token char">' '</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 遇到非空格字符，将其复制到 slow 指针的位置</span></pre></td></tr><tr><td data-num="7"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>slow <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// 当前 slow 指针不在字符串开头，说明前面已经有字符了，此时需要添加空格，作为单词间的分隔</span></pre></td></tr><tr><td data-num="8"></td><td><pre>                chars<span class="token punctuation">[</span>slow<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">' '</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>            <span class="token keyword">while</span> <span class="token punctuation">(</span>fast <span class="token operator">&lt;</span> chars<span class="token punctuation">.</span>length <span class="token operator">&amp;&amp;</span> chars<span class="token punctuation">[</span>fast<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token char">' '</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 复制连续的非空格字符，直到遇到空格</span></pre></td></tr><tr><td data-num="10"></td><td><pre>                chars<span class="token punctuation">[</span>slow<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> chars<span class="token punctuation">[</span>fast<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token keyword">return</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">copyOfRange</span><span class="token punctuation">(</span>chars<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> slow<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//slow 指针指向最后一个非空格字符的后一个位置 [0, slow)</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure></li><li><p>将整个字符串反转</p><blockquote><p>可参考 [344. 反转字符串]，采用双指针法，一个从字符串前面，一个从字符串后面，两个指针同时向中间移动，并交换元素。</p></blockquote><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 双指针法，反转字符串 s 中的 [start, end] 区间的字符</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">reverse</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> chars<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> start<span class="token punctuation">,</span> j <span class="token operator">=</span> end<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> j<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">,</span> j<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 交换区间 [start,end] 两端的字符</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token keyword">char</span> temp <span class="token operator">=</span> chars<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        chars<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> chars<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        chars<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure></li><li><p>将每个单词反转</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 双指针法，反转单词</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">reverseEachWord</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> chars<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">int</span> start <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 因为 chars 已去除多余空格，所以 0 位置一定是单词的开头</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">int</span> end <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> end <span class="token operator">&lt;=</span> chars<span class="token punctuation">.</span>length<span class="token punctuation">;</span> end<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>end <span class="token operator">==</span> chars<span class="token punctuation">.</span>length <span class="token operator">||</span> chars<span class="token punctuation">[</span>end<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">' '</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 遇到空格，或者到达字符串末尾，说明当前单词结束</span></pre></td></tr><tr><td data-num="7"></td><td><pre>            <span class="token function">reverse</span><span class="token punctuation">(</span>chars<span class="token punctuation">,</span> start<span class="token punctuation">,</span> end <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 反转 [start, end - 1] 区间的字符</span></pre></td></tr><tr><td data-num="8"></td><td><pre>            start <span class="token operator">=</span> end <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 下一个单词的开始位置</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure></li></ul><p>完整代码如下：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 双指针（快慢指针），移除多余空格</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">removeExtraSpace</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> chars<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 去除所有空格，并在相邻单词间添加空格</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token keyword">int</span> slow <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">int</span> fast <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> fast <span class="token operator">&lt;</span> chars<span class="token punctuation">.</span>length<span class="token punctuation">;</span> fast<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>chars<span class="token punctuation">[</span>fast<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token char">' '</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 遇到非空格字符，将其复制到 slow 指针的位置</span></pre></td></tr><tr><td data-num="8"></td><td><pre>                <span class="token keyword">if</span> <span class="token punctuation">(</span>slow <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// 当前 slow 指针不在字符串开头，说明前面已经有字符了，此时需要添加空格，作为单词间的分隔</span></pre></td></tr><tr><td data-num="9"></td><td><pre>                    chars<span class="token punctuation">[</span>slow<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">' '</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>                <span class="token keyword">while</span> <span class="token punctuation">(</span>fast <span class="token operator">&lt;</span> chars<span class="token punctuation">.</span>length <span class="token operator">&amp;&amp;</span> chars<span class="token punctuation">[</span>fast<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token char">' '</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 复制连续的非空格字符，直到遇到空格</span></pre></td></tr><tr><td data-num="11"></td><td><pre>                    chars<span class="token punctuation">[</span>slow<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> chars<span class="token punctuation">[</span>fast<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>                <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token keyword">return</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">copyOfRange</span><span class="token punctuation">(</span>chars<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> slow<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//slow 指针指向最后一个非空格字符的后一个位置 [0, slow)</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="17"></td><td><pre></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token comment">// 双指针法，反转字符串 s 中的 [start, end] 区间的字符</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">reverse</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> chars<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> start<span class="token punctuation">,</span> j <span class="token operator">=</span> end<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> j<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">,</span> j<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 交换区间 [start,end] 两端的字符</span></pre></td></tr><tr><td data-num="21"></td><td><pre>            <span class="token keyword">char</span> temp <span class="token operator">=</span> chars<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>            chars<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> chars<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>            chars<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="26"></td><td><pre></pre></td></tr><tr><td data-num="27"></td><td><pre>    <span class="token comment">// 双指针法，反转单词</span></pre></td></tr><tr><td data-num="28"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">reverseEachWord</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> chars<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>        <span class="token keyword">int</span> start <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 因为 chars 已去除多余空格，所以 0 位置一定是单词的开头</span></pre></td></tr><tr><td data-num="30"></td><td><pre>        <span class="token keyword">int</span> end <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="31"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> end <span class="token operator">&lt;=</span> chars<span class="token punctuation">.</span>length<span class="token punctuation">;</span> end<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>end <span class="token operator">==</span> chars<span class="token punctuation">.</span>length <span class="token operator">||</span> chars<span class="token punctuation">[</span>end<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">' '</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 遇到空格，或者到达字符串末尾，说明当前单词结束</span></pre></td></tr><tr><td data-num="33"></td><td><pre>                <span class="token function">reverse</span><span class="token punctuation">(</span>chars<span class="token punctuation">,</span> start<span class="token punctuation">,</span> end <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 反转 [start, end - 1] 区间的字符</span></pre></td></tr><tr><td data-num="34"></td><td><pre>                start <span class="token operator">=</span> end <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 下一个单词的开始位置</span></pre></td></tr><tr><td data-num="35"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="36"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="37"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="38"></td><td><pre></pre></td></tr><tr><td data-num="39"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">reverseWords</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="40"></td><td><pre>        <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> chars <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="41"></td><td><pre></pre></td></tr><tr><td data-num="42"></td><td><pre>        <span class="token comment">// 去除多余空格</span></pre></td></tr><tr><td data-num="43"></td><td><pre>        chars <span class="token operator">=</span> <span class="token function">removeExtraSpace</span><span class="token punctuation">(</span>chars<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="44"></td><td><pre>        <span class="token comment">// 反转整个字符串</span></pre></td></tr><tr><td data-num="45"></td><td><pre>        <span class="token function">reverse</span><span class="token punctuation">(</span>chars<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> chars<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="46"></td><td><pre>        <span class="token comment">// 反转每个单词</span></pre></td></tr><tr><td data-num="47"></td><td><pre>        <span class="token function">reverseEachWord</span><span class="token punctuation">(</span>chars<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="48"></td><td><pre></pre></td></tr><tr><td data-num="49"></td><td><pre>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>chars<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="50"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="51"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20221212121635803.png" alt="image-20221212121635803"></p><h3 id="剑指-offer-58-ii-左旋转字符串"><a class="anchor" href="#剑指-offer-58-ii-左旋转字符串">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy96dW8teHVhbi16aHVhbi16aS1mdS1jaHVhbi1sY29mLw==">剑指 Offer 58 - II. 左旋转字符串</span></h3><blockquote><p>反转个字符串还有这么多用处？</p></blockquote><p>为了让本题更有意义，提升一下本题难度：<strong>不能申请额外空间，只能在本串上操作</strong>。</p><p>不能使用额外空间的话，模拟在本串操作要实现左旋转字符串的功能还是有点困难的。</p><p>那么我们可以想一下上一题目<span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVyY2FybC5jb20vMDE1MS4lRTclQkYlQkIlRTglQkQlQUMlRTUlQUQlOTclRTclQUMlQTYlRTQlQjglQjIlRTklODclOEMlRTclOUElODQlRTUlOEQlOTUlRTglQUYlOEQuaHRtbA==">字符串：花式反转还不够！</span>中讲过，使用整体反转 + 局部反转就可以实现反转单词顺序的目的。</p><p>这道题目也非常类似，依然可以通过<strong>局部反转 + 整体反转</strong> 达到左旋转的目的。</p><p>具体步骤为：</p><ol><li><strong>反转区间为前 n 的子串</strong></li><li><strong>反转区间为 n 到末尾的子串</strong></li><li><strong>反转整个字符串</strong></li></ol><p>最后就可以达到左旋 n 的目的，而不用定义新的字符串，完全在本串上操作。</p><p>例如 ：示例 1 中 输入：字符串 abcdefg，n=2</p><p>如图：</p><p><img data-src="https://code-thinking.cdn.bcebos.com/pics/%E5%89%91%E6%8C%87Offer58-II.%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2.png" alt="img"></p><p>最终得到左旋 2 个单元的字符串：cdefgab</p><p>思路明确之后，那么代码实现就很简单了</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">reverseLeftWords</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> chars <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token comment">// 反转 [0,n) 区间的字符</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token function">reverse</span><span class="token punctuation">(</span>chars<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token comment">// 反转 [n,s.length) 区间的字符</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token function">reverse</span><span class="token punctuation">(</span>chars<span class="token punctuation">,</span> n<span class="token punctuation">,</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token comment">// 反转整个字符串</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token function">reverse</span><span class="token punctuation">(</span>chars<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>chars<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">reverse</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> chars<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token keyword">while</span> <span class="token punctuation">(</span>start <span class="token operator">&lt;</span> end<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>            <span class="token keyword">char</span> temp <span class="token operator">=</span> chars<span class="token punctuation">[</span>start<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>            chars<span class="token punctuation">[</span>start<span class="token punctuation">]</span> <span class="token operator">=</span> chars<span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>            chars<span class="token punctuation">[</span>end<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>            start<span class="token operator">++</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>            end<span class="token operator">--</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="22"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id="28-找出字符串中第一个匹配项的下标实现strstr"><a class="anchor" href="#28-找出字符串中第一个匹配项的下标实现strstr">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9maW5kLXRoZS1pbmRleC1vZi10aGUtZmlyc3Qtb2NjdXJyZW5jZS1pbi1hLXN0cmluZy8=">28. 找出字符串中第一个匹配项的下标：实现 strStr ()</span></h3><blockquote><p>在一个串中查找是否出现过另一个串，称为<strong>字符串的模式匹配</strong>，这是<strong> KMP</strong> 的看家本领。</p></blockquote><h4 id="kmp有什么用"><a class="anchor" href="#kmp有什么用">#</a> KMP 有什么用</h4><p>KMP 主要应用在<strong>字符串的模式匹配</strong>上。</p><p>KMP 的主要思想是<strong>当出现字符串不匹配时，可以知道一部分之前已经匹配的文本内容，可以利用这些信息避免从头再去做匹配了。</strong></p><p>所以<strong>如何记录已经匹配的文本内容</strong>，是 KMP 的重点，也是<strong> next 数组</strong>肩负的重任。</p><h4 id="什么是前缀表"><a class="anchor" href="#什么是前缀表">#</a> 什么是前缀表</h4><p>写过 KMP 的同学，一定都写过 next 数组，那么这个 next 数组究竟是个啥呢？</p><p><strong>next 数组就是一个前缀表（prefix table）</strong>。</p><p>前缀表有什么作用呢？</p><p><strong>前缀表是用来回退的，它记录了模式串与主串 (文本串) 不匹配的时候，<u>模式串应该从哪里开始重新匹配</u>。</strong></p><p>为了清楚地了解前缀表的来历，我们来举一个例子：</p><p>要在 <code>文本串</code> ：aabaabaafa 中查找是否出现过一个 <code>模式串</code> ：aabaaf。</p><p>如动画所示：</p><p><img data-src="https://code-thinking.cdn.bcebos.com/gifs/KMP%E7%B2%BE%E8%AE%B21.gif" alt="KMP详解1"></p><p>动画里，我特意把 子串 <code>aa</code> 标记上了，这是有原因的，大家先注意一下，后面还会说到。</p><p>可以看出，文本串中第六个字符 b 和 模式串的第六个字符 f，不匹配了。如果暴力匹配，发现不匹配，此时就要从头匹配了。</p><p>但如果使用前缀表，就不会从头匹配，而是从上次已经匹配的内容开始匹配，找到了模式串中第三个字符 b 继续开始匹配。</p><p>此时就要问了<strong>前缀表是如何记录的呢？</strong></p><p>首先要知道<strong>前缀表的任务是：当前位置匹配失败，找到之前已经匹配上的位置，再重新匹配，此也意味着在某个字符失配时，前缀表会告诉你下一步匹配中，模式串应该跳到哪个位置</strong>。</p><p>那么什么是前缀表：<strong>记录下标 i 之前（包括 i）的字符串中，有多大长度的相同前缀后缀。</strong></p><h4 id="最长u公共u前后缀-or-最长u相等u前后缀"><a class="anchor" href="#最长u公共u前后缀-or-最长u相等u前后缀">#</a> 最长<u>公共</u>前后缀 or 最长<u>相等</u>前后缀</h4><p>文章中字符串的<strong>前缀是指不包含最后一个字符的所有以第一个字符开头的连续子串</strong>。</p><p><strong>后缀是指不包含第一个字符的所有以最后一个字符结尾的连续子串</strong>。</p><p><strong>正确理解什么是前缀什么是后缀很重要</strong>！</p><p>那么网上清一色都说 “kmp 最长公共前后缀” 又是什么回事呢？</p><p>我查了一遍 算法导论 和 算法 4 里 KMP 的章节，都没有提到 “最长公共前后缀” 这个词，也不知道从哪里来了，我理解是用 “<strong>最长相等前后缀</strong>” 更准确一些。</p><p><strong>因为前缀表要求的就是相同前后缀的长度。</strong></p><p>而最长公共前后缀里面的 “公共”，更像是说前缀和后缀公共的长度。这其实并不是前缀表所需要的。</p><p>所以字符串 a 的最长相等前后缀为 0。 字符串 aa 的最长相等前后缀为 1。 字符串 aaa 的最长相等前后缀为 2。 等等.....。</p><h4 id="为什么一定要用前缀表"><a class="anchor" href="#为什么一定要用前缀表">#</a> 为什么一定要用前缀表</h4><p>这就是前缀表，那为啥就能告诉我们 上次匹配的位置，并跳过去呢？</p><p>回顾一下，刚刚匹配的过程在下标 5 的地方遇到不匹配，模式串是指向 f，如图：</p><p><img data-src="https://code-thinking.cdn.bcebos.com/pics/KMP%E7%B2%BE%E8%AE%B21.png" alt="KMP精讲1"></p><p>然后就找到了下标 2，指向 b，继续匹配：如图：</p><p><img data-src="https://code-thinking.cdn.bcebos.com/pics/KMP%E7%B2%BE%E8%AE%B22.png" alt="KMP精讲2"></p><p>以下这句话，对于理解为什么使用前缀表可以告诉我们匹配失败之后跳到哪里重新匹配 非常重要！</p><p><strong>下标 5 之前这部分的字符串（也就是字符串 aabaa）的最长相等的前缀 和 后缀字符串是 子字符串 aa ，因为找到了最长相等的前缀和后缀，匹配失败的位置是后缀子串的后面，那么我们找到与其相同的前缀的后面重新匹配就可以了。</strong></p><p>所以前缀表具有告诉我们当前位置匹配失败，跳到之前已经匹配过的地方的能力。</p><p><strong>很多介绍 KMP 的文章或者视频并没有把为什么要用前缀表？这个问题说清楚，而是直接默认使用前缀表。</strong></p><h4 id="如何计算前缀表"><a class="anchor" href="#如何计算前缀表">#</a> 如何计算前缀表</h4><p>接下来就要说一说怎么计算前缀表。</p><p>如图：</p><p><img data-src="https://code-thinking.cdn.bcebos.com/pics/KMP%E7%B2%BE%E8%AE%B25.png" alt="KMP精讲5"></p><p>长度为前 1 个字符的子串 <code>a</code> ，最长相同前后缀的长度为 0。（注意字符串的<strong>前缀是指不包含最后一个字符的所有以第一个字符开头的连续子串</strong>；<strong>后缀是指不包含第一个字符的所有以最后一个字符结尾的连续子串</strong>。）</p><p><img data-src="https://code-thinking.cdn.bcebos.com/pics/KMP%E7%B2%BE%E8%AE%B26.png" alt="KMP精讲6"></p><p>长度为前 2 个字符的子串 <code>aa</code> ，最长相同前后缀的长度为 1。</p><p><img data-src="https://code-thinking.cdn.bcebos.com/pics/KMP%E7%B2%BE%E8%AE%B27.png" alt="KMP精讲7"></p><p>长度为前 3 个字符的子串 <code>aab</code> ，最长相同前后缀的长度为 0。</p><p>以此类推： 长度为前 4 个字符的子串 <code>aaba</code> ，最长相同前后缀的长度为 1。 长度为前 5 个字符的子串 <code>aabaa</code> ，最长相同前后缀的长度为 2。 长度为前 6 个字符的子串 <code>aabaaf</code> ，最长相同前后缀的长度为 0。</p><p>那么把求得的<strong>最长相同前后缀的长度就是对应前缀表的元素</strong>，如图：</p><p><img data-src="https://code-thinking.cdn.bcebos.com/pics/KMP%E7%B2%BE%E8%AE%B28.png" alt="KMP精讲8"></p><p>可以看出模式串与前缀表对应位置的数字表示的就是：<strong>下标 i 之前（包括 i）的字符串中，有多大长度的相同前缀后缀。</strong></p><p>再来看一下如何利用 前缀表找到 当字符不匹配的时候应该指针应该移动的位置。如动画所示：</p><p><img data-src="https://code-thinking.cdn.bcebos.com/gifs/KMP%E7%B2%BE%E8%AE%B22.gif" alt="KMP精讲2"></p><p><strong>找到的不匹配的位置， 那么此时我们要看它的前一个字符的前缀表的数值是多少</strong>。</p><p>为什么要前一个字符的前缀表的数值呢，因为要找前面字符串的最长相同的前缀和后缀。</p><p>所以要看前一位的 前缀表的数值。</p><p>前一个字符的前缀表的数值是 2， 所以<strong>把下标移动到数值对应的位置继续比配</strong>。 可以再反复看一下上面的动画。</p><p>最后就在文本串中找到了和模式串匹配的子串了</p><h4 id="前缀表与next数组"><a class="anchor" href="#前缀表与next数组">#</a> 前缀表与 next 数组</h4><p>很多 KMP 算法的时间都是使用 next 数组来做回退操作，那么 next 数组与前缀表有什么关系呢？</p><p>next 数组就可以是前缀表，但是很多实现都是把前缀表统一减一（右移一位，初始位置为 - 1）之后作为 next 数组。</p><p>为什么这么做呢，其实也是很多文章视频没有解释清楚的地方。</p><p>其实<strong>这并不涉及到 KMP 的原理，而是具体实现，next 数组既可以就是前缀表，也可以是前缀表统一减一（右移一位，初始位置为 - 1）。</strong></p><p>后面我会提供两种不同的实现代码，大家就明白了。</p><h4 id="使用next数组来匹配"><a class="anchor" href="#使用next数组来匹配">#</a> 使用 next 数组来匹配</h4><p><strong>以下我们以<u>前缀表统一减一</u>之后的 next 数组来做演示</strong>。</p><p>有了 next 数组，就可以根据 next 数组来 匹配文本串 s，和模式串 t 了。</p><p>匹配过程动画如下：</p><p><img data-src="https://code-thinking.cdn.bcebos.com/gifs/KMP%E7%B2%BE%E8%AE%B24.gif" alt="KMP精讲4"></p><h4 id="时间复杂度分析"><a class="anchor" href="#时间复杂度分析">#</a> 时间复杂度分析</h4><p>其中 n 为文本串长度，m 为模式串长度，因为在匹配的过程中，根据前缀表不断调整匹配的位置，可以看出<strong>匹配的过程是 O (n)</strong>，之前还要<strong>单独生成 next 数组，时间复杂度是 O (m)</strong>。所以 ** 整个 KMP 算法的时间复杂度是 O (n+m)** 的。</p><p>暴力的解法显而易见是 O (n × m)，所以<strong> KMP 在字符串匹配中极大地提高了搜索的效率。</strong></p><p>为了和力扣题目 28. 实现 strStr 保持一致，方便大家理解，<u>以下文章统称 haystack 为文本串，needle 为模式串</u>。</p><p>都知道使用 KMP 算法，一定要构造 next 数组。</p><h4 id="构造next数组"><a class="anchor" href="#构造next数组">#</a> 构造 next 数组？</h4><p>我们定义一个函数 getNext 来构建 next 数组，函数参数为指向 next 数组的指针，和一个字符串。 代码如下：</p><pre><code class="language-c++">void getNext(int* next, const string&amp; s)
</code></pre><p><strong>构造 next 数组其实就是计算模式串 s，前缀表的过程。</strong> 主要有如下三步：</p><ol><li>初始化</li><li>处理前后缀不相同的情况</li><li>处理前后缀相同的情况</li></ol><p>接下来我们详解一下。</p><h5 id="1-初始化"><a class="anchor" href="#1-初始化">#</a> 1. 初始化</h5><p>定义两个指针 i 和 j，<strong>j 指向前缀末尾位置，i 指向后缀末尾位置</strong>。</p><p>然后还要<strong>对 next 数组进行初始化赋值</strong>，如下：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>next<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> j<span class="token punctuation">;</span></pre></td></tr></table></figure><p>j 为什么要初始化为 -1 呢，因为之前说过 前缀表要统一减一的操作仅仅是其中的一种实现，我们这里选择 j 初始化为 - 1，下文我还会给出 j 不初始化为 - 1 的实现代码。</p><p><strong>next [i] 表示 i（包括 i）之前最长相等的前后缀长度（其实就是 j）</strong></p><p>所以初始化 next [0] = j 。</p><h5 id="2-处理前后缀不相同的情况"><a class="anchor" href="#2-处理前后缀不相同的情况">#</a> 2. 处理前后缀不相同的情况</h5><p>因为 j 初始化为 - 1，那么 i 就从 1 开始，进行 s [i] 与 s [j+1] 的比较。</p><p>所以<strong>遍历模式串 s 的循环下标 i 要从 1 开始</strong>，代码如下：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr></table></figure><p>如果 s [i] 与 s [j+1] 不相同，也就是遇到 前后缀末尾不相同的情况，就要向前回退。</p><p>怎么回退呢？</p><p>next [j] 就是记录着 j（包括 j）之前的子串的相同前后缀的长度。</p><p>那么 s [i] 与 s [j+1] 不相同，就要找 j+1 前一个元素在 next 数组里的值（就是 next [j]）。</p><p>所以，处理前后缀不相同的情况代码如下：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> s<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 前后缀不相同了</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    j <span class="token operator">=</span> next<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 向前回退</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h5 id="3-处理前后缀相同的情况"><a class="anchor" href="#3-处理前后缀相同的情况">#</a> 3. 处理前后缀相同的情况</h5><p>如果 s [i] 与 s [j + 1] 相同，那么就同时向后移动 i 和 j 说明找到了相同的前后缀，同时还要将 j（前缀的长度）赋给 next [i], 因为 next [i] 要记录相同前后缀的长度。</p><p>代码如下：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> s<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 找到相同的前后缀</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    j<span class="token operator">++</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>next<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> j<span class="token punctuation">;</span></pre></td></tr></table></figure><p>最后整体构建 next 数组的函数代码如下：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">void</span> <span class="token function">getNext</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> next<span class="token punctuation">,</span> <span class="token keyword">const</span> string<span class="token operator">&amp;</span> s<span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 指向前缀的末尾位置，也可以理解为 “最长相等前后缀的长度”</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    next<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> j<span class="token punctuation">;</span> <span class="token comment">// 模式串中第一个字符无前、后缀，故 “最长相等前后缀长度” 为 0，又因采用 “前缀表统一减一” 的策略，故初始化为 - 1，这也是 j 初始化为 - 1 的原因</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">//i 指向后缀的末尾位置，从 1 开始</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> s<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 前后缀不相同了</span></pre></td></tr><tr><td data-num="6"></td><td><pre>            j <span class="token operator">=</span> next<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 向前回退</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> s<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 找到相同的前后缀</span></pre></td></tr><tr><td data-num="9"></td><td><pre>            j<span class="token operator">++</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        next<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> j<span class="token punctuation">;</span> <span class="token comment">// 将 j（前缀的长度）赋给 next [i]</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>代码构造 next 数组的逻辑流程动画如下：</p><p><img data-src="https://code-thinking.cdn.bcebos.com/gifs/KMP%E7%B2%BE%E8%AE%B23.gif" alt="KMP精讲3"></p><p>得到了 next 数组之后，就要用这个来做匹配了。</p><h4 id="使用next数组来做匹配"><a class="anchor" href="#使用next数组来做匹配">#</a> 使用 next 数组来做匹配</h4><p>在文本串 s 里 找是否出现过模式串 t。</p><p>定义两个下标<strong> j 指向模式串起始位置，i 指向文本串起始位置</strong>。</p><p>那么<strong> j 初始值依然为 - 1</strong>，为什么呢？ <strong>依然因为 next 数组里记录的起始位置为 - 1。</strong></p><p>i 就从 0 开始，遍历文本串，代码如下：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span></pre></td></tr></table></figure><p>接下来就是 s [i] 与 t [j + 1] （因为 j 从 - 1 开始的） 进行比较。</p><p>如果 s [i] 与 t [j + 1] 不相同，j 就要从 next 数组里寻找下一个匹配的位置。</p><p>代码如下：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">while</span><span class="token punctuation">(</span>j <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> t<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    j <span class="token operator">=</span> next<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>如果 s [i] 与 t [j + 1] 相同，那么 i 和 j 同时向后移动， 代码如下：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> t<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    j<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">//i 的增加在 for 循环里</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>如何判断在文本串 s 里出现了模式串 t 呢，<strong>如果 j 指向了模式串 t 的末尾，那么就说明模式串 t 完全匹配文本串 s 里的某个子串了</strong>。</p><p>本题要在文本串字符串中找出模式串出现的第一个位置 (从 0 开始)，所以返回当前在文本串匹配模式串的位置 i 减去 模式串的长度，就是文本串字符串中出现模式串的第一个位置。</p><p>代码如下：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">==</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">return</span> <span class="token punctuation">(</span>i <span class="token operator">-</span> t<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>那么使用 next 数组，用模式串匹配文本串的整体代码如下：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 因为 next 数组里记录的起始位置为 - 1</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 注意 i 就从 0 开始</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">while</span><span class="token punctuation">(</span>j <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> t<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 不匹配</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        j <span class="token operator">=</span> next<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//j 寻找之前匹配的位置</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> t<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 匹配，j 和 i 同时向后移动</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        j<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">//i 的增加在 for 循环里</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">==</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 文本串 s 里出现了模式串 t</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token keyword">return</span> <span class="token punctuation">(</span>i <span class="token operator">-</span> t<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>此时所有逻辑的代码都已经写出来了，力扣 28. 实现 strStr 题目的整体代码如下：</p><h4 id="前缀表统一减一-c代码实现"><a class="anchor" href="#前缀表统一减一-c代码实现">#</a> 前缀表统一减一 C++ 代码实现</h4><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">void</span> <span class="token function">getNext</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> next<span class="token punctuation">,</span> <span class="token keyword">const</span> string<span class="token operator">&amp;</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        next<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> j<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 注意 i 从 1 开始</span></pre></td></tr><tr><td data-num="7"></td><td><pre>            <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> s<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 前后缀不相同了</span></pre></td></tr><tr><td data-num="8"></td><td><pre>                j <span class="token operator">=</span> next<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 向前回退</span></pre></td></tr><tr><td data-num="9"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> s<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 找到相同的前后缀</span></pre></td></tr><tr><td data-num="11"></td><td><pre>                j<span class="token operator">++</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>            next<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> j<span class="token punctuation">;</span> <span class="token comment">// 将 j（前缀的长度）赋给 next [i]</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token keyword">int</span> <span class="token function">strStr</span><span class="token punctuation">(</span>string haystack<span class="token punctuation">,</span> string needle<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>needle<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>        <span class="token keyword">int</span> next<span class="token punctuation">[</span>needle<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>        <span class="token function">getNext</span><span class="token punctuation">(</span>next<span class="token punctuation">,</span> needle<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>        <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">//// 因为 next 数组里记录的起始位置为 - 1</span></pre></td></tr><tr><td data-num="23"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> haystack<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 注意 i 就从 0 开始</span></pre></td></tr><tr><td data-num="24"></td><td><pre>            <span class="token keyword">while</span><span class="token punctuation">(</span>j <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> haystack<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> needle<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 不匹配</span></pre></td></tr><tr><td data-num="25"></td><td><pre>                j <span class="token operator">=</span> next<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//j 寻找之前匹配的位置</span></pre></td></tr><tr><td data-num="26"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>haystack<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> needle<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 匹配，j 和 i 同时向后移动</span></pre></td></tr><tr><td data-num="28"></td><td><pre>                j<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">//i 的增加在 for 循环里</span></pre></td></tr><tr><td data-num="29"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">==</span> <span class="token punctuation">(</span>needle<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 文本串 s 里出现了模式串 t</span></pre></td></tr><tr><td data-num="31"></td><td><pre>                <span class="token keyword">return</span> <span class="token punctuation">(</span>i <span class="token operator">-</span> needle<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="33"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="34"></td><td><pre>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="35"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="36"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h4 id="前缀表不减一c实现"><a class="anchor" href="#前缀表不减一c实现">#</a> 前缀表（不减一）C++ 实现</h4><p>那么前缀表就不减一了，也不右移的，到底行不行呢？</p><p><strong>行！</strong></p><p>我之前说过，这仅仅是 KMP 算法实现上的问题，<strong>如果就直接使用前缀表可以换一种回退方式，找 <code>j=next[j-1]</code> 来进行回退</strong>。</p><p>主要就是 j=next [x] 这一步最为关键！</p><p>我给出的 getNext 的实现为：（前缀表统一减一）</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">void</span> <span class="token function">getNext</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> next<span class="token punctuation">,</span> <span class="token keyword">const</span> string<span class="token operator">&amp;</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    next<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> j<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 注意 i 从 1 开始</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> s<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 前后缀不相同了</span></pre></td></tr><tr><td data-num="6"></td><td><pre>            j <span class="token operator">=</span> next<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 向前回退</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> s<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 找到相同的前后缀</span></pre></td></tr><tr><td data-num="9"></td><td><pre>            j<span class="token operator">++</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        next<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> j<span class="token punctuation">;</span> <span class="token comment">// 将 j（前缀的长度）赋给 next [i]</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>此时如果输入的模式串为 aabaaf，对应的 next 为 - 1 0 -1 0 1 -1。</p><p>这里 j 和 next [0] 初始化为 - 1，整个 next 数组是以 前缀表减一之后的效果来构建的。</p><p>那么前缀表不减一来构建 next 数组，代码如下：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">void</span> <span class="token function">getNext</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> next<span class="token punctuation">,</span> <span class="token keyword">const</span> string<span class="token operator">&amp;</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>        <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        next<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>            <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> s<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">//j 要保证大于 0，因为下面有取 j-1 作为数组下标的操作</span></pre></td></tr><tr><td data-num="6"></td><td><pre>                j <span class="token operator">=</span> next<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 注意这里，是要找前一位的对应的回退位置了</span></pre></td></tr><tr><td data-num="7"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> s<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>                j<span class="token operator">++</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>            next<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> j<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>此时如果输入的模式串为 aabaaf，对应的 next 为 0 1 0 1 2 0，（其实这就是前缀表的数值了）。</p><p>那么用这样的 next 数组也可以用来做匹配，代码要有所改动。</p><p>实现代码如下：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">void</span> <span class="token function">getNext</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> next<span class="token punctuation">,</span> <span class="token keyword">const</span> string<span class="token operator">&amp;</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        next<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>            <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> s<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>                j <span class="token operator">=</span> next<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> s<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>                j<span class="token operator">++</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>            next<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> j<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token keyword">int</span> <span class="token function">strStr</span><span class="token punctuation">(</span>string haystack<span class="token punctuation">,</span> string needle<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>needle<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>        <span class="token keyword">int</span> next<span class="token punctuation">[</span>needle<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>        <span class="token function">getNext</span><span class="token punctuation">(</span>next<span class="token punctuation">,</span> needle<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>        <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> haystack<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>            <span class="token keyword">while</span><span class="token punctuation">(</span>j <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> haystack<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> needle<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>                j <span class="token operator">=</span> next<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>haystack<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> needle<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>                j<span class="token operator">++</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">==</span> needle<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="31"></td><td><pre>                <span class="token keyword">return</span> <span class="token punctuation">(</span>i <span class="token operator">-</span> needle<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="33"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="34"></td><td><pre>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="35"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="36"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>java 代码如下：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// KMP 算法，时间复杂度 O (m+n)，空间复杂度 O (n)</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token comment">// 前缀表（不减一）</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">strStr</span><span class="token punctuation">(</span><span class="token class-name">String</span> haystack<span class="token punctuation">,</span> <span class="token class-name">String</span> needle<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token comment">// 特判：needle 为空串</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>needle<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token comment">// 特判：haystack 长度小于 needle 长度</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>haystack<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> needle<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="10"></td><td><pre>            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token comment">// 构造前缀表，长度与 needle 相同</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>needle<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token function">getNext</span><span class="token punctuation">(</span>next<span class="token punctuation">,</span> needle<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre></pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token comment">// 匹配</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">//i 指向 haystack，j 指向 needle</span></pre></td></tr><tr><td data-num="18"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> haystack<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>            <span class="token comment">// 不匹配，且 j 不为 0，j 回溯，直到 j 为 0 或匹配</span></pre></td></tr><tr><td data-num="20"></td><td><pre>            <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> haystack<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">!=</span> needle<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="21"></td><td><pre>                j <span class="token operator">=</span> next<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>            <span class="token comment">// 匹配，j++</span></pre></td></tr><tr><td data-num="23"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>haystack<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">==</span> needle<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="24"></td><td><pre>                j<span class="token operator">++</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>            <span class="token comment">// 匹配成功，返回下标</span></pre></td></tr><tr><td data-num="26"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">==</span> needle<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="27"></td><td><pre>                <span class="token keyword">return</span> i <span class="token operator">-</span> needle<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="31"></td><td><pre></pre></td></tr><tr><td data-num="32"></td><td><pre>    <span class="token comment">// 构建前缀表</span></pre></td></tr><tr><td data-num="33"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">getNext</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> next<span class="token punctuation">,</span> <span class="token class-name">String</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="34"></td><td><pre>        <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 指向前缀末尾</span></pre></td></tr><tr><td data-num="35"></td><td><pre>        next<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 第一个字符无前缀、后缀，故 “最长相等前后缀” 的长度为 0</span></pre></td></tr><tr><td data-num="36"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 指向后缀末尾，从下标 1 开始</span></pre></td></tr><tr><td data-num="37"></td><td><pre>            <span class="token comment">/* 开始计算 next [i]：即 s [0..i] 的最长相等前后缀的长度，需要匹配前、后缀 */</span></pre></td></tr><tr><td data-num="38"></td><td><pre></pre></td></tr><tr><td data-num="39"></td><td><pre>            <span class="token comment">// 前缀末尾字符与后缀末尾字符不相等时，需要回退</span></pre></td></tr><tr><td data-num="40"></td><td><pre>            <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">!=</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="41"></td><td><pre>                j <span class="token operator">=</span> next<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 回退到前一个字符的最长相等前后缀的长度</span></pre></td></tr><tr><td data-num="42"></td><td><pre></pre></td></tr><tr><td data-num="43"></td><td><pre>            <span class="token comment">// 前缀末尾字符与后缀末尾字符相等时，最长相等前后缀的长度加 1</span></pre></td></tr><tr><td data-num="44"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span> <span class="token operator">==</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="45"></td><td><pre>                j<span class="token operator">++</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="46"></td><td><pre></pre></td></tr><tr><td data-num="47"></td><td><pre>            <span class="token comment">// 记录最长相等前后缀的长度</span></pre></td></tr><tr><td data-num="48"></td><td><pre>            next<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> j<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="49"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="50"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="51"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h4 id="总结-6"><a class="anchor" href="#总结-6">#</a> 总结</h4><p>我们介绍了什么是 KMP，KMP 可以解决什么问题，然后分析 KMP 算法里的 next 数组，知道了 next 数组就是前缀表，再分析为什么要是前缀表而不是什么其他表。</p><p>接着从给出的模式串中，我们一步一步的推导出了前缀表，得出前缀表无论是统一减一还是不减一得到的 next 数组仅仅是 kmp 的实现方式的不同。</p><p>其中还分析了 KMP 算法的时间复杂度，并且和暴力方法做了对比。</p><p>然后先用前缀表统一减一得到的 next 数组，求得文本串 s 里是否出现过模式串 t，并给出了具体分析代码。</p><p>又给出了直接用前缀表作为 next 数组，来做匹配的实现代码。</p><p>可以说把 KMP 的每一个细微的细节都扣了出来，毫无遮掩的展示给大家了！</p><h3 id="459-重复的子字符串"><a class="anchor" href="#459-重复的子字符串">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yZXBlYXRlZC1zdWJzdHJpbmctcGF0dGVybi8=">459. 重复的子字符串</span></h3><blockquote><p>KMP 算法还能干这个</p></blockquote><h4 id="暴力法-2"><a class="anchor" href="#暴力法-2">#</a> 暴力法</h4><p>如果重复的子串存在，其起始位置必定在首字符，因此只需<strong>枚举子串的长度</strong>，即可确定子串，这是外层 for 循环的任务。</p><p>内层 for 循环的任务：判断子串是否能重复构成字符串，</p><ul><li>若有一个字符与当前长度的子串不相等，就枚举下一个长度的子串。若枚举完所有长度的子串均没找到符合条件的子串，返回 false</li><li>若所有字符均与当前长度的子串匹配，就返回 true</li></ul><p>时间复杂度：O (n^2)</p><p>一些细节：</p><ul><li>子串的长度从 1 开始枚举，0 没有意义</li><li>外层 for 循环的判断条件 <code>subLength * 2 &lt;= strLength</code> ，只需要遍历到中间位置，因为子串结束位置大于中间位置的话，一定不能重复组成字符串。符合条件的子串至少要重复两次，否则不符题意</li><li>只有长度能被字符串长度整除的子串才有可能重复组成字符串</li><li>在内层 for 循环判断子串是否能重复构成字符串的过程中，判断条件是 <code>if (s.charAt(i) != s.charAt(i - subLength))</code></li></ul><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 暴力法，时间复杂度 O (n^2)</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">repeatedSubstringPattern</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token keyword">int</span> strLength <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> subLength <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> subLength <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">&lt;=</span> strLength<span class="token punctuation">;</span> subLength<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 枚举子串长度（从 1 开始），要判断 subLength * 2 &lt;= n，即 subLength &lt;= n/2，因为子串长度不能超过字符串长度的一半，否则肯定不符合题意。</span></pre></td></tr><tr><td data-num="6"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>strLength <span class="token operator">%</span> subLength <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 子串长度能整除字符串长度，才有可能重复</span></pre></td></tr><tr><td data-num="7"></td><td><pre>                <span class="token keyword">boolean</span> match <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> subLength<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> strLength<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 从子串的第二个字符开始，与子串的第一个字符比较</span></pre></td></tr><tr><td data-num="9"></td><td><pre>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">!=</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i <span class="token operator">-</span> subLength<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 有一个字符不相等，就不是重复的子串</span></pre></td></tr><tr><td data-num="10"></td><td><pre>                        match <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>                        <span class="token keyword">break</span><span class="token punctuation">;</span> <span class="token comment">// 退出循环，继续枚举子串长度</span></pre></td></tr><tr><td data-num="12"></td><td><pre>                    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>                <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>                <span class="token keyword">if</span> <span class="token punctuation">(</span>match<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>                    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment">// 所有字符都匹配，返回 true</span></pre></td></tr><tr><td data-num="16"></td><td><pre>                <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">// 枚举完所有子串长度，都不符合题意，返回 false</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="21"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20221213115113347.png" alt="image-20221213115113347"></p><h4 id="移动匹配"><a class="anchor" href="#移动匹配">#</a> 移动匹配</h4><p>当一个字符串 s：abcabc，内部由重复的子串组成，那么这个字符串的结构一定是这样的：</p><p><img data-src="https://code-thinking-1253855093.file.myqcloud.com/pics/20220728104518.png" alt="图一"></p><p>也就是由前后相同的子串组成。</p><p>那么既然前面有相同的子串，后面有相同的子串，用 s + s，这样组成的字符串中，后面的子串做前串，前后的子串做后串，就一定还能组成一个 s，如图：</p><p><img data-src="https://code-thinking-1253855093.file.myqcloud.com/pics/20220728104931.png" alt="图二"></p><p>所以判断字符串 s 是否由重复子串组成，只要<strong>两个 s 拼接在一起，里面还出现一个 s 的话，就说明是由重复子串组成</strong>。</p><p>当然，我们在判断 s + s 拼接的字符串里是否出现一个 s 的的时候，<strong>要刨除 s + s 的首字符和尾字符</strong>，这样避免在 s+s 中搜索出原来的 s，我们要搜索的是中间拼接出来的 s。</p><p>代码如下：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 移动匹配：将 s+s 的拼接字符串的首、尾各去掉一个字符，如果 s 在拼接字符串中存在，则说明 s 可以由它的一个子串重复多次构成</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">repeatedSubstringPattern</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token keyword">return</span> <span class="token punctuation">(</span>s <span class="token operator">+</span> s<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>s <span class="token operator">+</span> s<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20221213132737394.png" alt="image-20221213132737394"></p><p>不过这种解法还有一个问题，就是 我们最终还是要判断 一个字符串（s + s）是否出现过 s 的过程，<strong>大家可能直接用 contains，find 之类的库函数。 却忽略了实现这些函数的时间复杂度（暴力解法是 m * n，一般库函数实现为 O (m + n))</strong>。</p><p>如果我们做过 <span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVyY2FybC5jb20vMDAyOC4lRTUlQUUlOUUlRTclOEUlQjBzdHJTdHIuaHRtbA==">28. 实现 strStr</span> 题目的话，其实就知道，<strong>实现一个 高效的算法来判断 一个字符串中是否出现另一个字符串是很复杂的</strong>，这里就涉及到了 KMP 算法。</p><h4 id="kmp算法"><a class="anchor" href="#kmp算法">#</a> KMP 算法</h4><h5 id="为什么会使用kmp算法"><a class="anchor" href="#为什么会使用kmp算法">#</a> 为什么会使用 KMP 算法</h5><p>在一个串中查找是否出现过另一个串，这是 KMP 的看家本领。那么寻找重复子串怎么也涉及到 KMP 算法了呢？</p><p>KMP 算法中 next 数组为什么遇到字符不匹配的时候可以找到上一个匹配过的位置继续匹配，靠的是有计算好的前缀表。 前缀表里，统计了各个位置为终点字符串的最长相同前后缀的长度。</p><p>那么最长相同前后缀和重复子串的关系又有什么关系呢。</p><p>可能很多录友又忘了 前缀和后缀的定义，再回顾一下：</p><ul><li>前缀是指不包含最后一个字符的所有以第一个字符开头的连续子串；</li><li>后缀是指不包含第一个字符的所有以最后一个字符结尾的连续子串</li></ul><p>在由重复子串组成的字符串中，<strong><u>最长相等前后缀</u>不包含的子串就是<u>最小重复子串</u></strong>，这里拿字符串 s：abababab 来举例，ab 就是最小重复单位，如图所示：</p><p><img data-src="https://code-thinking-1253855093.file.myqcloud.com/pics/20220728205249.png" alt="图三"></p><h5 id="如何找到最小重复子串"><a class="anchor" href="#如何找到最小重复子串">#</a> 如何找到最小重复子串</h5><p>这里有同学就问了，为啥一定是开头的 ab 呢。 其实最关键还是要理解 最长相等前后缀，如图：</p><p><img data-src="https://code-thinking-1253855093.file.myqcloud.com/pics/20220728212157.png" alt="图四"></p><p>步骤一：因为 这是相等的前缀和后缀，t [0] 与 k [0] 相同， t [1] 与 k [1] 相同，所以 s [0] 一定和 s [2] 相同，s [1] 一定和 s [3] 相同，即：，s [0] s [1] 与 s [2] s [3] 相同 。</p><p>步骤二： 因为在同一个字符串位置，所以 t [2] 与 k [0] 相同，t [3] 与 k [1] 相同。</p><p>步骤三： 因为 这是相等的前缀和后缀，t [2] 与 k [2] 相同 ，t [3] 与 k [3] 相同，所以，s [2] 一定和 s [4] 相同，s [3] 一定和 s [5] 相同，即：s [2] s [3] 与 s [4] s [5] 相同。</p><p>步骤四：循环往复。</p><p>所以字符串 s，s [0] s [1] 与 s [2] s [3] 相同， s [2] s [3] 与 s [4] s [5] 相同，s [4] s [5] 与 s [6] s [7] 相同。</p><p>正是因为 最长相等前后缀的规则，当一个字符串由重复子串组成的，<strong>最长相等前后缀不包含的子串就是最小重复子串</strong>。</p><h5 id="简单推理"><a class="anchor" href="#简单推理">#</a> 简单推理</h5><p>这里再给出一个数学推导，就容易理解很多。</p><p>假设字符串 s 使用多个重复子串构成（这个子串是最小重复单位），重复出现的子字符串长度是 x，所以 s 是由 n * x 组成。</p><p>因为字符串 s 的最长相同前后缀的长度一定是不包含 s 本身，所以 <u>最长相同前后缀长度必然是 m * x，而且 n - m = 1</u>，（这里如果不懂，看上面的推理）</p><p>所以<strong>如果 <code>nx % (n - m)x = 0</code> ，就可以判定有重复出现的子字符串</strong>。</p><p>next 数组记录的就是最长相同前后缀 <span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVyY2FybC5jb20vMDAyOC4lRTUlQUUlOUUlRTclOEUlQjBzdHJTdHIuaHRtbA==">字符串：KMP 算法精讲</span>这里介绍了什么是前缀，什么是后缀，什么又是最长相同前后缀)， 如果 next [len - 1] != -1，则说明字符串有最长相同的前后缀（就是字符串里的前缀子串和后缀子串相同的最长长度）。</p><p>最长相等前后缀的长度为：next [len - 1] + 1。(这里的 next 数组是以统一减一的方式计算的，因此需要 + 1，两种计算 next 数组的具体区别看这里：<span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVyY2FybC5jb20vMDAyOC4lRTUlQUUlOUUlRTclOEUlQjBzdHJTdHIuaHRtbA==">字符串：KMP 算法精讲</span>)</p><p>数组长度为：len。</p><p><strong>如果 <code>len % (len - (next[len - 1] + 1)) == 0</code> ，则说明数组的长度正好可以被 (数组长度 - 最长相等前后缀的长度) 整除 ，说明该字符串有重复的子字符串。</strong></p><blockquote><p>前提是满足条件 <code>next[len - 1] != 0</code> ，即存在最长相等前后缀。</p></blockquote><p><strong>数组长度减去最长相同前后缀的长度相当于是第一个周期的长度，也就是一个周期的长度，如果这个周期可以被整除，就说明整个数组就是这个周期的循环。</strong></p><p><strong>强烈建议大家把 next 数组打印出来，看看 next 数组里的规律，有助于理解 KMP 算法</strong></p><p>如图：</p><p><img data-src="https://code-thinking.cdn.bcebos.com/pics/459.%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2_1.png" alt="459.重复的子字符串_1"></p><p>next [len - 1] = 7，next [len - 1] + 1 = 8，8 就是此时字符串 asdfasdfasdf 的最长相同前后缀的长度。</p><p>(len - (next [len - 1] + 1)) 也就是： 12 (字符串的长度) - 8 (最长公共前后缀的长度) = 4， 4 正好可以被 12 (字符串的长度) 整除，所以说明有重复的子字符串（asdf）。</p><p>代码如下：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// KMP 算法（前缀表不减一）</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">repeatedSubstringPattern</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token keyword">boolean</span> res <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token comment">// 特判：字符串长度小于 2，直接返回 false</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>            <span class="token keyword">return</span> res<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token comment">// 构造前缀表</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token function">getNext</span><span class="token punctuation">(</span>next<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token comment">// 判断是否存在重复子串</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token keyword">int</span> len <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 字符串总长度</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token keyword">int</span> repeatLen <span class="token operator">=</span> len <span class="token operator">-</span> next<span class="token punctuation">[</span>len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 重复子串长度 = 字符串总长度 - 前缀表最后一个元素 (最长公共前后缀长度)</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>next<span class="token punctuation">[</span>len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> len <span class="token operator">%</span> repeatLen <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 最长公共前后缀长度不为 0，且字符串总长度能被重复子串长度整除，说明存在重复子串</span></pre></td></tr><tr><td data-num="16"></td><td><pre>            res <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>        <span class="token keyword">return</span> res<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="20"></td><td><pre></pre></td></tr><tr><td data-num="21"></td><td><pre>    <span class="token comment">// 获取前缀表</span></pre></td></tr><tr><td data-num="22"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">getNext</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> next<span class="token punctuation">,</span> <span class="token class-name">String</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>        <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>        next<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>            <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">!=</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>                j <span class="token operator">=</span> next<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">==</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>                j<span class="token operator">++</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="31"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>            next<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> j<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="33"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="34"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="35"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h2 id="双指针法-5"><a class="anchor" href="#双指针法-5">#</a> 双指针法</h2><h3 id="1移除元素27-移除元素"><a class="anchor" href="#1移除元素27-移除元素">#</a> [1. 移除元素](#27. 移除元素)</h3><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/008eGmZEly1gntrds6r59g30du09mnpd.gif" alt="27.移除元素-双指针法"></p><h3 id="2反转字符串344-反转字符串"><a class="anchor" href="#2反转字符串344-反转字符串">#</a> [2. 反转字符串](#344. 反转字符串)</h3><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/008eGmZEly1gp0fvi91pfg30de0akwnq.gif" alt="344.反转字符串"></p><h3 id="3替换空格剑指-offer-05-替换空格"><a class="anchor" href="#3替换空格剑指-offer-05-替换空格">#</a> [3. 替换空格](# 剑指 Offer 05. 替换空格)</h3><p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1go6qmevhgpg20du09m4qp.gif" alt="替换空格"></p><h3 id="4翻转字符串里的单词151-反转字符串中的单词"><a class="anchor" href="#4翻转字符串里的单词151-反转字符串中的单词">#</a> [4. 翻转字符串里的单词](#151. 反转字符串中的单词)</h3><blockquote><ol><li>移除冗余空格</li><li>翻转整个字符串</li><li>翻转每个单词</li></ol></blockquote><h3 id="5反转链表206-反转链表"><a class="anchor" href="#5反转链表206-反转链表">#</a> [5. 反转链表](#206. 反转链表)</h3><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/206.%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8.gif" alt="img"></p><blockquote><p>动画中应该是 pre 先移动，cur 再移动</p></blockquote><h3 id="6删除链表的倒数第n个节点19-删除链表的倒数第-n-个结点"><a class="anchor" href="#6删除链表的倒数第n个节点19-删除链表的倒数第-n-个结点">#</a> [6. 删除链表的倒数第 n 个节点](#19. 删除链表的倒数第 n 个结点)</h3><blockquote><ol><li><p>slow、fast 指针的初始值为虚拟头节点</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20221213142711440.png" alt="image-20221213142711440"></p></li><li><p>fast 先走 n+1 步</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20221213142731300.png" alt="image-20221213142731300"></p></li><li><p>fast 和 slow 同时移动，直到 fast 指向 null</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20221213142755771.png" alt="image-20221213142755771"></p></li><li><p>删除 slow 指向的下一个节点</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20221213142814247.png" alt="image-20221213142814247"></p></li></ol></blockquote><h3 id="7链表相交面试题-0207-链表相交"><a class="anchor" href="#7链表相交面试题-0207-链表相交">#</a> [7. 链表相交](# 面试题 02.07. 链表相交)</h3><blockquote><ol><li><p>求出两个链表的长度差值，让 curA 移动到和 curB 末尾对齐的地方</p></li><li><p><strong>比较 curA 和 curB 是否相同</strong></p><ul><li><p>如果<strong>不相同，同时向后移动 curA 和 curB</strong></p></li><li><p>如果<strong>遇到 curA == curB，则找到交点</strong></p><blockquote><p>因为交点不是数值相等，而是指针相等。</p></blockquote></li><li><p>若循环结束，返回空指针</p></li></ul></li></ol></blockquote><p><img data-src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png" alt="img"></p><h3 id="8环形链表ii142-环形链表-ii"><a class="anchor" href="#8环形链表ii142-环形链表-ii">#</a> [8. 环形链表 II](#142. 环形链表 II)</h3><blockquote><ol><li><p>判断链表是否有环</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/141.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8.gif" alt="141.环形链表"></p></li><li><p>如果有环，如何找到环的入口<img data-src="https://code-thinking-1253855093.file.myqcloud.com/pics/20220925103433.png" alt="img"></p></li></ol></blockquote><h3 id="9三数之和15-三数之和"><a class="anchor" href="#9三数之和15-三数之和">#</a> [9. 三数之和](#15. 三数之和)</h3><blockquote><ol><li><p>对数组排序</p></li><li><p><strong>for 循环</strong></p><ul><li><p>i：从下标 0 的地方开始</p></li><li><p>left：定义在 i+1 的位置上</p></li><li><p>right：在数组结尾的位置上</p></li></ul></li><li><p>for 循环中<strong>如何移动 left、right</strong></p><ul><li>如果 nums [i] + nums [left] + nums [right] &gt; 0 就说明 此时三数之和大了，因为数组是排序后了，所以 right 下标就应该向左移动，这样才能让三数之和小一些</li><li>如果 nums [i] + nums [left] + nums [right] &lt; 0 说明 此时 三数之和小了，left 就向右移动，才能让三数之和大一些</li><li>直到 left 与 right 相遇为止。</li></ul></li></ol><p>注意：对三个数都要进行<strong>去重</strong>。</p></blockquote><p><img data-src="https://code-thinking.cdn.bcebos.com/gifs/15.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C.gif" alt="15.三数之和"></p><h3 id="10四数之和18-四数之和"><a class="anchor" href="#10四数之和18-四数之和">#</a> [10. 四数之和](#18. 四数之和)</h3><blockquote><p>在三数之和的基础上<strong>再套一层 for 循环</strong>，但是最外两层的<strong>去重、剪枝不一样</strong>了。</p></blockquote><h3 id="总结-7"><a class="anchor" href="#总结-7">#</a> 总结</h3><h4 id="数组篇"><a class="anchor" href="#数组篇">#</a> 数组篇</h4><p>在<span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVyY2FybC5jb20vMDAyNy4lRTclQTclQkIlRTklOTklQTQlRTUlODUlODMlRTclQjQlQTAuaHRtbA==">移除元素</span>中，原地移除数组上的元素，我们说到了<strong>数组上的元素，不能真正的删除，只能覆盖</strong>。</p><p>一些同学可能会写出如下代码（伪代码）：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> array<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>array<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        array<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>这个代码看上去好像是 O (n) 的时间复杂度，其实是 O (n^2) 的时间复杂度，因为 erase 操作也是 O (n) 的操作。</p><p>所以此时使用双指针法才展现出效率的优势：<strong>通过两个指针在一个 for 循环下完成两个 for 循环的工作。</strong></p><h4 id="字符串篇"><a class="anchor" href="#字符串篇">#</a> 字符串篇</h4><p>在<span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVyY2FybC5jb20vMDM0NC4lRTUlOEYlOEQlRTglQkQlQUMlRTUlQUQlOTclRTclQUMlQTYlRTQlQjglQjIuaHRtbA==">反转字符串 </span>中讲解了反转字符串，注意这里强调要原地反转，要不然就失去了题目的意义。</p><p>使用双指针法，<strong>定义两个指针（也可以说是索引下标），一个从字符串前面，一个从字符串后面，两个指针同时向中间移动，并交换元素。</strong>，时间复杂度是 O (n)。</p><p>在<span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVyY2FybC5jb20vJUU1JTg5JTkxJUU2JThDJTg3T2ZmZXIwNS4lRTYlOUIlQkYlRTYlOEQlQTIlRTclQTklQkElRTYlQTAlQkMuaHRtbA==">替换空格 </span>中介绍使用双指针填充字符串的方法，如果想把这道题目做到极致，就不要只用额外的辅助空间了！</p><p>思路就是<strong>首先扩充数组到每个空格替换成 &quot;%20&quot; 之后的大小。然后双指针从后向前替换空格。</strong></p><p>有同学问了，为什么要从后向前填充，从前向后填充不行么？</p><p>从前向后填充就是 O (n^2) 的算法了，因为每次添加元素都要将添加元素之后的所有元素向后移动。</p><p><strong>其实很多数组（字符串）填充类的问题，都可以先预先给数组扩容带填充后的大小，然后在从后向前进行操作。</strong></p><p>那么在<span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVyY2FybC5jb20vMDE1MS4lRTclQkYlQkIlRTglQkQlQUMlRTUlQUQlOTclRTclQUMlQTYlRTQlQjglQjIlRTklODclOEMlRTclOUElODQlRTUlOEQlOTUlRTglQUYlOEQuaHRtbA==">翻转字符串里的单词</span>中，我们使用双指针法，用 O (n) 的时间复杂度完成字符串删除类的操作，因为题目要删除冗余空格。</p><p><strong>在删除冗余空格的过程中，如果不注意代码效率，很容易写成了 O (n^2) 的时间复杂度。其实使用双指针法 O (n) 就可以搞定。</strong></p><p><strong>主要还是大家用 erase 用的比较随意，一定要注意 for 循环下用 erase 的情况，一般可以用双指针写效率更高！</strong></p><h4 id="链表篇"><a class="anchor" href="#链表篇">#</a> 链表篇</h4><p>翻转链表是现场面试，白纸写代码的好题，考察了候选者对链表以及指针的熟悉程度，而且代码也不长，适合在白纸上写。</p><p>在<span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVyY2FybC5jb20vMDIwNi4lRTclQkYlQkIlRTglQkQlQUMlRTklOTMlQkUlRTglQTElQTguaHRtbA==">翻转链表 </span>中，讲如何使用双指针法来翻转链表，<strong>只需要改变链表的 next 指针的指向，直接将链表反转 ，而不用重新定义一个新的链表。</strong></p><p>思路还是很简单的，代码也不长，但是想在白纸上一次性写出 bugfree 的代码，并不是容易的事情。</p><p>在链表中求环，应该是双指针在链表里最经典的应用，在<span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVyY2FybC5jb20vMDE0Mi4lRTclOEUlQUYlRTUlQkQlQTIlRTklOTMlQkUlRTglQTElQThJSS5odG1s">环形链表 II</span> 中讲解了如何通过双指针判断是否有环，而且还要找到环的入口。</p><p><strong>使用快慢指针（双指针法），分别定义 fast 和 slow 指针，从头结点出发，fast 指针每次移动两个节点，slow 指针每次移动一个节点，如果 fast 和 slow 指针在途中相遇 ，说明这个链表有环。</strong></p><p>那么找到环的入口，其实需要点简单的数学推理，我在文章中把找环的入口清清楚楚的推理的一遍，如果对找环入口不够清楚的同学建议自己看一看<span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVyY2FybC5jb20vMDE0Mi4lRTclOEUlQUYlRTUlQkQlQTIlRTklOTMlQkUlRTglQTElQThJSS5odG1s">环形链表 II</span>。</p><h4 id="n数之和篇"><a class="anchor" href="#n数之和篇">#</a> N 数之和篇</h4><p>在<span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVyY2FybC5jb20vMDAxNS4lRTQlQjglODklRTYlOTUlQjAlRTQlQjklOEIlRTUlOTIlOEMuaHRtbA==">哈希表：解决了两数之和，那么能解决三数之和么？ </span>中，讲到使用<strong>哈希法</strong>可以解决 [1. 两数之和](#1. 两数之和) 的问题</p><p>其实使用<strong>双指针</strong>也可以解决 [1. 两数之和](#1. 两数之和) 的问题，只不过 [1. 两数之和](#1. 两数之和) 求的是两个元素的下标，没法用双指针，如果改成求具体两个元素的数值就可以了，大家可以尝试用双指针做一个 leetcode 上两数之和的题目，就可以体会到我说的意思了。</p><p>使用了哈希法解决了两数之和，但是<strong>哈希法并不使用于三数之和！</strong></p><p>使用哈希法的过程中要把符合条件的三元组放进 vector 中，然后在去去重，这样是非常费时的，很容易超时，也是三数之和通过率如此之低的根源所在。</p><p>去重的过程不好处理，有很多小细节，如果在面试中很难想到位。</p><p>时间复杂度可以做到 O (n^2)，但还是比较费时的，因为不好做剪枝操作。</p><p>所以这道题目使用双指针法才是最为合适的，用双指针做这道题目才能就能真正体会到，<strong>通过前后两个指针不算向中间逼近，在一个 for 循环下完成两个 for 循环的工作。</strong></p><p>只用双指针法时间复杂度为 O (n^2)，但比哈希法的 O (n^2) 效率高得多，哈希法在使用两层 for 循环的时候，能做的剪枝操作很有限。</p><p>在<span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVyY2FybC5jb20vMDAxOC4lRTUlOUIlOUIlRTYlOTUlQjAlRTQlQjklOEIlRTUlOTIlOEMuaHRtbA==">双指针法：一样的道理，能解决四数之和 </span>中，讲到了四数之和，其实思路是一样的，<strong>在三数之和的基础上再套一层 for 循环，依然是使用双指针法。</strong></p><p>对于三数之和使用双指针法就是将原本暴力 O (n^3) 的解法，降为 O (n^2) 的解法，四数之和的双指针解法就是将原本暴力 O (n^4) 的解法，降为 O (n^3) 的解法。</p><p>同样的道理，五数之和，n 数之和都是在这个基础上累加。</p><h4 id="小结"><a class="anchor" href="#小结">#</a> 小结</h4><p>本文中一共介绍了 leetcode 上九道使用双指针解决问题的经典题目，除了链表一些题目一定要使用双指针，其他题目都是使用双指针来提高效率，一般是将 O (n^2) 的时间复杂度，降为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。</p><p>建议大家可以把文中涉及到的题目在好好做一做，琢磨琢磨，基本对双指针法就不在话下了。</p><h2 id="栈与队列"><a class="anchor" href="#栈与队列">#</a> 栈与队列</h2><h3 id="理论基础-4"><a class="anchor" href="#理论基础-4">#</a> 理论基础</h3><p>我想栈和队列的原理大家应该很熟悉了，<strong>队列是先进先出，栈是先进后出</strong>。</p><p>如图所示：</p><p><img data-src="https://img-blog.csdnimg.cn/20210104235346563.png" alt="栈与队列理论1"></p><p>那么我这里在列出<strong>四个关于栈的问题</strong>，大家可以思考一下。以下是以 C++ 为例，相信使用其他编程语言的同学也对应思考一下，自己使用的编程语言里栈和队列是什么样的。</p><ol><li>C++ 中 stack 是容器么？</li><li>我们使用的 stack 是属于哪个版本的 STL？</li><li>我们使用的 STL 中 stack 是如何实现的？</li><li>stack 提供迭代器来遍历 stack 空间么？</li></ol><p>相信这四个问题并不那么好回答， 因为一些同学使用数据结构会停留在非常表面上的应用，稍稍往深一问，就会有好像懂，好像也不懂的感觉。</p><p>有的同学可能仅仅知道有栈和队列这么个数据结构，却不知道底层实现，也不清楚所使用栈和队列和 STL 是什么关系。</p><p>所以这里我在给大家扫一遍基础知识。</p><hr><p>首先大家要知道<strong>栈和队列是 STL（C++ 标准库）里面的两个数据结构</strong>。</p><p>C++ 标准库是有多个版本的，要知道我们使用的 STL 是哪个版本，才能知道对应的栈和队列的实现原理。</p><p>那么来介绍一下，三个最为普遍的 STL 版本：</p><ol><li><strong>HP STL</strong> 其他版本的 C++ STL，一般是以 HP STL 为蓝本实现出来的，HP STL 是 C++ STL 的第一个实现版本，而且开放源代码。</li><li><strong>P.J.Plauger STL</strong> 由 P.J.Plauger 参照 HP STL 实现出来的，被 Visual C++ 编译器所采用，不是开源的。</li><li><strong>SGI STL</strong> 由 Silicon Graphics Computer Systems 公司参照 HP STL 实现，被 Linux 的 C++ 编译器 GCC 所采用，SGI STL 是开源软件，源码可读性甚高。</li></ol><p>接下来介绍的栈和队列也是 SGI STL 里面的数据结构， 知道了使用版本，才知道对应的底层实现。</p><hr><p>来说一说栈，栈先进后出，如图所示：</p><p><img data-src="https://img-blog.csdnimg.cn/20210104235434905.png" alt="栈与队列理论2"></p><p><strong>栈提供 push 和 pop 等等接口，所有元素必须符合先进后出规则，所以栈不提供走访功能，也不提供迭代器 (iterator)。</strong> 不像是 set 或者 map 提供迭代器 iterator 来遍历所有元素。</p><p><strong>栈是以底层容器完成其所有的工作，对外提供统一的接口，<u>底层容器是可插拔的</u>（也就是说我们可以控制使用哪种容器来实现栈的功能）。</strong></p><p>所以 STL 中栈往往不被归类为容器，而被归类为 container adapter（容器适配器）。</p><p>那么问题来了，<strong>STL 中栈是用什么容器实现的？</strong></p><p>从下图中可以看出，栈的内部结构，<strong>栈的底层实现可以是 vector，deque，list</strong> 都是可以的， 主要就是数组和链表的底层实现。</p><p><img data-src="https://img-blog.csdnimg.cn/20210104235459376.png" alt="栈与队列理论3"></p><p><strong>我们常用的 SGI STL，如果没有指定底层实现的话，默认是以 deque 为缺省情况下栈的底层结构。</strong></p><p>deque 是一个双向队列，只要封住一段，只开通另一端就可以实现栈的逻辑了。</p><p>我们也可以指定 vector 为栈的底层实现，初始化语句如下：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>std<span class="token double-colon punctuation">::</span>stack<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token operator">></span> third<span class="token punctuation">;</span>  <span class="token comment">// 使用 vector 为底层容器的栈</span></pre></td></tr></table></figure><hr><p>刚刚讲过栈的特性，对应的队列的情况是一样的。</p><p>队列中先进先出的数据结构，同样不允许有遍历行为，不提供迭代器，<strong>SGI STL 中队列一样是以 deque 为缺省情况下的底部结构。</strong></p><p>也可以指定 list 为起底层实现，初始化 queue 的语句如下：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>std<span class="token double-colon punctuation">::</span>queue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> third<span class="token punctuation">;</span> <span class="token comment">// 定义以 list 为底层容器的队列</span></pre></td></tr></table></figure><p>所以 STL 队列也不被归类为容器，而被归类为 container adapter（ 容器适配器）。</p><p>我这里讲的都是 C++ 语言中情况， 使用其他语言的同学也要思考栈与队列的底层实现问题， 不要对数据结构的使用浅尝辄止，而要深挖起内部原理，才能夯实基础。</p><h3 id="232-用栈实现队列"><a class="anchor" href="#232-用栈实现队列">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9pbXBsZW1lbnQtcXVldWUtdXNpbmctc3RhY2tzLw==">232. 用栈实现队列</span></h3><p>这是一道模拟题，不涉及到具体算法，考察的就是对栈和队列的掌握程度。</p><p>使用栈来模式队列的行为，如果仅仅用一个栈，是一定不行的，所以需要两个栈<strong>一个输入栈，一个输出栈</strong>，这里要注意输入栈和输出栈的关系。</p><p>下面动画模拟以下队列的执行过程如下：</p><p>执行语句：<br>queue.push(1);<br>queue.push(2);<br>queue.pop(); <strong>注意此时的输出栈的操作</strong><br>queue.push (3);<br>queue.push(4);<br>queue.pop();<br>queue.pop();<strong> 注意此时的输出栈的操作</strong><br>queue.pop ();<br>queue.empty();</p><p><img data-src="https://code-thinking.cdn.bcebos.com/gifs/232.%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%E7%89%88%E6%9C%AC2.gif" alt="232.用栈实现队列版本2"></p><p>在 push 数据的时候，只要数据放进输入栈就好，<strong>但在 pop 的时候，操作就复杂一些，输出栈如果为空，就把进栈数据全部导入进来（注意是全部导入）</strong>，再从出栈弹出数据，如果输出栈不为空，则直接从出栈弹出数据就可以了。</p><p>最后如何判断队列为空呢？<strong>如果进栈和出栈都为空的话，说明模拟的队列为空了。</strong></p><p>在代码实现的时候，会发现 pop () 和 peek () 两个函数功能类似，代码实现上也是类似的，可以思考一下如何把代码抽象一下。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">MyQueue</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> stackIn<span class="token punctuation">;</span> <span class="token comment">// 输入栈</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> stackOut<span class="token punctuation">;</span> <span class="token comment">// 输出栈</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">MyQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        stackIn <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        stackOut <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        stackIn<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>stackOut<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 输出栈为空</span></pre></td></tr><tr><td data-num="17"></td><td><pre>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>stackIn<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 将输入栈的元素全部倒入输出栈</span></pre></td></tr><tr><td data-num="18"></td><td><pre>                stackOut<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>stackIn<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>        <span class="token keyword">return</span> stackOut<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="23"></td><td><pre></pre></td></tr><tr><td data-num="24"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>        <span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 复用 pop 方法</span></pre></td></tr><tr><td data-num="26"></td><td><pre>        stackOut<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将弹出的元素重新压入输出栈</span></pre></td></tr><tr><td data-num="27"></td><td><pre>        <span class="token keyword">return</span> result<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="29"></td><td><pre></pre></td></tr><tr><td data-num="30"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="31"></td><td><pre>        <span class="token keyword">return</span> stackIn<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> stackOut<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输入栈和输出栈都为空时，队列为空</span></pre></td></tr><tr><td data-num="32"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="33"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id="225-用队列实现栈"><a class="anchor" href="#225-用队列实现栈">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9pbXBsZW1lbnQtc3RhY2stdXNpbmctcXVldWVzLw==">225. 用队列实现栈</span></h3><blockquote><p>用队列实现栈还是有点别扭。</p></blockquote><p>（这里要强调是单向队列）</p><p>有的同学可能疑惑这种题目有什么实际工程意义，<strong>其实很多算法题目主要是对知识点的考察和教学意义远大于其工程实践的意义，所以面试题也是这样！</strong></p><p>刚刚做过<span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVyY2FybC5jb20vMDIzMi4lRTclOTQlQTglRTYlQTAlODglRTUlQUUlOUUlRTclOEUlQjAlRTklOTglOUYlRTUlODglOTcuaHRtbA==">栈与队列：我用栈来实现队列怎么样？ </span>的同学可能依然想着用一个输入队列，一个输出队列，就可以模拟栈的功能，仔细想一下还真不行！</p><p><strong>队列模拟栈，其实一个队列就够了</strong>，那么我们先说一说两个队列来实现栈的思路。</p><p><strong>队列是先进先出的规则，把一个队列中的数据导入另一个队列中，数据的顺序并没有变，并没有变成先进后出的顺序。</strong></p><p>所以用栈实现队列， 和用队列实现栈的思路还是不一样的，这取决于这两个数据结构的性质。</p><p>但是依然还是要用两个队列来模拟栈，只不过没有输入和输出的关系，而是<strong>另一个队列完全用又来备份的</strong>！</p><p>如下面动画所示，<strong>用两个队列 que1 和 que2 实现栈的功能，que2 其实完全就是一个备份的作用</strong>，把 que1 最后面的元素以外的元素都备份到 que2，然后弹出最后面的元素，再把其他元素从 que2 导回 que1。</p><p>模拟的队列执行语句如下：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        </pre></td></tr><tr><td data-num="2"></td><td><pre>queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        </pre></td></tr><tr><td data-num="3"></td><td><pre>queue<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 注意弹出的操作       </span></pre></td></tr><tr><td data-num="4"></td><td><pre>queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        </pre></td></tr><tr><td data-num="5"></td><td><pre>queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       </pre></td></tr><tr><td data-num="6"></td><td><pre>queue<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 注意弹出的操作    </span></pre></td></tr><tr><td data-num="7"></td><td><pre>queue<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    </pre></td></tr><tr><td data-num="8"></td><td><pre>queue<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    </pre></td></tr><tr><td data-num="9"></td><td><pre>queue<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p><img data-src="https://code-thinking.cdn.bcebos.com/gifs/225.%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88.gif" alt="225.用队列实现栈"></p><p>代码如下（用两个队列实现栈）：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 用两个队列实现栈（不带 top 数据成员）</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">MyStack</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">private</span> <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> queue1<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">private</span> <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> queue2<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">MyStack</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        queue1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        queue2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        queue1<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//offer ()：将指定元素插入队列尾部</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token keyword">while</span> <span class="token punctuation">(</span>queue1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 将 queue1 中的元素全部转移到 queue2 中，只留下一个元素</span></pre></td></tr><tr><td data-num="17"></td><td><pre>            queue2<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>queue1<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//poll ()：获取并移除队列头部元素</span></pre></td></tr><tr><td data-num="18"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>        <span class="token keyword">int</span> res <span class="token operator">=</span> queue1<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre></pre></td></tr><tr><td data-num="21"></td><td><pre>        <span class="token comment">// 交换 queue1 和 queue2</span></pre></td></tr><tr><td data-num="22"></td><td><pre>        <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> temp <span class="token operator">=</span> queue1<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>        queue1 <span class="token operator">=</span> queue2<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>        queue2 <span class="token operator">=</span> temp<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre></pre></td></tr><tr><td data-num="26"></td><td><pre>        <span class="token keyword">return</span> res<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="28"></td><td><pre></pre></td></tr><tr><td data-num="29"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>        <span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="31"></td><td><pre>        queue1<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>        <span class="token keyword">return</span> result<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="33"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="34"></td><td><pre></pre></td></tr><tr><td data-num="35"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="36"></td><td><pre>        <span class="token keyword">return</span> queue1<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="37"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="38"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h4 id="优化"><a class="anchor" href="#优化">#</a> 优化</h4><p>其实这道题目就是用一个队列就够了。</p><p><strong>一个队列在模拟栈弹出元素的时候，只要将队列头部的所有元素（除了最后一个元素外） 重新添加到队列尾部，此时再去弹出元素就是栈的顺序了。</strong></p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">MyStack</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">private</span> <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> queue<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">MyStack</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token keyword">int</span> size <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token keyword">while</span> <span class="token punctuation">(</span>size <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>            queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//poll ()：检索并删除队列的头部元素</span></pre></td></tr><tr><td data-num="16"></td><td><pre>            size<span class="token operator">--</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>        <span class="token keyword">return</span> queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="20"></td><td><pre></pre></td></tr><tr><td data-num="21"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>        <span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>        queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>        <span class="token keyword">return</span> result<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="26"></td><td><pre></pre></td></tr><tr><td data-num="27"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>        <span class="token keyword">return</span> queue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="30"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id="20-有效的括号"><a class="anchor" href="#20-有效的括号">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy92YWxpZC1wYXJlbnRoZXNlcy8=">20. 有效的括号</span></h3><h4 id="题外话"><a class="anchor" href="#题外话">#</a> 题外话</h4><p><strong>括号匹配是使用栈解决的经典问题。</strong></p><p>题意其实就像我们在写代码的过程中，要求括号的顺序是一样的，有左括号，相应的位置必须要有右括号。</p><p>如果还记得编译原理的话，编译器在 词法分析的过程中处理括号、花括号等这个符号的逻辑，也是使用了栈这种数据结构。</p><p>再举个例子，linux 系统中，cd 这个进入目录的命令我们应该再熟悉不过了。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>cd a<span class="token operator">/</span>b<span class="token operator">/</span>c<span class="token operator">/</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">/</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">/</span></pre></td></tr></table></figure><p>这个命令最后进入 a 目录，系统是如何知道进入了 a 目录呢 ，这就是栈的应用（其实可以出一道相应的面试题了）</p><p>所以栈在计算机领域中应用是非常广泛的。</p><p>有的同学经常会想学的这些数据结构有什么用，也开发不了什么软件，大多数同学说的软件应该都是可视化的软件例如 APP、网站之类的，那都是非常上层的应用了，底层很多功能的实现都是基础的数据结构和算法。</p><p><strong>所以数据结构与算法的应用往往隐藏在我们看不到的地方！</strong></p><p>这里我就不过多展开了，先来看题。</p><h4 id="进入正题"><a class="anchor" href="#进入正题">#</a> 进入正题</h4><p>由于栈结构的特殊性，非常适合做<strong>对称匹配类</strong>的题目。</p><p>首先要弄清楚，字符串里的括号不匹配有几种情况。</p><p><strong>一些同学，在面试中看到这种题目上来就开始写代码，然后就越写越乱。</strong></p><p>建议要写代码之前要分析好有哪几种不匹配的情况，如果不动手之前分析好，写出的代码也会有很多问题。</p><p>先来分析一下 这里<strong>有三种不匹配的情况</strong>，</p><ol><li>第一种情况，字符串里<u>左方向的括号多余</u>了 ，所以不匹配。 <img data-src="https://img-blog.csdnimg.cn/2020080915505387.png" alt="括号匹配1"></li><li>第二种情况，括号没有多余，但是<u>括号的类型没有匹配上</u>。 <img data-src="https://img-blog.csdnimg.cn/20200809155107397.png" alt="括号匹配2"></li><li>第三种情况，字符串里<u>右方向的括号多余</u>了，所以不匹配。 <img data-src="https://img-blog.csdnimg.cn/20200809155115779.png" alt="括号匹配3"></li></ol><p>我们的代码只要覆盖了这三种不匹配的情况，就不会出问题，可以看出动手之前分析好题目的重要性。</p><p>动画如下：</p><p><img data-src="https://code-thinking.cdn.bcebos.com/gifs/20.%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7.gif" alt="20.有效括号"></p><ol><li><p><strong>已经遍历完了字符串，但是栈不为空</strong>，说明有相应的左括号没有右括号来匹配，所以 return false</p><blockquote><p>左括号多余</p></blockquote></li><li><p>遍历字符串匹配的过程中，发现<strong>栈里没有要匹配的字符</strong>。所以 return false</p><blockquote><p>括号类型不匹配</p></blockquote></li><li><p>遍历字符串匹配的过程中，<strong>栈已经为空了，没有匹配的字符了</strong>，说明右括号没有找到对应的左括号 return false</p><blockquote><p>右括号多余</p></blockquote></li></ol><p>那么什么时候说明左括号和右括号全都匹配了呢，就是<strong>字符串遍历完之后，栈是空的，就说明全都匹配了。</strong></p><p>分析完之后，代码其实就比较好写了，</p><p>但还有一些技巧，<strong>在匹配左括号的时候，右括号先入栈，就只需要比较当前元素和栈顶相不相等就可以了，比左括号先入栈代码实现要简单的多了！</strong></p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isValid</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token keyword">boolean</span> flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token comment">// 特判：字符串长度为奇数，直接返回 false</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Character</span><span class="token punctuation">></span></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>            <span class="token keyword">char</span> c <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>            <span class="token comment">// 如果是左括号，入栈</span></pre></td></tr><tr><td data-num="13"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token char">'('</span> <span class="token operator">||</span> c <span class="token operator">==</span> <span class="token char">'['</span> <span class="token operator">||</span> c <span class="token operator">==</span> <span class="token char">'&#123;'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>                stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 如果是右括号</span></pre></td></tr><tr><td data-num="16"></td><td><pre>                <span class="token comment">// 情况 3：如果栈为空，说明没有左括号与之匹配，直接返回 false</span></pre></td></tr><tr><td data-num="17"></td><td><pre>                <span class="token keyword">if</span> <span class="token punctuation">(</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>                    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>                <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>                <span class="token comment">// 情况 2：如果栈不为空，且栈顶元素与当前右括号不匹配，直接返回 false</span></pre></td></tr><tr><td data-num="21"></td><td><pre>                <span class="token keyword">char</span> topChar <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>                <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token char">')'</span> <span class="token operator">&amp;&amp;</span> topChar <span class="token operator">!=</span> <span class="token char">'('</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>                    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>                <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>                <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token char">']'</span> <span class="token operator">&amp;&amp;</span> topChar <span class="token operator">!=</span> <span class="token char">'['</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>                    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>                <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>                <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token char">'&#125;'</span> <span class="token operator">&amp;&amp;</span> topChar <span class="token operator">!=</span> <span class="token char">'&#123;'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>                    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>                <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="31"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="33"></td><td><pre>        <span class="token comment">// 情况 1：遍历字符串结束，此时如果栈不为空，说明有左括号没有匹配，直接返回 false</span></pre></td></tr><tr><td data-num="34"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="35"></td><td><pre>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="36"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="37"></td><td><pre>        <span class="token keyword">return</span> flag<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="38"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="39"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id="1047-删除字符串中的所有相邻重复项"><a class="anchor" href="#1047-删除字符串中的所有相邻重复项">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yZW1vdmUtYWxsLWFkamFjZW50LWR1cGxpY2F0ZXMtaW4tc3RyaW5nLw==">1047. 删除字符串中的所有相邻重复项</span></h3><blockquote><p>匹配问题都是栈的强项</p></blockquote><p>本题要删除相邻相同元素，相对于<span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVyY2FybC5jb20vMDAyMC4lRTYlOUMlODklRTYlOTUlODglRTclOUElODQlRTYlOEIlQUMlRTUlOEYlQjcuaHRtbA=="> 20. 有效的括号</span>来说其实也是<strong>匹配问题</strong>，<span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVyY2FybC5jb20vMDAyMC4lRTYlOUMlODklRTYlOTUlODglRTclOUElODQlRTYlOEIlQUMlRTUlOEYlQjcuaHRtbA==">20. 有效的括号</span>是匹配左右括号，本题是匹配相邻元素，最后都是做消除的操作。</p><p>本题也是<strong>用栈来解决</strong>的经典题目。</p><p>那么栈里应该放的是什么元素呢？</p><p>我们在删除相邻重复项的时候，其实就是要知道当前遍历的这个元素，我们在前一位是不是遍历过一样数值的元素，那么如何记录前面遍历过的元素呢？</p><p>所以就是用栈来存放，那么<strong>栈的目的，就是存放遍历过的元素</strong>，当遍历当前的这个元素的时候，去栈里看一下我们是不是遍历过相同数值的相邻元素。</p><p>然后再去做对应的消除操作。 如动画所示：</p><p><img data-src="https://code-thinking.cdn.bcebos.com/gifs/1047.%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E7%9B%B8%E9%82%BB%E9%87%8D%E5%A4%8D%E9%A1%B9.gif" alt="1047.删除字符串中的所有相邻重复项"></p><p>从栈中弹出剩余元素，此时是字符串 ac，因为<strong>从栈里弹出的元素是倒序的，所以在对字符串进行反转一下</strong>，就得到了最终的结果。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 用栈来解决匹配问题</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">removeDuplicates</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token class-name">String</span> res <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Character</span><span class="token punctuation">></span></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 遍历字符串</span></pre></td></tr><tr><td data-num="8"></td><td><pre>            <span class="token keyword">char</span> c <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> stack<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> c<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 如果栈为空或者栈顶元素不等于当前元素，入栈</span></pre></td></tr><tr><td data-num="10"></td><td><pre>                stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 如果栈顶元素等于当前元素，出栈</span></pre></td></tr><tr><td data-num="12"></td><td><pre>                stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre></pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 将栈中元素出栈，拼接成字符串</span></pre></td></tr><tr><td data-num="17"></td><td><pre>            res <span class="token operator">+=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="19"></td><td><pre></pre></td></tr><tr><td data-num="20"></td><td><pre>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 反转字符串</span></pre></td></tr><tr><td data-num="21"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="22"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>可是效率有点低啊：<img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20221214100820054.png" alt="image-20221214100820054"></p><h4 id="优化直接拿字符串作为栈"><a class="anchor" href="#优化直接拿字符串作为栈">#</a> 优化：直接拿字符串作为栈</h4><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 拿字符串直接作为栈</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">removeDuplicates</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token class-name">String</span> resStr <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">char</span> c <span class="token operator">:</span> s<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>resStr<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> resStr<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>resStr<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">!=</span> c<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre>                resStr <span class="token operator">+=</span> c<span class="token punctuation">;</span> <span class="token comment">// 如果栈为空，或者栈顶元素不等于当前元素，入栈</span></pre></td></tr><tr><td data-num="8"></td><td><pre>            <span class="token keyword">else</span></pre></td></tr><tr><td data-num="9"></td><td><pre>                resStr <span class="token operator">=</span> resStr<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> resStr<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 否则，出栈</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token keyword">return</span> resStr<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>可惜效率还是很低：<img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20221214101959556.png" alt="image-20221214101959556"></p><h4 id="双指针法-6"><a class="anchor" href="#双指针法-6">#</a> 双指针法</h4><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 双指针法（慢指针指向更新数组的位置，快指针去遍历）</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">removeDuplicates</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token keyword">int</span> slow <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> fast <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 慢指针指向当前不重复的位置，快指针遍历字符串</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> chars <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> fast <span class="token operator">&lt;</span> chars<span class="token punctuation">.</span>length<span class="token punctuation">;</span> fast<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>slow <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> chars<span class="token punctuation">[</span>slow <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">!=</span> chars<span class="token punctuation">[</span>fast<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">// 如果慢指针指向的位置和快指针指向的位置不相等，就将快指针指向的位置赋值给慢指针指向的位置</span></pre></td></tr><tr><td data-num="8"></td><td><pre>                chars<span class="token punctuation">[</span>slow<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> chars<span class="token punctuation">[</span>fast<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>            <span class="token keyword">else</span> <span class="token comment">// 如果相等，就将慢指针向前移动一位，相当于删除了重复的字符</span></pre></td></tr><tr><td data-num="10"></td><td><pre>                slow<span class="token operator">--</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>chars<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> slow<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>双指针 yyds：<img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20221214102345832.png" alt="image-20221214102345832"></p><h3 id="150-逆波兰表达式求值"><a class="anchor" href="#150-逆波兰表达式求值">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9ldmFsdWF0ZS1yZXZlcnNlLXBvbGlzaC1ub3RhdGlvbi8=">150. 逆波兰表达式求值</span></h3><blockquote><p>这不仅仅是一道好题，也展现出计算机的思考方式</p></blockquote><h4 id="概念"><a class="anchor" href="#概念">#</a> 概念</h4><p>逆波兰表达式：是一种<strong>后缀表达式</strong>，所谓后缀就是指算符写在后面。</p><p>平常使用的算式则是一种中缀表达式，如 (1 + 2) * ( 3 + 4 ) 。</p><p>该算式的逆波兰表达式写法为 (( 1 2 +) ( 3 4 + ) * ) 。</p><p>逆波兰表达式主要有以下两个优点：</p><ul><li><strong>去掉括号后表达式无歧义</strong>，上式即便写成 1 2 + 3 4 + * 也可以依据次序计算出正确结果。</li><li>适合用栈操作运算：<strong>遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中</strong>。</li></ul><h4 id="思路"><a class="anchor" href="#思路">#</a> 思路</h4><p>在上一篇文章中 [1047. 删除字符串中的所有相邻重复项](#1047. 删除字符串中的所有相邻重复项) 提到了递归就是用栈来实现的。</p><p>所以<strong>栈与递归之间在某种程度上是可以转换的！</strong> 这一点我们在后续讲解二叉树的时候，会更详细的讲解到。</p><p>那么来看一下本题，<strong>其实逆波兰表达式相当于是二叉树中的后序遍历</strong>。 大家可以把运算符作为中间节点，按照后序遍历的规则画出一个二叉树。</p><p>但我们没有必要从二叉树的角度去解决这个问题，只要知道逆波兰表达式是用后序遍历的方式把二叉树序列化了，就可以了。</p><p>在进一步看，本题中每一个子表达式要得出一个结果，然后拿这个结果再进行运算，那么<strong>这岂不就是一个相邻字符串消除的过程，和 [1047. 删除字符串中的所有相邻重复项](#1047. 删除字符串中的所有相邻重复项) 中的对对碰游戏是不是就非常像了。</strong></p><p>如动画所示： <img data-src="https://code-thinking.cdn.bcebos.com/gifs/150.%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC.gif" alt="150.逆波兰表达式求值"></p><p>相信看完动画大家应该知道，<strong>这和 [1047. 删除字符串中的所有相邻重复项](#1047. 删除字符串中的所有相邻重复项) 是差不多的，只不过本题不要相邻元素做消除了，而是做<mark>运算</mark>！</strong></p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 用栈实现</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">evalRPN</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> tokens<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> t <span class="token operator">:</span> tokens<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>            <span class="token comment">// 注意：字符串的比较不能用 ==，要用 equals ()</span></pre></td></tr><tr><td data-num="7"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"+"</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre>                stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"-"</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="10"></td><td><pre>                stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token operator">-</span>stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 注意减法的顺序</span></pre></td></tr><tr><td data-num="11"></td><td><pre>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"*"</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="12"></td><td><pre>                stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>                <span class="token keyword">int</span> num1 <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> num2 <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>                stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>num2 <span class="token operator">/</span> num1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 注意除法的顺序</span></pre></td></tr><tr><td data-num="16"></td><td><pre>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span></pre></td></tr><tr><td data-num="17"></td><td><pre>                stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>        <span class="token keyword">return</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="21"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h4 id="题外话-2"><a class="anchor" href="#题外话-2">#</a> 题外话</h4><p>我们习惯看到的表达式都是中缀表达式，因为符合我们的习惯，但是<strong>中缀表达式对于计算机来说就不是很友好</strong>。</p><p>例如：4 + 13 / 5，这就是中缀表达式，计算机从左到右去扫描的话，扫到 13，还要判断 13 后面是什么运算法，还要比较一下优先级，然后 13 还和后面的 5 做运算，做完运算之后，还要向前回退到 4 的位置，继续做加法，你说麻不麻烦！</p><p>那么将中缀表达式，转化为后缀表达式之后：[&quot;4&quot;, &quot;13&quot;, &quot;5&quot;, &quot;/&quot;, &quot;+&quot;] ，就不一样了。 <strong>后缀表达式对计算机来说是非常友好的，因为计算机可以利用栈里顺序处理，不需要考虑优先级了。也不用回退了。</strong></p><p>可以说本题不仅仅是一道好题，也展现出计算机的思考方式。</p><p>在 1970 年代和 1980 年代，惠普在其所有台式和手持式计算器中都使用了 RPN（后缀表达式），直到 2020 年代仍在某些模型中使用了 RPN。</p><p>参考维基百科如下：</p><blockquote><p>During the 1970s and 1980s, Hewlett-Packard used RPN in all of their desktop and hand-held calculators, and continued to use it in some models into the 2020s.</p></blockquote><h3 id="239-滑动窗口最大值"><a class="anchor" href="#239-滑动窗口最大值">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zbGlkaW5nLXdpbmRvdy1tYXhpbXVtLw==">239. 滑动窗口最大值</span></h3><blockquote><p>第一道 hard，要用啥数据结构呢？</p></blockquote><p>这是使用 **<mark> 单调队列</mark> ** 的经典题目。</p><p>难点是<strong>如何求一个区间里的最大值呢？</strong> （这好像是废话），暴力一下不就得了。</p><p>暴力方法，遍历一遍的过程中每次从窗口中在找到最大的数值，这样很明显是 O (n × k) 的算法。</p><p>有的同学可能会想用一个大顶堆（优先级队列）来存放这个窗口里的 k 个数字，这样就可以知道最大的最大值是多少了， <strong>但是问题是这个窗口是移动的，而大顶堆每次只能弹出最大值，我们无法移除其他数值，这样就造成大顶堆维护的不是滑动窗口里面的数值了。所以不能用大顶堆。</strong></p><p>此时我们需要一个队列，这个队列呢，放进去窗口里的元素，然后随着窗口的移动，队列也一进一出，每次移动之后，队列告诉我们里面的最大值是什么。</p><p>这个队列应该长这个样子：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">MyQueue</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">void</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">int</span> <span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token keyword">return</span> que<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>每次窗口移动的时候，调用 que.pop (滑动窗口中移除元素的数值)，que.push (滑动窗口添加元素的数值)，然后 que.front () 就返回我们要的最大值。</p><p>这么个队列香不香，要是有现成的这种数据结构是不是更香了！</p><p><strong>可惜了，没有！ 我们需要自己实现这么个队列。</strong></p><p>然后在分析一下，<strong>队列里的元素一定是要排序的，而且要最大值放在出队口</strong>，要不然怎么知道最大值呢。</p><p>但如果把窗口里的元素都放进队列里，窗口移动的时候，队列需要弹出元素。</p><p>那么问题来了，<strong>已经排序之后的队列 怎么能把窗口要移除的元素（这个元素可不一定是最大值）弹出呢。</strong></p><p>大家此时应该陷入深思.....</p><p><mark><strong>其实队列没有必要维护窗口里的所有元素，只需要维护有可能成为窗口里最大值的元素就可以了，同时保证队里的元素数值是由大到小的。</strong></mark></p><p>那么这个维护元素单调递减的队列就叫做<strong>单调队列，即单调递减或单调递增的队列。C++ 中没有直接支持单调队列，需要我们自己来一个单调队列</strong></p><p><strong>不要以为实现的单调队列就是对窗口里面的数进行排序，如果排序的话，那和优先级队列又有什么区别了呢。</strong></p><p>来看一下单调队列如何维护队列里的元素。</p><p>动画如下：</p><p><img data-src="https://code-thinking.cdn.bcebos.com/gifs/239.%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC.gif" alt="239.滑动窗口最大值"></p><p>对于窗口里的元素 {2, 3, 5, 1 ,4}，单调队列里只维护 {5, 4} 就够了，保持单调队列里单调递减，此时队列出口元素就是窗口里最大元素。</p><p>此时大家应该怀疑单调队列里维护着 {5, 4} 怎么配合窗口进行滑动呢？</p><p>设计单调队列的时候，<strong>pop，和 push 操作</strong>要保持如下规则：</p><ol><li>pop (value)：如果窗口移除的元素 value 等于单调队列的出口元素，那么队列弹出元素，否则不用任何操作</li><li>push (value)：如果 push 的元素 value 大于入口元素的数值，那么就将队列入口的元素弹出，直到 push 元素的数值小于等于队列入口元素的数值为止</li></ol><p>保持如上规则，每次窗口移动的时候，只要问 que.front () 就可以返回当前窗口的最大值。</p><p>为了更直观的感受到单调队列的工作过程，以题目示例为例，输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3，动画如下：</p><p><img data-src="https://code-thinking.cdn.bcebos.com/gifs/239.%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC-2.gif" alt="239.滑动窗口最大值-2"></p><p>那么我们用什么数据结构来实现这个单调队列呢？</p><p>使用 deque 最为合适，在文章<span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVyY2FybC5jb20vJUU2JUEwJTg4JUU0JUI4JThFJUU5JTk4JTlGJUU1JTg4JTk3JUU3JTkwJTg2JUU4JUFFJUJBJUU1JTlGJUJBJUU3JUExJTgwLmh0bWw=">栈与队列：来看看栈和队列不为人知的一面</span>中，我们就提到了常用的 queue。<strong>在没有指定容器的情况下，deque 就是默认底层容器。</strong></p><p>代码如下：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 自定义单调队列类（使用双端队列 deque 作为底层数据结构）</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">MonotonicQueue</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">private</span> <span class="token class-name">Deque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> deque<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">MonotonicQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        deque <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token comment">// 返回当前队列中的最大值</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getMax</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token keyword">return</span> deque<span class="token punctuation">.</span><span class="token function">peekFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//peekFirst () 方法返回队列头部元素</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token comment">// 向队列尾部添加元素</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token comment">// 从队尾开始，依次弹出比 n 小的元素，确保队列单调递减</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>deque<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> deque<span class="token punctuation">.</span><span class="token function">peekLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>            deque<span class="token punctuation">.</span><span class="token function">pollLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//pollLast () 方法弹出队列尾部元素，这就是 Deque 的好处</span></pre></td></tr><tr><td data-num="19"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>        deque<span class="token punctuation">.</span><span class="token function">offerLast</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//offerLast () 方法在队列尾部添加元素</span></pre></td></tr><tr><td data-num="21"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="22"></td><td><pre></pre></td></tr><tr><td data-num="23"></td><td><pre>    <span class="token comment">// 如果队列非空，且头部元素等于 n，则弹出头部元素，否则不做任何操作</span></pre></td></tr><tr><td data-num="24"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>deque<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> deque<span class="token punctuation">.</span><span class="token function">peekFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>            deque<span class="token punctuation">.</span><span class="token function">pollFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="29"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="30"></td><td><pre></pre></td></tr><tr><td data-num="31"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">maxSlidingWindow</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="33"></td><td><pre>        <span class="token class-name">MonotonicQueue</span> window <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MonotonicQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="34"></td><td><pre>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>nums<span class="token punctuation">.</span>length <span class="token operator">-</span> k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="35"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="36"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="37"></td><td><pre>                window<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 先填满窗口的前 k - 1</span></pre></td></tr><tr><td data-num="38"></td><td><pre>            <span class="token keyword">else</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="39"></td><td><pre>                window<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 窗口向前滑动</span></pre></td></tr><tr><td data-num="40"></td><td><pre>                res<span class="token punctuation">[</span>i <span class="token operator">-</span> k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> window<span class="token punctuation">.</span><span class="token function">getMax</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 记录窗口最大值</span></pre></td></tr><tr><td data-num="41"></td><td><pre>                window<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i <span class="token operator">-</span> k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 移除窗口最左侧元素</span></pre></td></tr><tr><td data-num="42"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="43"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="44"></td><td><pre>        <span class="token keyword">return</span> res<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="45"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="46"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>在来看一下时间复杂度，使用单调队列的<strong>时间复杂度是 O (n)</strong>。</p><p>有的同学可能想了，在队列中 push 元素的过程中，还有 pop 操作呢，感觉不是纯粹的 O (n)。</p><p>其实，大家可以自己观察一下单调队列的实现，nums 中的每个元素最多也就被 push_back 和 pop_back 各一次，没有任何多余操作，所以整体的复杂度还是 O (n)。</p><p><strong>空间复杂度因为我们定义一个辅助队列，所以是 O (k)</strong>。</p><p>大家貌似对单调队列 都有一些疑惑，首先要明确的是，题解中单调队列里的 pop 和 push 接口，仅适用于本题哈。<strong>单调队列不是一成不变的，而是不同场景不同写法，总之要保证队列里单调递减或递增的原则，所以叫做单调队列。</strong> 不要以为本题中的单调队列实现就是固定的写法哈。</p><p>大家貌似对 deque 也有一些疑惑，C++ 中 deque 是 stack 和 queue 默认的底层实现容器（这个我们之前已经讲过啦），deque 是可以两边扩展的，而且 deque 里元素并不是严格的连续分布的。</p><h3 id="347-前-k-个高频元素"><a class="anchor" href="#347-前-k-个高频元素">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy90b3Atay1mcmVxdWVudC1lbGVtZW50cy8=">347. 前 K 个高频元素</span></h3><blockquote><p>前 K 个大数问题，老生常谈，不得不谈</p></blockquote><p>这道题目主要涉及到如下三块内容：</p><ol><li><p><strong>要统计元素出现频率</strong></p><blockquote><p>使用哈希结构中的 map (映射)</p></blockquote></li><li><p><strong>对频率排序</strong></p><blockquote><ul><li>调用<strong>库函数</strong>，时间复杂度为 O (n*logn)</li><li>使用一种容器适配器：<strong>优先级队列</strong></li></ul></blockquote></li><li><p><strong>找出前 K 个高频元素</strong></p></li></ol><hr><p>调用<strong>库函数</strong>对频率进行排序的代码如下：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 用 map 存储元素，key 为元素，value 为出现的次数，对 map 的 value 进行排序，取前 k 个</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">topKFrequent</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">></span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> num <span class="token operator">:</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>            map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>num<span class="token punctuation">,</span> map<span class="token punctuation">.</span><span class="token function">getOrDefault</span><span class="token punctuation">(</span>num<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//map.getOrDefault (key, defaultValue)：如果 key 存在，返回 key 对应的 value，否则返回 defaultValue</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将 map 的 key 存入 list</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        list<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">(</span>o1<span class="token punctuation">,</span> o2<span class="token punctuation">)</span> <span class="token operator">-></span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>o2<span class="token punctuation">)</span> <span class="token operator">-</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>o1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 对 list 进行降序排序，按照 map 的 value 进行排序，时间复杂度为 O (nlogn)</span></pre></td></tr><tr><td data-num="11"></td><td><pre></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> k<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>            res<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="16"></td><td><pre></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token keyword">return</span> res<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20221215151132784.png" alt="image-20221215151132784"></p><p>可见效率是比较低的，主要原因是调用了库函数 sort () 对频率进行排序（假如是快速排序），时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>∗</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n*logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.01968em">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:.03588em">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。</p><hr><p>因此，最好使用<strong>优先级队列</strong>来对频率进行排序。什么是优先级队列呢？</p><p>其实<strong>就是一个披着队列外衣的堆</strong>，因为优先级队列 **<mark> 对外接口只是<u>从队头取元素</u>，<u>从队尾添加元素</u></mark>**，再无其他取元素的方式，看起来就是一个队列。</p><p>而且优先级队列<strong>内部元素是自动依照元素的权值排列</strong>。那么它是如何有序排列的呢？</p><p>缺省情况下 priority_queue 利用<strong> max-heap（大顶堆）<strong>完成对元素的排序，这个大顶堆是</strong>以 vector 为表现形式的 complete binary tree（完全二叉树）</strong>。</p><p>什么是堆呢？</p><p><strong>堆是一棵完全二叉树，树中每个结点的值都不小于（或不大于）其左右孩子的值。</strong> 如果父亲结点是大于等于左右孩子就是大顶堆，小于等于左右孩子就是小顶堆。</p><p>所以大家经常说的<strong>大顶堆（堆头是最大元素），小顶堆（堆头是最小元素）</strong>，如果懒得自己实现的话，就直接用 priority_queue（优先级队列）就可以了，底层实现都是一样的，从小到大排就是小顶堆，从大到小排就是大顶堆。</p><p>本题我们就要使用优先级队列来对部分频率进行排序。</p><p>为什么不用快排呢， 使用快排要将 map 转换为 vector 的结构，然后对整个数组进行排序， 而这种场景下，我们其实只需要维护 k 个有序的序列就可以了，所以使用优先级队列是最优的。</p><p>此时要思考一下，是使用小顶堆呢，还是大顶堆？</p><p>有的同学一想，题目要求前 K 个高频元素，那么果断用大顶堆啊。</p><p>那么问题来了，定义一个大小为 k 的大顶堆，在每次移动更新大顶堆的时候，每次弹出都把最大的元素弹出去了，那么怎么保留下来前 K 个高频元素呢。</p><p>而且使用大顶堆就要把所有元素都进行排序，那能不能只排序 k 个元素呢？</p><p><strong>所以我们要用小顶堆，因为要统计最大前 k 个元素，只有小顶堆每次将最小的元素弹出，最后小顶堆里积累的才是前 k 个最大元素。</strong></p><p>寻找前 k 个最大元素流程如图所示：（图中的频率只有三个，所以正好构成一个大小为 3 的小顶堆，如果频率更多一些，则用这个小顶堆进行扫描）</p><p><img data-src="https://code-thinking.cdn.bcebos.com/pics/347.%E5%89%8DK%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0.jpg" alt="347.前K个高频元素"></p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 使用小顶堆实现</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">topKFrequent</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">></span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 用 map 存储元素，key 为元素，value 为出现的次数</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> num <span class="token operator">:</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>            map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>num<span class="token punctuation">,</span> map<span class="token punctuation">.</span><span class="token function">getOrDefault</span><span class="token punctuation">(</span>num<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token class-name">PriorityQueue</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span> pq <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PriorityQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">(</span>pair1<span class="token punctuation">,</span> pair2<span class="token punctuation">)</span> <span class="token operator">-></span> pair1<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> pair2<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 小顶堆，存储二元组 (元素，出现的次数)</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">></span></span> entry <span class="token operator">:</span> map<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 遍历 map 中每对 (key:value)</span></pre></td></tr><tr><td data-num="11"></td><td><pre>            <span class="token keyword">int</span> num <span class="token operator">=</span> entry<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> count <span class="token operator">=</span> entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>pq<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> k<span class="token punctuation">)</span> <span class="token comment">// 如果堆中元素个数小于 k 个，直接将元素加入堆中</span></pre></td></tr><tr><td data-num="13"></td><td><pre>                pq<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">&#123;</span>num<span class="token punctuation">,</span> count<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//offer ()：将元素加入队列尾部</span></pre></td></tr><tr><td data-num="14"></td><td><pre>            <span class="token keyword">else</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 如果堆中元素个数大于等于 k 个</span></pre></td></tr><tr><td data-num="15"></td><td><pre>                <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">></span> pq<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 如果当前元素的出现次数大于堆顶元素的出现次数（即 k 个元素中出现次数最少的那个）</span></pre></td></tr><tr><td data-num="16"></td><td><pre>                    pq<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//poll ()：移除并返回队列头部的元素</span></pre></td></tr><tr><td data-num="17"></td><td><pre>                    pq<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">&#123;</span>num<span class="token punctuation">,</span> count<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将当前元素加入堆中</span></pre></td></tr><tr><td data-num="18"></td><td><pre>                <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="21"></td><td><pre></pre></td></tr><tr><td data-num="22"></td><td><pre>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 因为是小顶堆，所以需要将堆中元素逆序输出</span></pre></td></tr><tr><td data-num="24"></td><td><pre>            res<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> pq<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>        <span class="token keyword">return</span> res<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="28"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20221215222347580.png" alt="image-20221215222347580"></p><p>这时间效率一下就从 29.18% 飙到了 90.54%。因为<strong>使用小顶堆的时间复杂度是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n\log k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mop">lo<span style="margin-right:.01389em">g</span></span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal" style="margin-right:.03148em">k</span><span class="mclose">)</span></span></span></span></strong>，而<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>log</mi><mo>⁡</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">\log k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8888799999999999em;vertical-align:-.19444em"></span><span class="mop">lo<span style="margin-right:.01389em">g</span></span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal" style="margin-right:.03148em">k</span></span></span></span> 是常数项，比库函数的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mop">lo<span style="margin-right:.01389em">g</span></span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 强多了。</p><h3 id="总结-8"><a class="anchor" href="#总结-8">#</a> 总结</h3><p>栈与队列是我们熟悉的不能再熟悉的数据结构，但它们的底层实现，很多同学都比较模糊，这其实就是基础所在。</p><p>可以出一道面试题：<strong>栈里面的元素在内存中是连续分布的么？</strong></p><p>这个问题有两个陷阱：</p><ul><li>陷阱 1：栈是容器适配器，<strong>底层容器使用不同的容器</strong>，导致栈内数据在内存中是不是连续分布。</li><li>陷阱 2：缺省情况下，<strong>默认底层容器是 deque</strong>，那么 deque 的在内存中的数据分布是什么样的呢？ 答案是：不连续的，下文也会提到 deque。</li></ul><p>所以这就是考察候选者基础知识扎不扎实的好问题。</p><p>大家还是要多多重视起来！</p><p>了解了栈与队列基础之后，那么可以用<span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVyY2FybC5jb20vMDIzMi4lRTclOTQlQTglRTYlQTAlODglRTUlQUUlOUUlRTclOEUlQjAlRTklOTglOUYlRTUlODglOTcuaHRtbA==">栈与队列：栈实现队列 </span>和 <span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVyY2FybC5jb20vMDIyNS4lRTclOTQlQTglRTklOTglOUYlRTUlODglOTclRTUlQUUlOUUlRTclOEUlQjAlRTYlQTAlODguaHRtbA==">栈与队列：队列实现栈 </span>来练习一下栈与队列的基本操作。</p><p>值得一提的是，用<span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVyY2FybC5jb20vMDIyNS4lRTclOTQlQTglRTklOTglOUYlRTUlODglOTclRTUlQUUlOUUlRTclOEUlQjAlRTYlQTAlODguaHRtbA==">栈与队列：用队列实现栈还有点别扭 </span>中，其实只用一个队列就够了。</p><p><strong>一个队列在模拟栈弹出元素的时候只要将队列头部的元素（除了最后一个元素外） 重新添加到队列尾部，此时在去弹出元素就是栈的顺序了。</strong></p><h4 id="栈经典题目"><a class="anchor" href="#栈经典题目">#</a> 栈 —— 经典题目</h4><h5 id="栈在系统中的应用"><a class="anchor" href="#栈在系统中的应用">#</a> 栈在系统中的应用</h5><p>如果还记得编译原理的话，编译器在 词法分析的过程中处理括号、花括号等这个符号的逻辑，就是使用了栈这种数据结构。</p><p>再举个例子，linux 系统中，cd 这个进入目录的命令我们应该再熟悉不过了。</p><figure class="highlight text"><figcaption data-lang="text"></figcaption><table><tr><td data-num="1"></td><td><pre>cd a/b/c/../../</pre></td></tr></table></figure><p>这个命令最后进入 a 目录，系统是如何知道进入了 a 目录呢 ，这就是栈的应用。<strong>这在 leetcode 上也是一道题目，编号：71. 简化路径，大家有空可以做一下。</strong></p><p><strong>递归的实现是栈：每一次递归调用都会把函数的局部变量、参数值和返回地址等压入调用栈中</strong>，然后递归返回的时候，从栈顶弹出上一次递归的各项参数，所以这就是递归为什么可以返回上一层位置的原因。</p><p>所以栈在计算机领域中应用是非常广泛的。</p><p>有的同学经常会想学的这些数据结构有什么用，也开发不了什么软件，大多数同学说的软件应该都是可视化的软件例如 APP、网站之类的，那都是非常上层的应用了，底层很多功能的实现都是基础的数据结构和算法。</p><p><strong>所以数据结构与算法的应用往往隐藏在我们看不到的地方！</strong></p><h5 id="括号匹配问题20-有效的括号"><a class="anchor" href="#括号匹配问题20-有效的括号">#</a> [括号匹配问题](#20. 有效的括号)</h5><p>建议要<strong>写代码之前要分析好有哪几种不匹配的情况</strong>，如果不动手之前分析好，写出的代码也会有很多问题。</p><p>先来分析一下 这里有三种不匹配的情况，</p><ol><li>第一种情况，字符串里<u>左方向的括号多余</u>了 ，所以不匹配。</li><li>第二种情况，括号没有多余，但是<u>括号的类型没有匹配上</u>。</li><li>第三种情况，字符串里<u>右方向的括号多余</u>了，所以不匹配。</li></ol><p>这里还有一些技巧，在匹配左括号的时候，右括号先入栈，就只需要比较当前元素和栈顶相不相等就可以了，比左括号先入栈代码实现要简单的多了！</p><p><img data-src="https://code-thinking.cdn.bcebos.com/gifs/20.%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7.gif" alt="20.有效括号"></p><h5 id="字符串去重问题1047-删除字符串中的所有相邻重复项"><a class="anchor" href="#字符串去重问题1047-删除字符串中的所有相邻重复项">#</a> [字符串去重问题](#1047. 删除字符串中的所有相邻重复项)</h5><p>思路：把字符串按顺序放到一个栈中，放之前与栈顶字符比较，然后如果相同的话栈就弹出，这样最后栈里剩下的元素都是相邻不相同的元素了。</p><p><img data-src="https://code-thinking.cdn.bcebos.com/gifs/1047.%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E7%9B%B8%E9%82%BB%E9%87%8D%E5%A4%8D%E9%A1%B9.gif" alt="1047.删除字符串中的所有相邻重复项"></p><h5 id="逆波兰表达式问题150-逆波兰表达式求值"><a class="anchor" href="#逆波兰表达式问题150-逆波兰表达式求值">#</a> [逆波兰表达式问题](#150. 逆波兰表达式求值)</h5><p>思路：<strong>遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中</strong>。</p><p><img data-src="https://code-thinking.cdn.bcebos.com/gifs/150.%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC.gif" alt="150.逆波兰表达式求值"></p><h4 id="队列经典题目"><a class="anchor" href="#队列经典题目">#</a> 队列 —— 经典题目</h4><h5 id="滑动窗口最大值问题239-滑动窗口最大值"><a class="anchor" href="#滑动窗口最大值问题239-滑动窗口最大值">#</a> [滑动窗口最大值问题](#239. 滑动窗口最大值)</h5><p>使用 ==<strong> 单调队列</strong> ==，主要思想是<strong>队列没有必要维护窗口里的所有元素，只需要维护有可能成为窗口里最大值的元素就可以了，同时保证队列里的元素数值是由大到小的。</strong></p><p>那么这个维护元素单调递减的队列就叫做<strong>单调队列，即单调递减或单调递增的队列。C++ 中没有直接支持单调队列，需要我们自己来一个单调队列</strong></p><p>而且<strong>不要以为实现的单调队列就是对窗口里面的数进行排序，如果排序的话，那和优先级队列又有什么区别了呢。</strong></p><p>设计单调队列的时候，pop，和 push 操作要保持如下规则：</p><ol><li><strong>pop(value)</strong>：如果窗口移除的元素 value 等于单调队列的出口元素，那么队列弹出元素，否则不用任何操作</li><li><strong>push(value)</strong>：如果 push 的元素 value 大于入口元素的数值，那么就将队列出口的元素弹出，直到 push 元素的数值小于等于队列入口元素的数值为止</li></ol><p>保持如上规则，每次窗口移动的时候，<strong>只要问 que.front () 就可以返回当前窗口的最大值</strong>。</p><p>一些同学还会对单调队列都有一些困惑，首先要明确的是，<strong>题解中单调队列里的 pop 和 push 接口，仅适用于本题。</strong></p><p><strong>单调队列不是一成不变的，而是不同场景不同写法</strong>，总之要保证队列里单调递减或递增的原则，所以叫做单调队列。</p><p><strong>不要以为本地中的单调队列实现就是固定的写法。</strong></p><p>我们用 deque 作为单调队列的底层数据结构，C++ 中 deque 是 stack 和 queue 默认的底层实现容器（这个我们之前已经讲过），deque 是可以两边扩展的，而且 deque 里元素并不是严格的连续分布的。</p><p><img data-src="https://code-thinking.cdn.bcebos.com/gifs/239.%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC-2.gif" alt="239.滑动窗口最大值-2"></p><h5 id="求前k个高频元素"><a class="anchor" href="#求前k个高频元素">#</a> 求前 k 个高频元素</h5><p>通过求前 K 个高频元素，引出另一种队列就是 **<mark> 优先级队列</mark> **。</p><p>什么是优先级队列呢？</p><p>其实<strong>就是一个披着队列外衣的<mark>堆</mark></strong>，因为优先级队列对<strong>外接口只是：从队头取元素，从队尾添加元素</strong>，再无其他取元素的方式，看起来就是一个队列。</p><p>而且优先级队列<strong>内部元素是自动依照元素的权值排列</strong>。那么它是如何有序排列的呢？</p><p>缺省情况下 priority_queue 利用 max-heap（大顶堆）完成对元素的排序，这个大顶堆是以 vector 为表现形式的 complete binary tree（完全二叉树）。</p><p>什么是堆呢？</p><p><strong>堆是一棵完全二叉树，树中每个结点的值都不小于（或不大于）其左右孩子的值。</strong> 如果父亲结点是大于等于左右孩子就是大顶堆，小于等于左右孩子就是小顶堆。</p><p>所以大家经常说的大顶堆（堆头是最大元素），小顶堆（堆头是最小元素），如果懒得自己实现的话，就直接用 priority_queue（优先级队列）就可以了，底层实现都是一样的，从小到大排就是小顶堆，从大到小排就是大顶堆。</p><p>本题就要<strong>使用优先级队列来对部分频率进行排序。</strong> 注意这里是对部分数据进行排序而不需要对所有数据排序！</p><p>所以排序的过程的时间复杂度是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:.01389em">g</span></span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal" style="margin-right:.03148em">k</span><span class="mclose">)</span></span></span></span>，<strong>整个算法的时间复杂度是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n\log k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mop">lo<span style="margin-right:.01389em">g</span></span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal" style="margin-right:.03148em">k</span><span class="mclose">)</span></span></span></span></strong>。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20221215230845690.png" alt="image-20221215230845690"></p><h4 id="小结-2"><a class="anchor" href="#小结-2">#</a> 小结</h4><p>在栈与队列系列中，我们强调栈与队列的基础，也是很多同学容易忽视的点。</p><p>使用抽象程度越高的语言，越容易忽视其底层实现，而 C++ 相对来说是比较接近底层的语言。</p><p>我们用栈实现队列，用队列实现栈来掌握的栈与队列的基本操作。</p><p>接着，通过括号匹配问题、字符串去重问题、逆波兰表达式问题来系统讲解了栈在系统中的应用，以及使用技巧。</p><p>通过求滑动窗口最大值，以及前 K 个高频元素介绍了两种队列：单调队列和优先级队列，这是特殊场景解决问题的利器，是一定要掌握的。</p><p>好了，栈与队列我们就总结到这里了，接下来 Carl 就要带大家开启新的篇章了，大家加油！</p><h2 id="二叉树"><a class="anchor" href="#二叉树">#</a> 二叉树</h2><h3 id="二叉树的理论基础"><a class="anchor" href="#二叉树的理论基础">#</a> 二叉树的理论基础</h3><p><img data-src="https://img-blog.csdnimg.cn/20210219190809451.png" alt="二叉树大纲"></p><h4 id="种类"><a class="anchor" href="#种类">#</a> 种类</h4><hr><p>在我们解题过程中二叉树有两种主要的形式：满二叉树和完全二叉树。</p><h5 id="满二叉树"><a class="anchor" href="#满二叉树">#</a> 满二叉树</h5><p>如果一棵二叉树只有<strong>度为 0</strong> 的结点和<strong>度为 2</strong> 的结点，并且<strong>度为 0 的结点在同一层上</strong>，则这棵二叉树为满二叉树。</p><p>如图所示：</p><p><img data-src="https://img-blog.csdnimg.cn/20200806185805576.png" alt="img"></p><p>这棵二叉树为满二叉树，也可以说<strong>深度为 k，有 2<sup>k</sup>-1 个节点</strong>的二叉树。</p><h5 id="完全二叉树"><a class="anchor" href="#完全二叉树">#</a> 完全二叉树</h5><blockquote><p>满二叉树是完全二叉树</p></blockquote><p>在完全二叉树中，<strong>除了最底层节点可能没填满外，其余每层节点数都达到最大值</strong>，并且<strong>最下面一层的节点都集中在该层最左边</strong>的若干位置。<strong>若最底层为第 h 层，则该层包含 1~ 2<sup>(h-1)</sup> 个节点</strong>。</p><p>大家要自己看完全二叉树的定义，很多同学对完全二叉树其实不是真正的懂了。</p><p>我来举一个典型的例子如题：</p><p><img data-src="https://img-blog.csdnimg.cn/20200920221638903.png" alt="img"></p><p>相信不少同学最后一个二叉树是不是完全二叉树都中招了。</p><p><strong>之前我们刚刚讲过优先级队列其实是一个堆，堆就是一棵完全二叉树，同时保证父子节点的顺序关系。</strong></p><h5 id="二叉搜索树"><a class="anchor" href="#二叉搜索树">#</a> 二叉搜索树</h5><p>前面介绍的树，都没有数值的，而<strong>二叉搜索树是<mark>有数值</mark>的</strong>了，<strong>二叉搜索树是一个<mark>有序</mark>树</strong>。</p><ul><li><p>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</p></li><li><p>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</p></li><li><p>它的左、右子树也分别为二叉排序树</p><blockquote><p>二叉搜索树，也称二叉排序树、二叉查找树；</p><p>树的定义中常见的 “递归定义”；</p></blockquote></li></ul><p>下面这两棵树都是搜索树<img data-src="https://img-blog.csdnimg.cn/20200806190304693.png" alt="img"></p><h5 id="平衡二叉搜索树"><a class="anchor" href="#平衡二叉搜索树">#</a> 平衡二叉搜索树</h5><p>又被称为<strong> AVL（Adelson-Velsky and Landis）树</strong>，且具有以下性质：它是<strong>一棵空树</strong>或它的<strong>左右两个子树的高度差的绝对值不超过 1</strong>，并且左右两个子树都是一棵平衡二叉树。</p><p>如图：</p><p><img data-src="https://img-blog.csdnimg.cn/20200806190511967.png" alt="img"></p><p>最后一棵 不是平衡二叉树，因为它的左右两个子树的高度差的绝对值超过了 1。</p><p><strong>C++ 中 map、set、multimap，multiset 的底层实现都是平衡二叉搜索树</strong>，所以 map、set 的增删操作时间时间复杂度是 logn，注意我这里没有说 unordered_map、unordered_set，unordered_map、unordered_map 底层实现是哈希表。</p><p><strong>所以大家使用自己熟悉的编程语言写算法，一定要知道常用的容器底层都是如何实现的，最基本的就是 map、set 等等，否则自己写的代码，自己对其性能分析都分析不清楚！</strong></p><h4 id="存储方式-2"><a class="anchor" href="#存储方式-2">#</a> 存储方式</h4><hr><p>二叉树可以链式存储，也可以顺序存储。</p><p>那么<strong>链式存储方式就用<mark>指针</mark>， 顺序存储的方式就是用<mark>数组</mark>。</strong></p><p>顾名思义就是顺序存储的元素在内存是连续分布的，而链式存储则是通过指针把分布在散落在各个地址的节点串联一起。</p><ul><li>链式存储如图：</li></ul><p><img data-src="https://img-blog.csdnimg.cn/2020092019554618.png" alt="img"></p><p>​	链式存储是大家很熟悉的一种方式，那么我们来看看如何顺序存储呢？</p><ul><li>其实就是用数组来存储二叉树，顺序存储的方式如图：</li></ul><p><img data-src="https://img-blog.csdnimg.cn/20200920200429452.png" alt="img"></p><p>​	用数组来存储二叉树如何遍历的呢？</p><p>​	<strong>如果父节点的数组下标是 i，那么它的左孩子就是 i * 2 + 1，右孩子就是 i * 2 + 2。</strong></p><p>但是用链式表示的二叉树，更有利于我们理解，所以<strong>一般我们都是用链式存储二叉树</strong>。</p><p><strong>所以大家要了解，用数组依然可以表示二叉树。</strong></p><h4 id="遍历方式"><a class="anchor" href="#遍历方式">#</a> 遍历方式</h4><hr><p>二叉树主要有两种遍历方式：</p><ol><li>深度优先遍历：先往深走，遇到叶子节点再往回走。</li><li>广度优先遍历：一层一层的去遍历。</li></ol><p><strong>这两种遍历是图论中最基本的两种遍历方式</strong>，后面在介绍图论的时候 还会介绍到。</p><p>那么从深度优先遍历和广度优先遍历进一步拓展，才有如下遍历方式：</p><ul><li>深度优先遍历<ul><li>前序遍历（递归法，迭代法）</li><li>中序遍历（递归法，迭代法）</li><li>后序遍历（递归法，迭代法）</li></ul></li><li>广度优先遍历<ul><li>层次遍历（迭代法）</li></ul></li></ul><p>在深度优先遍历中：有三个顺序，前中后序遍历， 有同学总分不清这三个顺序，经常搞混，我这里教大家一个技巧。</p><p><strong>这里前中后，其实指的就是根节点的遍历顺序</strong>，只要大家记住前中后序指的就是根节点的位置就可以了。</p><p>看如下根节点的顺序，就可以发现，根节点的顺序就是所谓的遍历方式</p><ul><li>前序遍历：中左右</li><li>中序遍历：左中右</li><li>后序遍历：左右中</li></ul><p>大家可以对着如下图，看看自己理解的前后中序有没有问题。</p><p><img data-src="https://img-blog.csdnimg.cn/20200806191109896.png" alt="img"></p><p>最后再说一说二叉树中深度优先和广度优先遍历实现方式，我们做二叉树相关题目，<strong>经常会使用<u>递归</u>的方式来实现深度优先遍历</strong>，也就是实现前中后序遍历，使用递归是比较方便的。</p><p><strong>之前我们讲栈与队列的时候，就说过栈其实就是递归的一种是实现结构</strong>，也就说前中后序遍历的逻辑其实都是<strong>可以借助<u>栈</u>使用非递归的方式来实现的</strong>。</p><p>而<strong>广度优先遍历的实现一般使用<u>队列</u>来实现</strong>，这也是队列先进先出的特点所决定的，因为需要先进先出的结构，才能一层一层的来遍历二叉树。</p><p><strong>这里其实我们又了解了栈与队列的一个应用场景了。</strong></p><p>具体的实现我们后面都会讲的，这里大家先要清楚这些理论基础。</p><h4 id="定义"><a class="anchor" href="#定义">#</a> 定义</h4><hr><p>链式存储的二叉树节点的定义方式：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TreeNode</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">int</span> val<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token class-name">TreeNode</span> left<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token class-name">TreeNode</span> right<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token class-name">TreeNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token class-name">TreeNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token keyword">this</span><span class="token punctuation">.</span>val <span class="token operator">=</span> val<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token class-name">TreeNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> val<span class="token punctuation">,</span> <span class="token class-name">TreeNode</span> left<span class="token punctuation">,</span> <span class="token class-name">TreeNode</span> right<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token keyword">this</span><span class="token punctuation">.</span>val <span class="token operator">=</span> val<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token keyword">this</span><span class="token punctuation">.</span>left <span class="token operator">=</span> left<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token keyword">this</span><span class="token punctuation">.</span>right <span class="token operator">=</span> right<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>大家会发现二叉树的定义和链表是差不多的，相对于链表 ，二叉树的节点里多了一个指针， 有两个指针，指向左右孩子。</p><p>这里要提醒大家要注意二叉树节点定义的书写方式。</p><p><strong>在现场面试的时候 面试官可能要求手写代码，所以数据结构的定义以及简单逻辑的代码一定要锻炼白纸写出来。</strong></p><p>因为我们在刷 leetcode 的时候，节点的定义默认都定义好了，真到面试的时候，需要自己写节点定义的时候，有时候会一脸懵逼！</p><h4 id="总结-9"><a class="anchor" href="#总结-9">#</a> 总结</h4><hr><p>二叉树是一种基础数据结构，在算法面试中都是常客，也是众多数据结构的基石。</p><p>本篇我们介绍了二叉树的种类、存储方式、遍历方式以及定义，比较全面的介绍了二叉树各个方面的重点，帮助大家扫一遍基础。</p><p><strong>说到二叉树，就不得不说递归，很多同学对递归都是又熟悉又陌生，递归的代码一般很简短，但每次都是一看就会，一写就废。</strong></p><h3 id="二叉树的递归遍历"><a class="anchor" href="#二叉树的递归遍历">#</a> 二叉树的递归遍历</h3><blockquote><p>一看就会，一写就废！</p></blockquote><p>这次我们要好好谈一谈递归，为什么很多同学看递归算法都是 “一看就会，一写就废”。</p><p>主要是对递归不成体系，没有方法论，每次写递归算法 ，都是靠玄学来写代码，代码能不能编过都靠运气。</p><p>本篇将介绍前后中序的递归写法，一些同学可能会感觉很简单，其实不然，我们要通过简单题目把方法论确定下来，有了方法论，后面才能应付复杂的递归。</p><p>这里帮助大家确定下来递归算法的三个要素。<strong>每次写递归，都按照这三要素来写，可以保证大家写出正确的递归算法！</strong></p><ol><li><strong>确定递归函数的<u>参数</u>和<u>返回值</u>：</strong> 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。</li><li><strong>确定<u>终止条件</u>：</strong> 写完了递归算法，运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。</li><li><strong>确定<u>单层递归的逻辑</u>：</strong> 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。</li></ol><hr><p>好了，我们确认了递归的三要素，接下来就来练练手：</p><p><strong>以下以前序遍历为例：</strong></p><ol><li><p><strong>确定递归函数的参数和返回值</strong>：因为要打印出前序遍历节点的数值，所以参数里需要<strong>传入 List 来存放各个节点的数值</strong>，除了这一点就不需要在处理什么数据了也<strong>不需要有返回值</strong>，所以递归函数返回类型就是 void，代码如下：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">preorder</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> cur<span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> res<span class="token punctuation">)</span></pre></td></tr></table></figure></li><li><p><strong>确定终止条件</strong>：在递归的过程中，如何算是递归结束了呢，当然是当前遍历的节点是空了，那么本层递归就要要结束了，所以如果当前遍历的这个节点是空，就直接 return，代码如下：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">if</span> <span class="token punctuation">(</span>cur <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre>	<span class="token keyword">return</span><span class="token punctuation">;</span></pre></td></tr></table></figure></li><li><p><strong>确定单层递归的逻辑</strong>：前序遍历是中左右的循序，所以在单层递归的逻辑，是要先取中节点的数值，代码如下：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre>res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 首先访问根节点</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">preorder</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>left<span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 递归访问左子树</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token function">preorder</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>right<span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 递归访问右子树</span></pre></td></tr></table></figure></li></ol><p>单层递归的逻辑就是按照中左右的顺序来处理的，这样二叉树的前序遍历，基本就写完了，再看一下完整代码：</p><h4 id="前序遍历递归"><a class="anchor" href="#前序遍历递归">#</a> 前序遍历（递归）</h4><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">preorder</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> cur<span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> res<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>cur <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token keyword">return</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 首先访问根节点</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token function">preorder</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>left<span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 递归访问左子树</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token function">preorder</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>right<span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 递归访问右子树</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h4 id="中序遍历递归"><a class="anchor" href="#中序遍历递归">#</a> 中序遍历（递归）</h4><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">inorder</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> cur<span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> res<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>cur <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token keyword">return</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token function">inorder</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>left<span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 递归访问左子树</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 访问根节点</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token function">inorder</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>right<span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 递归访问右子树</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h4 id="后序遍历递归"><a class="anchor" href="#后序遍历递归">#</a> 后序遍历（递归）</h4><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">postorder</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> cur<span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> res<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>cur <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token keyword">return</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token function">postorder</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>left<span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 递归访问左子树</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token function">postorder</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>right<span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 递归访问右子树</span></pre></td></tr><tr><td data-num="6"></td><td><pre>	res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 访问根节点</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><hr><p>下面看一下 leetcode 上三道题目，分别是：</p><ul><li><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iaW5hcnktdHJlZS1wcmVvcmRlci10cmF2ZXJzYWwv">144. 二叉树的前序遍历</span></p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 递归</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">preorder</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> cur<span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> res<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>cur <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre>            <span class="token keyword">return</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 首先访问根节点</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token function">preorder</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>left<span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 递归访问左子树</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token function">preorder</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>right<span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 递归访问右子树</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> <span class="token function">preorderTraversal</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token function">preorder</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token keyword">return</span> res<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure></li><li><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iaW5hcnktdHJlZS1wb3N0b3JkZXItdHJhdmVyc2FsLw==">145. 二叉树的后序遍历</span></p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">postorder</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> cur<span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> res<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>cur <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre>            <span class="token keyword">return</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token function">postorder</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>left<span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token function">postorder</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>right<span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> <span class="token function">postorderTraversal</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token function">postorder</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token keyword">return</span> res<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure></li><li><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iaW5hcnktdHJlZS1pbm9yZGVyLXRyYXZlcnNhbC8=">94. 二叉树的中序遍历</span></p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">inorder</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> cur<span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> res<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>cur <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre>            <span class="token keyword">return</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token function">inorder</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>left<span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token function">inorder</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>right<span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> <span class="token function">inorderTraversal</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token function">inorder</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token keyword">return</span> res<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure></li></ul><p>可能有同学感觉前后中序遍历的递归太简单了，要打迭代法（非递归），别急，我们明天打迭代法，打个通透</p><h3 id="二叉树的迭代遍历"><a class="anchor" href="#二叉树的迭代遍历">#</a> 二叉树的迭代遍历</h3><blockquote><p>听说还可以用非递归的方式 —— 栈</p></blockquote><p>为什么可以用迭代法（非递归的方式）来实现二叉树的前后中序遍历呢？</p><p>我们在<span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVyY2FybC5jb20vMTA0Ny4lRTUlODglQTAlRTklOTklQTQlRTUlQUQlOTclRTclQUMlQTYlRTQlQjglQjIlRTQlQjglQUQlRTclOUElODQlRTYlODklODAlRTYlOUMlODklRTclOUIlQjglRTklODIlQkIlRTklODclOEQlRTUlQTQlOEQlRTklQTElQjkuaHRtbA==">栈与队列：匹配问题都是栈的强项</span>中提到了，<strong>递归的实现就是：每一次递归调用都会把函数的局部变量、参数值和返回地址等压入调用栈中</strong>，然后递归返回的时候，从栈顶弹出上一次递归的各项参数，所以这就是递归为什么可以返回上一层位置的原因。</p><p>此时大家应该知道我们用<mark>栈</mark>也可以是实现二叉树的前后中序遍历了。</p><h4 id="前序遍历迭代"><a class="anchor" href="#前序遍历迭代">#</a> 前序遍历（迭代）</h4><p>前序遍历是中左右，每次先处理的是中间节点，那么<strong>先将根节点放入栈中，然后将<u>右孩子</u>加入栈，再加入左孩子</strong>。</p><p>为什么要先加入 右孩子，再加入左孩子呢？ 因为这样出栈的时候才是中左右的顺序。</p><p>动画如下：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/008eGmZEly1gnbmss7603g30eq0d4b2a.gif" alt="二叉树前序遍历（迭代法）"></p><p>不难写出如下代码: （<strong>注意代码中空节点不入栈</strong>）</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 迭代实现前序遍历</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> <span class="token function">preorderTraversal</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre>            <span class="token keyword">return</span> res<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TreeNode</span><span class="token punctuation">></span></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>            <span class="token class-name">TreeNode</span> node <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>            res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将栈顶元素的值添加到结果集</span></pre></td></tr><tr><td data-num="13"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token comment">// 先压入右子树</span></pre></td></tr><tr><td data-num="14"></td><td><pre>                stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token comment">// 再压入左子树</span></pre></td></tr><tr><td data-num="16"></td><td><pre>                stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>        <span class="token keyword">return</span> res<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>此时会发现貌似使用迭代法写出前序遍历并不难，确实不难。</p><p><strong>此时是不是想改一点前序遍历代码顺序就把中序遍历搞出来了？</strong></p><p>其实还真不行！</p><p>但接下来，<strong>再用迭代法写中序遍历的时候，会发现套路又不一样了，目前的前序遍历的逻辑无法直接应用到中序遍历上。</strong></p><h4 id="中序遍历迭代"><a class="anchor" href="#中序遍历迭代">#</a> 中序遍历（迭代）</h4><p>为了解释清楚，我说明一下 刚刚在迭代的过程中，其实我们有两个操作：</p><ol><li><strong>处理：将元素放进 result 数组中</strong></li><li><strong>访问：遍历节点</strong></li></ol><p>分析一下为什么刚刚写的前序遍历的代码，不能和中序遍历通用呢，因为前序遍历的顺序是中左右，先访问的元素是中间节点，要处理的元素也是中间节点，所以刚刚才能写出相对简洁的代码，<strong>因为要访问的元素和要处理的元素顺序是一致的，都是中间节点。</strong></p><p>那么再看看中序遍历，中序遍历是左中右，先访问的是二叉树顶部的节点，然后一层一层向下访问，直到到达树左面的最底部，再开始处理节点（也就是在把节点的数值放进 result 数组中），这就造成了<strong>处理顺序和访问顺序是不一致的。</strong></p><p>那么<strong>在使用迭代法写中序遍历，就需要借用<mark>指针的遍历</mark>来帮助<u>访问</u>节点，<mark>栈</mark>则用来<u>处理</u>节点上的元素。</strong></p><p>动画如下：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/%25E4%25BA%258C%25E5%258F%2589%25E6%25A0%2591%25E4%25B8%25AD%25E5%25BA%258F%25E9%2581%258D%25E5%258E%2586%25EF%25BC%2588%25E8%25BF%25AD%25E4%25BB%25A3%25E6%25B3%2595%25EF%25BC%2589.gif" alt="二叉树中序遍历（迭代法）"></p><p><strong>中序遍历，可以写出如下代码：</strong></p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 迭代实现中序遍历：左根右</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> <span class="token function">inorderTraversal</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TreeNode</span><span class="token punctuation">></span></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 用于存放节点</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token class-name">TreeNode</span> cur <span class="token operator">=</span> root<span class="token punctuation">;</span> <span class="token comment">// 用于遍历节点</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token keyword">while</span> <span class="token punctuation">(</span>cur <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 节点不为空 / 栈不为空</span></pre></td></tr><tr><td data-num="9"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>cur <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>                stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将节点压入栈</span></pre></td></tr><tr><td data-num="11"></td><td><pre>                cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>left<span class="token punctuation">;</span> <span class="token comment">// 一路向左</span></pre></td></tr><tr><td data-num="12"></td><td><pre>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span> <span class="token comment">//cur == null 意味着已经到达最左边的节点</span></pre></td></tr><tr><td data-num="13"></td><td><pre>                cur <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 弹出栈顶元素，同时 cur 回退</span></pre></td></tr><tr><td data-num="14"></td><td><pre>                res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 根</span></pre></td></tr><tr><td data-num="15"></td><td><pre>                cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>right<span class="token punctuation">;</span> <span class="token comment">// 右</span></pre></td></tr><tr><td data-num="16"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token punctuation">&#125;</span> <span class="token comment">// 此时栈为空，且 cur 为 null，遍历结束</span></pre></td></tr><tr><td data-num="18"></td><td><pre>        <span class="token keyword">return</span> res<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h4 id="后续遍历迭代"><a class="anchor" href="#后续遍历迭代">#</a> 后续遍历（迭代）</h4><p>再来看后序遍历，先序遍历是中左右，后续遍历是左右中，那么我们<strong>只需要调整一下先序遍历的代码顺序</strong>，就变成中右左的遍历顺序，然后在反转 result 数组，输出的结果顺序就是左右中了，如下图：</p><p><img data-src="https://img-blog.csdnimg.cn/20200808200338924.png" alt="前序到后序"></p><p><strong>所以后序遍历只需要前序遍历的代码稍作修改就可以了，代码如下：</strong></p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 迭代实现后序遍历：左右根</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> <span class="token function">postorderTraversal</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>            <span class="token keyword">return</span> res<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TreeNode</span><span class="token punctuation">></span></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>            <span class="token class-name">TreeNode</span> node <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>            res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 先压入左子树</span></pre></td></tr><tr><td data-num="15"></td><td><pre>                stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 再压入右子树</span></pre></td></tr><tr><td data-num="18"></td><td><pre>                stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>        <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 反转结果集</span></pre></td></tr><tr><td data-num="22"></td><td><pre>        <span class="token keyword">return</span> res<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="24"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20221216115213773.png" alt="image-20221216115213773"></p><h4 id="总结-10"><a class="anchor" href="#总结-10">#</a> 总结</h4><p>此时我们用迭代法写出了二叉树的前后中序遍历，大家可以看出前序和中序是完全两种代码风格，并不像递归写法那样代码稍做调整，就可以实现前后中序。</p><p><strong>这是因为前序遍历中访问节点（遍历节点）和处理节点（将元素放进 result 数组中）可以同步处理，但是中序就无法做到同步！</strong></p><p>上面这句话，可能一些同学不太理解，建议自己亲手用迭代法，先写出来前序，再试试能不能写出中序，就能理解了。</p><p><strong>那么问题又来了，难道 二叉树前后中序遍历的迭代法实现，就不能风格统一么（即前序遍历 改变代码顺序就可以实现中序 和 后序）？</strong></p><p>当然可以，这种写法，还不是很好理解，我们将在下一篇文章里重点讲解，敬请期待！</p><h3 id="二叉树的统一迭代法"><a class="anchor" href="#二叉树的统一迭代法">#</a> ☆二叉树的统一迭代法</h3><p>此时我们在<a href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86">二叉树的递归遍历</a>中用<strong>递归</strong>的方式，实现了二叉树前中后序的遍历。</p><p>在<a href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%86">二叉树的迭代遍历</a>中用栈实现了二叉树前后中序的<strong>迭代</strong>遍历（非递归）。</p><p>之后我们发现<strong>迭代法实现的先中后序，其实风格也不是那么统一，除了先序和后序，有关联，中序完全就是另一个风格了，一会用栈遍历，一会又用指针来遍历。</strong></p><p>实践过的同学，也会发现使用迭代法实现先中后序遍历，很难写出统一的代码，不像是递归法，实现了其中的一种遍历方式，其他两种只要稍稍改一下节点顺序就可以了。</p><p>其实<strong>针对三种遍历方式，使用迭代法是可以写出统一风格的代码！</strong></p><p><strong>重头戏来了，接下来介绍一下统一写法。</strong></p><p>我们以中序遍历为例，在<a href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%86">二叉树的迭代遍历</a>中提到说使用栈的话，<strong>无法同时解决访问节点（遍历节点）和处理节点（将元素放进结果集）不一致的情况</strong>。</p><p><strong>那我们就将访问的节点放入栈中，把要处理的节点也放入栈中但是要做标记。</strong></p><p>如何标记呢，<strong>就是要处理的节点放入栈之后，紧接着放入一个空指针作为标记。</strong> 这种方法也可以叫做 ==<strong> 标记法</strong> ==。</p><h4 id="中序遍历统一迭代"><a class="anchor" href="#中序遍历统一迭代">#</a> 中序遍历（统一迭代）</h4><p>先来看一下动画 (中序遍历)：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/%25E4%25B8%25AD%25E5%25BA%258F%25E9%2581%258D%25E5%258E%2586%25E8%25BF%25AD%25E4%25BB%25A3%25EF%25BC%2588%25E7%25BB%259F%25E4%25B8%2580%25E5%2586%2599%25E6%25B3%2595%25EF%25BC%2589.gif" alt="中序遍历迭代（统一写法）"></p><p>动画中，result 数组就是最终结果集。</p><p>可以看出我们将访问的节点直接加入到栈中，但如果是处理的节点则后面放入一个空节点， 这样只有空节点弹出的时候，才将下一个节点放进结果集。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// （统一格式的）迭代实现中序遍历：左根右</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> <span class="token function">inorderTraversal</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TreeNode</span><span class="token punctuation">></span></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 用于存放节点</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre>            stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>            <span class="token class-name">TreeNode</span> node <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 获取栈顶元素，但不弹出</span></pre></td></tr><tr><td data-num="11"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>                stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 弹出栈顶元素，避免重复访问，下面再将右、中、左节点入栈</span></pre></td></tr><tr><td data-num="13"></td><td><pre></pre></td></tr><tr><td data-num="14"></td><td><pre>                <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="15"></td><td><pre>                    stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 右节点入栈</span></pre></td></tr><tr><td data-num="16"></td><td><pre></pre></td></tr><tr><td data-num="17"></td><td><pre>                stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 中节点入栈</span></pre></td></tr><tr><td data-num="18"></td><td><pre>                stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 标记中节点已访问，待处理</span></pre></td></tr><tr><td data-num="19"></td><td><pre></pre></td></tr><tr><td data-num="20"></td><td><pre>                <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="21"></td><td><pre>                    stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 左节点入栈</span></pre></td></tr><tr><td data-num="22"></td><td><pre>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 遇到 null，说明中节点已访问，弹出 null，弹出中节点，将中节点值加入结果集</span></pre></td></tr><tr><td data-num="23"></td><td><pre>                stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>                node <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>                res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>        <span class="token keyword">return</span> res<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="30"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h4 id="前序遍历统一迭代"><a class="anchor" href="#前序遍历统一迭代">#</a> 前序遍历（统一迭代）</h4><p>迭代法前序遍历代码如下： (<strong>注意此时我们和中序遍历相比仅仅改变了两处代码的顺序</strong>)</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// （统一格式的）迭代实现前序遍历：根左右</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> <span class="token function">preorderTraversal</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TreeNode</span><span class="token punctuation">></span></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 用于存放节点</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre>            stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>            <span class="token class-name">TreeNode</span> node <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 获取栈顶元素，但不弹出</span></pre></td></tr><tr><td data-num="11"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>                stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 弹出栈顶元素，避免重复访问，下面再将右、中、左节点入栈</span></pre></td></tr><tr><td data-num="13"></td><td><pre></pre></td></tr><tr><td data-num="14"></td><td><pre>                <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="15"></td><td><pre>                    stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 右节点入栈</span></pre></td></tr><tr><td data-num="16"></td><td><pre></pre></td></tr><tr><td data-num="17"></td><td><pre>                <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="18"></td><td><pre>                    stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 左节点入栈</span></pre></td></tr><tr><td data-num="19"></td><td><pre></pre></td></tr><tr><td data-num="20"></td><td><pre>                stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 中节点入栈</span></pre></td></tr><tr><td data-num="21"></td><td><pre>                stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 标记中节点已访问，待处理</span></pre></td></tr><tr><td data-num="22"></td><td><pre>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 遇到 null，说明中节点已访问，弹出 null，弹出中节点，将中节点值加入结果集</span></pre></td></tr><tr><td data-num="23"></td><td><pre>                stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>                node <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>                res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>        <span class="token keyword">return</span> res<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="30"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h4 id="后续遍历统一迭代"><a class="anchor" href="#后续遍历统一迭代">#</a> 后续遍历（统一迭代）</h4><p>后续遍历代码如下： (<strong>注意此时我们和中序遍历相比仅仅改变了两处代码的顺序</strong>)</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 迭代实现后序遍历：左右根</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> <span class="token function">postorderTraversal</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TreeNode</span><span class="token punctuation">></span></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 用于存放节点</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre>            stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>            <span class="token class-name">TreeNode</span> node <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 获取栈顶元素，但不弹出</span></pre></td></tr><tr><td data-num="11"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>                stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 弹出栈顶元素，避免重复访问，下面再将右、中、左节点入栈</span></pre></td></tr><tr><td data-num="13"></td><td><pre></pre></td></tr><tr><td data-num="14"></td><td><pre>                stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 中节点入栈</span></pre></td></tr><tr><td data-num="15"></td><td><pre>                stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 标记中节点已访问，待处理</span></pre></td></tr><tr><td data-num="16"></td><td><pre></pre></td></tr><tr><td data-num="17"></td><td><pre>                <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="18"></td><td><pre>                    stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 右节点入栈</span></pre></td></tr><tr><td data-num="19"></td><td><pre></pre></td></tr><tr><td data-num="20"></td><td><pre>                <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="21"></td><td><pre>                    stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 左节点入栈</span></pre></td></tr><tr><td data-num="22"></td><td><pre>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 遇到 null，说明中节点已访问，弹出 null，弹出中节点，将中节点值加入结果集</span></pre></td></tr><tr><td data-num="23"></td><td><pre>                stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>                node <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>                res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>        <span class="token keyword">return</span> res<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="30"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h4 id="总结-11"><a class="anchor" href="#总结-11">#</a> 总结</h4><p>此时我们写出了统一风格的迭代法，不用在纠结于前序写出来了，中序写不出来的情况了。</p><p>但是统一风格的迭代法并不好理解，而且想在面试直接写出来还有难度的。</p><p>所以大家根据自己的个人喜好，对于二叉树的前中后序遍历，选择一种自己容易理解的递归和迭代法。</p><h3 id="102-二叉树的层序遍历"><a class="anchor" href="#102-二叉树的层序遍历">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iaW5hcnktdHJlZS1sZXZlbC1vcmRlci10cmF2ZXJzYWwv">102. 二叉树的层序遍历</span></h3><p>学会二叉树的层序遍历，可以一口气打完以下十题：</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iaW5hcnktdHJlZS1sZXZlbC1vcmRlci10cmF2ZXJzYWwv">102. 二叉树的层序遍历</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iaW5hcnktdHJlZS1sZXZlbC1vcmRlci10cmF2ZXJzYWwtaWkv">107. 二叉树的层序遍历 II</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iaW5hcnktdHJlZS1yaWdodC1zaWRlLXZpZXcv">199. 二叉树的右视图</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9hdmVyYWdlLW9mLWxldmVscy1pbi1iaW5hcnktdHJlZS8=">637. 二叉树的层平均值</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9uLWFyeS10cmVlLWxldmVsLW9yZGVyLXRyYXZlcnNhbC8=">429. N 叉树的层序遍历</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9maW5kLWxhcmdlc3QtdmFsdWUtaW4tZWFjaC10cmVlLXJvdy8=">515. 在每个树行中找最大值</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9wb3B1bGF0aW5nLW5leHQtcmlnaHQtcG9pbnRlcnMtaW4tZWFjaC1ub2RlLw==">116. 填充每个节点的下一个右侧节点指针</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9wb3B1bGF0aW5nLW5leHQtcmlnaHQtcG9pbnRlcnMtaW4tZWFjaC1ub2RlLWlpLw==">117. 填充每个节点的下一个右侧节点指针 II</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tYXhpbXVtLWRlcHRoLW9mLWJpbmFyeS10cmVlLw==">104. 二叉树的最大深度</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9taW5pbXVtLWRlcHRoLW9mLWJpbmFyeS10cmVlL2Rlc2NyaXB0aW9uLw==">111. 二叉树的最小深度</span></li></ul><p>之前讲过了三篇关于二叉树的<mark>深度优先遍历</mark>的文章：</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVyY2FybC5jb20vJUU0JUJBJThDJUU1JThGJTg5JUU2JUEwJTkxJUU3JTlBJTg0JUU5JTgwJTkyJUU1JUJEJTkyJUU5JTgxJThEJUU1JThFJTg2Lmh0bWw=">二叉树：前中后序递归法</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVyY2FybC5jb20vJUU0JUJBJThDJUU1JThGJTg5JUU2JUEwJTkxJUU3JTlBJTg0JUU4JUJGJUFEJUU0JUJCJUEzJUU5JTgxJThEJUU1JThFJTg2Lmh0bWw=">二叉树：前中后序迭代法</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVyY2FybC5jb20vJUU0JUJBJThDJUU1JThGJTg5JUU2JUEwJTkxJUU3JTlBJTg0JUU3JUJCJTlGJUU0JUI4JTgwJUU4JUJGJUFEJUU0JUJCJUEzJUU2JUIzJTk1Lmh0bWw=">二叉树：前中后序迭代方式统一写法</span></li></ul><p>接下来我们再来介绍二叉树的另一种遍历方式：层序遍历。</p><p>层序遍历一个二叉树。就是从左到右一层一层的去遍历二叉树。这种遍历的方式和我们之前讲过的都不太一样。</p><p>需要借用一个辅助数据结构即<strong>队列</strong>来实现，<strong>队列先进先出，符合一层一层遍历的逻辑，而是用栈先进后出适合模拟深度优先遍历也就是递归的逻辑。</strong></p><p><strong>而这种层序遍历方式就是图论中的<mark>广度优先遍历</mark>，只不过我们应用在二叉树上。</strong></p><p>使用队列实现二叉树广度优先遍历，动画如下：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/102%25E4%25BA%258C%25E5%258F%2589%25E6%25A0%2591%25E7%259A%2584%25E5%25B1%2582%25E5%25BA%258F%25E9%2581%258D%25E5%258E%2586.gif" alt="102二叉树的层序遍历"></p><p>这样就实现了层序从左到右遍历二叉树。</p><h4 id="迭代借助队列"><a class="anchor" href="#迭代借助队列">#</a> 迭代（借助队列）</h4><p>代码如下：<strong>这份代码也可以作为二叉树层序遍历的模板，打十个就靠它了</strong>。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 迭代（借助队列）实现二叉树的层序遍历</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span><span class="token punctuation">></span></span> <span class="token function">levelOrder</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span><span class="token punctuation">></span></span> resList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 保存结果的列表，是一个二维列表</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TreeNode</span><span class="token punctuation">></span></span> que <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TreeNode</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 保存节点的队列</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>            que<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将根节点入队</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>            <span class="token keyword">return</span> resList<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>que<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>            <span class="token keyword">int</span> size <span class="token operator">=</span> que<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 当前层的节点数</span></pre></td></tr><tr><td data-num="14"></td><td><pre>            <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> levelList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 保存当前层的节点值</span></pre></td></tr><tr><td data-num="15"></td><td><pre></pre></td></tr><tr><td data-num="16"></td><td><pre>            <span class="token keyword">while</span> <span class="token punctuation">(</span>size <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>                <span class="token class-name">TreeNode</span> tmpNode <span class="token operator">=</span> que<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 出队</span></pre></td></tr><tr><td data-num="18"></td><td><pre>                levelList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>tmpNode<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将节点值加入当前层的列表</span></pre></td></tr><tr><td data-num="19"></td><td><pre>                <span class="token keyword">if</span> <span class="token punctuation">(</span>tmpNode<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>                    que<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>tmpNode<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将左子节点入队</span></pre></td></tr><tr><td data-num="21"></td><td><pre>                <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>                <span class="token keyword">if</span> <span class="token punctuation">(</span>tmpNode<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>                    que<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>tmpNode<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将右子节点入队</span></pre></td></tr><tr><td data-num="24"></td><td><pre>                <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>                size<span class="token operator">--</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="27"></td><td><pre></pre></td></tr><tr><td data-num="28"></td><td><pre>            resList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>levelList<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将当前层的列表加入到结果列表中</span></pre></td></tr><tr><td data-num="29"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="30"></td><td><pre></pre></td></tr><tr><td data-num="31"></td><td><pre>        <span class="token keyword">return</span> resList<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="33"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20221216182821682.png" alt="image-20221216182821682"></p><h4 id="递归"><a class="anchor" href="#递归">#</a> 递归</h4><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 递归实现二叉树的层序遍历</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span><span class="token punctuation">></span></span> <span class="token function">levelOrder</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span><span class="token punctuation">></span></span> resList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 保存结果的列表，是一个二维列表</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">int</span> depth <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 记录当前层的深度</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token function">recursionFunc</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> resList<span class="token punctuation">,</span> depth<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token keyword">return</span> resList<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token comment">// DFS - 递归方式</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">recursionFunc</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> cur<span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span><span class="token punctuation">></span></span> resList<span class="token punctuation">,</span> <span class="token class-name">Integer</span> deep<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>cur <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token comment">// 递归终止条件</span></pre></td></tr><tr><td data-num="15"></td><td><pre>            <span class="token keyword">return</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>resList<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> deep<span class="token punctuation">)</span> <span class="token comment">// 如果当前层还没有创建对应的 list，就创建一个</span></pre></td></tr><tr><td data-num="18"></td><td><pre>            resList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre></pre></td></tr><tr><td data-num="20"></td><td><pre>        resList<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>deep<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将当前节点的值加入到对应的层的 list 中</span></pre></td></tr><tr><td data-num="21"></td><td><pre></pre></td></tr><tr><td data-num="22"></td><td><pre>        <span class="token function">recursionFunc</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>left<span class="token punctuation">,</span> resList<span class="token punctuation">,</span> deep <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 递归遍历左子树</span></pre></td></tr><tr><td data-num="23"></td><td><pre>        <span class="token function">recursionFunc</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>right<span class="token punctuation">,</span> resList<span class="token punctuation">,</span> deep <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 递归遍历右子树</span></pre></td></tr><tr><td data-num="24"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="25"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20221216181150720.png" alt="image-20221216181150720"></p><h3 id="226-翻转二叉树"><a class="anchor" href="#226-翻转二叉树">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9pbnZlcnQtYmluYXJ5LXRyZWUv">226. 翻转二叉树</span></h3><h4 id="题外话-3"><a class="anchor" href="#题外话-3">#</a> 题外话</h4><p>这道题目是非常经典的题目，也是比较简单的题目（至少一看就会）。</p><p>但正是因为这道题太简单，一看就会，一些同学都没有抓住起本质，稀里糊涂的就把这道题目过了。</p><p>如果做过这道题的同学也建议认真看完，相信一定有所收获！</p><h4 id="思路-2"><a class="anchor" href="#思路-2">#</a> 思路</h4><p>这得怎么翻转呢？</p><p>如果要从整个树来看，翻转还真的挺复杂，整个树以中间分割线进行翻转，如图：</p><p><img data-src="https://img-blog.csdnimg.cn/20210203192724351.png" alt="226.翻转二叉树1"></p><p>可以发现想要翻转它，其实就 **<mark> 把每一个节点的左右孩子交换一下就可以了</mark> **。</p><p><strong>关键在于<mark>遍历顺序</mark>，前中后序应该选哪一种遍历顺序？</strong> （一些同学这道题都过了，但是不知道自己用的是什么顺序）</p><p>遍历的过程中去翻转每一个节点的左右孩子就可以达到整体翻转的效果。</p><p><strong>注意只要把每一个节点的左右孩子翻转一下，就可以达到整体翻转的效果</strong></p><p><strong>这道题目使用<mark>前序遍历和后序遍历都可以，唯独中序遍历不方便</mark>，因为中序遍历会把某些节点的左右孩子翻转了两次！建议拿纸画一画，就理解了</strong></p><p>那么层序遍历可以不可以呢？<strong>依然可以的！只要把每一个节点的左右孩子翻转一下的遍历方式都是可以的！</strong></p><h4 id="递归法-2"><a class="anchor" href="#递归法-2">#</a> 递归法</h4><p>下文以<strong>前序遍历</strong>（根左右）为例，通过动画来看一下翻转的过程:</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/%25E7%25BF%25BB%25E8%25BD%25AC%25E4%25BA%258C%25E5%258F%2589%25E6%25A0%2591.gif" alt="翻转二叉树"></p><p>我们来看一下递归三部曲：</p><ol><li>确定递归函数的参数和返回值</li></ol><p>参数就是要传入节点的指针，不需要其他参数了，通常此时定下来主要参数，如果在写递归的逻辑中发现还需要其他参数的时候，随时补充。</p><p>返回值的话其实也不需要，但是题目中给出的要返回 root 节点的指针，可以直接使用题目定义好的函数，所以就函数的返回类型为 <code>TreeNode*</code> 。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token class-name">TreeNode</span> <span class="token function">invertTree</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span></pre></td></tr></table></figure><ol start="2"><li>确定终止条件</li></ol><p>当前节点为空的时候，就返回</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre>	<span class="token keyword">return</span> root<span class="token punctuation">;</span></pre></td></tr></table></figure><ol start="3"><li>确定单层递归的逻辑</li></ol><p>因为是先前序遍历，所以先进行交换左右孩子节点，然后反转左子树，反转右子树。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 根：交换左右子树</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name">TreeNode</span> temp <span class="token operator">=</span> root<span class="token punctuation">.</span>left<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>root<span class="token punctuation">.</span>left <span class="token operator">=</span> root<span class="token punctuation">.</span>right<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>root<span class="token punctuation">.</span>right <span class="token operator">=</span> temp<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token comment">// 左：递归</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token function">invertTree</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token comment">// 右：递归</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token function">invertTree</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>基于这递归三步法，代码基本写完，代码如下：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 递归（前序遍历）</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">TreeNode</span> <span class="token function">invertTree</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token comment">// 递归终止条件</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre>            <span class="token keyword">return</span> root<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token comment">// 根：交换左右子树</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token class-name">TreeNode</span> temp <span class="token operator">=</span> root<span class="token punctuation">.</span>left<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        root<span class="token punctuation">.</span>left <span class="token operator">=</span> root<span class="token punctuation">.</span>right<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        root<span class="token punctuation">.</span>right <span class="token operator">=</span> temp<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token comment">// 左：递归</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token function">invertTree</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token comment">// 右：递归</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token function">invertTree</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre></pre></td></tr><tr><td data-num="18"></td><td><pre>        <span class="token keyword">return</span> root<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20221216230315432.png" alt="image-20221216230315432"></p><p>对于后序遍历，直接把 “根” 的代码放到 “右” 的后面即可。</p><p>但对于中序遍历，就不能简单地把 “根” 的代码放到 “左” 的后面了，还需要把 “右” 处改为 <code>root.left</code> 。这样才能避免对 root 的左子树交换两次，而右子树没变动的情况。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 递归（中序遍历）</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">TreeNode</span> <span class="token function">invertTree</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token comment">// 递归终止条件</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre>            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token comment">// 左子树翻转</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token function">invertTree</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token comment">// 根：交换左右子树</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token class-name">TreeNode</span> tmp <span class="token operator">=</span> root<span class="token punctuation">.</span>left<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        root<span class="token punctuation">.</span>left <span class="token operator">=</span> root<span class="token punctuation">.</span>right<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        root<span class="token punctuation">.</span>right <span class="token operator">=</span> tmp<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token comment">// "左" 子树翻转！！！！</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token function">invertTree</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token keyword">return</span> root<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h4 id="迭代法"><a class="anchor" href="#迭代法">#</a> 迭代法</h4><h5 id="深度优先遍历"><a class="anchor" href="#深度优先遍历">#</a> 深度优先遍历</h5><p>前序遍历：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 迭代（前序遍历），借助栈</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">TreeNode</span> <span class="token function">invertTree</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre>            <span class="token keyword">return</span> root<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TreeNode</span><span class="token punctuation">></span></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>            <span class="token comment">// 根：交换左右子树</span></pre></td></tr><tr><td data-num="11"></td><td><pre>            <span class="token class-name">TreeNode</span> node <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>            <span class="token class-name">TreeNode</span> temp <span class="token operator">=</span> node<span class="token punctuation">.</span>left<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>            node<span class="token punctuation">.</span>left <span class="token operator">=</span> node<span class="token punctuation">.</span>right<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>            node<span class="token punctuation">.</span>right <span class="token operator">=</span> temp<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>            <span class="token comment">// 右：入栈</span></pre></td></tr><tr><td data-num="16"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="17"></td><td><pre>                stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>            <span class="token comment">// 左：入栈</span></pre></td></tr><tr><td data-num="19"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="20"></td><td><pre>                stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>        <span class="token keyword">return</span> root<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="24"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20221216231454189.png" alt="image-20221216231454189"></p><p>对于后序遍历，只需要把” 右 “处代码和” 左 “处的交换位置即可。</p><p>对于中序遍历，不方便直接变动上述代码，但之前介绍了一种统一的迭代遍历方式，下面以前序遍历举例：</p><blockquote><p>搞不懂啊！</p></blockquote><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 统一格式迭代（前序遍历），借助栈</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">TreeNode</span> <span class="token function">invertTree</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TreeNode</span><span class="token punctuation">></span></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>            stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>            <span class="token class-name">TreeNode</span> node <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 非空节点</span></pre></td></tr><tr><td data-num="12"></td><td><pre>                stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>                <span class="token comment">// 右</span></pre></td></tr><tr><td data-num="14"></td><td><pre>                <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>                    stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>                <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>                <span class="token comment">// 左</span></pre></td></tr><tr><td data-num="18"></td><td><pre>                <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>                    stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>                <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>                <span class="token comment">// 中</span></pre></td></tr><tr><td data-num="22"></td><td><pre>                stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>                stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 空节点</span></pre></td></tr><tr><td data-num="25"></td><td><pre>                stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 弹出 null 节点</span></pre></td></tr><tr><td data-num="26"></td><td><pre>                node <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 待处理的节点</span></pre></td></tr><tr><td data-num="27"></td><td><pre>                stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 弹出待处理的节点</span></pre></td></tr><tr><td data-num="28"></td><td><pre></pre></td></tr><tr><td data-num="29"></td><td><pre>                <span class="token comment">// 交换左右子树</span></pre></td></tr><tr><td data-num="30"></td><td><pre>                <span class="token class-name">TreeNode</span> temp <span class="token operator">=</span> node<span class="token punctuation">.</span>left<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="31"></td><td><pre>                node<span class="token punctuation">.</span>left <span class="token operator">=</span> node<span class="token punctuation">.</span>right<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>                node<span class="token punctuation">.</span>right <span class="token operator">=</span> temp<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="33"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="34"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="35"></td><td><pre>        <span class="token keyword">return</span> root<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="36"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="37"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>这效率有够拉的：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20221216232605077.png" alt="image-20221216232605077"></p><h5 id="广度优先遍历"><a class="anchor" href="#广度优先遍历">#</a> 广度优先遍历</h5><blockquote><p>就是层序遍历嘛</p></blockquote><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 层序遍历（广度优先搜索），借助队列</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">TreeNode</span> <span class="token function">invertTree</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TreeNode</span><span class="token punctuation">></span></span> que <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TreeNode</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>            que<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>que<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>            <span class="token keyword">int</span> size <span class="token operator">=</span> que<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>            <span class="token keyword">while</span> <span class="token punctuation">(</span>size <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>                <span class="token class-name">TreeNode</span> tmpNode <span class="token operator">=</span> que<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>                <span class="token comment">// 处理中间节点：交换左右子树</span></pre></td></tr><tr><td data-num="14"></td><td><pre>                <span class="token class-name">TreeNode</span> tmp <span class="token operator">=</span> tmpNode<span class="token punctuation">.</span>left<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>                tmpNode<span class="token punctuation">.</span>left <span class="token operator">=</span> tmpNode<span class="token punctuation">.</span>right<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>                tmpNode<span class="token punctuation">.</span>right <span class="token operator">=</span> tmp<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>                <span class="token comment">// 左右子树入队</span></pre></td></tr><tr><td data-num="18"></td><td><pre>                <span class="token keyword">if</span> <span class="token punctuation">(</span>tmpNode<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>                    que<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>tmpNode<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>                <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>                <span class="token keyword">if</span> <span class="token punctuation">(</span>tmpNode<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>                    que<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>tmpNode<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>                <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>                size<span class="token operator">--</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="27"></td><td><pre></pre></td></tr><tr><td data-num="28"></td><td><pre>        <span class="token keyword">return</span> root<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="30"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>这效率有点牛：<img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20221216233022776.png" alt="image-20221216233022776"></p><h4 id="拓展-2"><a class="anchor" href="#拓展-2">#</a> 拓展</h4><p><strong>文中我指的是递归的中序遍历是不行的，因为使用递归的中序遍历，某些节点的左右孩子会翻转两次。</strong></p><p>如果非要使用递归中序的方式写，也可以，如下代码就可以避免节点左右孩子翻转两次的情况：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 递归（中序遍历）</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">TreeNode</span> <span class="token function">invertTree</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token comment">// 递归终止条件</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre>            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token comment">// 左子树翻转</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token function">invertTree</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token comment">// 根：交换左右子树</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token class-name">TreeNode</span> tmp <span class="token operator">=</span> root<span class="token punctuation">.</span>left<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        root<span class="token punctuation">.</span>left <span class="token operator">=</span> root<span class="token punctuation">.</span>right<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        root<span class="token punctuation">.</span>right <span class="token operator">=</span> tmp<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token comment">// "左" 子树翻转！！！！</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token function">invertTree</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token keyword">return</span> root<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>代码虽然可以，但这毕竟不是真正的递归中序遍历了。</p><p>但使用迭代方式统一写法的中序是可以的。</p><p>代码如下：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 统一格式的迭代法（中序遍历），使用栈</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">TreeNode</span> <span class="token function">invertTree</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TreeNode</span><span class="token punctuation">></span></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre>            stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>            <span class="token class-name">TreeNode</span> node <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 获取栈顶元素</span></pre></td></tr><tr><td data-num="10"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>                stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>                <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 右</span></pre></td></tr><tr><td data-num="13"></td><td><pre>                stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 中</span></pre></td></tr><tr><td data-num="14"></td><td><pre>                stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>                <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 左</span></pre></td></tr><tr><td data-num="16"></td><td><pre>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>                stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 弹出 null</span></pre></td></tr><tr><td data-num="18"></td><td><pre>                node <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 弹出中，要处理</span></pre></td></tr><tr><td data-num="19"></td><td><pre>                <span class="token class-name">TreeNode</span> temp <span class="token operator">=</span> node<span class="token punctuation">.</span>left<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>                node<span class="token punctuation">.</span>left <span class="token operator">=</span> node<span class="token punctuation">.</span>right<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>                node<span class="token punctuation">.</span>right <span class="token operator">=</span> temp<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>        <span class="token keyword">return</span> root<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="26"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20221216234206350.png" alt="image-20221216234206350"></p><p>为什么这个中序就是可以的呢，因为这是用栈来遍历，而不是靠指针来遍历，避免了递归法中翻转了两次的情况，大家可以画图理解一下，这里有点意思的。</p><h4 id="总结-12"><a class="anchor" href="#总结-12">#</a> 总结</h4><p>针对二叉树的问题，解题之前一定要想清楚究竟是前中后序遍历，还是层序遍历。</p><p><strong>二叉树解题的大忌就是自己稀里糊涂的过了（因为这道题相对简单），但是也不知道自己是怎么遍历的。</strong></p><p>这也是造成了二叉树的题目 “一看就会，一写就废” 的原因。</p><p><strong>针对翻转二叉树，我给出了一种递归，三种迭代（两种模拟深度优先遍历，一种层序遍历）的写法，都是之前我们讲过的写法，融汇贯通一下而已。</strong></p><p>大家一定也有自己的解法，但一定要成方法论，这样才能通用，才能举一反三！</p><h3 id="本周小结"><a class="anchor" href="#本周小结">#</a> 本周小结</h3><h4 id="周一"><a class="anchor" href="#周一">#</a> 周一</h4><p>关于二叉树的理论基础，<strong>红黑树就是一种二叉平衡搜索树</strong>，这两个树不是独立的，所以 C++ 中 map、multimap、set、multiset 的底层实现机制是二叉平衡搜索树，再具体一点是红黑树。</p><blockquote><p>二叉平衡搜索树：又被称为<strong> AVL（Adelson-Velsky and Landis）树</strong>，且具有以下性质：它是<strong>一棵空树</strong>或它的<strong>左右两个子树的高度差的绝对值不超过 1</strong>，并且左右两个子树都是一棵平衡二叉树。此外，二叉搜索树是一种<strong>有序</strong>树。</p></blockquote><p>对于二叉树节点的定义：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TreeNode</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">int</span> val<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token class-name">TreeNode</span> left<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token class-name">TreeNode</span> right<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token class-name">TreeNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token class-name">TreeNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token keyword">this</span><span class="token punctuation">.</span>val <span class="token operator">=</span> val<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token class-name">TreeNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> val<span class="token punctuation">,</span> <span class="token class-name">TreeNode</span> left<span class="token punctuation">,</span> <span class="token class-name">TreeNode</span> right<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token keyword">this</span><span class="token punctuation">.</span>val <span class="token operator">=</span> val<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token keyword">this</span><span class="token punctuation">.</span>left <span class="token operator">=</span> left<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token keyword">this</span><span class="token punctuation">.</span>right <span class="token operator">=</span> right<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>在介绍前中后序遍历的时候，有<strong>递归</strong>和<strong>迭代（非递归）</strong>，还有一种牛逼的遍历方式：morris 遍历。</p><p>morris 遍历是二叉树遍历算法的超强进阶算法，morris 遍历可以将非递归遍历中的空间复杂度降为 O (1)，感兴趣大家就去查一查学习学习，比较小众，面试几乎不会考。我其实也没有研究过，就不做过多介绍了。</p><h4 id="周二"><a class="anchor" href="#周二">#</a> 周二</h4><p>在<a href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86">二叉树的递归遍历</a>中讲到了<strong>递归三要素</strong>，以及<strong>前、中、后序</strong>的递归写法。</p><p>文章中我给出了 leetcode 上三道二叉树的前中后序题目，但是看完<a href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86">二叉树的递归遍历</a>，依然可以解决<strong> n 叉树的前后序遍历</strong>，在 leetcode 上分别是</p><ul><li><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbi1hcnktdHJlZS1wcmVvcmRlci10cmF2ZXJzYWwv">589. N 叉树的前序遍历</span></p><ul class="task-list"><li class="task-list-item"><input type="checkbox" id="cbx_0" disabled><label for="cbx_0">递归 1</label></li></ul><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 递归实现 N 叉树的前序遍历：根 孩子 1 孩子 2 孩子 3 ...</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> <span class="token function">preorder</span><span class="token punctuation">(</span><span class="token class-name">Node</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> resList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token comment">// 递归终止条件</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre>            <span class="token keyword">return</span> resList<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token comment">// 递归过程</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        resList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 根</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Node</span> child <span class="token operator">:</span> root<span class="token punctuation">.</span>children<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>            resList<span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span><span class="token function">preorder</span><span class="token punctuation">(</span>child<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 孩子</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token keyword">return</span> resList<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>​ 时间效率太低辣！</p><ul class="task-list"><li class="task-list-item"><input type="checkbox" id="cbx_1" checked disabled><label for="cbx_1">递归 2</label></li></ul><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 递归实现 N 叉树的前序遍历：根 孩子 1 孩子 2 孩子 3 ...</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> <span class="token function">preorder</span><span class="token punctuation">(</span><span class="token class-name">Node</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> resList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token function">helper</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> resList<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token keyword">return</span> resList<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">helper</span><span class="token punctuation">(</span><span class="token class-name">Node</span> root<span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> resList<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token comment">// 递归终止条件</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="12"></td><td><pre>            <span class="token keyword">return</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token comment">// 递归过程</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        resList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 根</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Node</span> child <span class="token operator">:</span> root<span class="token punctuation">.</span>children<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 孩子 1 孩子 2 孩子 3 ...</span></pre></td></tr><tr><td data-num="16"></td><td><pre>            <span class="token function">helper</span><span class="token punctuation">(</span>child<span class="token punctuation">,</span> resList<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20221217120054843.png" alt="image-20221217120054843"></p></li><li><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbi1hcnktdHJlZS1wb3N0b3JkZXItdHJhdmVyc2FsLw==">590. N 叉树的后序遍历</span></p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 递归实现 N 叉树的后序遍历：孩子 1 孩子 2 ... 孩子 n 根</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> <span class="token function">postorder</span><span class="token punctuation">(</span><span class="token class-name">Node</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> resList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token function">helper</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> resList<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token keyword">return</span> resList<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">helper</span><span class="token punctuation">(</span><span class="token class-name">Node</span> root<span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> resList<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token comment">// 递归终止条件</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="12"></td><td><pre>            <span class="token keyword">return</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token comment">// 递归过程</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Node</span> child <span class="token operator">:</span> root<span class="token punctuation">.</span>children<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="15"></td><td><pre>            <span class="token function">helper</span><span class="token punctuation">(</span>child<span class="token punctuation">,</span> resList<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 递归遍历孩子</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        resList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 遍历完孩子后，再遍历根</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20221217121042007.png" alt="image-20221217121042007"></p></li></ul><p>大家可以再去把这两道题目做了。</p><h4 id="周三"><a class="anchor" href="#周三">#</a> 周三</h4><p>在<a href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%86">二叉树的迭代遍历</a>中我们开始用 ==<strong> 栈</strong> == 来实现递归的写法，也就是所谓的<strong>迭代法</strong>。</p><p>细心的同学发现文中前后序遍历空节点是否入栈写法是不同的</p><p>其实空节点入不入栈都差不多，但感觉空节点不入栈确实清晰一些，符合文中动画的演示。</p><p>拿前序遍历来举例，空节点入栈：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 迭代实现前序遍历（空节点入栈）</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> <span class="token function">preorderTraversal</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TreeNode</span><span class="token punctuation">></span></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 即使是空节点也入栈</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>            <span class="token class-name">TreeNode</span> node <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="11"></td><td><pre>                res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 只处理非空节点</span></pre></td></tr><tr><td data-num="12"></td><td><pre>            <span class="token keyword">else</span></pre></td></tr><tr><td data-num="13"></td><td><pre>                <span class="token keyword">continue</span><span class="token punctuation">;</span> <span class="token comment">// 空间点直接跳过</span></pre></td></tr><tr><td data-num="14"></td><td><pre></pre></td></tr><tr><td data-num="15"></td><td><pre>            <span class="token comment">// 先右后左，因为栈是先进后出，所以先入栈的后出栈</span></pre></td></tr><tr><td data-num="16"></td><td><pre>            stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 右节点入栈，即使是空节点也入栈</span></pre></td></tr><tr><td data-num="17"></td><td><pre>            stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 左节点入栈，即使是空节点也入栈</span></pre></td></tr><tr><td data-num="18"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>        <span class="token keyword">return</span> res<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="21"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20221217133836210.png" alt="image-20221217133836210"></p><p>拿前序遍历来举例，空节点不入栈：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 迭代实现前序遍历（空节点不入栈）</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> <span class="token function">preorderTraversal</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token comment">// 空节点直接返回，不用入栈</span></pre></td></tr><tr><td data-num="6"></td><td><pre>            <span class="token keyword">return</span> res<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TreeNode</span><span class="token punctuation">></span></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>            <span class="token class-name">TreeNode</span> node <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>            res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token comment">// 先压入右子树</span></pre></td></tr><tr><td data-num="15"></td><td><pre>                stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token comment">// 再压入左子树</span></pre></td></tr><tr><td data-num="17"></td><td><pre>                stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>        <span class="token keyword">return</span> res<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="21"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20221217133424637.png" alt="image-20221217133424637"></p><p>在实现迭代法的过程中，有同学问了：递归与迭代究竟谁优谁劣呢？</p><p>从<strong>时间复杂度上其实迭代法和递归法差不多</strong>（在不考虑函数调用开销和函数调用产生的堆栈开销），但是<strong>空间复杂度上，递归开销会大一些</strong>，因为递归需要系统堆栈存参数返回值等等。</p><p>递归更容易让程序员理解，但收敛不好，容易栈溢出。</p><p>这么说吧，<strong>递归是方便了程序员，难为了机器</strong>（各种保存参数，各种进栈出栈）。</p><p><strong>在实际项目开发的过程中我们是要尽量避免递归！因为项目代码参数、调用关系都比较复杂，不容易控制递归深度，甚至会栈溢出。</strong></p><h4 id="周四"><a class="anchor" href="#周四">#</a> 周四</h4><p>在<a href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%BB%9F%E4%B8%80%E8%BF%AD%E4%BB%A3%E6%B3%95">☆二叉树的统一迭代法</a>中我们<strong>使用空节点作为标记</strong>，给出了统一的前中后序迭代法。</p><p>此时又多了一种前中后序的迭代写法，那么有同学问了：前中后序迭代法是不是一定要统一来写，这样才算是规范。</p><p>其实没必要，还是自己感觉哪一种更好记就用哪种。</p><p>但是<strong>一定要掌握前中后序一种迭代的写法，并不因为某种场景的题目一定要用迭代，而是现场面试的时候，面试官看你顺畅的写出了递归，一般会进一步考察能不能写出相应的迭代。</strong></p><h4 id="周五"><a class="anchor" href="#周五">#</a> 周五</h4><p>在 [102. 二叉树的层序遍历](#102. 二叉树的层序遍历) 中我们介绍了二叉树的另一种遍历方式（图论中广度优先搜索在二叉树上的应用）即：<strong>层序遍历</strong>。</p><p>看完这篇文章，去 leetcode 上怒刷五题，文章中编号 107 题目的样例图放错了（原谅我匆忙之间总是手抖），但不影响大家理解。</p><p>只有同学发现 leetcode 上 “515. 在每个树行中找最大值”，也是层序遍历的应用，依然可以分分钟解决，所以就是一鼓作气解决六道了，哈哈。</p><p><strong>层序遍历遍历相对容易一些，只要掌握基本写法（也就是框架模板），剩下的就是在二叉树每一行遍历的时候做做逻辑修改。</strong></p><h4 id="周六"><a class="anchor" href="#周六">#</a> 周六</h4><p>在 [226. 翻转二叉树](#226. 翻转二叉树) 中我们把翻转二叉树这么一道简单又经典的问题，充分的剖析了一波，相信就算做过这道题目的同学，看完本篇之后依然有所收获！</p><p><strong>文中我指的是<u>递归的中序遍历</u>是不行的，因为使用递归的中序遍历，某些节点的左右孩子会翻转两次。</strong></p><p>如果非要使用递归中序的方式写，也可以，如下代码就可以避免节点左右孩子翻转两次的情况：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 递归（中序遍历）</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">TreeNode</span> <span class="token function">invertTree</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token comment">// 递归终止条件</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre>            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token comment">// 左子树翻转</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token function">invertTree</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token comment">// 根：交换左右子树</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token class-name">TreeNode</span> tmp <span class="token operator">=</span> root<span class="token punctuation">.</span>left<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        root<span class="token punctuation">.</span>left <span class="token operator">=</span> root<span class="token punctuation">.</span>right<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        root<span class="token punctuation">.</span>right <span class="token operator">=</span> tmp<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token comment">// "左" 子树翻转！！！！</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token function">invertTree</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 注意 这里依然要遍历左孩子，因为中间节点已经翻转了</span></pre></td></tr><tr><td data-num="16"></td><td><pre></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token keyword">return</span> root<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>代码虽然可以，但这毕竟不是真正的递归中序遍历了。</p><p>但使用 **<u>迭代方式统一写法的中序</u>** 是可以的。</p><p>代码如下：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 统一格式的迭代法（中序遍历），使用栈</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">TreeNode</span> <span class="token function">invertTree</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TreeNode</span><span class="token punctuation">></span></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre>            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token keyword">else</span></pre></td></tr><tr><td data-num="8"></td><td><pre>            stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>            <span class="token class-name">TreeNode</span> node <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>                stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 为 null 的节点出栈</span></pre></td></tr><tr><td data-num="14"></td><td><pre>                node <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 处理根节点：交换左右子树</span></pre></td></tr><tr><td data-num="15"></td><td><pre>                <span class="token class-name">TreeNode</span> temp <span class="token operator">=</span> node<span class="token punctuation">.</span>left<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>                node<span class="token punctuation">.</span>left <span class="token operator">=</span> node<span class="token punctuation">.</span>right<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>                node<span class="token punctuation">.</span>right <span class="token operator">=</span> temp<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>                stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 根节点出栈</span></pre></td></tr><tr><td data-num="20"></td><td><pre>                <span class="token comment">// 按照右中左的顺序入栈</span></pre></td></tr><tr><td data-num="21"></td><td><pre>                <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="22"></td><td><pre>                    stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre></pre></td></tr><tr><td data-num="24"></td><td><pre>                stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 根节点再次入栈</span></pre></td></tr><tr><td data-num="25"></td><td><pre>                stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 根节点的左子树为 null</span></pre></td></tr><tr><td data-num="26"></td><td><pre></pre></td></tr><tr><td data-num="27"></td><td><pre>                <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="28"></td><td><pre>                    stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="31"></td><td><pre>        <span class="token keyword">return</span> root<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="33"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20221217141743445.png" alt="image-20221217141743445"></p><p>为什么这个中序就是可以的呢，因为这是用栈来遍历，而不是靠指针来遍历，避免了递归法中翻转了两次的情况，大家可以画图理解一下，这里有点意思的。</p><h4 id="小结-3"><a class="anchor" href="#小结-3">#</a> 小结</h4><p><strong>本周我们都是讲解了二叉树，从理论基础到遍历方式，从递归到迭代，从深度遍历到广度遍历，最后再用了一个翻转二叉树的题目把我们之前讲过的遍历方式都串了起来。</strong></p><h3 id="101-对称二叉树"><a class="anchor" href="#101-对称二叉树">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zeW1tZXRyaWMtdHJlZS8=">101. 对称二叉树</span></h3><p>首先想清楚，判断对称二叉树要比较的是哪两个节点，要比较的可不是左右节点！</p><p>对于二叉树是否对称，<strong>要比较的是根节点的左子树与右子树是不是相互翻转的</strong>，理解这一点就知道了<strong>其实我们要比较的是两个树（这两个树是根节点的左右子树）</strong>，所以在递归遍历的过程中，也是<em>要同时遍历两棵树</em>。</p><p>那么如果比较呢？</p><p><strong><mark>比较的是两个子树的里侧和外侧的元素是否相等</mark></strong>。如图所示：</p><p><img data-src="https://img-blog.csdnimg.cn/20210203144624414.png" alt="101. 对称二叉树1"></p><p>那么遍历的顺序应该是什么样的呢？</p><p>本题遍历 **<mark> 只能是 “后序遍历”</mark>**，因为我们要通过递归函数的返回值来判断两个子树的内侧节点和外侧节点是否相等。</p><p><strong>正是因为要遍历两棵树而且要比较内侧和外侧节点，所以准确的来说是一个树的遍历顺序是左右中，一个树的遍历顺序是右左中。</strong></p><p>但都可以理解算是后序遍历，尽管已经不是严格上在一个树上进行遍历的后序遍历了。</p><p><strong>其实后序也可以理解为是一种回溯</strong>，当然这是题外话，讲回溯的时候会重点讲的。</p><p>说到这大家可能感觉我有点啰嗦，哪有这么多道理，上来就干就完事了。别急，我说的这些在下面的代码讲解中都有身影。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20221217190212324.png" alt="image-20221217190212324"></p><p>那么我们先来看看<strong>递归法</strong>的代码应该怎么写。</p><h4 id="递归法-3"><a class="anchor" href="#递归法-3">#</a> √递归法</h4><p>递归三部曲：</p><ol><li><p>参数、返回值</p><p>因为我们要比较的是根节点的两个子树是否是相互翻转的，进而判断这个树是不是对称树，所以要比较的是两个树，<strong>参数自然也是左子树节点和右子树节点</strong>。</p><p><strong>返回值自然是 bool 类型</strong>。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">compare</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> left<span class="token punctuation">,</span> <span class="token class-name">TreeNode</span> right<span class="token punctuation">)</span></pre></td></tr></table></figure></li><li><p>递归终止条件</p><p>要比较两个节点数值相不相同，首先要把两个节点为空的情况弄清楚！否则后面比较数值的时候就会操作空指针了。</p><p><mark>节点为空的情况</mark>有：（<strong>注意我们比较的其实不是左孩子和右孩子，所以如下我称之为左节点右节点</strong>）</p><ul><li>左节点为空，右节点不为空，不对称，return false</li><li>左不为空，右为空，不对称 return false</li><li>左右都为空，对称，返回 true</li></ul><p>此时已经排除掉了节点为空的情况，那么剩下的就是<mark>左右节点不为空</mark>：</p><ul><li>左右都不为空，比较节点数值，不相同就 return false</li></ul><p>此时左右节点不为空，且数值也不相同的情况我们也处理了。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 递归终止条件</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment">// 先排除存在空节点的情况</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> right <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> right <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token comment">// 此时两个节点都不为空，但是值不相等</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>left<span class="token punctuation">.</span>val <span class="token operator">!=</span> right<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>注意上面最后一种情况，我没有使用 else，而是 else if， 因为我们把以上情况都排除之后，<strong>剩下的就是：左右节点都不为空，且数值相同的情况</strong>，也就是我们的递归过程逻辑。</p></li><li><p>单层递归的逻辑</p><p>此时才进入单层递归的逻辑，单层递归的逻辑就是处理 左右节点都不为空，且数值相同的情况。</p><ul><li>比较二叉树<strong>外侧</strong>是否对称：传入的是<em>左节点的左孩子，右节点的右孩子</em>。</li><li>比较<strong>内测</strong>是否对称，传入<em>左节点的右孩子，右节点的左孩子</em>。</li><li>如果<strong>左右都对称就返回 true ，有一侧不对称就返回 false</strong> 。</li></ul><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 递归（对应的情况是：左右子树都不为空，且值相等）</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">boolean</span> outside <span class="token operator">=</span> <span class="token function">compare</span><span class="token punctuation">(</span>left<span class="token punctuation">.</span>left<span class="token punctuation">,</span> right<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 比较外侧：左子树。左 与 右子树。右</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">boolean</span> inside <span class="token operator">=</span> <span class="token function">compare</span><span class="token punctuation">(</span>left<span class="token punctuation">.</span>right<span class="token punctuation">,</span> right<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 比较内侧：左子树。右 与 右子树。左</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">return</span> outside <span class="token operator">&amp;&amp;</span> inside<span class="token punctuation">;</span> <span class="token comment">// 两侧都相等才是对称的：左子树。中 与 右子树。中</span></pre></td></tr></table></figure><p>如上代码中，我们可以看出使用的遍历方式，<strong>左子树：左 -&gt; 右 -&gt; 中，右子树：右 -&gt; 左 -&gt; 中</strong>，所以我把这个遍历顺序也称之为 “后序遍历”（尽管不是严格的后序遍历）。</p></li></ol><p>递归的 java 整体代码如下：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 递归法，后续遍历</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isSymmetric</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">return</span> <span class="token function">compare</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">compare</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> left<span class="token punctuation">,</span> <span class="token class-name">TreeNode</span> right<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token comment">// 递归终止条件</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token comment">// 先排除存在空节点的情况</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> right <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> right <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token comment">// 此时两个节点都不为空，但是值不相等</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>left<span class="token punctuation">.</span>val <span class="token operator">!=</span> right<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token comment">// 递归（对应的情况是：左右子树都不为空，且值相等）</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token keyword">boolean</span> outside <span class="token operator">=</span> <span class="token function">compare</span><span class="token punctuation">(</span>left<span class="token punctuation">.</span>left<span class="token punctuation">,</span> right<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 比较外侧：左子树。左 与 右子树。右</span></pre></td></tr><tr><td data-num="18"></td><td><pre>        <span class="token keyword">boolean</span> inside <span class="token operator">=</span> <span class="token function">compare</span><span class="token punctuation">(</span>left<span class="token punctuation">.</span>right<span class="token punctuation">,</span> right<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 比较内侧：左子树。右 与 右子树。左</span></pre></td></tr><tr><td data-num="19"></td><td><pre>        <span class="token keyword">return</span> outside <span class="token operator">&amp;&amp;</span> inside<span class="token punctuation">;</span> <span class="token comment">// 两侧都相等才是对称的：左子树。中 与 右子树。中</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="21"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20221217195725774.png" alt="image-20221217195725774">、</p><h4 id="迭代法-2"><a class="anchor" href="#迭代法-2">#</a> 迭代法</h4><p>这道题目我们也可以使用迭代法，但要注意，<strong>这里的迭代法可不是前中后序的迭代写法</strong>，因为本题的本质是判断两个树是否是相互翻转的，其实已经不是所谓二叉树遍历的前中后序的关系了。</p><h5 id="使用队列"><a class="anchor" href="#使用队列">#</a> 使用队列</h5><p>这里我们可以使用队列来比较两个树（根节点的左右子树）是否相互翻转，（<strong>注意这不是层序遍历</strong>）</p><p><strong>通过<mark>队列</mark>来判断根节点的左子树和右子树的内侧和外侧是否相等</strong>，如动画所示：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/101.%25E5%25AF%25B9%25E7%25A7%25B0%25E4%25BA%258C%25E5%258F%2589%25E6%25A0%2591.gif" alt="101.对称二叉树"></p><p>如下的条件判断和递归的逻辑是一样的。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 迭代法，使用队列</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isSymmetric</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TreeNode</span><span class="token punctuation">></span></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将左子树的根节点入队</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将右子树的根节点入队</span></pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>            <span class="token class-name">TreeNode</span> left <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将左子树的根节点出队</span></pre></td></tr><tr><td data-num="12"></td><td><pre>            <span class="token class-name">TreeNode</span> right <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将右子树的根节点出队</span></pre></td></tr><tr><td data-num="13"></td><td><pre></pre></td></tr><tr><td data-num="14"></td><td><pre>            <span class="token comment">// 左右子树的根节点都为空，继续循环</span></pre></td></tr><tr><td data-num="15"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> right <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre></pre></td></tr><tr><td data-num="17"></td><td><pre>            <span class="token comment">// 左右子树的根节点有一个为空，或者两个根节点的值不相等，返回 false</span></pre></td></tr><tr><td data-num="18"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> right <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> left<span class="token punctuation">.</span>val <span class="token operator">!=</span> right<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre></pre></td></tr><tr><td data-num="20"></td><td><pre>            <span class="token comment">// 此时左、右子树的根节点均不为空，且值相等</span></pre></td></tr><tr><td data-num="21"></td><td><pre>            queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>left<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将左子树的左子节点入队</span></pre></td></tr><tr><td data-num="22"></td><td><pre>            queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>right<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将右子树的右子节点入队</span></pre></td></tr><tr><td data-num="23"></td><td><pre>            queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>left<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将左子树的右子节点入队</span></pre></td></tr><tr><td data-num="24"></td><td><pre>            queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>right<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将右子树的左子节点入队</span></pre></td></tr><tr><td data-num="25"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="26"></td><td><pre></pre></td></tr><tr><td data-num="27"></td><td><pre>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="29"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>时间效率比递归法差：<img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20221217201334418.png" alt="image-20221217201334418"></p><h5 id="使用栈"><a class="anchor" href="#使用栈">#</a> 使用栈</h5><p>细心的话，其实可以发现，<strong>这个迭代法，其实是把左右两个子树要比较的元素顺序放进一个容器，然后成对成对的取出来进行比较，那么其实使用栈也是可以的</strong>。</p><p>只要把队列<strong>原封不动的改成栈就可以了</strong>，我下面也给出了代码。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 迭代法，使用栈</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isSymmetric</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TreeNode</span><span class="token punctuation">></span></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将左子树的根节点入队</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将右子树的根节点入队</span></pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>            <span class="token class-name">TreeNode</span> left <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将左子树的根节点出队</span></pre></td></tr><tr><td data-num="12"></td><td><pre>            <span class="token class-name">TreeNode</span> right <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将右子树的根节点出队</span></pre></td></tr><tr><td data-num="13"></td><td><pre></pre></td></tr><tr><td data-num="14"></td><td><pre>            <span class="token comment">// 左右子树的根节点都为空，继续循环</span></pre></td></tr><tr><td data-num="15"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> right <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre></pre></td></tr><tr><td data-num="17"></td><td><pre>            <span class="token comment">// 左右子树的根节点有一个为空，或者两个根节点的值不相等，返回 false</span></pre></td></tr><tr><td data-num="18"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> right <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> left<span class="token punctuation">.</span>val <span class="token operator">!=</span> right<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre></pre></td></tr><tr><td data-num="20"></td><td><pre>            <span class="token comment">// 此时左、右子树的根节点均不为空，且值相等</span></pre></td></tr><tr><td data-num="21"></td><td><pre>            stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>left<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将左子树的左子节点入队</span></pre></td></tr><tr><td data-num="22"></td><td><pre>            stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>right<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将右子树的右子节点入队</span></pre></td></tr><tr><td data-num="23"></td><td><pre>            stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>left<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将左子树的右子节点入队</span></pre></td></tr><tr><td data-num="24"></td><td><pre>            stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>right<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将右子树的左子节点入队</span></pre></td></tr><tr><td data-num="25"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>        </pre></td></tr><tr><td data-num="27"></td><td><pre>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="29"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20221217201744667.png" alt="image-20221217201744667"></p><h4 id="总结-13"><a class="anchor" href="#总结-13">#</a> 总结</h4><p>这次我们又深度剖析了一道二叉树的 “简单题”，大家会发现，真正的把题目搞清楚其实并不简单，leetcode 上 accept 了和真正掌握了还是有距离的。</p><p>我们介绍了<strong>递归法</strong>和<strong>迭代法</strong>，递归依然通过<mark>递归三部曲</mark>来解决了这道题目，如果只看精简的代码根本看不出来递归三部曲是如果解题的。</p><p>在迭代法中我们使用了队列，需要注意的是这不是层序遍历，而且仅仅<mark>通过一个容器来成对的存放我们要比较的元素</mark>，知道这一本质之后就发现，用队列，用栈，甚至用数组，都是可以的。</p><p>如果已经做过这道题目的同学，读完文章可以再去看看这道题目，思考一下，会有不一样的发现！</p><h4 id="相关题目推荐"><a class="anchor" href="#相关题目推荐">#</a> 相关题目推荐</h4><p>这两道题目基本和本题是一样的，只要稍加修改就可以 AC。</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zYW1lLXRyZWUv">100. 相同的树</span></li></ul><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 递归</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isSameTree</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> p<span class="token punctuation">,</span> <span class="token class-name">TreeNode</span> q<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token keyword">return</span> <span class="token function">compare</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> q<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">compare</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> p<span class="token punctuation">,</span> <span class="token class-name">TreeNode</span> q<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token comment">// 递归终止条件</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token comment">// 存在空节点的情况</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> q <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> q <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> q <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token comment">// 两个节点都不为空，且值不相等</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>val <span class="token operator">!=</span> q<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token comment">// 单层递归的逻辑</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token keyword">boolean</span> left <span class="token operator">=</span> <span class="token function">compare</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>left<span class="token punctuation">,</span> q<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 左子树是否相同</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token keyword">boolean</span> right <span class="token operator">=</span> <span class="token function">compare</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>right<span class="token punctuation">,</span> q<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 右子树是否相同</span></pre></td></tr><tr><td data-num="18"></td><td><pre>        <span class="token keyword">return</span> left <span class="token operator">&amp;&amp;</span> right<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="20"></td><td><pre></pre></td></tr><tr><td data-num="21"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20221217202604861.png" alt="image-20221217202604861"></p><ul><li><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zdWJ0cmVlLW9mLWFub3RoZXItdHJlZS9kZXNjcmlwdGlvbi8/cT0lRTklODAlOTIlRTUlQkQlOTImYW1wO29yZGVyQnk9bW9zdF9yZWxldmFudA==">572. 另一棵树的子树</span></p><blockquote><p>双递归！</p></blockquote><p>看到题目描述，首先判断一个树是否是另一棵树的子树，很明显想到可以用递归，但是两棵树完全相同也可以看做一棵树是另一棵树的子树。 所以自然而然想到用<strong>一个判断两棵树是否相同的递归函数</strong>。</p></li></ul><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 递归判断 subRoot 是否是 root 的子树</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isSubtree</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">,</span> <span class="token class-name">TreeNode</span> subRoot<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token comment">// 递归终止条件</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> subRoot <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">//root 为空，subRoot 不为空，那么 subRoot 必不是 root 的子树</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>subRoot <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment">//subRoot 为 null，则一定是 root 的子树</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token comment">// 递归过程，满足子树条件的情况有三种：</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token comment">// 1. root 和 subRoot 是同一棵树；2. root 的左子树是 subRoot；3. root 的右子树是 subRoot</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token keyword">return</span> <span class="token function">isSameTree</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> subRoot<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token function">isSubtree</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> subRoot<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token function">isSubtree</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> subRoot<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token comment">// 递归判断两棵树是否相同</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">isSameTree</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">,</span> <span class="token class-name">TreeNode</span> subRoot<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token comment">// 递归终止条件</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> subRoot <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> subRoot <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>val <span class="token operator">!=</span> subRoot<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>        <span class="token comment">// 递归过程：此时 root 和 subRoot 都不为空，且值相等，则比较左右子树</span></pre></td></tr><tr><td data-num="19"></td><td><pre>        <span class="token keyword">return</span> <span class="token function">isSameTree</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> subRoot<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isSameTree</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> subRoot<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="21"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20221217205916411.png" alt="image-20221217205916411"></p><h3 id="104-二叉树的最大深度"><a class="anchor" href="#104-二叉树的最大深度">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tYXhpbXVtLWRlcHRoLW9mLWJpbmFyeS10cmVlLw==">104. 二叉树的最大深度</span></h3><p>看完本篇可以一起做了如下两道题目：</p><ul><li>104. 二叉树的最大深度</li><li>559.n 叉树的最大深度</li></ul><h4 id="递归-2"><a class="anchor" href="#递归-2">#</a> 递归</h4><p>本题可以使用前序（中左右），也可以使用后序遍历（左右中），<strong>使用<u>前序</u>求的就是深度，使用<u>后序</u>求的是高度</strong>。</p><ul><li><p>二叉树节点的深度：指从<u>根节点</u>到<u>该节点</u>的最长简单路径边的条数或者节点数（取决于深度从 0 开始还是从 1 开始）</p><blockquote><p>从上往下访问（前序遍历），每到下一层，深度 + 1</p></blockquote></li><li><p>二叉树节点的高度：指从<u>该节点</u>到<u>叶子节点</u>的最长简单路径边的条数或者节点数（取决于高度从 0 开始还是从 1 开始）</p><blockquote><p>从下往上访问（后序遍历），每到上一层，统计左、右子树的最大高度，在此基础上 + 1</p></blockquote></li></ul><p><strong>而<mark>根节点的高度就是二叉树的最大深度</mark></strong>，所以本题中我们<strong>通过<u>后序</u>求的根节点高度来求的二叉树最大深度</strong>。</p><p>这一点其实是很多同学没有想清楚的，很多题解同样没有讲清楚。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20221218132117585.png" alt="image-20221218132117585"></p><h5 id="u后序u遍历计算根节点的高度"><a class="anchor" href="#u后序u遍历计算根节点的高度">#</a> <u>后序</u>遍历：计算根节点的高度</h5><ol><li><p>参数、返回值：参数就是传入树的根节点，返回就返回这棵树的深度，所以返回值为 int 类型。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">maxDepth</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span></pre></td></tr></table></figure></li><li><p>递归终止条件：如果为空节点的话，就返回 0，表示高度为 0。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr></table></figure></li><li><p>单层递归的逻辑：先求它的左子树的深度，再求的右子树的深度，最后<strong>取左右深度最大的数值 再 + 1</strong> （加 1 是因为算上当前中间节点）就是目前节点为根节点的树的深度。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> leftDepth <span class="token operator">=</span> <span class="token function">maxDepth</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">int</span> rightDepth <span class="token operator">=</span> <span class="token function">maxDepth</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">return</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>leftDepth<span class="token punctuation">,</span> rightDepth<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr></table></figure></li></ol><p>整体 java 代码如下：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 递归实现</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">maxDepth</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token comment">// 递归终止条件</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token comment">// 递归过程</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token keyword">int</span> leftDepth <span class="token operator">=</span> <span class="token function">maxDepth</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 左</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token keyword">int</span> rightDepth <span class="token operator">=</span> <span class="token function">maxDepth</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 右</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token keyword">return</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>leftDepth<span class="token punctuation">,</span> rightDepth<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 根：+1 是因为算上当前根节点</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20221218130136622.png" alt="image-20221218130136622"></p><p>精简后的代码如下：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 递归实现</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">maxDepth</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token comment">// 递归终止条件</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token comment">// 递归过程</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token keyword">return</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token function">maxDepth</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">maxDepth</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><strong>精简之后的代码根本看不出是哪种遍历方式，也看不出递归三部曲的步骤，所以如果对二叉树的操作还不熟练，尽量不要直接照着精简代码来学。</strong></p><h5 id="u前序u遍历计算最大深度"><a class="anchor" href="#u前序u遍历计算最大深度">#</a> <u>前序</u>遍历：计算最大深度</h5><p>本题当然也可以使用 **<u>前序</u>**，代码如下：(<strong>充分表现出求深度回溯的过程</strong>)</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">int</span> res<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">getDepth</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> node<span class="token punctuation">,</span> <span class="token keyword">int</span> depth<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        res <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> depth<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 根</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token comment">// 递归终止条件：叶子节点</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>left <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> node<span class="token punctuation">.</span>right <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="9"></td><td><pre>            <span class="token keyword">return</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 左</span></pre></td></tr><tr><td data-num="12"></td><td><pre>            depth<span class="token operator">++</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>            <span class="token function">getDepth</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">,</span> depth<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>            depth<span class="token operator">--</span><span class="token punctuation">;</span> <span class="token comment">// 回溯</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 右</span></pre></td></tr><tr><td data-num="17"></td><td><pre>            depth<span class="token operator">++</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>            <span class="token function">getDepth</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span> depth<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>            depth<span class="token operator">--</span><span class="token punctuation">;</span> <span class="token comment">// 回溯</span></pre></td></tr><tr><td data-num="20"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>        <span class="token keyword">return</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="23"></td><td><pre></pre></td></tr><tr><td data-num="24"></td><td><pre>    <span class="token comment">// 递归实现（前序遍历：求根节点到当前结点 root 的 “深度”）</span></pre></td></tr><tr><td data-num="25"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">maxDepth</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>        res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> res<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>        <span class="token function">getDepth</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 从根节点开始，深度为 1</span></pre></td></tr><tr><td data-num="29"></td><td><pre>        <span class="token keyword">return</span> res<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="31"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20221218132820800.png" alt="image-20221218132820800"></p><p><strong>可以看出使用了前序（中左右）的遍历顺序，这才是真正求深度的逻辑！</strong></p><p>简化后的代码如下：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">int</span> res<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">getDepth</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> node<span class="token punctuation">,</span> <span class="token keyword">int</span> depth<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        res <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> depth<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 根</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token comment">// 递归终止条件：叶子节点</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>left <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> node<span class="token punctuation">.</span>right <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="9"></td><td><pre>            <span class="token keyword">return</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 左</span></pre></td></tr><tr><td data-num="12"></td><td><pre>            <span class="token function">getDepth</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">,</span> depth <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 右</span></pre></td></tr><tr><td data-num="15"></td><td><pre>            <span class="token function">getDepth</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span> depth <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token keyword">return</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="19"></td><td><pre></pre></td></tr><tr><td data-num="20"></td><td><pre>    <span class="token comment">// 递归实现（前序遍历：求根节点到当前结点 root 的 “深度”）</span></pre></td></tr><tr><td data-num="21"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">maxDepth</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>        res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> res<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>        <span class="token function">getDepth</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 从根节点开始，深度为 1</span></pre></td></tr><tr><td data-num="25"></td><td><pre>        <span class="token keyword">return</span> res<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="27"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h4 id="迭代层序遍历"><a class="anchor" href="#迭代层序遍历">#</a> 迭代（层序遍历）</h4><p>使用迭代法的话，使用<strong>层序遍历</strong>是最为合适的，因为最大的深度就是二叉树的层数，和层序遍历的方式极其吻合。</p><p>在二叉树中，一层一层的来遍历二叉树，记录一下遍历的层数就是二叉树的深度，如图所示：</p><p><img data-src="https://img-blog.csdnimg.cn/20200810193056585.png" alt="层序遍历"></p><p>所以这道题的迭代法就是一道模板题，<strong>可以使用二叉树层序遍历的模板来解决</strong>的。</p><p>如果对层序遍历还不清楚的话，可以看这篇：[102. 二叉树的层序遍历](#102. 二叉树的层序遍历)</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 迭代实现（借助队列，层序遍历）</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">maxDepth</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TreeNode</span><span class="token punctuation">></span></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre>            <span class="token keyword">return</span> res<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token keyword">else</span></pre></td></tr><tr><td data-num="9"></td><td><pre>            queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 根节点入队</span></pre></td></tr><tr><td data-num="10"></td><td><pre></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>            <span class="token keyword">int</span> size <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 当前层的节点数</span></pre></td></tr><tr><td data-num="13"></td><td><pre>            <span class="token keyword">while</span> <span class="token punctuation">(</span>size <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>                <span class="token class-name">TreeNode</span> tmpNode <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 出队</span></pre></td></tr><tr><td data-num="15"></td><td><pre>                <span class="token keyword">if</span> <span class="token punctuation">(</span>tmpNode<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="16"></td><td><pre>                    queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>tmpNode<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 左子节点入队</span></pre></td></tr><tr><td data-num="17"></td><td><pre>                <span class="token keyword">if</span> <span class="token punctuation">(</span>tmpNode<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="18"></td><td><pre>                    queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>tmpNode<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 右子节点入队</span></pre></td></tr><tr><td data-num="19"></td><td><pre>                size<span class="token operator">--</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>            <span class="token punctuation">&#125;</span> <span class="token comment">// 当前层的节点全部出队</span></pre></td></tr><tr><td data-num="21"></td><td><pre>            res<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">// 每出队一层，深度加一</span></pre></td></tr><tr><td data-num="22"></td><td><pre>        <span class="token punctuation">&#125;</span> <span class="token comment">// 队列为空，遍历结束</span></pre></td></tr><tr><td data-num="23"></td><td><pre>        <span class="token keyword">return</span> res<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="25"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20221218134940494.png" alt="image-20221218134940494"></p><h3 id="559-n-叉树的最大深度"><a class="anchor" href="#559-n-叉树的最大深度">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tYXhpbXVtLWRlcHRoLW9mLW4tYXJ5LXRyZWUv">559. N 叉树的最大深度</span></h3><p>依然可以提供递归法和迭代法，来解决这个问题，思路是和二叉树思路一样的，只不过二叉树中遍历的是左、右孩子，而 N 叉树遍历的是所有孩子，直接给出代码如下：</p><h4 id="递归后序遍历"><a class="anchor" href="#递归后序遍历">#</a> 递归（后序遍历）</h4><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 递归实现（后序遍历）</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">maxDepth</span><span class="token punctuation">(</span><span class="token class-name">Node</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token comment">// 递归终止条件</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token comment">// 递归过程</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token keyword">int</span> max <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Node</span> child <span class="token operator">:</span> root<span class="token punctuation">.</span>children<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 遍历子节点</span></pre></td></tr><tr><td data-num="9"></td><td><pre>            max <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>max<span class="token punctuation">,</span> <span class="token function">maxDepth</span><span class="token punctuation">(</span>child<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token keyword">return</span> max <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 根：在子节点中找到最大深度，然后加 1</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h4 id="迭代层序遍历-2"><a class="anchor" href="#迭代层序遍历-2">#</a> 迭代（层序遍历）</h4><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 迭代实现（借助队列，层序遍历）</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">maxDepth</span><span class="token punctuation">(</span><span class="token class-name">Node</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Node</span><span class="token punctuation">></span></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Queue 接口，LinkedList 实现类</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre>            <span class="token keyword">return</span> res<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token keyword">else</span></pre></td></tr><tr><td data-num="9"></td><td><pre>            queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//root 入队</span></pre></td></tr><tr><td data-num="10"></td><td><pre></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>            <span class="token keyword">int</span> size <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 当前层的节点数</span></pre></td></tr><tr><td data-num="13"></td><td><pre>            <span class="token keyword">while</span> <span class="token punctuation">(</span>size <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>                <span class="token class-name">Node</span> tmpNode <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Node</span> node <span class="token operator">:</span> tmpNode<span class="token punctuation">.</span>children<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>                    queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将当前节点的所有子节点入队</span></pre></td></tr><tr><td data-num="17"></td><td><pre>                <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>                size<span class="token operator">--</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>            <span class="token punctuation">&#125;</span> <span class="token comment">// 当前层遍历完毕</span></pre></td></tr><tr><td data-num="20"></td><td><pre>            res<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">// 深度加一</span></pre></td></tr><tr><td data-num="21"></td><td><pre>        <span class="token punctuation">&#125;</span> <span class="token comment">// 队列为空，遍历完毕</span></pre></td></tr><tr><td data-num="22"></td><td><pre>        <span class="token keyword">return</span> res<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="24"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20221218135846469.png" alt="image-20221218135846469"></p><h3 id="111-二叉树的最小深度"><a class="anchor" href="#111-二叉树的最小深度">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9taW5pbXVtLWRlcHRoLW9mLWJpbmFyeS10cmVlLw==">111. 二叉树的最小深度</span></h3><blockquote><p>和求最大深度一个套路？</p></blockquote><p>直觉上好像和求最大深度差不多，其实还是差不少的。</p><p>本题依然是前序遍历和后序遍历都可以，<strong>前序求的是深度，后序求的是高度</strong>。</p><ul><li>二叉树节点的<mark>深度</mark>：指从<u>根节点</u>到<u>该节点</u>的最长简单路径边的条数或者节点数（取决于深度从 0 开始还是从 1 开始）</li><li>二叉树节点的<mark>高度</mark>：指从<u>该节点</u>到<u>叶子节点</u>的最长简单路径边的条数后者节点数（取决于高度从 0 开始还是从 1 开始）</li></ul><p>那么使用后序遍历，其实求的是根节点到叶子节点的最小距离，就是求高度的过程，这不过这个最小距离也同样是最小深度。</p><p>以下讲解中遍历顺序上依然采用后序遍历（因为要比较递归返回之后的结果，本文我也给出前序遍历的写法）。</p><p>本题还有一个误区，在处理节点的过程中，最大深度很容易理解，最小深度就不那么好理解，如图：</p><p><img data-src="https://img-blog.csdnimg.cn/20210203155800503.png" alt="111.二叉树的最小深度"></p><p>这就重新审题了，题目中说的是：<strong>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。<strong>注意是</strong>叶子节点</strong>。</p><p>什么是叶子节点，左右孩子都为空的节点才是叶子节点！</p><h4 id="递归后序遍历-2"><a class="anchor" href="#递归后序遍历-2">#</a> 递归（后序遍历）</h4><ol><li><p>参数、返回值：参数为要传入的二叉树根节点，返回的是 int 类型的深度。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">minDepth</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span></pre></td></tr></table></figure></li><li><p>终止条件：遇到<u>空节点</u>返回 0，表示当前节点的高度为 0。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr></table></figure></li><li><p>单层递归逻辑：这块和求最大深度可就不一样了，一些同学可能会写如下代码：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> leftDepth <span class="token operator">=</span> <span class="token function">minDepth</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">int</span> rightDepth <span class="token operator">=</span> <span class="token function">minDepth</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token function">min</span><span class="token punctuation">(</span>leftDepth<span class="token punctuation">,</span> rightDepth<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">return</span> result<span class="token punctuation">;</span></pre></td></tr></table></figure><p>这个代码就犯了此图中的误区：</p><p><img data-src="https://img-blog.csdnimg.cn/20210203155800503.png" alt="111.二叉树的最小深度"></p><p><strong>如果这么求的话，没有左孩子的分支会算为最短深度</strong>。</p><p>所以，</p><ul><li>如果左子树为空，右子树不为空，说明最小深度是 1 + 右子树的深度</li><li>如果右子树为空，左子树不为空，最小深度是 1 + 左子树的深度</li><li>最后，如果左右子树都不为空，返回左右子树深度最小值 + 1</li></ul><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> leftDepth <span class="token operator">=</span> <span class="token function">minDepth</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 左子树的最小深度</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">int</span> rightDepth <span class="token operator">=</span> <span class="token function">minDepth</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 右子树的最小深度</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">// 中</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment">// 若左子树为空，右子树非空，此时并不是最小深度</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>left <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> root<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span> <span class="token operator">+</span> rightDepth<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token comment">// 若右子树为空，左子树非空，此时并不是最小深度</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> root<span class="token punctuation">.</span>right <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span> <span class="token operator">+</span> leftDepth<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token comment">// 若左右子树都不为空，返回左右子树最小深度的最小值</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">return</span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>leftDepth<span class="token punctuation">,</span> rightDepth<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>遍历的顺序为后序（左右中），可以看出：<strong>求二叉树的最小深度和求二叉树的最大深度的差别主要在于处理<u>左右孩子不为空的逻辑</u>。</strong></p></li></ol><p>完整代码如下：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 递归（后序遍历）</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">minDepth</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token comment">// 递归终止条件</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token comment">// 递归过程</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token keyword">int</span> leftDepth <span class="token operator">=</span> <span class="token function">minDepth</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 左子树的最小深度</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token keyword">int</span> rightDepth <span class="token operator">=</span> <span class="token function">minDepth</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 右子树的最小深度</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token comment">// 中</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token comment">// 若左子树为空，右子树非空，此时并不是最小深度</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>left <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> root<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span> <span class="token operator">+</span> rightDepth<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token comment">// 若右子树为空，左子树非空，此时并不是最小深度</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> root<span class="token punctuation">.</span>right <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span> <span class="token operator">+</span> leftDepth<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token comment">// 若左右子树都不为空，返回左右子树最小深度的最小值</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token keyword">return</span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>leftDepth<span class="token punctuation">,</span> rightDepth<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20221218172628162.png" alt="image-20221218172628162"></p><h4 id="迭代层序遍历-3"><a class="anchor" href="#迭代层序遍历-3">#</a> 迭代（层序遍历）</h4><p>借助队列，通过层序遍历。</p><p><strong>需要注意的是，只有当左右孩子都为空的时候，才说明遍历的最低点了。如果其中一个孩子为空则不是最低点。</strong></p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 借助队列实现</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">minDepth</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token keyword">int</span> minDepth <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre>            <span class="token keyword">return</span> minDepth<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TreeNode</span><span class="token punctuation">></span></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>            minDepth<span class="token operator">++</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>            <span class="token keyword">int</span> size <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>            <span class="token keyword">while</span> <span class="token punctuation">(</span>size <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>                <span class="token class-name">TreeNode</span> tmpNode <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>                <span class="token comment">// 如果当前节点是叶子节点，直接返回</span></pre></td></tr><tr><td data-num="16"></td><td><pre>                <span class="token keyword">if</span> <span class="token punctuation">(</span>tmpNode<span class="token punctuation">.</span>left <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> tmpNode<span class="token punctuation">.</span>right <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="17"></td><td><pre>                    <span class="token keyword">return</span> minDepth<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre></pre></td></tr><tr><td data-num="19"></td><td><pre>                <span class="token keyword">if</span> <span class="token punctuation">(</span>tmpNode<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="20"></td><td><pre>                    queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>tmpNode<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>                <span class="token keyword">if</span> <span class="token punctuation">(</span>tmpNode<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="22"></td><td><pre>                    queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>tmpNode<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>                size<span class="token operator">--</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>        <span class="token keyword">return</span> minDepth<span class="token punctuation">;</span> <span class="token comment">// 实际上不会执行到这里，因为上面的 return 已经返回了</span></pre></td></tr><tr><td data-num="27"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="28"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20221218171427585.png" alt="image-20221218171427585"></p><h3 id="222-完全二叉树的节点个数"><a class="anchor" href="#222-完全二叉树的节点个数">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb3VudC1jb21wbGV0ZS10cmVlLW5vZGVzLw==">222. 完全二叉树的节点个数</span></h3><h4 id="普通二叉树"><a class="anchor" href="#普通二叉树">#</a> 普通二叉树</h4><p>首先按照普通二叉树的逻辑来求。</p><p>这道题目的递归法和求二叉树的深度写法类似， 而迭代法，<span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVyY2FybC5jb20vMDEwMi4lRTQlQkElOEMlRTUlOEYlODklRTYlQTAlOTElRTclOUElODQlRTUlQjElODIlRTUlQkElOEYlRTklODElOEQlRTUlOEUlODYuaHRtbA==">二叉树：层序遍历登场！</span>遍历模板稍稍修改一下，记录遍历的节点数量就可以了。</p><h5 id="递归后序遍历-3"><a class="anchor" href="#递归后序遍历-3">#</a> 递归（后序遍历）</h5><ol><li><p>参数、返回值：参数就是传入树的根节点，返回就返回<strong>以该节点为根的二叉树的节点数量</strong>，所以返回值为 int 类型。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">countNodes</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span></pre></td></tr></table></figure></li><li><p>递归终止条件：如果为空节点的话，就返回 0，表示节点数为 0。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr></table></figure></li><li><p>单层递归逻辑：先求它的左子树的节点数量，再求的右子树的节点数量，最后取总和再加一 （加 1 是因为算上当前中间节点）就是目前节点为根节点的节点数量。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> leftCount <span class="token operator">=</span> <span class="token function">countNodes</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 左子树节点个数</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">int</span> rightCount <span class="token operator">=</span> <span class="token function">countNodes</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 右子树节点个数</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">int</span> treeCount <span class="token operator">=</span> leftCount <span class="token operator">+</span> rightCount <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 当前树的节点个数，+1 是根节点</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">return</span> treeCount<span class="token punctuation">;</span></pre></td></tr></table></figure></li></ol><p>完整的 java 代码如下：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 递归（后序遍历）</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">countNodes</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token comment">// 递归终止条件</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token comment">// 递归过程</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token keyword">int</span> leftCount <span class="token operator">=</span> <span class="token function">countNodes</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 左子树节点个数</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token keyword">int</span> rightCount <span class="token operator">=</span> <span class="token function">countNodes</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 右子树节点个数</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token keyword">int</span> treeCount <span class="token operator">=</span> leftCount <span class="token operator">+</span> rightCount <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 当前树的节点个数，+1 是根节点</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token keyword">return</span> treeCount<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20221218180104704.png" alt="image-20221218180104704"></p><ul><li>时间复杂度：O (n)</li><li>空间复杂度：O (log n)，算上了递归系统栈占用的空间</li></ul><h5 id="迭代层序遍历-4"><a class="anchor" href="#迭代层序遍历-4">#</a> 迭代（层序遍历）</h5><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 迭代（层序遍历），借助队列</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">countNodes</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TreeNode</span><span class="token punctuation">></span></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre>            <span class="token keyword">return</span> count<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token keyword">else</span></pre></td></tr><tr><td data-num="9"></td><td><pre>            queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>            <span class="token keyword">int</span> size <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>            <span class="token keyword">while</span> <span class="token punctuation">(</span>size <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>                <span class="token class-name">TreeNode</span> tmpNode <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>                count<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">// 每次出队一个节点，计数加一</span></pre></td></tr><tr><td data-num="16"></td><td><pre>                <span class="token keyword">if</span> <span class="token punctuation">(</span>tmpNode<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="17"></td><td><pre>                    queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>tmpNode<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>                <span class="token keyword">if</span> <span class="token punctuation">(</span>tmpNode<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="19"></td><td><pre>                    queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>tmpNode<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>                size<span class="token operator">--</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>        <span class="token keyword">return</span> count<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="25"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20221218180726667.png" alt="image-20221218180726667"></p><ul><li>时间复杂度：O (n)</li><li>空间复杂度：O (n)</li></ul><h4 id="完全二叉树递归后序遍历"><a class="anchor" href="#完全二叉树递归后序遍历">#</a> 完全二叉树（递归（后序遍历））</h4><p>在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。<strong>若最底层为第 h 层，则该层包含 1~ 2^(h-1) 个节点</strong>。</p><p>大家要自己看完全二叉树的定义，很多同学对完全二叉树其实不是真正的懂了。</p><p>我来举一个典型的例子如题：</p><p><img data-src="https://img-blog.csdnimg.cn/20200920221638903.png" alt="img"></p><p>完全二叉树只有<mark>两种情况</mark>：</p><ul><li><p>满二叉树</p><blockquote><p>用 <code>2^树深度^ - 1</code> 来计算所有节点个数，注意这里根节点深度为 1</p></blockquote></li><li><p>最后一层叶子节点没有满</p><blockquote><p><strong>分别递归左孩子，和右孩子</strong>，递归到某一深度一定会有左孩子或者右孩子为满二叉树，然后依然可以按照情况 1 来计算。</p></blockquote></li></ul><p>完全二叉树（一）如图： <img data-src="https://img-blog.csdnimg.cn/20201124092543662.png" alt="222.完全二叉树的节点个数"></p><p>完全二叉树（二）如图： <img data-src="https://img-blog.csdnimg.cn/20201124092634138.png" alt="222.完全二叉树的节点个数1"></p><p>可以看出<strong>如果整个树不是满二叉树，就递归其左右孩子，直到遇到满二叉树为止，用公式计算这个子树（满二叉树）的节点数量</strong>。</p><p>这里关键在于<strong>如果判断一个左子树或者右子树是不是满二叉树呢？</strong></p><p><strong><u>在完全二叉树中</u>，如果递归向左遍历的深度等于递归向右遍历的深度，那说明就是满二叉树</strong>。如图：</p><p><img data-src="https://code-thinking-1253855093.file.myqcloud.com/pics/20220829163554.png" alt="img"></p><p>在完全二叉树中，如果递归向左遍历的深度不等于递归向右遍历的深度，则说明不是满二叉树，如图：</p><p><img data-src="https://code-thinking-1253855093.file.myqcloud.com/pics/20220829163709.png" alt="img"></p><p>哪有录友说了，这种情况，递归向左遍历的深度等于递归向右遍历的深度，但也不是满二叉树，如题：</p><p><img data-src="https://code-thinking-1253855093.file.myqcloud.com/pics/20220829163811.png" alt="img"></p><p>如果这么想，大家就是对 完全二叉树理解有误区了，<strong>以上这棵二叉树，它根本就不是一个完全二叉树</strong>！</p><p>判断其子树是不是满二叉树，如果是则利用用公式计算这个子树（满二叉树）的节点数量，如果不是则继续递归。那么<strong>递归三部曲</strong>为：</p><ol><li><p>参数、返回值：传入节点，返回以该节点为根的树的节点数量，类型为 int</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">countNodes</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span></pre></td></tr></table></figure></li><li><p>递归终止条件：</p><ol><li><p>如果节点为空，直接返回 0</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr></table></figure></li><li><p>如果节点的左、右子树的递归深度相同（可判断以节点为根的树为满二叉树），根据满二叉树的节点个数计算公式返回节点数</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">TreeNode</span> left <span class="token operator">=</span> root<span class="token punctuation">.</span>left<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name">TreeNode</span> right <span class="token operator">=</span> root<span class="token punctuation">.</span>right<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">int</span> leftDepth <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">int</span> rightDepth <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    leftDepth<span class="token operator">++</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    left <span class="token operator">=</span> left<span class="token punctuation">.</span>left<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">while</span> <span class="token punctuation">(</span>right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    rightDepth<span class="token operator">++</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    right <span class="token operator">=</span> right<span class="token punctuation">.</span>right<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token comment">// 如果左右深度相等，说明 root 为满二叉树，直接计算公式返回节点数</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token keyword">if</span> <span class="token punctuation">(</span>leftDepth <span class="token operator">==</span> rightDepth<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token comment">// 计算以 root 为根节点的满二叉树的节点数：2^(leftDepth+1)-1</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">pow</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> leftDepth <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token comment">// 如果左右深度不等，说明 root 不为满二叉树，继续递归，直到找到满二叉树</span></pre></td></tr></table></figure></li></ol></li><li><p>单层递归逻辑：后序遍历</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">/* --- 递归过程 --- */</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">int</span> leftCount <span class="token operator">=</span> <span class="token function">countNodes</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">int</span> rightCount <span class="token operator">=</span> <span class="token function">countNodes</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">int</span> res <span class="token operator">=</span> leftCount <span class="token operator">+</span> rightCount <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">return</span> res<span class="token punctuation">;</span></pre></td></tr></table></figure></li></ol><p>完整的 java 代码如下：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 递归（利用完全二叉树的特性，后序遍历）</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">countNodes</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token comment">/* --- 递归终止条件 --- */</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token comment">// 开始根据 左深度 == 右深度 判断 root 是否为满二叉树</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token class-name">TreeNode</span> left <span class="token operator">=</span> root<span class="token punctuation">.</span>left<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token class-name">TreeNode</span> right <span class="token operator">=</span> root<span class="token punctuation">.</span>right<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token keyword">int</span> leftDepth <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token keyword">int</span> rightDepth <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>            leftDepth<span class="token operator">++</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>            left <span class="token operator">=</span> left<span class="token punctuation">.</span>left<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token keyword">while</span> <span class="token punctuation">(</span>right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>            rightDepth<span class="token operator">++</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>            right <span class="token operator">=</span> right<span class="token punctuation">.</span>right<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>        <span class="token comment">// 如果左右深度相等，说明 root 为满二叉树，直接计算公式返回节点数</span></pre></td></tr><tr><td data-num="20"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>leftDepth <span class="token operator">==</span> rightDepth<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>            <span class="token comment">// 计算以 root 为根节点的满二叉树的节点数：2^(leftDepth+1)-1</span></pre></td></tr><tr><td data-num="22"></td><td><pre>            <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">pow</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> leftDepth <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>        <span class="token comment">// 如果左右深度不等，说明 root 不为满二叉树，继续递归，直到找到满二叉树</span></pre></td></tr><tr><td data-num="25"></td><td><pre></pre></td></tr><tr><td data-num="26"></td><td><pre>        <span class="token comment">/* --- 递归过程 --- */</span></pre></td></tr><tr><td data-num="27"></td><td><pre>        <span class="token keyword">int</span> leftCount <span class="token operator">=</span> <span class="token function">countNodes</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>        <span class="token keyword">int</span> rightCount <span class="token operator">=</span> <span class="token function">countNodes</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>        <span class="token keyword">int</span> res <span class="token operator">=</span> leftCount <span class="token operator">+</span> rightCount <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>        <span class="token keyword">return</span> res<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="31"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="32"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20221218185827881.png" alt="image-20221218185827881"></p><ul><li><p><strong>时间复杂度：O (log n × log n)</strong></p><blockquote><p>因为每次递归都要遍历一次树的高度，时间复杂度为 O (logn)，而递归次数为 logn</p></blockquote></li><li><p>空间复杂度：O (log n)</p><blockquote><p>递归栈的深度为树的高度，即 logn</p></blockquote></li></ul><h3 id="110-平衡二叉树"><a class="anchor" href="#110-平衡二叉树">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iYWxhbmNlZC1iaW5hcnktdHJlZS8=">☆110. 平衡二叉树</span></h3><blockquote><p>定义：一个二叉树<em>每个节点</em> 的左右两个子树的<strong>高度</strong>差的绝对值不超过 1 。</p></blockquote><p>使用<strong>递归</strong>方法，既然要比较高度，必然是要<strong>后序遍历</strong>。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20221218193755322.png" alt="image-20221218193755322"></p><ol><li><p>参数、返回值：</p><ul><li>参数：当前传入节点。</li><li>返回值：以当前传入节点为根节点的树的高度。</li></ul><p>那么如何标记左右子树是否差值大于 1 呢？</p><p>如果当前传入节点为根节点的二叉树已经不是二叉平衡树了，还返回高度的话就没有意义了。</p><p>所以<strong>如果已经不是二叉平衡树了，可以返回 - 1 来标记</strong>已经不符合平衡树的规则了。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">getHeight</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> node<span class="token punctuation">)</span></pre></td></tr></table></figure></li><li><p>递归终止条件：递归的过程中依然是<strong>遇到空节点了为终止，返回 0</strong>，表示当前节点为根节点的树高度为 0</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr></table></figure></li><li><p>单层递归逻辑：如何判断以当前传入节点为根节点的二叉树是否是平衡二叉树呢？当然是其左子树高度和其右子树高度的差值。</p><p>分别求出其左右子树的高度，然后如果差值小于等于 1，则返回当前二叉树的高度，否则则返回 - 1，表示已经不是二叉平衡树了。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> leftHeight <span class="token operator">=</span> <span class="token function">getHeight</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 左子树高度</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">if</span> <span class="token punctuation">(</span>leftHeight <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 剪枝</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">int</span> rightHeight <span class="token operator">=</span> <span class="token function">getHeight</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 右子树高度</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">if</span> <span class="token punctuation">(</span>rightHeight <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 剪枝</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">int</span> res<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span>leftHeight <span class="token operator">-</span> rightHeight<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    res <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>leftHeight<span class="token punctuation">,</span> rightHeight<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 中间节点的高度</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    res <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token keyword">return</span> res<span class="token punctuation">;</span></pre></td></tr></table></figure></li></ol><p>此时递归的函数就已经写出来了，<strong>这个递归的函数传入节点指针，返回以该节点为根节点的二叉树的高度，如果不是二叉平衡树，则返回 - 1</strong>。</p><p>完整 java 代码如下：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 递归，后序遍历</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">getHeight</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> node<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token comment">// 递归终止条件</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token comment">// 递归过程</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">int</span> leftHeight <span class="token operator">=</span> <span class="token function">getHeight</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 左子树高度</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>leftHeight <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 剪枝</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">int</span> rightHeight <span class="token operator">=</span> <span class="token function">getHeight</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 右子树高度</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>rightHeight <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 剪枝</span></pre></td></tr><tr><td data-num="10"></td><td><pre></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token keyword">int</span> res<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span>leftHeight <span class="token operator">-</span> rightHeight<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        res <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>leftHeight<span class="token punctuation">,</span> rightHeight<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 中间节点的高度</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        res <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token keyword">return</span> res<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>最后本题整体递归代码如下：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 递归，后序遍历</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">getHeight</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> node<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token comment">// 递归终止条件</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token comment">// 递归过程</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token keyword">int</span> leftHeight <span class="token operator">=</span> <span class="token function">getHeight</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 左子树高度</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>leftHeight <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 剪枝</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token keyword">int</span> rightHeight <span class="token operator">=</span> <span class="token function">getHeight</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 右子树高度</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>rightHeight <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 剪枝</span></pre></td></tr><tr><td data-num="11"></td><td><pre></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token keyword">int</span> res<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span>leftHeight <span class="token operator">-</span> rightHeight<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>            res <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>leftHeight<span class="token punctuation">,</span> rightHeight<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 中间节点的高度</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>            res <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>        <span class="token keyword">return</span> res<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="20"></td><td><pre></pre></td></tr><tr><td data-num="21"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isBalanced</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>        <span class="token keyword">return</span> <span class="token function">getHeight</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="24"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20221218195200788.png" alt="image-20221218195200788"></p><h4 id="总结-14"><a class="anchor" href="#总结-14">#</a> 总结</h4><p>通过本题可以了解求二叉树深度 和 二叉树高度的差异，<strong>求深度适合用前序遍历，而求高度适合用后序遍历</strong>。</p><p>本题迭代法其实有点复杂，大家可以有一个思路，也不一定说非要写出来。</p><p>但是<strong>递归</strong>方式是一定要掌握的！</p><h3 id="257-二叉树的所有路径"><a class="anchor" href="#257-二叉树的所有路径">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iaW5hcnktdHJlZS1wYXRocy8=">☆257. 二叉树的所有路径</span></h3><blockquote><p>以为只用了<strong>递归</strong>，其实还用了<strong>回溯</strong></p></blockquote><p>这道题目要求从根节点到叶子的路径，所以需要<strong>前序遍历</strong>，这样才方便让父节点指向孩子节点，找到对应的路径。</p><p>在这道题目中将第一次<strong>涉及到回溯</strong>，因为我们要把路径记录下来，需要回溯来回退一一个路径在进入另一个路径。</p><p>前序遍历以及回溯的过程如图：</p><p><img data-src="https://img-blog.csdnimg.cn/20210204151702443.png" alt="257.二叉树的所有路径"></p><p>我们先使用<strong>递归</strong>的方式，来做前序遍历。<strong>要知道递归和回溯就是一家的，本题也需要回溯。</strong></p><h4 id="递归-3"><a class="anchor" href="#递归-3">#</a> 递归</h4><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20221218202059928.png" alt="image-20221218202059928"></p><ol><li><p>参数、返回值：要传入根节点 root，记录每一条路径的 path，和存放结果集的 res，这里递归不需要返回值</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">traversal</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> cur<span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> path<span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> res<span class="token punctuation">)</span></pre></td></tr></table></figure></li><li><p>递归终止条件：之前都习惯了这么写：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">if</span> <span class="token punctuation">(</span>cur <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    终止处理逻辑</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>但是本题的终止条件这样写会很麻烦，因为<strong>本题要找到叶子节点，就开始结束的处理逻辑了（把路径放进 result 里）</strong>。</p><p><strong>那么什么时候算是找到了叶子节点？</strong> 是当 cur 不为空，其左右孩子都为空的时候，就找到叶子节点。</p><p>所以本题的终止条件是：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">if</span> <span class="token punctuation">(</span>cur<span class="token punctuation">.</span>left <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> cur<span class="token punctuation">.</span>right <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    终止处理逻辑</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>为什么没有判断 cur 是否为空呢，因为下面的逻辑可以控制空节点不入循环。</p><p>再来看一下<strong>终止处理的逻辑</strong>。</p><p>这里使用 List 结构 path 来记录路径，所以要把 List 结构的 path 转为 string 格式，再把这个 string 放进 res 里。</p><p><strong>那么为什么使用了 List 结构来记录路径呢？</strong> 因为在下面处理单层递归逻辑的时候，方便来做回溯。</p><p>可能有的同学问了，我看有些人的代码也没有回溯啊。</p><p><strong>其实是有回溯的，只不过隐藏在函数调用时的参数赋值里</strong>，下文我还会提到。</p><p>这里我们先使用 List 结构的 path 容器来记录路径，那么终止处理逻辑如下：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 递归终止条件：当前节点为叶子节点</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">if</span> <span class="token punctuation">(</span>cur<span class="token punctuation">.</span>left <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> cur<span class="token punctuation">.</span>right <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token class-name">StringBuilder</span> sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> path<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"->"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将 path 里记录的路径转为 string 格式</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>sb<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 收集一个路径</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">return</span><span class="token punctuation">;</span> <span class="token comment">// 递归终止</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure></li><li><p>单层递归逻辑：因为是<strong>前序遍历，需要先处理中间节点</strong>，中间节点就是我们要记录路径上的节点，先放进 path 中。</p><pre><code>path.push_back(cur-&gt;val);
</code></pre><p>然后是<strong>递归和回溯</strong>的过程，上面说过没有判断 cur 是否为空，那么在这里递归的时候，如果为空就不进行下一层递归了。</p><p>所以递归前要加上判断语句，下面要递归的节点是否为空，如下：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 左</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">if</span> <span class="token punctuation">(</span>cur<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 空节点不遍历，否则在 “递归终止条件” 处会报空指针异常</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token function">traversal</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>left<span class="token punctuation">,</span> path<span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    path<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 回溯</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token comment">// 右</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token keyword">if</span> <span class="token punctuation">(</span>cur<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token function">traversal</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>right<span class="token punctuation">,</span> path<span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    path<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 回溯</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>注意：我们知道，<strong>回溯和递归是一一对应的，有一个递归，就要有一个回溯</strong>，不能把递归和回溯拆开了， 一个在花括号里，一个在花括号外。<strong>回溯要和递归永远在一起，世界上最遥远的距离是你在花括号里，而我在花括号外！</strong></p></li></ol><p>本题的完整代码如下：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 递归（前序遍历）+ 回溯</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> <span class="token function">binaryTreePaths</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> path <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 记录单条路径</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token function">traversal</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> path<span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token keyword">return</span> res<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token comment">// 递归函数</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">traversal</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> cur<span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> path<span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> res<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token comment">// 中，之所以写在这，因为叶子结点也要加入到 path 中</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        path<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token comment">// 递归终止条件：当前节点为叶子节点</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>cur<span class="token punctuation">.</span>left <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> cur<span class="token punctuation">.</span>right <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>            <span class="token class-name">StringBuilder</span> sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> path<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="19"></td><td><pre>                sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"->"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将 path 里记录的路径转为 string 格式</span></pre></td></tr><tr><td data-num="20"></td><td><pre>            sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>            res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>sb<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 收集一个路径</span></pre></td></tr><tr><td data-num="22"></td><td><pre>            <span class="token keyword">return</span><span class="token punctuation">;</span> <span class="token comment">// 递归终止</span></pre></td></tr><tr><td data-num="23"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="24"></td><td><pre></pre></td></tr><tr><td data-num="25"></td><td><pre>        <span class="token comment">// 左</span></pre></td></tr><tr><td data-num="26"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>cur<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 空节点不遍历，否则在 “递归终止条件” 处会报空指针异常</span></pre></td></tr><tr><td data-num="27"></td><td><pre>            <span class="token function">traversal</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>left<span class="token punctuation">,</span> path<span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>            path<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 回溯</span></pre></td></tr><tr><td data-num="29"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="30"></td><td><pre></pre></td></tr><tr><td data-num="31"></td><td><pre>        <span class="token comment">// 右</span></pre></td></tr><tr><td data-num="32"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>cur<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="33"></td><td><pre>            <span class="token function">traversal</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>right<span class="token punctuation">,</span> path<span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="34"></td><td><pre>            path<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 回溯</span></pre></td></tr><tr><td data-num="35"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="36"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="37"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20221218205424274.png" alt="image-20221218205424274"></p><h3 id="本周小结-2"><a class="anchor" href="#本周小结-2">#</a> 本周小结</h3><h4 id="周一-2"><a class="anchor" href="#周一-2">#</a> 周一</h4><p>本周刚开始我们讲解了判断二叉树是否对称的写法， [101. 对称二叉树](#101. 对称二叉树)。</p><p>这道题目的本质是要比较两个树（这两个树是根节点的左右子树），<strong>遍历两棵树而且要比较内侧和外侧节点</strong>，所以准确的来说是一个树的遍历顺序是左右中，一个树的遍历顺序是右左中。</p><p>而本题的<strong>迭代法中我们使用了队列</strong>，需要注意的是这不是层序遍历，而且仅仅通过一个容器来成对的存放我们要比较的元素，认识到这一点之后就发现：<strong>用队列，用栈，甚至用数组，都是可以的</strong>。</p><p>那么做完本题之后，在看如下两个题目。</p><ul><li>100. 相同的树</li><li>572. 另一个树的子树</li></ul><h4 id="周二-2"><a class="anchor" href="#周二-2">#</a> 周二</h4><p>在 [104. 二叉树的最大深度](#104. 二叉树的最大深度) 中，我们讲解了如何求二叉树的最大深度。</p><p>本题可以使用前序，也可以使用后序遍历（左右中），<strong>使用前序求的就是深度，使用后序呢求的是高度</strong>。</p><p><strong>而根节点的高度就是二叉树的最大深度</strong>，所以本题中我们通过后序求的根节点高度来求的二叉树最大深度，所以 [104. 二叉树的最大深度](#104. 二叉树的最大深度) 中使用的是<strong>后序遍历</strong>，代码见<a href="#%3Cu%3E%E5%90%8E%E5%BA%8F%3C/u%3E%E9%81%8D%E5%8E%86%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%A0%B9%E8%8A%82%E7%82%B9%E7%9A%84%E9%AB%98%E5%BA%A6"><u>后序</u>遍历：计算根节点的高度</a>。</p><p>本题当然也可以使用前序，代码如下，<a href="#%3Cu%3E%E5%89%8D%E5%BA%8F%3C/u%3E%E9%81%8D%E5%8E%86%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6"><u>前序</u>遍历：计算最大深度</a></p><h4 id="周三-2"><a class="anchor" href="#周三-2">#</a> 周三</h4><p>在 [111. 二叉树的最小深度](#111. 二叉树的最小深度) 中，我们讲解如何求二叉树的最小深度， 这道题目要是稍不留心很容易犯错。</p><p><strong>注意这里最小深度是从根节点到最近叶子节点的最短路径上的节点数量。注意是叶子节点。</strong></p><p>什么是叶子节点，左右孩子都为空的节点才是叶子节点！</p><p><strong>求二叉树的最小深度和求二叉树的最大深度的差别主要在于<u>处理左右孩子不为空的逻辑</u>。</strong></p><p>注意到这一点之后 递归法和迭代法 都可以参照 [104. 二叉树的最大深度](#104. 二叉树的最大深度) 写出来。</p><h4 id="周四-2"><a class="anchor" href="#周四-2">#</a> 周四</h4><p>我们在 [222. 完全二叉树的节点个数](#222. 完全二叉树的节点个数) 中，讲解了如何<strong>求二叉树的节点数量</strong>。</p><p>这一天是十一长假的第一天，又是双节，所以简单一些，只要把之前两篇 [104. 二叉树的最大深度](#104. 二叉树的最大深度)， [111. 二叉树的最小深度](#111. 二叉树的最小深度) 都认真看了的话，这道题目可以分分钟刷掉了。</p><p>估计此时大家对这一类求二叉树节点数量以及求深度应该非常熟练了。</p><h4 id="周五-2"><a class="anchor" href="#周五-2">#</a> 周五</h4><p>在 [☆110. 平衡二叉树](#☆110. 平衡二叉树) 中讲解了<strong>如何判断二叉树是否是平衡二叉树</strong></p><p>今天讲解一道判断平衡二叉树的题目，其实 方法上我们之前讲解深度的时候都讲过了，但是这次我们通过这道题目彻底搞清楚二叉树高度与深度的问题，以及对应的遍历方式。</p><ul><li>二叉树节点的 **<mark> 深度</mark> **：↓指从<u>根节点</u>到<u>该节点</u>的最长简单路径边的条数。</li><li>二叉树节点的 **<mark> 高度</mark> **：↑指从<u>该节点</u>到<u>叶子节点</u>的最长简单路径边的条数。</li></ul><p><strong>但 leetcode 中强调的深度和高度很明显是按照节点来计算的</strong>。</p><p>关于根节点的深度究竟是 1 还是 0，不同的地方有不一样的标准，leetcode 的题目中都是以节点为一度，即根节点深度是 1。但维基百科上定义用边为一度，即根节点的深度是 0，我们暂时以 leetcode 为准（毕竟要在这上面刷题）。</p><p>当然此题用迭代法，其实效率很低，因为没有很好的模拟回溯的过程，所以迭代法有很多重复的计算。</p><p>虽然理论上所有的递归都可以用迭代来实现，但是有的场景难度可能比较大。</p><p><strong>例如：都知道回溯法其实就是递归，但是很少人用迭代的方式去实现回溯算法！</strong></p><p>讲了这么多二叉树题目的迭代法，有的同学会疑惑，迭代法中究竟什么时候用队列，什么时候用栈？</p><p><strong>如果是模拟前中后序遍历就用栈，如果是适合层序遍历就用队列，当然还是其他情况，那么就是 先用队列试试行不行，不行就用栈。</strong></p><h4 id="周六-2"><a class="anchor" href="#周六-2">#</a> 周六</h4><p>在 [☆257. 二叉树的所有路径](#☆257. 二叉树的所有路径) 中正式涉及到了回溯，很多同学过了这道题目，可能都不知道自己使用了回溯，其实<strong>回溯和递归都是相伴相生的</strong>。最后我依然给出了迭代法的版本。</p><p>我在题解中第一个版本的代码会把回溯的过程充分体现出来，如果大家直接看简洁的代码版本，很可能就会忽略的回溯的存在。</p><p>我在文中也强调了这一点。</p><p>有的同学还不理解 ，文中精简之后的递归代码，回溯究竟隐藏在哪里了。</p><p>文中我明确的说了：<strong>回溯就隐藏在 traversal (cur-&gt;left, path + &quot;-&gt;&quot;, result); 中的 path + &quot;-&gt;&quot;。 每次函数调用完，path 依然是没有加上 &quot;-&gt;&quot; 的，这就是回溯了。</strong></p><h4 id="小结-4"><a class="anchor" href="#小结-4">#</a> 小结</h4><p>二叉树的题目，我都是使用了<strong>递归三部曲</strong>一步一步的把整个过程分析出来，而不是上来就给出简洁的代码。</p><p>一些同学可能上来就能写出代码，大体上也知道是为啥，可以自圆其说，但往细节一扣，就不知道了。</p><p>所以刚接触二叉树的同学，建议按照文章分析的步骤一步一步来，不要上来就照着精简的代码写（那样写完了也很容易忘的，知其然不知其所以然）。</p><p><strong>简短的代码看不出遍历的顺序，也看不出分析的逻辑，还会把必要的回溯的逻辑隐藏了，所以尽量按照原理分析一步一步来，写出来之后，再去优化代码。</strong></p><p>大家加个油！！</p><h3 id="404-左叶子之和"><a class="anchor" href="#404-左叶子之和">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zdW0tb2YtbGVmdC1sZWF2ZXMv">404. 左叶子之和</span></h3><p><strong>首先要注意是判断左叶子，不是二叉树左侧节点，所以不要上来想着层序遍历。</strong></p><p>因为题目中其实没有说清楚左叶子究竟是什么节点，那么我来给出左叶子的明确定义：<strong>节点 A 的左孩子不为空，且左孩子的左右孩子都为空（说明是叶子节点），那么 A 节点的左孩子为左叶子节点</strong></p><p>大家思考一下如下图中二叉树，左叶子之和究竟是多少？</p><p><img data-src="https://img-blog.csdnimg.cn/20210204151949672.png" alt="404.左叶子之和"></p><p><strong>其实是 0，因为这棵树根本没有左叶子！</strong></p><p>但看这个图的左叶子之和是多少？</p><p><img data-src="https://code-thinking-1253855093.file.myqcloud.com/pics/20220902165805.png" alt="图二"></p><p>相信通过这两个图，大家可以最左叶子的定义有明确理解了。</p><p>那么<strong>判断当前节点是不是左叶子是无法判断的，必须要通过节点的父节点来判断其左孩子是不是左叶子。</strong></p><p>如果该节点的左节点不为空，该节点的左节点的左节点为空，该节点的左节点的右节点为空，则找到了一个左叶子，判断代码如下：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">if</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> cur<span class="token punctuation">.</span>left<span class="token punctuation">.</span>left <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> cur<span class="token punctuation">.</span>left<span class="token punctuation">.</span>right <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 左叶子的处理逻辑</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h4 id="递归-4"><a class="anchor" href="#递归-4">#</a> 递归</h4><p>递归的遍历顺序为<strong>后序遍历（左右中）</strong>，是因为要通过递归函数的返回值来累加求取左叶子数值之和。</p><p>递归三部曲：</p><ol><li><p>参数和返回值：判断一个树的左叶子节点之和，那么一定要传入树的根节点，递归函数的返回值为数值之和，所以为 int，</p><p>使用题目中给出的函数就可以了。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">sumOfLeftLeaves</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span></pre></td></tr></table></figure></li><li><p>确定终止条件：</p><ul><li>如果遍历到空节点，那么左叶子值一定是 0</li><li>如果当前遍历的节点是叶子节点，那其左叶子也必定是 0</li></ul><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">//null 节点</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>left <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> root<span class="token punctuation">.</span>right <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 叶子节点</span></pre></td></tr></table></figure></li><li><p>单层递归逻辑：当遇到左叶子节点的时候，记录数值，然后通过递归求取左子树左叶子之和，和 右子树左叶子之和，相加便是整个树的左叶子之和。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> leftSum <span class="token operator">=</span> <span class="token function">sumOfLeftLeaves</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 左子树的左叶子之和</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> root<span class="token punctuation">.</span>left<span class="token punctuation">.</span>left <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> root<span class="token punctuation">.</span>left<span class="token punctuation">.</span>right <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    leftSum <span class="token operator">+=</span> root<span class="token punctuation">.</span>left<span class="token punctuation">.</span>val<span class="token punctuation">;</span> <span class="token comment">// !!! 左子树是叶子节点，加入到左叶子之和中！！！</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">int</span> rightSum <span class="token operator">=</span> <span class="token function">sumOfLeftLeaves</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 右子树的左叶子之和</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">int</span> midSum <span class="token operator">=</span> leftSum <span class="token operator">+</span> rightSum<span class="token punctuation">;</span> <span class="token comment">// 中</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token keyword">return</span> midSum<span class="token punctuation">;</span></pre></td></tr></table></figure></li></ol><p>完整的 java 代码：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 递归（后序遍历）</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">sumOfLeftLeaves</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token comment">// 递归终止条件</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">//null 节点</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>left <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> root<span class="token punctuation">.</span>right <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 叶子节点</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token comment">// 递归过程</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token keyword">int</span> leftSum <span class="token operator">=</span> <span class="token function">sumOfLeftLeaves</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 左子树的左叶子之和</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> root<span class="token punctuation">.</span>left<span class="token punctuation">.</span>left <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> root<span class="token punctuation">.</span>left<span class="token punctuation">.</span>right <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="10"></td><td><pre>            leftSum <span class="token operator">+=</span> root<span class="token punctuation">.</span>left<span class="token punctuation">.</span>val<span class="token punctuation">;</span> <span class="token comment">// !!! 左子树是叶子节点，加入到左叶子之和中！！！</span></pre></td></tr><tr><td data-num="11"></td><td><pre></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token keyword">int</span> rightSum <span class="token operator">=</span> <span class="token function">sumOfLeftLeaves</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 右子树的左叶子之和</span></pre></td></tr><tr><td data-num="13"></td><td><pre></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token keyword">int</span> midSum <span class="token operator">=</span> leftSum <span class="token operator">+</span> rightSum<span class="token punctuation">;</span> <span class="token comment">// 中</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token keyword">return</span> midSum<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20221219003828202.png" alt="image-20221219003828202"></p><h4 id="迭代"><a class="anchor" href="#迭代">#</a> 迭代</h4><p>本题迭代法使用<strong>前中后序都是可以的</strong>，只要把左叶子节点统计出来，就可以了，那么参考文章 <a href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%86">二叉树的迭代遍历</a>和<a href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%BB%9F%E4%B8%80%E8%BF%AD%E4%BB%A3%E6%B3%95">二叉树的统一迭代法</a>中的写法，可以写出一个前序遍历的迭代法。</p><p>判断条件都是一样的，代码如下：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 迭代（前序遍历），借助栈</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">sumOfLeftLeaves</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TreeNode</span><span class="token punctuation">></span></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>            <span class="token class-name">TreeNode</span> cur <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>cur<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> cur<span class="token punctuation">.</span>left<span class="token punctuation">.</span>left <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> cur<span class="token punctuation">.</span>left<span class="token punctuation">.</span>right <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="13"></td><td><pre>                res <span class="token operator">+=</span> cur<span class="token punctuation">.</span>left<span class="token punctuation">.</span>val<span class="token punctuation">;</span> <span class="token comment">// 中间节点 cur 的左子树是左叶子，加入结果</span></pre></td></tr><tr><td data-num="14"></td><td><pre></pre></td></tr><tr><td data-num="15"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>cur<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 先右</span></pre></td></tr><tr><td data-num="16"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>cur<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 后左</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>        <span class="token keyword">return</span> res<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20221219005750410.png" alt="image-20221219005750410"></p><h4 id="总结-15"><a class="anchor" href="#总结-15">#</a> 总结</h4><p>这道题目要求左叶子之和，其实是比较绕的，因为<strong>不能判断本节点是不是左叶子节点</strong>。</p><p>此时就<strong>要通过节点的父节点来判断其左孩子是不是左叶子</strong>了。</p><p><strong>平时我们解二叉树的题目时，已经习惯了通过节点的左右孩子判断本节点的属性，而本题我们要通过节点的父节点判断本节点的属性。</strong></p><p>希望通过这道题目，可以扩展大家对二叉树的解题思路。</p><h3 id="513-找树左下角的值"><a class="anchor" href="#513-找树左下角的值">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9maW5kLWJvdHRvbS1sZWZ0LXRyZWUtdmFsdWUv">513. 找树左下角的值</span></h3><p>本地要找出树的最后一行找到最左边的值。此时大家应该想起<strong>用<u>层序遍历</u>是非常简单的了，反而用<u>递归</u>的话会比较难一点</strong>。</p><p>我们依然还是先介绍递归法。</p><h4 id="递归前序"><a class="anchor" href="#递归前序">#</a> 递归（前序）</h4><p>咋眼一看，这道题目用递归的话就就一直向左遍历，最后一个就是答案呗？</p><p>没有这么简单，一直向左遍历到最后一个，它未必是最后一行啊。</p><p>我们来分析一下题目：在树的<strong>最后一行</strong>找到<strong>最左边的值</strong>。</p><ul><li><p>如何判断是最后一行呢？</p><blockquote><p>要找<strong>深度最大的叶子节点</strong></p></blockquote></li><li><p>如何找最左边的呢？</p><blockquote><p>可以使用前序遍历（当然中序，后序都可以，因为本题没有 中间节点的处理逻辑，只要左优先就行），保证优先左边搜索，然后记录深度最大的叶子节点，此时就是树的最后一行最左边的值。</p></blockquote></li></ul><p>递归三部曲：</p><ol><li><p>参数和返回值：</p><p>参数必须有<strong>要遍历的树的根节点</strong>，还有就是<strong>一个 int 型的变量用来记录最长深度</strong>。 这里就不需要返回值了，所以递归函数的<strong>返回类型为 void</strong>。</p><p>本题还需要类里的<strong>两个全局变量，maxLen 用来记录最大深度，result 记录最大深度最左节点的数值</strong>。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">int</span> maxDepth <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token constant">MIN_VALUE</span><span class="token punctuation">;</span> <span class="token comment">// 记录最大深度</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 记录结果：最大深度，最左边的值</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">traversal</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">,</span> <span class="token keyword">int</span> depth<span class="token punctuation">)</span></pre></td></tr></table></figure></li><li><p>递归终止条件：</p><p>当遇到叶子节点的时候，就需要统计一下最大的深度了，所以需要<strong>遇到叶子节点来更新最大深度</strong>。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>left <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> root<span class="token punctuation">.</span>right <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 叶子节点</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>depth <span class="token operator">></span> maxDepth<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        maxDepth <span class="token operator">=</span> depth<span class="token punctuation">;</span> <span class="token comment">// 更新最大深度</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        res <span class="token operator">=</span> root<span class="token punctuation">.</span>val<span class="token punctuation">;</span> <span class="token comment">// 更新结果</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">return</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure></li><li><p>递归单层逻辑：</p><p>在找最大深度的时候，递归的过程中依然要使用<strong>回溯</strong>，代码如下：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 中</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 左</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    depth<span class="token operator">++</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token function">traversal</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> depth<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    depth<span class="token operator">--</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 右</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    depth<span class="token operator">++</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token function">traversal</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> depth<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    depth<span class="token operator">--</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token keyword">return</span><span class="token punctuation">;</span></pre></td></tr></table></figure></li></ol><p>完整的 java 代码如下：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 递归（前序遍历）</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">int</span> maxDepth <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token constant">MIN_VALUE</span><span class="token punctuation">;</span> <span class="token comment">// 记录最大深度</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 记录结果：最大深度，最左边的值</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">traversal</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">,</span> <span class="token keyword">int</span> depth<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token comment">// 递归终止条件</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>left <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> root<span class="token punctuation">.</span>right <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 叶子节点</span></pre></td></tr><tr><td data-num="9"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>depth <span class="token operator">></span> maxDepth<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>                maxDepth <span class="token operator">=</span> depth<span class="token punctuation">;</span> <span class="token comment">// 更新最大深度</span></pre></td></tr><tr><td data-num="11"></td><td><pre>                res <span class="token operator">=</span> root<span class="token punctuation">.</span>val<span class="token punctuation">;</span> <span class="token comment">// 更新结果</span></pre></td></tr><tr><td data-num="12"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>            <span class="token keyword">return</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token comment">// 递归过程</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token comment">// 中</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 左</span></pre></td></tr><tr><td data-num="18"></td><td><pre>            depth<span class="token operator">++</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>            <span class="token function">traversal</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> depth<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>            depth<span class="token operator">--</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 右</span></pre></td></tr><tr><td data-num="23"></td><td><pre>            depth<span class="token operator">++</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>            <span class="token function">traversal</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> depth<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>            depth<span class="token operator">--</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>        <span class="token keyword">return</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="29"></td><td><pre></pre></td></tr><tr><td data-num="30"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findBottomLeftValue</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="31"></td><td><pre>        <span class="token function">traversal</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>        <span class="token keyword">return</span> res<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="33"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="34"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20221219123341600.png" alt="image-20221219123341600"></p><h4 id="迭代层序遍历-5"><a class="anchor" href="#迭代层序遍历-5">#</a> √迭代（层序遍历）</h4><p>本题使用层序遍历再合适不过了，比递归要好理解的多！</p><p>只需要记录最后一行第一个节点的数值就可以了。</p><p>如果对层序遍历不了解，看这篇 [102. 二叉树的层序遍历](#102. 二叉树的层序遍历)，这篇里也给出了层序遍历的模板，稍作修改就一过刷了这道题了。</p><p>代码如下：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 迭代（层序遍历），借助队列</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findBottomLeftValue</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span><span class="token punctuation">></span></span> resList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 逐层记录所有节点值</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TreeNode</span><span class="token punctuation">></span></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>            <span class="token keyword">int</span> size <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>            <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> levelList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 记录每一层的节点值</span></pre></td></tr><tr><td data-num="13"></td><td><pre>            <span class="token keyword">while</span> <span class="token punctuation">(</span>size <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>                <span class="token class-name">TreeNode</span> cur <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>                levelList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>                <span class="token keyword">if</span> <span class="token punctuation">(</span>cur<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>                <span class="token keyword">if</span> <span class="token punctuation">(</span>cur<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>                size<span class="token operator">--</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>            resList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>levelList<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将每一层的节点值记录到 resList 中</span></pre></td></tr><tr><td data-num="21"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>        <span class="token keyword">return</span> resList<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>resList<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 返回最后一层的第一个节点值</span></pre></td></tr><tr><td data-num="23"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="24"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20221219095959078.png" alt="image-20221219095959078"></p><h4 id="总结-16"><a class="anchor" href="#总结-16">#</a> 总结</h4><p>本题涉及如下几点：</p><ul><li><strong>递归求深度</strong>的写法，我们在 [110. 平衡二叉树](#110. 平衡二叉树) 中详细的分析了深度应该怎么求，高度应该怎么求。</li><li>递归中其实隐藏了<strong>回溯</strong>，在 [257. 二叉树的所有路径](#257. 二叉树的所有路径) 中讲解了究竟哪里使用了回溯，哪里隐藏了回溯。</li><li><strong>层次遍历</strong>，在 [102. 二叉树的层序遍历](#102. 二叉树的层序遍历) 深度讲解了二叉树层次遍历。 所以本题涉及到的点，我们之前都讲解过，这些知识点需要同学们灵活运用，这样就举一反三了。</li></ul><h3 id="112-路径总和"><a class="anchor" href="#112-路径总和">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9wYXRoLXN1bS8=">☆112. 路径总和</span></h3><p>相信很多同学都会疑惑，<strong>递归函数什么时候要有返回值，什么时候没有返回值</strong>，特别是有的时候递归函数返回类型为 bool 类型。</p><p>那么接下来我通过详细讲解如下两道题，来回答这个问题：</p><ul><li>112. 路径总和</li><li>113. 路径总和 ii</li></ul><p>这道题我们要遍历从根节点到叶子节点的的路径看看总和是不是目标和。</p><h4 id="递归-5"><a class="anchor" href="#递归-5">#</a> 递归</h4><blockquote><p>中间节点不需要处理，注意回溯</p></blockquote><p>可以使用深度优先遍历的方式（本题<strong>前中后序都可以，无所谓，因为中节点也没有处理逻辑</strong>）来遍历二叉树</p><ol><li><p>参数、返回类型：</p><p>参数：需要二叉树的根节点，还需要一个计数器，这个计数器用来计算二叉树的一条边之和是否正好是目标和，计数器为 int 型。</p><p>再来看返回值，**<mark> 递归函数什么时候需要返回值？什么时候不需要返回值？</mark>** 这里总结如下三点：</p><ul><li><p>如果需要<strong>搜索整棵二叉树</strong>且<strong>不用处理递归返回值</strong>，递归函数就<u>不要返回值</u>。（这种情况就是本文下半部分介绍的 113. 路径总和 ii）</p></li><li><p>如果需要<strong>搜索整棵二叉树</strong>且<strong>需要处理递归返回值</strong>，递归函数就<u>需要返回值</u>。 （这种情况我们在<span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVyY2FybC5jb20vMDIzNi4lRTQlQkElOEMlRTUlOEYlODklRTYlQTAlOTElRTclOUElODQlRTYlOUMlODAlRTglQkYlOTElRTUlODUlQUMlRTUlODUlQjElRTclQTUlOTYlRTUlODUlODguaHRtbA=="> 236. 二叉树的最近公共祖先 </span>中介绍）</p></li><li><p>如果要<strong>搜索其中一条符合条件的路径</strong>，那么递归<u>一定需要返回值</u>，因为遇到符合条件的路径了就要及时返回。（本题的情况）</p></li></ul><p>而本题我们要找一条符合条件的路径，所以递归函数需要返回值，及时返回，那么返回类型是什么呢？</p><p>如图所示：</p><p><img data-src="https://img-blog.csdnimg.cn/2021020316051216.png" alt="112.路径总和"></p><p>图中可以看出，遍历的路线，并不要遍历整棵树，所以递归函数需要返回值，可以用 bool 类型表示。</p><p>所以代码如下：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">traversal</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">,</span> <span class="token keyword">int</span> targetSum<span class="token punctuation">)</span></pre></td></tr></table></figure></li><li><p>终止条件：</p><p>首先计数器如何统计这一条路径的和呢？</p><p>不要去累加然后判断是否等于目标和，那么代码比较麻烦，可以用递减，<strong>让计数器 count 初始为目标和，然后每次减去遍历路径节点上的数值</strong>。</p><ul><li><p><strong>如果最后 count == 0，同时到了叶子节点的话，说明找到了目标和</strong></p></li><li><p><strong>如果遍历到了叶子节点，count 不为 0，就是没找到</strong></p></li></ul><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>left <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> root<span class="token punctuation">.</span>right <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> targetSum <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>left <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> root<span class="token punctuation">.</span>right <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> targetSum <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr></table></figure></li><li><p>单层递归逻辑：</p><p><strong><mark>因为终止条件是判断叶子节点，所以递归的过程中就不要让空节点进入递归了</mark></strong>，否则会引发空指针异常。</p><p>递归函数是有返回值的，如果递归函数返回 true，说明找到了合适的路径，应该立刻返回。</p><p>注意<strong>回溯</strong>。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 左子树</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    targetSum <span class="token operator">-=</span> root<span class="token punctuation">.</span>left<span class="token punctuation">.</span>val<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">traversal</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> targetSum<span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    targetSum <span class="token operator">+=</span> root<span class="token punctuation">.</span>left<span class="token punctuation">.</span>val<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 右子树</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    targetSum <span class="token operator">-=</span> root<span class="token punctuation">.</span>right<span class="token punctuation">.</span>val<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">traversal</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> targetSum<span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    targetSum <span class="token operator">+=</span> root<span class="token punctuation">.</span>right<span class="token punctuation">.</span>val<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr></table></figure></li></ol><p>整体的 java 代码如下：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 递归（前序遍历）</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">traversal</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">,</span> <span class="token keyword">int</span> targetSum<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token comment">// 递归终止条件</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>left <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> root<span class="token punctuation">.</span>right <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> targetSum <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>left <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> root<span class="token punctuation">.</span>right <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> targetSum <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token comment">// 递归过程</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 左子树</span></pre></td></tr><tr><td data-num="11"></td><td><pre>            targetSum <span class="token operator">-=</span> root<span class="token punctuation">.</span>left<span class="token punctuation">.</span>val<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">traversal</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> targetSum<span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="13"></td><td><pre>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>            targetSum <span class="token operator">+=</span> root<span class="token punctuation">.</span>left<span class="token punctuation">.</span>val<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 右子树</span></pre></td></tr><tr><td data-num="17"></td><td><pre>            targetSum <span class="token operator">-=</span> root<span class="token punctuation">.</span>right<span class="token punctuation">.</span>val<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">traversal</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> targetSum<span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="19"></td><td><pre>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>            targetSum <span class="token operator">+=</span> root<span class="token punctuation">.</span>right<span class="token punctuation">.</span>val<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="24"></td><td><pre></pre></td></tr><tr><td data-num="25"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">hasPathSum</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">,</span> <span class="token keyword">int</span> targetSum<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="27"></td><td><pre>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>        targetSum <span class="token operator">-=</span> root<span class="token punctuation">.</span>val<span class="token punctuation">;</span> <span class="token comment">// 根节点</span></pre></td></tr><tr><td data-num="29"></td><td><pre>        <span class="token keyword">return</span> <span class="token function">traversal</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> targetSum<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="31"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20221219133333737.png" alt="image-20221219133333737"></p><h4 id="迭代-2"><a class="anchor" href="#迭代-2">#</a> 迭代</h4><p>如果使用<strong>栈</strong>模拟递归的话，那么如果做<strong>回溯</strong>呢？</p><p><strong>此时栈里一个元素不仅要记录该节点指针，还要记录从头结点到该节点的路径数值总和。</strong></p><p>c++ 就我们用 pair 结构来存放这个栈里的元素。</p><p>定义为： <code>pair&lt;TreeNode*, int&gt;</code> pair &lt;节点指针，路径数值&gt;</p><p>这个为栈里的一个元素。</p><p>如下代码是使用栈模拟的<strong>前序遍历</strong>，如下：（详细注释）</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 迭代，借助栈</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">hasPathSum</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">,</span> <span class="token keyword">int</span> targetSum<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TreeNode</span><span class="token punctuation">></span></span> nodeStack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 节点栈</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> sumStack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 路径和栈</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        nodeStack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        sumStack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>nodeStack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>            <span class="token keyword">int</span> size <span class="token operator">=</span> nodeStack<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 一定要先记录 size，因为后面会改变</span></pre></td></tr><tr><td data-num="13"></td><td><pre>            <span class="token keyword">while</span> <span class="token punctuation">(</span>size <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>                <span class="token class-name">TreeNode</span> node <span class="token operator">=</span> nodeStack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>                <span class="token keyword">int</span> sum <span class="token operator">=</span> sumStack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>                <span class="token comment">// 如果是叶子节点，且 sum 等于 targetSum，返回 true</span></pre></td></tr><tr><td data-num="17"></td><td><pre>                <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>left <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> node<span class="token punctuation">.</span>right <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> sum <span class="token operator">==</span> targetSum<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="18"></td><td><pre>                    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre></pre></td></tr><tr><td data-num="20"></td><td><pre>                <span class="token comment">// 右节点入栈</span></pre></td></tr><tr><td data-num="21"></td><td><pre>                <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>                    nodeStack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>                    sumStack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>sum <span class="token operator">+</span> node<span class="token punctuation">.</span>right<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>                <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>                <span class="token comment">// 左节点入栈</span></pre></td></tr><tr><td data-num="26"></td><td><pre>                <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>                    nodeStack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>                    sumStack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>sum <span class="token operator">+</span> node<span class="token punctuation">.</span>left<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>                <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>                size<span class="token operator">--</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="31"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="33"></td><td><pre>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="34"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="35"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20221219134359295.png" alt="image-20221219134359295"></p><h4 id="113-路径总和-ii"><a class="anchor" href="#113-路径总和-ii">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9wYXRoLXN1bS1paS8=">113. 路径总和 II</span></h4><p>本题要遍历整个树，找到所有路径，<strong>所以递归函数不要返回值！</strong></p><p><img data-src="https://img-blog.csdnimg.cn/20210203160922745.png" alt="113.路径总和ii"></p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 递归，注意回溯</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">traversal</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">,</span> <span class="token keyword">int</span> targetSum<span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> path<span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span><span class="token punctuation">></span></span> res<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        path<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token comment">// 递归终止条件</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>left <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> root<span class="token punctuation">.</span>right <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 叶子节点</span></pre></td></tr><tr><td data-num="8"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>targetSum <span class="token operator">-</span> root<span class="token punctuation">.</span>val <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 找到一条路径</span></pre></td></tr><tr><td data-num="9"></td><td><pre>                res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>            <span class="token keyword">return</span><span class="token punctuation">;</span> <span class="token comment">// 如果该叶子节点不满足条件，直接返回</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token comment">// 递归</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>            <span class="token function">traversal</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> targetSum <span class="token operator">-</span> root<span class="token punctuation">.</span>val<span class="token punctuation">,</span> path<span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>            path<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 回溯</span></pre></td></tr><tr><td data-num="18"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>            <span class="token function">traversal</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> targetSum <span class="token operator">-</span> root<span class="token punctuation">.</span>val<span class="token punctuation">,</span> path<span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>            path<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 回溯</span></pre></td></tr><tr><td data-num="22"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="24"></td><td><pre></pre></td></tr><tr><td data-num="25"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span><span class="token punctuation">></span></span> <span class="token function">pathSum</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">,</span> <span class="token keyword">int</span> targetSum<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span><span class="token punctuation">></span></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> path <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 存放单条路径</span></pre></td></tr><tr><td data-num="28"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="29"></td><td><pre>            <span class="token keyword">return</span> res<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="30"></td><td><pre></pre></td></tr><tr><td data-num="31"></td><td><pre>        <span class="token function">traversal</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> targetSum<span class="token punctuation">,</span> path<span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="32"></td><td><pre></pre></td></tr><tr><td data-num="33"></td><td><pre>        <span class="token keyword">return</span> res<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="34"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="35"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20221219140515939.png" alt="image-20221219140515939"></p><h4 id="总结-17"><a class="anchor" href="#总结-17">#</a> 总结</h4><p>本篇通过 leetcode 上 112. 路径总和 和 113. 路径总和 ii 详细的讲解了 <strong>递归函数什么时候需要返回值，什么不需要返回值</strong>。</p><p>这两道题目是掌握这一知识点非常好的题目，大家看完本篇文章再去做题，就会感受到<strong>搜索整棵树和搜索某一路径的差别</strong>。</p><p>对于 112. 路径总和，我依然给出了递归法和迭代法，这种题目其实用迭代法会复杂一些，能<strong>掌握<u>递归</u>方式就够了</strong>！</p><h3 id="106-从中序与后序遍历序列构造二叉树"><a class="anchor" href="#106-从中序与后序遍历序列构造二叉树">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb25zdHJ1Y3QtYmluYXJ5LXRyZWUtZnJvbS1pbm9yZGVyLWFuZC1wb3N0b3JkZXItdHJhdmVyc2FsLw==">106. 从中序与后序遍历序列构造二叉树</span></h3><p>看完本文，可以一起解决如下两道题目</p><ul><li>106. 从中序与后序遍历序列构造二叉树</li><li>105. 从前序与中序遍历序列构造二叉树</li></ul><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20221219171327545.png" alt="image-20221219171327545"></p><p>首先回忆一下如何根据两个顺序构造一个唯一的二叉树，相信理论知识大家应该都清楚，就是以 后序数组的最后一个元素为切割点，先切中序数组，根据中序数组，反过来在切后序数组。一层一层切下去，每次后序数组最后一个元素就是节点元素。</p><p>如果让我们肉眼看两个序列，画一棵二叉树的话，应该分分钟都可以画出来。</p><p>流程如图：</p><p><img data-src="https://img-blog.csdnimg.cn/20210203154249860.png" alt="106.从中序与后序遍历序列构造二叉树"></p><p>那么代码应该怎么写呢？</p><p>说到一层一层切割，就应该想到了<strong>递归</strong>。</p><p>来看一下一共分几步：</p><ul><li>第一步：如果数组大小为零的话，说明是空节点了。</li><li>第二步：如果不为空，那么取后序数组最后一个元素作为节点元素。</li><li>第三步：找到后序数组最后一个元素在中序数组的位置，作为切割点</li><li>第四步：切割中序数组，切成中序左数组和中序右数组 （顺序别搞反了，<strong>一定是先切中序数组</strong>）</li><li>第五步：切割后序数组，切成后序左数组和后序右数组</li><li>第六步：递归处理左区间和右区间</li></ul><p>不难写出如下代码：（先把框架写出来）</p><p><strong>难点大家应该发现了，就是如何切割，以及边界值找不好很容易乱套。</strong></p><p>此时应该注意确定切割的标准，是左闭右开，还有左开右闭，还是左闭右闭，这个就是不变量，要在递归中保持这个不变量。</p><p><strong>在切割的过程中会产生四个区间，把握不好不变量的话，一会左闭右开，一会左闭右闭，必然乱套！</strong></p><p>我在 [35. 搜索插入位置](#35. 搜索插入位置) 和 [59. 螺旋矩阵 II](#59. 螺旋矩阵 II) 中都强调过<strong>循环不变量</strong>的重要性，在二分查找以及螺旋矩阵的求解中，坚持循环不变量非常重要，本题也是。</p><p><strong>首先要切割中序数组</strong>，为什么先切割中序数组呢？</p><p>切割点在后序数组的最后一个元素，就是用这个元素来切割中序数组的，所以必要先切割中序数组。</p><p>中序数组相对比较好切，找到切割点（后序数组的最后一个元素）在中序数组的位置，然后切割，如下代码中我坚持左闭右开的原则：</p><p>接下来就要切割后序数组了。</p><p>首先后序数组的最后一个元素指定不能要了，这是切割点 也是 当前二叉树中间节点的元素，已经用了。</p><p>后序数组的切割点怎么找？</p><p>后序数组没有明确的切割元素来进行左右切割，不像中序数组有明确的切割点，切割点左右分开就可以了。</p><p><strong>此时有一个很重的点，就是中序数组大小一定是和后序数组的大小相同的（这是必然）。</strong></p><p>中序数组我们都切成了左中序数组和右中序数组了，那么后序数组就可以按照左中序数组的大小来切割，切成左后序数组和右后序数组。</p><p>代码如下：</p><p>此时，<strong>中序数组切成了<u>左中序</u>数组和<u>右中序</u>数组，后序数组切割成<u>左后序</u>数组和<u>右后序</u>数组</strong>。</p><p>接下来可以<strong>递归</strong>了，代码如下：</p><h4 id="分割方式创建新数组"><a class="anchor" href="#分割方式创建新数组">#</a> 分割方式：创建新数组</h4><p>整体代码如下：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">TreeNode</span> <span class="token function">buildTree</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> inorder<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> postorder<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>inorder<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> postorder<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token keyword">return</span> <span class="token function">traversal</span><span class="token punctuation">(</span>inorder<span class="token punctuation">,</span> postorder<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">private</span> <span class="token class-name">TreeNode</span> <span class="token function">traversal</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> inorder<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> postorder<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token comment">// 递归终止条件</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>inorder<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> postorder<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token comment">// 取后序数组的最后一个元素作为根节点</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token class-name">TreeNode</span> root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span>postorder<span class="token punctuation">[</span>postorder<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>inorder<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> root<span class="token punctuation">;</span> <span class="token comment">// 只有一个元素，直接返回</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token comment">// 在中序数组中找到根节点的位置</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token keyword">int</span> rootIndex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> rootIndex <span class="token operator">&lt;</span> inorder<span class="token punctuation">.</span>length<span class="token punctuation">;</span> rootIndex<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>inorder<span class="token punctuation">[</span>rootIndex<span class="token punctuation">]</span> <span class="token operator">==</span> root<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>        <span class="token comment">// 切割中序数组，坚持左闭右开区间：[0, rootIndex) 和 [rootIndex + 1, inorder.length)</span></pre></td></tr><tr><td data-num="20"></td><td><pre>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> leftInorder <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">copyOfRange</span><span class="token punctuation">(</span>inorder<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> rootIndex<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> rightInorder <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">copyOfRange</span><span class="token punctuation">(</span>inorder<span class="token punctuation">,</span> rootIndex <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> inorder<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>        <span class="token comment">// 切割后序数组，坚持左闭右开区间：[0, leftInorder.length) 和 [leftInorder.length, postorder.length - 1)</span></pre></td></tr><tr><td data-num="23"></td><td><pre>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> leftPostorder <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">copyOfRange</span><span class="token punctuation">(</span>postorder<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> leftInorder<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> rightPostorder <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">copyOfRange</span><span class="token punctuation">(</span>postorder<span class="token punctuation">,</span> leftInorder<span class="token punctuation">.</span>length<span class="token punctuation">,</span> postorder<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 注意这里不闭合的右区间是 postorder.length - 1，因为要舍弃最后一个根节点</span></pre></td></tr><tr><td data-num="25"></td><td><pre>        <span class="token comment">// 递归构造 root 的左右子树</span></pre></td></tr><tr><td data-num="26"></td><td><pre>        root<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">traversal</span><span class="token punctuation">(</span>leftInorder<span class="token punctuation">,</span> leftPostorder<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>        root<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">traversal</span><span class="token punctuation">(</span>rightInorder<span class="token punctuation">,</span> rightPostorder<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>        <span class="token keyword">return</span> root<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="30"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20221219180726051.png" alt="image-20221219180726051"></p><p><strong>性能并不好，因为每层递归定定义了新的数组，既耗时又耗空间，但上面的代码是最好理解的，为了方便读者理解，所以用如上的代码来讲解。</strong></p><h4 id="分割方式下标索引"><a class="anchor" href="#分割方式下标索引">#</a> 分割方式：下标索引</h4><p>下面给出<strong>用下标索引</strong>写出的代码版本：（思路是一样的，只不过不用重复定义数组了，每次用下标索引来分割）</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">></span></span> map<span class="token punctuation">;</span> <span class="token comment">// 用于存储中序遍历的值和索引，方便查找</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token comment">// 循环不变量：左闭右开区间</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">private</span> <span class="token class-name">TreeNode</span> <span class="token function">findNode</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> inorder<span class="token punctuation">,</span> <span class="token keyword">int</span> inBegin<span class="token punctuation">,</span> <span class="token keyword">int</span> inEnd<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> postorder<span class="token punctuation">,</span> <span class="token keyword">int</span> postBegin<span class="token punctuation">,</span> <span class="token keyword">int</span> postEnd<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token comment">// 递归终止条件：区间无效</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>inBegin <span class="token operator">>=</span> inEnd <span class="token operator">||</span> postBegin <span class="token operator">>=</span> postEnd<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token comment">// 取后序数组最后一个元素作为根节点</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token keyword">int</span> rootVal <span class="token operator">=</span> postorder<span class="token punctuation">[</span>postEnd <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token comment">// 根据根节点的值找到中序数组中的索引</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token keyword">int</span> rootIndex <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>rootVal<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token comment">// 构造根节点</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token class-name">TreeNode</span> root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span>rootVal<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre></pre></td></tr><tr><td data-num="18"></td><td><pre>        <span class="token comment">// 切割中序数组，找到左右子树的区间</span></pre></td></tr><tr><td data-num="19"></td><td><pre>        <span class="token keyword">int</span> lenOfLeft <span class="token operator">=</span> rootIndex <span class="token operator">-</span> inBegin<span class="token punctuation">;</span> <span class="token comment">// 左中序子树的长度，用于确定左后序子树的区间</span></pre></td></tr><tr><td data-num="20"></td><td><pre></pre></td></tr><tr><td data-num="21"></td><td><pre>        <span class="token comment">// 递归构造左右子树</span></pre></td></tr><tr><td data-num="22"></td><td><pre>        root<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">findNode</span><span class="token punctuation">(</span>inorder<span class="token punctuation">,</span> inBegin<span class="token punctuation">,</span> rootIndex<span class="token punctuation">,</span> postorder<span class="token punctuation">,</span> postBegin<span class="token punctuation">,</span> postBegin <span class="token operator">+</span> lenOfLeft<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>        root<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">findNode</span><span class="token punctuation">(</span>inorder<span class="token punctuation">,</span> rootIndex <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> inEnd<span class="token punctuation">,</span> postorder<span class="token punctuation">,</span> postBegin <span class="token operator">+</span> lenOfLeft<span class="token punctuation">,</span> postEnd <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre></pre></td></tr><tr><td data-num="25"></td><td><pre>        <span class="token keyword">return</span> root<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="27"></td><td><pre></pre></td></tr><tr><td data-num="28"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">TreeNode</span> <span class="token function">buildTree</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> inorder<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> postorder<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>        map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> inorder<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="31"></td><td><pre>            map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>inorder<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="33"></td><td><pre></pre></td></tr><tr><td data-num="34"></td><td><pre>        <span class="token keyword">return</span> <span class="token function">findNode</span><span class="token punctuation">(</span>inorder<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> inorder<span class="token punctuation">.</span>length<span class="token punctuation">,</span> postorder<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> postorder<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="35"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="36"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20221219175126090.png" alt="image-20221219175126090"></p><h3 id="105-从前序与中序遍历序列构造二叉树"><a class="anchor" href="#105-从前序与中序遍历序列构造二叉树">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb25zdHJ1Y3QtYmluYXJ5LXRyZWUtZnJvbS1wcmVvcmRlci1hbmQtaW5vcmRlci10cmF2ZXJzYWwv">105. 从前序与中序遍历序列构造二叉树</span></h3><h4 id="分割方式创建新数组-2"><a class="anchor" href="#分割方式创建新数组-2">#</a> 分割方式：创建新数组</h4><p>对上面的代码稍加修改即可：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">private</span> <span class="token class-name">TreeNode</span> <span class="token function">traversal</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> preorder<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> inorder<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token comment">// 递归终止条件</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>preorder<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> inorder<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token comment">// 取前序数组的第一个元素作为根节点</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token class-name">TreeNode</span> root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span>preorder<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>preorder<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> root<span class="token punctuation">;</span> <span class="token comment">// 只有一个元素，直接返回</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token comment">// 在中序数组中找到根节点的位置</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token keyword">int</span> rootIndex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> rootIndex <span class="token operator">&lt;</span> inorder<span class="token punctuation">.</span>length<span class="token punctuation">;</span> rootIndex<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>inorder<span class="token punctuation">[</span>rootIndex<span class="token punctuation">]</span> <span class="token operator">==</span> root<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token comment">// 切割中序数组，坚持左闭右开区间：[0, rootIndex) 和 [rootIndex + 1, inorder.length)</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> leftInorder <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">copyOfRange</span><span class="token punctuation">(</span>inorder<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> rootIndex<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> rightInorder <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">copyOfRange</span><span class="token punctuation">(</span>inorder<span class="token punctuation">,</span> rootIndex <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> inorder<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token comment">// 切割前序数组，坚持左闭右开区间：[1, leftInorder.length + 1) 和 [leftInorder.length + 1, preorder.length)</span></pre></td></tr><tr><td data-num="18"></td><td><pre>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> leftPreorder <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">copyOfRange</span><span class="token punctuation">(</span>preorder<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> leftInorder<span class="token punctuation">.</span>length <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> rightPreorder <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">copyOfRange</span><span class="token punctuation">(</span>preorder<span class="token punctuation">,</span> leftInorder<span class="token punctuation">.</span>length <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> preorder<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>        <span class="token comment">// 递归构造左右子树</span></pre></td></tr><tr><td data-num="21"></td><td><pre>        root<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">traversal</span><span class="token punctuation">(</span>leftPreorder<span class="token punctuation">,</span> leftInorder<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>        root<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">traversal</span><span class="token punctuation">(</span>rightPreorder<span class="token punctuation">,</span> rightInorder<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>        <span class="token keyword">return</span> root<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="25"></td><td><pre></pre></td></tr><tr><td data-num="26"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">TreeNode</span> <span class="token function">buildTree</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> preorder<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> inorder<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>preorder<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> inorder<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>        <span class="token keyword">return</span> <span class="token function">traversal</span><span class="token punctuation">(</span>preorder<span class="token punctuation">,</span> inorder<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="30"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20221219181645319.png" alt="image-20221219181645319"></p><h4 id="分割方式下标索引-2"><a class="anchor" href="#分割方式下标索引-2">#</a> 分割方式：下标索引</h4><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 递归，构造二叉树一般选择前序遍历，分割方式：通过下标索引</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">private</span> <span class="token class-name">TreeNode</span> <span class="token function">buildTree_</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> preorder<span class="token punctuation">,</span> <span class="token keyword">int</span> preStart<span class="token punctuation">,</span> <span class="token keyword">int</span> preEnd<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> inorder<span class="token punctuation">,</span> <span class="token keyword">int</span> inStart<span class="token punctuation">,</span> <span class="token keyword">int</span> inEnd<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token comment">// 递归终止条件</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>preStart <span class="token operator">></span> preEnd <span class="token operator">||</span> inStart <span class="token operator">></span> inEnd<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre>            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token comment">// 取前序遍历的第一个节点作为根节点</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token keyword">int</span> rootVal <span class="token operator">=</span> preorder<span class="token punctuation">[</span>preStart<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token class-name">TreeNode</span> root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span>rootVal<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token comment">// 在中序数组中找到根节点的位置</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token keyword">int</span> rootIndex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> inStart<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> inEnd<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>inorder<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> rootVal<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>                rootIndex <span class="token operator">=</span> i<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>                <span class="token keyword">break</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="21"></td><td><pre></pre></td></tr><tr><td data-num="22"></td><td><pre>        <span class="token comment">// 递归构造左子树</span></pre></td></tr><tr><td data-num="23"></td><td><pre>        root<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">buildTree_</span><span class="token punctuation">(</span>preorder<span class="token punctuation">,</span> preStart <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> preStart <span class="token operator">+</span> rootIndex <span class="token operator">-</span> inStart<span class="token punctuation">,</span> inorder<span class="token punctuation">,</span> inStart<span class="token punctuation">,</span> rootIndex <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>        <span class="token comment">// 递归构造右子树</span></pre></td></tr><tr><td data-num="25"></td><td><pre>        root<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">buildTree_</span><span class="token punctuation">(</span>preorder<span class="token punctuation">,</span> preStart <span class="token operator">+</span> rootIndex <span class="token operator">-</span> inStart <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> preEnd<span class="token punctuation">,</span> inorder<span class="token punctuation">,</span> rootIndex <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> inEnd<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>        <span class="token keyword">return</span> root<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="28"></td><td><pre></pre></td></tr><tr><td data-num="29"></td><td><pre></pre></td></tr><tr><td data-num="30"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">TreeNode</span> <span class="token function">buildTree</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> preorder<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> inorder<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="31"></td><td><pre>        <span class="token comment">// 循环不变量：左闭右闭区间</span></pre></td></tr><tr><td data-num="32"></td><td><pre>        <span class="token keyword">return</span> <span class="token function">buildTree_</span><span class="token punctuation">(</span>preorder<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> preorder<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> inorder<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> inorder<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="33"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="34"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20221220164912154.png" alt="image-20221220164912154"></p><h3 id="654-最大二叉树"><a class="anchor" href="#654-最大二叉树">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tYXhpbXVtLWJpbmFyeS10cmVlLw==">654. 最大二叉树</span></h3><p><strong><mark>构造树一般采用的是<u>前序遍历</u>，因为先构造中间节点，然后<u>递归</u>构造左子树和右子树</mark></strong>。</p><h4 id="分割方式创建新数组-3"><a class="anchor" href="#分割方式创建新数组-3">#</a> 分割方式：创建新数组</h4><p>递归三部曲：</p><ol><li><p>参数和返回值：</p><p>参数就是传入的是存放元素的数组，返回该数组构造的二叉树的头结点，返回类型是指向节点的指针。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token class-name">TreeNode</span> <span class="token function">constructMaximumBinaryTree</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span></pre></td></tr></table></figure></li><li><p>递归终止条件：</p><p>题目中说了输入的数组大小一定是大于等于 1 的，所以我们不用考虑小于 1 的情况，那么当递归遍历的时候，<strong>如果传入的数组大小为 1，说明遍历到了叶子节点了</strong>。</p><p>那么应该定义一个新的节点，并把这个数组的数值赋给新的节点，然后返回这个节点。 这表示一个数组大小是 1 的时候，构造了一个新的节点，并返回。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 只有一个叶子节点</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 返回叶子节点</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure></li><li><p>单层递归的逻辑：</p><p>3.1. 找到数组中最大的值和对应的下标， 最大的值构造根节点，下标用来下一步分割数组</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 找到 nums 中的最大值</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">int</span> max <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token constant">MIN_VALUE</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">int</span> maxIndex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> max<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        max <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        maxIndex <span class="token operator">=</span> i<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token comment">// 创建根节点</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token class-name">TreeNode</span> root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span>max<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>3.2. 根据最大值下标将数组分割为左、右子数组</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 将 nums 分为左右两部分</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> leftNums <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>maxIndex<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> rightNums <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>nums<span class="token punctuation">.</span>length <span class="token operator">-</span> maxIndex <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> maxIndex<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    leftNums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> maxIndex <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    rightNums<span class="token punctuation">[</span>i <span class="token operator">-</span> maxIndex <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>3.3. 递归构造根节点的左、右子树</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 递归创建左右子树</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">if</span> <span class="token punctuation">(</span>leftNums<span class="token punctuation">.</span>length <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    root<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">constructMaximumBinaryTree</span><span class="token punctuation">(</span>leftNums<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">if</span> <span class="token punctuation">(</span>rightNums<span class="token punctuation">.</span>length <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    root<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">constructMaximumBinaryTree</span><span class="token punctuation">(</span>rightNums<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token keyword">return</span> root<span class="token punctuation">;</span></pre></td></tr></table></figure></li></ol><p>完整的 java 代码如下：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 递归（前序遍历）</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">TreeNode</span> <span class="token function">constructMaximumBinaryTree</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token comment">// 递归终止条件</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 只有一个叶子节点</span></pre></td></tr><tr><td data-num="6"></td><td><pre>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 返回叶子节点</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token comment">// 递归过程</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token comment">// 找到 nums 中的最大值</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token keyword">int</span> max <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token constant">MIN_VALUE</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token keyword">int</span> maxIndex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> max<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>                max <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>                maxIndex <span class="token operator">=</span> i<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>        <span class="token comment">// 创建根节点</span></pre></td></tr><tr><td data-num="20"></td><td><pre>        <span class="token class-name">TreeNode</span> root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span>max<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>        <span class="token comment">// 将 nums 分为左右两部分</span></pre></td></tr><tr><td data-num="22"></td><td><pre>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> leftNums <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>maxIndex<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> rightNums <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>nums<span class="token punctuation">.</span>length <span class="token operator">-</span> maxIndex <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> maxIndex<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>            leftNums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> maxIndex <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>            rightNums<span class="token punctuation">[</span>i <span class="token operator">-</span> maxIndex <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>        <span class="token comment">// 递归创建左右子树</span></pre></td></tr><tr><td data-num="31"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>leftNums<span class="token punctuation">.</span>length <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>            root<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">constructMaximumBinaryTree</span><span class="token punctuation">(</span>leftNums<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="33"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="34"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>rightNums<span class="token punctuation">.</span>length <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="35"></td><td><pre>            root<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">constructMaximumBinaryTree</span><span class="token punctuation">(</span>rightNums<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="36"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="37"></td><td><pre>        <span class="token keyword">return</span> root<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="38"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="39"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20221220160917141.png" alt="image-20221220160917141"></p><p>以上代码比较冗余，效率也不高，<strong>每次切割的时候还都要定义新的数组</strong>，但逻辑比较清晰。</p><h4 id="分割方式下标索引-3"><a class="anchor" href="#分割方式下标索引-3">#</a> 分割方式：下标索引</h4><p>和文章 [106. 从中序与后序遍历序列构造二叉树](#106. 从中序与后序遍历序列构造二叉树) 中一样的优化思路，就是<strong>每次分隔不用定义新的数组，而是通过下标索引直接在原数组上操作</strong>。这回导致以下几方面的变换：</p><ol><li>不能直接在原函数上编写递归逻辑了，需要另外定义一个递归函数，因为参数改变了，除了数组 nums，还需要<strong>起始下标、终止下标</strong></li><li>还需要明确循环不变量：<strong>区间的定义原则</strong>（是左闭右开？还是左闭右闭？），这里选择左闭右闭</li><li>递归终止条件变了：<ul><li>数组是否为空：是则返回 null 节点</li><li>数组长度是否为 1：是则返回该叶子节点</li></ul></li><li>最重要的是，找到最大值作为根节点后，对数组<strong> nums 的分割方式改变了</strong>！</li></ol><p>优化后代码如下：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 递归（前序遍历），每次分割不需要重新创建数组，只需通过下标索引在原数组上操作</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">TreeNode</span> <span class="token function">constructMaximumBinaryTree</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token keyword">return</span> <span class="token function">buildTree</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 区间：左闭右闭</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token comment">// 循环不变量：左闭右闭区间</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">private</span> <span class="token class-name">TreeNode</span> <span class="token function">buildTree</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> startIndex<span class="token punctuation">,</span> <span class="token keyword">int</span> endIndex<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token comment">// 递归终止条件</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>startIndex <span class="token operator">></span> endIndex<span class="token punctuation">)</span> <span class="token comment">// 数组为空</span></pre></td></tr><tr><td data-num="11"></td><td><pre>            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>startIndex <span class="token operator">==</span> endIndex<span class="token punctuation">)</span> <span class="token comment">// 数组只有一个元素</span></pre></td></tr><tr><td data-num="13"></td><td><pre>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>startIndex<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token comment">// 找到最大值，及其下标</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token keyword">int</span> maxIndex <span class="token operator">=</span> startIndex<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> startIndex<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> endIndex<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>maxIndex<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>                maxIndex <span class="token operator">=</span> i<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>        <span class="token comment">// 构造根节点</span></pre></td></tr><tr><td data-num="23"></td><td><pre>        <span class="token class-name">TreeNode</span> root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>maxIndex<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>        <span class="token comment">// 递归构造左右子树（这里没有对传入的 nums 是否为空进行判断，需要在 “递归终止条件” 中加以判断）</span></pre></td></tr><tr><td data-num="25"></td><td><pre>        root<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">buildTree</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> startIndex<span class="token punctuation">,</span> maxIndex <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>        root<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">buildTree</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> maxIndex <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> endIndex<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>        <span class="token keyword">return</span> root<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="29"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>优化后的速度明显快了许多：<img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20221220163142088.png" alt="image-20221220163142088"></p><h3 id="本周小结-3"><a class="anchor" href="#本周小结-3">#</a> 本周小结</h3><h4 id="周一-3"><a class="anchor" href="#周一-3">#</a> 周一</h4><p>在<span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVyY2FybC5jb20vJUU0JUJBJThDJUU1JThGJTg5JUU2JUEwJTkxJUU0JUI4JUFEJUU5JTgwJTkyJUU1JUJEJTkyJUU1JUI4JUE2JUU3JTlEJTgwJUU1JTlCJTlFJUU2JUJBJUFGLmh0bWw=">二叉树：以为使用了递归，其实还隐藏着回溯</span>中，通过 leetcode [☆257. 二叉树的所有路径](#☆257. 二叉树的所有路径)，讲解了递归如何隐藏着回溯，一些代码会把回溯的过程都隐藏了起来了，甚至刷过这道题的同学可能都不知道自己用了回溯。</p><p>文章中第一版代码把每一个细节都展示了输出来了，大家可以清晰的看到回溯的过程。</p><p>然后给出了第二版优化后的代码，分析了其回溯隐藏在了哪里，如果要把这个回溯扣出来的话，在第二版的基础上应该怎么改。</p><p>主要需要理解：<strong>回溯隐藏在 <code>traversal(cur-&gt;left, path + &quot;-&gt;&quot;, result);</code> 中的 <code>path + &quot;-&gt;&quot;</code> 。 每次函数调用完，path 依然是没有加上&quot;-&gt;&quot; 的，这就是回溯了。</strong></p><h4 id="周二-3"><a class="anchor" href="#周二-3">#</a> 周二</h4><p>在文章 [404. 左叶子之和](#404. 左叶子之和) 中提供了另一个判断节点属性的思路，平时我们习惯了使用通过节点的左右孩子判断本节点的属性，但发现使用这个思路无法判断左叶子。</p><p>此时需要相连的三层之间构成的约束条件，也就是<strong>要通过节点的父节点以及孩子节点来判断本节点的属性</strong>。</p><p>这道题目可以扩展大家对二叉树的解题思路。</p><h4 id="周三-3"><a class="anchor" href="#周三-3">#</a> 周三</h4><p>在 [513. 找树左下角的值](#513. 找树左下角的值) 中的题目如果使用递归的写法还是有点难度的，<strong>层次遍历</strong>反而很简单。</p><p>题目其实就是要在树的<strong>最后一行</strong>找到<strong>最左边的值</strong>。</p><p><strong>如何判断是最后一行呢，其实就是深度最大的叶子节点一定是最后一行。</strong></p><p>在这篇文章中，我们使用递归算法实实在在的求了一次深度，然后使用靠左的遍历，保证求得靠左的最大深度，而且又一次使用了回溯。</p><p>如果对二叉树的高度与深度又有点模糊了，在看这里 [☆110. 平衡二叉树](#☆110. 平衡二叉树)，回忆一下吧。</p><p>[513. 找树左下角的值](#513. 找树左下角的值) 中把我们之前讲过的内容都过了一遍，此外，还用前序遍历的技巧求得了靠左的最大深度。</p><p><strong>求二叉树的各种最值，就想应该采用什么样的遍历顺序，确定了遍历循序，其实就和数组求最值一样容易了。</strong></p><h4 id="周四-3"><a class="anchor" href="#周四-3">#</a> 周四</h4><p>在 [☆112. 路径总和](#☆112. 路径总和) 中通过两道题目，彻底说清楚递归函数的返回值问题。</p><p>一般情况下：</p><ul><li><p><strong>如果需要搜索整棵二叉树，那么递归函数就不要返回值</strong></p></li><li><p><strong>如果要搜索其中一条符合条件的路径，递归函数就需要返回值，因为遇到符合条件的路径了就要及时返回</strong></p><blockquote><p>特别是有些时候 递归函数的返回值是 bool 类型，一些同学会疑惑为啥要加这个，其实就是为了找到一条边立刻返回</p></blockquote></li><li><p><strong><u>后序遍历</u>需要根据左右递归的返回值推出中间节点的状态，这种需要有返回值</strong></p><blockquote><p>例如 [222. 完全二叉树的节点个数](#222. 完全二叉树的节点个数)，[☆110. 平衡二叉树](#☆110. 平衡二叉树)</p></blockquote></li></ul><h4 id="周五-3"><a class="anchor" href="#周五-3">#</a> 周五</h4><p>之前都是讲解<strong>遍历二叉树</strong>，这次该 **<mark> 构造二叉树</mark> ** 了，在 [106. 从中序与后序遍历序列构造二叉树](#106. 从中序与后序遍历序列构造二叉树) 中，我们通过前序和中序，后序和中序，构造了唯一的一棵二叉树。</p><p><strong>构造二叉树有三个注意的点：</strong></p><ul><li>分割时候，坚持<strong>区间不变量</strong>原则，左闭右开，或者左闭又闭。</li><li>分割的时候，<strong>注意后序 或者 前序已经有一个节点作为中间节点了，不能继续使用了</strong>。</li><li>如何使用切割后的中序数组来切割后序数组？<strong>利用中序数组大小一定是和后序数组的大小相同这一特点来进行切割</strong>。</li></ul><p>这道题目代码实现并不简单，大家啃下来之后，二叉树的构造应该不是问题了。</p><p><strong>最后我还给出了为什么前序和后序不能唯一构成一棵二叉树，因为没有中序遍历就无法确定左右部分，也就无法分割。</strong></p><h4 id="周六-3"><a class="anchor" href="#周六-3">#</a> 周六</h4><p>知道了如何构造二叉树，那么使用一个套路就可以解决文章 [654. 最大二叉树](#654. 最大二叉树) 中的问题。</p><p><strong>注意类似用数组构造二叉树的题目，每次分隔尽量不要定义新的数组，而是通过<mark>下标索引</mark>直接在原数组上操作，这样可以节约时间和空间上的开销。</strong></p><p>文章中我还给出了递归函数什么时候加 if，什么时候不加 if，其实就是控制空节点（空指针）是否进入递归，是不同的代码实现方式，都是可以的。</p><p><strong>一般情况来说</strong></p><ul><li><strong>如果让空节点（空指针）进入递归，就不加 if</strong></li><li><strong>如果不让空节点进入递归，就加 if 限制一下</strong></li></ul><p><u>终止条件也会相应的调整</u></p><h4 id="小结-5"><a class="anchor" href="#小结-5">#</a> 小结</h4><p>本周我们深度讲解了如下知识点：</p><ol><li><span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVyY2FybC5jb20vJUU0JUJBJThDJUU1JThGJTg5JUU2JUEwJTkxJUU0JUI4JUFEJUU5JTgwJTkyJUU1JUJEJTkyJUU1JUI4JUE2JUU3JTlEJTgwJUU1JTlCJTlFJUU2JUJBJUFGLmh0bWw=">递归中如何隐藏着回溯</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVyY2FybC5jb20vMDQwNC4lRTUlQjclQTYlRTUlOEYlQjYlRTUlQUQlOTAlRTQlQjklOEIlRTUlOTIlOEMuaHRtbA==">如何通过三层关系确定左叶子</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVyY2FybC5jb20vMDUxMy4lRTYlODklQkUlRTYlQTAlOTElRTUlQjclQTYlRTQlQjglOEIlRTglQTclOTIlRTclOUElODQlRTUlODAlQkMuaHRtbA==">如何通过二叉树深度来判断左下角的值</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVyY2FybC5jb20vMDExMi4lRTglQjclQUYlRTUlQkUlODQlRTYlODAlQkIlRTUlOTIlOEMuaHRtbA==">递归函数究竟什么时候需要返回值，什么时候不要返回值？</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVyY2FybC5jb20vMDEwNi4lRTQlQkIlOEUlRTQlQjglQUQlRTUlQkElOEYlRTQlQjglOEUlRTUlOTAlOEUlRTUlQkElOEYlRTklODElOEQlRTUlOEUlODYlRTUlQkElOEYlRTUlODglOTclRTYlOUUlODQlRTklODAlQTAlRTQlQkElOEMlRTUlOEYlODklRTYlQTAlOTEuaHRtbA==">前序和中序，后序和中序构造唯一二叉树</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVyY2FybC5jb20vMDY1NC4lRTYlOUMlODAlRTUlQTQlQTclRTQlQkElOEMlRTUlOEYlODklRTYlQTAlOTEuaHRtbA==">使用数组构造某一特性的二叉树</span></li></ol><p><strong>如果大家一路跟下来，一定收获满满，如果周末不做这个总结，大家可能都不知道自己收获满满，啊哈！</strong></p><h3 id="617-合并二叉树"><a class="anchor" href="#617-合并二叉树">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tZXJnZS10d28tYmluYXJ5LXRyZWVzLw==">617. 合并二叉树</span></h3><p>相信这道题目很多同学疑惑的点是如何同时遍历两个二叉树呢？</p><p>其实和遍历一个树逻辑是一样的，只不过<strong>传入两个树的节点，同时操作</strong>。</p><h4 id="递归-6"><a class="anchor" href="#递归-6">#</a> √递归</h4><p>二叉树使用递归，就要想使用前中后哪种遍历方式？</p><p><strong>本题使用哪种遍历都是可以的！</strong></p><p>我们下面以<u>前序遍历</u>为例。</p><p>动画如下：</p><p><img data-src="https://code-thinking.cdn.bcebos.com/gifs/617.%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91.gif" alt="617.合并二叉树"></p><p>那么我们来按照递归三部曲来解决：</p><ol><li><p>参数、返回值：</p><ul><li>参数：至少是要传入两个二叉树的根节点</li><li>返回值：就是合并之后二叉树的根节点</li></ul><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token class-name">TreeNode</span> <span class="token function">mergeTrees</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root1<span class="token punctuation">,</span> <span class="token class-name">TreeNode</span> root2<span class="token punctuation">)</span></pre></td></tr></table></figure></li><li><p>递归终止条件：</p><p>因为是传入了两个树，那么就有两个树遍历的节点 t1 和 t2</p><ul><li>如果 <code>t1 == NULL</code> ，两个树合并就应该是 t2 了（如果 t2 也为 NULL 也无所谓，合并之后就是 NULL）</li><li>如果 <code>t2 == NULL</code> ，那么两个数合并就是 t1（如果 t1 也为 NULL 也无所谓，合并之后就是 NULL）</li></ul><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">if</span> <span class="token punctuation">(</span>root1 <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> root2<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">if</span> <span class="token punctuation">(</span>root2 <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> root1<span class="token punctuation">;</span></pre></td></tr></table></figure></li><li><p>单层递归逻辑：</p><p>单层递归的逻辑就比较好写了，这里我们重复利用一下 t1 这个树，t1 就是合并之后树的根节点（就是修改了原来树的结构）</p><ol><li><p>把两棵树的元素加到一起</p></li><li><p>t1 的左子树：合并 t1 左子树 t2 左子树之后的左子树</p></li><li><p>t1 的右子树：合并 t1 右子树 t2 右子树之后的右子树</p></li></ol><p>最终 t1 就是合并之后的根节点。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre>root1<span class="token punctuation">.</span>val <span class="token operator">=</span> root1<span class="token punctuation">.</span>val <span class="token operator">+</span> root2<span class="token punctuation">.</span>val<span class="token punctuation">;</span> <span class="token comment">// 根节点合并，重复利用 root1</span></pre></td></tr><tr><td data-num="2"></td><td><pre>root1<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">mergeTrees</span><span class="token punctuation">(</span>root1<span class="token punctuation">.</span>left<span class="token punctuation">,</span> root2<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 左子树合并</span></pre></td></tr><tr><td data-num="3"></td><td><pre>root1<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">mergeTrees</span><span class="token punctuation">(</span>root1<span class="token punctuation">.</span>right<span class="token punctuation">,</span> root2<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 右子树合并</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">return</span> root1<span class="token punctuation">;</span></pre></td></tr></table></figure></li></ol><p>完整的 java 代码如下：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 递归实现（前序遍历）</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">TreeNode</span> <span class="token function">mergeTrees</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root1<span class="token punctuation">,</span> <span class="token class-name">TreeNode</span> root2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token comment">// 递归终止条件</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root1 <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> root2<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root2 <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> root1<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token comment">// 递归过程</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        root1<span class="token punctuation">.</span>val <span class="token operator">=</span> root1<span class="token punctuation">.</span>val <span class="token operator">+</span> root2<span class="token punctuation">.</span>val<span class="token punctuation">;</span> <span class="token comment">// 根节点合并，重复利用 root1</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        root1<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">mergeTrees</span><span class="token punctuation">(</span>root1<span class="token punctuation">.</span>left<span class="token punctuation">,</span> root2<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 左子树合并</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        root1<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">mergeTrees</span><span class="token punctuation">(</span>root1<span class="token punctuation">.</span>right<span class="token punctuation">,</span> root2<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 右子树合并</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token keyword">return</span> root1<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20221220193615456.png" alt="image-20221220193615456"></p><p>对于中序遍历、后序遍历，只需要更改一下代码顺序即可。<strong>但是前序遍历是最好理解的，我建议大家用前序遍历来做就 OK。</strong></p><p>如上的方法修改了 t1 的结构，当然也可以不修改 t1 和 t2 的结构，重新定义一个树。</p><p>不修改输入树的结构，前序遍历，代码如下：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 递归实现（前序遍历）</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">TreeNode</span> <span class="token function">mergeTrees</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root1<span class="token punctuation">,</span> <span class="token class-name">TreeNode</span> root2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token comment">// 递归终止条件</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root1 <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> root2<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root2 <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> root1<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token comment">// 递归过程</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token class-name">TreeNode</span> root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span>root1<span class="token punctuation">.</span>val <span class="token operator">+</span> root2<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 根节点合并，新建一个节点</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        root<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">mergeTrees</span><span class="token punctuation">(</span>root1<span class="token punctuation">.</span>left<span class="token punctuation">,</span> root2<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 左子树合并</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        root<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">mergeTrees</span><span class="token punctuation">(</span>root1<span class="token punctuation">.</span>right<span class="token punctuation">,</span> root2<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 右子树合并</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token keyword">return</span> root<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20221220193823862.png" alt="image-20221220193823862"></p><h4 id="迭代-3"><a class="anchor" href="#迭代-3">#</a> 迭代</h4><p>使用迭代法，如何同时处理两棵树呢？</p><p>思路我们在 [101. 对称二叉树](#101. 对称二叉树) 中的迭代法已经讲过一次了，求二叉树对称的时候就是把两个树的节点同时加入队列进行比较。</p><p>本题我们也使用<strong>队列</strong>，模拟的<strong>层序遍历</strong>，代码如下：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 迭代（层序遍历），借助队列</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">TreeNode</span> <span class="token function">mergeTrees</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root1<span class="token punctuation">,</span> <span class="token class-name">TreeNode</span> root2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token comment">// 特判</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root1 <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> root2<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root2 <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> root1<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TreeNode</span><span class="token punctuation">></span></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>root1<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>root2<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>            <span class="token class-name">TreeNode</span> node1 <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>            <span class="token class-name">TreeNode</span> node2 <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre></pre></td></tr><tr><td data-num="17"></td><td><pre>            <span class="token comment">// 根节点处理逻辑</span></pre></td></tr><tr><td data-num="18"></td><td><pre>            node1<span class="token punctuation">.</span>val <span class="token operator">+=</span> node2<span class="token punctuation">.</span>val<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre></pre></td></tr><tr><td data-num="20"></td><td><pre>            <span class="token comment">// 左子树处理逻辑</span></pre></td></tr><tr><td data-num="21"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>node1<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> node2<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>                queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>node1<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>                queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>node2<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>node1<span class="token punctuation">.</span>left <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> node2<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>                node1<span class="token punctuation">.</span>left <span class="token operator">=</span> node2<span class="token punctuation">.</span>left<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>node1<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> node2<span class="token punctuation">.</span>left <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>                <span class="token comment">// 什么都不做，因为本身就是复用 node1</span></pre></td></tr><tr><td data-num="28"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="29"></td><td><pre></pre></td></tr><tr><td data-num="30"></td><td><pre>            <span class="token comment">// 右子树处理逻辑</span></pre></td></tr><tr><td data-num="31"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>node1<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> node2<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>                queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>node1<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="33"></td><td><pre>                queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>node2<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="34"></td><td><pre>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>node1<span class="token punctuation">.</span>right <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> node2<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="35"></td><td><pre>                node1<span class="token punctuation">.</span>right <span class="token operator">=</span> node2<span class="token punctuation">.</span>right<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="36"></td><td><pre>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>node1<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> node2<span class="token punctuation">.</span>right <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="37"></td><td><pre>                <span class="token comment">// 什么都不做，因为本身就是复用 node1</span></pre></td></tr><tr><td data-num="38"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="39"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="40"></td><td><pre>        <span class="token keyword">return</span> root1<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="41"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="42"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20221220200159211.png" alt="image-20221220200159211"></p><h4 id="总结-18"><a class="anchor" href="#总结-18">#</a> 总结</h4><p>合并二叉树，也是二叉树操作的经典题目，如果没有接触过的话，其实并不简单，因为我们习惯了操作一个二叉树，一起操作两个二叉树，还会有点懵懵的。</p><p>这不是我们第一次操作两棵二叉树了，在 [101. 对称二叉树](#101. 对称二叉树) 中也一起操作了两棵二叉树。</p><p><strong>迭代法</strong>中，一般一起操作两个树都是<strong>使用队列模拟类似层序遍历</strong>，同时处理两个树的节点，这种方式最好理解，如果用模拟递归的思路的话，要复杂一些。</p><p>最后拓展中，我给了一个操作指针的野路子，大家随便看看就行了，如果学习 C++ 的话，可以再去研究研究。</p><h3 id="700-二叉搜索树中的搜索"><a class="anchor" href="#700-二叉搜索树中的搜索">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zZWFyY2gtaW4tYS1iaW5hcnktc2VhcmNoLXRyZWUv">700. 二叉搜索树中的搜索</span></h3><p>之前我们讲的都是普通二叉树，那么接下来看看二叉搜索树。</p><p>在<a href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80">二叉树的理论基础</a>中，我们已经讲过了二叉搜索树。</p><p>二叉搜索树是一个<mark>有序</mark>树：</p><ul><li>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li><li>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li><li>它的左、右子树也分别为二叉搜索树</li></ul><p>这就决定了，二叉搜索树，<strong>递归遍历和迭代遍历和普通二叉树都不一样</strong>。</p><p>本题，其实就是在二叉搜索树中搜索一个节点。那么我们来看看应该如何遍历。</p><h4 id="递归-7"><a class="anchor" href="#递归-7">#</a> 递归</h4><ol><li><p>参数、返回值：参数传入的就是根节点和要搜索的数值，返回的就是以这个搜索数值所在的节点</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token class-name">TreeNode</span> <span class="token function">searchBST</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span></pre></td></tr></table></figure></li><li><p>递归终止条件：</p><ul><li>如果 root 为空，就返回 root 节点</li><li>如果 root 符合条件，也返回 root 节点</li></ul><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> root<span class="token punctuation">.</span>val <span class="token operator">==</span> val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">return</span> root<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure></li><li><p>单层递归的逻辑：</p><p>看看二叉搜索树的单层递归逻辑有何不同。</p><p><strong>因为二叉搜索树的节点是有序的，所以可以有方向的去搜索</strong>。</p><p>如果 root-&gt;val &gt; val，搜索左子树，如果 root-&gt;val &lt; val，就搜索右子树，最后如果都没有搜索到，就返回 NULL。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">TreeNode</span> res <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>val <span class="token operator">></span> val<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    res <span class="token operator">=</span> <span class="token function">searchBST</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 左</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> val<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    res <span class="token operator">=</span> <span class="token function">searchBST</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 右</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">return</span> res<span class="token punctuation">;</span></pre></td></tr></table></figure><p>很多录友写递归函数的时候 习惯直接写 <code>searchBST(root-&gt;left, val)</code> ，却忘了 递归函数还有返回值。</p><p>递归函数的返回值是什么？是 左子树如果搜索到了 val，要将该节点返回。 如果不用一个变量将其接住，那么返回值不就没了。</p><p>所以要 <code>result = searchBST(root-&gt;left, val)</code> 。</p></li></ol><p>完整的 java 代码如下：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 递归（前序遍历）</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">TreeNode</span> <span class="token function">searchBST</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token comment">// 递归终止条件：root 为空 或者 root 的值等于 val</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> root<span class="token punctuation">.</span>val <span class="token operator">==</span> val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>            <span class="token keyword">return</span> root<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token comment">// 单层递归逻辑（无根节点的处理逻辑，在终止条件中）</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token class-name">TreeNode</span> res <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>val <span class="token operator">></span> val<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="11"></td><td><pre>            res <span class="token operator">=</span> <span class="token function">searchBST</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 左</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> val<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="13"></td><td><pre>            res <span class="token operator">=</span> <span class="token function">searchBST</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 右</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token keyword">return</span> res<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20221220201957787.png" alt="image-20221220201957787"></p><h4 id="迭代-4"><a class="anchor" href="#迭代-4">#</a> 迭代</h4><p>一提到二叉树遍历的迭代法，可能立刻想起使<strong>用栈来模拟深度遍历，使用队列来模拟广度遍历</strong>。</p><blockquote><p>深度遍历：前、中、后序</p><p>广度遍历：层序</p></blockquote><p>对于二叉搜索树可就不一样了，因为二叉搜索树的特殊性，也就是 **<mark> 节点的有序性，可以不使用辅助栈或者队列就可以写出迭代法</mark> **</p><p>对于一般二叉树，递归过程中还有回溯的过程，例如走一个左方向的分支走到头了，那么要调头，在走右分支</p><p>而 **<mark> 对于二叉搜索树，不需要回溯的过程，因为节点的有序性就帮我们确定了搜索的方向</mark> **</p><p>例如要搜索元素为 3 的节点，<strong>我们不需要搜索其他节点，也不需要做回溯，查找的路径已经规划好了</strong></p><p>中间节点如果大于 3 就向左走，如果小于 3 就向右走，如图：</p><p><img data-src="https://img-blog.csdnimg.cn/20200812190213280.png" alt="二叉搜索树"></p><p>所以迭代法代码如下：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 迭代</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">TreeNode</span> <span class="token function">searchBST</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token keyword">while</span> <span class="token punctuation">(</span>root <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>                root <span class="token operator">=</span> root<span class="token punctuation">.</span>right<span class="token punctuation">;</span> <span class="token comment">// 右子树</span></pre></td></tr><tr><td data-num="7"></td><td><pre>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>val <span class="token operator">></span> val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>                root <span class="token operator">=</span> root<span class="token punctuation">.</span>left<span class="token punctuation">;</span> <span class="token comment">// 左子树</span></pre></td></tr><tr><td data-num="9"></td><td><pre>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>                <span class="token keyword">return</span> root<span class="token punctuation">;</span> <span class="token comment">// 找到</span></pre></td></tr><tr><td data-num="11"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// 未找到</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20221220214606641.png" alt="image-20221220214606641"></p><h4 id="总结-19"><a class="anchor" href="#总结-19">#</a> 总结</h4><p>本篇我们介绍了二叉搜索树的遍历方式，<strong>因为二叉搜索树的有序性，遍历的时候要比普通二叉树简单很多</strong>。</p><p>但是一些同学很容易忽略二叉搜索树的特性，所以写出遍历的代码就未必真的简单了。</p><p>所以针对二叉搜索树的题目，一样要利用其特性。</p><p>文中我依然给出递归和迭代两种方式，可以看出写法都非常简单，就是利用了二叉搜索树有序的特点。</p><h3 id="98-验证二叉搜索树"><a class="anchor" href="#98-验证二叉搜索树">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy92YWxpZGF0ZS1iaW5hcnktc2VhcmNoLXRyZWUv">98. 验证二叉搜索树</span></h3><p>要知道<strong>中序遍历下，输出的二叉搜索树节点的数值是递增的有序序列</strong>。</p><p>有了这个特性，<strong>验证二叉搜索树，就相当于变成了判断一个序列是不是递增的了。</strong></p><h4 id="递归-8"><a class="anchor" href="#递归-8">#</a> 递归</h4><h5 id="转为有序数组"><a class="anchor" href="#转为有序数组">#</a> √转为有序数组</h5><p>可以递归中序遍历将二叉搜索树转变成一个数组，代码如下：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">inorder</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> list<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 递归终止条件</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token comment">// 递归过程</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token function">inorder</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> list<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token function">inorder</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> list<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>然后只要比较一下，这个数组是否是有序的，<strong>注意二叉搜索树中不能有重复元素</strong>。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isValidBST</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token function">inorder</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> list<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>整体代码如下：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 递归（中序遍历），判断是否是升序即可</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isValidBST</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token function">inorder</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> list<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">inorder</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> list<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token comment">// 递归终止条件</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token comment">// 递归过程</span></pre></td></tr><tr><td data-num="18"></td><td><pre>        <span class="token function">inorder</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> list<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>        <span class="token function">inorder</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> list<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="22"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20221221113106006.png" alt="image-20221221113106006"></p><p>以上代码中，我们把二叉树转变为数组来判断，是最直观的，但<strong>其实不用转变成数组，可以在递归遍历的过程中直接判断是否有序</strong>。</p><h5 id="前-后双指针"><a class="anchor" href="#前-后双指针">#</a> 前、后双指针</h5><p>这道题目比较容易陷入两个陷阱：</p><ul><li>陷阱 1</li></ul><p><strong>不能单纯的比较左节点小于中间节点，右节点大于中间节点就完事了</strong>。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>val <span class="token operator">></span> root<span class="token punctuation">.</span>left<span class="token punctuation">.</span>val <span class="token operator">&amp;&amp;</span> root<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> root<span class="token punctuation">.</span>right<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><strong>我们要比较的是 左子树所有节点小于中间节点，右子树所有节点大于中间节点</strong>。所以以上代码的判断逻辑是错误的。</p><p>例如： [10,5,15,null,null,6,20] 这个 case：</p><p><img data-src="https://img-blog.csdnimg.cn/20200812191501419.png" alt="二叉搜索树"></p><p>节点 10 大于左节点 5，小于右节点 15，但右子树里出现了一个 6 这就不符合了！</p><ul><li>陷阱 2</li></ul><p>样例中最小节点 可能是 int 的最小值，如果这样使用最小的 int 来比较也是不行的。</p><p>此时可以初始化比较元素为 longlong 的最小值。</p><p>问题可以进一步演进：如果样例中根节点的 val 可能是 longlong 的最小值 又要怎么办呢？文中会解答。</p><p>了解这些陷阱之后我们来看一下代码应该怎么写：</p><p>递归三部曲：</p><ol><li><p>返回值、参数：</p><p>要定义<strong>一个 longlong 的全局变量，用来比较遍历的节点是否有序</strong>，因为后台测试数据中有 int 最小值，所以定义为 longlong 的类型，初始化为 longlong 最小值。</p><p>注意递归函数<strong>要有 bool 类型的返回值</strong>， 我们在<span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVyY2FybC5jb20vMDExMi4lRTglQjclQUYlRTUlQkUlODQlRTYlODAlQkIlRTUlOTIlOEMuaHRtbA==">二叉树：递归函数究竟什么时候需要返回值，什么时候不要返回值？</span>中讲了，只有寻找某一条边（或者一个节点）的时候，递归函数会有 bool 类型的返回值。</p><p>其实本题是同样的道理，<strong>我们在寻找一个不符合条件的节点</strong>，如果没有找到这个节点就遍历了整个树，如果找到不符合的节点了，立刻返回。</p><p>这样看来可以<strong>直接使用原函数作为递归函数</strong>。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">TreeNode</span> pre <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// 记录上一个节点</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isValidBST</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span></pre></td></tr></table></figure></li><li><p>递归终止条件：</p><p>如果是空节点 是不是二叉搜索树呢？</p><p>是的，二叉搜索树也可以为空！</p><p>代码如下：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr></table></figure></li><li><p>单层递归逻辑：</p><p>中序遍历，一直更新 maxVal，一旦发现 maxVal &gt;= root-&gt;val，就返回 false，注意元素相同时候也要返回 false。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 递归过程：中序遍历，一直更新 pre，一旦发现 pre.val >= root->val，就返回 false，注意元素相同时候也要返回 false。</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">boolean</span> left <span class="token operator">=</span> <span class="token function">isValidBST</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 左子树</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment">// 中间节点</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">if</span> <span class="token punctuation">(</span>pre <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> pre<span class="token punctuation">.</span>val <span class="token operator">>=</span> root<span class="token punctuation">.</span>val<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>pre <span class="token operator">=</span> root<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">boolean</span> right <span class="token operator">=</span> <span class="token function">isValidBST</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 右子树</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token keyword">return</span> left <span class="token operator">&amp;&amp;</span> right<span class="token punctuation">;</span></pre></td></tr></table></figure></li></ol><p>整体代码：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 递归（中序遍历），在递归过程中判断是否有序</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token class-name">TreeNode</span> pre <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// 记录上一个节点</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isValidBST</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token comment">// 递归终止条件</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token comment">// 递归过程：中序遍历，一直更新 pre，一旦发现 pre.val >= root->val，就返回 false，注意元素相同时候也要返回 false。</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token keyword">boolean</span> left <span class="token operator">=</span> <span class="token function">isValidBST</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 左子树</span></pre></td></tr><tr><td data-num="10"></td><td><pre></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token comment">// 中间节点</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>pre <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> pre<span class="token punctuation">.</span>val <span class="token operator">>=</span> root<span class="token punctuation">.</span>val<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="13"></td><td><pre>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        pre <span class="token operator">=</span> root<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre></pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token keyword">boolean</span> right <span class="token operator">=</span> <span class="token function">isValidBST</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 右子树</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token keyword">return</span> left <span class="token operator">&amp;&amp;</span> right<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20221221114845254.png" alt="image-20221221114845254"></p><h4 id="迭代-5"><a class="anchor" href="#迭代-5">#</a> 迭代</h4><p>可以用迭代法模拟二叉树<strong>中序遍历</strong>，对前中后序迭代法生疏的同学可以看这两篇<a href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%86">二叉树的迭代遍历</a>，<a href="#%E2%98%86%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%BB%9F%E4%B8%80%E8%BF%AD%E4%BB%A3%E6%B3%95">☆二叉树的统一迭代法</a></p><p>迭代法中序遍历稍加改动就可以了，代码如下：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 迭代（中序遍历），借助栈、节点指针</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isValidBST</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TreeNode</span><span class="token punctuation">></span></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token class-name">TreeNode</span> cur <span class="token operator">=</span> root<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token class-name">TreeNode</span> pre <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// 记录前一个节点</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token keyword">while</span> <span class="token punctuation">(</span>cur <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>cur <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>                stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>                cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>left<span class="token punctuation">;</span> <span class="token comment">// 一路向左</span></pre></td></tr><tr><td data-num="13"></td><td><pre>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 此时 cur == null，到达最左节点下的 null 节点</span></pre></td></tr><tr><td data-num="14"></td><td><pre>                cur <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//cur 回退到中间节点</span></pre></td></tr><tr><td data-num="15"></td><td><pre>                <span class="token keyword">if</span> <span class="token punctuation">(</span>pre <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> cur<span class="token punctuation">.</span>val <span class="token operator">&lt;=</span> pre<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 发现 pre ≥ cur</span></pre></td></tr><tr><td data-num="16"></td><td><pre>                    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>                <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>                pre <span class="token operator">=</span> cur<span class="token punctuation">;</span> <span class="token comment">// 更新 pre</span></pre></td></tr><tr><td data-num="19"></td><td><pre></pre></td></tr><tr><td data-num="20"></td><td><pre>                cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>right<span class="token punctuation">;</span> <span class="token comment">// 右</span></pre></td></tr><tr><td data-num="21"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="23"></td><td><pre></pre></td></tr><tr><td data-num="24"></td><td><pre>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="26"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20221221120046166.png" alt="image-20221221120046166"></p><p>在 [700. 二叉搜索树中的搜索](#700. 二叉搜索树中的搜索) 中我们分明写出了痛哭流涕的简洁迭代法，怎么在这里不行了呢，因为本题是要验证二叉搜索树啊。</p><h4 id="总结-20"><a class="anchor" href="#总结-20">#</a> 总结</h4><p>这道题目是一个简单题，但对于没接触过的同学还是有难度的。</p><p>所以初学者刚开始学习算法的时候，看到简单题目没有思路很正常，千万别怀疑自己智商，学习过程都是这样的，大家智商都差不多，哈哈。</p><p>只要把基本类型的题目都做过，总结过之后，思路自然就开阔了。</p><h3 id="530-二叉搜索树的最小绝对差"><a class="anchor" href="#530-二叉搜索树的最小绝对差">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9taW5pbXVtLWFic29sdXRlLWRpZmZlcmVuY2UtaW4tYnN0Lw==">530. 二叉搜索树的最小绝对差</span></h3><p>题目中要求在二叉搜索树上任意两节点的差的绝对值的最小值。</p><p><strong>注意是二叉搜索树</strong>，二叉搜索树可是<mark>有序</mark>的。</p><p>遇到在二叉搜索树上求什么最值啊，差值之类的，就把它想成在一个<strong>有序数组</strong>上求最值，求差值，这样就简单多了。</p><h4 id="递归-9"><a class="anchor" href="#递归-9">#</a> 递归</h4><h5 id="转为有序数组-2"><a class="anchor" href="#转为有序数组-2">#</a> √转为有序数组</h5><p>那么二叉搜索树采用<strong>中序遍历</strong>，其实就是一个有序数组。</p><p>在一个有序数组上求两个数最小差值，这是不是就是一道送分题了。</p><p>最直观的想法，就是<strong>把二叉搜索树转换成有序数组，然后遍历一遍数组，就统计出来最小差值了</strong>。</p><p>代码如下：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getMinimumDifference</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token function">inorder</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> list<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token comment">// 找出递增数组 list 中的最小差值</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token keyword">int</span> min <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token constant">MAX_VALUE</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token comment">// 通过双层循环遍历</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>                min <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>min<span class="token punctuation">,</span> list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span> <span class="token operator">-</span> list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token keyword">return</span> min<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">inorder</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> list<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token comment">// 递归终止条件</span></pre></td></tr><tr><td data-num="18"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre></pre></td></tr><tr><td data-num="20"></td><td><pre>        <span class="token comment">// 递归过程</span></pre></td></tr><tr><td data-num="21"></td><td><pre>        <span class="token function">inorder</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> list<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>        <span class="token function">inorder</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> list<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="25"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>效率奇差：<img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20221221125534438.png" alt="image-20221221125534438"></p><p>其实这里不必通过双层 for 循环去查找有序数组中的最小差值，因为最小差值一定是在相邻元素之间的（因为数组是递增的），更改如下：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getMinimumDifference</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token function">inorder</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> list<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token comment">// 找出递增数组 list 中的最小差值</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token keyword">int</span> min <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token constant">MAX_VALUE</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre>            min <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>min<span class="token punctuation">,</span> list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">-</span> list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token keyword">return</span> min<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">inorder</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> list<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token comment">// 递归终止条件</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre></pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token comment">// 递归过程</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token function">inorder</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> list<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>        <span class="token function">inorder</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> list<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="21"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20221221125916246.png" alt="image-20221221125916246"></p><h5 id="前-后双指针-2"><a class="anchor" href="#前-后双指针-2">#</a> √前、后双指针</h5><blockquote><p>双指针：pre 和 root</p></blockquote><p>以上代码是把二叉搜索树转化为有序数组了，<strong>其实在二叉搜素树中序遍历的过程中，我们就可以直接计算了</strong>。</p><p><strong>需要用一个 pre 节点记录一下 cur 节点的前一个节点</strong>。</p><p>如图：</p><p><img data-src="https://img-blog.csdnimg.cn/20210204153247458.png" alt="530.二叉搜索树的最小绝对差"></p><p>一些同学不知道<strong>在递归中如何记录前一个节点的指针</strong>，其实实现起来是很简单的，大家只要看过一次，写过一次，就掌握了。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">int</span> minRes <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token constant">MAX_VALUE</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token class-name">TreeNode</span> pre <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getMinimumDifference</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token function">inorder</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token keyword">return</span> minRes<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">inorder</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token comment">// 递归终止条件</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token comment">// 递归过程</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token function">inorder</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 左</span></pre></td></tr><tr><td data-num="15"></td><td><pre></pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>pre <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token comment">// 中</span></pre></td></tr><tr><td data-num="17"></td><td><pre>            minRes <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>minRes<span class="token punctuation">,</span> root<span class="token punctuation">.</span>val <span class="token operator">-</span> pre<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>        pre <span class="token operator">=</span> root<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>        </pre></td></tr><tr><td data-num="20"></td><td><pre>        <span class="token function">inorder</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 右</span></pre></td></tr><tr><td data-num="21"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="22"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20221221130449567.png" alt="image-20221221130449567"></p><h4 id="迭代-6"><a class="anchor" href="#迭代-6">#</a> 迭代</h4><blockquote><p>双指针：pre 和 cur</p></blockquote><p>用 **<mark> 栈</mark><strong>模拟</strong>中序遍历<strong>的递归法，同时需要</strong><mark>节点指针</mark> ** 以进行遍历，代码如下：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 迭代（中序遍历），借助栈、节点指针</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getMinimumDifference</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token keyword">int</span> minRes <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token constant">MAX_VALUE</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TreeNode</span><span class="token punctuation">></span></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token class-name">TreeNode</span> cur <span class="token operator">=</span> root<span class="token punctuation">;</span> <span class="token comment">// 当前节点，用于遍历</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token class-name">TreeNode</span> pre <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// 记录前一个节点</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token keyword">while</span> <span class="token punctuation">(</span>cur <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 当前节点不为空（第一次） 或者 栈不为空</span></pre></td></tr><tr><td data-num="9"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>cur <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>                stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>                cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>left<span class="token punctuation">;</span> <span class="token comment">// 一路向左</span></pre></td></tr><tr><td data-num="12"></td><td><pre>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>                cur <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 中</span></pre></td></tr><tr><td data-num="14"></td><td><pre>                <span class="token keyword">if</span> <span class="token punctuation">(</span>pre <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="15"></td><td><pre>                    minRes <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>minRes<span class="token punctuation">,</span> cur<span class="token punctuation">.</span>val <span class="token operator">-</span> pre<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>                pre <span class="token operator">=</span> cur<span class="token punctuation">;</span> <span class="token comment">// 记录前一个节点</span></pre></td></tr><tr><td data-num="17"></td><td><pre></pre></td></tr><tr><td data-num="18"></td><td><pre>                cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>right<span class="token punctuation">;</span> <span class="token comment">// 右</span></pre></td></tr><tr><td data-num="19"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>        <span class="token keyword">return</span> minRes<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="23"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20221221131143704.png" alt="image-20221221131143704"></p><h4 id="总结-21"><a class="anchor" href="#总结-21">#</a> 总结</h4><p><strong>遇到在二叉搜索树上求什么最值，求差值之类的，都要思考一下二叉搜索树可是有序的，要利用好这一特点。</strong></p><p>同时要学会<strong>在递归遍历的过程中如何记录前后两个指针</strong>，这也是一个小技巧，学会了还是很受用的。</p><p>后面我将继续介绍一系列利用二叉搜索树特性的题目。</p><h3 id="501-二叉搜索树中的众数"><a class="anchor" href="#501-二叉搜索树中的众数">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9maW5kLW1vZGUtaW4tYmluYXJ5LXNlYXJjaC10cmVlLw==">501. 二叉搜索树中的众数</span></h3><blockquote><p>二叉树上应该怎么求，二叉搜索树上又应该怎么求？</p></blockquote><p>这道题目呢，递归法我从两个维度来讲。</p><p>首先如果不是二叉搜索树的话，应该怎么解题，是二叉搜索树，又应该如何解题，两种方式做一个比较，可以加深大家对二叉树的理解。</p><h4 id="递归法-4"><a class="anchor" href="#递归法-4">#</a> 递归法</h4><h5 id="不是二叉搜索树"><a class="anchor" href="#不是二叉搜索树">#</a> √不是二叉搜索树</h5><p>如果不是二叉搜索树，最直观的方法一定是<strong>把这个树都遍历了，用 map 统计频率，把频率排个序，最后取前面高频的元素的集合</strong>。</p><p>具体步骤如下：</p><ol><li><p>这个树都遍历了，用 map 统计频率</p><p>至于用前中后序<strong>哪种遍历也不重要</strong>，因为就是要全遍历一遍，怎么个遍历法都行，层序遍历都没毛病！</p><p>这里采用前序遍历，代码如下：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">preorder</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>        <span class="token comment">// 递归终止条件</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token comment">// 递归过程</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">,</span> map<span class="token punctuation">.</span><span class="token function">getOrDefault</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 中</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token function">preorder</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 左</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token function">preorder</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 右</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr></table></figure></li><li><p>把统计的出来的出现频率（即 map 中的 value）排个序</p><p>有的同学可能可以想直接对 map 中的 value 排序，还真做不到，C++ 中如果使用 std::map 或者 std::multimap 可以对 key 排序，但不能对 value 排序。</p><p>所以<strong>要把 map 转化数组</strong>即 vector，再进行排序，当然 vector 里面放的也是 <code>pair&lt;int, int&gt;</code> 类型的数据，第一个 int 为元素，第二个 int 为出现频率。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 对 map 的 value 进行降序排序</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">></span><span class="token punctuation">></span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>list<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">(</span>o1<span class="token punctuation">,</span> o2<span class="token punctuation">)</span> <span class="token operator">-></span> o2<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> o1<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure></li><li><p>取前面高频的元素</p><p>此时数组 vector 中已经是存放着按照频率排好序的 pair，那么把前面高频的元素取出来就可以了。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 找出最大的 value</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">int</span> max <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment">// 找出所有 value 等于 max 的 key</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">></span></span> entry <span class="token operator">:</span> list<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> max<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>entry<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token keyword">break</span><span class="token punctuation">;</span> <span class="token comment">// 因为 list 已经按 value 降序排序，所以一旦出现 value 不等于 max 的情况，就可以跳出循环</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token comment">// 将 list 转为数组</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>res<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> res<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> res<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token keyword">return</span> arr<span class="token punctuation">;</span></pre></td></tr></table></figure></li></ol><p>整体的 java 代码如下：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">private</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">></span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//key: 节点值，value: 节点值出现的次数</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token comment">// 递归（前序遍历）</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">findMode</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token function">preorder</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token comment">// 对 map 的 value 进行降序排序</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">></span><span class="token punctuation">></span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        list<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">(</span>o1<span class="token punctuation">,</span> o2<span class="token punctuation">)</span> <span class="token operator">-></span> o2<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> o1<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token comment">// 找出最大的 value</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token keyword">int</span> max <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token comment">// 找出所有 value 等于 max 的 key</span></pre></td></tr><tr><td data-num="18"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">></span></span> entry <span class="token operator">:</span> list<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> max<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>                res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>entry<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>                <span class="token keyword">break</span><span class="token punctuation">;</span> <span class="token comment">// 因为 list 已经按 value 降序排序，所以一旦出现 value 不等于 max 的情况，就可以跳出循环</span></pre></td></tr><tr><td data-num="23"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="25"></td><td><pre></pre></td></tr><tr><td data-num="26"></td><td><pre>        <span class="token comment">// 将 list 转为数组</span></pre></td></tr><tr><td data-num="27"></td><td><pre>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>res<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> res<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>            arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> res<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="31"></td><td><pre>        <span class="token keyword">return</span> arr<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="33"></td><td><pre></pre></td></tr><tr><td data-num="34"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">preorder</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="35"></td><td><pre>        <span class="token comment">// 递归终止条件</span></pre></td></tr><tr><td data-num="36"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="37"></td><td><pre>        <span class="token comment">// 递归过程</span></pre></td></tr><tr><td data-num="38"></td><td><pre>        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">,</span> map<span class="token punctuation">.</span><span class="token function">getOrDefault</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 中</span></pre></td></tr><tr><td data-num="39"></td><td><pre>        <span class="token function">preorder</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 左</span></pre></td></tr><tr><td data-num="40"></td><td><pre>        <span class="token function">preorder</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 右</span></pre></td></tr><tr><td data-num="41"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="42"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20221221155616381.png" alt="image-20221221155616381"></p><h5 id="是二叉搜索树"><a class="anchor" href="#是二叉搜索树">#</a> 是二叉搜索树</h5><p><strong>既然是搜索树，它中序遍历就是有序的</strong>。</p><p><img data-src="https://img-blog.csdnimg.cn/20210204152758889.png" alt="501.二叉搜索树中的众数1"></p><p>中序遍历代码如下：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">void</span> <span class="token function">searchBST</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> cur<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>cur <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token function">searchBST</span><span class="token punctuation">(</span>cur<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// 左</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    （处理节点）                <span class="token comment">// 中</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token function">searchBST</span><span class="token punctuation">(</span>cur<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// 右</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">return</span> <span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>遍历有序数组的元素出现频率，从头遍历，那么<strong>一定是相邻两个元素作比较，然后就把出现频率最高的元素输出就可以了</strong>。</p><p>关键是在有序数组上的话，好搞，在树上怎么搞呢？</p><p>这就考察对树的操作了。</p><p>在 [530. 二叉搜索树的最小绝对差](#530. 二叉搜索树的最小绝对差) 中我们就使用了<strong> pre 指针和 cur 指针</strong>的技巧，这次又用上了。</p><p>弄一个指针指向前一个节点，这样每次 cur（当前节点）才能和 pre（前一个节点）作比较。</p><p>而且<strong>初始化的时候 pre = NULL，这样当 pre 为 NULL 时候，我们就知道这是比较的第一个元素</strong>。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">if</span> <span class="token punctuation">(</span>pre <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 第一个节点</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    count <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 频率为 1</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>pre<span class="token operator">-></span>val <span class="token operator">==</span> cur<span class="token operator">-></span>val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 与前一个节点数值相同</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    count<span class="token operator">++</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 与前一个节点数值不同</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    count <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>pre <span class="token operator">=</span> cur<span class="token punctuation">;</span> <span class="token comment">// 更新上一个节点</span></pre></td></tr></table></figure><p>此时又有问题了，因为要求最大频率的元素集合（注意是集合，不是一个元素，可以有多个众数），如果是数组上大家一般怎么办？</p><p>应该是<strong>先遍历一遍数组，找出最大频率（maxCount）</strong>，然后<strong>再重新遍历一遍数组把出现频率为 maxCount 的元素放进集合</strong>。（因为众数有多个）</p><p>这种方式遍历了两遍数组。</p><p>那么我们遍历两遍二叉搜索树，把众数集合算出来也是可以的。</p><p>但这里<strong>其实只需要遍历一次就可以找到所有的众数</strong>。</p><p>那么如何只遍历一遍呢？</p><p>如果 频率 count 等于 maxCount（最大频率），当然要把这个元素加入到结果集中（以下代码为 result 数组），代码如下：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> maxCount<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 如果和最大值相同，放进 result 中</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    result<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>cur<span class="token operator">-></span>val<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>是不是感觉这里有问题，result 怎么能轻易就把元素放进去了呢，万一，这个 maxCount 此时还不是真正最大频率呢。</p><p>所以下面要做如下操作：</p><p><strong>频率 count 大于 maxCount 的时候，不仅要更新 maxCount，而且要清空结果集</strong>（以下代码为 result 数组），因为结果集之前的元素都失效了。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">></span> maxCount<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 如果计数大于最大值</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    maxCount <span class="token operator">=</span> count<span class="token punctuation">;</span>   <span class="token comment">// 更新最大频率</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    result<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 很关键的一步，不要忘记清空 result，之前 result 里的元素都失效了</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    result<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>cur<span class="token operator">-></span>val<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>关键代码都讲完了，完整代码如下：（<strong>只需要遍历一遍二叉搜索树，就求出了众数的集合</strong>）</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">int</span> maxCount<span class="token punctuation">;</span><span class="token comment">// 众数出现的最大次数</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">int</span> count<span class="token punctuation">;</span> <span class="token comment">// 统计出现次数</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token class-name">TreeNode</span> pre<span class="token punctuation">;</span> <span class="token comment">// 记录前一个节点</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> resList<span class="token punctuation">;</span> <span class="token comment">// 众数列表</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token comment">// 递归（中序遍历），不适用额外空间，利用二叉搜索树的特性</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">inorder</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token comment">// 递归终止条件</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token comment">// 递归过程</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token function">inorder</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 左</span></pre></td></tr><tr><td data-num="14"></td><td><pre></pre></td></tr><tr><td data-num="15"></td><td><pre></pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token keyword">int</span> rootVal <span class="token operator">=</span> root<span class="token punctuation">.</span>val<span class="token punctuation">;</span> <span class="token comment">// 中</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>pre <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> rootVal <span class="token operator">!=</span> pre<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token comment">// 当前节点与前一个节点不相等</span></pre></td></tr><tr><td data-num="18"></td><td><pre>            count <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>        <span class="token keyword">else</span> <span class="token comment">// 当前节点与前一个节点相等</span></pre></td></tr><tr><td data-num="20"></td><td><pre>            count<span class="token operator">++</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre></pre></td></tr><tr><td data-num="22"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">></span> maxCount<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 更新</span></pre></td></tr><tr><td data-num="23"></td><td><pre>            resList<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 清空</span></pre></td></tr><tr><td data-num="24"></td><td><pre>            resList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>rootVal<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>            maxCount <span class="token operator">=</span> count<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> maxCount<span class="token punctuation">)</span> <span class="token comment">// 与最大次数相等</span></pre></td></tr><tr><td data-num="27"></td><td><pre>            resList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>rootVal<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre></pre></td></tr><tr><td data-num="29"></td><td><pre>        pre <span class="token operator">=</span> root<span class="token punctuation">;</span> <span class="token comment">// 更新前一个节点</span></pre></td></tr><tr><td data-num="30"></td><td><pre></pre></td></tr><tr><td data-num="31"></td><td><pre></pre></td></tr><tr><td data-num="32"></td><td><pre>        <span class="token function">inorder</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 右</span></pre></td></tr><tr><td data-num="33"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="34"></td><td><pre></pre></td></tr><tr><td data-num="35"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">findMode</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="36"></td><td><pre>        maxCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="37"></td><td><pre>        count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="38"></td><td><pre>        pre <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="39"></td><td><pre>        resList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="40"></td><td><pre></pre></td></tr><tr><td data-num="41"></td><td><pre>        <span class="token function">inorder</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="42"></td><td><pre></pre></td></tr><tr><td data-num="43"></td><td><pre>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>resList<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="44"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> resList<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="45"></td><td><pre>            res<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> resList<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="46"></td><td><pre>        <span class="token keyword">return</span> res<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="47"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="48"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20221221161215768.png" alt="image-20221221161215768"></p><h4 id="迭代-7"><a class="anchor" href="#迭代-7">#</a> 迭代</h4><p>只要<strong>把中序遍历转成迭代，中间节点的处理逻辑完全一样</strong>。</p><p>下面我给出其中的一种中序遍历的迭代法，其中间处理逻辑一点都没有变（我从递归法直接粘过来的代码，连注释都没改，哈哈）</p><p>代码如下：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 迭代（中序遍历），借助栈</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">findMode</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token keyword">int</span> maxCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">// 众数出现的最大次数</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 统计出现次数</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token class-name">TreeNode</span> pre <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// 记录前一个节点</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> resList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 众数列表</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TreeNode</span><span class="token punctuation">></span></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token class-name">TreeNode</span> cur <span class="token operator">=</span> root<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token keyword">while</span> <span class="token punctuation">(</span>cur <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>cur <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>                stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>                cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>left<span class="token punctuation">;</span> <span class="token comment">// 左</span></pre></td></tr><tr><td data-num="16"></td><td><pre>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>                cur <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 中</span></pre></td></tr><tr><td data-num="18"></td><td><pre>                <span class="token keyword">if</span> <span class="token punctuation">(</span>pre <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> cur<span class="token punctuation">.</span>val <span class="token operator">!=</span> pre<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token comment">// 当前节点与前一个节点不相等</span></pre></td></tr><tr><td data-num="19"></td><td><pre>                    count <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>                <span class="token keyword">else</span> <span class="token comment">// 当前节点与前一个节点相等</span></pre></td></tr><tr><td data-num="21"></td><td><pre>                    count<span class="token operator">++</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre></pre></td></tr><tr><td data-num="23"></td><td><pre>                <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">></span> maxCount<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 更新</span></pre></td></tr><tr><td data-num="24"></td><td><pre>                    maxCount <span class="token operator">=</span> count<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>                    resList<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 清空</span></pre></td></tr><tr><td data-num="26"></td><td><pre>                    resList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>                <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> maxCount<span class="token punctuation">)</span> <span class="token comment">// 与最大次数相等</span></pre></td></tr><tr><td data-num="28"></td><td><pre>                    resList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="29"></td><td><pre></pre></td></tr><tr><td data-num="30"></td><td><pre>                pre <span class="token operator">=</span> cur<span class="token punctuation">;</span> <span class="token comment">// 更新前一个节点</span></pre></td></tr><tr><td data-num="31"></td><td><pre></pre></td></tr><tr><td data-num="32"></td><td><pre>                cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>right<span class="token punctuation">;</span> <span class="token comment">// 右</span></pre></td></tr><tr><td data-num="33"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="34"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="35"></td><td><pre></pre></td></tr><tr><td data-num="36"></td><td><pre>        <span class="token keyword">return</span> resList<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">mapToInt</span><span class="token punctuation">(</span><span class="token class-name">Integer</span><span class="token operator">::</span><span class="token function">valueOf</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将列表 List 转为数组 []</span></pre></td></tr><tr><td data-num="37"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="38"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20221221162111746.png" alt="image-20221221162111746"></p><h4 id="总结-22"><a class="anchor" href="#总结-22">#</a> 总结</h4><p>本题在递归法中，我给出了如果是普通二叉树，应该怎么求众数。</p><p>知道了普通二叉树的做法时候，我再进一步给出二叉搜索树又应该怎么求众数，这样鲜明的对比，相信会对二叉树又有更深层次的理解了。</p><p>在递归遍历二叉搜索树的过程中，我还介绍了一个统计最高出现频率元素集合的技巧， 要不然就要遍历两次二叉搜索树才能把这个最高出现频率元素的集合求出来。</p><p><strong>为什么没有这个技巧一定要遍历两次呢？ 因为要求的是集合，会有多个众数，如果规定只有一个众数，那么就遍历一次稳稳的了。</strong></p><p>最后我依然给出对应的迭代法，其实就是<strong>迭代法中序遍历的模板加上递归法中中间节点的处理逻辑</strong>，分分钟就可以写出来，中间逻辑的代码我都是从递归法中直接粘过来的。</p><p><strong>求二叉搜索树中的众数其实是一道简单题，但大家可以发现我写了这么一大篇幅的文章来讲解，主要是为了尽量从各个角度对本题进剖析，帮助大家更快更深入理解二叉树</strong>。</p><blockquote><p><strong>需要强调的是 leetcode 上的耗时统计是非常不准确的，看个大概就行，一样的代码耗时可以差百分之 50 以上</strong>，所以 leetcode 的耗时统计别太当回事，知道理论上的效率优劣就行了。</p></blockquote><h3 id="236-二叉树的最近公共祖先"><a class="anchor" href="#236-二叉树的最近公共祖先">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sb3dlc3QtY29tbW9uLWFuY2VzdG9yLW9mLWEtYmluYXJ5LXRyZWUv">236. 二叉树的最近公共祖先</span></h3><blockquote><p>下一篇再谈二叉搜索树的最近公共祖先问题</p></blockquote><p>遇到这个题目首先想的是要是能自底向上查找就好了，这样就可以找到公共祖先了。</p><p>那么二叉树如何可以<strong>自底向上查找</strong>呢？</p><p><strong>回溯</strong>啊，二叉树回溯的过程就是从底到上。</p><p><strong>后序遍历（左右中）就是天然的回溯过程，可以根据左右子树的返回值，来处理中节点的逻辑</strong>。</p><p>接下来就看如何判断一个节点是节点 q 和节点 p 的公共祖先呢。</p><p><strong>首先最容易想到的一个情况：如果找到一个节点，发现左子树出现结点 p，右子树出现节点 q，或者 左子树出现结点 q，右子树出现节点 p，那么该节点就是节点 p 和 q 的最近公共祖先。</strong> 即情况一：</p><p><img data-src="https://code-thinking-1253855093.file.myqcloud.com/pics/20220922173502.png" alt="img"></p><p>判断逻辑是 如果递归遍历遇到 q，就将 q 返回，遇到 p 就将 p 返回，那么如果 左右子树的返回值都不为空，说明此时的中节点，一定是 q 和 p 的最近祖先。</p><p>那么有录友可能疑惑，会不会左子树 遇到 q 返回，右子树也遇到 q 返回，这样并没有找到 q 和 p 的最近祖先。</p><p>这么想的录友，要审题了，题目强调：<strong>二叉树节点数值是不重复的，而且一定存在 q 和 p</strong>。</p><p><strong>但是很多人容易忽略一个情况，就是节点本身 p (q)，它拥有一个子孙节点 q (p)。</strong> 情况二：</p><p><img data-src="https://code-thinking-1253855093.file.myqcloud.com/pics/20220922173530.png" alt="img"></p><p>其实情况一 和 情况二 代码实现过程都是一样的，也可以说，实现情况一的逻辑，顺便包含了情况二。</p><p>因为遇到 q 或者 p 就返回，这样也包含了 q 或者 p 本身就是 公共祖先的情况。</p><p>这一点是很多录友容易忽略的，在下面的代码讲解中，可以再去体会。</p><h4 id="递归后序遍历-4"><a class="anchor" href="#递归后序遍历-4">#</a> 递归（后序遍历）</h4><p>递归三部曲：</p><ol><li><p>参数、返回值：</p><p>需要递归函数返回值，来告诉我们是否找到节点 q 或者 p，那么返回值为 bool 类型就可以了。</p><p>但我们还要返回最近公共节点，可以利用上题目中返回值是 TreeNode * ，那么如果遇到 p 或者 q，就把 q 或者 p 返回，返回值不为空，就说明找到了 q 或者 p。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token class-name">TreeNode</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">,</span> <span class="token class-name">TreeNode</span> p<span class="token punctuation">,</span> <span class="token class-name">TreeNode</span> q<span class="token punctuation">)</span></pre></td></tr></table></figure></li><li><p>递归终止条件：</p><ul><li><p>遇到空的话，因为树都是空了，所以返回空。</p></li><li><p>如果 root == q，或者 root == p，说明找到 q p ，则将其返回，这个返回值，后面在中节点的处理过程中会用到，那么中节点的处理逻辑，下面讲解。</p></li></ul><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> p <span class="token operator">||</span> root <span class="token operator">==</span> q<span class="token punctuation">)</span> <span class="token keyword">return</span> root<span class="token punctuation">;</span></pre></td></tr></table></figure></li><li><p>单层递归的逻辑：</p><p>值得注意的是 本题<strong>函数有返回值</strong>，是因为回溯的过程需要递归函数的返回值做判断，但本题我们依然<strong>要遍历树的所有节点</strong>。</p><p>我们在 [☆112. 路径总和](#☆112. 路径总和) 中说了 递归函数有返回值就是要遍历某一条边，但有返回值也要看如何处理返回值！</p><p>如果递归函数有返回值，如何区分要搜索一条边，还是搜索整个树呢？</p><p>搜索一条边的写法：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">if</span> <span class="token punctuation">(</span>递归函数<span class="token punctuation">(</span>root<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">if</span> <span class="token punctuation">(</span>递归函数<span class="token punctuation">(</span>root<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">;</span></pre></td></tr></table></figure><p>搜索整个树写法：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>left <span class="token operator">=</span> 递归函数<span class="token punctuation">(</span>root<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 左</span></pre></td></tr><tr><td data-num="2"></td><td><pre>right <span class="token operator">=</span> 递归函数<span class="token punctuation">(</span>root<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 右</span></pre></td></tr><tr><td data-num="3"></td><td><pre>left与right的逻辑处理<span class="token punctuation">;</span>         <span class="token comment">// 中</span></pre></td></tr></table></figure><p>看出区别了没？</p><p><strong>在递归函数有返回值的情况下：</strong></p><ul><li><strong>如果要搜索一条边，递归函数返回值不为空的时候，立刻返回</strong></li><li><strong>如果搜索整个树，直接用一个变量 left、right 接住返回值，这个 left、right 后序还有逻辑处理的需要，也就是后序遍历中处理中间节点的逻辑（也是回溯）</strong>。</li></ul><p>那么为什么要遍历整棵树呢？直观上来看，找到最近公共祖先，直接一路返回就可以了。</p><p>如图：</p><p><img data-src="https://img-blog.csdnimg.cn/2021020415105872.png" alt="236.二叉树的最近公共祖先"></p><p>就像图中一样直接返回 7，多美滋滋。</p><p>但事实上还要遍历根节点右子树（即使此时已经找到了目标节点了），也就是图中的节点 4、15、20。</p><p>因为在如下代码的后序遍历中，如果想利用 left 和 right 做逻辑处理， 不能立刻返回，而是要等 left 与 right 逻辑处理完之后才能返回。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>left <span class="token operator">=</span> 递归函数<span class="token punctuation">(</span>root<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 左</span></pre></td></tr><tr><td data-num="2"></td><td><pre>right <span class="token operator">=</span> 递归函数<span class="token punctuation">(</span>root<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 右</span></pre></td></tr><tr><td data-num="3"></td><td><pre>left与right的逻辑处理<span class="token punctuation">;</span>         <span class="token comment">// 中</span></pre></td></tr></table></figure><p>所以此时大家要知道我们要遍历整棵树。知道这一点，对本题就有一定深度的理解了。</p><p>那么先用 left 和 right 接住左子树和右子树的返回值，代码如下：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">TreeNode</span> left <span class="token operator">=</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 左</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name">TreeNode</span> right <span class="token operator">=</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 右</span></pre></td></tr></table></figure><p><strong>如果 left 和 right 都不为空，说明此时 root 就是最近公共节点。这个比较好理解</strong></p><p><strong>如果 left 为空，right 不为空，就返回 right，说明目标节点是通过 right 返回的，反之依然</strong>。</p><p>这里有的同学就理解不了了，为什么 left 为空，right 不为空，目标节点通过 right 返回呢？</p><p>如图：</p><p><img data-src="https://img-blog.csdnimg.cn/20210204151125844.png" alt="236.二叉树的最近公共祖先1"></p><p>图中节点 10 的左子树返回 null，右子树返回目标值 7，那么此时节点 10 的处理逻辑就是把右子树的返回值（最近公共祖先 7）返回上去！</p><p>这里也很重要，可能刷过这道题目的同学，都不清楚结果究竟是如何从底层一层一层传到头结点的。</p><p>那么如果 left 和 right 都为空，则返回 left 或者 right 都是可以的，也就是返回空。</p><p>代码如下：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> right <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// 左右都为空，说明 p,q 都不在 root 的左右子树中</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> right <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> left<span class="token punctuation">;</span> <span class="token comment">// 左不为空，右为空，说明 p,q 都在 root 的左子树中</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> right<span class="token punctuation">;</span> <span class="token comment">// 左为空，右不为空，说明 p,q 都在 root 的右子树中</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">else</span> <span class="token keyword">return</span> root<span class="token punctuation">;</span> <span class="token comment">// 左右都不为空，说明 p,q 分别在 root 的左右子树中，root 为最近公共祖先</span></pre></td></tr></table></figure><p>那么寻找最小公共祖先，完整流程图如下：</p><p><img data-src="https://img-blog.csdnimg.cn/202102041512582.png" alt="236.二叉树的最近公共祖先2"></p><p><strong>从图中，大家可以看到，我们是如何回溯遍历整棵二叉树，将结果返回给头结点的！</strong></p></li></ol><p>整体的 java 代码如下：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 递归（后序遍历）</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">TreeNode</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">,</span> <span class="token class-name">TreeNode</span> p<span class="token punctuation">,</span> <span class="token class-name">TreeNode</span> q<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token comment">// 递归终止条件</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> p <span class="token operator">||</span> root <span class="token operator">==</span> q<span class="token punctuation">)</span> <span class="token keyword">return</span> root<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token comment">// 单层递归逻辑</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token class-name">TreeNode</span> left <span class="token operator">=</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 左</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token class-name">TreeNode</span> right <span class="token operator">=</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 右</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> right <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// 左右都为空，说明 p,q 都不在 root 的左右子树中</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> right <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> left<span class="token punctuation">;</span> <span class="token comment">// 左不为空，右为空，说明 p,q 都在 root 的左子树中</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> right<span class="token punctuation">;</span> <span class="token comment">// 左为空，右不为空，说明 p,q 都在 root 的右子树中</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token keyword">else</span> <span class="token keyword">return</span> root<span class="token punctuation">;</span> <span class="token comment">// 左右都不为空，说明 p,q 分别在 root 的左右子树中，root 为最近公共祖先</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20221223162738658.png" alt="image-20221223162738658"></p><h4 id="总结-23"><a class="anchor" href="#总结-23">#</a> 总结</h4><p>这道题目刷过的同学未必真正了解这里面回溯的过程，以及结果是如何一层一层传上去的。</p><p><strong>那么我给大家归纳如下三点</strong>：</p><ol><li>求最小公共祖先，需要从底向上遍历，那么二叉树，只能通过后序遍历（即：回溯）实现从底向上的遍历方式。</li><li>在回溯的过程中，必然要遍历整棵二叉树，即使已经找到结果了，依然要把其他节点遍历完，因为要使用递归函数的返回值（也就是代码中的 left 和 right）做逻辑判断。</li><li>要理解如果返回值 left 为空，right 不为空为什么要返回 right，为什么可以用返回 right 传给上一层结果。</li></ol><p>可以说这里每一步，都是有难度的，都需要对二叉树，递归和回溯有一定的理解。</p><p>本题没有给出迭代法，因为<strong>迭代法不适合模拟回溯的过程</strong>。理解递归的解法就够了。</p><h3 id="本周小结-4"><a class="anchor" href="#本周小结-4">#</a> 本周小结</h3><h4 id="周一-4"><a class="anchor" href="#周一-4">#</a> 周一</h4><p>在 [617. 合并二叉树](#617. 合并二叉树) 中讲解了如何合并两个二叉树，平时我们都习惯了操作一个二叉树，一起操作两个树可能还有点陌生。</p><blockquote><p>单层递归的逻辑：</p><ol><li><p>把两棵树的元素加到一起</p></li><li><p>t1 的左子树：合并 t1 左子树 t2 左子树之后的左子树</p></li><li><p>t1 的右子树：合并 t1 右子树 t2 右子树之后的右子树</p></li></ol></blockquote><p>其实套路是一样，只不过<strong>一起操作两个树的指针</strong>，我们之前讲过求 [101. 对称二叉树](#101. 对称二叉树) 的时候，已经初步涉及到了 一起遍历两棵二叉树了。</p><p><strong>迭代法中，一般一起操作两个树都是使用队列模拟类似层序遍历，同时处理两个树的节点，这种方式最好理解，如果用模拟递归的思路的话，要复杂一些。</strong></p><h4 id="周二-4"><a class="anchor" href="#周二-4">#</a> 周二</h4><p>周二开始讲解一个新的树，二叉搜索树，开始要换一个思路了，如果没有利用好<strong>二叉搜索树的特性</strong>，就容易把简单题做成了难题了。</p><p>学习 [700. 二叉搜索树中的搜索](#700. 二叉搜索树中的搜索)，还是比较容易的。</p><blockquote><p>单层递归逻辑：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">TreeNode</span> res <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>val <span class="token operator">></span> val<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    res <span class="token operator">=</span> <span class="token function">searchBST</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 左</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> val<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    res <span class="token operator">=</span> <span class="token function">searchBST</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 右</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">return</span> res<span class="token punctuation">;</span></pre></td></tr></table></figure></blockquote><p>大多是二叉搜索树的题目，其实都离不开<strong>中序遍历</strong>，因为这样就是有序的。</p><p>至于迭代法，相信大家看到文章中<strong>如此简单的迭代法</strong>的时候，都会感动的痛哭流涕。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20221223164410190.png" alt="image-20221223164410190"></p><h4 id="周三-4"><a class="anchor" href="#周三-4">#</a> 周三</h4><p>了解了二搜索树的特性之后， 开始验证 [98. 验证二叉搜索树](#98. 验证二叉搜索树)。</p><p>首先在此强调一下二叉搜索树的特性：</p><ul><li>节点的左子树只包含小于当前节点的数。</li><li>节点的右子树只包含大于当前节点的数。</li><li>所有左子树和右子树自身必须也是二叉搜索树。</li></ul><p>那么我们在验证二叉搜索树的时候，有两个陷阱：</p><ul><li>陷阱一</li></ul><p><strong>不能单纯的比较左节点小于中间节点，右节点大于中间节点就完事了</strong>，而是 **<mark> 左子树都小于中间节点，右子树都大于中间节点</mark> **。</p><ul><li>陷阱二</li></ul><p>在一个有序序列求最值的时候，不要定义一个全局遍历，然后遍历序列更新全局变量求最值。因为最值可能就是 int 或者 longlong 的最小值。</p><p>推荐要通过前一个数值（pre）和后一个数值比较（cur），得出最值。</p><p><strong>在二叉树中通过<mark>两个前后指针</mark>作比较，会经常用到</strong>。</p><p>本文 [98. 验证二叉搜索树](#98. 验证二叉搜索树) 中迭代法中为什么没有周一那篇那么简洁了呢，因为本篇是验证二叉搜索树，前提默认它是一棵普通二叉树，所以还是要回归之前老办法。</p><h4 id="周四-4"><a class="anchor" href="#周四-4">#</a> 周四</h4><p>了解了 [700. 二叉搜索树中的搜索](#700. 二叉搜索树中的搜索)，并且知道 [98. 验证二叉搜索树](#98. 验证二叉搜索树)，本篇就很简单了。</p><p><strong>要知道<mark>二叉搜索树和中序遍历是好朋友</mark>！</strong></p><p>在 [530. 二叉搜索树的最小绝对差](#530. 二叉搜索树的最小绝对差) 中强调了要利用搜索树的特性，把这道题目想象成在一个有序数组上求两个数最小差值，这就是一道送分题了。</p><p><strong>需要明确：<mark>在有序数组求任意两数最小值差等价于相邻两数的最小值差</mark></strong>。</p><p>同样本题也需要用 pre 节点记录 cur 节点的前一个节点。（这种写法一定要掌握）</p><h4 id="周五-4"><a class="anchor" href="#周五-4">#</a> 周五</h4><p>此时大家应该知道遇到二叉搜索树，就想是有序数组，那么在二叉搜索树中求二叉搜索树众数就很简单了。</p><p>在 [501. 二叉搜索树中的众数](#501. 二叉搜索树中的众数) 中我给出了如果是普通二叉树，应该如何求众数的集合，然后进一步讲解了二叉搜索树应该如何求众数集合。</p><p>在求众数集合的时候有一个技巧，因为题目中众数是可以有多个的，所以一般的方法需要遍历两遍才能求出众数的集合。</p><p><strong>但可以遍历一遍就可以求众数集合，使用了适时清空结果集的方法</strong>，这个方法还是很巧妙的。相信仔细读了文章的同学会惊呼其巧妙！</p><p><strong>所以大家不要看题目简单了，就不动手做了，我选的题目，一般不会简单到不用动手的程度，哈哈</strong>。</p><h4 id="周六-4"><a class="anchor" href="#周六-4">#</a> 周六</h4><p>在 [236. 二叉树的最近公共祖先](#236. 二叉树的最近公共祖先) 中，我们开始讲解如何在二叉树中求公共祖先的问题，本来是打算和二叉搜索树一起讲的，但发现篇幅过长，所以先讲二叉树的公共祖先问题。</p><p><strong>如果找到一个节点，发现左子树出现结点 p，右子树出现节点 q，或者 左子树出现结点 q，右子树出现节点 p，那么该节点就是节点 p 和 q 的最近公共祖先。</strong></p><p>这道题目的看代码比较简单，而且好像也挺好理解的，但是如果把每一个细节理解到位，还是不容易的。</p><p>主要思考如下几点：</p><ul><li>如何从底向上遍历？</li><li>遍历整棵树，还是遍历局部树？</li><li>如何把结果传到根节点的？</li></ul><p>这些问题都需要弄清楚，上来直接看代码的话，是可能想不到这些细节的。</p><p>公共祖先问题，还是有难度的，初学者还是需要慢慢消化！</p><h4 id="小结-6"><a class="anchor" href="#小结-6">#</a> 小结</h4><p>本周我们讲了 [617. 合并二叉树](#617. 合并二叉树)，了解了如何操作两个二叉树。</p><p>然后开始另一种树：二叉搜索树，了解 [700. 二叉搜索树中的搜索](#700. 二叉搜索树中的搜索)，然后 [98. 验证二叉搜索树](#98. 验证二叉搜索树)。</p><p>了解以上知识之后，就开始利用其特性，做一些二叉搜索树上的题目，[530. 二叉搜索树的最小绝对差](#530. 二叉搜索树的最小绝对差)，[501. 二叉搜索树中的众数](#501. 二叉搜索树中的众数)。</p><p>接下来，开始求二叉树与二叉搜索树的公共祖先问题，单篇篇幅原因，先单独介绍 [236. 二叉树的最近公共祖先](#236. 二叉树的最近公共祖先)。</p><p>现在已经讲过了几种二叉树了，二叉树，二叉平衡树，完全二叉树，二叉搜索树，后面还会有平衡二叉搜索树。 那么一些同学难免会有混乱了，我针对如下三个问题，帮大家在捋顺一遍：</p><ol><li>平衡二叉搜索树是不是二叉搜索树和平衡二叉树的结合？</li></ol><p>是的，是二叉搜索树和平衡二叉树的结合。</p><ol start="2"><li>平衡二叉树与完全二叉树的区别在于底层节点的位置？</li></ol><p>是的，完全二叉树底层必须是从左到右连续的，且次底层是满的。</p><ol start="3"><li>堆是完全二叉树和排序的结合，而不是平衡二叉搜索树？</li></ol><p><strong>堆是一棵完全二叉树，同时保证父子节点的顺序关系（有序）</strong>。 <strong>但完全二叉树一定是平衡二叉树，堆的排序是父节点大于子节点，而搜索树是父节点大于左孩子，小于右孩子，所以堆不是平衡二叉搜索树</strong>。</p><h3 id="235-二叉搜索树的最近公共祖先"><a class="anchor" href="#235-二叉搜索树的最近公共祖先">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sb3dlc3QtY29tbW9uLWFuY2VzdG9yLW9mLWEtYmluYXJ5LXNlYXJjaC10cmVlLw==">235. 二叉搜索树的最近公共祖先</span></h3><p>做过 [236. 二叉树的最近公共祖先](#236. 二叉树的最近公共祖先) 题目的同学应该知道，利用回溯从底向上搜索，遇到一个节点的左子树里有 p，右子树里有 q，那么当前节点就是最近公共祖先。</p><p>那么本题是二叉搜索树，二叉搜索树是有序的，那得好好利用一下这个特点。</p><p>在有序树里，如果判断一个节点的左子树里有 p，右子树里有 q 呢？</p><p>因为是有序树，所有 如果 中间节点是 q 和 p 的公共祖先，那么 中节点的数组 一定是在 [p, q] 区间的。即 中节点 &gt; p &amp;&amp; 中节点 &lt; q 或者 中节点 &gt; q &amp;&amp; 中节点 &lt; p。</p><p>那么<strong>只要从上到下去遍历，遇到 cur 节点是数值在 [p, q] 区间中则一定可以说明该节点 cur 就是 q 和 p 的公共祖先</strong>。 那问题来了，<strong>一定是最近公共祖先吗</strong>？</p><p>如图，我们从根节点搜索，第一次遇到 cur 节点是数值在 [p, q] 区间中，即 节点 5，此时可以说明 p 和 q 一定分别存在于 节点 5 的左子树，和右子树中。</p><p><img data-src="https://code-thinking-1253855093.file.myqcloud.com/pics/20220926164214.png" alt="235.二叉搜索树的最近公共祖先"></p><p>此时节点 5 是不是最近公共祖先？ 如果 从节点 5 继续向左遍历，那么将错过成为 q 的祖先， 如果从节点 5 继续向右遍历则错过成为 p 的祖先。</p><p>所以 **<mark> 当我们从上向下去递归遍历，第一次遇到 cur 节点是数值在 [p, q] 区间中，那么 cur 就是 p 和 q 的最近公共祖先</mark> **。</p><p>理解这一点，本题就很好解了。</p><p>而递归遍历顺序，本题就不涉及到 前中后序了（这里<strong>没有中节点的处理逻辑，遍历顺序无所谓</strong>了）。</p><p>如图所示：p 为节点 6，q 为节点 9</p><p><img data-src="https://code-thinking-1253855093.file.myqcloud.com/pics/20220926165141.png" alt="235.二叉搜索树的最近公共祖先2"></p><p>可以看出直接按照指定的方向，就可以找到节点 8，为最近公共祖先，而且不需要遍历整棵树，找到结果直接返回！</p><h4 id="递归-10"><a class="anchor" href="#递归-10">#</a> 递归</h4><p>递归三部曲：</p><ol><li><p>参数、返回值：</p><ul><li><p>参数就是当前节点，以及两个结点 p、q</p></li><li><p>返回值是要返回最近公共祖先，所以是 TreeNode</p></li></ul><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token class-name">TreeNode</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">,</span> <span class="token class-name">TreeNode</span> p<span class="token punctuation">,</span> <span class="token class-name">TreeNode</span> q<span class="token punctuation">)</span></pre></td></tr></table></figure></li><li><p>递归终止条件：</p><p>遇到空返回就可以了。</p><p>其实都不需要这个终止条件，因为题目中说了 p、q 为不同节点且均存在于给定的二叉搜索树中。也就是说一定会找到公共祖先的，所以并不存在遇到空的情况。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span></pre></td></tr></table></figure></li><li><p>单层递归的逻辑：</p><p>在遍历二叉搜索树的时候就是寻找区间 [p-&gt;val, q-&gt;val]（注意这里是左闭又闭）</p><ul><li>那么如果 cur-&gt;val 大于 p-&gt;val，同时 cur-&gt;val 大于 q-&gt;val，那么就应该向左遍历（说明目标区间在左子树上）。</li></ul><p><strong>需要注意的是此时不知道 p 和 q 谁大，所以两个都要判断</strong></p><p>代码如下：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">if</span> <span class="token punctuation">(</span>cur<span class="token operator">-></span>val <span class="token operator">></span> p<span class="token operator">-></span>val <span class="token operator">&amp;&amp;</span> cur<span class="token operator">-></span>val <span class="token operator">></span> q<span class="token operator">-></span>val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    TreeNode<span class="token operator">*</span> left <span class="token operator">=</span> <span class="token function">traversal</span><span class="token punctuation">(</span>cur<span class="token operator">-></span>left<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token keyword">return</span> left<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><strong>细心的同学会发现，在这里调用递归函数的地方，把递归函数的返回值 left，直接 return</strong>。</p><p>在 [236. 二叉树的最近公共祖先](#236. 二叉树的最近公共祖先) 中，如果递归函数有返回值，如何区分要搜索一条边，还是搜索整个树。</p><p>搜索一条边的写法：</p><figure class="highlight text"><figcaption data-lang="text"></figcaption><table><tr><td data-num="1"></td><td><pre>if (递归函数(root->left)) return ;</pre></td></tr><tr><td data-num="2"></td><td><pre>if (递归函数(root->right)) return ;</pre></td></tr></table></figure><p>搜索整个树写法：</p><figure class="highlight text"><figcaption data-lang="text"></figcaption><table><tr><td data-num="1"></td><td><pre>left = 递归函数(root->left);</pre></td></tr><tr><td data-num="2"></td><td><pre>right = 递归函数(root->right);</pre></td></tr><tr><td data-num="3"></td><td><pre>left与right的逻辑处理;</pre></td></tr></table></figure><p>本题就是标准的搜索一条边的写法，遇到递归函数的返回值，如果不为空，立刻返回。</p><ul><li>如果 cur-&gt;val 小于 p-&gt;val，同时 cur-&gt;val 小于 q-&gt;val，那么就应该向右遍历（目标区间在右子树）。</li></ul><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">if</span> <span class="token punctuation">(</span>cur<span class="token operator">-></span>val <span class="token operator">&lt;</span> p<span class="token operator">-></span>val <span class="token operator">&amp;&amp;</span> cur<span class="token operator">-></span>val <span class="token operator">&lt;</span> q<span class="token operator">-></span>val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    TreeNode<span class="token operator">*</span> right <span class="token operator">=</span> <span class="token function">traversal</span><span class="token punctuation">(</span>cur<span class="token operator">-></span>right<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>right <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token keyword">return</span> right<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><ul><li>剩下的情况，就是 cur 节点在区间（p-&gt;val &lt;= cur-&gt;val &amp;&amp; cur-&gt;val &lt;= q-&gt;val）或者 （q-&gt;val &lt;= cur-&gt;val &amp;&amp; cur-&gt;val &lt;= p-&gt;val）中，那么 cur 就是最近公共祖先了，直接返回 cur。</li></ul><p>代码如下：</p><figure class="highlight text"><figcaption data-lang="text"></figcaption><table><tr><td data-num="1"></td><td><pre>return cur;</pre></td></tr></table></figure></li></ol><p>整体的 java 代码如下：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 递归</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">TreeNode</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">,</span> <span class="token class-name">TreeNode</span> p<span class="token punctuation">,</span> <span class="token class-name">TreeNode</span> q<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token comment">// 递归终止条件</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token comment">// 单层递归的逻辑</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>val <span class="token operator">></span> p<span class="token punctuation">.</span>val <span class="token operator">&amp;&amp;</span> root<span class="token punctuation">.</span>val <span class="token operator">></span> q<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">//p,q 都在左子树</span></pre></td></tr><tr><td data-num="8"></td><td><pre>            <span class="token class-name">TreeNode</span> left <span class="token operator">=</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> left<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> p<span class="token punctuation">.</span>val <span class="token operator">&amp;&amp;</span> root<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> q<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">//p,q 都在右子树</span></pre></td></tr><tr><td data-num="12"></td><td><pre>            <span class="token class-name">TreeNode</span> right <span class="token operator">=</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> right<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token comment">//p,q 分别在左右子树</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token keyword">return</span> root<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20221223174926353.png" alt="image-20221223174926353"></p><p>化简后的代码如下：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 递归</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">TreeNode</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">,</span> <span class="token class-name">TreeNode</span> p<span class="token punctuation">,</span> <span class="token class-name">TreeNode</span> q<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token comment">// 递归终止条件</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token comment">// 单层递归的逻辑</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>val <span class="token operator">></span> p<span class="token punctuation">.</span>val <span class="token operator">&amp;&amp;</span> root<span class="token punctuation">.</span>val <span class="token operator">></span> q<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">//p,q 都在左子树</span></pre></td></tr><tr><td data-num="8"></td><td><pre>            <span class="token keyword">return</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> p<span class="token punctuation">.</span>val <span class="token operator">&amp;&amp;</span> root<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> q<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">//p,q 都在右子树</span></pre></td></tr><tr><td data-num="10"></td><td><pre>            <span class="token keyword">return</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span> <span class="token comment">//p,q 分别在左右子树</span></pre></td></tr><tr><td data-num="12"></td><td><pre>            <span class="token keyword">return</span> root<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h4 id="迭代-8"><a class="anchor" href="#迭代-8">#</a> 迭代</h4><p>对于二叉搜索树的迭代法，大家应该在 [700. 二叉搜索树中的搜索](#700. 二叉搜索树中的搜索) 就了解了。</p><p><strong>利用其有序性，迭代的方式还是比较简单的</strong>，解题思路在递归中已经分析了。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 迭代</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">TreeNode</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">,</span> <span class="token class-name">TreeNode</span> p<span class="token punctuation">,</span> <span class="token class-name">TreeNode</span> q<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token keyword">while</span> <span class="token punctuation">(</span>root <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>val <span class="token operator">></span> p<span class="token punctuation">.</span>val <span class="token operator">&amp;&amp;</span> root<span class="token punctuation">.</span>val <span class="token operator">></span> q<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">//p,q 都在左子树</span></pre></td></tr><tr><td data-num="6"></td><td><pre>                root <span class="token operator">=</span> root<span class="token punctuation">.</span>left<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> p<span class="token punctuation">.</span>val <span class="token operator">&amp;&amp;</span> root<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> q<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">//p,q 都在右子树</span></pre></td></tr><tr><td data-num="8"></td><td><pre>                root <span class="token operator">=</span> root<span class="token punctuation">.</span>right<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span> <span class="token comment">//p,q 分别在左右子树</span></pre></td></tr><tr><td data-num="10"></td><td><pre>                <span class="token keyword">return</span> root<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// 不存在</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>灵魂拷问：是不是又被简单的迭代法感动到痛哭流涕？</p><h4 id="小结-7"><a class="anchor" href="#小结-7">#</a> 小结</h4><p>对于二叉搜索树的最近祖先问题，其实要比 [236. 二叉树的最近公共祖先](#236. 二叉树的最近公共祖先) 简单的多。</p><p><strong>不用使用回溯，二叉搜索树自带方向性，可以方便的从上向下查找目标区间，遇到目标区间内的节点，直接返回</strong>。</p><p>最后给出了对应的迭代法，<strong>二叉搜索树的迭代法甚至比递归更容易理解，也是因为其有序性（自带方向性），按照目标区间找就行了</strong>。</p><h3 id="701-二叉搜索树中的插入操作"><a class="anchor" href="#701-二叉搜索树中的插入操作">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9pbnNlcnQtaW50by1hLWJpbmFyeS1zZWFyY2gtdHJlZS8=">701. 二叉搜索树中的插入操作</span></h3><p>这道题目其实是一道简单题目，<strong>但是题目中的提示：有多种有效的插入方式，还可以重构二叉搜索树，一下子吓退了不少人</strong>，瞬间感觉题目复杂了很多。</p><p>其实<strong>可以不考虑题目中提示所说的改变树的结构的插入方式。</strong></p><p>如下演示视频中可以看出：只要 **<mark> 按照二叉搜索树的规则去遍历，遇到空节点就插入节点</mark> ** 就可以了。</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/701.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C.gif" alt="701.二叉搜索树中的插入操作"></p><p>例如插入元素 10 ，需要找到末尾节点插入便可，一样的道理来插入元素 15，插入元素 0，插入元素 6，<strong>需要调整二叉树的结构么？ 并不需要。</strong></p><h4 id="递归-11"><a class="anchor" href="#递归-11">#</a> √递归</h4><p>递归三部曲：</p><ol><li><p>参数、返回值：</p><p>参数就是根节点指针，以及要插入元素，这里递归函数要不要有返回值呢？</p><p>可以有，也可以没有，但递归函数如果没有返回值的话，实现是比较麻烦的，下面也会给出其具体实现代码。</p><p><strong>有返回值的话，可以利用返回值完成新加入的节点与其父节点的赋值操作</strong>。（下面会进一步解释）</p><p>递归函数的返回类型为节点类型 TreeNode * 。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token class-name">TreeNode</span> <span class="token function">insertIntoBST</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span></pre></td></tr></table></figure></li><li><p>递归终止条件：</p><p>终止条件就是找到遍历的节点为 null 的时候，就是要插入节点的位置了，并把插入的节点返回。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>这里把添加的节点返回给上一层，就完成了父子节点的赋值操作了，详细再往下看。</p></li><li><p>单层递归的逻辑：</p><p>此时要明确，需要遍历整棵树么？</p><p>别忘了这是搜索树，<strong>遍历整棵搜索树简直是对搜索树的侮辱</strong>，哈哈。</p><p>搜索树是有方向了，可以根据插入元素的数值，决定递归方向。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>val <span class="token operator">></span> val<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    root<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">insertIntoBST</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> val<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    root<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">insertIntoBST</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">return</span> root<span class="token punctuation">;</span></pre></td></tr></table></figure><p><strong>到这里，大家应该能感受到，如何通过递归函数返回值完成了新加入节点的父子关系赋值操作了，下一层将加入节点返回，本层用 root-&gt;left 或者 root-&gt;right 将其接住</strong>。</p></li></ol><p>完整的 java 代码如下：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 递归</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">TreeNode</span> <span class="token function">insertIntoBST</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token comment">// 递归终止条件</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token comment">// 递归过程</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>val <span class="token operator">></span> val<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="10"></td><td><pre>            root<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">insertIntoBST</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> val<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="12"></td><td><pre>            root<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">insertIntoBST</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token keyword">return</span> root<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20221223222829962.png" alt="image-20221223222829962"></p><h4 id="迭代前-后双指针"><a class="anchor" href="#迭代前-后双指针">#</a> 迭代（前、后双指针）</h4><p>再来看看迭代法，对二叉搜索树迭代写法不熟悉，可以看这篇：[700. 二叉搜索树中的搜索](#700. 二叉搜索树中的搜索)</p><p>在迭代法遍历的过程中，<strong>需要记录一下当前遍历的节点的父节点，这样才能做插入节点的操作</strong>。</p><p>在 [530. 二叉搜索树的最小绝对差](#530. 二叉搜索树的最小绝对差) 和 [501. 二叉搜索树中的众数](#501. 二叉搜索树中的众数) 中，都是用了 **<mark> 记录 pre 和 cur 两个指针</mark> ** 的技巧，本题也是一样的。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 迭代</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">TreeNode</span> <span class="token function">insertIntoBST</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token class-name">TreeNode</span> cur <span class="token operator">=</span> root<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token class-name">TreeNode</span> pre <span class="token operator">=</span> root<span class="token punctuation">;</span> <span class="token comment">// 记录父节点，否则无法插入</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token keyword">while</span> <span class="token punctuation">(</span>cur <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>            pre <span class="token operator">=</span> cur<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>cur<span class="token punctuation">.</span>val <span class="token operator">></span> val<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="12"></td><td><pre>                cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>left<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>            <span class="token keyword">else</span></pre></td></tr><tr><td data-num="14"></td><td><pre>                cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>right<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token punctuation">&#125;</span> <span class="token comment">// 此时 cur 为 null，pre 指向要插入的位置。这就是 pre 的意义！</span></pre></td></tr><tr><td data-num="16"></td><td><pre></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token class-name">TreeNode</span> node <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 新节点</span></pre></td></tr><tr><td data-num="18"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>pre<span class="token punctuation">.</span>val <span class="token operator">></span> val<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="19"></td><td><pre>            pre<span class="token punctuation">.</span>left <span class="token operator">=</span> node<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>        <span class="token keyword">else</span></pre></td></tr><tr><td data-num="21"></td><td><pre>            pre<span class="token punctuation">.</span>right <span class="token operator">=</span> node<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre></pre></td></tr><tr><td data-num="23"></td><td><pre>        <span class="token keyword">return</span> root<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="25"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20221223222816002.png" alt="image-20221223222816002"></p><h4 id="总结-24"><a class="anchor" href="#总结-24">#</a> 总结</h4><p>首先在二叉搜索树中的插入操作，大家不用恐惧其重构搜索树，其实根本不用重构。</p><p>然后在递归中，我们重点讲了如何<strong>通过<u>递归函数的返回值</u>完成新加入节点和其父节点的赋值操作</strong>，并强调了搜索树的有序性。</p><p>最后依然给出了迭代的方法，<strong>迭代的方法就需要记录当前遍历节点的父节点了</strong>，这个和没有返回值的递归函数实现的代码逻辑是一样的。</p><h3 id="450-删除二叉搜索树中的节点"><a class="anchor" href="#450-删除二叉搜索树中的节点">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9kZWxldGUtbm9kZS1pbi1hLWJzdC8=">450. 删除二叉搜索树中的节点</span></h3><blockquote><p>BST 删除节点就涉及到<strong>结构调整</strong>了</p></blockquote><p><strong>搜索树的节点删除要比节点增加复杂的多</strong>，有很多情况需要考虑，做好心理准备。</p><h4 id="递归-12"><a class="anchor" href="#递归-12">#</a> 递归</h4><p>递归三部曲：</p><ol><li><p>参数、返回值：</p><p>说到递归函数的返回值，在 [701. 二叉搜索树中的插入操作](#701. 二叉搜索树中的插入操作) 中通过递归返回值来加入新节点， 这里也可以通过递归返回值删除节点。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token class-name">TreeNode</span> <span class="token function">deleteNode</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">,</span> <span class="token keyword">int</span> key<span class="token punctuation">)</span></pre></td></tr></table></figure></li><li><p>递归终止条件：</p><p>遇到空返回，其实这也说明没找到删除的节点，遍历到空节点直接返回了</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span></pre></td></tr></table></figure></li><li><p>单层递归的逻辑：</p><p>这里就把二叉搜索树中删除节点遇到的情况都搞清楚。</p><p><strong>有以下五种情况：</strong></p><ul><li><p><strong>第一种情况：没找到删除的节点，遍历到空节点直接返回了</strong></p><blockquote><p>递归终止条件</p></blockquote></li><li><p><strong>找到删除的节点</strong></p><ul><li><strong>第二种情况：左右孩子都为空（叶子节点），直接删除节点， 返回 NULL 为根节点</strong></li><li><strong>第三种情况：删除节点的左孩子为空，右孩子不为空，删除节点，右孩子补位，返回右孩子为根节点</strong></li><li><strong>第四种情况：删除节点的右孩子为空，左孩子不为空，删除节点，左孩子补位，返回左孩子为根节点</strong></li><li><strong>第五种情况：左右孩子节点都不为空，则将删除节点的左子树头结点（左孩子）放到删除节点的右子树的最左面节点的左孩子上，返回删除节点右孩子为新的根节点</strong></li></ul></li></ul><p>第五种情况有点难以理解，看下面动画：</p><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/450.%25E5%2588%25A0%25E9%2599%25A4%25E4%25BA%258C%25E5%258F%2589%25E6%2590%259C%25E7%25B4%25A2%25E6%25A0%2591%25E4%25B8%25AD%25E7%259A%2584%25E8%258A%2582%25E7%2582%25B9.gif" alt="450.删除二叉搜索树中的节点"></p><p>动画中的二叉搜索树中，删除元素 7， 那么删除节点（元素 7）的左孩子就是 5，删除节点（元素 7）的右子树的最左面节点是元素 8。</p><p>将删除节点（元素 7）的左孩子放到删除节点（元素 7）的右子树的最左面节点（元素 8）的左孩子上，就是把 5 为根节点的子树移到了 8 的左孩子的位置。</p><p>要删除的节点（元素 7）的右孩子（元素 9）为新的根节点。.</p><p>这样就完成删除元素 7 的逻辑，最好动手画一个图，尝试删除一个节点试试。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>val <span class="token operator">==</span> key<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 找到了要删除的 key</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 情况 2：key 是叶子节点，直接删除，返回 null 为根节点</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>left <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> root<span class="token punctuation">.</span>right <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token comment">// 情况 3：key 的左孩子为空，右孩子不为空，删除节点，右孩子补位，直接返回右子树为根节点</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>left <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> root<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> root<span class="token punctuation">.</span>right<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token comment">// 情况 4：key 的右孩子为空，左孩子不为空，删除节点，左孩子补位，直接返回左子树为根节点</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> root<span class="token punctuation">.</span>right <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> root<span class="token punctuation">.</span>left<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token comment">// 情况 5：key 的左右孩子均不为空，将 key 的左子树接到 key 的右子树的最左节点的左孩子上，并返回 key 的右孩子为根节点</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">else</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token class-name">TreeNode</span> cur <span class="token operator">=</span> root<span class="token punctuation">.</span>right<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token keyword">while</span> <span class="token punctuation">(</span>cur<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="12"></td><td><pre>            cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>left<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        cur<span class="token punctuation">.</span>left <span class="token operator">=</span> root<span class="token punctuation">.</span>left<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token keyword">return</span> root<span class="token punctuation">.</span>right<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>这里相当于把新的节点返回给上一层，上一层就要用 root-&gt;left 或者 root-&gt;right 接住，代码如下：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>val <span class="token operator">></span> key<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    root<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">deleteNode</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> key<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    root<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">deleteNode</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">return</span> root<span class="token punctuation">;</span></pre></td></tr></table></figure></li></ol><p>整体的 java 代码如下：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 递归</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">TreeNode</span> <span class="token function">deleteNode</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">,</span> <span class="token keyword">int</span> key<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token comment">// 递归终止条件</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// 情况 1：未找到 key</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token comment">// 单层递归逻辑</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>val <span class="token operator">==</span> key<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 找到了要删除的 key</span></pre></td></tr><tr><td data-num="8"></td><td><pre>            <span class="token comment">// 情况 2：key 是叶子节点，直接删除，返回 null 为根节点</span></pre></td></tr><tr><td data-num="9"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>left <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> root<span class="token punctuation">.</span>right <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>                <span class="token comment">// 情况 3：key 的左孩子为空，右孩子不为空，删除节点，右孩子补位，直接返回右子树为根节点</span></pre></td></tr><tr><td data-num="11"></td><td><pre>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>left <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> root<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> root<span class="token punctuation">.</span>right<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>                <span class="token comment">// 情况 4：key 的右孩子为空，左孩子不为空，删除节点，左孩子补位，直接返回左子树为根节点</span></pre></td></tr><tr><td data-num="13"></td><td><pre>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> root<span class="token punctuation">.</span>right <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> root<span class="token punctuation">.</span>left<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>                <span class="token comment">// 情况 5：key 的左右孩子均不为空，将 key 的左子树接到 key 的右子树的最左节点的左孩子上，并返回 key 的右孩子为根节点</span></pre></td></tr><tr><td data-num="15"></td><td><pre>            <span class="token keyword">else</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>                <span class="token class-name">TreeNode</span> cur <span class="token operator">=</span> root<span class="token punctuation">.</span>right<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>                <span class="token keyword">while</span> <span class="token punctuation">(</span>cur<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="18"></td><td><pre>                    cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>left<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>                cur<span class="token punctuation">.</span>left <span class="token operator">=</span> root<span class="token punctuation">.</span>left<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>                <span class="token keyword">return</span> root<span class="token punctuation">.</span>right<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>val <span class="token operator">></span> key<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="24"></td><td><pre>            root<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">deleteNode</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> key<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="26"></td><td><pre>            root<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">deleteNode</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>        <span class="token keyword">return</span> root<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="29"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20221224143724871.png" alt="image-20221224143724871"></p><h4 id="总结-25"><a class="anchor" href="#总结-25">#</a> 总结</h4><p>读完本篇，大家会发现二叉搜索树删除节点比增加节点复杂的多。</p><p><strong>因为二叉搜索树添加节点只需要在叶子上添加就可以的，不涉及到结构的调整，而删除节点操作涉及到结构的调整</strong>。</p><p>这里我们依然<strong>使用<u>递归函数的返回值</u>来完成把节点从二叉树中移除的操作</strong>。</p><p><strong>这里最关键的逻辑就是第五种情况（删除一个左右孩子都不为空的节点），这种情况一定要想清楚</strong>。</p><p>而且就算想清楚了，对应的代码也未必可以写出来，所以<strong>这道题目既考察思维逻辑，也考察代码能力</strong>。</p><p>递归中我给出了两种写法，推荐大家学会第一种（利用搜索树的特性）就可以了，第二种递归写法其实是比较绕的。</p><p>最后我也给出了相应的迭代法，就是模拟递归法中的逻辑来删除节点，但需要一个 pre 记录 cur 的父节点，方便做删除操作。</p><p>迭代法其实不太容易写出来，所以如果是初学者的话，彻底掌握第一种递归写法就够了。</p><h3 id="669-修剪二叉搜索树"><a class="anchor" href="#669-修剪二叉搜索树">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy90cmltLWEtYmluYXJ5LXNlYXJjaC10cmVlLw==">669. 修剪二叉搜索树</span></h3><blockquote><p>如果不对递归有深刻的理解，本题有点难 单纯移除一个节点那还不够，要修剪！</p></blockquote><p>相信看到这道题目大家都感觉是一道简单题，但还真的不简单！</p><h4 id="递归-13"><a class="anchor" href="#递归-13">#</a> 递归</h4><h5 id="误区"><a class="anchor" href="#误区">#</a> 误区</h5><p>直接想法就是：递归处理，然后遇到 <code>root-&gt;val &lt; low || root-&gt;val &gt; high</code> 的时候直接 return NULL，一波修改，赶紧利落。</p><p>不难写出如下代码：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    TreeNode<span class="token operator">*</span> <span class="token function">trimBST</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">,</span> <span class="token keyword">int</span> low<span class="token punctuation">,</span> <span class="token keyword">int</span> high<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">nullptr</span> <span class="token operator">||</span> root<span class="token operator">-></span>val <span class="token operator">&lt;</span> low <span class="token operator">||</span> root<span class="token operator">-></span>val <span class="token operator">></span> high<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span> <span class="token comment">// 这一步不对！</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        root<span class="token operator">-></span>left <span class="token operator">=</span> <span class="token function">trimBST</span><span class="token punctuation">(</span>root<span class="token operator">-></span>left<span class="token punctuation">,</span> low<span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        root<span class="token operator">-></span>right <span class="token operator">=</span> <span class="token function">trimBST</span><span class="token punctuation">(</span>root<span class="token operator">-></span>right<span class="token punctuation">,</span> low<span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token keyword">return</span> root<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p><strong>然而 [1, 3] 区间在二叉搜索树的中可不是单纯的节点 3 和左孩子节点 0 就决定的，还要考虑节点 0 的右子树</strong>。</p><p>我们在重新关注一下第二个示例，如图：</p><p><img data-src="https://img-blog.csdnimg.cn/20210204155302751.png" alt="669.修剪二叉搜索树"></p><p><strong>所以以上的代码是不可行的！</strong></p><h5 id="正确思路"><a class="anchor" href="#正确思路">#</a> 正确思路</h5><p>递归三部曲：</p><ol><li><p>参数、返回值：</p><p>这里我们为什么需要返回值呢？</p><p>因为是要遍历整棵树，做修改，其实不需要返回值也可以，我们也可以完成修剪（其实就是从二叉树中移除节点）的操作。</p><p>但是有返回值，更方便，<strong>可以通过递归函数的返回值来移除节点</strong>。</p><p>这样的做法在 [701. 二叉搜索树中的插入操作](#701. 二叉搜索树中的插入操作) 和 [450. 删除二叉搜索树中的节点](#450. 删除二叉搜索树中的节点) 中大家已经了解过了。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token class-name">TreeNode</span> <span class="token function">trimBST</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">,</span> <span class="token keyword">int</span> low<span class="token punctuation">,</span> <span class="token keyword">int</span> high<span class="token punctuation">)</span></pre></td></tr></table></figure></li><li><p>递归终止条件：</p><p>修剪的操作并不是在终止条件上进行的，所以就是遇到空节点返回就可以了。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span></pre></td></tr></table></figure></li><li><p>单层递归的逻辑：</p><p>如果 root（当前节点）的元素小于 low 的数值，那么应该递归右子树，并返回右子树符合条件的头结点。</p><p>如果 root (当前节点) 的元素大于 high 的，那么应该递归左子树，并返回左子树符合条件的头结点。</p><p>接下来要将下一层处理完左子树的结果赋给 root-&gt;left，处理完右子树的结果赋给 root-&gt;right。</p><p>最后返回 root 节点。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> low<span class="token punctuation">)</span> <span class="token comment">// 当前节点值小于 low，当前节点的左子树不可能符合条件，递归右子树并返回</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">return</span> <span class="token function">trimBST</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> low<span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>val <span class="token operator">></span> high<span class="token punctuation">)</span> <span class="token comment">// 当前节点值大于 high，当前节点的右子树不可能符合条件，递归左子树并返回</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">return</span> <span class="token function">trimBST</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> low<span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>root<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">trimBST</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> low<span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 当前节点值在 low 和 high 之间，递归左子树</span></pre></td></tr><tr><td data-num="6"></td><td><pre>root<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">trimBST</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> low<span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 当前节点值在 low 和 high 之间，递归右子树</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">return</span> root<span class="token punctuation">;</span></pre></td></tr></table></figure></li></ol><p>完整的 java 代码：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 递归</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">TreeNode</span> <span class="token function">trimBST</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">,</span> <span class="token keyword">int</span> low<span class="token punctuation">,</span> <span class="token keyword">int</span> high<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token comment">// 递归终止条件</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token comment">// 递归过程</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> low<span class="token punctuation">)</span> <span class="token comment">// 当前节点值小于 low，当前节点的左子树不可能符合条件，递归右子树并返回</span></pre></td></tr><tr><td data-num="8"></td><td><pre>            <span class="token keyword">return</span> <span class="token function">trimBST</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> low<span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>val <span class="token operator">></span> high<span class="token punctuation">)</span> <span class="token comment">// 当前节点值大于 high，当前节点的右子树不可能符合条件，递归左子树并返回</span></pre></td></tr><tr><td data-num="10"></td><td><pre>            <span class="token keyword">return</span> <span class="token function">trimBST</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> low<span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        root<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">trimBST</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> low<span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 当前节点值在 low 和 high 之间，递归左子树</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        root<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">trimBST</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> low<span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 当前节点值在 low 和 high 之间，递归右子树</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token keyword">return</span> root<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20221224152314426.png" alt="image-20221224152314426"></p><h4 id="总结-26"><a class="anchor" href="#总结-26">#</a> 总结</h4><p>修剪二叉搜索树其实并不难，但在递归法中大家可看出我费了很大的功夫来讲解如何删除节点的，这个思路其实是比较绕的。</p><p>最终的代码倒是很简洁。</p><p><strong>如果不对递归有深刻的理解，这道题目还是有难度的！</strong></p><p>本题我依然给出递归法和迭代法，初学者掌握递归就可以了，如果想进一步学习，就把迭代法也写一写。</p><h3 id="108-将有序数组转换为二叉搜索树"><a class="anchor" href="#108-将有序数组转换为二叉搜索树">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb252ZXJ0LXNvcnRlZC1hcnJheS10by1iaW5hcnktc2VhcmNoLXRyZWUv">108. 将有序数组转换为二叉搜索树</span></h3><blockquote><p>构造二叉搜索树，一不小心就平衡了</p></blockquote><p>做这道题目之前大家可以了解一下这几道：</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVyY2FybC5jb20vMDEwNi4lRTQlQkIlOEUlRTQlQjglQUQlRTUlQkElOEYlRTQlQjglOEUlRTUlOTAlOEUlRTUlQkElOEYlRTklODElOEQlRTUlOEUlODYlRTUlQkElOEYlRTUlODglOTclRTYlOUUlODQlRTklODAlQTAlRTQlQkElOEMlRTUlOEYlODklRTYlQTAlOTEuaHRtbA==">106. 从中序与后序遍历序列构造二叉树</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVyY2FybC5jb20vMDY1NC4lRTYlOUMlODAlRTUlQTQlQTclRTQlQkElOEMlRTUlOEYlODklRTYlQTAlOTEuaHRtbA==">654. 最大二叉树 </span>中其实已经讲过了，如果根据数组构造一棵二叉树。</li><li><span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVyY2FybC5jb20vMDcwMS4lRTQlQkElOEMlRTUlOEYlODklRTYlOTAlOUMlRTclQjQlQTIlRTYlQTAlOTElRTQlQjglQUQlRTclOUElODQlRTYlOEYlOTIlRTUlODUlQTUlRTYlOTMlOEQlRTQlQkQlOUMuaHRtbA==">701. 二叉搜索树中的插入操作</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVyY2FybC5jb20vMDQ1MC4lRTUlODglQTAlRTklOTklQTQlRTQlQkElOEMlRTUlOEYlODklRTYlOTAlOUMlRTclQjQlQTIlRTYlQTAlOTElRTQlQjglQUQlRTclOUElODQlRTglOEElODIlRTclODIlQjkuaHRtbA==">450. 删除二叉搜索树中的节点</span></li></ul><p>进入正题：</p><p>题目中说要转换为一棵高度平衡二叉搜索树。为什么强调要平衡呢？</p><p>因为只要给我们一个有序数组，如果不强调平衡，都可以以线性结构来构造二叉搜索树。</p><p>例如 有序数组 [-10，-3，0，5，9] 就可以构造成这样的二叉搜索树，如图。</p><p><img data-src="https://code-thinking-1253855093.file.myqcloud.com/pics/20220930173553.png" alt="img"></p><p>上图中，是符合二叉搜索树的特性吧，如果要这么做的话，是不是本题意义就不大了，所以才强调是平衡二叉搜索树。</p><p>其实数组构造二叉树，构成平衡树是自然而然的事情，因为大家默认都是从数组中间位置取值作为节点元素，一般不会随机取。<strong>所以想构成不平衡的二叉树是自找麻烦</strong>。</p><p>在<span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVyY2FybC5jb20vMDEwNi4lRTQlQkIlOEUlRTQlQjglQUQlRTUlQkElOEYlRTQlQjglOEUlRTUlOTAlOEUlRTUlQkElOEYlRTklODElOEQlRTUlOEUlODYlRTUlQkElOEYlRTUlODglOTclRTYlOUUlODQlRTklODAlQTAlRTQlQkElOEMlRTUlOEYlODklRTYlQTAlOTEuaHRtbA==">二叉树：构造二叉树登场！ </span>和<span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVyY2FybC5jb20vMDY1NC4lRTYlOUMlODAlRTUlQTQlQTclRTQlQkElOEMlRTUlOEYlODklRTYlQTAlOTEuaHRtbA==">二叉树：构造一棵最大的二叉树 </span>中其实已经讲过了，如果根据数组构造一棵二叉树。</p><p><strong>本质就是寻找分割点，分割点作为当前节点，然后递归左区间和右区间</strong>。</p><p>本题其实要比<span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVyY2FybC5jb20vMDEwNi4lRTQlQkIlOEUlRTQlQjglQUQlRTUlQkElOEYlRTQlQjglOEUlRTUlOTAlOEUlRTUlQkElOEYlRTklODElOEQlRTUlOEUlODYlRTUlQkElOEYlRTUlODglOTclRTYlOUUlODQlRTklODAlQTAlRTQlQkElOEMlRTUlOEYlODklRTYlQTAlOTEuaHRtbA==">二叉树：构造二叉树登场！ </span>和 <span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVyY2FybC5jb20vMDY1NC4lRTYlOUMlODAlRTUlQTQlQTclRTQlQkElOEMlRTUlOEYlODklRTYlQTAlOTEuaHRtbA==">二叉树：构造一棵最大的二叉树 </span>简单一些，因为有序数组构造二叉搜索树，寻找分割点就比较容易了。</p><p><strong>分割点就是有序数组中间位置的节点</strong>。</p><p>那么为问题来了，如果数组长度为偶数，中间节点有两个，取哪一个？</p><p>取哪一个都可以，只不过构成了不同的平衡二叉搜索树。</p><p>例如：输入：[-10,-3,0,5,9]</p><p>如下两棵树，都是这个数组的平衡二叉搜索树：</p><p><img data-src="https://code-thinking.cdn.bcebos.com/pics/108.%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.png" alt="108.将有序数组转换为二叉搜索树"></p><p>如果要分割的数组长度为偶数的时候，中间元素为两个，是取左边元素 就是树 1，取右边元素就是树 2。</p><p><strong>这也是题目中强调答案不是唯一的原因。 理解这一点，这道题目算是理解到位了</strong>。</p><h4 id="递归-14"><a class="anchor" href="#递归-14">#</a> 递归</h4><p>三部曲：</p><ol><li><p>参数、返回值：</p><p>删除二叉树节点，增加二叉树节点，都是用递归函数的返回值来完成，这样是比较方便的。</p><p>相信大家如果仔细看了<span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVyY2FybC5jb20vMDcwMS4lRTQlQkElOEMlRTUlOEYlODklRTYlOTAlOUMlRTclQjQlQTIlRTYlQTAlOTElRTQlQjglQUQlRTclOUElODQlRTYlOEYlOTIlRTUlODUlQTUlRTYlOTMlOEQlRTQlQkQlOUMuaHRtbA==">二叉树：搜索树中的插入操作 </span>和<span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVyY2FybC5jb20vMDQ1MC4lRTUlODglQTAlRTklOTklQTQlRTQlQkElOEMlRTUlOEYlODklRTYlOTAlOUMlRTclQjQlQTIlRTYlQTAlOTElRTQlQjglQUQlRTclOUElODQlRTglOEElODIlRTclODIlQjkuaHRtbA==">二叉树：搜索树中的删除操作 </span>，一定会对递归函数返回值的作用深有感触。</p><p>那么本题要构造二叉树，依然用递归函数的返回值来构造中节点的左右孩子。</p><p>再来看参数，首先是传入数组，然后就是左下标 left 和右下标 right，我们在<span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVyY2FybC5jb20vMDEwNi4lRTQlQkIlOEUlRTQlQjglQUQlRTUlQkElOEYlRTQlQjglOEUlRTUlOTAlOEUlRTUlQkElOEYlRTklODElOEQlRTUlOEUlODYlRTUlQkElOEYlRTUlODglOTclRTYlOUUlODQlRTklODAlQTAlRTQlQkElOEMlRTUlOEYlODklRTYlQTAlOTEuaHRtbA==">二叉树：构造二叉树登场！ </span>中提过，<strong>在构造二叉树的时候尽量不要重新定义左右区间数组，而是用下标来操作原数组</strong>。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">private</span> <span class="token class-name">TreeNode</span> <span class="token function">buildTree</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span></pre></td></tr></table></figure></li><li><p>递归终止条件：</p><p>这里定义的是左闭右闭的区间，所以当区间 left &gt; right 的时候，就是空节点了。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">></span> right<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span></pre></td></tr></table></figure></li><li><p>单层递归的逻辑：</p><ul><li><p>首先取数组中间元素的位置</p><blockquote><p>不难写出 <code>int mid = (left + right) / 2;</code> ，<strong>这么写其实有一个问题，就是数值越界，例如 left 和 right 都是最大 int，这么操作就越界了，在<span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVyY2FybC5jb20vMDAzNS4lRTYlOTAlOUMlRTclQjQlQTIlRTYlOEYlOTIlRTUlODUlQTUlRTQlQkQlOEQlRTclQkQlQUUuaHRtbA==">二分法</span>中尤其需要注意！</strong></p><p>所以可以这么写： <code>int mid = left + ((right - left) / 2);</code></p><p>但本题 leetcode 的测试数据并不会越界，所以怎么写都可以。但需要有这个意识！</p></blockquote></li><li><p>取了中间位置，就开始以中间位置的元素构造节点</p><blockquote><p>代码： <code>TreeNode* root = new TreeNode(nums[mid]);</code></p></blockquote></li><li><p>接着划分区间，root 的左孩子接住下一层左区间的构造节点，右孩子接住下一层右区间构造的节点</p></li><li><p>最后返回 root 节点</p></li></ul><p>单层递归整体代码如下：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> mid <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">// 取有序数组的中间元素作为根节点，如果数组长度为偶数，中间位置有两个元素，取靠左边的。这样写防止溢出。</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name">TreeNode</span> root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 构建根节点</span></pre></td></tr><tr><td data-num="3"></td><td><pre>root<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">buildTree</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> left<span class="token punctuation">,</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 递归构建左子树</span></pre></td></tr><tr><td data-num="4"></td><td><pre>root<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">buildTree</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 递归构建右子树</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">return</span> root<span class="token punctuation">;</span></pre></td></tr></table></figure></li></ol><p>整体的 java 代码如下：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">TreeNode</span> <span class="token function">sortedArrayToBST</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token keyword">return</span> <span class="token function">buildTree</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token comment">// 递归构建二叉搜索树，左闭右闭区间</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">private</span> <span class="token class-name">TreeNode</span> <span class="token function">buildTree</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token comment">// 递归终止条件</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">></span> right<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token comment">// 单层递归逻辑</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token keyword">int</span> mid <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">// 取有序数组的中间元素作为根节点，如果数组长度为偶数，中间位置有两个元素，取靠左边的。这样写防止溢出。</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token class-name">TreeNode</span> root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 构建根节点</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        root<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">buildTree</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> left<span class="token punctuation">,</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 递归构建左子树</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        root<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">buildTree</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 递归构建右子树</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token keyword">return</span> root<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20221224164322426.png" alt="image-20221224164322426"></p><h4 id="总结-27"><a class="anchor" href="#总结-27">#</a> 总结</h4><p><strong>在<span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVyY2FybC5jb20vMDEwNi4lRTQlQkIlOEUlRTQlQjglQUQlRTUlQkElOEYlRTQlQjglOEUlRTUlOTAlOEUlRTUlQkElOEYlRTklODElOEQlRTUlOEUlODYlRTUlQkElOEYlRTUlODglOTclRTYlOUUlODQlRTklODAlQTAlRTQlQkElOEMlRTUlOEYlODklRTYlQTAlOTEuaHRtbA==">二叉树：构造二叉树登场！</span>和 <span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVyY2FybC5jb20vMDY1NC4lRTYlOUMlODAlRTUlQTQlQTclRTQlQkElOEMlRTUlOEYlODklRTYlQTAlOTEuaHRtbA==">二叉树：构造一棵最大的二叉树</span>之后，我们顺理成章的应该构造一下二叉搜索树了，一不小心还是一棵平衡二叉搜索树</strong>。</p><p>其实思路也是一样的，不断中间分割，然后递归处理左区间，右区间，也可以说是分治。</p><p>此时相信大家应该对通过递归函数的返回值来增删二叉树很熟悉了，这也是常规操作。</p><p>在定义区间的过程中我们又一次强调了循环不变量的重要性。</p><p>最后依然给出迭代的方法，其实就是模拟取中间元素，然后不断分割去构造二叉树的过程。</p><h3 id="538-把二叉搜索树转换为累加树"><a class="anchor" href="#538-把二叉搜索树转换为累加树">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb252ZXJ0LWJzdC10by1ncmVhdGVyLXRyZWUv">538. 把二叉搜索树转换为累加树</span></h3><p>一看到累加树，相信很多小伙伴都会疑惑：如何累加？遇到一个节点，然后再遍历其他节点累加？怎么一想这么麻烦呢。</p><p>然后再发现这是一棵二叉搜索树，二叉搜索树啊，这是有序的啊。</p><p>那么有序的元素如何求累加呢？</p><p><strong>其实这就是一棵树，大家可能看起来有点别扭，换一个角度来看，这就是一个有序数组 [2, 5, 13]，求从后到前的累加数组，也就是 [20, 18, 13]，是不是感觉这就简单了。</strong></p><p>为什么变成数组就是感觉简单了呢？</p><p>因为数组大家都知道怎么遍历啊，从后向前，挨个累加就完事了，这换成了二叉搜索树，看起来就别扭了一些是不是。</p><p>那么知道如何遍历这个二叉树，也就迎刃而解了，<strong>从树中可以看出累加的顺序是右中左，所以我们需要<mark>反中序遍历</mark>这个二叉树，然后顺序累加就可以了</strong>。</p><h4 id="递归-15"><a class="anchor" href="#递归-15">#</a> 递归</h4><p>遍历顺序如图所示：</p><p><img data-src="https://img-blog.csdnimg.cn/20210204153440666.png" alt="538.把二叉搜索树转换为累加树"></p><p><strong><mark>前、后双指针法</mark></strong>：本题依然需要一个 pre 指针记录当前遍历节点 cur 的前一个节点，这样才方便做累加。</p><p>pre 指针的使用技巧，我们在<span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVyY2FybC5jb20vMDUzMC4lRTQlQkElOEMlRTUlOEYlODklRTYlOTAlOUMlRTclQjQlQTIlRTYlQTAlOTElRTclOUElODQlRTYlOUMlODAlRTUlQjAlOEYlRTclQkIlOUQlRTUlQUYlQjklRTUlQjclQUUuaHRtbA==">二叉树：搜索树的最小绝对差</span>和<span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVyY2FybC5jb20vMDUwMS4lRTQlQkElOEMlRTUlOEYlODklRTYlOTAlOUMlRTclQjQlQTIlRTYlQTAlOTElRTQlQjglQUQlRTclOUElODQlRTQlQkMlOTclRTYlOTUlQjAuaHRtbA==">二叉树：我的众数是多少？</span>都提到了，这是常用的操作手段。</p><p>递归三部曲：</p><ol><li><p>返回值、参数：</p><p>这里很明确了，<strong>不需要递归函数的返回值</strong>做什么操作了，要遍历整棵树。</p><p>同时需要定义<strong>一个全局变量 pre，用来保存 cur 节点的前一个节点的数值，定义为 int 型就可以</strong>了。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">int</span> pre <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">traversal</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> cur<span class="token punctuation">)</span></pre></td></tr></table></figure></li><li><p>递归终止条件：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span></pre></td></tr></table></figure></li><li><p>单层递归的逻辑：</p><p>注意<strong>要右中左来遍历二叉树</strong>， 中节点的处理逻辑就是让 cur 的数值加上 pre 的数值，并更新 pre。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">convertBST</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 右</span></pre></td></tr><tr><td data-num="2"></td><td><pre>root<span class="token punctuation">.</span>val <span class="token operator">+=</span> pre<span class="token punctuation">;</span> <span class="token comment">// 中</span></pre></td></tr><tr><td data-num="3"></td><td><pre>pre <span class="token operator">=</span> root<span class="token punctuation">.</span>val<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token function">convertBST</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 左</span></pre></td></tr></table></figure></li></ol><p>整体的 java 代码：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">int</span> pre <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">traversal</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> cur<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token comment">// 递归终止条件</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>cur <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token comment">// 单层递归逻辑</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token function">convertBST</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 右</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        cur<span class="token punctuation">.</span>val <span class="token operator">+=</span> pre<span class="token punctuation">;</span> <span class="token comment">// 中</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        pre <span class="token operator">=</span> cur<span class="token punctuation">.</span>val<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token function">convertBST</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 左</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">TreeNode</span> <span class="token function">convertBST</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token function">traversal</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token keyword">return</span> root<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20221224170250499.png" alt="image-20221224170250499"></p><h4 id="迭代-9"><a class="anchor" href="#迭代-9">#</a> 迭代</h4><p>迭代法其实就是中序模板题了，在<span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVyY2FybC5jb20vJUU0JUJBJThDJUU1JThGJTg5JUU2JUEwJTkxJUU3JTlBJTg0JUU4JUJGJUFEJUU0JUJCJUEzJUU5JTgxJThEJUU1JThFJTg2Lmh0bWw=">二叉树：前中后序迭代法</span>和<span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVyY2FybC5jb20vJUU0JUJBJThDJUU1JThGJTg5JUU2JUEwJTkxJUU3JTlBJTg0JUU3JUJCJTlGJUU0JUI4JTgwJUU4JUJGJUFEJUU0JUJCJUEzJUU2JUIzJTk1Lmh0bWw=">二叉树：前中后序统一方式迭代法</span>可以选一种自己习惯的写法。</p><p>这里我给出其中的一种，借助<strong>栈</strong>，代码如下：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 迭代（反中序遍历），借助栈</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">int</span> pre <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">traversal</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> cur<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TreeNode</span><span class="token punctuation">></span></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token keyword">while</span> <span class="token punctuation">(</span>cur <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>cur <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>                stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>                cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>right<span class="token punctuation">;</span> <span class="token comment">// 右</span></pre></td></tr><tr><td data-num="11"></td><td><pre>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 此时 cur 为 null，到达最右端</span></pre></td></tr><tr><td data-num="12"></td><td><pre>                cur <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>                cur<span class="token punctuation">.</span>val <span class="token operator">+=</span> pre<span class="token punctuation">;</span> <span class="token comment">// 中</span></pre></td></tr><tr><td data-num="14"></td><td><pre>                pre <span class="token operator">=</span> cur<span class="token punctuation">.</span>val<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre></pre></td></tr><tr><td data-num="16"></td><td><pre>                cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>left<span class="token punctuation">;</span> <span class="token comment">// 左</span></pre></td></tr><tr><td data-num="17"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="20"></td><td><pre></pre></td></tr><tr><td data-num="21"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">TreeNode</span> <span class="token function">convertBST</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>        <span class="token function">traversal</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>        <span class="token keyword">return</span> root<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="25"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20221224170743147.png" alt="image-20221224170743147"></p><h3 id="二叉树总结篇"><a class="anchor" href="#二叉树总结篇">#</a> 二叉树总结篇</h3><h4 id="二叉树的理论基础-2"><a class="anchor" href="#二叉树的理论基础-2">#</a> 二叉树的理论基础</h4><ul><li><a href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80">二叉树的理论基础</a>：二叉树的种类、存储方式、遍历方式、定义方式</li></ul><h4 id="二叉树的遍历方式"><a class="anchor" href="#二叉树的遍历方式">#</a> 二叉树的遍历方式</h4><ul><li>深度优先遍历<ul><li><a href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86">二叉树：前中后序递归法</a>：<strong>递归三部曲</strong>初次亮相</li><li><a href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%86">二叉树：前中后序迭代法（一）</a>：通过<strong>栈</strong>模拟递归</li><li><a href="#%E2%98%86%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%BB%9F%E4%B8%80%E8%BF%AD%E4%BB%A3%E6%B3%95">二叉树：前中后序迭代法（二）统一风格</a>：栈 + <strong>null 标记法</strong></li></ul></li><li>广度优先遍历<ul><li>[二叉树的层序遍历](#102. 二叉树的层序遍历)：通过<strong>队列</strong>模拟</li></ul></li></ul><h4 id="求二叉树的属性"><a class="anchor" href="#求二叉树的属性">#</a> 求二叉树的属性</h4><ul><li>[二叉树：是否对称](#101. 对称二叉树)<ul><li>递归：后序，比较的是根节点的左子树与右子树是不是相互翻转</li><li>迭代：使用队列 / 栈将两个节点顺序放入容器中进行比较</li></ul></li><li>[二叉树：求最大深度](#104. 二叉树的最大深度)<ul><li>递归：后序，求根节点最大高度就是最大深度，通过递归函数的返回值做计算树的高度</li><li>迭代：层序遍历</li></ul></li><li>[二叉树：求最小深度](#111. 二叉树的最小深度)<ul><li>递归：后序，求根节点最小高度就是最小深度，注意最小深度的定义</li><li>迭代：层序遍历</li></ul></li><li>[二叉树：求有多少个节点](#222. 完全二叉树的节点个数)<ul><li>递归：后序，通过递归函数的返回值计算节点数量</li><li>迭代：层序遍历</li></ul></li><li>[☆二叉树：是否平衡](#☆110. 平衡二叉树)<ul><li>递归：后序，注意后序求高度和前序求深度，递归过程判断高度差</li><li>迭代：效率很低，不推荐</li></ul></li><li>[☆二叉树：找所有路径](#☆257. 二叉树的所有路径)<ul><li>递归：前序，方便让父节点指向子节点，涉及回溯处理根节点到叶子的所有路径</li><li>迭代：一个栈模拟递归，一个栈来存放对应的遍历路径</li></ul></li><li>二叉树：递归中如何隐藏着回溯<ul><li>详解 [☆二叉树：找所有路径](#☆257. 二叉树的所有路径) 中递归如何隐藏着回溯</li></ul></li><li>[二叉树：求左叶子之和](#404. 左叶子之和)<ul><li>递归：后序，必须三层约束条件，才能判断是否是左叶子。</li><li>迭代：直接模拟后序遍历</li></ul></li><li>[二叉树：求左下角的值](#513. 找树左下角的值)<ul><li>递归：顺序无所谓，优先左孩子搜索，同时找深度最大的叶子节点。</li><li>迭代：<strong>层序遍历</strong>找最后一行最左边</li></ul></li><li>[☆二叉树：求路径总和](#☆112. 路径总和)<ul><li>递归：顺序无所谓，递归函数返回值为 bool 类型是为了搜索一条边，没有返回值是搜索整棵树。</li><li>迭代：栈里元素不仅要记录节点指针，还要记录从头结点到该节点的路径数值总和</li></ul></li></ul><h4 id="二叉树的修改与构造"><a class="anchor" href="#二叉树的修改与构造">#</a> 二叉树的修改与构造</h4><ul><li>[翻转二叉树](#226. 翻转二叉树)<ul><li>递归：<strong>前序 / 后序</strong>，交换左右孩子</li><li>迭代：直接模拟前序遍历</li></ul></li><li>[构造二叉树](#106. 从中序与后序遍历序列构造二叉树)<ul><li>递归：<strong>前序</strong>，重点在于找分割点，分左右区间构造</li><li>迭代：比较复杂，意义不大</li></ul></li><li>[构造最大的二叉树](#654. 最大二叉树)<ul><li>递归：<strong>前序</strong>，分割点为数组最大值，分左右区间构造</li><li>迭代：比较复杂，意义不大</li></ul></li><li>[合并两个二叉树](#617. 合并二叉树)<ul><li>递归：<strong>前序</strong>，同时操作两个树的节点，注意合并的规则</li><li>迭代：使用队列，类似层序遍历</li></ul></li></ul><h4 id="求bst的属性"><a class="anchor" href="#求bst的属性">#</a> 求 BST 的属性</h4><ul><li>[二叉搜索树中的搜索](#700. 二叉搜索树中的搜索)<ul><li>递归：二叉搜索树的递归是有方向的</li><li>迭代：因为有方向，所以迭代法很简单</li></ul></li><li>[是不是二叉搜索树](#98. 验证二叉搜索树)<ul><li>递归：<strong>中序</strong>，相当于变成了判断一个序列是不是递增的</li><li>迭代：模拟中序，逻辑相同</li></ul></li><li>[求二叉搜索树的最小绝对差](#530. 二叉搜索树的最小绝对差)<ul><li>递归：<strong>中序</strong>，双指针操作</li><li>迭代：模拟中序，逻辑相同</li></ul></li><li>[求二叉搜索树的众数](#501. 二叉搜索树中的众数)<ul><li>递归：<strong>中序</strong>，清空结果集的技巧，遍历一遍便可求众数集合</li></ul></li><li>[二叉搜索树转成累加树](#538. 把二叉搜索树转换为累加树)<ul><li>递归：<strong>中序</strong>，双指针操作累加</li><li>迭代：模拟中序，逻辑相同</li></ul></li></ul><h4 id="二叉树公共祖先问题"><a class="anchor" href="#二叉树公共祖先问题">#</a> 二叉树公共祖先问题</h4><ul><li>[二叉树的最近公共祖先](#236. 二叉树的最近公共祖先)<ul><li>递归：<strong>后序</strong>，回溯，找到左子树出现目标值，右子树节点目标值的节点。</li><li>迭代：不适合模拟回溯</li></ul></li><li>[BST 的公共祖先问题](#235. 二叉搜索树的最近公共祖先)<ul><li>递归：顺序无所谓，如果节点的数值在目标区间就是最近公共祖先</li><li>迭代：按序遍历</li></ul></li></ul><h4 id="bst的修改与构造"><a class="anchor" href="#bst的修改与构造">#</a> BST 的修改与构造</h4><ul><li>[二叉搜索树中的插入操作](#701. 二叉搜索树中的插入操作)<ul><li>递归：顺序无所谓，通过递归函数返回值添加节点</li><li>迭代：按序遍历，需要记录插入父节点，这样才能做插入操作</li></ul></li><li>[二叉搜索树中的删除操作](#450. 删除二叉搜索树中的节点)<ul><li>递归：<strong>前序</strong>，想清楚删除非叶子节点的情况</li><li>迭代：有序遍历，较复杂</li></ul></li><li>[修剪二叉搜索树](#669. 修剪二叉搜索树)<ul><li>递归：<strong>前序</strong>，通过递归函数返回值删除节点</li><li>迭代：有序遍历，较复杂</li></ul></li><li>[构造二叉搜索树](#108. 将有序数组转换为二叉搜索树)<ul><li>递归：<strong>前序</strong>，数组中间节点分割</li><li>迭代：较复杂，通过三个队列来模拟</li></ul></li></ul><h4 id="最后总结"><a class="anchor" href="#最后总结">#</a> 最后总结！</h4><p><strong>在二叉树题目选择什么遍历顺序是不少同学头疼的事情，我们做了这么多二叉树的题目了，Carl 给大家大体分分类</strong>。</p><ul><li><p>涉及到二叉<strong>树的构造</strong>，无论普通二叉树还是二叉搜索树<strong>一定前序</strong>，都是先构造中节点。</p></li><li><p>求<strong>普通二叉树的属性</strong>，一般是<strong>后序</strong>，一般要通过递归函数的返回值做计算。</p><blockquote><p>注意在普通二叉树的属性中，我用的是一般为后序，例如单纯求深度就用前序，<span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVyY2FybC5jb20vMDI1Ny4lRTQlQkElOEMlRTUlOEYlODklRTYlQTAlOTElRTclOUElODQlRTYlODklODAlRTYlOUMlODklRTglQjclQUYlRTUlQkUlODQuaHRtbA==">二叉树：找所有路径</span>也用了前序，这是为了方便让父节点指向子节点。</p><p>所以求普通二叉树的属性还是要具体问题具体分析。</p></blockquote></li><li><p>求<strong>二叉搜索树的属性</strong>，<strong>一定中序</strong>了，要不白瞎了有序性了。</p></li></ul><p>二叉树专题汇聚为一张图：</p><p><img data-src="https://code-thinking-1253855093.file.myqcloud.com/pics/20211030125421.png" alt="img"></p><h2 id="回溯算法"><a class="anchor" href="#回溯算法">#</a> 回溯算法</h2><h3 id="回溯算法理论基础"><a class="anchor" href="#回溯算法理论基础">#</a> 回溯算法理论基础</h3><p><img data-src="https://img-blog.csdnimg.cn/20210219192050666.png" alt="回溯算法大纲"></p><h4 id="什么是回溯"><a class="anchor" href="#什么是回溯">#</a> 什么是回溯</h4><p>回溯法也可以叫做<strong>回溯搜索法，它是一种搜索的方式</strong>。</p><p>在二叉树系列中，我们已经不止一次，提到了回溯，例如<span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVyY2FybC5jb20vJUU0JUJBJThDJUU1JThGJTg5JUU2JUEwJTkxJUU0JUI4JUFEJUU5JTgwJTkyJUU1JUJEJTkyJUU1JUI4JUE2JUU3JTlEJTgwJUU1JTlCJTlFJUU2JUJBJUFGLmh0bWw=">二叉树：以为使用了递归，其实还隐藏着回溯</span>。</p><p>回溯是递归的副产品，<strong>只要有递归就会有回溯</strong>。</p><p><strong>所以以下讲解中，回溯函数也就是递归函数，指的都是一个函数</strong>。</p><h4 id="回溯法的效率"><a class="anchor" href="#回溯法的效率">#</a> 回溯法的效率</h4><p>回溯法的性能如何呢，这里要和大家说清楚了，<strong>虽然回溯法很难，很不好理解，但是回溯法并不是什么高效的算法</strong>。</p><p><strong>因为回溯的本质是穷举，穷举所有可能，然后选出我们想要的答案</strong>，如果想让回溯法高效一些，可以加一些剪枝的操作，但也改不了回溯法就是穷举的本质。</p><p>那么既然回溯法并不高效为什么还要用它呢？</p><p>因为没得选，一些问题能暴力搜出来就不错了，撑死了再剪枝一下，还没有更高效的解法。</p><p>此时大家应该好奇了，都什么问题，这么牛逼，只能暴力搜索。</p><h4 id="回溯法解决的问题"><a class="anchor" href="#回溯法解决的问题">#</a> 回溯法解决的问题</h4><p>回溯法，一般可以解决如下几种问题：</p><ul><li>组合问题：N 个数里面按一定规则找出 k 个数的集合</li><li>切割问题：一个字符串按一定规则有几种切割方式</li><li>子集问题：一个 N 个数的集合里有多少符合条件的子集</li><li>排列问题：N 个数按一定规则全排列，有几种排列方式</li><li>棋盘问题：N 皇后，解数独等等</li></ul><p><strong>相信大家看着这些之后会发现，每个问题，都不简单！</strong></p><p>另外，会有一些同学可能分不清什么是组合，什么是排列？</p><p><strong>组合是不强调元素顺序的，排列是强调元素顺序</strong>。</p><p>例如：{1, 2} 和 {2, 1} 在组合上，就是一个集合，因为不强调顺序，而要是排列的话，{1, 2} 和 {2, 1} 就是两个集合了。</p><p>记住<strong>组合无序，排列有序</strong>，就可以了。</p><h4 id="如何理解回溯法"><a class="anchor" href="#如何理解回溯法">#</a> 如何理解回溯法</h4><p><strong>回溯法解决的问题都可以抽象为树形结构</strong>，是的，我指的是所有回溯法的问题都可以抽象为树形结构！</p><p>因为回溯法解决的都是在集合中递归查找子集，<strong>集合的大小就构成了树的宽度，递归的深度，都构成的树的深度</strong>。</p><p>递归就要有终止条件，所以必然是一棵高度有限的树（N 叉树）。</p><p>这块可能初学者还不太理解，后面的回溯算法解决的所有题目中，我都会强调这一点并画图举相应的例子，现在有一个印象就行。</p><h4 id="回溯法模板"><a class="anchor" href="#回溯法模板">#</a> 回溯法模板</h4><p>这里给出 Carl 总结的回溯算法模板。</p><p>在讲<a href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86">二叉树的递归遍历</a>中我们说了递归三部曲，这里我再给大家列出<strong>回溯三部曲</strong>。</p><ul><li>回溯函数模板 **<mark> 返回值、参数</mark> **</li></ul><p>在回溯算法中，我的习惯是函数起名字为 backtracking，这个起名大家随意。</p><p>回溯算法中函数<strong>返回值一般为 void</strong>。</p><p>再来看一下参数，因为回溯算法需要的参数可不像二叉树递归的时候那么容易一次性确定下来，所以<strong>一般是先写逻辑，然后需要什么参数，就填什么参数</strong>。</p><p>但后面的回溯题目的讲解中，为了方便大家理解，我在一开始就帮大家把参数确定下来。</p><p>回溯函数伪代码如下：</p><figure class="highlight text"><figcaption data-lang="text"></figcaption><table><tr><td data-num="1"></td><td><pre>void backtracking(参数)</pre></td></tr></table></figure><ul><li>回溯函数 **<mark> 终止条件</mark> **</li></ul><p>既然是树形结构，那么我们在讲解<a href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86">二叉树的递归遍历</a>的时候，就知道遍历树形结构一定要有终止条件。</p><p>所以回溯也有要终止条件。</p><p>什么时候达到了终止条件，树中就可以看出，<strong>一般来说搜到叶子节点了</strong>，也就找到了满足条件的一条答案，<strong>把这个答案存放起来</strong>，并结束本层递归。</p><p>所以回溯函数终止条件伪代码如下：</p><figure class="highlight text"><figcaption data-lang="text"></figcaption><table><tr><td data-num="1"></td><td><pre>if (终止条件) &#123;</pre></td></tr><tr><td data-num="2"></td><td><pre>    存放结果;</pre></td></tr><tr><td data-num="3"></td><td><pre>    return;</pre></td></tr><tr><td data-num="4"></td><td><pre>&#125;</pre></td></tr></table></figure><ul><li>回溯搜索的 **<mark> 遍历过程</mark> **</li></ul><p>在上面我们提到了，<strong>回溯法一般是在集合中递归搜索，<u>集合的大小</u>构成了树的宽度，<u>递归的深度</u>构成的树的深度</strong>。</p><p>如图：</p><p><img data-src="https://img-blog.csdnimg.cn/20210130173631174.png" alt="回溯算法理论基础"></p><p>注意图中，我特意举例集合大小和孩子的数量是相等的！</p><p>回溯函数遍历过程伪代码如下：</p><figure class="highlight text"><figcaption data-lang="text"></figcaption><table><tr><td data-num="1"></td><td><pre>for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;</pre></td></tr><tr><td data-num="2"></td><td><pre>    处理节点;</pre></td></tr><tr><td data-num="3"></td><td><pre>    backtracking(路径，选择列表); // 递归</pre></td></tr><tr><td data-num="4"></td><td><pre>    回溯，撤销处理结果</pre></td></tr><tr><td data-num="5"></td><td><pre>&#125;</pre></td></tr></table></figure><p>for 循环就是遍历集合区间，可以理解一个节点有多少个孩子，这个 for 循环就执行多少次。</p><p>backtracking 这里自己调用自己，实现递归。</p><p>大家可以从图中看出<strong> for 循环可以理解是横向遍历，backtracking（递归）就是纵向遍历</strong>，这样就把这棵树全遍历完了，一般来说，搜索叶子节点就是找的其中一个结果了。</p><p>分析完过程，回溯算法模板框架如下：</p><figure class="highlight text"><figcaption data-lang="text"></figcaption><table><tr><td data-num="1"></td><td><pre>void backtracking(参数) &#123;</pre></td></tr><tr><td data-num="2"></td><td><pre>    if (终止条件) &#123;</pre></td></tr><tr><td data-num="3"></td><td><pre>        存放结果;</pre></td></tr><tr><td data-num="4"></td><td><pre>        return;</pre></td></tr><tr><td data-num="5"></td><td><pre>    &#125;</pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre>    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;</pre></td></tr><tr><td data-num="8"></td><td><pre>        处理节点;</pre></td></tr><tr><td data-num="9"></td><td><pre>        backtracking(路径，选择列表); // 递归</pre></td></tr><tr><td data-num="10"></td><td><pre>        回溯，撤销处理结果</pre></td></tr><tr><td data-num="11"></td><td><pre>    &#125;</pre></td></tr><tr><td data-num="12"></td><td><pre>&#125;</pre></td></tr></table></figure><p><strong>这份模板很重要，后面做回溯法的题目都靠它了！</strong></p><p>如果从来没有学过回溯算法的录友们，看到这里会有点懵，后面开始讲解具体题目的时候就会好一些了，已经做过回溯法题目的录友，看到这里应该会感同身受了。</p><h4 id="总结-28"><a class="anchor" href="#总结-28">#</a> 总结</h4><p>本篇我们讲解了，什么是回溯算法，知道了<strong>回溯和递归是相辅相成的</strong>。</p><p>接着提到了回溯法的效率，<strong>回溯法其实就是暴力查找，并不是什么高效的算法</strong>。</p><p>然后列出了回溯法可以解决几类问题，可以看出<strong>每一类问题都不简单</strong>。</p><p>最后我们讲到回溯法解决的<strong>问题都可以抽象为树形结构（N 叉树）</strong>，并给出了<strong>回溯法的模板</strong>。</p><p>今天是回溯算法的第一天，按照惯例 Carl 都是先概述一波，然后在开始讲解具体题目，没有接触过回溯法的同学刚学起来有点看不懂很正常，后面和具体题目结合起来会好一些。</p><h3 id="77-组合"><a class="anchor" href="#77-组合">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb21iaW5hdGlvbnMv">77. 组合</span></h3><h4 id="思路-3"><a class="anchor" href="#思路-3">#</a> 思路</h4><p>本题是回溯法的经典题目。</p><p>直接的解法当然是使用 for 循环。</p><p>输入：n = 4，k = 2，很容易想到，用两个 for 循环，这样就可以输出 和示例中一样的结果。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        cout <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> j <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>输入：n = 100, k = 3，那么就三层 for 循环，代码如下：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> u <span class="token operator">=</span> j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> u <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> n<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>            cout <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> j <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> u <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><strong>如果 n 为 100，k 为 50 呢，那就 50 层 for 循环，是不是开始窒息</strong>。</p><p><strong>此时就会发现虽然想暴力搜索，但是用 for 循环嵌套连暴力都写不出来！</strong></p><p>咋整？</p><hr><p><strong>回溯搜索法</strong>来了，虽然回溯法也是暴力，但至少能写出来，不像 for 循环嵌套 k 层让人绝望。</p><p>那么回溯法怎么暴力搜呢？</p><p>上面我们说了<strong>要解决 n 为 100，k 为 50 的情况，暴力写法需要嵌套 50 层 for 循环，那么回溯法就用<mark>递归</mark>来解决嵌套层数的问题</strong>。</p><p>递归来做层叠嵌套（可以理解是开 k 层 for 循环），<strong>每一次的递归中嵌套一个 for 循环，那么递归就可以用于解决多层嵌套循环的问题了</strong>。</p><p>此时递归的层数大家应该知道了，例如：n 为 100，k 为 50 的情况下，就是递归 50 层。</p><p>一些同学本来对递归就懵，回溯法中递归还要嵌套 for 循环，可能就直接晕倒了！</p><p>如果脑洞模拟回溯搜索的过程，绝对可以让人窒息，所以需要抽象图形结构来进一步理解。</p><p><strong>我们在<a href="#%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80">回溯算法理论基础</a>中说到回溯法解决的问题都可以抽象为<mark>树形结构（N 叉树）</mark>，用树形结构来理解回溯就容易多了</strong>。</p><p>那么我把组合问题抽象为如下树形结构：</p><p><img data-src="https://img-blog.csdnimg.cn/20201123195223940.png" alt="77.组合"></p><p>可以看出这棵树，一开始集合是 1，2，3，4， 从左向右取数，取过的数，不再重复取。</p><p>第一次取 1，集合变为 2，3，4 ，因为 k 为 2，我们只需要再取一个数就可以了，分别取 2，3，4，得到集合 [1,2] [1,3] [1,4]，以此类推。</p><p><strong>每次从集合中选取元素，可选择的范围随着选择的进行而收缩，调整可选择的范围</strong>。</p><p><strong>图中可以发现<u>n 相当于树的宽度，k 相当于树的深度</u></strong>。</p><p>那么如何在这个树上遍历，然后收集到我们要的结果集呢？</p><p><strong>图中每次搜索到了叶子节点，我们就找到了一个结果</strong>。</p><p>相当于只需要把达到叶子节点的结果收集起来，就可以求得 n 个数中 k 个数的组合集合。</p><p>在<a href="#%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80">回溯算法理论基础</a>中我们提到了回溯法三部曲，那么我们按照<strong>回溯法三部曲</strong>开始正式讲解代码了。</p><h4 id="回溯三部曲"><a class="anchor" href="#回溯三部曲">#</a> 回溯三部曲</h4><ol><li><p>递归函数的<em>返回值</em>、<em>参数</em></p><p>在这里要定义<strong>两个全局变量</strong>，一个用来存放符合条件单一结果，一个用来存放符合条件结果的集合。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span><span class="token punctuation">></span></span> res<span class="token punctuation">;</span> <span class="token comment">// 结果集</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> path<span class="token punctuation">;</span> <span class="token comment">// 符合条件的单一结果</span></pre></td></tr></table></figure><p>其实不定义这两个全局变量也是可以的，把这两个变量放进递归函数的参数里，但<strong>函数里参数太多影响可读性</strong>，所以我定义全局变量了。</p><p>函数里一定有两个参数，既然是集合 n 里面取 k 个数，那么<strong> n 和 k 是两个 int 型的参数</strong>。</p><p>然后还需要一个参数，为<strong> int 型变量 startIndex，这个参数用来记录本层递归中，集合从哪里开始遍历</strong>（集合就是 [1,...,n] ）。</p><p>为什么要有这个 startIndex 呢？</p><p><strong>建议在<span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMXRpNHkxTDdjdg=="> 77. 组合视频讲解</span>中，07:36 的时候开始听，startIndex 就是防止出现重复的组合</strong>。</p><p>从下图中红线部分可以看出，在集合 [1,2,3,4] 取 1 之后，下一层递归，就要在 [2,3,4] 中取数了，那么下一层递归如何知道从 [2,3,4] 中取数呢，靠的就是 startIndex。</p><p><img data-src="https://img-blog.csdnimg.cn/20201123195328976.png" alt="77.组合2"></p><p>所以需要<strong> startIndex 来记录下一层递归，搜索的起始位置</strong>。</p><p>那么整体代码如下：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span><span class="token punctuation">></span></span> res<span class="token punctuation">;</span> <span class="token comment">// 结果集</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> path<span class="token punctuation">;</span> <span class="token comment">// 符合条件的单一结果</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">backtracking</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">,</span> <span class="token keyword">int</span> startIndex<span class="token punctuation">)</span></pre></td></tr></table></figure></li><li><p>回溯函数<em>终止条件</em></p><p>什么时候到达所谓的叶子节点了呢？</p><p><strong>path 这个数组的大小如果达到 k</strong>，说明我们找到了一个子集大小为 k 的组合了，在图中 path 存的就是根节点到叶子节点的路径。</p><p>如图红色部分：</p><p><img data-src="https://img-blog.csdnimg.cn/20201123195407907.png" alt="77.组合3"></p><p>此时用 result 二维数组，把 path 保存起来，并终止本层递归。</p><p>所以终止条件代码如下：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">if</span> <span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 注意：这里要 new 一个新的对象，因为 path 是全局变量，会被后续的递归修改</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">return</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure></li><li><p><em>单层的搜索过程</em></p><p>回溯法的搜索过程就是一个<strong>树型结构的遍历过程</strong>，在如下图中，可以看出</p><ul><li><strong>for 循环</strong>用来横向遍历</li><li><strong>递归</strong>的过程是纵向遍历</li></ul><p><img data-src="https://img-blog.csdnimg.cn/20201123195242899.png" alt="77.组合1"></p><p>如此我们才遍历完图中的这棵树。</p><p><strong>for 循环每次从 startIndex 开始遍历，然后用 path 保存取到的节点 i</strong>。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> startIndex<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 控制树的横向遍历</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    path<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 处理节点</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token function">backtracking</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> k<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 递归，控制树的纵向遍历，注意下一层搜索的起点是 i+1</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    path<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 回溯，撤销处理的节点</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>可以看出 backtracking（递归函数）通过不断调用自己一直往深处遍历，总会遇到叶子节点，遇到了叶子节点就要返回。</p><p>backtracking 的下面部分就是回溯的操作了，撤销本次处理的结果。</p></li></ol><p>组合问题 java 完整代码如下：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span><span class="token punctuation">></span></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 结果集</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> path <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 符合条件的单一结果</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">backtracking</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">,</span> <span class="token keyword">int</span> startIndex<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token comment">// 递归终止条件</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>            res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 注意：这里要 new 一个新的对象，因为 path 是全局变量，会被后续的递归修改</span></pre></td></tr><tr><td data-num="9"></td><td><pre>            <span class="token keyword">return</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token comment">// 单层的搜索过程</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> startIndex<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 控制树的横向遍历</span></pre></td></tr><tr><td data-num="13"></td><td><pre>            path<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 处理节点</span></pre></td></tr><tr><td data-num="14"></td><td><pre>            <span class="token function">backtracking</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> k<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 递归，控制树的纵向遍历，注意下一层搜索的起点是 i+1</span></pre></td></tr><tr><td data-num="15"></td><td><pre>            path<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 回溯，撤销处理的节点</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="18"></td><td><pre></pre></td></tr><tr><td data-num="19"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span><span class="token punctuation">></span></span> <span class="token function">combine</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>        <span class="token function">backtracking</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> k<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>        <span class="token keyword">return</span> res<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="23"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20221225004737160.png" alt="image-20221225004737160"></p><p>还记得我们在<a href="#%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80">回溯算法理论基础</a>中给出的回溯法模板么？</p><p>如下：</p><figure class="highlight text"><figcaption data-lang="text"></figcaption><table><tr><td data-num="1"></td><td><pre>void backtracking(参数) &#123;</pre></td></tr><tr><td data-num="2"></td><td><pre>    if (终止条件) &#123;</pre></td></tr><tr><td data-num="3"></td><td><pre>        存放结果;</pre></td></tr><tr><td data-num="4"></td><td><pre>        return;</pre></td></tr><tr><td data-num="5"></td><td><pre>    &#125;</pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre>    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;</pre></td></tr><tr><td data-num="8"></td><td><pre>        处理节点;</pre></td></tr><tr><td data-num="9"></td><td><pre>        backtracking(路径，选择列表); // 递归</pre></td></tr><tr><td data-num="10"></td><td><pre>        回溯，撤销处理结果</pre></td></tr><tr><td data-num="11"></td><td><pre>    &#125;</pre></td></tr><tr><td data-num="12"></td><td><pre>&#125;</pre></td></tr></table></figure><p><strong>对比一下本题的代码，是不是发现有点像！</strong> 所以有了这个模板，就有解题的大体方向，不至于毫无头绪。</p><h4 id="总结-29"><a class="anchor" href="#总结-29">#</a> 总结</h4><p>组合问题是回溯法解决的经典问题，我们开始的时候给大家列举一个很形象的例子，就是 n 为 100，k 为 50 的话，直接想法就需要 50 层 for 循环。</p><p>从而引出了<strong>回溯法就是解决这种 k 层 for 循环嵌套的问题</strong>。</p><p>然后进一步<strong>把回溯法的搜索过程抽象为树形结构</strong>，可以直观的看出搜索的过程。</p><p>接着用<strong>回溯法三部曲</strong>，逐步分析了函数参数、终止条件和单层搜索的过程。</p><h3 id="77-组合优化"><a class="anchor" href="#77-组合优化">#</a> 77. 组合优化</h3><p>在上一节中，我们通过回溯搜索法，解决了 n 个数中求 k 个数的组合问题。</p><p>文中的回溯法是可以剪枝优化的，本篇我们继续来看一下这个题目。</p><h4 id="剪枝优化"><a class="anchor" href="#剪枝优化">#</a> 剪枝优化</h4><p>我们说过，回溯法虽然是暴力搜索，但也有时候可以有点剪枝优化一下的。</p><p>在遍历的过程中有如下代码：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> startIndex<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 控制树的横向遍历</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    path<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 处理节点</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token function">backtracking</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> k<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 递归，控制树的纵向遍历，注意下一层搜索的起点是 i+1</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    path<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 回溯，撤销处理的节点</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>这个<strong>遍历的范围是可以剪枝优化的</strong>，怎么优化呢？</p><p>来举一个例子，n = 4，k = 4 的话，那么第一层 for 循环的时候，从元素 2 开始的遍历都没有意义了。 在第二层 for 循环，从元素 3 开始的遍历都没有意义了。</p><p>这么说有点抽象，如图所示：</p><p><img data-src="https://img-blog.csdnimg.cn/20210130194335207.png" alt="77.组合4"></p><p>图中每一个节点（图中为矩形），就代表本层的一个 for 循环，那么每一层的 for 循环从第二个数开始遍历的话，都没有意义，都是无效遍历。</p><p><strong>所以，可以剪枝的地方就在递归中每一层的 for 循环所选择的起始位置</strong>。</p><p><strong>如果 for 循环选择的起始位置之后的元素个数 已经不足 我们需要的元素个数了，那么就没有必要搜索了</strong>。</p><p>注意代码中 i，就是 for 循环里选择的起始位置。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> startIndex<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span></pre></td></tr></table></figure><p>接下来看一下优化过程如下：</p><ol><li>已经选择的元素个数：path.size ();</li><li>还需要的元素个数为: k - path.size ();</li><li><strong>在集合 n 中至多要从该起始位置 : <code>n - (k - path.size()) + 1</code> ，开始遍历</strong></li></ol><p>为什么有个 + 1 呢，因为包括起始位置，我们要是一个左闭的集合。</p><p>举个例子，n = 4，k = 3， 目前已经选取的元素个数为 0（path.size 为 0），n - (k - 0) + 1 即 4 - ( 3 - 0) + 1 = 2。</p><p>从 2 开始搜索都是合理的，可以是组合 [2, 3, 4]。</p><p>这里大家想不懂的话，建议也举一个例子，就知道是不是要 + 1 了。</p><p>所以优化之后的 for 循环是：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> startIndex<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n <span class="token operator">-</span> <span class="token punctuation">(</span>k <span class="token operator">-</span> path<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span></pre></td></tr></table></figure><p>剪枝优化后的完整 java 代码如下：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span><span class="token punctuation">></span></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 结果集</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> path <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 符合条件的单一结果</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">backtracking</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">,</span> <span class="token keyword">int</span> startIndex<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token comment">// 递归终止条件</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>            res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 注意：这里要 new 一个新的对象，因为 path 是全局变量，会被后续的递归修改</span></pre></td></tr><tr><td data-num="9"></td><td><pre>            <span class="token keyword">return</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token comment">// 单层的搜索过程（剪枝优化！！！）</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> startIndex<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n <span class="token operator">-</span> <span class="token punctuation">(</span>k <span class="token operator">-</span> path<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 控制树的横向遍历，剪枝优化，只有当剩余的数的个数大于等于 k-path.size () 时，才有必要继续遍历</span></pre></td></tr><tr><td data-num="13"></td><td><pre>            path<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 处理节点</span></pre></td></tr><tr><td data-num="14"></td><td><pre>            <span class="token function">backtracking</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> k<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 递归，控制树的纵向遍历，注意下一层搜索的起点是 i+1</span></pre></td></tr><tr><td data-num="15"></td><td><pre>            path<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 回溯，撤销处理的节点</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="18"></td><td><pre></pre></td></tr><tr><td data-num="19"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span><span class="token punctuation">></span></span> <span class="token function">combine</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>        <span class="token function">backtracking</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> k<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>        <span class="token keyword">return</span> res<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="23"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>时间效率大幅提升：<img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20221225005833667.png" alt="image-20221225005833667"></p><h4 id="总结-30"><a class="anchor" href="#总结-30">#</a> 总结</h4><p>本篇我们对求组合问题的回溯法代码做了剪枝优化，这个优化如果不画图的话，其实不好理解，也不好讲清楚。</p><p>所以我依然是把整个回溯过程抽象为一棵树形结构，然后可以直观的看出，剪枝究竟是剪的哪里。</p><h3 id="216-组合总和-iii"><a class="anchor" href="#216-组合总和-iii">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb21iaW5hdGlvbi1zdW0taWlpLw==">216. 组合总和 III</span></h3><blockquote><p>别看本篇选的是组合总和 III，而不是组合总和，本题和上一篇 77. 组合相比难度刚刚好！</p></blockquote><h4 id="思路-4"><a class="anchor" href="#思路-4">#</a> 思路</h4><p>本题就是在 [1,2,3,4,5,6,7,8,9] 这个集合中找到和为 n 的 k 个数的组合。</p><p>相对于 [77. 组合](#77. 组合)，无非就是多了一个限制，本题是要找到和为 n 的 k 个数的组合，而整个集合已经是固定的了 [1,...,9]。</p><p>想到这一点了，做过 [77. 组合](#77. 组合) 之后，本题是简单一些了。</p><p>本题<strong> k 相当于树的深度，9（因为整个集合就是 9 个数）就是树的宽度</strong>。</p><p>例如 k = 2，n = 4 的话，就是在集合 [1,2,3,4,5,6,7,8,9] 中求 k（个数） = 2, n（和） = 4 的组合。</p><p>选取过程如图：</p><p><img data-src="https://img-blog.csdnimg.cn/20201123195717975.png" alt="216.组合总和III"></p><p>图中，可以看出，只有最后取到集合（1，3）和为 4 符合条件。</p><h4 id="回溯三部曲-2"><a class="anchor" href="#回溯三部曲-2">#</a> 回溯三部曲</h4><ol><li><p><strong>参数</strong>：</p><p>和 [77. 组合](#77. 组合) 一样，依然需要一维数组 path 来存放符合条件的结果，二维数组 result 来存放结果集。</p><p>这里我依然<strong>定义 path 和 result 为全局变量</strong>。</p><p>至于为什么取名为 path？从上面树形结构中，可以看出，结果其实就是一条根节点到叶子节点的路径。</p><p>接下来还需要如下参数：</p><ul><li>**targetSum（int）** 目标和，也就是题目中的 n。</li><li>**k（int）** 就是题目中要求 k 个数的集合。</li><li>**sum（int）** 为已经收集的元素的总和，也就是 path 里元素的总和。</li><li>**startIndex（int）** 为下一层 for 循环搜索的起始位置。</li></ul><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span><span class="token punctuation">></span></span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> path <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">backtracking</span><span class="token punctuation">(</span><span class="token keyword">int</span> targetSum<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">,</span> <span class="token keyword">int</span> sum<span class="token punctuation">,</span> <span class="token keyword">int</span> startIndex<span class="token punctuation">)</span></pre></td></tr></table></figure><p>其实这里 sum 这个参数也可以省略，每次 targetSum 减去选取的元素数值，然后判断如果 targetSum 为 0 了，说明收集到符合条件的结果了，我这里为了直观便于理解，还是加一个 sum 参数。</p><p>还要强调一下，回溯法中递归函数参数很难一次性确定下来，一般先写逻辑，需要啥参数了，填什么参数。</p></li><li><p>终止条件：</p><p>什么时候终止呢？</p><p>在上面已经说了，k 其实就已经限制树的深度，因为就取 k 个元素，树再往下深了没有意义。</p><p>所以<strong>如果 path.size () 和 k 相等</strong>了，就终止。</p><p><strong>如果此时 path 里收集到的元素和（sum） 和 targetSum（就是题目描述的 n）相同</strong>了，就用 result 收集当前的结果。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">if</span> <span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>sum <span class="token operator">==</span> targetSum<span class="token punctuation">)</span> <span class="token comment">// 找到一组解</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        result<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">return</span><span class="token punctuation">;</span> <span class="token comment">// 无论是否找到一组解，都要终止递归</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure></li><li><p><strong>单层搜索过程</strong>：</p><p>本题和 [77. 组合](#77. 组合) 区别之一就是<strong>集合固定的就是 9 个数 [1,...,9]，所以 for 循环固定 i&lt;=9</strong></p><p>如图： <img data-src="https://img-blog.csdnimg.cn/20201123195717975.png" alt="216.组合总和III"></p><p>处理过程就是 path 收集每次选取的元素，相当于树型结构里的边，sum 来统计 path 里元素的总和。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> startIndex<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">9</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 处理节点</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    path<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    sum <span class="token operator">+=</span> i<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token comment">// 递归</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token function">backtracking</span><span class="token punctuation">(</span>targetSum<span class="token punctuation">,</span> k<span class="token punctuation">,</span> sum<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token comment">// 回溯，撤销处理的节点</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    path<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    sum <span class="token operator">-=</span> i<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><strong>别忘了<mark>处理过程 和 回溯过程是一一对应的</mark>，处理有加，回溯就要有减！</strong></p></li></ol><p>完整的 java 代码如下：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span><span class="token punctuation">></span></span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> path <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">backtracking</span><span class="token punctuation">(</span><span class="token keyword">int</span> targetSum<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">,</span> <span class="token keyword">int</span> sum<span class="token punctuation">,</span> <span class="token keyword">int</span> startIndex<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token comment">// 递归终止条件</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>sum <span class="token operator">==</span> targetSum<span class="token punctuation">)</span> <span class="token comment">// 找到一组解</span></pre></td></tr><tr><td data-num="9"></td><td><pre>                result<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>            <span class="token keyword">return</span><span class="token punctuation">;</span> <span class="token comment">// 无论是否找到一组解，都要终止递归</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token comment">// 单层搜索过程</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> startIndex<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">9</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>            <span class="token comment">// 处理节点</span></pre></td></tr><tr><td data-num="15"></td><td><pre>            path<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>            sum <span class="token operator">+=</span> i<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>            <span class="token comment">// 递归</span></pre></td></tr><tr><td data-num="18"></td><td><pre>            <span class="token function">backtracking</span><span class="token punctuation">(</span>targetSum<span class="token punctuation">,</span> k<span class="token punctuation">,</span> sum<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>            <span class="token comment">// 回溯，撤销处理的节点</span></pre></td></tr><tr><td data-num="20"></td><td><pre>            path<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>            sum <span class="token operator">-=</span> i<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="24"></td><td><pre></pre></td></tr><tr><td data-num="25"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span><span class="token punctuation">></span></span> <span class="token function">combinationSum3</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>        <span class="token function">backtracking</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> k<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>        <span class="token keyword">return</span> result<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="29"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20221225141828656.png" alt="image-20221225141828656"></p><h4 id="剪枝"><a class="anchor" href="#剪枝">#</a> 剪枝</h4><p>这道题目，剪枝操作其实是很容易想到了，想必大家看上面的树形图的时候已经想到了。</p><p>如图： <img data-src="https://img-blog.csdnimg.cn/2020112319580476.png" alt="216.组合总和III1"></p><p><strong>已选元素总和如果已经大于 n（图中数值为 4）了，那么往后遍历就没有意义了，直接剪掉</strong>。</p><p>剪枝的地方：</p><ul><li><strong>可以放在<u>递归函数开始</u>的地方</strong>，剪枝代码如下：</li></ul><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">if</span> <span class="token punctuation">(</span>sum <span class="token operator">></span> targetSum<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 剪枝操作</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">return</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><ul><li><strong>可以放在<u>调用递归之前</u></strong>，即放在这里，只不过<strong>要记得把回溯操作给做了</strong></li></ul><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> startIndex<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">9</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 处理节点</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    path<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    sum <span class="token operator">+=</span> i<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token comment">// 剪枝：记得回溯</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>sum <span class="token operator">></span> targetSum<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    	path<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    	sum <span class="token operator">-=</span> i<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token keyword">return</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token comment">// 递归</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token function">backtracking</span><span class="token punctuation">(</span>targetSum<span class="token punctuation">,</span> k<span class="token punctuation">,</span> sum<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token comment">// 回溯，撤销处理的节点</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    path<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    sum <span class="token operator">-=</span> i<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>和 [77. 组合优化](#77. 组合优化) 一样，<strong>for 循环的范围也可以剪枝</strong>， <code>i &lt;= 9 - (k - path.size()) + 1</code> 就可以了。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> startIndex<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">9</span> <span class="token operator">-</span> <span class="token punctuation">(</span>k <span class="token operator">-</span> path<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token comment">//n = 9，即集合大小</span></pre></td></tr></table></figure><p>剪枝后的完整 java 代码如下：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 剪枝优化</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span><span class="token punctuation">></span></span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> path <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">backtracking</span><span class="token punctuation">(</span><span class="token keyword">int</span> targetSum<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">,</span> <span class="token keyword">int</span> sum<span class="token punctuation">,</span> <span class="token keyword">int</span> startIndex<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token comment">// 剪枝</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>sum <span class="token operator">></span> targetSum<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span> <span class="token comment">// 当前路径和已经大于目标值，无需继续搜索</span></pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token comment">// 递归终止条件</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>sum <span class="token operator">==</span> targetSum<span class="token punctuation">)</span> <span class="token comment">// 找到一组解</span></pre></td></tr><tr><td data-num="13"></td><td><pre>                result<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>            <span class="token keyword">return</span><span class="token punctuation">;</span> <span class="token comment">// 无论是否找到一组解，都要终止递归</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token comment">// 单层搜索过程</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> startIndex<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">9</span> <span class="token operator">-</span> <span class="token punctuation">(</span>k <span class="token operator">-</span> path<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 剪枝</span></pre></td></tr><tr><td data-num="18"></td><td><pre>            <span class="token comment">// 处理节点</span></pre></td></tr><tr><td data-num="19"></td><td><pre>            path<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>            sum <span class="token operator">+=</span> i<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>            <span class="token comment">// 递归</span></pre></td></tr><tr><td data-num="22"></td><td><pre>            <span class="token function">backtracking</span><span class="token punctuation">(</span>targetSum<span class="token punctuation">,</span> k<span class="token punctuation">,</span> sum<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>            <span class="token comment">// 回溯，撤销处理的节点</span></pre></td></tr><tr><td data-num="24"></td><td><pre>            path<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>            sum <span class="token operator">-=</span> i<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="28"></td><td><pre></pre></td></tr><tr><td data-num="29"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span><span class="token punctuation">></span></span> <span class="token function">combinationSum3</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>        <span class="token function">backtracking</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> k<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="31"></td><td><pre>        <span class="token keyword">return</span> result<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="33"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20221225143010214.png" alt="image-20221225143010214"></p><h4 id="总结-31"><a class="anchor" href="#总结-31">#</a> 总结</h4><p>开篇就介绍了本题与 [77. 组合](#77. 组合) 的区别，相对来说<strong>加了元素总和的限制</strong>，如果做完 [77. 组合](#77. 组合) 再做本题在合适不过。</p><p>分析完区别，依然<strong>把问题抽象为树形结构</strong>，按照<strong>回溯三部曲</strong>进行讲解，最后给出<strong>剪枝的优化</strong>。</p><p>相信做完本题，大家对组合问题应该有初步了解了。</p><h3 id="17-电话号码的字母组合"><a class="anchor" href="#17-电话号码的字母组合">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sZXR0ZXItY29tYmluYXRpb25zLW9mLWEtcGhvbmUtbnVtYmVyLw==">17. 电话号码的字母组合</span></h3><p>n = 8（集合 [2,3,...,9] 的大小）；k = str.length () ；</p><h4 id="思路-5"><a class="anchor" href="#思路-5">#</a> 思路</h4><p>从示例上来说，输入 &quot;23&quot;，最直接的想法就是两层 for 循环遍历了吧，正好把组合的情况都输出了。</p><p>如果输入 &quot;233&quot; 呢，那么就三层 for 循环，如果 &quot;2333&quot; 呢，就四层 for 循环.......</p><p>大家应该感觉出和 [77. 组合](#77. 组合) 遇到的一样的问题，就是这 for 循环的层数如何写出来，此时又是回溯法登场的时候了。</p><p>理解本题后，要解决如下三个问题：</p><ol><li><strong>数字和字母如何映射</strong></li><li>两个字母就两个 for 循环，三个字符我就三个 for 循环，以此类推，然后发现代码根本写不出来</li><li>输入 1 * #按键等等<strong>异常情况</strong></li></ol><h4 id="数字和字母如何映射"><a class="anchor" href="#数字和字母如何映射">#</a> 数字和字母如何映射</h4><p>可以使用 map 或者定义一个二维数组，例如：string letterMap [10]，来做映射，我这里定义<strong>一个二维数组</strong>，代码如下：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">private</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> letterMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token string">""</span><span class="token punctuation">,</span>		<span class="token comment">// 0</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token string">""</span><span class="token punctuation">,</span>		<span class="token comment">// 1</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token string">"abc"</span><span class="token punctuation">,</span>	<span class="token comment">// 2</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token string">"def"</span><span class="token punctuation">,</span>	<span class="token comment">// 3</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token string">"ghi"</span><span class="token punctuation">,</span>	<span class="token comment">// 4</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token string">"jkl"</span><span class="token punctuation">,</span>	<span class="token comment">// 5</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token string">"mno"</span><span class="token punctuation">,</span> 	<span class="token comment">// 6</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token string">"pqrs"</span><span class="token punctuation">,</span>	<span class="token comment">// 7</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token string">"tuv"</span><span class="token punctuation">,</span> 	<span class="token comment">// 8</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token string">"wxyz"</span> 	<span class="token comment">// 9</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h4 id="回溯法来解决n个for循环的问题"><a class="anchor" href="#回溯法来解决n个for循环的问题">#</a> 回溯法来解决 n 个 for 循环的问题</h4><p>例如：输入：&quot;23&quot;，抽象为树形结构，如图所示：</p><p><img data-src="https://img-blog.csdnimg.cn/20201123200304469.png" alt="17. 电话号码的字母组合"></p><p>图中可以看出<strong>遍历的深度 k，就是输入 &quot;23&quot; 的长度</strong>，而叶子节点就是我们要收集的结果，输出 [&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;]。</p><p>回溯三部曲：</p><ol><li><p>参数：</p><p>首先需要<u>两个全局变量</u>：<strong>一个字符串 s 来收集叶子节点的结果</strong>，然后用<strong>一个字符串数组 result 作为结果集</strong>起来。</p><p>再来看参数，参数指定是有<strong>题目中给的 string digits</strong>，然后还要有一个参数就是<strong> int 型的 index</strong>。</p><p>注意这个 index 可不是 [77. 组合](#77. 组合) 和 [216. 组合总和 III](#216. 组合总和 III) 中的 startIndex 了。</p><p>这个 index 是记录遍历第几个数字了，就是<strong>用来遍历 digits</strong> 的（题目中给出数字字符串），同时 index 也表示树的深度。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 结果集</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">private</span> <span class="token class-name">StringBuilder</span> path_sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 符合条件的单一结果</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">backtracking</span><span class="token punctuation">(</span><span class="token class-name">String</span> digits<span class="token punctuation">,</span> <span class="token keyword">int</span> index<span class="token punctuation">)</span></pre></td></tr></table></figure></li><li><p>终止条件：</p><p>例如输入用例 &quot;23&quot;，两个数字，那么根节点往下递归两层就可以了，叶子节点就是要收集的结果集。</p><p>那么终止条件就是 ** 如果 index 等于 输入的数字个数（digits.size）** 了（本来 index 就是用来遍历 digits 的）。</p><p>然后收集结果，结束本层递归。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">==</span> digits<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    result<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>path_sb<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 存放结果</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">return</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure></li><li><p>单层搜索过程：</p><p>首先要<strong>取 index 指向的数字，并找到对应的字符集</strong>（手机键盘的字符集）。</p><p>然后<strong> for 循环来处理这个字符集</strong>，代码如下：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">String</span> letters <span class="token operator">=</span> letterMap<span class="token punctuation">[</span>digits<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token char">'0'</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 获取当前数字对应的字母集</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> letters<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token comment">// 处理节点</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    path_sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>letters<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token comment">// 递归</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token function">backtracking</span><span class="token punctuation">(</span>digits<span class="token punctuation">,</span> index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token comment">// 回溯，撤销处理的节点</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    path_sb<span class="token punctuation">.</span><span class="token function">deleteCharAt</span><span class="token punctuation">(</span>path_sb<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><strong>注意这里 for 循环，可不像是在 [216. 组合总和 III](#216. 组合总和 III) 中从 startIndex 开始遍历的</strong>。</p><p><strong>因为本题每一个数字代表的是不同集合，也就是求不同集合之间的组合，而 [77. 组合](#77. 组合) 和 [216. 组合总和 III](#216. 组合总和 III) 都是求同一个集合中的组合！</strong></p></li></ol><p>注意：输入 1 * #按键等等异常情况</p><p>代码中最好考虑这些异常情况，但题目的测试数据中应该没有异常情况的数据，所以我就没有加了。</p><p><strong>但是要知道会有这些异常，如果是现场面试中，一定要考虑到！</strong></p><p>完整的 java 代码如下：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">private</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> letterMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">&#123;</span><span class="token string">""</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token string">"abc"</span><span class="token punctuation">,</span> <span class="token string">"def"</span><span class="token punctuation">,</span> <span class="token string">"ghi"</span><span class="token punctuation">,</span> <span class="token string">"jkl"</span><span class="token punctuation">,</span> <span class="token string">"mno"</span><span class="token punctuation">,</span> <span class="token string">"pqrs"</span><span class="token punctuation">,</span> <span class="token string">"tuv"</span><span class="token punctuation">,</span> <span class="token string">"wxyz"</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">private</span> <span class="token class-name">StringBuilder</span> path_sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">backtracking</span><span class="token punctuation">(</span><span class="token class-name">String</span> digits<span class="token punctuation">,</span> <span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token comment">// 递归终止条件</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">==</span> digits<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>            result<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>path_sb<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 存放一组解</span></pre></td></tr><tr><td data-num="11"></td><td><pre>            <span class="token keyword">return</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token comment">// 单层搜索过程</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token class-name">String</span> letters <span class="token operator">=</span> letterMap<span class="token punctuation">[</span>digits<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token char">'0'</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 获取当前数字对应的字母集</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> letters<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>            <span class="token comment">// 处理节点</span></pre></td></tr><tr><td data-num="17"></td><td><pre>            path_sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>letters<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>            <span class="token comment">// 递归</span></pre></td></tr><tr><td data-num="19"></td><td><pre>            <span class="token function">backtracking</span><span class="token punctuation">(</span>digits<span class="token punctuation">,</span> index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>            <span class="token comment">// 回溯，撤销处理的节点</span></pre></td></tr><tr><td data-num="21"></td><td><pre>            path_sb<span class="token punctuation">.</span><span class="token function">deleteCharAt</span><span class="token punctuation">(</span>path_sb<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="24"></td><td><pre></pre></td></tr><tr><td data-num="25"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> <span class="token function">letterCombinations</span><span class="token punctuation">(</span><span class="token class-name">String</span> digits<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>digits<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>            <span class="token keyword">return</span> result<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>        <span class="token function">backtracking</span><span class="token punctuation">(</span>digits<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>        <span class="token keyword">return</span> result<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="31"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="32"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20221225151218173.png" alt="image-20221225151218173"></p><h4 id="总结-32"><a class="anchor" href="#总结-32">#</a> 总结</h4><p>本篇将题目的三个要点一一列出，并重点强调了和前面讲解过的 [77. 组合](#77. 组合) 和 [216. 组合总和 III](#216. 组合总和 III) 的区别，本题是多个集合求组合，所以在回溯的搜索过程中，都有一些细节需要注意的。</p><p>其实本题不算难，但也处处是细节，大家还要自己亲自动手写一写。</p><h3 id="回溯周末总结"><a class="anchor" href="#回溯周末总结">#</a> 回溯周末总结</h3><h4 id="周一-5"><a class="anchor" href="#周一-5">#</a> 周一</h4><p>在<a href="#%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80">回溯算法理论基础</a>中介绍了什么是回溯，回溯法的效率，回溯法解决的问题以及回溯法模板。</p><p><strong>回溯是递归的副产品，只要有递归就会有回溯</strong>。</p><p>回溯法就是暴力搜索，并不是什么高效的算法，最多在剪枝一下。</p><p>回溯算法能解决如下问题：</p><ul><li>组合问题：N 个数里面按一定规则找出 k 个数的集合</li><li>排列问题：N 个数按一定规则全排列，有几种排列方式</li><li>切割问题：一个字符串按一定规则有几种切割方式</li><li>子集问题：一个 N 个数的集合里有多少符合条件的子集</li><li>棋盘问题：N 皇后，解数独等等</li></ul><p>是不是感觉回溯算法有点厉害了。</p><p>回溯法确实不好理解，所以需要把回溯法抽象为一个图形来理解就容易多了，每一道回溯法的题目都可以抽象为树形结构。</p><p>针对很多同学都写不好回溯，我在<a href="#%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80">回溯算法理论基础</a>用回溯三部曲，分析了回溯算法，并给出了回溯法的模板。</p><p>这个模板会伴随整个回溯法系列！</p><h4 id="周二-5"><a class="anchor" href="#周二-5">#</a> 周二</h4><p>在 [77. 组合](#77. 组合) 中，我们开始用回溯法解决第一道题目，组合问题。</p><p>我在文中开始的时候给大家列举 k 层 for 循环例子，进而得出都是同样是暴力解法，为什么要用回溯法。</p><p><strong>此时大家应该深有体会回溯法的魅力，用递归控制 for 循环嵌套的数量！</strong></p><p>本题我把回溯问题抽象为树形结构，可以直观的看出其搜索的过程：<strong>for 循环横向遍历，递归纵向遍历，回溯不断调整结果集</strong>。</p><h4 id="周三-5"><a class="anchor" href="#周三-5">#</a> 周三</h4><p>针对 [77. 组合](#77. 组合) 还可以做剪枝的操作。</p><p>在 [77. 组合优化](#77. 组合优化) 中把回溯法代码做了<strong>剪枝优化</strong>，在文中我依然把问题抽象为一个树形结构，大家可以一目了然剪的究竟是哪里。</p><p><strong>剪枝精髓是：for 循环在寻找起点的时候要有一个范围，如果这个起点到集合终止之间的元素已经不够 题目要求的 k 个元素了，就没有必要搜索了</strong>。</p><h4 id="周四-5"><a class="anchor" href="#周四-5">#</a> 周四</h4><p>在 [216. 组合总和 III](#216. 组合总和 III) 中，相当于 [77. 组合](#77. 组合) 加了一个元素总和的限制。</p><p>整体思路还是一样的，本题的剪枝会好想一些，即：<strong>已选元素总和如果已经大于 n（题中要求的和）了，那么往后遍历就没有意义了，直接剪掉</strong>。</p><p>在本题中，依然还可以有一个剪枝，就是 [77. 组合优化](#77. 组合优化) 中提到的，<strong>对 for 循环选择的起始范围的剪枝</strong>。</p><p>所以，剪枝的代码，可以把 for 循环，加上 <code>i &lt;= 9 - (k - path.size()) + 1</code> 的限制！</p><p>组合总和问题还有一些花样，下周还会介绍到。</p><h4 id="周五-5"><a class="anchor" href="#周五-5">#</a> 周五</h4><p>在 [17. 电话号码的字母组合](#17. 电话号码的字母组合) 中，开始用多个集合来求组合，还是熟悉的模板题目，但是有一些细节。</p><p>例如这里 for 循环，可不像是在 [77. 组合](#77. 组合) 和 [216. 组合总和 III](#216. 组合总和 III) 中从 startIndex 开始遍历的。</p><p><strong>因为本题每一个数字代表的是<u>不同集合</u>，也就是求不同集合之间的组合，而 [77. 组合](#77. 组合) 和 [216. 组合总和 III](#216. 组合总和 III) 都是是求同一个集合中的组合！</strong></p><p>如果大家在现场面试的时候，一定要注意各种输入异常的情况，例如本题输入 1 * #按键。</p><p>其实本题不算难，但也处处是细节，还是要反复琢磨。</p><h4 id="周六-5"><a class="anchor" href="#周六-5">#</a> 周六</h4><p>因为之前链表系列没有写总结，虽然链表系列已经是两个月前的事情，但还是有必要补一下。</p><p>所以给出<a href="#%E9%93%BE%E8%A1%A8%E6%80%BB%E7%BB%93%E7%AF%87">链表总结篇</a>，这里对之前链表理论基础和经典题目进行了总结。</p><p>同时对 [142. 环形链表 II](#142. 环形链表 II) 中求环入口的问题又进行了补充证明，可以说把环形链表的方方面面都讲的很通透了，大家如果没有做过环形链表的题目一定要去做一做。</p><h4 id="总结-33"><a class="anchor" href="#总结-33">#</a> 总结</h4><p>相信通过这一周对回溯法的学习，大家已经掌握其题本套路了，也不会对回溯法那么畏惧了。</p><p>回溯法抽象为树形结构后，其遍历过程就是：<strong>for 循环横向遍历，递归纵向遍历，回溯不断调整结果集</strong>。</p><p>这个是我做了很多回溯的题目，不断摸索其规律才总结出来的。</p><p>对于回溯法的整体框架，网上搜的文章这块一般都说不清楚，按照天上掉下来的代码对着讲解，不知道究竟是怎么来的，也不知道为什么要这么写。</p><p>所以，录友们刚开始学回溯法，起跑姿势就很标准了，哈哈。</p><p>下周依然是回溯法，难度又要上升一个台阶了。</p><h3 id="39-组合总和"><a class="anchor" href="#39-组合总和">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb21iaW5hdGlvbi1zdW0v">39. 组合总和</span></h3><p>题目中的<strong>无限制重复被选取，吓得我赶紧想想 出现 0 可咋办</strong>，然后看到下面提示：2 &lt;= candidates [i] &lt;= 40，我就放心了。</p><p>本题和 [77. 组合](#77. 组合)，[216. 组合总和 III](#216. 组合总和 III) 的区别是：本题没有数量要求，可以无限重复，但是有总和的限制，所以间接的也是有个数的限制。</p><p>本题搜索的过程抽象成树形结构如下：</p><p><img data-src="https://img-blog.csdnimg.cn/20201223170730367.png" alt="39.组合总和"> 注意图中叶子节点的返回条件，<strong>因为本题没有组合数量要求，仅仅是总和的限制，所以递归没有层数的限制</strong>，只要选取的元素总和超过 target，就返回！</p><p>而在 [77. 组合](#77. 组合)，[216. 组合总和 III](#216. 组合总和 III) 中都可以知道要递归 K 层，因为要取 k 个元素的组合。</p><h4 id="回溯三部曲-3"><a class="anchor" href="#回溯三部曲-3">#</a> 回溯三部曲</h4><ol><li><p>参数：</p><p>这里依然是定义<strong>两个全局变量</strong>，二维数组 result 存放结果集，数组 path 存放符合条件的结果。（这两个变量可以作为函数参数传入）</p><p>首先是<strong>题目中给出的参数</strong>，集合 candidates, 和目标值 target。</p><p>此外我还定义了<strong> int 型的 sum 变量</strong>来统计单一结果 path 里的总和，其实这个 sum 也可以不用，用 target 做相应的减法就可以了，最后如何 target==0 就说明找到符合的结果了，但为了代码逻辑清晰，我依然用了 sum。</p><p><strong>本题还需要 startIndex 来控制 for 循环的起始位置，对于组合问题，什么时候需要 startIndex 呢？</strong></p><ul><li><p>如果是一个集合来求组合的话，就需要 startIndex，例如：[77. 组合](#77. 组合)，[216. 组合总和 III](#216. 组合总和 III)。</p></li><li><p>如果是多个集合取组合，各个集合之间相互不影响，那么就不用 startIndex，例如：[17. 电话号码的字母组合](#17. 电话号码的字母组合)</p></li></ul><p><strong>注意以上我只是说求组合的情况，如果是排列问题，又是另一套分析的套路，后面我再讲解排列的时候就重点介绍</strong>。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span><span class="token punctuation">></span></span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> path <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">backtracking</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> candidates<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">,</span> <span class="token keyword">int</span> sum<span class="token punctuation">,</span> <span class="token keyword">int</span> startIndex<span class="token punctuation">)</span></pre></td></tr></table></figure></li><li><p>递归终止条件：</p><p>在如下树形结构中：</p><p><img data-src="https://img-blog.csdnimg.cn/20201223170730367.png" alt="39.组合总和"></p><p>从叶子节点可以清晰看到，终止只有两种情况：</p><ul><li><p>sum 大于 target 时，直接返回</p></li><li><p>sum 等于 target 时，收集结果</p></li></ul><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">if</span> <span class="token punctuation">(</span>sum <span class="token operator">></span> target<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span> <span class="token comment">// 剪枝</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">if</span> <span class="token punctuation">(</span>sum <span class="token operator">==</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 找到一组解</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    result<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">return</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure></li><li><p>单层搜索的过程：</p><p>单层 for 循环依然是从 startIndex 开始，搜索 candidates 集合。</p><p><strong>注意本题和 [77. 组合](#77. 组合)，[216. 组合总和 III](#216. 组合总和 III) 的一个区别是：本题元素为可重复选取的</strong>。</p><p>如何重复选取呢，看代码，注释部分：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> startIndex<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> candidates<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 处理节点</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    path<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>candidates<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    sum <span class="token operator">+=</span> candidates<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token comment">// 递归</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token function">backtracking</span><span class="token punctuation">(</span>candidates<span class="token punctuation">,</span> target<span class="token punctuation">,</span> sum<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 注意：这里是 i，而不是 i + 1，因为可以重复选取</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token comment">// 回溯，撤销处理的节点</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    path<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    sum <span class="token operator">-=</span> candidates<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure></li></ol><p>完整的 java 代码如下：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span><span class="token punctuation">></span></span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> path <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">backtracking</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> candidates<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">,</span> <span class="token keyword">int</span> sum<span class="token punctuation">,</span> <span class="token keyword">int</span> startIndex<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token comment">// 递归终止条件</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>sum <span class="token operator">></span> target<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span> <span class="token comment">// 剪枝</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>sum <span class="token operator">==</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 找到一组解</span></pre></td></tr><tr><td data-num="9"></td><td><pre>            result<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>            <span class="token keyword">return</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token comment">// 单层搜索过程</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> startIndex<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> candidates<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>            <span class="token comment">// 处理节点</span></pre></td></tr><tr><td data-num="16"></td><td><pre>            path<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>candidates<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>            sum <span class="token operator">+=</span> candidates<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>            <span class="token comment">// 递归</span></pre></td></tr><tr><td data-num="19"></td><td><pre>            <span class="token function">backtracking</span><span class="token punctuation">(</span>candidates<span class="token punctuation">,</span> target<span class="token punctuation">,</span> sum<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 注意：这里是 i，而不是 i + 1，因为可以重复选取</span></pre></td></tr><tr><td data-num="20"></td><td><pre>            <span class="token comment">// 回溯，撤销处理的节点</span></pre></td></tr><tr><td data-num="21"></td><td><pre>            path<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>            sum <span class="token operator">-=</span> candidates<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="25"></td><td><pre></pre></td></tr><tr><td data-num="26"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span><span class="token punctuation">></span></span> <span class="token function">combinationSum</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> candidates<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>        <span class="token function">backtracking</span><span class="token punctuation">(</span>candidates<span class="token punctuation">,</span> target<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>        <span class="token keyword">return</span> result<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="30"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20221225220754524.png" alt="image-20221225220754524"></p><h4 id="剪枝优化-2"><a class="anchor" href="#剪枝优化-2">#</a> 剪枝优化</h4><p>在这个树形结构中：</p><p><img data-src="https://img-blog.csdnimg.cn/20201223170730367.png" alt="39.组合总和"></p><p>以及上面的版本一的代码大家可以看到，对于 sum 已经大于 target 的情况，其实是依然进入了下一层递归，只是下一层递归结束判断的时候，会判断 sum &gt; target 的话就返回。</p><p>其实<strong>如果已经知道下一层的 sum 会大于 target，就没有必要进入下一层递归了</strong>。</p><p>那么可以在 for 循环的搜索范围上做做文章了。</p><p><strong>对总集合排序</strong>之后，如果下一层的 sum（就是本层的 sum + candidates [i]）已经大于 target，就可以结束本轮 for 循环的遍历。</p><p>如图：</p><p><img data-src="https://img-blog.csdnimg.cn/20201223170809182.png" alt="39.组合总和1"></p><p>for 循环剪枝代码如下：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> startIndex<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> candidates<span class="token punctuation">.</span>length <span class="token operator">&amp;&amp;</span> sum <span class="token operator">+</span> candidates<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> target<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span></pre></td></tr></table></figure><p>优化后的整体 java 代码如下：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 剪枝优化</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span><span class="token punctuation">></span></span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> path <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">backtracking</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> candidates<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">,</span> <span class="token keyword">int</span> sum<span class="token punctuation">,</span> <span class="token keyword">int</span> startIndex<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token comment">// 递归终止条件</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>sum <span class="token operator">==</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 找到一组解</span></pre></td></tr><tr><td data-num="9"></td><td><pre>            result<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>            <span class="token keyword">return</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token comment">// 单层搜索过程</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> startIndex<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>             i <span class="token operator">&lt;</span> candidates<span class="token punctuation">.</span>length <span class="token operator">&amp;&amp;</span> sum <span class="token operator">+</span> candidates<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> target<span class="token punctuation">;</span> <span class="token comment">// !! 剪枝！！</span></pre></td></tr><tr><td data-num="16"></td><td><pre>             i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>            <span class="token comment">// 处理节点</span></pre></td></tr><tr><td data-num="18"></td><td><pre>            path<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>candidates<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>            sum <span class="token operator">+=</span> candidates<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>            <span class="token comment">// 递归</span></pre></td></tr><tr><td data-num="21"></td><td><pre>            <span class="token function">backtracking</span><span class="token punctuation">(</span>candidates<span class="token punctuation">,</span> target<span class="token punctuation">,</span> sum<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 注意：这里是 i，而不是 i + 1，因为可以重复选取</span></pre></td></tr><tr><td data-num="22"></td><td><pre>            <span class="token comment">// 回溯，撤销处理的节点</span></pre></td></tr><tr><td data-num="23"></td><td><pre>            path<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>            sum <span class="token operator">-=</span> candidates<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="27"></td><td><pre></pre></td></tr><tr><td data-num="28"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span><span class="token punctuation">></span></span> <span class="token function">combinationSum</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> candidates<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>        <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>candidates<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// !! 对数组进行排序，方便剪枝！！</span></pre></td></tr><tr><td data-num="30"></td><td><pre>        <span class="token function">backtracking</span><span class="token punctuation">(</span>candidates<span class="token punctuation">,</span> target<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="31"></td><td><pre>        <span class="token keyword">return</span> result<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="33"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20221225221613259.png" alt="image-20221225221613259"></p><h4 id="总结-34"><a class="anchor" href="#总结-34">#</a> 总结</h4><p>本题和我们之前讲过的 [77. 组合](#77. 组合)，[216. 组合总和 III](#216. 组合总和 III) 有两点不同：</p><ul><li>组合没有数量要求</li><li>元素可无限重复选取</li></ul><p>针对这两个问题，我都做了详细的分析。</p><p>并且给出了<strong>对于组合问题，什么时候用 startIndex</strong>，什么时候不用，并用 [17. 电话号码的字母组合](#17. 电话号码的字母组合) 做了对比。</p><p>最后还给出了本题的<strong>剪枝优化</strong>，这个优化如果是初学者的话并不容易想到。</p><p><strong>在求和问题中，<mark>排序之后加剪枝</mark>是常见的套路！</strong></p><p>可以看出我写的文章都会大量引用之前的文章，就是要不断作对比，分析其差异，然后给出代码解决的方法，这样才能彻底理解题目的本质与难点。</p><h3 id="40-组合总和-ii"><a class="anchor" href="#40-组合总和-ii">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb21iaW5hdGlvbi1zdW0taWkv">40. 组合总和 II</span></h3><blockquote><p>这篇可以说是全网把组合问题如何<strong>去重</strong>，讲的最清晰的了！</p></blockquote><h4 id="思路-6"><a class="anchor" href="#思路-6">#</a> 思路</h4><p>这道题目和 [39. 组合总和](#39. 组合总和) 如下区别：</p><ol><li>本题 candidates 中的每个数字在每个组合中只能使用一次。</li><li>本题数组 candidates 的<strong>元素是有重复的</strong>，而 [39. 组合总和](#39. 组合总和) 是无重复元素的数组 candidates</li></ol><p>最后本题和 [39. 组合总和](#39. 组合总和) 要求一样，解集不能包含重复的组合。</p><p><strong>本题的难点在于区别 2 中：集合（数组 candidates）有重复元素，但还不能有重复的组合</strong>。</p><p>一些同学可能想了：我把所有组合求出来，再用 set 或者 map 去重，这么做很容易超时！</p><p>所以要在搜索的过程中就去掉重复组合。</p><p>很多同学在去重的问题上想不明白，其实很多题解也没有讲清楚，反正代码是能过的，感觉是那么回事，稀里糊涂的先把题目过了。</p><p>这个去重为什么很难理解呢，<strong>所谓去重，其实就是使用过的元素不能重复选取。</strong> 这么一说好像很简单！</p><p>都知道组合问题可以抽象为树形结构，那么 “使用过” 在这个树形结构上是有两个维度的，一个维度是<u>同一树枝上</u>使用过，一个维度是<u>同一树层上</u>使用过。<strong>没有理解这两个层面上的 “使用过” 是造成大家没有彻底理解去重的根本原因。</strong></p><p>那么问题来了，我们是要同一树层上使用过，还是同一树枝上使用过呢？</p><p>回看一下题目，元素在同一个组合内是可以重复的，怎么重复都没事，但两个组合不能相同。</p><p><strong>所以我们要去重的是同一树层上的 “使用过”，同一树枝上的都是一个组合里的元素，不用去重</strong>。</p><p>为了理解去重我们来举一个例子，candidates = [1, 1, 2], target = 3，（方便起见 candidates 已经排序了）</p><p><strong>强调一下，树层去重的话，需要对数组排序！</strong></p><p>选择过程树形结构如图所示：</p><p><img data-src="https://img-blog.csdnimg.cn/20201123202736384.png" alt="40.组合总和II"></p><p>可以看到图中，每个节点相对于 [39. 组合总和](#39. 组合总和) 我多加了 **<mark>used 数组</mark> **，这个 used 数组下面会重点介绍。</p><h4 id="回溯三部曲-4"><a class="anchor" href="#回溯三部曲-4">#</a> 回溯三部曲</h4><ol><li><p>参数：</p><p>与 [39. 组合总和](#39. 组合总和) 套路相同，此题还需要加一个<strong> bool 型数组 used</strong>，用来记录同一树枝上的元素是否使用过。</p><p>这个集合去重的重任就是 used 来完成的。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span><span class="token punctuation">></span></span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> path <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">backtracking</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> candidates<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">,</span> <span class="token keyword">int</span> sum<span class="token punctuation">,</span> <span class="token keyword">int</span> startIndex<span class="token punctuation">,</span> <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span> used<span class="token punctuation">)</span></pre></td></tr></table></figure></li><li><p>递归终止条件：</p><p>与 [39. 组合总和](#39. 组合总和) 相同，终止条件为 <code>sum &gt; target</code> 和 <code>sum == target</code> 。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">if</span><span class="token punctuation">(</span>sum <span class="token operator">></span> target<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span> <span class="token comment">// 可以忽略</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">if</span><span class="token punctuation">(</span>sum <span class="token operator">==</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    result<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">return</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><code>sum &gt; target</code> 这个条件其实可以省略，因为在递归单层遍历的时候，会有剪枝的操作，下面会介绍到。</p></li><li><p>单层的搜索过程：</p><p>这里与 [39. 组合总和](#39. 组合总和) 最大的不同就是要 **<mark> 去重</mark> ** 了。</p><p>前面我们提到：要去重的是 “同一树层上的使用过”，如何判断同一树层上元素（相同的元素）是否使用过了呢。</p><p><strong>如果 <code>candidates[i] == candidates[i - 1]</code> 并且 <code>used[i - 1] == false</code> ，就说明：前一个树枝，使用了 candidates [i - 1]，也就是说同一树层使用过 candidates [i - 1]</strong>。</p><p>此时 for 循环里就应该做 continue 的操作。</p><p>这块比较抽象，如图：</p><p><img data-src="https://img-blog.csdnimg.cn/20201123202817973.png" alt="40.组合总和II1"></p><p>我在图中将 used 的变化用橘黄色标注上，可以看出在 candidates [i] == candidates [i - 1] 相同的情况下：</p><ul><li>used [i - 1] == true，说明同一树枝 candidates [i - 1] 使用过</li><li>used [i - 1] == false，说明同一树层 candidates [i - 1] 使用过</li></ul><p>可能有的录友想，为什么 used [i - 1] == false 就是同一树层呢，因为同一树层，used [i - 1] == false 才能表示，当前取的 candidates [i] 是从 candidates [i - 1] 回溯而来的。</p><p>而 used [i - 1] == true，说明是进入下一层递归，去下一个数，所以是树枝上，如图所示：</p><p><img data-src="https://code-thinking-1253855093.file.myqcloud.com/pics/20221021163812.png" alt="img"></p><p><strong>这块去重的逻辑很抽象，网上搜的题解基本没有能讲清楚的，如果大家之前思考过这个问题或者刷过这道题目，看到这里一定会感觉通透了很多！</strong></p><p>那么单层搜索的逻辑代码如下：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 单层搜索的过程</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> startIndex<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> candidates<span class="token punctuation">.</span>length <span class="token operator">&amp;&amp;</span> sum <span class="token operator">+</span> candidates<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> target<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 剪枝</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token comment">// 去重，当 candidates [i] == candidates [i - 1] 时：</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token comment">//- 如果 used [i - 1] == true，说明在上一层搜索中，candidates [i - 1] 已经被使用过了，是在同一树枝上，那么在本层搜索中，candidates [i] 也可以使用</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token comment">//- 如果 used [i - 1] == false，说明在上一层搜索中，candidates [i - 1] 没有被使用过，是在同一树层上，那么在本层搜索中，candidates [i] 不能使用</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">>=</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> candidates<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> candidates<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> used<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token boolean">false</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token keyword">continue</span><span class="token punctuation">;</span> <span class="token comment">// 对于同一树层上的节点，如果前一个节点和当前节点值相同，且前一个节点未使用过，那么当前节点也不能使用</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token comment">// 处理节点</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    path<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>candidates<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    sum <span class="token operator">+=</span> candidates<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    used<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token comment">// 递归。和 39. 组合总和的区别 1：这里 startIndex 是 i + 1，每个数字在每个组合中只能使用一次</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token function">backtracking</span><span class="token punctuation">(</span>candidates<span class="token punctuation">,</span> target<span class="token punctuation">,</span> sum<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> used<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token comment">// 回溯，撤销处理的节点</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    path<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    sum <span class="token operator">-=</span> candidates<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    used<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><strong>注意 <code>sum + candidates[i] &lt;= target</code> 为剪枝操作，在 [39. 组合总和](#39. 组合总和) 有讲解过！</strong></p></li></ol><p>完整的 java 代码如下：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span><span class="token punctuation">></span></span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> path <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">backtracking</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> candidates<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">,</span> <span class="token keyword">int</span> sum<span class="token punctuation">,</span> <span class="token keyword">int</span> startIndex<span class="token punctuation">,</span> <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span> used<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token comment">// 递归终止条件</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>sum <span class="token operator">></span> target<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span> <span class="token comment">// 可以忽略，因为下面有剪枝</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>sum <span class="token operator">==</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>            result<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>            <span class="token keyword">return</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token comment">// 单层搜索的过程</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> startIndex<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> candidates<span class="token punctuation">.</span>length <span class="token operator">&amp;&amp;</span> sum <span class="token operator">+</span> candidates<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> target<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 剪枝</span></pre></td></tr><tr><td data-num="14"></td><td><pre>            <span class="token comment">// 去重，当 candidates [i] == candidates [i - 1] 时：</span></pre></td></tr><tr><td data-num="15"></td><td><pre>            <span class="token comment">//- 如果 used [i - 1] == true，说明在上一层搜索中，candidates [i - 1] 已经被使用过了，是在同一树枝上，那么在本层搜索中，candidates [i] 也可以使用</span></pre></td></tr><tr><td data-num="16"></td><td><pre>            <span class="token comment">//- 如果 used [i - 1] == false，说明在上一层搜索中，candidates [i - 1] 没有被使用过，是在同一树层上，那么在本层搜索中，candidates [i] 不能使用</span></pre></td></tr><tr><td data-num="17"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">>=</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> candidates<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> candidates<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> used<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token boolean">false</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="18"></td><td><pre>                <span class="token keyword">continue</span><span class="token punctuation">;</span> <span class="token comment">// 对于同一树层上的节点，如果前一个节点和当前节点值相同，且前一个节点未使用过，那么当前节点也不能使用</span></pre></td></tr><tr><td data-num="19"></td><td><pre></pre></td></tr><tr><td data-num="20"></td><td><pre>            <span class="token comment">// 处理节点</span></pre></td></tr><tr><td data-num="21"></td><td><pre>            path<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>candidates<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>            sum <span class="token operator">+=</span> candidates<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>            used<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>            <span class="token comment">// 递归。和 39. 组合总和的区别 1：这里 startIndex 是 i + 1，每个数字在每个组合中只能使用一次</span></pre></td></tr><tr><td data-num="25"></td><td><pre>            <span class="token function">backtracking</span><span class="token punctuation">(</span>candidates<span class="token punctuation">,</span> target<span class="token punctuation">,</span> sum<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> used<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>            <span class="token comment">// 回溯，撤销处理的节点</span></pre></td></tr><tr><td data-num="27"></td><td><pre>            path<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>            sum <span class="token operator">-=</span> candidates<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>            used<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="31"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="32"></td><td><pre></pre></td></tr><tr><td data-num="33"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span><span class="token punctuation">></span></span> <span class="token function">combinationSum2</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> candidates<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="34"></td><td><pre>        <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span> used <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">boolean</span><span class="token punctuation">[</span>candidates<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 记录 candidates 中的元素是否被使用过</span></pre></td></tr><tr><td data-num="35"></td><td><pre></pre></td></tr><tr><td data-num="36"></td><td><pre>        <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>candidates<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 排序，让相同的元素相邻，方便去重</span></pre></td></tr><tr><td data-num="37"></td><td><pre>        <span class="token function">backtracking</span><span class="token punctuation">(</span>candidates<span class="token punctuation">,</span> target<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> used<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="38"></td><td><pre>        <span class="token keyword">return</span> result<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="39"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="40"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h4 id="总结-35"><a class="anchor" href="#总结-35">#</a> 总结</h4><p>本题同样是求组合总和，但就是因为其数组 candidates 有重复元素，而要求不能有重复的组合，所以相对于 [39. 组合总和](#39. 组合总和) 难度提升了不少。</p><p><strong>关键是去重的逻辑，代码很简单，网上一搜一大把，但几乎没有能把这块代码含义讲明白的，基本都是给出代码，然后说这就是去重了，究竟怎么个去重法也是模棱两可</strong>。</p><p>所以 Carl 有必要把去重的这块彻彻底底的给大家讲清楚，<strong>就连 “树层去重” 和 “树枝去重” 都是我自创的词汇，希望对大家理解有帮助！</strong></p><h3 id="131-分割回文串"><a class="anchor" href="#131-分割回文串">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9wYWxpbmRyb21lLXBhcnRpdGlvbmluZy8=">☆131. 分割回文串</span></h3><blockquote><p>切割问题其实是一种组合问题！</p></blockquote><h4 id="思路-7"><a class="anchor" href="#思路-7">#</a> 思路</h4><p>本题这涉及到两个关键问题：</p><ol><li>切割问题，有不同的切割方式</li><li>判断回文</li></ol><p>相信这里不同的切割方式可以搞懵很多同学了。</p><p>这种题目，想用 for 循环暴力解法，可能都不那么容易写出来，所以要换一种暴力的方式，就是回溯。</p><p>一些同学可能想不清楚 回溯究竟是如何切割字符串呢？</p><p>我们来分析一下切割，<strong>其实切割问题类似组合问题</strong>。</p><p>例如对于字符串 abcdef：</p><ul><li>组合问题：选取一个 a 之后，在 bcdef 中再去选取第二个，选取 b 之后在 cdef 中再选取第三个.....。</li><li>切割问题：切割一个 a 之后，在 bcdef 中再去切割第二段，切割 b 之后在 cdef 中再切割第三段.....。</li></ul><p>感受出来了不？</p><p>所以切割问题，也可以抽象为一棵树形结构，如图：</p><p><img data-src="https://code-thinking.cdn.bcebos.com/pics/131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.jpg" alt="131.分割回文串"></p><p>递归用来纵向遍历，for 循环用来横向遍历，切割线（就是图中的红线）切割到字符串的结尾位置，说明找到了一个切割方法。</p><p>此时可以发现，切割问题的回溯搜索的过程和组合问题的回溯搜索的过程是差不多的。</p><h4 id="回溯三部曲-5"><a class="anchor" href="#回溯三部曲-5">#</a> 回溯三部曲</h4><ol><li><p>参数：</p><p>全局变量数组 path 存放切割后回文的子串，二维数组 result 存放结果集。 （这两个参数可以放到函数参数里）</p><p>本题递归函数参数还需要 startIndex，因为切割过的地方，不能重复切割，和组合问题也是保持一致的。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span><span class="token punctuation">></span></span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> path <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">backtracking</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">,</span> <span class="token keyword">int</span> startIndex<span class="token punctuation">)</span></pre></td></tr></table></figure></li><li><p>递归终止条件：</p><p><img data-src="https://code-thinking.cdn.bcebos.com/pics/131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.jpg" alt="131.分割回文串"></p><p>从树形结构的图中可以看出：<strong>切割线切到了字符串最后面</strong>，说明找到了一种切割方法，此时就是本层递归的终止条件。</p><p>那么在代码里什么是切割线呢？</p><p>在处理组合问题的时候，递归参数需要传入 startIndex，表示下一轮递归遍历的起始位置，<strong>这个 startIndex 就是切割线</strong>。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 递归终止条件：startIndex 超过字符串长度</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">if</span><span class="token punctuation">(</span>startIndex <span class="token operator">>=</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    result<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">return</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure></li><li><p>单层搜索的过程：</p><p><strong>来看看在递归循环中如何截取子串呢？</strong></p><p>在 <code>for (int i = startIndex; i &lt; s.size(); i++)</code> 循环中，我们 定义了起始位置 startIndex，那么 [startIndex, i] 就是要截取的子串。</p><p>首先判断这个子串是不是回文，如果是回文，就加入在 <code>vector&lt;string&gt; path</code> 中，path 用来记录切割过的回文子串。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 单层搜索过程</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> startIndex<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token comment">// 判断 [startIndex, i] 是否为回文串</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isPalindrome</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> startIndex<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">continue</span><span class="token punctuation">;</span> <span class="token comment">// 不是回文串，跳过</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 是回文串</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token comment">// 处理节点</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        path<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>startIndex<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token comment">// 递归</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token function">backtracking</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token comment">// 回溯</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        path<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><strong>注意切割过的位置，不能重复切割，所以，backtracking (s, i + 1); 传入下一层的起始位置为 i + 1</strong>。</p></li></ol><h4 id="判断回文子串"><a class="anchor" href="#判断回文子串">#</a> 判断回文子串</h4><p>最后我们看一下回文子串要如何判断了，判断一个字符串是否是回文。</p><p>可以使用<strong>双指针法</strong>，一个指针从前向后，一个指针从后向前，如果前后指针所指向的元素是相等的，就是回文字符串了。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 判断子串 s [start,end] 是否是回文串</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">isPalindrome</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token comment">// 双指针法</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> start<span class="token punctuation">,</span> j <span class="token operator">=</span> end<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> j<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">,</span> j<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">!=</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h4 id="java完整代码"><a class="anchor" href="#java完整代码">#</a> java 完整代码</h4><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span><span class="token punctuation">></span></span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> path <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token comment">// 判断子串 s [start,end] 是否是回文串</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">isPalindrome</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token comment">// 双指针法</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> start<span class="token punctuation">,</span> j <span class="token operator">=</span> end<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> j<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">,</span> j<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">!=</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="10"></td><td><pre>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">backtracking</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">,</span> <span class="token keyword">int</span> startIndex<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token comment">// 递归终止条件：startIndex 超过字符串长度</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>startIndex <span class="token operator">>=</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>            result<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>            <span class="token keyword">return</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>        <span class="token comment">// 单层搜索过程</span></pre></td></tr><tr><td data-num="22"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> startIndex<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>            <span class="token comment">// 判断 [startIndex, i] 是否为回文串</span></pre></td></tr><tr><td data-num="24"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isPalindrome</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> startIndex<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>                <span class="token keyword">continue</span><span class="token punctuation">;</span> <span class="token comment">// 不是回文串，跳过</span></pre></td></tr><tr><td data-num="26"></td><td><pre>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 是回文串</span></pre></td></tr><tr><td data-num="27"></td><td><pre>                <span class="token comment">// 处理节点</span></pre></td></tr><tr><td data-num="28"></td><td><pre>                path<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>startIndex<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>                <span class="token comment">// 递归</span></pre></td></tr><tr><td data-num="30"></td><td><pre>                <span class="token function">backtracking</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="31"></td><td><pre>                <span class="token comment">// 回溯</span></pre></td></tr><tr><td data-num="32"></td><td><pre>                path<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="33"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="34"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="35"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="36"></td><td><pre></pre></td></tr><tr><td data-num="37"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span><span class="token punctuation">></span></span> <span class="token function">partition</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="38"></td><td><pre>        <span class="token function">backtracking</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="39"></td><td><pre>        <span class="token keyword">return</span> result<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="40"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="41"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20221226151139156.png" alt="image-20221226151139156"></p><h4 id="优化动态规划"><a class="anchor" href="#优化动态规划">#</a> 优化：动态规划</h4><p>上面的代码还存在一定的优化空间，在于如何更高效的计算一个子字符串是否是回文字串。上述代码 <code>isPalindrome</code> 函数运用双指针的方法来判定对于一个字符串 <code>s</code> , 给定起始下标和终止下标，截取出的子字符串是否是回文字串。但是其中有一定的重复计算存在:</p><p>例如给定字符串 <code>&quot;abcde&quot;</code> , 在已知 <code>&quot;bcd&quot;</code> 不是回文字串时，不再需要去双指针操作 <code>&quot;abcde&quot;</code> 而可以直接判定它一定不是回文字串。</p><p>具体来说，<strong>给定一个字符串 <code>s</code> , 长度为 <code>n</code> , 它成为回文字串的充分必要条件是 <code>s[0] == s[n-1]</code> 且 <code>s[1:n-1]</code> 是回文字串</strong>。</p><p>大家如果熟悉动态规划这种算法的话，我们<strong>可以高效地事先一次性计算出，针对一个字符串 <code>s</code> , 它的任何子串是否是回文字串，然后在我们的回溯函数中直接查询即可，省去了双指针移动判定这一步骤</strong>.</p><p>具体参考代码如下:</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 回溯 + 动态规划（事先计算好回文串）</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span><span class="token punctuation">></span></span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> path <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp<span class="token punctuation">;</span> <span class="token comment">//dp [i][j] 表示 s [i:j] 是否为回文串</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">computePalindrome</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">boolean</span><span class="token punctuation">[</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">[</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 初始化</span></pre></td></tr><tr><td data-num="10"></td><td><pre></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 倒序遍历，保证 dp [i][j] 依赖的 dp [i+1][j-1] 已经计算过</span></pre></td></tr><tr><td data-num="12"></td><td><pre>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span> j <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">//i 从后往前，j 从前往后</span></pre></td></tr><tr><td data-num="13"></td><td><pre>                <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">==</span> i<span class="token punctuation">)</span> <span class="token comment">// 只有一个字符，肯定是回文串</span></pre></td></tr><tr><td data-num="14"></td><td><pre>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>                <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">==</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">// 两个字符，判断两个字符是否相等</span></pre></td></tr><tr><td data-num="16"></td><td><pre>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">==</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>                <span class="token keyword">else</span> <span class="token comment">// 三个及以上字符，判断首尾字符是否相等，且去掉首尾字符的子串是否为回文串</span></pre></td></tr><tr><td data-num="18"></td><td><pre>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">==</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> dp<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="22"></td><td><pre></pre></td></tr><tr><td data-num="23"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">backtracking</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">,</span> <span class="token keyword">int</span> startIndex<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>        <span class="token comment">// 递归终止条件：startIndex 超过字符串长度</span></pre></td></tr><tr><td data-num="25"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>startIndex <span class="token operator">>=</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>            result<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>            <span class="token keyword">return</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>        <span class="token comment">// 单层搜索过程</span></pre></td></tr><tr><td data-num="30"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> startIndex<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="31"></td><td><pre>            <span class="token comment">// 判断 [startIndex, i] 是否为回文串</span></pre></td></tr><tr><td data-num="32"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>dp<span class="token punctuation">[</span>startIndex<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="33"></td><td><pre>                <span class="token keyword">continue</span><span class="token punctuation">;</span> <span class="token comment">// 不是回文串，跳过</span></pre></td></tr><tr><td data-num="34"></td><td><pre>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 是回文串</span></pre></td></tr><tr><td data-num="35"></td><td><pre>                <span class="token comment">// 处理节点</span></pre></td></tr><tr><td data-num="36"></td><td><pre>                path<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>startIndex<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="37"></td><td><pre>                <span class="token comment">// 递归</span></pre></td></tr><tr><td data-num="38"></td><td><pre>                <span class="token function">backtracking</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="39"></td><td><pre>                <span class="token comment">// 回溯</span></pre></td></tr><tr><td data-num="40"></td><td><pre>                path<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="41"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="42"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="43"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="44"></td><td><pre></pre></td></tr><tr><td data-num="45"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span><span class="token punctuation">></span></span> <span class="token function">partition</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="46"></td><td><pre>        <span class="token function">computePalindrome</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="47"></td><td><pre>        <span class="token function">backtracking</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="48"></td><td><pre>        <span class="token keyword">return</span> result<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="49"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="50"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20221226153420089.png" alt="image-20221226153420089"></p><h4 id="总结-36"><a class="anchor" href="#总结-36">#</a> 总结</h4><p>这道题目在 leetcode 上是中等，但可以说是 hard 的题目了，但是代码其实就是按照模板的样子来的。</p><p>那么难究竟难在什么地方呢？</p><p><strong>我列出如下几个难点：</strong></p><ul><li><p>切割问题可以抽象为组合问题</p></li><li><p>如何模拟那些切割线</p><blockquote><p>startIndex</p></blockquote></li><li><p>切割问题中递归如何终止</p><blockquote><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">if</span> <span class="token punctuation">(</span>startIndex <span class="token operator">>=</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr></table></figure></blockquote></li><li><p>在递归循环中如何截取子串</p></li><li><p>如何判断回文</p></li></ul><p><strong>我们平时在做难题的时候，总结出来难究竟难在哪里也是一种需要锻炼的能力</strong>。</p><p>一些同学可能遇到题目比较难，但是不知道题目难在哪里，反正就是很难。其实这样还是思维不够清晰，这种总结的能力需要多接触多锻炼。</p><p><strong>本题我相信很多同学主要卡在了第一个难点上：就是不知道如何切割，甚至知道要用回溯法，也不知道如何用。也就是没有体会到按照求组合问题的套路就可以解决切割</strong>。</p><p>如果意识到这一点，算是重大突破了。接下来就可以对着模板照葫芦画瓢。</p><p><strong>但接下来如何模拟切割线，如何终止，如何截取子串，其实都不好想，最后判断回文算是最简单的了</strong>。</p><p>关于模拟切割线，其实就是<strong> index 是上一层已经确定了的分割线，i 是这一层试图寻找的新分割线</strong>。</p><p>除了这些难点，<strong>本题还有细节，例如：切割过的地方不能重复切割所以递归函数需要传入 i + 1</strong>。</p><p>所以本题应该是一道 hard 题目了。</p><p><strong>可能刷过这道题目的录友都没感受到自己原来克服了这么多难点，就把这道题目 AC 了</strong>，这应该叫做无招胜有招，人码合一，哈哈哈。</p><h3 id="93-复原-ip-地址"><a class="anchor" href="#93-复原-ip-地址">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yZXN0b3JlLWlwLWFkZHJlc3Nlcy8=">☆93. 复原 IP 地址</span></h3><p>其实只要意识到这是切割问题，<strong>切割问题就可以使用回溯搜索法把所有可能性搜出来</strong>，和刚做过的 [☆131. 分割回文串](#☆131. 分割回文串) 就十分类似了。</p><p>切割问题可以抽象为树型结构，如图：</p><p><img data-src="https://img-blog.csdnimg.cn/20201123203735933.png" alt="93.复原IP地址"></p><h4 id="回溯三部曲-6"><a class="anchor" href="#回溯三部曲-6">#</a> 回溯三部曲</h4><ol><li><p>参数：</p><p>在 [☆131. 分割回文串](#☆131. 分割回文串) 中我们就提到切割问题类似组合问题。</p><p><strong>startIndex</strong> 一定是需要的，因为不能重复分割，记录下一层递归分割的起始位置。</p><p>本题我们还需要一个变量<strong> pointNum</strong>，记录添加逗点的数量。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">backtracking</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">,</span> <span class="token keyword">int</span> startIndex<span class="token punctuation">,</span> <span class="token keyword">int</span> pointNum<span class="token punctuation">)</span></pre></td></tr></table></figure></li><li><p>递归终止条件：</p><p>终止条件和 [☆131. 分割回文串](#☆131. 分割回文串) 情况就不同了，本题明确要求分成 4 段，所以不能用切割线切到最后作为终止条件，而是分割的段数作为终止条件。</p><p>pointNum 表示逗点数量，<strong>pointNum 为 3 说明字符串分成了 4 段了</strong>。</p><p>然后<strong>验证一下第四段是否合法</strong>，如果合法就加入到结果集里</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 递归终止条件：因为要求分为 4 段，所以当逗号个数为 3 时，递归终止</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">if</span> <span class="token punctuation">(</span>pointNum <span class="token operator">==</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token comment">// 判断第四段子串是否合法</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isValid</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> startIndex<span class="token punctuation">,</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        result<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 合法则添加到结果集</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">return</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure></li><li><p>单层搜索的过程：</p><p>在 [☆131. 分割回文串](#☆131. 分割回文串) 中已经讲过在循环遍历中如何截取子串。</p><p>在 <code>for (int i = startIndex; i &lt; s.size(); i++)</code> 循环中 <strong>[startIndex, i] 这个区间就是截取的子串</strong>，需要判断这个子串是否合法。</p><p><strong>如果合法就在字符串后面加上符号 <code>.</code> 表示已经分割</strong>。</p><p><strong>如果不合法就结束本层循环</strong>，如图中剪掉的分支：</p><p><img data-src="https://img-blog.csdnimg.cn/20201123203735933.png" alt="93.复原IP地址"></p><p>然后就是递归和回溯的过程：</p><ul><li><p>递归调用时，<strong>下一层递归的 startIndex 要从 i+2 开始</strong>（因为需要在字符串中加入了分隔符 <code>.</code> ），同时记录分割符的数量<strong> pointNum 要 +1</strong>。</p></li><li><p>回溯的时候，就<strong>将刚刚加入的分隔符 <code>.</code> 删掉</strong>就可以了，<strong>pointNum 也要 - 1</strong>。</p></li></ul><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 单层搜索过程</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> startIndex<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isValid</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> startIndex<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 子串 s [startIndex, i] 合法</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token comment">// 处理节点：添加逗号</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        s <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"."</span> <span class="token operator">+</span> s<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        pointNum<span class="token operator">++</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token comment">// 递归</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token function">backtracking</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">,</span> pointNum<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//i+2 是因为添加了一个逗号</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token comment">// 回溯：删除逗号</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        s <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> s<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        pointNum<span class="token operator">--</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 子串 s [startIndex, i] 不合法，直接跳出循环，因为后面的子串更不合法</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token keyword">break</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure></li></ol><h4 id="判断子串是否合法"><a class="anchor" href="#判断子串是否合法">#</a> 判断子串是否合法</h4><p>最后就是在写一个判断段位是否是有效段位了。</p><p>主要考虑到如下三点：</p><ul><li>段位以 0 为开头的数字不合法</li><li>段位里有非正整数字符不合法</li><li>段位如果大于 255 了不合法</li></ul><p>代码如下：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">isValid</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 字符区间不合法</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>start <span class="token operator">></span> end<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token comment">// 以 0 开头的，长度超过 1 的字符串不合法</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>start<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token char">'0'</span> <span class="token operator">&amp;&amp;</span> start <span class="token operator">!=</span> end<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token comment">// 转换成数字</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> start<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> end<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token comment">// 非数字字符不合法</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token char">'0'</span> <span class="token operator">||</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token char">'9'</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre></pre></td></tr><tr><td data-num="13"></td><td><pre>        num <span class="token operator">=</span> num <span class="token operator">*</span> <span class="token number">10</span> <span class="token operator">+</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token char">'0'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 逐位转换成数字</span></pre></td></tr><tr><td data-num="14"></td><td><pre></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token comment">// 数字超过 255 不合法</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>num <span class="token operator">></span> <span class="token number">255</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h4 id="java完整代码-2"><a class="anchor" href="#java完整代码-2">#</a> java 完整代码</h4><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">isValid</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token comment">// 字符区间不合法</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>start <span class="token operator">></span> end<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token comment">// 以 0 开头的，长度超过 1 的字符串不合法</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>start<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token char">'0'</span> <span class="token operator">&amp;&amp;</span> start <span class="token operator">!=</span> end<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token comment">// 转换成数字</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> start<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> end<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>            <span class="token comment">// 非数字字符不合法</span></pre></td></tr><tr><td data-num="14"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token char">'0'</span> <span class="token operator">||</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token char">'9'</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre></pre></td></tr><tr><td data-num="16"></td><td><pre>            num <span class="token operator">=</span> num <span class="token operator">*</span> <span class="token number">10</span> <span class="token operator">+</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token char">'0'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 逐位转换成数字</span></pre></td></tr><tr><td data-num="17"></td><td><pre></pre></td></tr><tr><td data-num="18"></td><td><pre>            <span class="token comment">// 数字超过 255 不合法</span></pre></td></tr><tr><td data-num="19"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>num <span class="token operator">></span> <span class="token number">255</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="23"></td><td><pre></pre></td></tr><tr><td data-num="24"></td><td><pre>    <span class="token comment">// 回溯：s 表示剩余字符串，startIndex 表示当前处理的起始位置，pointNum 记录添加逗号的个数</span></pre></td></tr><tr><td data-num="25"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">backtracking</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">,</span> <span class="token keyword">int</span> startIndex<span class="token punctuation">,</span> <span class="token keyword">int</span> pointNum<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>        <span class="token comment">// 递归终止条件：因为要求分为 4 段，所以当逗号个数为 3 时，递归终止</span></pre></td></tr><tr><td data-num="27"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>pointNum <span class="token operator">==</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>            <span class="token comment">// 判断第四段子串是否合法</span></pre></td></tr><tr><td data-num="29"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isValid</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> startIndex<span class="token punctuation">,</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>                result<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 合法则添加到结果集</span></pre></td></tr><tr><td data-num="31"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>            <span class="token keyword">return</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="33"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="34"></td><td><pre>        <span class="token comment">// 单层搜索过程</span></pre></td></tr><tr><td data-num="35"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> startIndex<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="36"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isValid</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> startIndex<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 子串 s [startIndex, i] 合法</span></pre></td></tr><tr><td data-num="37"></td><td><pre>                <span class="token comment">// 处理节点：添加逗号</span></pre></td></tr><tr><td data-num="38"></td><td><pre>                s <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"."</span> <span class="token operator">+</span> s<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="39"></td><td><pre>                pointNum<span class="token operator">++</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="40"></td><td><pre>                <span class="token comment">// 递归</span></pre></td></tr><tr><td data-num="41"></td><td><pre>                <span class="token function">backtracking</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">,</span> pointNum<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//i+2 是因为添加了一个逗号</span></pre></td></tr><tr><td data-num="42"></td><td><pre>                <span class="token comment">// 回溯：删除逗号</span></pre></td></tr><tr><td data-num="43"></td><td><pre>                s <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> s<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="44"></td><td><pre>                pointNum<span class="token operator">--</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="45"></td><td><pre>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 子串 s [startIndex, i] 不合法，直接跳出循环，因为后面的子串更不合法</span></pre></td></tr><tr><td data-num="46"></td><td><pre>                <span class="token keyword">break</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="47"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="48"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="49"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="50"></td><td><pre></pre></td></tr><tr><td data-num="51"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> <span class="token function">restoreIpAddresses</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="52"></td><td><pre>        <span class="token comment">// 特判：字符串长度不合法</span></pre></td></tr><tr><td data-num="53"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">4</span> <span class="token operator">||</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">12</span><span class="token punctuation">)</span> <span class="token keyword">return</span> result<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="54"></td><td><pre></pre></td></tr><tr><td data-num="55"></td><td><pre>        <span class="token function">backtracking</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="56"></td><td><pre>        <span class="token keyword">return</span> result<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="57"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="58"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20221226162242100.png" alt="image-20221226162242100"></p><h4 id="总结-37"><a class="anchor" href="#总结-37">#</a> 总结</h4><p>在 [☆131. 分割回文串](#☆131. 分割回文串) 中我列举的分割字符串的难点，本题都覆盖了。</p><p>而且本题还需要操作字符串添加逗号作为分隔符，并验证区间的合法性。</p><p>可以说是 [☆131. 分割回文串](#☆131. 分割回文串) 的加强版。</p><p>在本文的树形结构图中，我已经把详细的分析思路都画了出来，相信大家看了之后一定会思路清晰不少！</p><h3 id="78-子集"><a class="anchor" href="#78-子集">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zdWJzZXRzLw==">78. 子集</span></h3><h4 id="思路-8"><a class="anchor" href="#思路-8">#</a> 思路</h4><p>求子集问题和 [77. 组合](#77. 组合) 和 [☆131. 分割回文串](#☆131. 分割回文串) 又不一样了。</p><p>如果把 子集问题、组合问题、分割问题都抽象为一棵树的话，<strong>那么组合问题和分割问题都是收集树的叶子节点，而子集问题是找树的所有节点！</strong></p><p>其实子集也是一种组合问题，因为它的集合是无序的，子集 {1,2} 和 子集 {2,1} 是一样的。</p><p><strong>那么既然是无序，取过的元素不会重复取，写回溯算法的时候，for 就要从 startIndex 开始，而不是从 0 开始！</strong></p><p>有同学问了，什么时候 for 可以从 0 开始呢？</p><p>求排列问题的时候，就要从 0 开始，因为集合是有序的，{1, 2} 和 {2, 1} 是两个集合，排列问题我们后续的文章就会讲到的。</p><p>以示例中 nums = [1,2,3] 为例把求子集抽象为树型结构，如下：</p><p><img data-src="https://img-blog.csdnimg.cn/202011232041348.png" alt="78.子集"></p><p>从图中红线部分，可以看出<strong>遍历这个树的时候，把所有节点都记录下来，就是要求的子集集合</strong>。</p><h4 id="回溯三部曲-7"><a class="anchor" href="#回溯三部曲-7">#</a> 回溯三部曲</h4><ol><li><p>参数：</p><p><strong>两个全局变量</strong>，数组 path 为子集收集元素，二维数组 result 存放子集组合。（也可以放到递归函数参数里）</p><p>递归函数参数在上面讲到了，需要<strong> startIndex</strong>。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span><span class="token punctuation">></span></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> path <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">backtracking</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> startIndex<span class="token punctuation">)</span></pre></td></tr></table></figure></li><li><p>递归终止条件：</p><p>从图中可以看出：</p><p><img data-src="https://img-blog.csdnimg.cn/202011232041348.png" alt="78.子集"></p><p>剩余集合为空的时候，就是叶子节点。</p><p>那么什么时候剩余集合为空呢？</p><p>就是<strong> startIndex 已经大于数组的长度</strong>了，就终止了，因为没有元素可取了。</p><p><strong>其实可以不需要加终止条件，因为 startIndex &gt;= nums.size ()，本层 for 循环本来也结束了，不需要剪枝</strong></p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">if</span> <span class="token punctuation">(</span>startIndex <span class="token operator">>=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">return</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure></li><li><p>单层搜索的逻辑：</p><p><strong>求取子集问题，不需要任何剪枝！因为子集就是要遍历整棵树</strong>。</p><p>那么单层递归逻辑代码如下：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> startIndex<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 处理节点</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    path<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token comment">// 递归</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token function">backtracking</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//i+1 是因为集合的无序性，要求不重复</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token comment">// 回溯，撤销处理的节点</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    path<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure></li></ol><h4 id="java完整代码-3"><a class="anchor" href="#java完整代码-3">#</a> java 完整代码</h4><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span><span class="token punctuation">></span></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> path <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">backtracking</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> startIndex<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token comment">// !!! 收集子集，要放在终止条件的上面，否则会漏掉自己！！！</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token comment">// 递归终止条件（不需要，因为没有剪枝）</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>startIndex <span class="token operator">>=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>            <span class="token keyword">return</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token comment">// 单层搜索的逻辑</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> startIndex<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>            <span class="token comment">// 处理节点</span></pre></td></tr><tr><td data-num="17"></td><td><pre>            path<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>            <span class="token comment">// 递归</span></pre></td></tr><tr><td data-num="19"></td><td><pre>            <span class="token function">backtracking</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//i+1 是因为集合的无序性，要求不重复</span></pre></td></tr><tr><td data-num="20"></td><td><pre>            <span class="token comment">// 回溯，撤销处理的节点</span></pre></td></tr><tr><td data-num="21"></td><td><pre>            path<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="24"></td><td><pre></pre></td></tr><tr><td data-num="25"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span><span class="token punctuation">></span></span> <span class="token function">subsets</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>        <span class="token function">backtracking</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>        <span class="token keyword">return</span> res<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="29"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>在注释中，可以发现可以不写终止条件，因为本来我们就要遍历整棵树。</p><p>有的同学可能担心不写终止条件会不会无限递归？</p><p>并不会，因为每次递归的下一层就是从 i+1 开始的。</p><h4 id="总结-38"><a class="anchor" href="#总结-38">#</a> 总结</h4><p>相信大家经过了</p><ul><li>组合问题：<ul><li>[77. 组合](#77. 组合)</li><li>[77. 组合优化](#77. 组合优化)</li><li>[216. 组合总和 III](#216. 组合总和 III)</li><li>[17. 电话号码的字母组合](#17. 电话号码的字母组合)</li><li>[39. 组合总和](#39. 组合总和)</li><li>[40. 组合总和 II](#40. 组合总和 II)</li></ul></li><li>分割问题：<ul><li>[☆131. 分割回文串](#☆131. 分割回文串)</li><li>[☆93. 复原 IP 地址](#☆93. 复原 IP 地址)</li></ul></li></ul><p>洗礼之后，发现子集问题还真的有点简单了，其实这就是一道标准的模板题。</p><p>但是要清楚子集问题和组合问题、分割问题的的区别，</p><ul><li><p><strong>子集是收集树形结构中树的<mark>所有节点</mark>的结果</strong></p><blockquote><p>在递归终止条件<strong>前</strong>要收集结果</p></blockquote></li><li><p><strong>组合问题、分割问题是收集树形结构中<mark>叶子节点</mark>的结果</strong></p><blockquote><p>在递归终止条件<strong>中</strong>收集结果</p></blockquote></li></ul><h3 id="本周小结回溯算法系列二"><a class="anchor" href="#本周小结回溯算法系列二">#</a> 本周小结！（回溯算法系列二）</h3><h4 id="周一-6"><a class="anchor" href="#周一-6">#</a> 周一</h4><p>在 [39. 组合总和](#39. 组合总和) 中讲解的组合总和问题，和以前的组合问题还都不一样。</p><p>本题和 [77. 组合](#77. 组合)，[216. 组合总和 III](#216. 组合总和 III) 和区别是：本题没有数量要求，可以无限重复，但是有总和的限制，所以间接的也是有个数的限制。</p><p>不少录友都是看到可以重复选择，就义无反顾的把 startIndex 去掉了。</p><p><strong>本题还需要 startIndex 来控制 for 循环的起始位置，对于组合问题，什么时候需要 startIndex 呢？</strong></p><ul><li><p>如果是<strong>一个集合</strong>来求组合的话，就需要 startIndex，例如：[77. 组合](#77. 组合)，[216. 组合总和 III](#216. 组合总和 III)。</p></li><li><p>如果是<strong>多个集合</strong>取组合，各个集合之间相互不影响，那么就不用 startIndex，例如：[17. 电话号码的字母组合](#17. 电话号码的字母组合)</p></li></ul><p><strong>注意以上我只是说求组合的情况，如果是排列问题，又是另一套分析的套路，后面我再讲解排列的时候就重点介绍</strong>。</p><p>最后还给出了本题的剪枝优化，如下：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> startIndex<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> candidates<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> sum <span class="token operator">+</span> candidates<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> target<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span></pre></td></tr></table></figure><blockquote><p>可以避免进入无意义的递归</p></blockquote><p>这个优化如果是初学者的话并不容易想到。</p><p><strong>在求和问题中，排序之后加剪枝是常见的套路！</strong></p><p>在 [39. 组合总和](#39. 组合总和) 第一个树形结构没有画出 startIndex 的作用，<strong>这里这里纠正一下，准确的树形结构如图所示：</strong></p><p><img data-src="https://img-blog.csdnimg.cn/20201123202227835.png" alt="39.组合总和"></p><h4 id="周二-6"><a class="anchor" href="#周二-6">#</a> 周二</h4><p>在 [40. 组合总和 II](#40. 组合总和 II) 中依旧讲解组合总和问题，本题集合元素会有重复，但要求解集不能包含重复的组合。</p><p><strong>所以难就难在<mark>去重问题</mark>上了</strong>。</p><p>这个去重问题，相信做过的录友都知道有多么的晦涩难懂。网上的题解一般就说 “去掉重复”，但说不清怎么个去重，代码一甩就完事了。</p><p>为了讲解这个去重问题，<strong>我自创了两个词汇，“树枝去重” 和 “树层去重”</strong>。</p><p>都知道组合问题可以抽象为树形结构，那么 “使用过” 在这个树形结构上是有两个维度的，</p><ul><li>一个维度是<u>同一树枝</u>上 “使用过”</li><li>一个维度是<u>同一树层</u>上 “使用过”</li></ul><p><strong>没有理解这两个层面上的 “使用过” 是造成大家没有彻底理解去重的根本原因</strong>。</p><p><img data-src="https://img-blog.csdnimg.cn/20201123202817973.png" alt="40.组合总和II1"></p><p>我在图中将 used 的变化用橘黄色标注上，可以看出在 <code>candidates[i] == candidates[i - 1]</code> 相同的情况下：</p><ul><li><code>used[i - 1] == true</code> ，说明同一树枝 candidates [i - 1] 使用过，可以重复选取</li><li><code>used[i - 1] == false</code> ，说明同一树层 candidates [i - 1] 使用过，不可重复选取</li></ul><p><strong>这块去重的逻辑很抽象，网上搜的题解基本没有能讲清楚的，如果大家之前思考过这个问题或者刷过这道题目，看到这里一定会感觉通透了很多！</strong></p><p>对于去重，其实排列问题也是一样的道理，后面我会讲到。</p><h4 id="周三-6"><a class="anchor" href="#周三-6">#</a> 周三</h4><p>在 [☆131. 分割回文串](#☆131. 分割回文串) 中，我们开始讲解切割问题，虽然最后代码看起来好像是一道模板题，但是从分析到学会套用这个模板，是比较难的。</p><p>我列出如下几个难点：</p><ul><li>切割问题其实类似组合问题</li><li>如何模拟那些切割线</li><li>切割问题中递归如何终止</li><li>在递归循环中如何截取子串</li><li>如何判断回文</li></ul><p>如果想到了<strong>用求解组合问题的思路来解决 切割问题本题就成功一大半了</strong>，接下来就可以对着模板照葫芦画瓢。</p><p><strong>但后续如何模拟切割线，如何终止，如何截取子串，其实都不好想，最后判断回文算是最简单的了</strong>。</p><p>除了这些难点，<strong>本题还有细节，例如：切割过的地方不能重复切割所以递归函数需要传入 i + 1</strong>。</p><p>所以本题应该是一个道 hard 题目了。</p><p><strong>本题的树形结构中，和代码的逻辑有一个小出入，已经判断不是回文的子串就不会进入递归了，纠正如下：</strong></p><p><img data-src="https://img-blog.csdnimg.cn/20201123203228309.png" alt="131.分割回文串"></p><h4 id="周四-6"><a class="anchor" href="#周四-6">#</a> 周四</h4><p>如果没有做过 [☆131. 分割回文串](#☆131. 分割回文串) 的话，[☆93. 复原 IP 地址](#☆93. 复原 IP 地址) 这道题目应该是比较难的。</p><p>复原 IP 照 [☆131. 分割回文串](#☆131. 分割回文串) 就多了一些限制，例如只能分四段，而且还是更改字符串，插入逗点。</p><p>树形图如下：</p><p><img data-src="https://img-blog.csdnimg.cn/20201123203735933.png" alt="93.复原IP地址"></p><p>在本文的树形结构图中，我已经把详细的分析思路都画了出来，相信大家看了之后一定会思路清晰不少！</p><p>本题还可以有一个剪枝，合法 ip 长度为 12，如果 s 的长度超过了 12 就不是有效 IP 地址，直接返回！</p><p>代码如下：</p><figure class="highlight text"><figcaption data-lang="text"></figcaption><table><tr><td data-num="1"></td><td><pre>if (s.size() > 12) return result; // 剪枝</pre></td></tr></table></figure><p>我之前给出 C++ 代码没有加这个限制，也没有超时，因为在第四段超过长度之后，就会截止了，所以就算给出特别长的字符串，搜索的范围也是有限的（递归只会到第三层），及时就会返回了。</p><h4 id="周五-6"><a class="anchor" href="#周五-6">#</a> 周五</h4><p>在 [78. 子集](#78. 子集) 中讲解了子集问题，<strong>在树形结构中子集问题是要收集所有节点的结果，而组合问题是收集叶子节点的结果</strong>。</p><p>如图：</p><p><img data-src="https://img-blog.csdnimg.cn/202011232041348.png" alt="78.子集"></p><p>认清这个本质之后，今天的题目就是一道模板题了。</p><p>其实可以不需要加终止条件，因为 startIndex &gt;= nums.size ()，本层 for 循环本来也结束了，本来我们就要<strong>遍历整棵树</strong>。</p><p>有的同学可能担心不写终止条件会不会无限递归？</p><p>并不会，因为每次递归的下一层就是从 i+1 开始的。</p><p>如果要写终止条件，注意： <code>result.push_back(path);</code> 要放在终止条件的上面，如下：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>result<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 收集子集，要放在终止添加的上面，否则会漏掉自己</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">if</span> <span class="token punctuation">(</span>startIndex <span class="token operator">>=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 终止条件可以不加</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">return</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h4 id="总结-39"><a class="anchor" href="#总结-39">#</a> 总结</h4><p>本周我们依次介绍了组合问题，分割问题以及子集问题，子集问题还没有讲完，下周还会继续。</p><p><strong>我讲解每一种问题，都会和其他问题作对比，做分析，所以只要跟着细心琢磨相信对回溯又有新的认识</strong>。</p><p>最近这两天题目有点难度，刚刚开始学回溯算法的话，按照现在这个每天一题的速度来，确实有点快，学起来吃力非常正常，这些题目都是我当初学了好几个月才整明白的，哈哈。</p><p><strong>所以大家能跟上的话，已经很优秀了！</strong></p><p>还有一些录友会很关心 leetcode 上的耗时统计。</p><p>这个是很不准确的，相同的代码多提交几次，大家就知道怎么回事了。</p><p>leetcode 上的计时应该是以 4ms 为单位，有的多提交几次，多个 4ms 就多击败 50%，所以比较夸张，如果程序运行是几百 ms 的级别，可以看看 leetcode 上的耗时，因为它的误差 10 几 ms 对最终影响不大。</p><p><strong>所以我的题解基本不会写击败百分之多少多少，没啥意义，时间复杂度分析清楚了就可以了</strong>，至于<strong>回溯算法不用分析时间复杂度了，都是一样的爆搜，就看谁剪枝厉害了。</strong></p><h3 id="90-子集-ii"><a class="anchor" href="#90-子集-ii">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zdWJzZXRzLWlpLw==">90. 子集 II</span></h3><blockquote><p>如何去重？used 数组！</p></blockquote><p>做本题之前一定要先做 [78. 子集](#78. 子集)。</p><p>这道题目和 [78. 子集](#78. 子集) 区别就是<strong>集合里有重复元素了，而且求取的子集要去重</strong>。</p><p>那么关于回溯算法中的去重问题，<strong>在 [40. 组合总和 II](#40. 组合总和 II) 中已经详细讲解过了，和本题是一个套路</strong>。</p><p><strong>剧透一下，后期要讲解的排列问题里去重也是这个套路，所以理解 “树层去重” 和 “树枝去重” 非常重要</strong>。</p><p>用示例中的 [1, 2, 2] 来举例，如图所示： （<strong>注意<mark>去重需要先对集合排序</mark></strong>）</p><p><img data-src="https://img-blog.csdnimg.cn/20201124195411977.png" alt="90.子集II"></p><p>从图中可以看出，同一树层上重复取 2 就要过滤掉，同一树枝上就可以重复取 2，因为同一树枝上元素的集合才是唯一子集！</p><p>本题就是其实就是 [78. 子集](#78. 子集) 的基础上加上了去重，去重我们在 [40. 组合总和 II](#40. 组合总和 II) 也讲过了，所以我就直接给出代码了：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span><span class="token punctuation">></span></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> path <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">backtracking</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> startIndex<span class="token punctuation">,</span> <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span> used<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token comment">// 在递归终止条件之前，就需要添加结果，因为需要对所有节点进行遍历，而不是只遍历叶子节点</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token comment">// 不需要递归终止条件，因为需要遍历整棵树，不需要剪枝</span></pre></td></tr><tr><td data-num="10"></td><td><pre></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token comment">// 单层搜索的逻辑</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> startIndex<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>            <span class="token comment">// 去重：对同一树层上的元素，如果前一个元素和当前元素相同，且前一个元素未被使用过，那么当前元素也不应该被使用</span></pre></td></tr><tr><td data-num="14"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">>=</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> used<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token boolean">false</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="15"></td><td><pre>                <span class="token keyword">continue</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre></pre></td></tr><tr><td data-num="17"></td><td><pre>            <span class="token comment">// 处理节点</span></pre></td></tr><tr><td data-num="18"></td><td><pre>            path<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>            used<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>            <span class="token comment">// 递归</span></pre></td></tr><tr><td data-num="21"></td><td><pre>            <span class="token function">backtracking</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> used<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//i+1 是因为不能重复使用同一个元素</span></pre></td></tr><tr><td data-num="22"></td><td><pre>            <span class="token comment">// 回溯，撤销处理的节点</span></pre></td></tr><tr><td data-num="23"></td><td><pre>            path<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>            used<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="26"></td><td><pre></pre></td></tr><tr><td data-num="27"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="28"></td><td><pre></pre></td></tr><tr><td data-num="29"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span><span class="token punctuation">></span></span> <span class="token function">subsetsWithDup</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>        <span class="token comment">// 排序是剪枝（去重）的前提，因为排序后相同的元素会相邻</span></pre></td></tr><tr><td data-num="31"></td><td><pre>        <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>        <span class="token comment">//used 数组记录元素是否被使用过，用于剪枝（去重）</span></pre></td></tr><tr><td data-num="33"></td><td><pre>        <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span> used <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">boolean</span><span class="token punctuation">[</span>nums<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="34"></td><td><pre></pre></td></tr><tr><td data-num="35"></td><td><pre>        <span class="token function">backtracking</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> used<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="36"></td><td><pre>        <span class="token keyword">return</span> res<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="37"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="38"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20221227231452060.png" alt="image-20221227231452060"></p><h4 id="补充-2"><a class="anchor" href="#补充-2">#</a> 补充</h4><p>本题也可以不使用 used 数组来去重，因为递归的时候下一个 startIndex 是 i+1 而不是 0。</p><p>如果要是全排列的话，每次要从 0 开始遍历，为了跳过已入栈的元素，需要使用 used。</p><p>代码如下：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span><span class="token punctuation">></span></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> path <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">backtracking</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> startIndex<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token comment">// 在递归终止条件之前，就需要添加结果，因为需要对所有节点进行遍历，而不是只遍历叶子节点</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token comment">// 不需要递归终止条件，因为需要遍历整棵树，不需要剪枝</span></pre></td></tr><tr><td data-num="10"></td><td><pre></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token comment">// 单层搜索的逻辑</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> startIndex<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>            <span class="token comment">// 去重：对同一树层上的元素，如果前一个元素和当前元素相同，且前一个元素未被使用过，那么当前元素也不应该被使用</span></pre></td></tr><tr><td data-num="14"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">></span> startIndex <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="15"></td><td><pre>                <span class="token keyword">continue</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre></pre></td></tr><tr><td data-num="17"></td><td><pre>            <span class="token comment">// 处理节点</span></pre></td></tr><tr><td data-num="18"></td><td><pre>            path<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>            <span class="token comment">// 递归</span></pre></td></tr><tr><td data-num="20"></td><td><pre>            <span class="token function">backtracking</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//i+1 是因为不能重复使用同一个元素</span></pre></td></tr><tr><td data-num="21"></td><td><pre>            <span class="token comment">// 回溯，撤销处理的节点</span></pre></td></tr><tr><td data-num="22"></td><td><pre>            path<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="24"></td><td><pre></pre></td></tr><tr><td data-num="25"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="26"></td><td><pre></pre></td></tr><tr><td data-num="27"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span><span class="token punctuation">></span></span> <span class="token function">subsetsWithDup</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>        <span class="token comment">// 排序是剪枝（去重）的前提，因为排序后相同的元素会相邻</span></pre></td></tr><tr><td data-num="29"></td><td><pre>        <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="30"></td><td><pre></pre></td></tr><tr><td data-num="31"></td><td><pre>        <span class="token function">backtracking</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>        <span class="token keyword">return</span> res<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="33"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="34"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20221227231938587.png" alt="image-20221227231938587"></p><h4 id="总结-40"><a class="anchor" href="#总结-40">#</a> 总结</h4><p>其实这道题目的知识点，我们之前都讲过了，如果之前讲过的子集问题和去重问题都掌握的好，这道题目应该分分钟 AC。</p><p>正如补充中所说，本题去重的逻辑，也可以这么写</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">></span> startIndex <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre>	<span class="token keyword">continue</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h3 id="491-递增子序列"><a class="anchor" href="#491-递增子序列">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9ub24tZGVjcmVhc2luZy1zdWJzZXF1ZW5jZXMv">491. 递增子序列</span></h3><blockquote><p>和子集问题有点像，但又处处是陷阱</p><ol><li>输入的是单个集合数组</li><li>不可重复取元素</li><li>数组中有重复元素，但不可重复取（需要去重）</li></ol></blockquote><h4 id="思路-9"><a class="anchor" href="#思路-9">#</a> 思路</h4><p>这个递增子序列比较像是<strong>取有序的子集</strong>。而且本题也要求不能有相同的递增子序列。</p><p>这又是子集，又是去重，是不是不由自主的想起了刚刚讲过的 [90. 子集 II](#90. 子集 II)。</p><p>就是因为太像了，更要注意差别所在，要不就掉坑里了！</p><p>在 [90. 子集 II](#90. 子集 II) 中我们是通过排序（让重复的元素相邻），再加一个标记数组 used 来达到去重的目的。</p><p>而<strong>本题求自增子序列，是不能对原数组进行排序的</strong>，排完序的数组都是自增子序列了。</p><p><mark><strong>所以不能使用之前的去重逻辑！</strong></mark></p><blockquote><p>用 Set</p></blockquote><p>本题给出的示例，还是一个有序数组 [4, 6, 7, 7]，这更容易误导大家按照排序的思路去做了。</p><p>为了有鲜明的对比，我用 [4, 7, 6, 7] 这个数组来举例，抽象为树形结构如图：</p><p><img data-src="https://img-blog.csdnimg.cn/20201124200229824.png" alt="491. 递增子序列1"></p><h4 id="回溯三部曲-8"><a class="anchor" href="#回溯三部曲-8">#</a> 回溯三部曲</h4><ol><li><p>参数：</p><ul><li><strong>两个全局变量</strong>。</li><li>一个元素不能重复使用，所以需要<strong> startIndex</strong>，调整下一层递归的起始位置。</li></ul><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span><span class="token punctuation">></span></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> path <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">backtracking</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> startIndex<span class="token punctuation">)</span></pre></td></tr></table></figure></li><li><p>递归终止条件：</p><p>本题其实类似求子集问题，也是要遍历树形结构找每一个节点，所以和 [78. 子集](#78. 子集) 一样，<strong>可以不加终止条件，startIndex 每次都会加 1，并不会无限递归</strong>。</p><p>但本题<strong>收集结果有所不同</strong>，题目要求递增子序列大小至少为 2，所以代码如下：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 收集结果</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">if</span> <span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token comment">// 题目要求至少两个元素</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure></li><li><p>单层搜索的逻辑：</p><p><img data-src="https://img-blog.csdnimg.cn/20201124200229824.png" alt="491. 递增子序列1"> 在图中可以看出，<strong>同一父节点下的同层上使用过的元素就不能再使用了</strong></p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 单层搜索的逻辑</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> usedSet <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 用于去重</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> startIndex<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token comment">// 剪枝（去重）：对于同一层，如果当前元素已经被使用过，就不再使用</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span></pre></td></tr><tr><td data-num="6"></td><td><pre>            <span class="token punctuation">(</span><span class="token operator">!</span>path<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> path<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 不满足递增条件</span></pre></td></tr><tr><td data-num="7"></td><td><pre>                    <span class="token operator">||</span> usedSet<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">// 当前元素已经被使用过</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token punctuation">)</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token keyword">continue</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre></pre></td></tr><tr><td data-num="11"></td><td><pre>    usedSet<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 记录当前元素已经被使用过</span></pre></td></tr><tr><td data-num="12"></td><td><pre></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token comment">// 处理节点</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    path<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token comment">// 递归</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token function">backtracking</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token comment">// 回溯，撤销处理的节点</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    path<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><strong>对于已经习惯写回溯的同学，看到递归函数上面的 <code>uset.insert(nums[i]);</code> ，下面却没有对应的 pop 之类的操作，应该很不习惯吧，哈哈</strong></p><p><strong>这也是需要注意的点， <code>unordered_set&lt;int&gt; uset;</code> 是记录本层元素是否重复使用，新的一层 uset 都会重新定义（清空），所以要知道 uset 只负责本层！</strong></p></li></ol><p>java 整体代码：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span><span class="token punctuation">></span></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> path <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">backtracking</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> startIndex<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token comment">// 收集结果</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token comment">// 题目要求至少两个元素</span></pre></td></tr><tr><td data-num="8"></td><td><pre>            res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token comment">// 不需要递归终止条件，因为题目要求返回所有结果</span></pre></td></tr><tr><td data-num="11"></td><td><pre></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token comment">// 单层搜索的逻辑</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> usedSet <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 用于去重</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> startIndex<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>            <span class="token comment">// 剪枝（去重）：对于同一层，如果当前元素已经被使用过，就不再使用</span></pre></td></tr><tr><td data-num="16"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span></pre></td></tr><tr><td data-num="17"></td><td><pre>                    <span class="token punctuation">(</span><span class="token operator">!</span>path<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> path<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 不满足递增条件</span></pre></td></tr><tr><td data-num="18"></td><td><pre>                            <span class="token operator">||</span> usedSet<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">// 当前元素已经被使用过</span></pre></td></tr><tr><td data-num="19"></td><td><pre>            <span class="token punctuation">)</span></pre></td></tr><tr><td data-num="20"></td><td><pre>                <span class="token keyword">continue</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre></pre></td></tr><tr><td data-num="22"></td><td><pre>            usedSet<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 记录当前元素已经被使用过</span></pre></td></tr><tr><td data-num="23"></td><td><pre></pre></td></tr><tr><td data-num="24"></td><td><pre>            <span class="token comment">// 处理节点</span></pre></td></tr><tr><td data-num="25"></td><td><pre>            path<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>            <span class="token comment">// 递归</span></pre></td></tr><tr><td data-num="27"></td><td><pre>            <span class="token function">backtracking</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>            <span class="token comment">// 回溯，撤销处理的节点</span></pre></td></tr><tr><td data-num="29"></td><td><pre>            path<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="31"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="32"></td><td><pre></pre></td></tr><tr><td data-num="33"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span><span class="token punctuation">></span></span> <span class="token function">findSubsequences</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="34"></td><td><pre>        <span class="token function">backtracking</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="35"></td><td><pre>        <span class="token keyword">return</span> res<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="36"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="37"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20221227235059903.png" alt="image-20221227235059903"></p><h4 id="优化-2"><a class="anchor" href="#优化-2">#</a> 优化</h4><p>以上代码用我用了 <code>Set&lt;Integer&gt;</code> 来记录本层元素是否重复使用。</p><p><strong>其实用数组来做哈希，效率就高了很多</strong>。</p><p>注意题目中说了，数值范围 [-100,100]，所以完全可以用数组来做哈希。</p><p>程序运行的时候对 unordered_set 频繁的 insert，unordered_set 需要做哈希映射（也就是把 key 通过 hash function 映射为唯一的哈希值）相对费时间，而且每次重新定义 set，insert 的时候其底层的符号表也要做相应的扩充，也是费事的。</p><p>那么优化后的代码如下：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 使用数组来做哈希表，而不是 Set。</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment">// 因为题意表明各个数值的范围是 [-100, 100]，所以可以使用一个长度为 201 的数组来做哈希表</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span><span class="token punctuation">></span></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> path <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">backtracking</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> startIndex<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token comment">// 收集结果</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token comment">// 题目要求至少两个元素</span></pre></td></tr><tr><td data-num="10"></td><td><pre>            res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token comment">// 不需要递归终止条件，因为题目要求返回所有结果</span></pre></td></tr><tr><td data-num="13"></td><td><pre></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token comment">// 单层搜索的逻辑</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> used <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">201</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 使用数组来做哈希表，用于去重，题意表明各个数值的范围是 [-100, 100]</span></pre></td></tr><tr><td data-num="16"></td><td><pre></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> startIndex<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>            <span class="token comment">// 剪枝（去重）：对于同一层，如果当前元素已经被使用过，就不再使用</span></pre></td></tr><tr><td data-num="19"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span></pre></td></tr><tr><td data-num="20"></td><td><pre>                    <span class="token punctuation">(</span><span class="token operator">!</span>path<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> path<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 不满足递增条件</span></pre></td></tr><tr><td data-num="21"></td><td><pre>                            <span class="token operator">||</span> used<span class="token punctuation">[</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">100</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span> <span class="token comment">// 当前元素已经被使用过</span></pre></td></tr><tr><td data-num="22"></td><td><pre>            <span class="token punctuation">)</span></pre></td></tr><tr><td data-num="23"></td><td><pre>                <span class="token keyword">continue</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre></pre></td></tr><tr><td data-num="25"></td><td><pre>            used<span class="token punctuation">[</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">100</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 标记当前元素已经被使用过，+100 是为了避免负数下标</span></pre></td></tr><tr><td data-num="26"></td><td><pre></pre></td></tr><tr><td data-num="27"></td><td><pre>            <span class="token comment">// 处理节点</span></pre></td></tr><tr><td data-num="28"></td><td><pre>            path<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>            <span class="token comment">// 递归</span></pre></td></tr><tr><td data-num="30"></td><td><pre>            <span class="token function">backtracking</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="31"></td><td><pre>            <span class="token comment">// 回溯，撤销处理的节点</span></pre></td></tr><tr><td data-num="32"></td><td><pre>            path<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="33"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="34"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="35"></td><td><pre></pre></td></tr><tr><td data-num="36"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span><span class="token punctuation">></span></span> <span class="token function">findSubsequences</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="37"></td><td><pre>        <span class="token function">backtracking</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="38"></td><td><pre>        <span class="token keyword">return</span> res<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="39"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="40"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20221227235706532.png" alt="image-20221227235706532"></p><p>这份代码在 leetcode 上提交，要比版本一耗时要好的多。</p><p><strong>所以正如在<span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVyY2FybC5jb20vJUU1JTkzJTg4JUU1JUI4JThDJUU4JUExJUE4JUU2JTgwJUJCJUU3JUJCJTkzLmh0bWw=">哈希表：总结篇！</span>中说的那样，数组，set，map 都可以做哈希表，而且数组干的活，map 和 set 都能干，但如果数值范围小的话能用数组尽量用数组</strong>。</p><h4 id="总结-41"><a class="anchor" href="#总结-41">#</a> 总结</h4><p>本题题解清一色都说是深度优先搜索，但我更倾向于说它用回溯法，而且本题我也是完全使用回溯法的逻辑来分析的。</p><p>相信大家在本题中处处都能看到是 [90. 子集 II](#90. 子集 II) 的身影，但处处又都是陷阱。</p><p><strong>对于养成思维定式或者套模板套嗨了的同学，这道题起到了很好的警醒作用。更重要的是拓展了大家的思路！</strong></p><h3 id="46-全排列"><a class="anchor" href="#46-全排列">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9wZXJtdXRhdGlvbnMv">46. 全排列</span></h3><p>此时我们已经学习了 [77. 组合](#77. 组合)、 [☆131. 分割回文串](#☆131. 分割回文串) 和 [78. 子集](#78. 子集)，接下来看一看排列问题。</p><p>相信这个排列问题就算是让你用 for 循环暴力把结果搜索出来，这个暴力也不是很好写。</p><p>所以正如我们在<a href="#%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80">回溯算法理论基础</a>所讲的为什么回溯法是暴力搜索，效率这么低，还要用它？</p><p><strong>因为一些问题能暴力搜出来就已经很不错了！</strong></p><p>我以 [1,2,3] 为例，抽象成树形结构如下：</p><p><img data-src="https://code-thinking-1253855093.file.myqcloud.com/pics/20211027181706.png" alt="46.全排列"></p><h4 id="回溯三部曲-9"><a class="anchor" href="#回溯三部曲-9">#</a> 回溯三部曲</h4><ol><li><p>参数：</p><ul><li><p><strong>两个全局变量</strong></p></li><li><p>startIndex？</p><blockquote><p><strong>首先排列是有序的，也就是说 [1,2] 和 [2,1] 是两个集合，这和之前分析的子集以及组合所不同的地方</strong>。</p><p>可以看出元素 1 在 [1,2] 中已经使用过了，但是在 [2,1] 中还要在使用一次 1，所以处理排列问题就 **<mark> 不用使用 startIndex</mark>** 了。</p></blockquote></li><li><p><strong>used 数组</strong>：标记已经选择的元素</p></li></ul><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span><span class="token punctuation">></span></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> path <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">backtracking</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span> used<span class="token punctuation">)</span></pre></td></tr></table></figure></li><li><p>递归终止条件：</p><p>可以看出叶子节点，就是收割结果的地方。</p><p>那么什么时候，算是到达叶子节点呢？</p><p><strong>当收集元素的数组 path 的大小达到和 nums 数组一样大的时候</strong>，说明找到了一个全排列，也表示到达了叶子节点。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">if</span> <span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">return</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure></li><li><p>单层搜索的逻辑：</p><p>这里和 [77. 组合](#77. 组合)、 [☆131. 分割回文串](#☆131. 分割回文串) 和 [78. 子集](#78. 子集) 最大的不同就是<strong> for 循环里不用 startIndex 了</strong>。</p><p>因为<strong>排列问题，每次都要从头开始搜索</strong>，例如元素 1 在 [1,2] 中已经使用过了，但是在 [2,1] 中还要再使用一次 1。</p><p><strong>而 used 数组，其实就是记录此时 path 里都有哪些元素使用了，一个排列里一个元素只能使用一次</strong>。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 剪枝：path 中已经存在该元素，跳过</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>used<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token boolean">true</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token keyword">continue</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token comment">// 处理节点</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    path<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    used<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token comment">// 递归</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token function">backtracking</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> used<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token comment">// 回溯</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    path<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    used<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure></li></ol><p>完整的 java 代码：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span><span class="token punctuation">></span></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> path <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">backtracking</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span> used<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token comment">// 递归终止条件</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>            res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>            <span class="token keyword">return</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token comment">// 单层搜索的逻辑</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>            <span class="token comment">// 剪枝：path 中已经存在该元素，跳过</span></pre></td></tr><tr><td data-num="14"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>used<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token boolean">true</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="15"></td><td><pre>                <span class="token keyword">continue</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>            <span class="token comment">// 处理节点</span></pre></td></tr><tr><td data-num="17"></td><td><pre>            path<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>            used<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>            <span class="token comment">// 递归</span></pre></td></tr><tr><td data-num="20"></td><td><pre>            <span class="token function">backtracking</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> used<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>            <span class="token comment">// 回溯</span></pre></td></tr><tr><td data-num="22"></td><td><pre>            path<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>            used<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="26"></td><td><pre></pre></td></tr><tr><td data-num="27"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span><span class="token punctuation">></span></span> <span class="token function">permute</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>        <span class="token comment">// 记录 nums 中的元素是否已经被使用过</span></pre></td></tr><tr><td data-num="29"></td><td><pre>        <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span> used <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">boolean</span><span class="token punctuation">[</span>nums<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="30"></td><td><pre></pre></td></tr><tr><td data-num="31"></td><td><pre>        <span class="token function">backtracking</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> used<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>        <span class="token keyword">return</span> res<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="33"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="34"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20221228092601283.png" alt="image-20221228092601283"></p><h4 id="总结-42"><a class="anchor" href="#总结-42">#</a> 总结</h4><p>大家此时可以感受出排列问题的不同：</p><ul><li>每层都是从 0 开始搜索而不是 startIndex</li><li>需要 used 数组记录 path 里都放了哪些元素了</li></ul><p>排列问题是回溯算法解决的经典题目，大家可以好好体会体会。</p><h3 id="47-全排列-ii"><a class="anchor" href="#47-全排列-ii">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9wZXJtdXRhdGlvbnMtaWkv">47. 全排列 II</span></h3><blockquote><p>与 [46. 全排列](#46. 全排列) 的区别是：包含可重复数字</p><p>关键：如何<strong>去重</strong>？<mark><strong>排序 + used 数组</strong></mark>！</p></blockquote><h4 id="思路-10"><a class="anchor" href="#思路-10">#</a> 思路</h4><p>这道题目和 [46. 全排列](#46. 全排列) 的区别在与<strong>给定一个可包含重复数字的序列</strong>，要返回<strong>所有不重复的全排列</strong>。</p><p>这里又涉及到去重了。</p><p>在 [40. 组合总和 II](#40. 组合总和 II)、[90. 子集 II](#90. 子集 II) 我们分别详细讲解了组合问题、子集问题如何去重。</p><p>那么排列问题其实也是一样的套路。</p><p><strong>还要强调的是去重一定要对元素进行排序，这样我们才方便通过相邻的节点来判断是否重复使用了</strong>。</p><p>我以示例中的 [1,1,2] 为例 （为了方便举例，已经排序）抽象为一棵树，去重过程如图：</p><p><img data-src="https://img-blog.csdnimg.cn/20201124201331223.png" alt="47.全排列II1"></p><p>图中我们对同一树层，前一位（也就是 nums [i-1]）如果使用过，那么就进行去重。</p><p><strong>一般来说：组合问题、排列问题是在树形结构的<u>叶子节点</u>上收集结果，而子集问题就是取树上<u>所有节点</u>的结果</strong>。</p><p>在 [46. 全排列](#46. 全排列) 中已经详细讲解了排列问题的写法，在 [40. 组合总和 II](#40. 组合总和 II)、[90. 子集 II](#90. 子集 II) 中详细讲解了去重的写法，所以这次我就不用回溯三部曲分析了，直接给出代码，如下：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span><span class="token punctuation">></span></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> path <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">backtracking</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span> used<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token comment">// 递归终止条件</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>            res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>            <span class="token keyword">return</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token comment">// 单层搜索的逻辑</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>            <span class="token comment">//used [i - 1] == true，说明同⼀树⽀ nums [i - 1] 使⽤过</span></pre></td></tr><tr><td data-num="14"></td><td><pre>            <span class="token comment">//used [i - 1] == false，说明同⼀树层 nums [i - 1] 使⽤过</span></pre></td></tr><tr><td data-num="15"></td><td><pre>            <span class="token comment">// 剪枝（去重）：如果同一树层上出现相同的元素，且前一个元素未被使用过，则跳过</span></pre></td></tr><tr><td data-num="16"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> used<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>                <span class="token keyword">continue</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="19"></td><td><pre></pre></td></tr><tr><td data-num="20"></td><td><pre>            <span class="token comment">// 如果同一树枝上 nums [i] 还没被使用过，则开始处理</span></pre></td></tr><tr><td data-num="21"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>used<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>                <span class="token comment">// 处理节点</span></pre></td></tr><tr><td data-num="23"></td><td><pre>                path<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>                used<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>                <span class="token comment">// 递归</span></pre></td></tr><tr><td data-num="26"></td><td><pre>                <span class="token function">backtracking</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> used<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>                <span class="token comment">// 回溯，撤销处理的节点</span></pre></td></tr><tr><td data-num="28"></td><td><pre>                path<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>                used<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="31"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="32"></td><td><pre></pre></td></tr><tr><td data-num="33"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="34"></td><td><pre></pre></td></tr><tr><td data-num="35"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span><span class="token punctuation">></span></span> <span class="token function">permuteUnique</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="36"></td><td><pre>        <span class="token comment">// 排序，使得相同的元素都相邻，方便剪枝（去重）</span></pre></td></tr><tr><td data-num="37"></td><td><pre>        <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="38"></td><td><pre></pre></td></tr><tr><td data-num="39"></td><td><pre>        <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span> used <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">boolean</span><span class="token punctuation">[</span>nums<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="40"></td><td><pre>        <span class="token function">backtracking</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> used<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="41"></td><td><pre>        <span class="token keyword">return</span> res<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="42"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="43"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h4 id="拓展-3"><a class="anchor" href="#拓展-3">#</a> 拓展</h4><p>大家发现，去重最为关键的代码为：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> used<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 对 树层 中前一位去重</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">continue</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><strong>如果改成 <code>used[i - 1] == true</code> ， 也是正确的！</strong>，去重代码如下：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> used<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 对 树枝 中前一位去重</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">continue</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>这是为什么呢，就是上面我刚说的，</p><ul><li>如果要对<strong>树层</strong>中前一位去重，就用 <code>used[i - 1] == false</code></li><li>如果要对<strong>树枝</strong>中前一位去重，就用 <code>used[i - 1] == true</code></li></ul><p><strong>对于排列问题，树层上去重和树枝上去重，都是可以的，但是树层上去重效率更高！</strong></p><p>这么说是不是有点抽象？</p><p>来来来，我就用输入: [1,1,1] 来举一个例子。</p><ul><li><strong>树层</strong>上去重 (used [i - 1] == false)，的树形结构如下：</li></ul><p><img data-src="https://img-blog.csdnimg.cn/20201124201406192.png" alt="47.全排列II2"></p><ul><li><strong>树枝</strong>上去重（used [i - 1] == true）的树型结构如下：</li></ul><p><img data-src="https://img-blog.csdnimg.cn/20201124201431571.png" alt="47.全排列II3"></p><p>大家应该很清晰的看到，<strong>树层上对前一位去重非常彻底，效率很高</strong>，树枝上对前一位去重虽然最后可以得到答案，但是做了很多无用搜索。</p><h3 id="本周小结回溯算法系列三"><a class="anchor" href="#本周小结回溯算法系列三">#</a> 本周小结！（回溯算法系列三）</h3><h4 id="周一-7"><a class="anchor" href="#周一-7">#</a> 周一</h4><p>在 [90. 子集 II](#90. 子集 II) 中，开始针对子集问题进行去重。</p><p>本题就是 [78. 子集](#78. 子集) 的基础上加上了去重，去重我们在 [40. 组合总和 II](#40. 组合总和 II) 也讲过了。</p><p>所以本题对大家应该并不难。</p><p>树形结构如下：</p><p><img data-src="https://img-blog.csdnimg.cn/2020111217110449.png" alt="90.子集II"></p><h4 id="周二-7"><a class="anchor" href="#周二-7">#</a> 周二</h4><p>在 [491. 递增子序列](#491. 递增子序列) 中，处处都能看到子集的身影，但处处是陷阱，值得好好琢磨琢磨！</p><p>树形结构如下： <img data-src="https://img-blog.csdnimg.cn/20201112170832333.png" alt="491. 递增子序列1"></p><p>[491. 递增子序列](#491. 递增子序列) 留言区大家有很多疑问，主要还是和 [90. 子集 II](#90. 子集 II) 混合在了一起。</p><h4 id="周三-7"><a class="anchor" href="#周三-7">#</a> 周三</h4><p>我们已经分析了组合问题，分割问题，子集问题，那么 [排列问题](#46. 全排列) 又不一样了。</p><p>排列是有序的，也就是说 [1,2] 和 [2,1] 是两个集合，这和之前分析的子集以及组合所不同的地方。</p><p>可以看出元素 1 在 [1,2] 中已经使用过了，但是在 [2,1] 中还要在使用一次 1，所以处理排列问题就<strong>不用使用 startIndex</strong> 了。</p><p>如图： <img data-src="https://img-blog.csdnimg.cn/20201112170304979.png" alt="46.全排列"></p><p><strong>大家此时可以感受出排列问题的不同：</strong></p><ul><li>每层都是<strong>从 0 开始搜索</strong>而不是 startIndex</li><li>需要<strong> used 数组记录 path 里都放了哪些元素</strong></li></ul><h4 id="周四-7"><a class="anchor" href="#周四-7">#</a> 周四</h4><p>排列问题也要去重了，在 [47. 全排列 II](#47. 全排列 II) 中又一次强调了 “树层去重” 和 “树枝去重”。</p><p>树形结构如下：</p><p><img data-src="https://img-blog.csdnimg.cn/20201112171930470.png" alt="47.全排列II1"></p><p><strong>这道题目神奇的地方就是 used [i - 1] == false 也可以，used [i - 1] == true 也可以！</strong></p><p>我就用输入: [1,1,1] 来举一个例子。</p><ul><li><strong>树层</strong>上去重 ( <code>used[i - 1] == false</code> )，的树形结构如下：</li></ul><p><img data-src="https://img-blog.csdnimg.cn/20201112172230434.png" alt="47.全排列II2.png"></p><ul><li><strong>树枝</strong>上去重（ <code>used[i - 1] == true</code> ）的树型结构如下：</li></ul><p><img data-src="https://img-blog.csdnimg.cn/20201112172327967.png" alt="47.全排列II3"></p><p><strong>可以清晰的看到使用 (used [i - 1] == false)，即树层去重，效率更高！</strong></p><h4 id="性能分析"><a class="anchor" href="#性能分析">#</a> 性能分析</h4><p>之前并没有分析各个问题的时间复杂度和空间复杂度，这次来说一说。</p><p>这块网上的资料鱼龙混杂，一些所谓的经典面试书籍根本不讲回溯算法，算法书籍对这块也避而不谈，感觉就像是算法里模糊的边界。</p><p><strong>所以这块就说一说我个人理解，对内容持开放态度，集思广益，欢迎大家来讨论！</strong></p><p>子集问题分析：</p><ul><li>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>×</mo><msup><mn>2</mn><mi>n</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n × 2^n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.664392em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，因为每一个元素的状态无外乎取与不取，所以时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mn>2</mn><mi>n</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(2^n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.664392em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，构造每一组子集都需要填进数组，又有需要<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，最终时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>×</mo><msup><mn>2</mn><mi>n</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n × 2^n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.664392em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。</li><li>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，递归深度为 n，所以系统栈所用空间为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，每一层递归所用的空间都是常数级别，注意代码里的 result 和 path 都是全局变量，就算是放在参数里，传的也是引用，并不会新申请内存空间，最终空间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。</li></ul><p>排列问题分析：</p><ul><li>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">!</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n!)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">!</span><span class="mclose">)</span></span></span></span>，这个可以从排列的树形图中很明显发现，每一层节点为 n，第二层每一个分支都延伸了 n-1 个分支，再往下又是 n-2 个分支，所以一直到叶子节点一共就是 n * n-1 * n-2 * ..... 1 = n!。每个叶子节点都会有一个构造全排列填进数组的操作（对应的代码： <code>result.push_back(path)</code> ），该操作的复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。所以，最终时间复杂度为：n * n!，简化为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">!</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n!)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">!</span><span class="mclose">)</span></span></span></span>。</li><li>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，和子集问题同理。</li></ul><p>组合问题分析：</p><ul><li>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>×</mo><msup><mn>2</mn><mi>n</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n × 2^n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.664392em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，组合问题其实就是一种子集的问题，所以组合问题最坏的情况，也不会超过子集问题的时间复杂度。</li><li>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，和子集问题同理。</li></ul><p><strong>一般说道回溯算法的复杂度，都说是指数级别的时间复杂度，这也算是一个概括吧！</strong></p><h4 id="总结-43"><a class="anchor" href="#总结-43">#</a> 总结</h4><p>本周我们对 [90. 子集 II](#90. 子集 II)，然后介绍了和子集问题非常像的 [491. 递增子序列](#491. 递增子序列)，如果还保持惯性思维，这道题就可以掉坑里。</p><p>接着介绍了 [排列问题](#46. 全排列)，以及对 [47. 全排列 II](#47. 全排列 II)。</p><p>最后我补充了子集问题，排列问题和组合问题的性能分析，给大家提供了回溯算法复杂度的分析思路。</p><h3 id="332-重新安排行程"><a class="anchor" href="#332-重新安排行程">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yZWNvbnN0cnVjdC1pdGluZXJhcnkv">☆332. 重新安排行程</span></h3><blockquote><p>这也可以用回溯法？ 其实深搜和回溯也是相辅相成的，毕竟都用递归。</p></blockquote><h4 id="思路-11"><a class="anchor" href="#思路-11">#</a> 思路</h4><p>这道题目还是很难的，之前我们用回溯法解决了如下问题：<span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVyY2FybC5jb20vMDA3Ny4lRTclQkIlODQlRTUlOTAlODguaHRtbA==">组合问题</span>，<span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVyY2FybC5jb20vMDA5My4lRTUlQTQlOEQlRTUlOEUlOUZJUCVFNSU5QyVCMCVFNSU5RCU4MC5odG1s">分割问题</span>，<span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVyY2FybC5jb20vMDA3OC4lRTUlQUQlOTAlRTklOUIlODYuaHRtbA==">子集问题</span>，<span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVyY2FybC5jb20vMDA0Ni4lRTUlODUlQTglRTYlOEUlOTIlRTUlODglOTcuaHRtbA==">排列问题</span>。</p><p>直觉上来看 这道题和回溯法没有什么关系，更像是图论中的深度优先搜索。</p><p>实际上确实是深搜，但这是<strong>深搜中使用了回溯</strong>的例子，在查找路径的时候，如果不回溯，怎么能查到目标路径呢。</p><p>所以我倾向于说本题应该使用回溯法，那么我也用回溯法的思路来讲解本题，其实深搜一般都使用了回溯法的思路，在图论系列中我会再详细讲解深搜。</p><p><strong>这里就是先给大家拓展一下，原来回溯法还可以这么玩！</strong></p><p><strong>这道题目有几个难点：</strong></p><ol><li>一个行程中，如果航班处理不好容易变成一个圈，成为<strong>死循环</strong></li><li>有多种解法，字母序靠前排在前面，让很多同学望而退步，该<strong>如何记录映射关系</strong>呢 ？</li><li>使用回溯法（也可以说深搜） 的话，那么<strong>终止条件是什么</strong>呢？</li><li>搜索的过程中，<strong>如何遍历一个机场所对应的所有机场</strong>。</li></ol><p>针对以上问题我来逐一解答！</p><h4 id="如何理解死循环"><a class="anchor" href="#如何理解死循环">#</a> 如何理解死循环</h4><p>对于死循环，我来举一个有重复机场的例子：</p><p><img data-src="https://img-blog.csdnimg.cn/20201115180537865.png" alt="332.重新安排行程"></p><p>为什么要举这个例子呢，就是告诉大家，出发机场和到达机场也会重复的，<strong>如果在解题的过程中没有对集合元素处理好，就会死循环。</strong></p><h4 id="如何记录映射关系"><a class="anchor" href="#如何记录映射关系">#</a> 如何记录映射关系</h4><p>有多种解法，字母序靠前排在前面，让很多同学望而退步，如何该记录映射关系呢 ？</p><p>一个机场映射多个机场，机场之间要靠字母序排列。一个机场映射多个机场，可以使用 std::unordered_map，如果让多个机场之间再有顺序的话，就是用 std::map 或者 std::multimap 或者 std::multiset。</p><p>如果对 map 和 set 的实现机制不太了解，也不清楚为什么 map、multimap 就是有序的同学，可以看这篇文章<span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVyY2FybC5jb20vJUU1JTkzJTg4JUU1JUI4JThDJUU4JUExJUE4JUU3JTkwJTg2JUU4JUFFJUJBJUU1JTlGJUJBJUU3JUExJTgwLmh0bWw=">关于哈希表，你该了解这些！</span>。</p><p>这样存放映射关系可以定义为 <code>unordered_map&lt;string, multiset&lt;string&gt;&gt; targets</code> 或者 <code>unordered_map&lt;string, map&lt;string, int&gt;&gt; targets</code> 。</p><p>含义如下：</p><ul><li><p>unordered_map &lt;出发机场，到达机场的集合&gt; targets</p></li><li><p>unordered_map &lt;出发机场，map &lt; 到达机场，航班次数&gt;&gt; targets</p></li></ul><p>这两个结构，我选择了后者，因为如果使用 <code>unordered_map&lt;string, multiset&lt;string&gt;&gt; targets</code> 遍历 multiset 的时候，不能删除元素，一旦删除元素，迭代器就失效了。</p><p><strong>再说一下为什么一定要增删元素呢，正如开篇我给出的图中所示，出发机场和到达机场是会重复的，搜索的过程没及时删除目的机场就会死循环。</strong></p><p>所以搜索的过程中就是要不断的删 multiset 里的元素，那么推荐使用 <code>unordered_map&lt;string, map&lt;string, int&gt;&gt; targets</code> 。</p><p>在遍历 <code>unordered_map&lt;出发机场, map&lt;到达机场, 航班次数&gt;&gt; targets</code> 的过程中，<strong>可以使用 &quot;航班次数&quot; 这个字段的数字做相应的增减，来标记到达机场是否使用过了。</strong></p><p>如果 “航班次数” 大于零，说明目的地还可以飞，如果 “航班次数” 等于零说明目的地不能飞了，而不用对集合做删除元素或者增加元素的操作。</p><p><strong>相当于说我不删，我就做一个标记！</strong></p><h4 id="回溯三部曲-10"><a class="anchor" href="#回溯三部曲-10">#</a> 回溯三部曲</h4><p>本题以输入：[[&quot;JFK&quot;, &quot;KUL&quot;], [&quot;JFK&quot;, &quot;NRT&quot;], [&quot;NRT&quot;, &quot;JFK&quot;] 为例，抽象为树形结构如下：</p><p><img data-src="https://img-blog.csdnimg.cn/2020111518065555.png" alt="332.重新安排行程1"></p><p>开始回溯三部曲讲解：</p><ol><li><p>参数、返回值：</p><ul><li><p>结果变量<strong> res</strong>，定义为全局变量</p></li><li><p>使用 <code>unordered_map&lt;string, map&lt;string, int&gt;&gt; targets;</code> 来记录航班的映射关系，我定义为<strong>全局变量</strong></p><blockquote><p>当然把参数放进函数里传进去也是可以的，我是尽量控制函数里参数的长度</p></blockquote></li><li><p>参数里还需要<strong> ticketNum</strong>，表示有多少个航班（终止条件会用上）</p></li></ul><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment">// Map&lt; 出发机场，Map&lt; 到达机场，航班次数 >> targets，记录每个机场的映射</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">private</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Map</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">></span><span class="token punctuation">></span></span> targets <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token comment">//ticketNum 表示航班数量</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">backtracking</span><span class="token punctuation">(</span><span class="token keyword">int</span> ticketNum<span class="token punctuation">)</span></pre></td></tr></table></figure><p><strong>注意函数返回值我用的是 bool！</strong></p><p>我们之前讲解回溯算法的时候，一般函数返回值都是 void，这次为什么是 bool 呢？</p><p>因为我们只需要找到一个行程，就是在树形结构中唯一的一条通向叶子节点的路线</p><p>所以找到了这个叶子节点了直接返回，这个递归函数的返回值问题我们在讲解二叉树的系列的时候，在这篇 [二叉树：递归函数究竟什么时候需要返回值，什么时候不要返回值？](#☆112. 路径总和) 详细介绍过。</p><p>当然本题的 targets 和 result 都需要初始化，代码如下：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre>res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"JFK"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 初始化起点</span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">// 根据 tickets 初始化 targets，注意题目要求按字典排序返回最小的行程组合，所以要对 targets 进行升序排序</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> ticket <span class="token operator">:</span> tickets<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token class-name">String</span> from <span class="token operator">=</span> ticket<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 出发机场</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token class-name">String</span> <span class="token keyword">to</span> <span class="token operator">=</span> ticket<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 到达机场</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>targets<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>from<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 如果 targets 中不包含该出发机场，则添加</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        targets<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>from<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">TreeMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// TreeMap 是有序的！！！</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre></pre></td></tr><tr><td data-num="12"></td><td><pre>    targets<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>from<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token keyword">to</span><span class="token punctuation">,</span> targets<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>from<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getOrDefault</span><span class="token punctuation">(</span><span class="token keyword">to</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 记录该航班的剩余次数</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p><strong>在 Java 中，TreeMap 是升序的 Map</strong>。</p></blockquote></li><li><p>递归终止条件：</p><p>拿题目中的示例为例，输入: [[&quot;MUC&quot;, &quot;LHR&quot;], [&quot;JFK&quot;, &quot;MUC&quot;], [&quot;SFO&quot;, &quot;SJC&quot;], [&quot;LHR&quot;, &quot;SFO&quot;]] ，这是有 4 个航班，那么只要找出一种行程，行程里的机场个数是 5 就可以了。</p><p>所以终止条件是：我们回溯遍历的过程中，<strong>遇到的机场个数，如果达到了（航班数量 + 1）</strong>，那么我们就找到了一个行程，把所有航班串在一起了。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 递归终止条件：遇到的机场个数 res.size ()，如果达到了（ticketNum+1），返回 true</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">if</span> <span class="token punctuation">(</span>res<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> ticketNum <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>已经看习惯回溯法代码的同学，到叶子节点了习惯性的想要收集结果，但发现并不需要，本题的 result 相当于 [216. 组合总和 III](#216. 组合总和 III) 中的 path，也就是本题的 result 就是记录路径的（就一条），在如下单层搜索的逻辑中 result 就添加元素了。</p></li><li><p>单层搜索的逻辑：</p><p>回溯的过程中，如何<strong>遍历一个机场所对应的所有机场</strong>呢？</p><p>这里刚刚说过，在选择映射函数的时候，不能选择 <code>unordered_map&lt;string, multiset&lt;string&gt;&gt; targets</code> ， 因为一旦有元素增删 multiset 的迭代器就会失效，当然可能有牛逼的容器删除元素迭代器不会失效，这里就不在讨论了。</p><p><strong>可以说本题既要找到一个对数据进行排序的容器，而且还要容易增删元素，迭代器还不能失效</strong>。</p><p>所以我选择了 <code>unordered_map&lt;string, map&lt;string, int&gt;&gt; targets</code> 来做机场之间的映射。</p><p>遍历过程如下：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 单层搜索的逻辑：从当前机场 res.get (res.size () - 1) 出发，遍历其所有的目的地机场</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name">String</span> latest_from <span class="token operator">=</span> res<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 当前机场</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">if</span> <span class="token punctuation">(</span>targets<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>latest_from<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 如果当前机场有目的地机场，遍历。</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">></span></span> target <span class="token operator">:</span> targets<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>latest_from<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>target<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 判断该航班是否还有剩余，即是否还能飞</span></pre></td></tr><tr><td data-num="6"></td><td><pre>            <span class="token comment">// 处理节点</span></pre></td></tr><tr><td data-num="7"></td><td><pre>            res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>target<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 添加目的地机场</span></pre></td></tr><tr><td data-num="8"></td><td><pre>            target<span class="token punctuation">.</span><span class="token function">setValue</span><span class="token punctuation">(</span>target<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将该航班的剩余次数减 1</span></pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre>            <span class="token comment">// 递归</span></pre></td></tr><tr><td data-num="11"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">backtracking</span><span class="token punctuation">(</span>ticketNum<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment">// 如果找到了，直接返回 true</span></pre></td></tr><tr><td data-num="13"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre></pre></td></tr><tr><td data-num="15"></td><td><pre>            <span class="token comment">// 回溯，撤销处理的节点</span></pre></td></tr><tr><td data-num="16"></td><td><pre>            res<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 删除目的地机场</span></pre></td></tr><tr><td data-num="17"></td><td><pre>            target<span class="token punctuation">.</span><span class="token function">setValue</span><span class="token punctuation">(</span>target<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将该航班的剩余次数加 1</span></pre></td></tr><tr><td data-num="18"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>可以看出 通过 <code>unordered_map&lt;string, map&lt;string, int&gt;&gt; targets</code> 里的 int 字段来判断 这个集合里的机场是否使用过，这样避免了直接去删元素。</p></li></ol><p>完整的 java 代码如下：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token comment">// Map&lt; 出发机场，Map&lt; 到达机场，航班次数 >> targets，记录每个机场的映射</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">private</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Map</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">></span><span class="token punctuation">></span></span> targets <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token comment">//ticketNum 表示航班数量</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">backtracking</span><span class="token punctuation">(</span><span class="token keyword">int</span> ticketNum<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token comment">// 递归终止条件：遇到的机场个数 res.size ()，如果达到了（ticketNum+1），返回 true</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>res<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> ticketNum <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token comment">// 单层搜索的逻辑：从当前机场 res.get (res.size () - 1) 出发，遍历其所有的目的地机场</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token class-name">String</span> latest_from <span class="token operator">=</span> res<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 当前机场</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>targets<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>latest_from<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 如果当前机场有目的地机场，遍历。</span></pre></td></tr><tr><td data-num="16"></td><td><pre>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">></span></span> target <span class="token operator">:</span> targets<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>latest_from<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>                <span class="token keyword">if</span> <span class="token punctuation">(</span>target<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 判断该航班是否还有剩余，即是否还能飞</span></pre></td></tr><tr><td data-num="18"></td><td><pre>                    <span class="token comment">// 处理节点</span></pre></td></tr><tr><td data-num="19"></td><td><pre>                    res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>target<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 添加目的地机场</span></pre></td></tr><tr><td data-num="20"></td><td><pre>                    target<span class="token punctuation">.</span><span class="token function">setValue</span><span class="token punctuation">(</span>target<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将该航班的剩余次数减 1</span></pre></td></tr><tr><td data-num="21"></td><td><pre></pre></td></tr><tr><td data-num="22"></td><td><pre>                    <span class="token comment">// 递归</span></pre></td></tr><tr><td data-num="23"></td><td><pre>                    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">backtracking</span><span class="token punctuation">(</span>ticketNum<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>                        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment">// 如果找到了，直接返回 true</span></pre></td></tr><tr><td data-num="25"></td><td><pre>                    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="26"></td><td><pre></pre></td></tr><tr><td data-num="27"></td><td><pre>                    <span class="token comment">// 回溯，撤销处理的节点</span></pre></td></tr><tr><td data-num="28"></td><td><pre>                    res<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 删除目的地机场</span></pre></td></tr><tr><td data-num="29"></td><td><pre>                    target<span class="token punctuation">.</span><span class="token function">setValue</span><span class="token punctuation">(</span>target<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将该航班的剩余次数加 1</span></pre></td></tr><tr><td data-num="30"></td><td><pre>                <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="31"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="33"></td><td><pre></pre></td></tr><tr><td data-num="34"></td><td><pre>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">// 如果没有找到，返回 false</span></pre></td></tr><tr><td data-num="35"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="36"></td><td><pre></pre></td></tr><tr><td data-num="37"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> <span class="token function">findItinerary</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span><span class="token punctuation">></span></span> tickets<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="38"></td><td><pre>        res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"JFK"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 初始化起点</span></pre></td></tr><tr><td data-num="39"></td><td><pre></pre></td></tr><tr><td data-num="40"></td><td><pre>        <span class="token comment">// 根据 tickets 初始化 targets，注意题目要求按字典排序返回最小的行程组合，所以要对 targets 进行升序排序</span></pre></td></tr><tr><td data-num="41"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> ticket <span class="token operator">:</span> tickets<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="42"></td><td><pre>            <span class="token class-name">String</span> from <span class="token operator">=</span> ticket<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 出发机场</span></pre></td></tr><tr><td data-num="43"></td><td><pre>            <span class="token class-name">String</span> <span class="token keyword">to</span> <span class="token operator">=</span> ticket<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 到达机场</span></pre></td></tr><tr><td data-num="44"></td><td><pre></pre></td></tr><tr><td data-num="45"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>targets<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>from<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 如果 targets 中不包含该出发机场，则添加</span></pre></td></tr><tr><td data-num="46"></td><td><pre>                targets<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>from<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">TreeMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// TreeMap 是有序的！！！</span></pre></td></tr><tr><td data-num="47"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="48"></td><td><pre></pre></td></tr><tr><td data-num="49"></td><td><pre>            targets<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>from<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token keyword">to</span><span class="token punctuation">,</span> targets<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>from<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getOrDefault</span><span class="token punctuation">(</span><span class="token keyword">to</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 记录该航班的剩余次数</span></pre></td></tr><tr><td data-num="50"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="51"></td><td><pre></pre></td></tr><tr><td data-num="52"></td><td><pre>        <span class="token function">backtracking</span><span class="token punctuation">(</span>tickets<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="53"></td><td><pre>        <span class="token keyword">return</span> res<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="54"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="55"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h4 id="总结-44"><a class="anchor" href="#总结-44">#</a> 总结</h4><p><strong>如果单纯的回溯搜索（深搜）并不难，难还难在容器的选择和使用上</strong>。</p><p>本题其实是一道深度优先搜索的题目，但是我完全使用回溯法的思路来讲解这道题题目，<strong>算是给大家拓展一下思维方式，其实深搜和回溯也是分不开的，毕竟最终都是用递归</strong>。</p><p>如果最终代码，发现照着回溯法模板画的话好像也能画出来，但难就难如何知道可以使用回溯，以及如果套进去，所以我再写了这么长的一篇来详细讲解。</p><h3 id="51-n-皇后"><a class="anchor" href="#51-n-皇后">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9uLXF1ZWVucy8=">☆51. N 皇后</span></h3><h4 id="思路-12"><a class="anchor" href="#思路-12">#</a> 思路</h4><p>都知道 n 皇后问题是回溯算法解决的经典问题，但是用回溯解决多了组合、切割、子集、排列问题之后，遇到这种<strong>二维矩阵</strong>还会有点不知所措。</p><p>首先来看一下皇后们的<strong>约束条件</strong>：</p><ol><li>不能同行</li><li>不能同列</li><li>不能同斜线</li></ol><p>确定完约束条件，来看看究竟要<strong>怎么搜索</strong>皇后们的位置，其实搜索皇后的位置，可以抽象为一棵树。</p><p>下面我用一个 3 * 3 的棋盘，将搜索过程抽象为一棵树，如图：</p><p><img data-src="https://img-blog.csdnimg.cn/20210130182532303.jpg" alt="51.N皇后"></p><p>从图中，可以看出，二维矩阵中<strong>矩阵的高就是这棵树的高度，矩阵的宽就是树形结构中每一个节点的宽度</strong>。</p><p>那么我们用皇后们的约束条件，来回溯搜索这棵树，<strong>只要搜索到了树的叶子节点，说明就找到了皇后们的合理位置了</strong>。</p><blockquote><p>因为递归前会检测是否合理，所以只要能到达叶子节点，都是合理的</p></blockquote><h4 id="回溯三部曲-11"><a class="anchor" href="#回溯三部曲-11">#</a> 回溯三部曲</h4><ol><li><p>参数：</p><ul><li>res：全局变量二维数组，记录结果</li><li>n：棋盘大小</li><li>row：记录当前遍历到棋盘第几行</li><li>chessboard：记录当前棋盘</li></ul><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span><span class="token punctuation">></span></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">backtracking</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> row<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> chessboard<span class="token punctuation">)</span></pre></td></tr></table></figure></li><li><p>递归终止条件：</p><p>当递归到棋盘最底层（也就是叶子节点）的时候，即 <code>row == n</code> 时，就可以收集结果并返回了。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">if</span> <span class="token punctuation">(</span>row <span class="token operator">==</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 将 char [][] 转换为 List&lt;String></span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> tmpList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> chars <span class="token operator">:</span> chessboard<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        tmpList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>chars<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token comment">// 将 List&lt;String> 加入结果集</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>tmpList<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token keyword">return</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure></li><li><p>单层搜索的逻辑：</p><p>递归深度就是<strong> row 控制棋盘的行</strong>，每一层里<strong> for 循环的 col 控制棋盘的列</strong>，一行一列，确定了放置皇后的位置。</p><p>每次都是要从新的一行的起始位置开始搜，所以都是<strong>从 0 开始</strong>。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> col <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> col <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> col<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isValid</span><span class="token punctuation">(</span>chessboard<span class="token punctuation">,</span> row<span class="token punctuation">,</span> col<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 只有合法时才放置</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token comment">// 做选择</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        chessboard<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'Q'</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token comment">// 进入下一层决策树</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token function">backtracking</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> row <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> chessboard<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token comment">// 撤销选择</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        chessboard<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'.'</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure></li></ol><h4 id="验证棋盘是否合法"><a class="anchor" href="#验证棋盘是否合法">#</a> 验证棋盘是否合法</h4><p>按照如下标准去重：</p><ol><li><p>不能同行</p><blockquote><p>可以不检查，因为在单层搜索的过程中，每一层递归，只会选 for 循环（也就是同一行）里的一个元素，所以不用去重了。</p></blockquote></li><li><p>不能同列</p></li><li><p>不能同斜线 （45 度和 135 度角）</p></li></ol><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 判断 (row, col) 是否可以放置皇后</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">isValid</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> chessboard<span class="token punctuation">,</span> <span class="token keyword">int</span> row<span class="token punctuation">,</span> <span class="token keyword">int</span> col<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">int</span> n <span class="token operator">=</span> chessboard<span class="token punctuation">.</span>length<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token comment">// 不用检查行，因为每行只放一个皇后</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token comment">// 检查列</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>chessboard<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'Q'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token comment">// 检查↗方向，因为是从上往下放，所以不用检查下方</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> row <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> j <span class="token operator">=</span> col <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">,</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>chessboard<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'Q'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    <span class="token comment">// 检查↖方向，因为是从上往下放，所以不用检查下方</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> row <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> j <span class="token operator">=</span> col <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> j <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">,</span> j<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>chessboard<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'Q'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h4 id="完整的java代码"><a class="anchor" href="#完整的java代码">#</a> 完整的 Java 代码</h4><p>可以看出，除了验证棋盘合法性的代码，剩下来部分就是按照回溯法模板来的。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span><span class="token punctuation">></span></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token comment">// 判断 (row, col) 是否可以放置皇后</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">isValid</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> chessboard<span class="token punctuation">,</span> <span class="token keyword">int</span> row<span class="token punctuation">,</span> <span class="token keyword">int</span> col<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token keyword">int</span> n <span class="token operator">=</span> chessboard<span class="token punctuation">.</span>length<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token comment">// 不用检查行，因为每行只放一个皇后</span></pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token comment">// 检查列</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>chessboard<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'Q'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token comment">// 检查↗方向，因为是从上往下放，所以不用检查下方</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> row <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> j <span class="token operator">=</span> col <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">,</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>chessboard<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'Q'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>        <span class="token comment">// 检查↖方向，因为是从上往下放，所以不用检查下方</span></pre></td></tr><tr><td data-num="23"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> row <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> j <span class="token operator">=</span> col <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> j <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">,</span> j<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>chessboard<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'Q'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="30"></td><td><pre></pre></td></tr><tr><td data-num="31"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">backtracking</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> row<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> chessboard<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>        <span class="token comment">// 递归终止条件</span></pre></td></tr><tr><td data-num="33"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>row <span class="token operator">==</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="34"></td><td><pre>            <span class="token comment">// 将 char [][] 转换为 List&lt;String></span></pre></td></tr><tr><td data-num="35"></td><td><pre>            <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> tmpList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="36"></td><td><pre>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> chars <span class="token operator">:</span> chessboard<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="37"></td><td><pre>                tmpList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>chars<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="38"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="39"></td><td><pre>            <span class="token comment">// 将 List&lt;String> 加入结果集</span></pre></td></tr><tr><td data-num="40"></td><td><pre>            res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>tmpList<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="41"></td><td><pre></pre></td></tr><tr><td data-num="42"></td><td><pre>            <span class="token keyword">return</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="43"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="44"></td><td><pre>        <span class="token comment">// 单层搜索的逻辑</span></pre></td></tr><tr><td data-num="45"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> col <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> col <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> col<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="46"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isValid</span><span class="token punctuation">(</span>chessboard<span class="token punctuation">,</span> row<span class="token punctuation">,</span> col<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 只有合法时才放置</span></pre></td></tr><tr><td data-num="47"></td><td><pre>                <span class="token comment">// 做选择</span></pre></td></tr><tr><td data-num="48"></td><td><pre>                chessboard<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'Q'</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="49"></td><td><pre>                <span class="token comment">// 进入下一层决策树</span></pre></td></tr><tr><td data-num="50"></td><td><pre>                <span class="token function">backtracking</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> row <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> chessboard<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="51"></td><td><pre>                <span class="token comment">// 撤销选择</span></pre></td></tr><tr><td data-num="52"></td><td><pre>                chessboard<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'.'</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="53"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="54"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="55"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="56"></td><td><pre></pre></td></tr><tr><td data-num="57"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span><span class="token punctuation">></span></span> <span class="token function">solveNQueens</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="58"></td><td><pre>        <span class="token comment">// 定义并初始化棋盘</span></pre></td></tr><tr><td data-num="59"></td><td><pre>        <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> chessboard <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">char</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="60"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="61"></td><td><pre>            <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span>chessboard<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token char">'.'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="62"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="63"></td><td><pre>        <span class="token comment">// 开始回溯</span></pre></td></tr><tr><td data-num="64"></td><td><pre>        <span class="token function">backtracking</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> chessboard<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="65"></td><td><pre>        <span class="token keyword">return</span> res<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="66"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="67"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h4 id="总结-45"><a class="anchor" href="#总结-45">#</a> 总结</h4><p>本题是我们解决棋盘问题的第一道题目。</p><p>如果从来没有接触过 N 皇后问题的同学看着这样的题会感觉无从下手，可能知道要用回溯法，但也不知道该怎么去搜。</p><p>这里我明确给出了<strong>棋盘的宽度就是 for 循环的长度</strong>，<strong>递归的深度就是棋盘的高度</strong>，这样就可以套进回溯法的模板里了。</p><h3 id="37-解数独"><a class="anchor" href="#37-解数独">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zdWRva3Utc29sdmVyLw==">☆37. 解数独</span></h3><p>棋盘搜索问题可以使用回溯法暴力搜索，只不过这次我们要做的是<strong>二维递归</strong>。</p><p>怎么做二维递归呢？</p><p>大家已经跟着「代码随想录」刷过了如下回溯法题目，例如：[77. 组合](#77. 组合)，[☆131. 分割回文串](#☆131. 分割回文串)，[78. 子集](#78. 子集)，[46. 全排列](#46. 全排列)，以及 [☆51. N 皇后](#☆51. N 皇后)，其实这些题目都是一维递归。</p><p><strong>如果以上这几道题目没有做过的话，不建议上来就做这道题哈！</strong></p><p>[☆51. N 皇后](#☆51. N 皇后) 是因为每一行每一列只放一个皇后，只需要一层 for 循环遍历一行，递归来遍历列，然后一行一列确定皇后的唯一位置。</p><p>本题就不一样了，<strong>本题中棋盘的每一个位置都要放一个数字（而 N 皇后是一行只放一个皇后），并检查数字是否合法，解数独的树形结构要比 N 皇后更宽更深</strong>。</p><p>因为这个树形结构太大了，我抽取一部分，如图所示：</p><p><img data-src="https://img-blog.csdnimg.cn/2020111720451790.png" alt="37.解数独"></p><h4 id="回溯三部曲-12"><a class="anchor" href="#回溯三部曲-12">#</a> 回溯三部曲</h4><ol><li><p>返回值、参数：</p><p><strong>递归函数的返回值需要是 bool 类型，为什么呢？</strong></p><p>因为解数独<strong>找到一个符合的条件（就在树的叶子节点上）立刻就返回</strong>，相当于找从根节点到叶子节点一条唯一路径，所以需要使用 bool 返回值。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">boolean</span> <span class="token function">backtracking</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> board<span class="token punctuation">)</span></pre></td></tr></table></figure></li><li><p>递归终止条件：</p><p>本题递归不用终止条件，解数独是要遍历整个树形结构寻找可能的叶子节点就立刻返回。</p><p><strong>不用终止条件会不会死循环？</strong></p><p>递归的下一层的棋盘一定比上一层的棋盘多一个数，等数填满了棋盘自然就终止（填满当然好了，说明找到结果了），所以不需要终止条件！</p><p><strong>那么有没有永远填不满的情况呢？</strong></p><p>这个问题我在递归单层搜索逻辑里再来讲！</p></li><li><p>单层搜索的逻辑：</p><p>在树形图中可以看出我们需要的是一个二维的递归（也就是两个 for 循环嵌套着递归）</p><p><strong>一个 for 循环遍历棋盘的行，一个 for 循环遍历棋盘的列，一行一列确定下来之后，递归遍历这个位置放 9 个数字的可能性！</strong></p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">boolean</span> <span class="token function">backtracking</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> board<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>        <span class="token comment">// 递归终止条件：不需要。等棋盘填满，自然会终止</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token comment">// 递归单层搜索逻辑</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> board<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 遍历行</span></pre></td></tr><tr><td data-num="6"></td><td><pre>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> board<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 遍历列</span></pre></td></tr><tr><td data-num="7"></td><td><pre>                <span class="token keyword">if</span> <span class="token punctuation">(</span>board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token char">'.'</span><span class="token punctuation">)</span> <span class="token comment">// 如果不是空格，跳过</span></pre></td></tr><tr><td data-num="8"></td><td><pre>                    <span class="token keyword">continue</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">char</span> c <span class="token operator">=</span> <span class="token char">'1'</span><span class="token punctuation">;</span> c <span class="token operator">&lt;=</span> <span class="token char">'9'</span><span class="token punctuation">;</span> c<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// (i,j) 位置遍历 1-9</span></pre></td></tr><tr><td data-num="10"></td><td><pre>                    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isValid</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> k<span class="token punctuation">,</span> board<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>                        <span class="token comment">// 做选择</span></pre></td></tr><tr><td data-num="12"></td><td><pre>                        board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> c<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>                        <span class="token comment">// 进入下一层决策树</span></pre></td></tr><tr><td data-num="14"></td><td><pre>                        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">backtracking</span><span class="token punctuation">(</span>board<span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="15"></td><td><pre>                            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>                        <span class="token comment">// 撤销选择</span></pre></td></tr><tr><td data-num="17"></td><td><pre>                        board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'.'</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>                    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>                <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>                <span class="token comment">// 1-9 都尝试过，依然没有找到可行解，此路不通</span></pre></td></tr><tr><td data-num="21"></td><td><pre>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>        <span class="token comment">// 递归完毕没返回 false，说明找到了可行解</span></pre></td></tr><tr><td data-num="25"></td><td><pre>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><strong>注意这里 return false 的地方，这里放 return false 是有讲究的</strong>。</p><p>因为如果一行一列确定下来了，这里尝试了 9 个数都不行，说明这个棋盘找不到解决数独问题的解！</p><p>那么会直接返回， <strong>这也就是为什么没有终止条件也不会永远填不满棋盘而无限递归下去！</strong></p></li></ol><h4 id="判断棋盘是否合法"><a class="anchor" href="#判断棋盘是否合法">#</a> 判断棋盘是否合法</h4><p>判断棋盘是否合法有如下三个维度：</p><ul><li>同行是否重复</li><li>同列是否重复</li><li>9 宫格里是否重复</li></ul><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">boolean</span> <span class="token function">isValid</span><span class="token punctuation">(</span><span class="token keyword">int</span> row<span class="token punctuation">,</span> <span class="token keyword">int</span> col<span class="token punctuation">,</span> <span class="token keyword">char</span> val<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> board<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 检查行里是否重复</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">9</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>board<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token comment">// 检查列里是否重复</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">9</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span> <span class="token operator">==</span> val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token comment">// 检查 3x3 宫格里是否重复</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token keyword">int</span> startRow <span class="token operator">=</span> row <span class="token operator">/</span> <span class="token number">3</span> <span class="token operator">*</span> <span class="token number">3</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token keyword">int</span> startCol <span class="token operator">=</span> col <span class="token operator">/</span> <span class="token number">3</span> <span class="token operator">*</span> <span class="token number">3</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> startRow<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> startRow <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> startCol<span class="token punctuation">;</span> j <span class="token operator">&lt;</span> startCol <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>    <span class="token comment">// 检查通过</span></pre></td></tr><tr><td data-num="25"></td><td><pre>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h4 id="完整的java代码-2"><a class="anchor" href="#完整的java代码-2">#</a> 完整的 Java 代码</h4><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">boolean</span> <span class="token function">isValid</span><span class="token punctuation">(</span><span class="token keyword">int</span> row<span class="token punctuation">,</span> <span class="token keyword">int</span> col<span class="token punctuation">,</span> <span class="token keyword">char</span> val<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> board<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token comment">// 检查行里是否重复</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">9</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>board<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token comment">// 检查列里是否重复</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">9</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span> <span class="token operator">==</span> val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token comment">// 检查 3x3 宫格里是否重复</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token keyword">int</span> startRow <span class="token operator">=</span> row <span class="token operator">/</span> <span class="token number">3</span> <span class="token operator">*</span> <span class="token number">3</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token keyword">int</span> startCol <span class="token operator">=</span> col <span class="token operator">/</span> <span class="token number">3</span> <span class="token operator">*</span> <span class="token number">3</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> startRow<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> startRow <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> startCol<span class="token punctuation">;</span> j <span class="token operator">&lt;</span> startCol <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>                <span class="token keyword">if</span> <span class="token punctuation">(</span>board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>                    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>                <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>        <span class="token comment">// 检查通过</span></pre></td></tr><tr><td data-num="26"></td><td><pre>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="28"></td><td><pre></pre></td></tr><tr><td data-num="29"></td><td><pre>    <span class="token keyword">boolean</span> <span class="token function">backtracking</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> board<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>        <span class="token comment">// 递归终止条件：不需要。等棋盘填满，自然会终止</span></pre></td></tr><tr><td data-num="31"></td><td><pre></pre></td></tr><tr><td data-num="32"></td><td><pre>        <span class="token comment">// 递归单层搜索逻辑</span></pre></td></tr><tr><td data-num="33"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> board<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 遍历行</span></pre></td></tr><tr><td data-num="34"></td><td><pre>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> board<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 遍历列</span></pre></td></tr><tr><td data-num="35"></td><td><pre>                <span class="token keyword">if</span> <span class="token punctuation">(</span>board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token char">'.'</span><span class="token punctuation">)</span> <span class="token comment">// 如果不是空格，跳过</span></pre></td></tr><tr><td data-num="36"></td><td><pre>                    <span class="token keyword">continue</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="37"></td><td><pre>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">char</span> c <span class="token operator">=</span> <span class="token char">'1'</span><span class="token punctuation">;</span> c <span class="token operator">&lt;=</span> <span class="token char">'9'</span><span class="token punctuation">;</span> c<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// (i,j) 位置遍历 1-9</span></pre></td></tr><tr><td data-num="38"></td><td><pre>                    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isValid</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> c<span class="token punctuation">,</span> board<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="39"></td><td><pre>                        <span class="token comment">// 做选择</span></pre></td></tr><tr><td data-num="40"></td><td><pre>                        board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> c<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="41"></td><td><pre>                        <span class="token comment">// 进入下一层决策树</span></pre></td></tr><tr><td data-num="42"></td><td><pre>                        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">backtracking</span><span class="token punctuation">(</span>board<span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="43"></td><td><pre>                            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="44"></td><td><pre>                        <span class="token comment">// 撤销选择</span></pre></td></tr><tr><td data-num="45"></td><td><pre>                        board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'.'</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="46"></td><td><pre>                    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="47"></td><td><pre>                <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="48"></td><td><pre>                <span class="token comment">// 1-9 都尝试过，依然没有找到可行解，此路不通</span></pre></td></tr><tr><td data-num="49"></td><td><pre>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="50"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="51"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="52"></td><td><pre>        <span class="token comment">// 递归完毕没返回 false，说明找到了可行解</span></pre></td></tr><tr><td data-num="53"></td><td><pre>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="54"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="55"></td><td><pre></pre></td></tr><tr><td data-num="56"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">solveSudoku</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> board<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="57"></td><td><pre>        <span class="token function">backtracking</span><span class="token punctuation">(</span>board<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="58"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="59"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230104164155643.png" alt="image-20230104164155643"></p><h4 id="总结-46"><a class="anchor" href="#总结-46">#</a> 总结</h4><p>解数独可以说是非常难的题目了，如果还一直停留在单层递归的逻辑中，这道题目可以让大家瞬间崩溃。</p><p>所以我在开篇就提到了<strong>二维递归</strong>，这也是我自创词汇，希望可以帮助大家理解解数独的搜索过程。</p><p>一波分析之后，再看代码会发现其实也不难，唯一难点就是理解<strong>二维递归</strong>的思维逻辑。</p><p><strong>这样，解数独这么难的问题，也被我们攻克了</strong>。</p><p><strong>恭喜一路上坚持打卡的录友们，回溯算法已经接近尾声了，接下来就是要一波总结了</strong>。</p><h3 id="回溯法总结篇"><a class="anchor" href="#回溯法总结篇">#</a> 回溯法总结篇</h3><p><strong>回溯是递归的副产品，只要有递归就会有回溯</strong>，所以回溯法也经常和二叉树遍历，深度优先搜索混在一起，因为这两种方式都是用了递归。</p><p>回溯法就是暴力搜索，并不是什么高效的算法，最多再剪枝一下。</p><p>回溯算法能解决如下问题：</p><ul><li>组合问题：N 个数里面按一定规则找出 k 个数的集合</li><li>排列问题：N 个数按一定规则全排列，有几种排列方式</li><li>切割问题：一个字符串按一定规则有几种切割方式</li><li>子集问题：一个 N 个数的集合里有多少符合条件的子集</li><li>棋盘问题：N 皇后，解数独等等</li></ul><p><strong>我在回溯算法系列讲解中就按照这个顺序给大家讲解，可以说深入浅出，步步到位</strong>。</p><p>回溯法确实不好理解，所以需要把回溯法抽象为一个图形来理解就容易多了，<strong>在后面的每一道回溯法的题目我都将遍历过程抽象为树形结构方便大家的理解</strong>。</p><p>回溯法的模板：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">void</span> <span class="token function">backtracking</span><span class="token punctuation">(</span>参数<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>终止条件<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        存放结果<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token keyword">return</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">for</span> <span class="token punctuation">(</span>选择：本层集合中元素（树中节点孩子的数量就是集合的大小）<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        处理节点<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token function">backtracking</span><span class="token punctuation">(</span>路径，选择列表<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 递归</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        回溯，撤销处理结果</pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h4 id="组合问题"><a class="anchor" href="#组合问题">#</a> 组合问题</h4><h5 id="组合问题-2"><a class="anchor" href="#组合问题-2">#</a> 组合问题</h5><p>在 [77. 组合](#77. 组合) 中，我们开始用回溯法解决第一道题目：组合问题。</p><p>我在文中开始的时候给大家列举 k 层 for 循环例子，进而得出都是同样是暴力解法，为什么要用回溯法！</p><p><strong>此时大家应该深有体会回溯法的魅力，用递归控制 for 循环嵌套的数量！</strong></p><p>本题我把回溯问题抽象为树形结构，如题：</p><p><img data-src="https://img-blog.csdnimg.cn/20201118152928844.png" alt="77.组合1"></p><p>可以直观的看出其搜索的过程：<strong>for 循环横向遍历，递归纵向遍历，回溯不断调整结果集</strong>，这个理念贯穿整个回溯法系列，也是我做了很多回溯的题目，不断摸索其规律才总结出来的。</p><p>对于回溯法的整体框架，网上搜的文章这块都说不清楚，按照天上掉下来的代码对着讲解，不知道究竟是怎么来的，也不知道为什么要这么写。</p><p><strong>所以，录友们刚开始学回溯法，起跑姿势就很标准了！</strong></p><p>优化回溯算法只有剪枝一种方法，在 [77. 组合优化](#77. 组合优化) 中把回溯法代码做了剪枝优化，树形结构如图：</p><p><img data-src="https://img-blog.csdnimg.cn/20201118153133458.png" alt="77.组合4"></p><p>大家可以一目了然剪的究竟是哪里。</p><p><strong>这里剪枝精髓是：for 循环在寻找起点的时候要有一个范围，如果这个起点到集合终止之间的元素已经不够题目要求的 k 个元素了，就没有必要搜索了</strong>。</p><p><strong>在 for 循环上做剪枝操作是回溯法剪枝的常见套路！</strong> 后面的题目还会经常用到。</p><h5 id="组合总和"><a class="anchor" href="#组合总和">#</a> 组合总和</h5><h6 id="组合总和一"><a class="anchor" href="#组合总和一">#</a> 组合总和（一）</h6><p>在 [216. 组合总和 III](#216. 组合总和 III) 中，相当于 [77. 组合](#77. 组合) 加了一个元素总和的限制。</p><p>树形结构如图： <img data-src="https://img-blog.csdnimg.cn/20201118201921245.png" alt="216.组合总和III"></p><p>整体思路还是一样的，本题的剪枝会好想一些，即：<strong>已选元素总和如果已经大于 n（题中要求的和）了，那么往后遍历就没有意义了，直接剪掉</strong>，如图：</p><p><img data-src="https://img-blog.csdnimg.cn/20201118202038240.png" alt="216.组合总和III1"></p><p>在本题中，依然还可以有一个剪枝，就是 [77. 组合优化](#77. 组合优化) 中提到的，对 for 循环选择的起始范围的剪枝。</p><p>所以剪枝的代码可以在 for 循环加上 <code>i &lt;= 9 - (k - path.size()) + 1</code> 的限制！</p><h6 id="组合总和二"><a class="anchor" href="#组合总和二">#</a> 组合总和（二）</h6><p>在 [39. 组合总和](#39. 组合总和) 中讲解的组合总和问题，和 [77. 组合](#77. 组合)，[216. 组合总和 III](#216. 组合总和 III) 的区别是：本题没有数量要求，可以无限重复，但是有总和的限制，所以间接的也是有个数的限制。</p><p>不少同学都是看到可以重复选择，就义无反顾的把 startIndex 去掉了。</p><p><strong>本题还需要 startIndex 来控制 for 循环的起始位置，对于组合问题，什么时候需要 startIndex 呢？</strong></p><blockquote><p>只是递归传入的 startIndex 参数不是 i+1，而是 i，因为可以重复选择</p></blockquote><ul><li><p>如果是一个集合来求组合的话，就需要 startIndex，例如：[77. 组合](#77. 组合)，[216. 组合总和 III](#216. 组合总和 III)</p></li><li><p>如果是多个集合取组合，各个集合之间相互不影响，那么就不用 startIndex，例如：[17. 电话号码的字母组合](#17. 电话号码的字母组合)</p></li></ul><p><strong>注意以上我只是说求组合的情况，如果是排列问题，又是另一套分析的套路</strong>。</p><p>树形结构如下：</p><p><img data-src="https://img-blog.csdnimg.cn/20201118152521990.png" alt="39.组合总和"></p><p>最后还给出了本题的剪枝优化，如下：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> startIndex<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> candidates<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> sum <span class="token operator">+</span> candidates<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> target<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span></pre></td></tr></table></figure><p>优化后树形结构如下：</p><p><img data-src="https://img-blog.csdnimg.cn/20201118202115929.png" alt="39.组合总和1"></p><h6 id="组合总和三"><a class="anchor" href="#组合总和三">#</a> 组合总和（三）</h6><p>在 [40. 组合总和 II](#40. 组合总和 II) 中集合元素会有重复，但要求解集不能包含重复的组合。</p><p><strong>所以难就难在<mark>去重</mark>问题上了</strong>。</p><blockquote><p>排序 + used 数组</p></blockquote><p>这个去重问题，相信做过的录友都知道有多么的晦涩难懂。网上的题解一般就说 “去掉重复”，但说不清怎么个去重，代码一甩就完事了。</p><p>为了讲解这个去重问题，<strong>Carl 自创了两个词汇，“树枝去重” 和 “树层去重”</strong>。</p><p>都知道组合问题可以抽象为树形结构，那么 “使用过” 在这个树形结构上是有两个维度的，一个维度是同一树枝上 “使用过”，一个维度是同一树层上 “使用过”。<strong>没有理解这两个层面上的 “使用过” 是造成大家没有彻底理解去重的根本原因</strong>。</p><p><img data-src="https://img-blog.csdnimg.cn/2020111820220675.png" alt="40.组合总和II1"></p><p>我在图中将 used 的变化用橘黄色标注上，<strong>可以看出在 candidates [i] == candidates [i - 1] 相同的情况下：</strong></p><ul><li>used [i - 1] == true，说明同一树枝 candidates [i - 1] 使用过</li><li>used [i - 1] == false，说明同一树层 candidates [i - 1] 使用过</li></ul><p><strong>这块去重的逻辑很抽象，网上搜的题解基本没有能讲清楚的，如果大家之前思考过这个问题或者刷过这道题目，看到这里一定会感觉通透了很多！</strong></p><p>对于去重，其实排列和子集问题也是一样的道理。</p><h5 id="多个集合求组合"><a class="anchor" href="#多个集合求组合">#</a> 多个集合求组合</h5><p>在 [17. 电话号码的字母组合](#17. 电话号码的字母组合) 中，开始用多个集合来求组合，还是熟悉的模板题目，但是有一些细节。</p><p>例如这里 for 循环，可不像是在 [77. 组合](#77. 组合)，[216. 组合总和 III](#216. 组合总和 III) 中从 startIndex 开始遍历的。</p><p><strong>因为本题每一个数字代表的是不同集合，也就是求不同集合之间的组合，而 [77. 组合](#77. 组合)，[216. 组合总和 III](#216. 组合总和 III) 都是是求同一个集合中的组合！</strong></p><p>树形结构如下：</p><p><img data-src="https://img-blog.csdnimg.cn/20201118202335724.png" alt="17. 电话号码的字母组合"></p><p>如果大家在现场面试的时候，一定要注意各种输入异常的情况，例如本题输入 1 * #按键。</p><p>其实本题不算难，但也处处是细节，还是要反复琢磨。</p><h4 id="切割问题"><a class="anchor" href="#切割问题">#</a> 切割问题</h4><p>在 [☆131. 分割回文串](#☆131. 分割回文串) 中，我们开始讲解切割问题，虽然最后代码看起来好像是一道模板题，但是从分析到学会套用这个模板，是比较难的。</p><p>我列出如下几个难点：</p><ul><li>切割问题其实类似组合问题</li><li>如何模拟那些切割线</li><li>切割问题中递归如何终止</li><li>在递归循环中如何截取子串</li><li>如何判断回文</li></ul><p>如果想到了<strong>用求解组合问题的思路来解决 切割问题本题就成功一大半了</strong>，接下来就可以对着模板照葫芦画瓢。</p><p><strong>但后序如何模拟切割线，如何终止，如何截取子串，其实都不好想，最后判断回文算是最简单的了</strong>。</p><p>所以本题应该是一个道 hard 题目了。</p><p>除了这些难点，<strong>本题还有细节，例如：切割过的地方不能重复切割所以递归函数需要传入 i + 1</strong>。</p><p>树形结构如下：</p><p><img data-src="https://img-blog.csdnimg.cn/20201118202448642.png" alt="131.分割回文串"></p><h4 id="子集问题"><a class="anchor" href="#子集问题">#</a> 子集问题</h4><h5 id="子集问题一"><a class="anchor" href="#子集问题一">#</a> 子集问题（一）</h5><p>在 [78. 子集](#78. 子集) 中讲解了子集问题，<strong>在树形结构中子集问题是要收集所有节点的结果，而组合问题是收集叶子节点的结果</strong>。</p><p>如图：</p><p><img data-src="https://img-blog.csdnimg.cn/20201118202544339.png" alt="78.子集"></p><p>认清这个本质之后，今天的题目就是一道模板题了。</p><p><strong>本题其实可以不需要加终止条件</strong>，因为 startIndex &gt;= nums.size ()，本层 for 循环本来也结束了，本来我们就要遍历整棵树。</p><p>有的同学可能担心不写终止条件会不会无限递归？</p><p>并不会，因为每次递归的下一层就是从 i+1 开始的。</p><p>如果要写终止条件，<strong>注意： <code>result.push_back(path);</code> 要放在终止条件的上面</strong>，如下：</p><figure class="highlight text"><figcaption data-lang="text"></figcaption><table><tr><td data-num="1"></td><td><pre>result.push_back(path); // 收集子集，要放在终止添加的上面，否则会漏掉结果</pre></td></tr><tr><td data-num="2"></td><td><pre>if (startIndex >= nums.size()) &#123; // 终止条件可以不加</pre></td></tr><tr><td data-num="3"></td><td><pre>    return;</pre></td></tr><tr><td data-num="4"></td><td><pre>&#125;</pre></td></tr></table></figure><h5 id="子集问题二"><a class="anchor" href="#子集问题二">#</a> 子集问题（二）</h5><p>在 [90. 子集 II](#90. 子集 II) 中，开始针对子集问题进行 **<mark> 去重</mark> **。</p><blockquote><p>排序 + used 数组！</p></blockquote><p>本题就是 [78. 子集](#78. 子集) 的基础上加上了去重，去重我们在 [40. 组合总和 II](#40. 组合总和 II) 也讲过了，一样的套路。</p><p>树形结构如下：</p><p><img data-src="https://img-blog.csdnimg.cn/2020111217110449.png" alt="90.子集II"></p><h5 id="递增子序列"><a class="anchor" href="#递增子序列">#</a> 递增子序列</h5><blockquote><p>不能通过排序 + used 数组来去重</p></blockquote><p>在 [491. 递增子序列](#491. 递增子序列) 中，处处都能看到子集的身影，但处处是陷阱，值得好好琢磨琢磨！</p><p>树形结构如下： <img data-src="https://img-blog.csdnimg.cn/20201112170832333.png" alt="491. 递增子序列1"></p><p>很多同学都会把这道题目和 [90. 子集 II](#90. 子集 II) 混在一起。</p><p><strong>[90. 子集 II](#90. 子集 II) 也可以使用 set 针对同一父节点本层去重，但子集问题一定要排序，为什么呢？</strong></p><p>我用没有排序的集合 {2,1,2,2} 来举个例子画一个图，如下：</p><p><img data-src="https://img-blog.csdnimg.cn/2020111316440479.png" alt="90.子集II2"></p><p><strong>相信这个图胜过千言万语的解释了</strong>。</p><h4 id="排列问题"><a class="anchor" href="#排列问题">#</a> 排列问题</h4><h5 id="排列问题一"><a class="anchor" href="#排列问题一">#</a> 排列问题（一）</h5><p>[46. 全排列](#46. 全排列) 又不一样了。</p><p>排列是有序的，也就是说 [1,2] 和 [2,1] 是两个集合，这和之前分析的子集以及组合所不同的地方。</p><p>可以看出元素 1 在 [1,2] 中已经使用过了，但是在 [2,1] 中还要在使用一次 1，所以<strong>处理排列问题就不用使用 startIndex 了</strong>。</p><p>如图：</p><p><img data-src="https://img-blog.csdnimg.cn/20201112170304979.png" alt="46.全排列"></p><p><strong>大家此时可以感受出排列问题的不同：</strong></p><ul><li>每层都是从 0 开始搜索而不是 startIndex</li><li>需要 used 数组记录 path 里都放了哪些元素了</li></ul><h5 id="排列问题二"><a class="anchor" href="#排列问题二">#</a> 排列问题（二）</h5><p>排列问题也要去重了，在 [47. 全排列 II](#47. 全排列 II) 中又一次强调了 “树层去重” 和 “树枝去重”。</p><p>树形结构如下：</p><p><img data-src="https://img-blog.csdnimg.cn/20201112171930470.png" alt="47.全排列II1"></p><p><strong>这道题目神奇的地方就是 used [i - 1] == false 也可以，used [i - 1] == true 也可以！</strong></p><p>我就用输入: [1,1,1] 来举一个例子。</p><p>树层上去重 (used [i - 1] == false)，的树形结构如下：</p><p><img data-src="https://img-blog.csdnimg.cn/20201112172230434.png" alt="47.全排列II2.png"></p><p>树枝上去重（used [i - 1] == true）的树型结构如下：</p><p><img data-src="https://img-blog.csdnimg.cn/20201112172327967.png" alt="47.全排列II3"></p><p><strong>可以清晰的看到使用 (used [i - 1] == false)，即树层去重，效率更高！</strong></p><p>本题 used 数组即是记录 path 里都放了哪些元素，同时也用来去重，一举两得。</p><h4 id="棋盘问题"><a class="anchor" href="#棋盘问题">#</a> 棋盘问题</h4><h5 id="n皇后问题"><a class="anchor" href="#n皇后问题">#</a> N 皇后问题</h5><p>在 [☆51. N 皇后](#☆51. N 皇后) 中终于迎来了传说中的 N 皇后。</p><p>下面我用一个 3 * 3 的棋盘，将搜索过程抽象为一棵树，如图：</p><p><img data-src="https://img-blog.csdnimg.cn/20201118225433127.png" alt="51.N皇后"></p><p>从图中，可以看出，二维矩阵中矩阵的高就是这棵树的高度，矩阵的宽就是树形结构中每一个节点的宽度。</p><p>那么我们用皇后们的约束条件，来回溯搜索这棵树，<strong>只要搜索到了树的叶子节点，说明就找到了皇后们的合理位置了</strong>。</p><p>如果从来没有接触过 N 皇后问题的同学看着这样的题会感觉无从下手，可能知道要用回溯法，但也不知道该怎么去搜。</p><p><strong>这里我明确给出了棋盘的宽度就是 for 循环的长度，递归的深度就是棋盘的高度，这样就可以套进回溯法的模板里了</strong>。</p><p>相信看完本篇 [☆51. N 皇后](#☆51. N 皇后) 也没那么难了，传说已经不是传说了，哈哈。</p><h5 id="解数独问题"><a class="anchor" href="#解数独问题">#</a> 解数独问题</h5><p>在 [☆37. 解数独](#☆37. 解数独) 中要征服回溯法的最后一道山峰。</p><p>解数独应该是棋盘很难的题目了，比 N 皇后还要复杂一些，但只要理解 “二维递归” 这个过程，其实发现就没那么难了。</p><p>大家已经跟着「代码随想录」刷过了如下回溯法题目，例如：<span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVyY2FybC5jb20vMDA3Ny4lRTclQkIlODQlRTUlOTAlODguaHRtbA==">77. 组合（组合问题） (opens new window)</span>，<span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVyY2FybC5jb20vMDEzMS4lRTUlODglODYlRTUlODklQjIlRTUlOUIlOUUlRTYlOTYlODclRTQlQjglQjIuaHRtbA==">131. 分割回文串（分割问题） (opens new window)</span>，<span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVyY2FybC5jb20vMDA3OC4lRTUlQUQlOTAlRTklOUIlODYuaHRtbA==">78. 子集（子集问题） (opens new window)</span>，<span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVyY2FybC5jb20vMDA0Ni4lRTUlODUlQTglRTYlOEUlOTIlRTUlODglOTcuaHRtbA==">46. 全排列（排列问题） (opens new window)</span>，以及<span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVyY2FybC5jb20vMDA1MS5OJUU3JTlBJTg3JUU1JTkwJThFLmh0bWw="> 51.N 皇后（N 皇后问题） (opens new window)</span>，其实这些题目都是一维递归。</p><p>其中<span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVyY2FybC5jb20vMDA1MS5OJUU3JTlBJTg3JUU1JTkwJThFLmh0bWw="> N 皇后问题 (opens new window)</span> 是因为每一行每一列只放一个皇后，只需要一层 for 循环遍历一行，递归来遍历列，然后一行一列确定皇后的唯一位置。</p><p>本题就不一样了，<strong>本题中棋盘的每一个位置都要放一个数字，并检查数字是否合法，解数独的树形结构要比 N 皇后更宽更深</strong>。</p><p>因为这个树形结构太大了，我抽取一部分，如图所示：</p><p><img data-src="https://img-blog.csdnimg.cn/2020111720451790.png" alt="37.解数独"></p><p>解数独可以说是非常难的题目了，如果还一直停留在一维递归的逻辑中，这道题目可以让大家瞬间崩溃。</p><p><strong>所以我在 [☆37. 解数独](#☆37. 解数独) 中开篇就提到了二维递归，这也是我自创词汇</strong>，希望可以帮助大家理解解数独的搜索过程。</p><p>一波分析之后，在看代码会发现其实也不难，唯一难点就是理解<strong>二维递归</strong>的思维逻辑。</p><p><strong>这样，解数独这么难的问题也被我们攻克了</strong>。</p><h4 id="去重问题"><a class="anchor" href="#去重问题">#</a> 去重问题</h4><p>以上我都是统一使用 used 数组来去重的，其实使用 set 也可以用来去重！</p><p>在<span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVyY2FybC5jb20vJUU1JTlCJTlFJUU2JUJBJUFGJUU3JUFFJTk3JUU2JUIzJTk1JUU1JThFJUJCJUU5JTg3JThEJUU5JTk3JUFFJUU5JUEyJTk4JUU3JTlBJTg0JUU1JThGJUE2JUU0JUI4JTgwJUU3JUE3JThEJUU1JTg2JTk5JUU2JUIzJTk1Lmh0bWw=">本周小结！（回溯算法系列三）续集 (opens new window)</span> 中给出了子集、组合、排列问题使用 set 来去重的解法以及具体代码，并纠正一些同学的常见错误写法。</p><p>同时详细分析了 使用 used 数组去重 和 使用 set 去重 两种写法的性能差异：</p><p><strong>使用 set 去重的版本相对于 used 数组的版本效率都要低很多</strong>，大家在 leetcode 上提交，能明显发现。</p><p>原因在<span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVyY2FybC5jb20vMDQ5MS4lRTklODAlOTIlRTUlQTIlOUUlRTUlQUQlOTAlRTUlQkElOEYlRTUlODglOTcuaHRtbA==">回溯算法：递增子序列 (opens new window)</span> 中也分析过，主要是因为程序运行的时候对 unordered_set 频繁的 insert，unordered_set 需要做哈希映射（也就是把 key 通过 hash function 映射为唯一的哈希值）相对费时间，而且 insert 的时候其底层的符号表也要做相应的扩充，也是费时的。</p><p><strong>而使用 used 数组在时间复杂度上几乎没有额外负担！</strong></p><p><strong>使用 set 去重，不仅时间复杂度高了，空间复杂度也高了</strong>，在<span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVyY2FybC5jb20vJUU1JTkxJUE4JUU2JTgwJUJCJUU3JUJCJTkzLzIwMjAxMTEyJUU1JTlCJTlFJUU2JUJBJUFGJUU1JTkxJUE4JUU2JTlDJUFCJUU2JTgwJUJCJUU3JUJCJTkzLmh0bWw=">本周小结！（回溯算法系列三） (opens new window)</span> 中分析过，组合，子集，排列问题的空间复杂度都是 O (n)，但如果使用 set 去重，空间复杂度就变成了 O (n^2)，因为每一层递归都有一个 set 集合，系统栈空间是 n，每一个空间都有 set 集合。</p><p>那有同学可能疑惑 用 used 数组也是占用 O (n) 的空间啊？</p><p>used 数组可是全局变量，每层与每层之间公用一个 used 数组，所以空间复杂度是 O (n + n)，最终空间复杂度还是 O (n)。</p><h4 id="重新安排行程图论额外拓展"><a class="anchor" href="#重新安排行程图论额外拓展">#</a> 重新安排行程（图论额外拓展）</h4><p>之前说过，有递归的地方就有回溯，深度优先搜索也是用递归来实现的，所以往往伴随着回溯。</p><p>在 [☆332. 重新安排行程](#☆332. 重新安排行程) 其实也算是图论里深搜的题目，但是我用回溯法的套路来讲解这道题目，算是给大家拓展一下思路，原来回溯法还可以这么玩！</p><p>以输入：[[&quot;JFK&quot;, &quot;KUL&quot;], [&quot;JFK&quot;, &quot;NRT&quot;], [&quot;NRT&quot;, &quot;JFK&quot;] 为例，抽象为树形结构如下：</p><p><img data-src="https://img-blog.csdnimg.cn/2020111518065555.png" alt="img"></p><p>本题可以算是一道 hard 的题目了，关于本题的难点我在文中已经详细列出。</p><p><strong>如果单纯的回溯搜索（深搜）并不难，难还难在容器的选择和使用上！</strong></p><p>本题其实是一道深度优先搜索的题目，但是我完全使用回溯法的思路来讲解这道题题目，<strong>算是给大家拓展一下思维方式，其实深搜和回溯也是分不开的，毕竟最终都是用递归</strong>。</p><h4 id="性能分析-2"><a class="anchor" href="#性能分析-2">#</a> 性能分析</h4><p><strong>关于回溯算法的复杂度分析在网上的资料鱼龙混杂，一些所谓的经典面试书籍不讲回溯算法，算法书籍对这块也避而不谈，感觉就像是算法里模糊的边界</strong>。</p><p><strong>所以这块就说一说我个人理解，对内容持开放态度，集思广益，欢迎大家来讨论！</strong></p><p>以下在计算空间复杂度的时候我都把系统栈（不是数据结构里的栈）所占空间算进去。</p><p>子集问题分析：</p><ul><li>时间复杂度：O (2<sup>n</sup>)，因为每一个元素的状态无外乎取与不取，所以时间复杂度为 O (2<sup>n</sup>)</li><li>空间复杂度：O (n)，递归深度为 n，所以系统栈所用空间为 O (n)，每一层递归所用的空间都是常数级别，注意代码里的 result 和 path 都是全局变量，就算是放在参数里，传的也是引用，并不会新申请内存空间，最终空间复杂度为 O (n)</li></ul><p>排列问题分析：</p><ul><li>时间复杂度：O (n!)，这个可以从排列的树形图中很明显发现，每一层节点为 n，第二层每一个分支都延伸了 n-1 个分支，再往下又是 n-2 个分支，所以一直到叶子节点一共就是 n * n-1 * n-2 * ..... 1 = n!。</li><li>空间复杂度：O (n)，和子集问题同理。</li></ul><p>组合问题分析：</p><ul><li>时间复杂度：O (2<sup>n</sup>)，组合问题其实就是一种子集的问题，所以组合问题最坏的情况，也不会超过子集问题的时间复杂度。</li><li>空间复杂度：O (n)，和子集问题同理。</li></ul><p>N 皇后问题分析：</p><ul><li>时间复杂度：O (n!) ，其实如果看树形图的话，直觉上是 O (n<sup>n</sup>)，但皇后之间不能见面所以在搜索的过程中是有剪枝的，最差也就是 O（n!），n! 表示 n * (n-1) * .... * 1。</li><li>空间复杂度：O (n)，和子集问题同理。</li></ul><p>解数独问题分析：</p><ul><li>时间复杂度：O (9<sup>m</sup>) , m 是 '.' 的数目。</li><li>空间复杂度：O (n<sup>2</sup>)，递归的深度是 n<sup>2</sup></li></ul><p><strong>一般说道回溯算法的复杂度，都说是指数级别的时间复杂度，这也算是一个概括吧！</strong></p><h4 id="总结-47"><a class="anchor" href="#总结-47">#</a> 总结</h4><p>这里的每一种问题，讲解的时候我都会和其他问题作对比，做分析，确保每一个问题都讲的通透。</p><p>可以说方方面面都详细介绍到了。</p><p>例如：</p><ul><li><p>如何理解回溯法的搜索过程？</p></li><li><p>什么时候用 startIndex，什么时候不用？</p><blockquote><p>对一个集合进行组合时用</p></blockquote></li><li><p>如何去重？如何理解 “树枝去重” 与 “树层去重”？</p><blockquote><p>排序 + used 数组</p></blockquote></li><li><p>去重的几种方法？</p><blockquote><ol><li>排序 + used 数组</li><li>Set</li></ol></blockquote></li><li><p>如何理解二维递归？</p><blockquote><p>递归套在二层循环中</p></blockquote></li></ul><p><strong>这里的每一个问题，网上几乎找不到能讲清楚的文章，这也是直击回溯算法本质的问题</strong>。</p><p>相信一路坚持下来的录友们，对回溯算法已经都深刻的认识。</p><p>此时回溯算法系列就要正式告一段落了。</p><p><strong>录友们可以回顾一下这 21 天，每天的打卡，每天在交流群里和大家探讨代码，最终换来的都是不知不觉的成长</strong>。</p><p>同样也感谢录友们的坚持，这也是我持续写作的动力，<strong>正是因为大家的积极参与，我才知道这件事件是非常有意义的</strong>。</p><p>回溯专题汇聚为一张图：</p><p><img data-src="https://code-thinking-1253855093.file.myqcloud.com/pics/20211030124742.png" alt="img"></p><h2 id="贪心算法"><a class="anchor" href="#贪心算法">#</a> 贪心算法</h2><h3 id="贪心算法理论基础"><a class="anchor" href="#贪心算法理论基础">#</a> 贪心算法理论基础</h3><p>题目分类大纲如下：</p><p><img data-src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210917104315.png" alt="贪心算法大纲"></p><h4 id="贪心的定义"><a class="anchor" href="#贪心的定义">#</a> 贪心的定义</h4><p><strong>贪心的本质是选择每一阶段的局部最优，从而达到全局最优</strong>。</p><p>这么说有点抽象，来举一个例子：</p><p>例如，有一堆钞票，你可以拿走十张，如果想达到最大的金额，你要怎么拿？</p><p>指定每次拿最大的，最终结果就是拿走最大数额的钱。</p><p>每次拿最大的就是局部最优，最后拿走最大数额的钱就是推出全局最优。</p><p>再举一个例子如果是 有一堆盒子，你有一个背包体积为 n，如何把背包尽可能装满，如果还每次选最大的盒子，就不行了。这时候就需要动态规划。动态规划的问题在下一个系列会详细讲解。</p><h4 id="什么时候用贪心"><a class="anchor" href="#什么时候用贪心">#</a> 什么时候用贪心</h4><p>很多同学做贪心的题目的时候，想不出来是贪心，想知道有没有什么套路可以一看就看出来是贪心。</p><p><strong>说实话贪心算法并没有固定的套路</strong>。</p><p>所以唯一的难点就是如何通过局部最优，推出整体最优。</p><p>那么如何能看出局部最优是否能推出整体最优呢？有没有什么固定策略或者套路呢？</p><p><strong>不好意思，也没有！</strong> 靠自己手动模拟，如果模拟可行，就可以试一试贪心策略，如果不可行，可能需要动态规划。</p><p>有同学问了如何验证可不可以用贪心算法呢？</p><p><strong>最好用的策略就是举反例，如果想不到反例，那么就试一试贪心吧</strong>。</p><p>可有有同学认为手动模拟，举例子得出的结论不靠谱，想要严格的数学证明。</p><p>一般数学证明有如下两种方法：</p><ul><li>数学归纳法</li><li>反证法</li></ul><p>看教课书上讲解贪心可以是一堆公式，估计大家连看都不想看，所以数学证明就不在我要讲解的范围内了，大家感兴趣可以自行查找资料。</p><p><strong>面试中基本不会让面试者现场证明贪心的合理性，代码写出来跑过测试用例即可，或者自己能自圆其说理由就行了</strong>。</p><p>举一个不太恰当的例子：我要用一下 1+1 = 2，但我要先证明 1+1 为什么等于 2。严谨是严谨了，但没必要。</p><p>虽然这个例子很极端，但可以表达这么个意思：<strong>刷题或者面试的时候，手动模拟一下感觉可以局部最优推出整体最优，而且想不到反例，那么就试一试贪心</strong>。</p><p><strong>例如刚刚举的拿钞票的例子，就是模拟一下每次拿做大的，最后就能拿到最多的钱，这还要数学证明的话，其实就不在算法面试的范围内了，可以看看专业的数学书籍！</strong></p><p>所以这也是为什么很多同学通过（accept）了贪心的题目，但都不知道自己用了贪心算法，<strong>因为贪心有时候就是常识性的推导，所以会认为本应该就这么做！</strong></p><p><strong>那么刷题的时候什么时候真的需要数学推导呢？</strong></p><p>例如这道题目：[142. 环形链表 II](#142. 环形链表 II)，这道题不用数学推导一下，就找不出环的起始位置，想试一下就不知道怎么试，这种题目确实需要数学简单推导一下。</p><h4 id="贪心算法解题步骤"><a class="anchor" href="#贪心算法解题步骤">#</a> 贪心算法解题步骤</h4><p>贪心算法一般分为如下四步：</p><ul><li>将问题分解为若干个子问题</li><li>找出适合的贪心策略</li><li>求解每一个子问题的最优解</li><li>将局部最优解堆叠成全局最优解</li></ul><p>其实这个分的有点细了，真正做题的时候很难分出这么详细的解题步骤，可能就是因为贪心的题目往往还和其他方面的知识混在一起。</p><h4 id="总结-48"><a class="anchor" href="#总结-48">#</a> 总结</h4><p>本篇给出了什么是贪心以及大家关心的贪心算法固定套路。</p><p><strong>不好意思了，贪心没有套路，说白了就是常识性推导加上举反例</strong>。</p><p>最后给出贪心的一般解题步骤，大家可以发现这个解题步骤也是比较抽象的，不像是二叉树，回溯算法，给出了那么具体的解题套路和模板。</p><h3 id="455-分发饼干"><a class="anchor" href="#455-分发饼干">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9hc3NpZ24tY29va2llcy8=">455. 分发饼干</span></h3><p>为了满足更多的小孩，就不要造成饼干尺寸的浪费。</p><p>大尺寸的饼干既可以满足胃口大的孩子也可以满足胃口小的孩子，那么就应该优先满足胃口大的。</p><p><strong>这里的局部最优就是大饼干喂给胃口大的，充分利用饼干尺寸喂饱一个，全局最优就是喂饱尽可能多的小孩</strong>。</p><p>可以尝试使用贪心策略，先将饼干数组和小孩数组排序。</p><p>然后从后向前遍历小孩数组，用大饼干优先满足胃口大的，并统计满足小孩数量。</p><p>如图：</p><p><img data-src="https://img-blog.csdnimg.cn/20201123161809624.png" alt="455.分发饼干"></p><p>这个例子可以看出饼干 9 只有喂给胃口为 7 的小孩，这样才是整体最优解，并想不出反例，那么就可以撸代码了。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 贪心策略：大饼干先分给大胃口孩子</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findContentChildren</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> g<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>g<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token keyword">int</span> index <span class="token operator">=</span> s<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 饼干的索引</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 满足的孩子数</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> g<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 从胃口最大的孩子开始遍历</span></pre></td></tr><tr><td data-num="9"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">>=</span> g<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">//index>=0 是为了防止饼干不够分</span></pre></td></tr><tr><td data-num="10"></td><td><pre>                res<span class="token operator">++</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>                index<span class="token operator">--</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token keyword">return</span> res<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>从代码中可以看出我<strong>用了一个 index 来控制饼干数组的遍历，遍历饼干并没有再起一个 for 循环，而是采用自减的方式</strong>，这也是常用的技巧。</p><p>有的同学看到要遍历两个数组，就想到用两个 for 循环，那样逻辑其实就复杂了。</p><p><strong>也可以换一个思路，小饼干先喂饱小胃口</strong></p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 贪心策略：小饼干先喂小胃口孩子</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findContentChildren</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> g<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>g<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 饼干的索引</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 满足的孩子数</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">&lt;</span> g<span class="token punctuation">.</span>length <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">>=</span> g<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>                res<span class="token operator">++</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>                index<span class="token operator">++</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token keyword">return</span> res<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h4 id="总结-49"><a class="anchor" href="#总结-49">#</a> 总结</h4><p>这道题是贪心很好的一道入门题目，思路还是比较容易想到的。</p><p>文中详细介绍了思考的过程，<strong>想清楚局部最优，想清楚全局最优，感觉局部最优是可以推出全局最优，并想不出反例，那么就试一试贪心</strong>。</p><h3 id="376-摆动序列"><a class="anchor" href="#376-摆动序列">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy93aWdnbGUtc3Vic2VxdWVuY2Uv">376. 摆动序列</span></h3><h4 id="贪心算法-2"><a class="anchor" href="#贪心算法-2">#</a> 贪心算法</h4><p>本题要求通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。</p><p>相信这么一说吓退不少同学，这要求最大摆动序列又可以修改数组，这得如何修改呢？</p><p>来分析一下，要求删除元素使其达到最大摆动序列，应该删除什么元素呢？</p><p>用示例二来举例，如图所示：</p><p><img data-src="https://img-blog.csdnimg.cn/20201124174327597.png" alt="376.摆动序列"></p><p><strong>局部最优：删除单调坡度上的节点（不包括单调坡度两端的节点），那么这个坡度就可以有两个局部峰值</strong>。</p><p><strong>整体最优：整个序列有最多的局部峰值，从而达到最长摆动序列</strong>。</p><p>局部最优推出全局最优，并举不出反例，那么试试贪心！</p><p>（为方便表述，以下说的峰值都是指局部峰值）</p><p><strong>实际操作上，其实连删除的操作都不用做，因为题目要求的是最长摆动子序列的长度，所以只需要统计数组的峰值数量就可以了（相当于是删除单一坡度上的节点，然后统计长度）</strong></p><p><strong>这就是贪心所贪的地方，让峰值尽可能的保持峰值，然后删除单一坡度上的节点</strong>。</p><p>本题代码实现中，还有一些技巧，例如统计峰值的时候，数组最左面和最右面是最不好统计的。</p><p>例如序列 [2,5]，它的峰值数量是 2，如果靠统计差值来计算峰值个数就需要考虑数组最左面和最右面的特殊情况。</p><p>所以可以针对序列 [2,5]，可以假设为 [2,2,5]，这样它就有坡度了即 preDiff = 0，如图：</p><p><img data-src="https://img-blog.csdnimg.cn/20201124174357612.png" alt="376.摆动序列1"></p><p>针对以上情形，result 初始为 1（默认最右面有一个峰值），此时 curDiff &gt; 0 &amp;&amp; preDiff &lt;= 0，那么 result++（计算了左面的峰值），最后得到的 result 就是 2（峰值个数为 2 即摆动序列长度为 2）</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 贪心算法</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">wiggleMaxLength</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token comment">// 特判：数组长度小于 2，直接返回数组长度</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>            <span class="token keyword">return</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 记录摆动序列的长度，初始化为 1</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token keyword">int</span> preDiff <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 记录前一个差值</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token keyword">int</span> curDiff <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 记录当前差值</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>            curDiff <span class="token operator">=</span> nums<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>            <span class="token comment">// 判断是否出现峰值，即 curDiff 和 preDiff 是否异号</span></pre></td></tr><tr><td data-num="15"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>curDiff <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> preDiff <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span>curDiff <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> preDiff <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>                res<span class="token operator">++</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>                preDiff <span class="token operator">=</span> curDiff<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>        <span class="token keyword">return</span> res<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="22"></td><td><pre><span class="token punctuation">&#125;</span> <span class="token comment">// 时间复杂度：O (n)，空间复杂度：O (1)</span></pre></td></tr></table></figure><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230105182927806.png" alt="image-20230105182927806"></p><h4 id="总结-50"><a class="anchor" href="#总结-50">#</a> 总结</h4><p><strong>贪心的题目说简单有的时候就是常识，说难就难在都不知道该怎么用贪心</strong>。</p><p>本题大家如果要去模拟删除元素达到最长摆动子序列的过程，那指定绕里面去了，一时半会拔不出来。</p><p>而这道题目有什么技巧说一下子能想到贪心么？</p><p>其实也没有，类似的题目做过了就会想到。</p><p>此时大家就应该了解了：保持区间波动，只需要把单调区间上的元素移除就可以了。</p><h3 id="53-最大子数组和"><a class="anchor" href="#53-最大子数组和">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tYXhpbXVtLXN1YmFycmF5Lw==">53. 最大子数组和</span></h3><h4 id="暴力解法-5"><a class="anchor" href="#暴力解法-5">#</a> 暴力解法</h4><p>暴力解法的思路，第一层 for 就是设置起始位置，第二层 for 循环遍历数组寻找最大值</p><ul><li>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li><li>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li></ul><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 暴力解法，时间复杂度 O (n^2)，空间复杂度 O (1)</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">maxSubArray</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token constant">MIN_VALUE</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>            <span class="token keyword">int</span> tmpSum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span> j <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>                tmpSum <span class="token operator">+=</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>                res <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> tmpSum<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token keyword">return</span> res<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>可是超时咯！</p><h4 id="贪心解法"><a class="anchor" href="#贪心解法">#</a> 贪心解法</h4><p><strong>贪心贪的是哪里呢？</strong></p><p>如果 -2 1 在一起，计算起点的时候，一定是从 1 开始计算，因为负数只会拉低总和，这就是贪心贪的地方！</p><p>局部最优：<font color="red">当前 “连续和” 为负数的时候立刻放弃，从下一个元素重新计算 “连续和”</font>，因为负数加上下一个元素 “连续和” 只会越来越小。</p><p>全局最优：选取最大 “连续和”</p><p><strong>局部最优的情况下，并记录最大的 “连续和”，可以推出全局最优</strong>。</p><p>从代码角度上来讲：遍历 nums，从头开始用 count 累积，如果 count 一旦加上 nums [i] 变为负数，那么就应该从 nums [i+1] 开始从 0 累积 count 了，因为已经变为负数的 count，只会拖累总和。</p><p><strong>这相当于是暴力解法中的不断调整最大子序和区间的起始位置</strong>。</p><p><strong>那有同学问了，区间终止位置不用调整么？ 如何才能得到最大 “连续和” 呢？</strong></p><p>区间的终止位置，其实就是如果 count 取到最大值了，及时记录下来了。例如如下代码：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">></span> result<span class="token punctuation">)</span> result <span class="token operator">=</span> count<span class="token punctuation">;</span></pre></td></tr></table></figure><p><strong>这样相当于是用 result 记录最大子序和区间和（变相的算是调整了终止位置）</strong>。</p><p>如动画所示：</p><p><img data-src="https://code-thinking.cdn.bcebos.com/gifs/53.%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C.gif" alt="53.最大子序和"></p><p>红色的起始位置就是贪心每次取 count 为正数的时候，开始一个区间的统计。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 贪心算法，时间复杂度 O (n)，空间复杂度 O (1)</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">maxSubArray</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token constant">MIN_VALUE</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>            count <span class="token operator">+=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">></span> res<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 更新最大值</span></pre></td></tr><tr><td data-num="9"></td><td><pre>                res <span class="token operator">=</span> count<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 如果 count 小于 0，说明前面的数对后面的数没有增益，所以舍弃</span></pre></td></tr><tr><td data-num="12"></td><td><pre>                count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token keyword">return</span> res<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230106120155285.png" alt="image-20230106120155285"></p><p>当然题目没有说如果数组为空，应该返回什么，所以数组为空的话返回啥都可以了。</p><p>不少同学认为 如果输入用例都是 - 1，或者 都是负数，这个贪心算法跑出来的结果是 0， 这是<strong>又一次证明脑洞模拟不靠谱的经典案例</strong>，建议大家把代码运行一下试一试，就知道了，也会理解 为什么 result 要初始化为最小负数了。</p><h4 id="总结-51"><a class="anchor" href="#总结-51">#</a> 总结</h4><p>本题的贪心思路其实并不好想，这也进一步验证了，别看贪心理论很直白，有时候看似是常识，但贪心的题目一点都不简单！</p><p>后续将介绍的贪心题目都挺难的，哈哈，所以贪心很有意思，别小看贪心！</p><h3 id="贪心周总结一"><a class="anchor" href="#贪心周总结一">#</a> 贪心周总结一</h3><h4 id="周一-8"><a class="anchor" href="#周一-8">#</a> 周一</h4><p><strong>贪心的本质是选择每一阶段的局部最优，从而达到全局最优。</strong></p><p>有没有啥套路呢？</p><p><strong>不好意思，贪心没套路，就刷题而言，如果感觉好像局部最优可以推出全局最优，然后想不到反例，那就试一试贪心吧！</strong></p><h4 id="周二-8"><a class="anchor" href="#周二-8">#</a> 周二</h4><p>在 [455. 分发饼干](#455. 分发饼干) 中讲解了贪心算法的第一道题目。</p><p>这道题目很明显能看出来是用贪心，也是入门好题。</p><p>我在文中给出<strong>局部最优：大饼干喂给胃口大的，充分利用饼干尺寸喂饱一个，全局最优：喂饱尽可能多的小孩</strong>。</p><p>很多录友都是用小饼干优先先喂饱小胃口的。</p><p>后来我想一想，虽然结果是一样的，但是大家的这个思考方式更好一些。</p><p><strong>因为用小饼干优先喂饱小胃口的 这样可以尽量保证最后省下来的是大饼干（虽然题目没有这个要求）！</strong></p><p>所有还是小饼干优先先喂饱小胃口更好一些，也比较直观。</p><p>一些录友不清楚 [455. 分发饼干](#455. 分发饼干) 中时间复杂度是怎么来的？</p><p>就是<strong>快排 O (nlog n)</strong>，遍历 O (n)，加一起就是还是 O (nlogn)。</p><h4 id="周三-8"><a class="anchor" href="#周三-8">#</a> 周三</h4><p>接下来就要上一点难度了，要不然大家会误以为贪心算法就是常识判断一下就行了。</p><p>在 [376. 摆动序列](#376. 摆动序列) 中，需要计算最长摇摆序列。</p><p>其实就是让序列有尽可能多的局部峰值。</p><p>局部最优：删除单调坡度上的节点（不包括单调坡度两端的节点），那么这个坡度就可以有两个局部峰值。</p><p>整体最优：整个序列有最多的局部峰值，从而达到最长摆动序列。</p><p>在计算峰值的时候，还是有一些代码技巧的，例如序列两端的峰值如何处理。</p><p>这些技巧，其实还是要多看多用才会掌握。</p><h4 id="周四-8"><a class="anchor" href="#周四-8">#</a> 周四</h4><p>在 [53. 最大子数组和](#53. 最大子数组和) 中，详细讲解了用贪心的方式来求最大子序列和，其实这道题目是一道动态规划的题目。</p><p><strong>贪心的思路为局部最优：当前 “连续和” 为负数的时候立刻放弃，从下一个元素重新计算 “连续和”，因为负数加上下一个元素 “连续和” 只会越来越小。从而推出全局最优：选取最大 “连续和”</strong></p><p>代码很简单，但是思路却比较难。还需要反复琢磨。</p><p>针对 [53. 最大子数组和](#53. 最大子数组和) 文章中给出的贪心代码如下；</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 贪心算法，时间复杂度 O (n)，空间复杂度 O (1)</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">maxSubArray</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token constant">MIN_VALUE</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>            count <span class="token operator">+=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">></span> res<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 更新最大值</span></pre></td></tr><tr><td data-num="9"></td><td><pre>                res <span class="token operator">=</span> count<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 如果 count 小于 0，说明前面的数对后面的数没有增益，所以舍弃</span></pre></td></tr><tr><td data-num="12"></td><td><pre>                count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token keyword">return</span> res<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>如果数组全是负数这个代码就有问题了，如果数组里有 int 最小值这个代码就有问题了。</p><p>大家不要脑洞模拟哈，可以亲自构造一些测试数据试一试，就发现其实没有问题。</p><p>数组都为负数，result 记录的就是最小的负数，如果数组里有 int 最小值，那么最终 result 就是 int 最小值。</p><h4 id="总结-52"><a class="anchor" href="#总结-52">#</a> 总结</h4><p>本周我们讲解了<a href="#%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80">贪心算法理论基础</a>，了解了贪心本质：局部最优推出全局最优。</p><p>然后讲解了第一道题目 [455. 分发饼干](#455. 分发饼干)，还是比较基础的，可能会给大家一种贪心算法比较简单的错觉，因为贪心有时候接近于常识。</p><p>其实我还准备一些简单的贪心题目，甚至网上很多都质疑这些题目是不是贪心算法。这些题目我没有立刻发出来，因为真的会让大家感觉贪心过于简单，而忽略了贪心的本质：局部最优和全局最优两个关键点。</p><p><strong>所以我在贪心系列难度会有所交替，难的题目在于拓展思路，简单的题目在于分析清楚其贪心的本质，后续我还会发一些简单的题目来做贪心的分析。</strong></p><p>在 [376. 摆动序列](#376. 摆动序列) 中大家就初步感受到贪心没那么简单了。</p><p>本周最后是 [53. 最大子数组和](#53. 最大子数组和)，这道题目要用贪心的方式做出来，就比较有难度，都知道负数加上正数之后会变小，但是这道题目依然会让很多人搞混淆，其关键在于：<strong><mark>不能让 “连续和” 为负数的时候加上下一个元素，而不是不让 “连续和” 加上一个负数</mark></strong>。这块真的需要仔细体会！</p><h3 id="122-买卖股票的最佳时机-ii"><a class="anchor" href="#122-买卖股票的最佳时机-ii">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iZXN0LXRpbWUtdG8tYnV5LWFuZC1zZWxsLXN0b2NrLWlpLw==">122. 买卖股票的最佳时机 II</span></h3><h4 id="思路-13"><a class="anchor" href="#思路-13">#</a> 思路</h4><p>本题首先要清楚两点：</p><ul><li>只有一只股票！</li><li>当前只有买股票或者卖股票的操作</li></ul><p>想获得利润至少要两天为一个交易单元。</p><h4 id="贪心解法-2"><a class="anchor" href="#贪心解法-2">#</a> 贪心解法</h4><p>这道题目可能我们只会想，选一个低的买入，再选个高的卖，再选一个低的买入..... 循环反复。</p><p><strong>如果想到其实最终利润是可以分解的，那么本题就很容易了！</strong></p><p>如何分解呢？</p><p>假如第 0 天买入，第 3 天卖出，那么利润为：prices [3] - prices [0]。</p><p>相当于 (prices [3] - prices [2]) + (prices [2] - prices [1]) + (prices [1] - prices [0])。</p><p><strong>此时就是把利润分解为每天为单位的维度，而不是从 0 天到第 3 天整体去考虑！</strong></p><p>那么根据 prices 可以得到每天的利润序列：(prices [i] - prices [i - 1]).....(prices [1] - prices [0])。</p><p>如图：</p><p><img data-src="https://img-blog.csdnimg.cn/2020112917480858.png" alt="122.买卖股票的最佳时机II"></p><p>一些同学陷入：第一天怎么就没有利润呢，第一天到底算不算的困惑中。</p><p>第一天当然没有利润，至少要第二天才会有利润，所以利润的序列比股票序列少一天！</p><p>从图中可以发现，其实我们需要收集每天的正利润就可以，<strong>收集正利润的区间，就是股票买卖的区间，而我们只需要关注最终利润，不需要记录区间</strong>。</p><p>那么只收集正利润就是贪心所贪的地方！</p><p><strong>局部最优：收集每天的正利润，全局最优：求得最大利润</strong>。</p><p>局部最优可以推出全局最优，找不出反例，试一试贪心！</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 贪心算法</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">maxProfit</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> prices<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> prices<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>            <span class="token keyword">int</span> diff <span class="token operator">=</span> prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> prices<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>diff <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 只要有利润就卖出</span></pre></td></tr><tr><td data-num="8"></td><td><pre>                res <span class="token operator">+=</span> diff<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token keyword">return</span> res<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token punctuation">&#125;</span> <span class="token comment">// 时间复杂度：O (n) 空间复杂度：O (1)</span></pre></td></tr></table></figure><h4 id="总结-53"><a class="anchor" href="#总结-53">#</a> 总结</h4><p>股票问题其实是一个系列的，属于动态规划的范畴，因为目前在讲解贪心系列，所以股票问题会在之后的动态规划系列中详细讲解。</p><p><strong>可以看出有时候，贪心往往比动态规划更巧妙，更好用，所以别小看了贪心算法</strong>。</p><p><strong>本题中理解<mark>利润拆分</mark>是关键点！</strong> 不要整块的去看，而是把整体利润拆为每天的利润。</p><p>一旦想到这里了，很自然就会想到贪心了，即：只收集每天的正利润，最后稳稳的就是最大利润了。</p><h3 id="55-跳跃游戏"><a class="anchor" href="#55-跳跃游戏">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9qdW1wLWdhbWUv">55. 跳跃游戏</span></h3><h4 id="思路-14"><a class="anchor" href="#思路-14">#</a> 思路</h4><p>刚看到本题一开始可能想：当前位置元素如果是 3，我究竟是跳一步呢，还是两步呢，还是三步呢，究竟跳几步才是最优呢？</p><p><strong>其实跳几步无所谓，关键在于可跳的覆盖范围</strong>！</p><p>不一定非要明确一次究竟跳几步，每次取最大的跳跃步数，这个就是可以跳跃的覆盖范围。</p><p>这个范围内，别管是怎么跳的，反正一定可以跳过来。</p><p><em><em>那么这个问题就转化为</em><u>跳跃覆盖范围究竟可不可以覆盖到终点！</u></em>**</p><p>每次移动取最大跳跃步数（得到最大的覆盖范围），每移动一个单位，就更新最大覆盖范围。</p><p><strong>贪心算法局部最优解：每次取最大跳跃步数（取最大覆盖范围），整体最优解：最后得到整体最大覆盖范围，看是否能到终点</strong>。</p><p>局部最优推出全局最优，找不出反例，试试贪心！</p><p>如图：</p><p><img data-src="https://img-blog.csdnimg.cn/20201124154758229.png" alt="55.跳跃游戏"></p><p>i 每次移动只能在 cover 的范围内移动，每移动一个元素，cover 得到该元素数值（新的覆盖范围）的补充，让 i 继续移动下去。</p><p>而 cover 每次只取 max (该元素数值补充后的范围，cover 本身范围)。</p><p>如果 cover 大于等于了终点下标，直接 return true 就可以了。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 贪心算法：每次都选择最大的步数，判断覆盖范围是否能到达最后一个位置</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">canJump</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token comment">// 特判</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token keyword">int</span> cover <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 覆盖范围</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> cover<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 注意是 & lt;=，因为 cover 是可以到达的最大位置</span></pre></td></tr><tr><td data-num="9"></td><td><pre>            <span class="token keyword">int</span> maxStep <span class="token operator">=</span> i <span class="token operator">+</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 当前位置最大步数</span></pre></td></tr><tr><td data-num="10"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>maxStep <span class="token operator">></span> cover<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>                cover <span class="token operator">=</span> maxStep<span class="token punctuation">;</span> <span class="token comment">// 更新覆盖范围</span></pre></td></tr><tr><td data-num="12"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>cover <span class="token operator">>=</span> nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 覆盖范围大于等于最后一个位置，说明可以到达</span></pre></td></tr><tr><td data-num="14"></td><td><pre>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h4 id="总结-54"><a class="anchor" href="#总结-54">#</a> 总结</h4><p>这道题目关键点在于：不用拘泥于每次究竟跳几步，而是看覆盖范围，覆盖范围内一定是可以跳过来的，不用管是怎么跳的。</p><p>大家可以看出思路想出来了，代码还是非常简单的。</p><p>一些同学可能感觉，我在讲贪心系列的时候，题目和题目之间貌似没有什么联系？</p><p>** 是真的就是没什么联系，因为贪心无套路！** 没有个整体的贪心框架解决一系列问题，只能是接触各种类型的题目锻炼自己的贪心思维！</p><h3 id="45-跳跃游戏-ii"><a class="anchor" href="#45-跳跃游戏-ii">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9qdW1wLWdhbWUtaWkv">☆45. 跳跃游戏 II</span></h3><h4 id="思路-15"><a class="anchor" href="#思路-15">#</a> 思路</h4><p>本题相对于 [55. 跳跃游戏](#55. 跳跃游戏) 还是难了不少。</p><p>但思路是相似的，还是要看最大覆盖范围。</p><p>本题要计算最小步数，那么就要想清楚什么时候步数才一定要加一呢？</p><p>贪心的思路，</p><ul><li>局部最优：当前可移动距离尽可能多走，如果还没到终点，步数再加一。</li><li>整体最优：一步尽可能多走，从而达到最小步数。</li></ul><p>思路虽然是这样，但在写代码的时候还不能真的能跳多远就跳多远，那样就不知道下一步最远能跳到哪里了。</p><p><strong>所以真正解题的时候，要从覆盖范围出发，不管怎么跳，覆盖范围内一定是可以跳到的，<u>以最小的步数增加覆盖范围</u>，覆盖范围一旦覆盖了终点，得到的就是最小步数！</strong></p><p><strong>这里需要统计两个覆盖范围，当前这一步的最大覆盖和下一步最大覆盖</strong>。</p><p>如果移动下标达到了当前这一步的最大覆盖最远距离了，还没有到终点的话，那么就必须再走一步来增加覆盖范围，直到覆盖范围覆盖了终点。</p><p>如图：</p><p><img data-src="https://img-blog.csdnimg.cn/20201201232309103.png" alt="45.跳跃游戏II"></p><p><strong>图中覆盖范围的意义在于，只要红色的区域，最多两步一定可以到！（不用管具体怎么跳，反正一定可以跳到）</strong></p><h4 id="方法一"><a class="anchor" href="#方法一">#</a> 方法一</h4><p>从图中可以看出来，就是<strong>移动下标达到了当前覆盖的最远距离下标时，步数就要加一，来增加覆盖距离</strong>。最后的步数就是最少步数。</p><p>这里还是有个特殊情况需要考虑，当移动下标达到了当前覆盖的最远距离下标时</p><ul><li>如果当前覆盖最远距离下标不是是集合终点，步数就加一，还需要继续走。</li><li>如果当前覆盖最远距离下标就是是集合终点，步数不用加一，因为不能再往后走了。</li></ul><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 贪心算法</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">jump</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token comment">// 特判</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 记录跳跃次数</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token keyword">int</span> curCover <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 当前能覆盖的最远距离</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token keyword">int</span> nextCover <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 下一步能覆盖的最远距离</span></pre></td></tr><tr><td data-num="10"></td><td><pre></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>            <span class="token keyword">int</span> tmp <span class="token operator">=</span> i <span class="token operator">+</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 当前位置能覆盖的最远距离</span></pre></td></tr><tr><td data-num="13"></td><td><pre>            nextCover <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>nextCover<span class="token punctuation">,</span> tmp<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 更新下一步能覆盖的最远距离</span></pre></td></tr><tr><td data-num="14"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> curCover<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 当前位置已经到达当前能覆盖的最远距离</span></pre></td></tr><tr><td data-num="15"></td><td><pre>                <span class="token keyword">if</span> <span class="token punctuation">(</span>curCover <span class="token operator">!=</span> nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 仍未到达终点</span></pre></td></tr><tr><td data-num="16"></td><td><pre>                    res<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">// 跳跃次数加一</span></pre></td></tr><tr><td data-num="17"></td><td><pre>                    curCover <span class="token operator">=</span> nextCover<span class="token punctuation">;</span> <span class="token comment">// 更新当前能覆盖的最远距离</span></pre></td></tr><tr><td data-num="18"></td><td><pre>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>nextCover <span class="token operator">>=</span> nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span> <span class="token comment">// 如果下一步能覆盖的最远距离已经大于等于数组长度，直接跳出循环</span></pre></td></tr><tr><td data-num="19"></td><td><pre>                <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>                    <span class="token keyword">break</span><span class="token punctuation">;</span> <span class="token comment">// 已经到达终点，跳出循环</span></pre></td></tr><tr><td data-num="21"></td><td><pre>                <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>        <span class="token keyword">return</span> res<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="26"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230106140725646.png" alt="image-20230106140725646"></p><h4 id="方法二"><a class="anchor" href="#方法二">#</a> √方法二</h4><p>依然是贪心，思路和方法一差不多，代码可以简洁一些。</p><p><strong>针对于方法一的特殊情况，可以统一处理</strong>，即：移动下标只要遇到当前覆盖最远距离的下标，直接步数加一，不考虑是不是终点的情况。</p><p>想要达到这样的效果，只要让移动下标，最大只能移动到 nums.size - 2 的地方就可以了。</p><p>因为当移动下标指向 nums.size - 2 时：</p><ul><li>如果移动下标等于当前覆盖最大距离下标， 需要再走一步（即 ans++），因为最后一步一定是可以到的终点。（题目假设总是可以到达数组的最后一个位置），如图： <img data-src="https://img-blog.csdnimg.cn/20201201232445286.png" alt="45.跳跃游戏II2"></li><li>如果移动下标不等于当前覆盖最大距离下标，说明当前覆盖最远距离就可以直接达到终点了，不需要再走一步。如图：</li></ul><p><img data-src="https://img-blog.csdnimg.cn/20201201232338693.png" alt="45.跳跃游戏II1"></p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 贪心算法</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">jump</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token comment">// 特判</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 记录跳跃次数</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token keyword">int</span> curCover <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 当前能覆盖的最远距离</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token keyword">int</span> nextCover <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 下一步能覆盖的最远距离</span></pre></td></tr><tr><td data-num="10"></td><td><pre></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>            <span class="token keyword">int</span> tmp <span class="token operator">=</span> i <span class="token operator">+</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 当前位置能覆盖的最远距离</span></pre></td></tr><tr><td data-num="13"></td><td><pre>            nextCover <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>nextCover<span class="token punctuation">,</span> tmp<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 更新下一步能覆盖的最远距离</span></pre></td></tr><tr><td data-num="14"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> curCover<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 当前位置已经到达了当前能覆盖的最远距离</span></pre></td></tr><tr><td data-num="15"></td><td><pre>                res<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">// 跳跃次数加一</span></pre></td></tr><tr><td data-num="16"></td><td><pre>                curCover <span class="token operator">=</span> nextCover<span class="token punctuation">;</span> <span class="token comment">// 更新当前能覆盖的最远距离</span></pre></td></tr><tr><td data-num="17"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="19"></td><td><pre></pre></td></tr><tr><td data-num="20"></td><td><pre>        <span class="token keyword">return</span> res<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="22"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230106141051226.png" alt="image-20230106141051226"></p><p>可以看出版本二的代码相对于版本一简化了不少！</p><p>其精髓在于控制移动下标 i 只移动到 nums.size () - 2 的位置，所以移动下标只要遇到当前覆盖最远距离的下标，直接步数加一，不用考虑别的了。</p><h4 id="总结-55"><a class="anchor" href="#总结-55">#</a> 总结</h4><p>相信大家可以发现，这道题目相当于 [55. 跳跃游戏](#55. 跳跃游戏) 难了不止一点。</p><p>但代码又十分简单，贪心就是这么巧妙。</p><p>理解本题的关键在于：<strong>以最小的步数增加最大的覆盖范围，直到覆盖范围覆盖了终点</strong>，这个范围内最小步数一定可以跳到，不用管具体是怎么跳的，不纠结于一步究竟跳一个单位还是两个单位。</p><h3 id="1005-k-次取反后最大化的数组和"><a class="anchor" href="#1005-k-次取反后最大化的数组和">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tYXhpbWl6ZS1zdW0tb2YtYXJyYXktYWZ0ZXItay1uZWdhdGlvbnMv">1005. K 次取反后最大化的数组和</span></h3><h4 id="思路-16"><a class="anchor" href="#思路-16">#</a> 思路</h4><p>本题思路其实比较好想了，如何可以让数组和最大呢？</p><p>贪心的思路，局部最优：让绝对值大的负数变为正数，当前数值达到最大，整体最优：整个数组和达到最大。</p><p>局部最优可以推出全局最优。</p><p>那么如果将负数都转变为正数了，K 依然大于 0，此时的问题是一个有序正整数序列，如何转变 K 次正负，让 数组和 达到最大。</p><p>那么又是一个贪心：局部最优：只找数值最小的正整数进行反转，当前数值可以达到最大（例如正整数数组 {5, 3, 1}，反转 1 得到 - 1 比 反转 5 得到的 - 5 大多了），全局最优：整个 数组和 达到最大。</p><p>虽然这道题目大家做的时候，可能都不会去想什么贪心算法，一鼓作气，就 AC 了。</p><p><strong>我这里其实是为了给大家展现出来 经常被大家忽略的贪心思路，这么一道简单题，就用了两次贪心！</strong></p><p>那么本题的解题步骤为：</p><ul><li><p>第一步：将数组<strong>按照绝对值大小降序</strong>排序，<strong>注意要按照绝对值的大小</strong></p><blockquote><p>Java 中可以直接通过 <code>Arrays.sort(nums,(a,b)-&gt;(Math.abs(b)-Math.abs(a)));</code> 对 <code>Integer</code> 数组进行绝对值降序排序，但是很难直接对 <code>int</code> 数组进行。</p><p>因此，需要通过</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre>nums <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token comment">// 转换为流</span></pre></td></tr><tr><td data-num="2"></td><td><pre>                <span class="token punctuation">.</span><span class="token function">boxed</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 装箱</span></pre></td></tr><tr><td data-num="3"></td><td><pre>                <span class="token punctuation">.</span><span class="token function">sorted</span><span class="token punctuation">(</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre>                <span class="token punctuation">.</span><span class="token function">mapToInt</span><span class="token punctuation">(</span><span class="token class-name">Integer</span><span class="token operator">::</span><span class="token function">intValue</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 拆箱，转换为 int []</span></pre></td></tr></table></figure><p>来实现对 <code>int</code> 数组按绝对值降序排序。</p></blockquote></li><li><p>第二步：从前向后遍历，遇到负数将其变为正数，同时 K--</p></li><li><p>第三步：如果 K 还大于 0，说明所有负数均已取反为正，那么直接<strong>反复取反</strong>绝对值最小的元素，将 K 用完</p><blockquote><p>若 k 为偶数，不用进行任何处理，因为取反 k 次等于不取反；</p><p>若 k 为奇数，直接对绝对值最小的元素进行取反即可，因为取反 k 次等于取反 1 次；</p></blockquote></li><li><p>第四步：求和</p></li></ul><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 贪心算法：优先取反最小的数</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">largestSumAfterKNegations</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token comment">// 第一步：按照 绝对值大小 降序排序</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        nums <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token comment">// 转换为流</span></pre></td></tr><tr><td data-num="6"></td><td><pre>                <span class="token punctuation">.</span><span class="token function">boxed</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 装箱</span></pre></td></tr><tr><td data-num="7"></td><td><pre>                <span class="token punctuation">.</span><span class="token function">sorted</span><span class="token punctuation">(</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre>                <span class="token punctuation">.</span><span class="token function">mapToInt</span><span class="token punctuation">(</span><span class="token class-name">Integer</span><span class="token operator">::</span><span class="token function">intValue</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 拆箱，转换为 int []</span></pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token comment">// 第二步：遍历，遇到负数就取反，同时 k--</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> k <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>                nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>                k<span class="token operator">--</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="17"></td><td><pre></pre></td></tr><tr><td data-num="18"></td><td><pre>        <span class="token comment">// 第三步：如果 K 还大于 0，说明所有负数均已取反为正，那么直接反复取反绝对值最小的元素，将 K 用完</span></pre></td></tr><tr><td data-num="19"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 若 k 为奇数，直接对绝对值最小的元素进行取反即可，因为取反 k 次等于取反 1 次</span></pre></td></tr><tr><td data-num="20"></td><td><pre>            nums<span class="token punctuation">[</span>nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">*=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>        <span class="token punctuation">&#125;</span><span class="token comment">// 若 k 为偶数，不用进行任何处理，因为取反 k 次等于不取反</span></pre></td></tr><tr><td data-num="22"></td><td><pre></pre></td></tr><tr><td data-num="23"></td><td><pre>        <span class="token comment">// 第四步：求和</span></pre></td></tr><tr><td data-num="24"></td><td><pre>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> num <span class="token operator">:</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>            res <span class="token operator">+=</span> num<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>        <span class="token keyword">return</span> res<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="30"></td><td><pre><span class="token punctuation">&#125;</span> <span class="token comment">// 时间复杂度：O (nlogn)；空间复杂度：O (logn)</span></pre></td></tr></table></figure><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230106145757701.png" alt="image-20230106145757701"></p><h4 id="总结-56"><a class="anchor" href="#总结-56">#</a> 总结</h4><p>贪心的题目如果简单起来，会让人简单到开始怀疑：本来不就应该这么做么？这也算是算法？我认为这不是贪心？</p><p>本题其实很简单，不会贪心算法的同学都可以做出来，但是我还是全程用贪心的思路来讲解。</p><p>因为贪心的思考方式一定要有！</p><p><strong>如果没有贪心的思考方式（局部最优，全局最优），很容易陷入贪心简单题凭感觉做，贪心难题直接不会做，其实这样就锻炼不了贪心的思考方式了</strong>。</p><p>所以明知道是贪心简单题，也要靠贪心的思考方式来解题，这样对培养解题感觉很有帮助。</p><h3 id="贪心周总结二"><a class="anchor" href="#贪心周总结二">#</a> 贪心周总结二</h3><h4 id="周一-9"><a class="anchor" href="#周一-9">#</a> 周一</h4><p>一说到股票问题，一般都会想到动态规划，其实有时候贪心更有效！</p><p>在 [122. 买卖股票的最佳时机 II](#122. 买卖股票的最佳时机 II) 中，讲到只能多次买卖一支股票，如何获取最大利润。</p><p><strong>这道题目理解利润拆分是关键点！</strong> 不要整块的去看，而是把整体利润拆为每天的利润，就很容易想到贪心了。</p><p><strong>局部最优：只收集每天的正利润，全局最优：得到最大利润</strong>。</p><p>如果正利润连续上了，相当于连续持有股票，而本题并不需要计算具体的区间。</p><p>如图：</p><p><img data-src="https://img-blog.csdnimg.cn/2020112917480858.png" alt="122.买卖股票的最佳时机II"></p><h4 id="周二-9"><a class="anchor" href="#周二-9">#</a> 周二</h4><p>在 [55. 跳跃游戏](#55. 跳跃游戏) 中是给你一个数组看能否跳到终点。</p><p>本题贪心的关键是：<strong>不用拘泥于每次究竟跳几步，而是看覆盖范围，覆盖范围内一定是可以跳过来的，不用管是怎么跳的</strong>。</p><p><strong>那么这个问题就转化为跳跃覆盖范围究竟可不可以覆盖到终点！</strong></p><p>贪心算法局部最优解：移动下标每次取最大跳跃步数（取最大覆盖范围），整体最优解：最后得到整体最大覆盖范围，看是否能到终点</p><p>如果覆盖范围覆盖到了终点，就表示一定可以跳过去。</p><p>如图：</p><p><img data-src="https://img-blog.csdnimg.cn/20201124154758229.png" alt="55.跳跃游戏"></p><h4 id="周三-9"><a class="anchor" href="#周三-9">#</a> 周三</h4><p>这道题目：[☆45. 跳跃游戏 II](#☆45. 跳跃游戏 II) 可就有点难了。</p><p>本题解题关键在于：<strong>以最小的步数增加最大的覆盖范围，直到覆盖范围覆盖了终点</strong>。</p><p>那么局部最优：求当前这步的最大覆盖，那么尽可能多走，到达覆盖范围的终点，只需要一步。整体最优：达到终点，步数最少。</p><p>如图：</p><p><img data-src="https://img-blog.csdnimg.cn/20201201232309103.png" alt="45.跳跃游戏II"></p><p>注意：<strong>图中的移动下标是到当前这步覆盖的最远距离（下标 2 的位置），此时没有到终点，只能增加第二步来扩大覆盖范围</strong>。</p><p>在 [☆45. 跳跃游戏 II](#☆45. 跳跃游戏 II) 中我给出了两个版本的代码。</p><p>其实本质都是超过当前覆盖范围，步数就加一，但版本一需要考虑当前覆盖最远距离下标是不是数组终点的情况。</p><p>而版本二就比较统一的，超过范围，步数就加一，但在移动下标的范围了做了文章。</p><p>即如果覆盖最远距离下标是倒数第二点：直接加一就行，默认一定可以到终点。如图：</p><p><img data-src="https://img-blog.csdnimg.cn/20201201232445286.png" alt="45.跳跃游戏II2"></p><p>如果覆盖最远距离下标不是倒数第二点，说明本次覆盖已经到终点了。如图：</p><p><img data-src="https://img-blog.csdnimg.cn/20201201232338693.png" alt="45.跳跃游戏II1"></p><p>有的录友认为版本一好理解，有的录友认为版本二好理解，其实掌握一种就可以了，也不用非要比拼一下代码的简洁性，简洁程度都差不多了。</p><p>我个人倾向于版本一的写法，思路清晰一点，版本二会有点绕。</p><h4 id="周四-9"><a class="anchor" href="#周四-9">#</a> 周四</h4><p>这道题目：[1005. K 次取反后最大化的数组和](#1005. K 次取反后最大化的数组和) 就比较简单了，哈哈，用简单题来讲一讲贪心的思想。</p><p><strong>这里其实用了两次贪心！</strong></p><p>第一次贪心：</p><ul><li>局部最优：让绝对值大的负数变为正数，当前数值达到最大</li><li>整体最优：整个数组和达到最大。</li></ul><p>处理之后，如果 K 依然大于 0，此时的问题是一个有序正整数序列，如何转变 K 次正负，让 数组和 达到最大。</p><p>第二次贪心：</p><ul><li>局部最优：只找数值最小的正整数进行反转，当前数值可以达到最大（例如正整数数组 {5, 3, 1}，反转 1 得到 - 1 比 反转 5 得到的 - 5 大多了）</li><li>全局最优：整个 数组和 达到最大。</li></ul><p>[1005. K 次取反后最大化的数组和](#1005. K 次取反后最大化的数组和) 中的代码，最后 while 处理 K 的时候，其实直接判断奇偶数就可以了，文中给出的方式太粗暴了，哈哈，Carl 大意了。</p><p>例外一位录友留言给出一个很好的建议，因为文中是使用快排，仔细看题，<strong>题目中限定了数据范围是正负一百，所以可以使用桶排序</strong>，这样时间复杂度就可以优化为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 了。但可能代码要复杂一些了。</p><h4 id="总结-57"><a class="anchor" href="#总结-57">#</a> 总结</h4><p>大家会发现本周的代码其实都简单，但思路却很巧妙，并不容易写出来。</p><p>如果是第一次接触的话，其实很难想出来，就是接触过之后就会了，所以大家不用感觉自己想不出来而烦躁，哈哈。</p><p>相信此时大家现在对贪心算法又有一个新的认识了，加油💪</p><h3 id="134-加油站"><a class="anchor" href="#134-加油站">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9nYXMtc3RhdGlvbi8=">☆134. 加油站</span></h3><h4 id="暴力解法-6"><a class="anchor" href="#暴力解法-6">#</a> 暴力解法</h4><p>暴力的方法很明显就是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 的，遍历每一个加油站为起点的情况，模拟一圈。</p><p>如果跑了一圈，中途没有断油，而且最后油量大于等于 0，说明这个起点是 ok 的。</p><p>暴力的方法思路比较简单，但代码写起来也不是很容易，关键是要模拟跑一圈的过程。</p><p><strong>for 循环适合模拟从头到尾的遍历，而 while 循环适合模拟环形遍历，要善于使用 while！</strong></p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 暴力解法：从每个加油站出发，看能否走完一圈</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">canCompleteCircuit</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> gas<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> cost<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> gas<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 从每个加油站出发</span></pre></td></tr><tr><td data-num="5"></td><td><pre>            <span class="token keyword">int</span> rest <span class="token operator">=</span> gas<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> cost<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 剩余油量</span></pre></td></tr><tr><td data-num="6"></td><td><pre>            <span class="token keyword">int</span> idx <span class="token operator">=</span> <span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> gas<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token comment">// 下一个加油站的索引</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre>            <span class="token keyword">while</span> <span class="token punctuation">(</span>idx <span class="token operator">!=</span> i <span class="token operator">&amp;&amp;</span> rest <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 未回到起点，且油量充足</span></pre></td></tr><tr><td data-num="9"></td><td><pre>                rest <span class="token operator">+=</span> gas<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">-</span> cost<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>                idx <span class="token operator">=</span> <span class="token punctuation">(</span>idx <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> gas<span class="token punctuation">.</span>length<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre></pre></td></tr><tr><td data-num="13"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>idx <span class="token operator">==</span> i <span class="token operator">&amp;&amp;</span> rest <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 回到起点，且油量充足</span></pre></td></tr><tr><td data-num="14"></td><td><pre>                <span class="token keyword">return</span> i<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="17"></td><td><pre></pre></td></tr><tr><td data-num="18"></td><td><pre>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 无解，返回 -1</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token punctuation">&#125;</span> <span class="token comment">// 时间复杂度：O (n^2)；空间复杂度：O (1)</span></pre></td></tr></table></figure><p>超时咯！</p><h4 id="贪心解法方法一"><a class="anchor" href="#贪心解法方法一">#</a> 贪心解法（方法一）</h4><p>直接从<strong>全局</strong>进行贪心选择，情况如下：</p><ul><li><p>情况一：如果 <code>gas</code> 的总和小于 <code>cost</code> 总和，那么无论从哪里出发，<strong>一定是跑不了一圈的</strong></p></li><li><p>情况二： <code>rest[i] = gas[i]-cost[i]</code> 为一天剩下的油，i 从 0 开始计算累加到最后一站，</p><ul><li>如果累加没有出现负数，说明从 0 出发，油就没有断过，那么<strong> 0 就是起点</strong></li><li>如果累加的最小值是负数，汽车就要从非 0 节点出发，从后向前，<strong>看哪个节点能这个负数填平</strong>，能把这个负数填平的节点就是出发节点。</li></ul><blockquote><p>情况三不理解┭┮﹏┭┮</p></blockquote></li></ul><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 贪心解法，三种情况：</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token comment">// 1. 如果 gas 总和小于 cost 总和，那么一定无解，直接返回 - 1</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token comment">// 2. rest [i] = gas [i] - cost [i] 为到达 i+1 站剩余的油量，i 从 0 累加到 n-1</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token comment">//   2.1 如果累加没有出现负数，说明从 0 出发，油就没有断过，那么 0 就是起点</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token comment">//   2.2 如果累加的最小值是负数，那么从 0 出发，一定无解，那么就要从非 0 节点出发，从后向前，看哪个节点能这个负数填平，能把这个负数填平的节点就是出发节点</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">canCompleteCircuit</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> gas<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> cost<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token keyword">int</span> curSum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 当前累加和，即当前剩余油量</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token keyword">int</span> minSum <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token constant">MAX_VALUE</span><span class="token punctuation">;</span> <span class="token comment">// 从起点出发，油箱里的最小值</span></pre></td></tr><tr><td data-num="10"></td><td><pre></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> gas<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 从 0 出发，看能不能走完一圈</span></pre></td></tr><tr><td data-num="12"></td><td><pre>            curSum <span class="token operator">+=</span> gas<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> cost<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 累加上当前的剩余油量</span></pre></td></tr><tr><td data-num="13"></td><td><pre>            minSum <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>minSum<span class="token punctuation">,</span> curSum<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 更新最小值</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre></pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>curSum <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 情况 1：无解</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>minSum <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 情况 2.1：从 0 出发，油就没有断过，那么 0 就可以作起点</span></pre></td></tr><tr><td data-num="18"></td><td><pre></pre></td></tr><tr><td data-num="19"></td><td><pre>        <span class="token comment">// 情况 2.2</span></pre></td></tr><tr><td data-num="20"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> gas<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>            minSum <span class="token operator">+=</span> gas<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> cost<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 从后向前，看哪个节点能这个负数填平</span></pre></td></tr><tr><td data-num="22"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>minSum <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> i<span class="token punctuation">;</span> <span class="token comment">// 能填平，那么这个节点就是出发节点</span></pre></td></tr><tr><td data-num="23"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="24"></td><td><pre></pre></td></tr><tr><td data-num="25"></td><td><pre>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="27"></td><td><pre><span class="token punctuation">&#125;</span> <span class="token comment">// 时间复杂度：O (n)，空间复杂度：O (1)</span></pre></td></tr></table></figure><ul><li>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li><li>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li></ul><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230107233543416.png" alt="image-20230107233543416"></p><p><strong>其实我不认为这种方式是贪心算法，因为没有找出局部最优，而是直接从全局最优的角度上思考问题</strong>。</p><p>但这种解法又说不出是什么方法，这就是一个从全局角度选取最优解的模拟操作。</p><p>所以对于本解法是贪心，我持保留意见！</p><p>但不管怎么说，解法毕竟还是巧妙的，不用过于执着于其名字称呼。</p><h4 id="贪心解法方法二"><a class="anchor" href="#贪心解法方法二">#</a> √贪心解法（方法二）</h4><p>可以换一个思路，首先如果总油量减去总消耗大于等于零那么一定可以跑完一圈，说明 各个站点的加油站 剩油量 rest [i] 相加一定是大于等于零的。</p><p>每个加油站的剩余量 rest [i] 为 gas [i] - cost [i]。</p><p>i 从 0 开始累加 rest [i]，和记为 curSum，一旦 curSum 小于零，说明 [0, i] 区间都不能作为起始位置，起始位置从 i+1 算起，再从 0 计算 curSum。</p><p>如图：</p><p><img data-src="https://img-blog.csdnimg.cn/20201213162821958.png" alt="134.加油站"></p><p>那么为什么一旦 [i，j] 区间和为负数，起始位置就可以是 j+1 呢，j+1 后面就不会出现更大的负数？</p><p>如果出现更大的负数，就是更新 j，那么起始位置又变成新的 j+1 了。</p><p>而且 j 之前出现了多少负数，j 后面就会出现多少正数，因为耗油总和是大于零的（前提我们已经确定了一定可以跑完全程）。</p><ul><li><strong>局部最优：当前累加 rest [j] 的和 curSum 一旦小于 0，起始位置至少要是 j+1，因为从 j 开始一定不行</strong></li><li><strong>全局最优：找到可以跑一圈的起始位置</strong></li></ul><p>局部最优可以推出全局最优，找不出反例，试试贪心！</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 贪心解法二</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">canCompleteCircuit</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> gas<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> cost<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token keyword">int</span> curSum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 当前累加和，即当前剩余油量</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">int</span> totalSum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 总累加和，即总剩余油量</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token keyword">int</span> start <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 起始位置</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> gas<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>            curSum <span class="token operator">+=</span> gas<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> cost<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>            totalSum <span class="token operator">+=</span> gas<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> cost<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre></pre></td></tr><tr><td data-num="12"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>curSum <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 当前剩余油量小于 0，说明从 start 到 i 这段路程无法走完</span></pre></td></tr><tr><td data-num="13"></td><td><pre>                start <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 从 i+1 开始重新计算</span></pre></td></tr><tr><td data-num="14"></td><td><pre>                curSum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 重新计算，当前剩余油量置为 0</span></pre></td></tr><tr><td data-num="15"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="17"></td><td><pre></pre></td></tr><tr><td data-num="18"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>totalSum <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 总剩余油量小于 0，说明无法绕一圈</span></pre></td></tr><tr><td data-num="19"></td><td><pre></pre></td></tr><tr><td data-num="20"></td><td><pre>        <span class="token keyword">return</span> start<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="22"></td><td><pre><span class="token punctuation">&#125;</span> <span class="token comment">// 时间复杂度：O (n)，空间复杂度：O (1)</span></pre></td></tr></table></figure><ul><li>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li><li>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li></ul><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230107234943075.png" alt="image-20230107234943075"></p><p><strong>说这种解法为贪心算法，才是有理有据的，因为全局最优解是根据局部最优推导出来的</strong>。</p><h4 id="总结-58"><a class="anchor" href="#总结-58">#</a> 总结</h4><p>对于本题首先给出了暴力解法，暴力解法模拟跑一圈的过程其实比较考验代码技巧的，要对 while 使用的很熟练。</p><p>然后给出了两种贪心算法，对于第一种贪心方法，其实我认为就是一种直接从全局选取最优的模拟操作，思路还是很巧妙的，值得学习一下。</p><p>对于第二种贪心方法，才真正体现出贪心的精髓，用局部最优可以推出全局最优，进而求得起始位置。</p><h3 id="135-分发糖果"><a class="anchor" href="#135-分发糖果">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jYW5keS8=">☆135. 分发糖果</span></h3><p>这道题目一定是要确定一边之后，再确定另一边，例如比较每一个孩子的左边，然后再比较右边，<strong>如果两边一起考虑一定会顾此失彼</strong>。</p><ul><li><p>先确定<strong>右边评分大于左边</strong>的情况（也就是<strong>从前向后</strong>遍历）</p><ul><li>局部最优：只要右边评分比左边大，右边的孩子就多一个糖果</li><li>全局最优：相邻的孩子中，评分高的右孩子获得比左边孩子更多的糖果</li></ul><p>局部最优可以推出全局最优。</p><p>如果 <code>ratings[i] &gt; ratings[i - 1]</code> 那么 [i] 的糖 一定要比 [i - 1] 的糖多一个，所以贪心： <code>candyVec[i] = candyVec[i - 1] + 1</code></p><p>代码如下：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 从前向后</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> ratings<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ratings<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> ratings<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> candyVec<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> candyVec<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>如图：</p><p><img data-src="https://img-blog.csdnimg.cn/20201117114916878.png" alt="135.分发糖果"></p></li><li><p>再确定<strong>左孩子大于右孩子</strong>的情况（<strong>从后向前</strong>遍历）</p><p>遍历顺序这里有同学可能会有疑问，为什么不能从前向后遍历呢？</p><p>因为如果从前向后遍历，根据 ratings [i + 1] 来确定 ratings [i] 对应的糖果，那么每次都不能利用上前一次的比较结果了。</p><p><strong>所以确定左孩子大于右孩子的情况一定要从后向前遍历！</strong></p><p>如果 <code>ratings[i] &gt; ratings[i + 1]</code> ，此时 candyVec [i]（第 i 个小孩的糖果数量）就有两个选择了，一个是 candyVec [i + 1] + 1（从右边这个加 1 得到的糖果数量），一个是 candyVec [i]（之前比较右孩子大于左孩子得到的糖果数量）。</p><p>那么又要贪心了，</p><ul><li>局部最优：<strong>取 <code>max(candyVec[i + 1] + 1, candyVec[i])</code> </strong>，保证第 i 个小孩的糖果数量既大于左边的也大于右边的</li><li>全局最优：相邻的孩子中，评分高的孩子获得更多的糖果。</li></ul><p>局部最优可以推出全局最优。</p><p>所以就取 candyVec [i + 1] + 1 和 candyVec [i] 最大的糖果数量，<strong>candyVec [i] 只有取最大的才能既保持对左边 candyVec [i - 1] 的糖果多，也比右边 candyVec [i + 1] 的糖果多</strong>。</p><p>如图：</p><p><img data-src="https://img-blog.csdnimg.cn/20201117115658791.png" alt="135.分发糖果1"></p><p>所以该过程代码如下：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 从后向前</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> ratings<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ratings<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> ratings<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        candyVec<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>candyVec<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> candyVec<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure></li></ul><p>整体的 Java 代码如下：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 贪心算法：从左到右遍历一遍，从右到左遍历一遍</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">candy</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> ratings<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> candies <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>ratings<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 存储每个孩子的糖果数</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span>candies<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 题目要求每个孩子至少分配到 1 个糖果</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token comment">// 从前向后：确定右边评分＞左边评分的孩子的糖果数</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> ratings<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>ratings<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> ratings<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>                candies<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> candies<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token comment">// 从后向前：确定左边评分＞右边评分的孩子的糖果数</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> ratings<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>ratings<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> ratings<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>                candies<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>candies<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> candies<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="20"></td><td><pre></pre></td></tr><tr><td data-num="21"></td><td><pre>        <span class="token comment">// 计算糖果总数</span></pre></td></tr><tr><td data-num="22"></td><td><pre>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> candy <span class="token operator">:</span> candies<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>            res <span class="token operator">+=</span> candy<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>        <span class="token keyword">return</span> res<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="28"></td><td><pre><span class="token punctuation">&#125;</span> <span class="token comment">// 时间复杂度：O (n)；空间复杂度：O (n)</span></pre></td></tr></table></figure><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230108001106442.png" alt="image-20230108001106442"></p><h4 id="总结-59"><a class="anchor" href="#总结-59">#</a> 总结</h4><p>这在 leetcode 上是一道困难的题目，其难点就在于贪心的策略，如果在考虑局部的时候想两边兼顾，就会顾此失彼。</p><p>那么本题我采用了两次贪心的策略：</p><ul><li>一次是从左到右遍历，只比较右边孩子评分比左边大的情况。</li><li>一次是从右到左遍历，只比较左边孩子评分比右边大的情况。</li></ul><p>这样从局部最优推出了全局最优，即：<strong>相邻的孩子中，评分高的孩子获得更多的糖果</strong>。</p><h3 id="860-柠檬水找零"><a class="anchor" href="#860-柠檬水找零">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sZW1vbmFkZS1jaGFuZ2Uv">860. 柠檬水找零</span></h3><p>这是前几天的 leetcode 每日一题，感觉不错，给大家讲一下。</p><p>这道题目刚一看，可能会有点懵，这要怎么找零才能保证完成全部账单的找零呢？</p><p><strong>但仔细一琢磨就会发现，可供我们做判断的空间非常少！</strong></p><p>只需要维护三种金额的数量，5，10 和 20。</p><p>有如下三种情况：</p><ul><li>情况一：账单是 5，直接收下。</li><li>情况二：账单是 10，消耗一个 5，增加一个 10</li><li>情况三：账单是 20，优先消耗一个 10 和一个 5，如果不够，再消耗三个 5</li></ul><p>此时大家就发现 情况一，情况二，都是固定策略，都不用我们来做分析了，而唯一不确定的其实在情况三。</p><p>而情况三逻辑也不复杂甚至感觉<strong>纯模拟</strong>就可以了，其实情况三这里是有贪心的。</p><p>账单是 20 的情况，为什么要优先消耗一个 10 和一个 5 呢？</p><p><strong>因为美元 10 只能给账单 20 找零，而美元 5 可以给账单 10 和账单 20 找零，美元 5 更万能！</strong></p><p>所以</p><ul><li>局部最优：遇到账单 20，优先消耗美元 10，完成本次找零。</li><li>全局最优：完成全部账单的找零。</li></ul><p>局部最优可以推出全局最优，并找不出反例，那么就试试贪心算法！</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">lemonadeChange</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bills<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token keyword">int</span> five <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> ten <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> twenty <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> bill <span class="token operator">:</span> bills<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>            <span class="token comment">// 情况一：顾客给了 5 美元，直接收下</span></pre></td></tr><tr><td data-num="6"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>bill <span class="token operator">==</span> <span class="token number">5</span><span class="token punctuation">)</span> five<span class="token operator">++</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>            <span class="token comment">// 情况二：顾客给了 10 美元，找 5 美元</span></pre></td></tr><tr><td data-num="8"></td><td><pre>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>bill <span class="token operator">==</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>                <span class="token keyword">if</span> <span class="token punctuation">(</span>five <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>                five<span class="token operator">--</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>                ten<span class="token operator">++</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>            <span class="token comment">// 情况三：顾客给了 20 美元，优先找 10 美元和 5 美元</span></pre></td></tr><tr><td data-num="14"></td><td><pre>            <span class="token keyword">else</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>                <span class="token keyword">if</span> <span class="token punctuation">(</span>five <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> ten <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>                    five<span class="token operator">--</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>                    ten<span class="token operator">--</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>                    twenty<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">// 其实这里 twenty++ 可以省略</span></pre></td></tr><tr><td data-num="19"></td><td><pre>                <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>five <span class="token operator">>=</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>                    five <span class="token operator">-=</span> <span class="token number">3</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>                    twenty<span class="token operator">++</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>                <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>                    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>                <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="29"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230108110103714.png" alt="image-20230108110103714"></p><h4 id="总结-60"><a class="anchor" href="#总结-60">#</a> 总结</h4><p>咋眼一看好像很复杂，分析清楚之后，会发现逻辑其实非常固定。</p><p>这道题目可以告诉大家，遇到感觉没有思路的题目，可以静下心来把能遇到的情况分析一下，只要分析到具体情况了，一下子就豁然开朗了。</p><p>如果一直陷入想从整体上寻找找零方案，就会把自己陷进去，各种情况一交叉，只会越想越复杂了。</p><h3 id="406-根据身高重建队列"><a class="anchor" href="#406-根据身高重建队列">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9xdWV1ZS1yZWNvbnN0cnVjdGlvbi1ieS1oZWlnaHQv">☆406. 根据身高重建队列</span></h3><p>本题有两个维度，h 和 k，看到这种题目一定要想如何确定一个维度，然后再按照另一个维度重新排列。</p><p>其实如果大家认真做了 [☆135. 分发糖果](#☆135. 分发糖果)，就会发现和此题有点点的像。</p><p>在 [☆135. 分发糖果](#☆135. 分发糖果) 我就强调过一次，<strong>遇到两个维度权衡的时候，一定要先确定一个维度，再确定另一个维度</strong>。</p><p><strong>如果两个维度一起考虑一定会顾此失彼</strong>。</p><p>对于本题相信大家困惑的点是先确定 k 还是先确定 h 呢，也就是究竟先按 h 排序呢，还是先按照 k 排序呢？</p><p>如果按照 k 来从小到大排序，排完之后，会发现 k 的排列并不符合条件，身高也不符合条件，两个维度哪一个都没确定下来。</p><p>那么按照身高 h 来排序呢，身高一定是从大到小排（身高相同的话则 k 小的站前面），让高个子在前面。</p><blockquote><p>为什么？</p></blockquote><p><strong>此时我们可以确定一个维度了，就是身高，前面的节点一定都比本节点高！</strong></p><p>那么只需要按照 k 为下标重新插入队列就可以了，为什么呢？</p><p>以图中 {5,2} 为例：</p><p><img data-src="https://img-blog.csdnimg.cn/20201216201851982.png" alt="406.根据身高重建队列"></p><p><strong><mark>按照身高排序之后，优先按身高高的 people 的 k 来插入</mark></strong>，后序插入节点也不会影响前面已经插入的节点，最终按照 k 的规则完成了队列。</p><p>所以在按照身高从大到小排序后：</p><ul><li><p><strong>局部最优：优先按身高高的 people 的 k 来插入。插入操作过后的 people 满足队列属性</strong></p></li><li><p><strong>全局最优：最后都做完插入操作，整个队列满足题目队列属性</strong></p></li></ul><p>局部最优可推出全局最优，找不出反例，那就试试贪心。</p><p>整个插入过程如下：</p><p>排序完的 people： [[7,0], [7,1], [6,1], [5,0], [5,2]，[4,4]]</p><p>插入的过程：</p><ul><li>插入 [7,0]：[[7,0]]</li><li>插入 [7,1]：[[7,0],[7,1]]</li><li>插入 [6,1]：[[7,0],[6,1],[7,1]]</li><li>插入 [5,0]：[[5,0],[7,0],[6,1],[7,1]]</li><li>插入 [5,2]：[[5,0],[7,0],[5,2],[6,1],[7,1]]</li><li>插入 [4,4]：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]</li></ul><p>此时就按照题目的要求完成了重新排列。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 贪心算法</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">reconstructQueue</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> people<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token comment">// 按照 h 降序，h 相同时按 k 升序排序</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>people<span class="token punctuation">,</span> <span class="token punctuation">(</span>o1<span class="token punctuation">,</span> o2<span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>o1<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> o2<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>                <span class="token keyword">return</span> o1<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> o2<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//k 升序</span></pre></td></tr><tr><td data-num="8"></td><td><pre>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>                <span class="token keyword">return</span> o2<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">-</span> o1<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//h 降序</span></pre></td></tr><tr><td data-num="10"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token comment">// 用（双向）链表模拟队列</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span> que <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> p <span class="token operator">:</span> people<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>            que<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>p<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 按照 k 插入</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token comment">// 转换为数组</span></pre></td></tr><tr><td data-num="18"></td><td><pre>        <span class="token keyword">return</span> que<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>que<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token punctuation">&#125;</span> <span class="token comment">// 时间复杂度：O (n^2) 空间复杂度：O (n)</span></pre></td></tr></table></figure><ul><li>时间复杂度：O (nlog n + n^2)</li><li>空间复杂度：O (n)</li></ul><h4 id="总结-61"><a class="anchor" href="#总结-61">#</a> 总结</h4><p>关于出现两个维度一起考虑的情况，我们已经做过两道题目了，另一道就是<span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVyY2FybC5jb20vMDEzNS4lRTUlODglODYlRTUlOEYlOTElRTclQjMlOTYlRTYlOUUlOUMuaHRtbA=="> 135. 分发糖果 (opens new window)</span>。</p><p><strong>其技巧都是确定一边然后贪心另一边，两边一起考虑，就会顾此失彼</strong>。</p><p>这道题目可以说比<span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVyY2FybC5jb20vMDEzNS4lRTUlODglODYlRTUlOEYlOTElRTclQjMlOTYlRTYlOUUlOUMuaHRtbA=="> 135. 分发糖果 (opens new window)</span> 难不少，其贪心的策略也是比较巧妙。</p><p>最后我给出了两个版本的代码，可以明显看是使用 C++ 中的 list（底层链表实现）比 vector（数组）效率高得多。</p><p><strong>对使用某一种语言容器的使用，特性的选择都会不同程度上影响效率</strong>。</p><p>所以很多人都说写算法题用什么语言都可以，主要体现在算法思维上，其实我是同意的但也不同意。</p><p>对于看别人题解的同学，题解用什么语言其实影响不大，只要题解把所使用语言特性优化的点讲出来，大家都可以看懂，并使用自己语言的时候注意一下。</p><p>对于写题解的同学，刷题用什么语言影响就非常大，如果自己语言没有学好而强调算法和编程语言没关系，其实是会误伤别人的。</p><p><strong>这也是我为什么统一使用 C++ 写题解的原因</strong>，其实用其他语言 java、python、php、go 啥的，我也能写，我的 Github 上也有用这些语言写的小项目，但写题解的话，我就不能保证把语言特性这块讲清楚，所以我始终坚持使用最熟悉的 C++ 写题解。</p><h3 id="贪心周总结三"><a class="anchor" href="#贪心周总结三">#</a> 贪心周总结三</h3><h4 id="周一-10"><a class="anchor" href="#周一-10">#</a> 周一</h4><p>在 [☆134. 加油站](#☆134. 加油站) 中给出每一个加油站的汽油和开到这个加油站的消耗，问汽车能不能开一圈。</p><p>这道题目咋眼一看，感觉是一道模拟题，模拟一下汽车从每一个节点出发看看能不能开一圈，时间复杂度是 O (n^2)。</p><p>即使用模拟这种情况，也挺考察代码技巧的。</p><p><strong>for 循环适合模拟从头到尾的遍历，而 while 循环适合模拟环形遍历，对于本题的场景要善于使用 while！</strong></p><p>如果代码功力不到位，就模拟这种情况，可能写的也会很费劲。</p><p>本题的贪心解法，我给出两种解法。</p><p>对于解法一，其实我并不认为这是贪心，因为没有找出局部最优，而是直接从<strong>全局最优的角度</strong>上思考问题，但思路很巧妙，值得学习一下。</p><p>对于解法二，贪心的局部最优：当前累加 rest [j] 的和 curSum 一旦小于 0，起始位置至少要是 j+1，因为从 j 开始一定不行。全局最优：找到可以跑一圈的起始位置。</p><p>这里是可以从局部最优推出全局最优的，想不出反例，那就试试贪心。</p><p><strong>解法二就体现出贪心的精髓，同时大家也会发现，虽然贪心是常识，有些常识并不容易，甚至很难！</strong></p><h4 id="周二-10"><a class="anchor" href="#周二-10">#</a> 周二</h4><p>在 [☆135. 分发糖果](#☆135. 分发糖果) 中我们第一次接触了需要考虑两个维度的情况。</p><p>例如这道题，是先考虑左边呢，还是考虑右边呢？</p><p><strong>先考虑哪一边都可以！ 就别两边一起考虑，那样就把自己陷进去了</strong>。</p><p>先贪心一边，局部最优：只要右边评分比左边大，右边的孩子就多一个糖果，全局最优：相邻的孩子中，评分高的右孩子获得比左边孩子更多的糖果</p><p>如图： <img data-src="https://img-blog.csdnimg.cn/20201117114916878.png" alt="135.分发糖果"></p><p>接着在贪心另一边，左孩子大于右孩子，左孩子的糖果就要比右孩子多。</p><p>此时 candyVec [i]（第 i 个小孩的糖果数量，左孩子）就有两个选择了，一个是 candyVec [i + 1] + 1（从右孩子这个加 1 得到的糖果数量），一个是 candyVec [i]（之前比较右孩子大于左孩子得到的糖果数量）。</p><p>那么第二次贪心的局部最优：取 candyVec [i + 1] + 1 和 candyVec [i] 最大的糖果数量，保证第 i 个小孩的糖果数量即大于左边的也大于右边的。全局最优：相邻的孩子中，评分高的孩子获得更多的糖果。</p><p>局部最优可以推出全局最优。</p><p>如图： <img data-src="https://img-blog.csdnimg.cn/20201117115658791.png" alt="135.分发糖果1"></p><h4 id="周三-10"><a class="anchor" href="#周三-10">#</a> 周三</h4><p>在 [860. 柠檬水找零](#860. 柠檬水找零) 中我们模拟了买柠檬水找零的过程。</p><p>这道题目刚一看，可能会有点懵，这要怎么找零才能保证完整全部账单的找零呢？</p><p><strong>但仔细一琢磨就会发现，可供我们做判断的空间非常少！</strong></p><p>美元 10 只能给账单 20 找零，而美元 5 可以给账单 10 和账单 20 找零，美元 5 更万能！</p><p>局部最优：遇到账单 20，优先消耗美元 10，完成本次找零。全局最优：完成全部账单的找零。</p><p>局部最优可以推出全局最优。</p><p>所以把能遇到的情况分析一下，只要分析到具体情况了，一下子就豁然开朗了。</p><p>这道题目其实是一道简单题，但如果一开始就想从整体上寻找找零方案，就会把自己陷进去，各种情况一交叉，只会越想越复杂了。</p><h4 id="周四-10"><a class="anchor" href="#周四-10">#</a> 周四</h4><p>在 [☆406. 根据身高重建队列](#☆406. 根据身高重建队列) 中，我们再一次遇到了需要考虑两个维度的情况。</p><p>之前我们已经做过一道类似的了就是 [☆135. 分发糖果](#☆135. 分发糖果)，但本题比分发糖果难不少！</p><p>[☆406. 根据身高重建队列](#☆406. 根据身高重建队列) 中依然是要确定一边，然后在考虑另一边，两边一起考虑一定会蒙圈。</p><p>那么本题先确定 k 还是先确定 h 呢，也就是究竟先按 h 排序呢，还先按照 k 排序呢？</p><p>这里其实很考察大家的思考过程，如果按照 k 来从小到大排序，排完之后，会发现 k 的排列并不符合条件，身高也不符合条件，两个维度哪一个都没确定下来。</p><p><strong>所以先从大到小按照 h 排个序，再来贪心 k</strong>。</p><p>此时局部最优：优先按身高高的 people 的 k 来插入。插入操作过后的 people 满足队列属性。全局最优：最后都做完插入操作，整个队列满足题目队列属性。</p><p>局部最优可以推出全局最优，找不出反例，那么就来贪心。</p><h4 id="总结-62"><a class="anchor" href="#总结-62">#</a> 总结</h4><p>「代码随想录」里已经讲了十一道贪心题目了，大家可以发现在每一道题目的讲解中，我都是把什么是局部最优，和什么是全局最优说清楚。</p><p>虽然有时候感觉贪心就是常识，但如果真正是常识性的题目，其实是模拟题，就不是贪心算法了！例如 [☆134. 加油站](#☆134. 加油站) 中的贪心方法一，其实我就认为不是贪心算法，而是直接从全局最优的角度上来模拟，因为方法里没有体现局部最优的过程。</p><p>而且大家也会发现，贪心并没有想象中的那么简单，贪心往往妙的出其不意，触不及防！哈哈</p><h3 id="452-用最少数量的箭引爆气球"><a class="anchor" href="#452-用最少数量的箭引爆气球">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9taW5pbXVtLW51bWJlci1vZi1hcnJvd3MtdG8tYnVyc3QtYmFsbG9vbnMv">452. 用最少数量的箭引爆气球</span></h3><p>如何使用最少的弓箭呢？</p><p>直觉上来看，貌似只射重叠最多的气球，用的弓箭一定最少，那么有没有当前重叠了三个气球，我射两个，留下一个和后面的一起射这样弓箭用的更少的情况呢？</p><p>尝试一下举反例，发现没有这种情况。</p><p>那么就试一试贪心吧！</p><ul><li>局部最优：<strong>当气球出现重叠，一起射</strong>，所用弓箭最少。</li><li>全局最优：把所有气球射爆所用弓箭最少。</li></ul><p><strong>算法确定下来了，那么如何模拟气球射爆的过程呢？是在数组中移除元素还是做标记呢？</strong></p><p>如果真实的模拟射气球的过程，应该射一个，气球数组就 remove 一个元素，这样最直观，毕竟气球被射了。</p><p>但仔细思考一下就发现：如果把气球排序之后，从前到后遍历气球，被射过的气球仅仅跳过就行了，没有必要让气球数组 remove 气球，只要记录一下箭的数量就可以了。</p><p>以上为思考过程，已经确定下来使用贪心了，那么开始解题。</p><p><strong>为了让气球尽可能的重叠，需要对数组进行排序</strong>。</p><p>那么按照气球起始位置排序，还是按照气球终止位置排序呢？</p><p>其实都可以！只不过对应的遍历顺序不同，我就按照气球的起始位置排序了。</p><p>既然按照起始位置排序，那么就从前向后遍历气球数组，靠左尽可能让气球重复。</p><p>从前向后遍历遇到重叠的气球了怎么办？</p><p><strong>如果气球重叠了，重叠气球中右边边界的最小值 之前的区间一定需要一个弓箭</strong>。</p><p>以题目示例： [[10,16],[2,8],[1,6],[7,12]] 为例，如图：（方便起见，已经排序）</p><p><img data-src="https://img-blog.csdnimg.cn/20201123101929791.png" alt="452.用最少数量的箭引爆气球"></p><p>可以看出首先第一组重叠气球，一定是需要一个箭，气球 3，的左边界大于了 第一组重叠气球的最小右边界，所以再需要一支箭来射气球 3 了。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findMinArrowShots</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> points<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token comment">// 特判：如果气球数量为 1，那么只需要一支箭</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>points<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token comment">// 按照气球的左边界进行升序排序（为了防止溢出，使用 Integer 内置比较方法 compare）</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>points<span class="token punctuation">,</span> <span class="token punctuation">(</span>o1<span class="token punctuation">,</span> o2<span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span>o1<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> o2<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 至少需要一支箭</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> points<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>            <span class="token comment">// 如果当前气球的左边界＞前一个气球的右边界，即二者不重叠，那么需要一支新的箭</span></pre></td></tr><tr><td data-num="12"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>points<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">></span> points<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>                res<span class="token operator">++</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>            <span class="token comment">// 否则，二者重叠，需要更新重叠气球最小右边界</span></pre></td></tr><tr><td data-num="16"></td><td><pre>            <span class="token keyword">else</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>                points<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>points<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> points<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>        <span class="token keyword">return</span> res<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="22"></td><td><pre><span class="token punctuation">&#125;</span> <span class="token comment">// 时间复杂度：O (nlogn)，因为有一个快排</span></pre></td></tr></table></figure><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230108224356641.png" alt="image-20230108224356641"></p><h4 id="注意"><a class="anchor" href="#注意">#</a> 注意</h4><p>注意题目中说的是：满足 xstart ≤ x ≤ xend，则该气球会被引爆。那么说明两个气球挨在一起不重叠也可以一起射爆，</p><p>所以代码中 <code>if (points[i][0] &gt; points[i - 1][1])</code> 不能是 &gt;=</p><h4 id="总结-63"><a class="anchor" href="#总结-63">#</a> 总结</h4><p>这道题目贪心的思路很简单也很直接，就是重复的一起射了，但本题我认为是有难度的。</p><p>就算思路都想好了，模拟射气球的过程，很多同学真的要去模拟了，实时把气球从数组中移走，这么写的话就复杂了。</p><p>而且寻找重复的气球，寻找重叠气球最小右边界，其实都有代码技巧。</p><p>贪心题目有时候就是这样，看起来很简单，思路很直接，但是一写代码就感觉贼复杂无从下手。</p><p>这里其实是需要代码功底的，那代码功底怎么练？</p><p><strong>多看多写多总结！</strong></p><h3 id="435-无重叠区间"><a class="anchor" href="#435-无重叠区间">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9ub24tb3ZlcmxhcHBpbmctaW50ZXJ2YWxzLw==">☆435. 无重叠区间</span></h3><p><strong>相信很多同学看到这道题目都冥冥之中感觉要排序，但是究竟是按照右边界排序，还是按照左边界排序呢？</strong></p><p>这其实是一个难点！</p><p>按照右边界排序，就要从左向右遍历，因为右边界越小越好，只要右边界越小，留给下一个区间的空间就越大，所以从左向右遍历，优先选右边界小的。</p><p>按照左边界排序，就要从右向左遍历，因为左边界数值越大越好（越靠右），这样就给前一个区间的空间就越大，所以可以从右向左遍历。</p><p>如果按照左边界排序，还从左向右遍历的话，其实也可以，逻辑会有所不同。</p><p>一些同学做这道题目可能真的去模拟去重复区间的行为，这是比较麻烦的，还要去删除区间。</p><p>题目只是要求移除区间的个数，没有必要去真实的模拟删除区间！</p><p><strong>我来按照右边界排序，从左向右记录非交叉区间的个数。最后用区间总数减去非交叉区间的个数就是需要移除的区间个数了</strong>。</p><p>此时问题就是要求非交叉区间的最大个数。</p><p>右边界排序之后，</p><ul><li><p>局部最优：优先选右边界小的区间，所以从左向右遍历，留给下一个区间的空间大一些，从而尽量避免交叉。</p></li><li><p>全局最优：选取最多的非交叉区间。</p><blockquote><p>从而使移除的区间数量最少</p></blockquote></li></ul><p>局部最优推出全局最优，试试贪心！</p><p>这里记录非交叉区间的个数还是有技巧的，如图：</p><p><img data-src="https://img-blog.csdnimg.cn/20201221201553618.png" alt="435.无重叠区间"></p><p>区间，1，2，3，4，5，6 都按照右边界排好序。</p><p>每次取非交叉区间的时候，都是可右边界最小的来做分割点（这样留给下一个区间的空间就越大），所以第一条分割线就是区间 1 结束的位置。</p><p>接下来就是找大于区间 1 结束位置的区间，是从区间 4 开始。<strong>那有同学问了为什么不从区间 5 开始？别忘了已经是按照右边界排序的了</strong>。</p><p>区间 4 结束之后，再找到区间 6，所以一共记录非交叉区间的个数是三个。</p><p>总共区间个数为 6，减去非交叉区间的个数 3。移除区间的最小数量就是 3。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 贪心算法：选取最多的非交叉区间，从而使移除的交叉区间数量最少</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">eraseOverlapIntervals</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> intervals<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token comment">// 特判：intervals 只有 1 个元素</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>intervals<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token comment">// 按照区间右边界对 intervals 进行升序排序</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>intervals<span class="token punctuation">,</span> <span class="token punctuation">(</span>o1<span class="token punctuation">,</span> o2<span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>            <span class="token keyword">return</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span>o1<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> o2<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 非交叉区间的个数</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token keyword">int</span> end <span class="token operator">=</span> intervals<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 区间分割点</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> intervals<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>end <span class="token operator">&lt;=</span> intervals<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 当前区间与上一个不相交</span></pre></td></tr><tr><td data-num="16"></td><td><pre>                end <span class="token operator">=</span> intervals<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 更新区间分割点</span></pre></td></tr><tr><td data-num="17"></td><td><pre>                count<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">// 非交叉区间个数 + 1</span></pre></td></tr><tr><td data-num="18"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="20"></td><td><pre></pre></td></tr><tr><td data-num="21"></td><td><pre>        <span class="token keyword">return</span> intervals<span class="token punctuation">.</span>length <span class="token operator">-</span> count<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="23"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230109131951893.png" alt="image-20230109131951893"></p><ul><li>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlog n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:.01968em">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:.03588em">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> ，有一个快排</li><li>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，有一个快排，最差情况 (倒序) 时，需要 n 次递归调用。因此确实需要 O (n) 的栈空间</li></ul><p>大家此时会发现如此复杂的一个问题，代码实现却这么简单！</p><h4 id="总结-64"><a class="anchor" href="#总结-64">#</a> 总结</h4><p>本题我认为难度级别可以算是 hard 级别的！</p><p>总结如下难点：</p><ul><li>难点一：一看题就有感觉需要排序，但究竟怎么排序，按左边界排还是右边界排。</li><li>难点二：排完序之后如何遍历，如果没有分析好遍历顺序，那么排序就没有意义了。</li><li>难点三：直接求重复的区间是复杂的，转而求最大非重复区间个数。</li><li>难点四：求最大非重复区间个数时，需要一个分割点来做标记。</li></ul><p><strong>这四个难点都不好想，但任何一个没想到位，这道题就解不了</strong>。</p><p>一些录友可能看网上的题解代码很简单，照葫芦画瓢稀里糊涂的就过了，但是其题解可能并没有把问题难点讲清楚，然后自己再没有钻研的话，那么一道贪心经典区间问题就这么浪费掉了。</p><p>贪心就是这样，代码有时候很简单（不是指代码短，而是逻辑简单），但想法是真的难！</p><p>这和动态规划还不一样，动规的代码有个递推公式，可能就看不懂了，而贪心往往是直白的代码，但想法读不懂，哈哈。</p><p><strong>所以我把本题的难点也一一列出，帮大家不仅代码看的懂，想法也理解的透彻！</strong></p><h3 id="763-划分字母区间"><a class="anchor" href="#763-划分字母区间">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9wYXJ0aXRpb24tbGFiZWxzLw==">763. 划分字母区间</span></h3><p>一想到分割字符串就想到了回溯，但本题其实不用回溯去暴力搜索。</p><p>题目要求同一字母最多出现在一个片段中，那么如何把同一个字母的都圈在同一个区间里呢？</p><p>如果没有接触过这种题目的话，还挺有难度的。</p><p>在遍历的过程中相当于是要找每一个字母的边界，<strong>如果找到之前遍历过的所有字母的最远边界，说明这个边界就是分割点了</strong>。此时前面出现过所有字母，最远也就到这个边界了。</p><p>可以分为如下两步：</p><ul><li>统计每一个字符最后出现的位置</li><li>从头遍历字符，并更新字符的最远出现下标，如果找到字符最远出现位置下标和当前下标相等了，则找到了分割点</li></ul><p>如图：</p><p><img data-src="https://img-blog.csdnimg.cn/20201222191924417.png" alt="763.划分字母区间"></p><p>明白原理之后，代码并不复杂，如下：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 贪心算法</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> <span class="token function">partitionLabels</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token comment">// 遍历字符串，记录每个字母最后出现的位置</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> hash <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">27</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>            hash<span class="token punctuation">[</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token char">'a'</span><span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token comment">// 遍历字符串，记录当前片段的最后位置</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> right <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>            right <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>right<span class="token punctuation">,</span> hash<span class="token punctuation">[</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token char">'a'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 更新当前片段的最后位置</span></pre></td></tr><tr><td data-num="16"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> right<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 当前位置到达当前片段的最后位置，划分片段</span></pre></td></tr><tr><td data-num="17"></td><td><pre>                res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>right <span class="token operator">-</span> left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 记录当前片段的长度</span></pre></td></tr><tr><td data-num="18"></td><td><pre>                left <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 更新下一个片段的起始位置</span></pre></td></tr><tr><td data-num="19"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="21"></td><td><pre></pre></td></tr><tr><td data-num="22"></td><td><pre>        <span class="token keyword">return</span> res<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="24"></td><td><pre><span class="token punctuation">&#125;</span> <span class="token comment">// 时间复杂度：O (n) 空间复杂度：O (1)</span></pre></td></tr></table></figure><ul><li>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li><li>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，使用的 hash 数组是固定大小</li></ul><p><img data-src="https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230109192256138.png" alt="image-20230109192256138"></p><h4 id="总结-65"><a class="anchor" href="#总结-65">#</a> 总结</h4><p>这道题目 leetcode 标记为贪心算法，说实话，我没有感受到贪心，找不出局部最优推出全局最优的过程。就是用最远出现距离模拟了圈字符的行为。</p><p>但这道题目的思路是很巧妙的，所以有必要介绍给大家做一做，感受一下。</p><h3 id="56-合并区间"><a class="anchor" href="#56-合并区间">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tZXJnZS1pbnRlcnZhbHMv">56. 合并区间</span></h3><p>大家应该都感觉到了，此题一定要排序，那么按照左边界排序，还是右边界排序呢？</p><p>都可以！</p><p>那么我按照左边界排序，排序之后</p><ul><li>局部最优：每次合并都取最大的右边界，这样就可以合并更多的区间了</li><li>整体最优：合并所有重叠的区间</li></ul><p>局部最优可以推出全局最优，找不出反例，试试贪心。</p><p>那有同学问了，本来不就应该合并最大右边界么，这和贪心有啥关系？</p><p>有时候贪心就是常识！哈哈</p><p>按照左边界从小到大排序之后，如果 <code>intervals[i][0] &lt; intervals[i - 1][1]</code> 即 intervals [i] 左边界 &lt; intervals [i - 1] 右边界，则一定有重复，因为 intervals [i] 的左边界一定是大于等于 intervals [i - 1] 的左边界。</p><p>即：intervals [i] 的左边界在 intervals [i - 1] 左边界和右边界的范围内，那么一定有重复！</p><p>这么说有点抽象，看图：（<strong>注意图中区间都是按照左边界排序之后了</strong>）</p><p><img data-src="https://img-blog.csdnimg.cn/20201223200632791.png" alt="56.合并区间"></p><p>知道如何判断重复之后，剩下的就是合并了，如何去模拟合并区间呢？</p><p>其实就是用合并区间后左边界和右边界，作为一个新的区间，加入到 result 数组里就可以了。如果没有合并就把原区间加入到 result 数组。</p><p>Java 代码如下：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 贪心算法：每次选择最小的右边界</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> intervals<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token class-name">List</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 这里不能定义为 int [][]，因为需要合并区间，对结果集中的区间数是未知</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token comment">// 特判</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>intervals<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> intervals<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token comment">// 按照左边界升序排序</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>intervals<span class="token punctuation">,</span> <span class="token punctuation">(</span>o1<span class="token punctuation">,</span> o2<span class="token punctuation">)</span> <span class="token operator">-></span> o1<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">-</span> o2<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token comment">// 遍历数组</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>intervals<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 先把第一个区间加入到结果集中</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> intervals<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>intervals<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;=</span> res<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>                <span class="token comment">// 合并区间：如果当前区间的左边界小于等于结果集中最后一个区间的右边界，说明两个区间有重叠，需要合并</span></pre></td></tr><tr><td data-num="17"></td><td><pre>                res<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> intervals<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>                <span class="token comment">// 不重叠，直接加入到结果集中</span></pre></td></tr><tr><td data-num="20"></td><td><pre>                res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>intervals<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="23"></td><td><pre></pre></td></tr><tr><td data-num="24"></td><td><pre>        <span class="token keyword">return</span> res<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>res<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//toArray () 方法的参数是一个空数组，用来指定返回的数组类型</span></pre></td></tr><tr><td data-num="25"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="26"></td><td><pre><span class="token punctuation">&#125;</span> <span class="token comment">// 时间复杂度：O (nlogn)，因为有一个快排；空间复杂度：O (n)，快排的最差情况（倒序）时需要 n 次递归</span></pre></td></tr></table></figure><ul><li>时间复杂度：O (nlog n) ，有一个快排</li><li>空间复杂度：O (n)，有一个快排，最差情况 (倒序) 时，需要 n 次递归调用。因此确实需要 O (n) 的栈空间</li></ul><h4 id="总结-66"><a class="anchor" href="#总结-66">#</a> 总结</h4><p>对于贪心算法，很多同学都是：<strong>如果能凭常识直接做出来，就会感觉不到自己用了贪心，一旦第一直觉想不出来，可能就一直想不出来了</strong>。</p><p>跟着「代码随想录」刷题的录友应该感受过，贪心难起来，真的难。</p><p>那应该怎么办呢？</p><p>正如我贪心系列开篇词<a href="#%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80">贪心算法理论基础</a>中讲解的一样，贪心本来就没有套路，也没有框架，所以各种常规解法需要多接触多练习，自然而然才会想到。</p><h3 id="贪心周总结四"><a class="anchor" href="#贪心周总结四">#</a> 贪心周总结四</h3><h4 id="周一-11"><a class="anchor" href="#周一-11">#</a> 周一</h4><p>在 [452. 用最少数量的箭引爆气球](#452. 用最少数量的箭引爆气球) 中，我们开始讲解了重叠区间问题，用最少的弓箭射爆所有气球，其本质就是找到最大的重叠区间。</p><p>按照左边界进行排序后，如果气球重叠了，<strong>重叠气球中右边边界的最小值</strong>之前的区间一定需要一个弓箭</p><p>如图：</p><p><img data-src="https://img-blog.csdnimg.cn/20201123101929791.png" alt="452.用最少数量的箭引爆气球"></p><p>模拟射气球的过程，很多同学真的要去模拟了，实时把气球从数组中移走，这么写的话就复杂了，从前向后遍历重复的只要跳过就可以的。</p><h4 id="周二-11"><a class="anchor" href="#周二-11">#</a> 周二</h4><p>在 [☆435. 无重叠区间](#☆435. 无重叠区间) 中要去掉最少的区间，来让所有区间没有重叠。</p><p>我来按照右边界排序，从左向右<strong>记录非交叉区间的个数</strong>。最后用区间总数减去非交叉区间的个数就是需要移除的区间个数了。</p><p>如图：</p><p><img data-src="https://img-blog.csdnimg.cn/20201221201553618.png" alt="435.无重叠区间"></p><h4 id="周三-11"><a class="anchor" href="#周三-11">#</a> 周三</h4><h4 id="周四-11"><a class="anchor" href="#周四-11">#</a> 周四</h4><h4 id="周五-7"><a class="anchor" href="#周五-7">#</a> 周五</h4></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2023-11-25 15:11:37" itemprop="dateModified" datetime="2023-11-25T15:11:37+08:00">2023-11-25</time> </span><span id="leetcode/carl/笔记随想录/" class="item leancloud_visitors" data-flag-title="代码随想录-笔记" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>范特东东东 <i class="ic i-at"><em>@</em></i>水文 & 摄影</li><li class="link"><strong>本文链接：</strong> <a href="http://example.com/leetcode/carl/%E7%AC%94%E8%AE%B0%E9%9A%8F%E6%83%B3%E5%BD%95/" title="代码随想录-笔记">http://example.com/leetcode/carl/笔记随想录/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/framework/spring/spring6/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;hjx159&#x2F;picture-bed&#x2F;main&#x2F;img&#x2F;2097896352.png" title="尚硅谷 Spring6"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> Spring</span><h3>尚硅谷 Spring6</h3></a></div><div class="item right"><a href="/java/java-se/java-knowledge/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E5%AE%8B%E7%BA%A2%E5%BA%B7_%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;hjx159&#x2F;picture-bed&#x2F;main&#x2F;img&#x2F;cover.jpg" title="宋红康_第01章_Java语言概述"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> Java基础-知识点</span><h3>宋红康_第01章_Java语言概述</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%94%E8%AE%B0%E9%9A%8F%E6%83%B3%E5%BD%95"><span class="toc-number">1.</span> <span class="toc-text">笔记随想录</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9F%E6%9F%A5%E6%89%8B%E5%86%8C"><span class="toc-number">1.1.</span> <span class="toc-text">速查手册</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#java%E4%B8%ADstack-queue%E7%9A%84%E6%8E%A5%E5%8F%A3%E5%87%BD%E6%95%B0"><span class="toc-number">1.1.1.</span> <span class="toc-text">java 中 Stack、Queue 的接口函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#stack%E7%B1%BB"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">Stack 类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#queue%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">Queue 接口</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4-%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">1.2.</span> <span class="toc-text">递归算法的时间、空间复杂度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">1.3.</span> <span class="toc-text">数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80"><span class="toc-number">1.3.1.</span> <span class="toc-text">理论基础</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#704-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="toc-number">1.3.2.</span> <span class="toc-text">704. 二分查找</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#35-%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">35. 搜索插入位置</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9A%B4%E5%8A%9B%E8%A7%A3%E6%B3%95"><span class="toc-number">1.3.2.1.1.</span> <span class="toc-text">暴力解法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%B3%95"><span class="toc-number">1.3.2.1.2.</span> <span class="toc-text">二分查找法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#27-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0"><span class="toc-number">1.3.3.</span> <span class="toc-text">27. 移除元素</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9A%B4%E5%8A%9B%E8%A7%A3%E6%B3%95-2"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">暴力解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95"><span class="toc-number">1.3.3.2.</span> <span class="toc-text">双指针法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%90%91%E5%8F%8C%E6%8C%87%E9%92%88"><span class="toc-number">1.3.3.3.</span> <span class="toc-text">相向双指针</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#977-%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9"><span class="toc-number">1.3.4.</span> <span class="toc-text">977. 有序数组的平方</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9A%B4%E5%8A%9B%E6%8E%92%E5%BA%8F"><span class="toc-number">1.3.4.1.</span> <span class="toc-text">暴力排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95-2"><span class="toc-number">1.3.4.2.</span> <span class="toc-text">双指针法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#209-%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84"><span class="toc-number">1.3.5.</span> <span class="toc-text">209. 长度最小的子数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9A%B4%E5%8A%9B%E8%A7%A3%E6%B3%95-3"><span class="toc-number">1.3.5.1.</span> <span class="toc-text">暴力解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="toc-number">1.3.5.2.</span> <span class="toc-text">滑动窗口</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#59-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5-ii"><span class="toc-number">1.3.6.</span> <span class="toc-text">59. 螺旋矩阵 II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.3.7.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8"><span class="toc-number">1.4.</span> <span class="toc-text">链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80"><span class="toc-number">1.4.1.</span> <span class="toc-text">链表理论基础</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">1.4.1.2.</span> <span class="toc-text">存储方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8A%82%E7%82%B9%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">1.4.1.3.</span> <span class="toc-text">节点的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C"><span class="toc-number">1.4.1.4.</span> <span class="toc-text">操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E4%B8%8E%E6%95%B0%E7%BB%84%E5%81%9A%E5%AF%B9%E6%AF%94"><span class="toc-number">1.4.1.5.</span> <span class="toc-text">性能分析（与数组做对比）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#203-%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0"><span class="toc-number">1.4.2.</span> <span class="toc-text">203. 移除链表元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#707-%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8"><span class="toc-number">1.4.3.</span> <span class="toc-text">707. 设计链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="toc-number">1.4.4.</span> <span class="toc-text">206. 反转链表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95-3"><span class="toc-number">1.4.4.1.</span> <span class="toc-text">双指针法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E6%B3%95"><span class="toc-number">1.4.4.2.</span> <span class="toc-text">递归法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9"><span class="toc-number">1.4.5.</span> <span class="toc-text">24. 两两交换链表中的节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC-n-%E4%B8%AA%E7%BB%93%E7%82%B9"><span class="toc-number">1.4.6.</span> <span class="toc-text">19. 删除链表的倒数第 n 个结点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98-0207-%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4"><span class="toc-number">1.4.7.</span> <span class="toc-text">面试题 02.07. 链表相交</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-ii"><span class="toc-number">1.4.8.</span> <span class="toc-text">142. 环形链表 II</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E6%9C%89%E7%8E%AF"><span class="toc-number">1.4.8.1.</span> <span class="toc-text">判断链表是否有环</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E6%9C%89%E7%8E%AF%E5%A6%82%E4%BD%95%E6%89%BE%E5%88%B0%E8%BF%99%E4%B8%AA%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3"><span class="toc-number">1.4.8.2.</span> <span class="toc-text">如果有环，如何找到这个环的入口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%A5%E5%85%85"><span class="toc-number">1.4.8.3.</span> <span class="toc-text">补充</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E6%80%BB%E7%BB%93%E7%AF%87"><span class="toc-number">1.4.9.</span> <span class="toc-text">链表总结篇</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E7%9A%84%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80"><span class="toc-number">1.4.9.1.</span> <span class="toc-text">链表的理论基础</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E7%BB%8F%E5%85%B8%E9%A2%98%E7%9B%AE"><span class="toc-number">1.4.9.2.</span> <span class="toc-text">链表经典题目</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%A4%B4%E8%8A%82%E7%82%B9"><span class="toc-number">1.4.9.2.1.</span> <span class="toc-text">虚拟头节点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">1.4.9.2.2.</span> <span class="toc-text">链表的基本操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="toc-number">1.4.9.2.3.</span> <span class="toc-text">反转链表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E5%80%92%E6%95%B0%E7%AC%ACn%E4%B8%AA%E8%8A%82%E7%82%B9"><span class="toc-number">1.4.9.2.4.</span> <span class="toc-text">删除倒数第 N 个节点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4"><span class="toc-number">1.4.9.2.5.</span> <span class="toc-text">链表相交</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8"><span class="toc-number">1.4.9.3.</span> <span class="toc-text">环形链表</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-number">1.5.</span> <span class="toc-text">哈希表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80-2"><span class="toc-number">1.5.1.</span> <span class="toc-text">理论基础</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8-2"><span class="toc-number">1.5.1.1.</span> <span class="toc-text">哈希表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0"><span class="toc-number">1.5.1.2.</span> <span class="toc-text">哈希函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E7%A2%B0%E6%92%9E"><span class="toc-number">1.5.1.3.</span> <span class="toc-text">哈希碰撞</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8B%89%E9%93%BE%E6%B3%95"><span class="toc-number">1.5.1.3.1.</span> <span class="toc-text">拉链法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E6%8E%A2%E6%B5%8B%E6%B3%95"><span class="toc-number">1.5.1.3.2.</span> <span class="toc-text">线性探测法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E4%B8%89%E7%A7%8D%E5%93%88%E5%B8%8C%E7%BB%93%E6%9E%84"><span class="toc-number">1.5.1.4.</span> <span class="toc-text">常见的三种哈希结构</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E7%BB%84-2"><span class="toc-number">1.5.1.4.1.</span> <span class="toc-text">数组</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#set%E9%9B%86%E5%90%88"><span class="toc-number">1.5.1.4.2.</span> <span class="toc-text">set（集合）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#map%E6%98%A0%E5%B0%84"><span class="toc-number">1.5.1.4.3.</span> <span class="toc-text">map（映射）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-2"><span class="toc-number">1.5.1.5.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#242-%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D"><span class="toc-number">1.5.2.</span> <span class="toc-text">242. 有效的字母异位词</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#383-%E8%B5%8E%E9%87%91%E4%BF%A1"><span class="toc-number">1.5.2.1.</span> <span class="toc-text">383. 赎金信</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9A%B4%E5%8A%9B%E8%A7%A3%E6%B3%95-4"><span class="toc-number">1.5.2.1.1.</span> <span class="toc-text">暴力解法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E8%A7%A3%E6%B3%95"><span class="toc-number">1.5.2.1.2.</span> <span class="toc-text">哈希解法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#349-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86"><span class="toc-number">1.5.3.</span> <span class="toc-text">349. 两个数组的交集</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%93%E5%B1%95"><span class="toc-number">1.5.3.1.</span> <span class="toc-text">拓展</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8E%E8%AE%B0"><span class="toc-number">1.5.3.2.</span> <span class="toc-text">后记</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#202-%E5%BF%AB%E4%B9%90%E6%95%B0"><span class="toc-number">1.5.4.</span> <span class="toc-text">202. 快乐数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="toc-number">1.5.5.</span> <span class="toc-text">1. 两数之和</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-3"><span class="toc-number">1.5.5.1.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#454-%E5%9B%9B%E6%95%B0%E7%9B%B8%E5%8A%A0-ii"><span class="toc-number">1.5.6.</span> <span class="toc-text">454. 四数相加 II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="toc-number">1.5.7.</span> <span class="toc-text">15. 三数之和</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E8%A7%A3%E6%B3%95-2"><span class="toc-number">1.5.7.1.</span> <span class="toc-text">哈希解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E6%8C%87%E9%92%88"><span class="toc-number">1.5.7.2.</span> <span class="toc-text">双指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%BB%E9%87%8D%E9%80%BB%E8%BE%91%E7%9A%84%E6%80%9D%E8%80%83"><span class="toc-number">1.5.7.3.</span> <span class="toc-text">去重逻辑的思考</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#a%E7%9A%84%E5%8E%BB%E9%87%8D"><span class="toc-number">1.5.7.3.1.</span> <span class="toc-text">a 的去重</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#b-c%E7%9A%84%E5%8E%BB%E9%87%8D"><span class="toc-number">1.5.7.3.2.</span> <span class="toc-text">b、c 的去重</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%80%83"><span class="toc-number">1.5.7.4.</span> <span class="toc-text">思考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="toc-number">1.5.8.</span> <span class="toc-text">18. 四数之和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-4"><span class="toc-number">1.5.9.</span> <span class="toc-text">总结</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80-3"><span class="toc-number">1.5.9.1.</span> <span class="toc-text">理论基础</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%8F%E5%85%B8%E9%A2%98%E7%9B%AE"><span class="toc-number">1.5.9.2.</span> <span class="toc-text">经典题目</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#u%E6%95%B0%E7%BB%84u%E4%BD%9C%E4%B8%BA%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-number">1.5.9.2.1.</span> <span class="toc-text">数组作为哈希表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#usetu%E4%BD%9C%E4%B8%BA%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-number">1.5.9.2.2.</span> <span class="toc-text">set作为哈希表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#umapu%E4%BD%9C%E4%B8%BA%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-number">1.5.9.2.3.</span> <span class="toc-text">map作为哈希表</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-5"><span class="toc-number">1.5.9.3.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.6.</span> <span class="toc-text">字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#344-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.6.1.</span> <span class="toc-text">344. 反转字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#541-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2-ii"><span class="toc-number">1.6.2.</span> <span class="toc-text">541. 反转字符串 II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%91%E6%8C%87-offer-05-%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC"><span class="toc-number">1.6.3.</span> <span class="toc-text">剑指 Offer 05. 替换空格</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9A%B4%E5%8A%9B%E6%B3%95"><span class="toc-number">1.6.3.1.</span> <span class="toc-text">暴力法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95-4"><span class="toc-number">1.6.3.2.</span> <span class="toc-text">双指针法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#151-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D"><span class="toc-number">1.6.4.</span> <span class="toc-text">151. 反转字符串中的单词</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%91%E6%8C%87-offer-58-ii-%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.6.5.</span> <span class="toc-text">剑指 Offer 58 - II. 左旋转字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#28-%E6%89%BE%E5%87%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8C%B9%E9%85%8D%E9%A1%B9%E7%9A%84%E4%B8%8B%E6%A0%87%E5%AE%9E%E7%8E%B0strstr"><span class="toc-number">1.6.6.</span> <span class="toc-text">28. 找出字符串中第一个匹配项的下标：实现 strStr ()</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#kmp%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8"><span class="toc-number">1.6.6.1.</span> <span class="toc-text">KMP 有什么用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%89%8D%E7%BC%80%E8%A1%A8"><span class="toc-number">1.6.6.2.</span> <span class="toc-text">什么是前缀表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E9%95%BFu%E5%85%AC%E5%85%B1u%E5%89%8D%E5%90%8E%E7%BC%80-or-%E6%9C%80%E9%95%BFu%E7%9B%B8%E7%AD%89u%E5%89%8D%E5%90%8E%E7%BC%80"><span class="toc-number">1.6.6.3.</span> <span class="toc-text">最长公共前后缀 or 最长相等前后缀</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%80%E5%AE%9A%E8%A6%81%E7%94%A8%E5%89%8D%E7%BC%80%E8%A1%A8"><span class="toc-number">1.6.6.4.</span> <span class="toc-text">为什么一定要用前缀表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97%E5%89%8D%E7%BC%80%E8%A1%A8"><span class="toc-number">1.6.6.5.</span> <span class="toc-text">如何计算前缀表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8D%E7%BC%80%E8%A1%A8%E4%B8%8Enext%E6%95%B0%E7%BB%84"><span class="toc-number">1.6.6.6.</span> <span class="toc-text">前缀表与 next 数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8next%E6%95%B0%E7%BB%84%E6%9D%A5%E5%8C%B9%E9%85%8D"><span class="toc-number">1.6.6.7.</span> <span class="toc-text">使用 next 数组来匹配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90"><span class="toc-number">1.6.6.8.</span> <span class="toc-text">时间复杂度分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0next%E6%95%B0%E7%BB%84"><span class="toc-number">1.6.6.9.</span> <span class="toc-text">构造 next 数组？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.6.6.9.1.</span> <span class="toc-text">1. 初始化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%A4%84%E7%90%86%E5%89%8D%E5%90%8E%E7%BC%80%E4%B8%8D%E7%9B%B8%E5%90%8C%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-number">1.6.6.9.2.</span> <span class="toc-text">2. 处理前后缀不相同的情况</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E5%A4%84%E7%90%86%E5%89%8D%E5%90%8E%E7%BC%80%E7%9B%B8%E5%90%8C%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-number">1.6.6.9.3.</span> <span class="toc-text">3. 处理前后缀相同的情况</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8next%E6%95%B0%E7%BB%84%E6%9D%A5%E5%81%9A%E5%8C%B9%E9%85%8D"><span class="toc-number">1.6.6.10.</span> <span class="toc-text">使用 next 数组来做匹配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8D%E7%BC%80%E8%A1%A8%E7%BB%9F%E4%B8%80%E5%87%8F%E4%B8%80-c%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.6.6.11.</span> <span class="toc-text">前缀表统一减一 C++ 代码实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8D%E7%BC%80%E8%A1%A8%E4%B8%8D%E5%87%8F%E4%B8%80c%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.6.6.12.</span> <span class="toc-text">前缀表（不减一）C++ 实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-6"><span class="toc-number">1.6.6.13.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#459-%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.6.7.</span> <span class="toc-text">459. 重复的子字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9A%B4%E5%8A%9B%E6%B3%95-2"><span class="toc-number">1.6.7.1.</span> <span class="toc-text">暴力法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E5%8C%B9%E9%85%8D"><span class="toc-number">1.6.7.2.</span> <span class="toc-text">移动匹配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#kmp%E7%AE%97%E6%B3%95"><span class="toc-number">1.6.7.3.</span> <span class="toc-text">KMP 算法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E4%BD%BF%E7%94%A8kmp%E7%AE%97%E6%B3%95"><span class="toc-number">1.6.7.3.1.</span> <span class="toc-text">为什么会使用 KMP 算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%89%BE%E5%88%B0%E6%9C%80%E5%B0%8F%E9%87%8D%E5%A4%8D%E5%AD%90%E4%B8%B2"><span class="toc-number">1.6.7.3.2.</span> <span class="toc-text">如何找到最小重复子串</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E6%8E%A8%E7%90%86"><span class="toc-number">1.6.7.3.3.</span> <span class="toc-text">简单推理</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95-5"><span class="toc-number">1.7.</span> <span class="toc-text">双指针法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A027-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0"><span class="toc-number">1.7.1.</span> <span class="toc-text">[1. 移除元素](#27. 移除元素)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2344-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.7.2.</span> <span class="toc-text">[2. 反转字符串](#344. 反转字符串)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC%E5%89%91%E6%8C%87-offer-05-%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC"><span class="toc-number">1.7.3.</span> <span class="toc-text">[3. 替换空格](# 剑指 Offer 05. 替换空格)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8C%E7%9A%84%E5%8D%95%E8%AF%8D151-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D"><span class="toc-number">1.7.4.</span> <span class="toc-text">[4. 翻转字符串里的单词](#151. 反转字符串中的单词)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="toc-number">1.7.5.</span> <span class="toc-text">[5. 反转链表](#206. 反转链表)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACn%E4%B8%AA%E8%8A%82%E7%82%B919-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC-n-%E4%B8%AA%E7%BB%93%E7%82%B9"><span class="toc-number">1.7.6.</span> <span class="toc-text">[6. 删除链表的倒数第 n 个节点](#19. 删除链表的倒数第 n 个结点)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4%E9%9D%A2%E8%AF%95%E9%A2%98-0207-%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4"><span class="toc-number">1.7.7.</span> <span class="toc-text">[7. 链表相交](# 面试题 02.07. 链表相交)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8ii142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-ii"><span class="toc-number">1.7.8.</span> <span class="toc-text">[8. 环形链表 II](#142. 环形链表 II)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="toc-number">1.7.9.</span> <span class="toc-text">[9. 三数之和](#15. 三数之和)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C18-%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="toc-number">1.7.10.</span> <span class="toc-text">[10. 四数之和](#18. 四数之和)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-7"><span class="toc-number">1.7.11.</span> <span class="toc-text">总结</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%AF%87"><span class="toc-number">1.7.11.1.</span> <span class="toc-text">数组篇</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AF%87"><span class="toc-number">1.7.11.2.</span> <span class="toc-text">字符串篇</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E7%AF%87"><span class="toc-number">1.7.11.3.</span> <span class="toc-text">链表篇</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#n%E6%95%B0%E4%B9%8B%E5%92%8C%E7%AF%87"><span class="toc-number">1.7.11.4.</span> <span class="toc-text">N 数之和篇</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">1.7.11.5.</span> <span class="toc-text">小结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97"><span class="toc-number">1.8.</span> <span class="toc-text">栈与队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80-4"><span class="toc-number">1.8.1.</span> <span class="toc-text">理论基础</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#232-%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97"><span class="toc-number">1.8.2.</span> <span class="toc-text">232. 用栈实现队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#225-%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88"><span class="toc-number">1.8.3.</span> <span class="toc-text">225. 用队列实现栈</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%8C%96"><span class="toc-number">1.8.3.1.</span> <span class="toc-text">优化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7"><span class="toc-number">1.8.4.</span> <span class="toc-text">20. 有效的括号</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E5%A4%96%E8%AF%9D"><span class="toc-number">1.8.4.1.</span> <span class="toc-text">题外话</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E5%85%A5%E6%AD%A3%E9%A2%98"><span class="toc-number">1.8.4.2.</span> <span class="toc-text">进入正题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1047-%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E7%9B%B8%E9%82%BB%E9%87%8D%E5%A4%8D%E9%A1%B9"><span class="toc-number">1.8.5.</span> <span class="toc-text">1047. 删除字符串中的所有相邻重复项</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E7%9B%B4%E6%8E%A5%E6%8B%BF%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BD%9C%E4%B8%BA%E6%A0%88"><span class="toc-number">1.8.5.1.</span> <span class="toc-text">优化：直接拿字符串作为栈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95-6"><span class="toc-number">1.8.5.2.</span> <span class="toc-text">双指针法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#150-%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC"><span class="toc-number">1.8.6.</span> <span class="toc-text">150. 逆波兰表达式求值</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-number">1.8.6.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF"><span class="toc-number">1.8.6.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E5%A4%96%E8%AF%9D-2"><span class="toc-number">1.8.6.3.</span> <span class="toc-text">题外话</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#239-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="toc-number">1.8.7.</span> <span class="toc-text">239. 滑动窗口最大值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#347-%E5%89%8D-k-%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0"><span class="toc-number">1.8.8.</span> <span class="toc-text">347. 前 K 个高频元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-8"><span class="toc-number">1.8.9.</span> <span class="toc-text">总结</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%88%E7%BB%8F%E5%85%B8%E9%A2%98%E7%9B%AE"><span class="toc-number">1.8.9.1.</span> <span class="toc-text">栈 —— 经典题目</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%88%E5%9C%A8%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">1.8.9.1.1.</span> <span class="toc-text">栈在系统中的应用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D%E9%97%AE%E9%A2%9820-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7"><span class="toc-number">1.8.9.1.2.</span> <span class="toc-text">[括号匹配问题](#20. 有效的括号)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8E%BB%E9%87%8D%E9%97%AE%E9%A2%981047-%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E7%9B%B8%E9%82%BB%E9%87%8D%E5%A4%8D%E9%A1%B9"><span class="toc-number">1.8.9.1.3.</span> <span class="toc-text">[字符串去重问题](#1047. 删除字符串中的所有相邻重复项)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E9%97%AE%E9%A2%98150-%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC"><span class="toc-number">1.8.9.1.4.</span> <span class="toc-text">[逆波兰表达式问题](#150. 逆波兰表达式求值)</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%9F%E5%88%97%E7%BB%8F%E5%85%B8%E9%A2%98%E7%9B%AE"><span class="toc-number">1.8.9.2.</span> <span class="toc-text">队列 —— 经典题目</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC%E9%97%AE%E9%A2%98239-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="toc-number">1.8.9.2.1.</span> <span class="toc-text">[滑动窗口最大值问题](#239. 滑动窗口最大值)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B1%82%E5%89%8Dk%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0"><span class="toc-number">1.8.9.2.2.</span> <span class="toc-text">求前 k 个高频元素</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-2"><span class="toc-number">1.8.9.3.</span> <span class="toc-text">小结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.9.</span> <span class="toc-text">二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80"><span class="toc-number">1.9.1.</span> <span class="toc-text">二叉树的理论基础</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A7%8D%E7%B1%BB"><span class="toc-number">1.9.1.1.</span> <span class="toc-text">种类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.9.1.1.1.</span> <span class="toc-text">满二叉树</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.9.1.1.2.</span> <span class="toc-text">完全二叉树</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-number">1.9.1.1.3.</span> <span class="toc-text">二叉搜索树</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-number">1.9.1.1.4.</span> <span class="toc-text">平衡二叉搜索树</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F-2"><span class="toc-number">1.9.1.2.</span> <span class="toc-text">存储方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F"><span class="toc-number">1.9.1.3.</span> <span class="toc-text">遍历方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-number">1.9.1.4.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-9"><span class="toc-number">1.9.1.5.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86"><span class="toc-number">1.9.2.</span> <span class="toc-text">二叉树的递归遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%E9%80%92%E5%BD%92"><span class="toc-number">1.9.2.1.</span> <span class="toc-text">前序遍历（递归）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E9%80%92%E5%BD%92"><span class="toc-number">1.9.2.2.</span> <span class="toc-text">中序遍历（递归）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E9%80%92%E5%BD%92"><span class="toc-number">1.9.2.3.</span> <span class="toc-text">后序遍历（递归）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%86"><span class="toc-number">1.9.3.</span> <span class="toc-text">二叉树的迭代遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%E8%BF%AD%E4%BB%A3"><span class="toc-number">1.9.3.1.</span> <span class="toc-text">前序遍历（迭代）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E8%BF%AD%E4%BB%A3"><span class="toc-number">1.9.3.2.</span> <span class="toc-text">中序遍历（迭代）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8E%E7%BB%AD%E9%81%8D%E5%8E%86%E8%BF%AD%E4%BB%A3"><span class="toc-number">1.9.3.3.</span> <span class="toc-text">后续遍历（迭代）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-10"><span class="toc-number">1.9.3.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%BB%9F%E4%B8%80%E8%BF%AD%E4%BB%A3%E6%B3%95"><span class="toc-number">1.9.4.</span> <span class="toc-text">☆二叉树的统一迭代法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E7%BB%9F%E4%B8%80%E8%BF%AD%E4%BB%A3"><span class="toc-number">1.9.4.1.</span> <span class="toc-text">中序遍历（统一迭代）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%E7%BB%9F%E4%B8%80%E8%BF%AD%E4%BB%A3"><span class="toc-number">1.9.4.2.</span> <span class="toc-text">前序遍历（统一迭代）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8E%E7%BB%AD%E9%81%8D%E5%8E%86%E7%BB%9F%E4%B8%80%E8%BF%AD%E4%BB%A3"><span class="toc-number">1.9.4.3.</span> <span class="toc-text">后续遍历（统一迭代）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-11"><span class="toc-number">1.9.4.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#102-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">1.9.5.</span> <span class="toc-text">102. 二叉树的层序遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%80%9F%E5%8A%A9%E9%98%9F%E5%88%97"><span class="toc-number">1.9.5.1.</span> <span class="toc-text">迭代（借助队列）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%BD%92"><span class="toc-number">1.9.5.2.</span> <span class="toc-text">递归</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#226-%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.9.6.</span> <span class="toc-text">226. 翻转二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E5%A4%96%E8%AF%9D-3"><span class="toc-number">1.9.6.1.</span> <span class="toc-text">题外话</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-2"><span class="toc-number">1.9.6.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E6%B3%95-2"><span class="toc-number">1.9.6.3.</span> <span class="toc-text">递归法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E6%B3%95"><span class="toc-number">1.9.6.4.</span> <span class="toc-text">迭代法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86"><span class="toc-number">1.9.6.4.1.</span> <span class="toc-text">深度优先遍历</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86"><span class="toc-number">1.9.6.4.2.</span> <span class="toc-text">广度优先遍历</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%93%E5%B1%95-2"><span class="toc-number">1.9.6.5.</span> <span class="toc-text">拓展</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-12"><span class="toc-number">1.9.6.6.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%AC%E5%91%A8%E5%B0%8F%E7%BB%93"><span class="toc-number">1.9.7.</span> <span class="toc-text">本周小结</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%A8%E4%B8%80"><span class="toc-number">1.9.7.1.</span> <span class="toc-text">周一</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%A8%E4%BA%8C"><span class="toc-number">1.9.7.2.</span> <span class="toc-text">周二</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%A8%E4%B8%89"><span class="toc-number">1.9.7.3.</span> <span class="toc-text">周三</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%A8%E5%9B%9B"><span class="toc-number">1.9.7.4.</span> <span class="toc-text">周四</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%A8%E4%BA%94"><span class="toc-number">1.9.7.5.</span> <span class="toc-text">周五</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%A8%E5%85%AD"><span class="toc-number">1.9.7.6.</span> <span class="toc-text">周六</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-3"><span class="toc-number">1.9.7.7.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#101-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.9.8.</span> <span class="toc-text">101. 对称二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E6%B3%95-3"><span class="toc-number">1.9.8.1.</span> <span class="toc-text">√递归法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E6%B3%95-2"><span class="toc-number">1.9.8.2.</span> <span class="toc-text">迭代法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E9%98%9F%E5%88%97"><span class="toc-number">1.9.8.2.1.</span> <span class="toc-text">使用队列</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%A0%88"><span class="toc-number">1.9.8.2.2.</span> <span class="toc-text">使用栈</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-13"><span class="toc-number">1.9.8.3.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE%E6%8E%A8%E8%8D%90"><span class="toc-number">1.9.8.4.</span> <span class="toc-text">相关题目推荐</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6"><span class="toc-number">1.9.9.</span> <span class="toc-text">104. 二叉树的最大深度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%BD%92-2"><span class="toc-number">1.9.9.1.</span> <span class="toc-text">递归</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#u%E5%90%8E%E5%BA%8Fu%E9%81%8D%E5%8E%86%E8%AE%A1%E7%AE%97%E6%A0%B9%E8%8A%82%E7%82%B9%E7%9A%84%E9%AB%98%E5%BA%A6"><span class="toc-number">1.9.9.1.1.</span> <span class="toc-text">后序遍历：计算根节点的高度</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#u%E5%89%8D%E5%BA%8Fu%E9%81%8D%E5%8E%86%E8%AE%A1%E7%AE%97%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6"><span class="toc-number">1.9.9.1.2.</span> <span class="toc-text">前序遍历：计算最大深度</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">1.9.9.2.</span> <span class="toc-text">迭代（层序遍历）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#559-n-%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6"><span class="toc-number">1.9.10.</span> <span class="toc-text">559. N 叉树的最大深度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">1.9.10.1.</span> <span class="toc-text">递归（后序遍历）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86-2"><span class="toc-number">1.9.10.2.</span> <span class="toc-text">迭代（层序遍历）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#111-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6"><span class="toc-number">1.9.11.</span> <span class="toc-text">111. 二叉树的最小深度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86-2"><span class="toc-number">1.9.11.1.</span> <span class="toc-text">递归（后序遍历）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86-3"><span class="toc-number">1.9.11.2.</span> <span class="toc-text">迭代（层序遍历）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#222-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0"><span class="toc-number">1.9.12.</span> <span class="toc-text">222. 完全二叉树的节点个数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.9.12.1.</span> <span class="toc-text">普通二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86-3"><span class="toc-number">1.9.12.1.1.</span> <span class="toc-text">递归（后序遍历）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86-4"><span class="toc-number">1.9.12.1.2.</span> <span class="toc-text">迭代（层序遍历）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E9%80%92%E5%BD%92%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">1.9.12.2.</span> <span class="toc-text">完全二叉树（递归（后序遍历））</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#110-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.9.13.</span> <span class="toc-text">☆110. 平衡二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-14"><span class="toc-number">1.9.13.1.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#257-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84"><span class="toc-number">1.9.14.</span> <span class="toc-text">☆257. 二叉树的所有路径</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%BD%92-3"><span class="toc-number">1.9.14.1.</span> <span class="toc-text">递归</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%AC%E5%91%A8%E5%B0%8F%E7%BB%93-2"><span class="toc-number">1.9.15.</span> <span class="toc-text">本周小结</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%A8%E4%B8%80-2"><span class="toc-number">1.9.15.1.</span> <span class="toc-text">周一</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%A8%E4%BA%8C-2"><span class="toc-number">1.9.15.2.</span> <span class="toc-text">周二</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%A8%E4%B8%89-2"><span class="toc-number">1.9.15.3.</span> <span class="toc-text">周三</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%A8%E5%9B%9B-2"><span class="toc-number">1.9.15.4.</span> <span class="toc-text">周四</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%A8%E4%BA%94-2"><span class="toc-number">1.9.15.5.</span> <span class="toc-text">周五</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%A8%E5%85%AD-2"><span class="toc-number">1.9.15.6.</span> <span class="toc-text">周六</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-4"><span class="toc-number">1.9.15.7.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#404-%E5%B7%A6%E5%8F%B6%E5%AD%90%E4%B9%8B%E5%92%8C"><span class="toc-number">1.9.16.</span> <span class="toc-text">404. 左叶子之和</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%BD%92-4"><span class="toc-number">1.9.16.1.</span> <span class="toc-text">递归</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3"><span class="toc-number">1.9.16.2.</span> <span class="toc-text">迭代</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-15"><span class="toc-number">1.9.16.3.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#513-%E6%89%BE%E6%A0%91%E5%B7%A6%E4%B8%8B%E8%A7%92%E7%9A%84%E5%80%BC"><span class="toc-number">1.9.17.</span> <span class="toc-text">513. 找树左下角的值</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E5%89%8D%E5%BA%8F"><span class="toc-number">1.9.17.1.</span> <span class="toc-text">递归（前序）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86-5"><span class="toc-number">1.9.17.2.</span> <span class="toc-text">√迭代（层序遍历）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-16"><span class="toc-number">1.9.17.3.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#112-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C"><span class="toc-number">1.9.18.</span> <span class="toc-text">☆112. 路径总和</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%BD%92-5"><span class="toc-number">1.9.18.1.</span> <span class="toc-text">递归</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3-2"><span class="toc-number">1.9.18.2.</span> <span class="toc-text">迭代</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#113-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C-ii"><span class="toc-number">1.9.18.3.</span> <span class="toc-text">113. 路径总和 II</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-17"><span class="toc-number">1.9.18.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#106-%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.9.19.</span> <span class="toc-text">106. 从中序与后序遍历序列构造二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%89%B2%E6%96%B9%E5%BC%8F%E5%88%9B%E5%BB%BA%E6%96%B0%E6%95%B0%E7%BB%84"><span class="toc-number">1.9.19.1.</span> <span class="toc-text">分割方式：创建新数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%89%B2%E6%96%B9%E5%BC%8F%E4%B8%8B%E6%A0%87%E7%B4%A2%E5%BC%95"><span class="toc-number">1.9.19.2.</span> <span class="toc-text">分割方式：下标索引</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#105-%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.9.20.</span> <span class="toc-text">105. 从前序与中序遍历序列构造二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%89%B2%E6%96%B9%E5%BC%8F%E5%88%9B%E5%BB%BA%E6%96%B0%E6%95%B0%E7%BB%84-2"><span class="toc-number">1.9.20.1.</span> <span class="toc-text">分割方式：创建新数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%89%B2%E6%96%B9%E5%BC%8F%E4%B8%8B%E6%A0%87%E7%B4%A2%E5%BC%95-2"><span class="toc-number">1.9.20.2.</span> <span class="toc-text">分割方式：下标索引</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#654-%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.9.21.</span> <span class="toc-text">654. 最大二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%89%B2%E6%96%B9%E5%BC%8F%E5%88%9B%E5%BB%BA%E6%96%B0%E6%95%B0%E7%BB%84-3"><span class="toc-number">1.9.21.1.</span> <span class="toc-text">分割方式：创建新数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%89%B2%E6%96%B9%E5%BC%8F%E4%B8%8B%E6%A0%87%E7%B4%A2%E5%BC%95-3"><span class="toc-number">1.9.21.2.</span> <span class="toc-text">分割方式：下标索引</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%AC%E5%91%A8%E5%B0%8F%E7%BB%93-3"><span class="toc-number">1.9.22.</span> <span class="toc-text">本周小结</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%A8%E4%B8%80-3"><span class="toc-number">1.9.22.1.</span> <span class="toc-text">周一</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%A8%E4%BA%8C-3"><span class="toc-number">1.9.22.2.</span> <span class="toc-text">周二</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%A8%E4%B8%89-3"><span class="toc-number">1.9.22.3.</span> <span class="toc-text">周三</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%A8%E5%9B%9B-3"><span class="toc-number">1.9.22.4.</span> <span class="toc-text">周四</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%A8%E4%BA%94-3"><span class="toc-number">1.9.22.5.</span> <span class="toc-text">周五</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%A8%E5%85%AD-3"><span class="toc-number">1.9.22.6.</span> <span class="toc-text">周六</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-5"><span class="toc-number">1.9.22.7.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#617-%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.9.23.</span> <span class="toc-text">617. 合并二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%BD%92-6"><span class="toc-number">1.9.23.1.</span> <span class="toc-text">√递归</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3-3"><span class="toc-number">1.9.23.2.</span> <span class="toc-text">迭代</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-18"><span class="toc-number">1.9.23.3.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#700-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2"><span class="toc-number">1.9.24.</span> <span class="toc-text">700. 二叉搜索树中的搜索</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%BD%92-7"><span class="toc-number">1.9.24.1.</span> <span class="toc-text">递归</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3-4"><span class="toc-number">1.9.24.2.</span> <span class="toc-text">迭代</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-19"><span class="toc-number">1.9.24.3.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#98-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-number">1.9.25.</span> <span class="toc-text">98. 验证二叉搜索树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%BD%92-8"><span class="toc-number">1.9.25.1.</span> <span class="toc-text">递归</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BD%AC%E4%B8%BA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84"><span class="toc-number">1.9.25.1.1.</span> <span class="toc-text">√转为有序数组</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%89%8D-%E5%90%8E%E5%8F%8C%E6%8C%87%E9%92%88"><span class="toc-number">1.9.25.1.2.</span> <span class="toc-text">前、后双指针</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3-5"><span class="toc-number">1.9.25.2.</span> <span class="toc-text">迭代</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-20"><span class="toc-number">1.9.25.3.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#530-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%B7%AE"><span class="toc-number">1.9.26.</span> <span class="toc-text">530. 二叉搜索树的最小绝对差</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%BD%92-9"><span class="toc-number">1.9.26.1.</span> <span class="toc-text">递归</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BD%AC%E4%B8%BA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84-2"><span class="toc-number">1.9.26.1.1.</span> <span class="toc-text">√转为有序数组</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%89%8D-%E5%90%8E%E5%8F%8C%E6%8C%87%E9%92%88-2"><span class="toc-number">1.9.26.1.2.</span> <span class="toc-text">√前、后双指针</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3-6"><span class="toc-number">1.9.26.2.</span> <span class="toc-text">迭代</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-21"><span class="toc-number">1.9.26.3.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#501-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E4%BC%97%E6%95%B0"><span class="toc-number">1.9.27.</span> <span class="toc-text">501. 二叉搜索树中的众数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E6%B3%95-4"><span class="toc-number">1.9.27.1.</span> <span class="toc-text">递归法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%8D%E6%98%AF%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-number">1.9.27.1.1.</span> <span class="toc-text">√不是二叉搜索树</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%98%AF%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-number">1.9.27.1.2.</span> <span class="toc-text">是二叉搜索树</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3-7"><span class="toc-number">1.9.27.2.</span> <span class="toc-text">迭代</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-22"><span class="toc-number">1.9.27.3.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#236-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="toc-number">1.9.28.</span> <span class="toc-text">236. 二叉树的最近公共祖先</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86-4"><span class="toc-number">1.9.28.1.</span> <span class="toc-text">递归（后序遍历）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-23"><span class="toc-number">1.9.28.2.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%AC%E5%91%A8%E5%B0%8F%E7%BB%93-4"><span class="toc-number">1.9.29.</span> <span class="toc-text">本周小结</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%A8%E4%B8%80-4"><span class="toc-number">1.9.29.1.</span> <span class="toc-text">周一</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%A8%E4%BA%8C-4"><span class="toc-number">1.9.29.2.</span> <span class="toc-text">周二</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%A8%E4%B8%89-4"><span class="toc-number">1.9.29.3.</span> <span class="toc-text">周三</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%A8%E5%9B%9B-4"><span class="toc-number">1.9.29.4.</span> <span class="toc-text">周四</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%A8%E4%BA%94-4"><span class="toc-number">1.9.29.5.</span> <span class="toc-text">周五</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%A8%E5%85%AD-4"><span class="toc-number">1.9.29.6.</span> <span class="toc-text">周六</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-6"><span class="toc-number">1.9.29.7.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#235-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="toc-number">1.9.30.</span> <span class="toc-text">235. 二叉搜索树的最近公共祖先</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%BD%92-10"><span class="toc-number">1.9.30.1.</span> <span class="toc-text">递归</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3-8"><span class="toc-number">1.9.30.2.</span> <span class="toc-text">迭代</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-7"><span class="toc-number">1.9.30.3.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#701-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C"><span class="toc-number">1.9.31.</span> <span class="toc-text">701. 二叉搜索树中的插入操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%BD%92-11"><span class="toc-number">1.9.31.1.</span> <span class="toc-text">√递归</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%89%8D-%E5%90%8E%E5%8F%8C%E6%8C%87%E9%92%88"><span class="toc-number">1.9.31.2.</span> <span class="toc-text">迭代（前、后双指针）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-24"><span class="toc-number">1.9.31.3.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#450-%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9"><span class="toc-number">1.9.32.</span> <span class="toc-text">450. 删除二叉搜索树中的节点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%BD%92-12"><span class="toc-number">1.9.32.1.</span> <span class="toc-text">递归</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-25"><span class="toc-number">1.9.32.2.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#669-%E4%BF%AE%E5%89%AA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-number">1.9.33.</span> <span class="toc-text">669. 修剪二叉搜索树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%BD%92-13"><span class="toc-number">1.9.33.1.</span> <span class="toc-text">递归</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%AF%E5%8C%BA"><span class="toc-number">1.9.33.1.1.</span> <span class="toc-text">误区</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AD%A3%E7%A1%AE%E6%80%9D%E8%B7%AF"><span class="toc-number">1.9.33.1.2.</span> <span class="toc-text">正确思路</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-26"><span class="toc-number">1.9.33.2.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#108-%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-number">1.9.34.</span> <span class="toc-text">108. 将有序数组转换为二叉搜索树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%BD%92-14"><span class="toc-number">1.9.34.1.</span> <span class="toc-text">递归</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-27"><span class="toc-number">1.9.34.2.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#538-%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%B4%AF%E5%8A%A0%E6%A0%91"><span class="toc-number">1.9.35.</span> <span class="toc-text">538. 把二叉搜索树转换为累加树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%BD%92-15"><span class="toc-number">1.9.35.1.</span> <span class="toc-text">递归</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3-9"><span class="toc-number">1.9.35.2.</span> <span class="toc-text">迭代</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E6%80%BB%E7%BB%93%E7%AF%87"><span class="toc-number">1.9.36.</span> <span class="toc-text">二叉树总结篇</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80-2"><span class="toc-number">1.9.36.1.</span> <span class="toc-text">二叉树的理论基础</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F"><span class="toc-number">1.9.36.2.</span> <span class="toc-text">二叉树的遍历方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B1%82%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="toc-number">1.9.36.3.</span> <span class="toc-text">求二叉树的属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%BF%AE%E6%94%B9%E4%B8%8E%E6%9E%84%E9%80%A0"><span class="toc-number">1.9.36.4.</span> <span class="toc-text">二叉树的修改与构造</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B1%82bst%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="toc-number">1.9.36.5.</span> <span class="toc-text">求 BST 的属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88%E9%97%AE%E9%A2%98"><span class="toc-number">1.9.36.6.</span> <span class="toc-text">二叉树公共祖先问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#bst%E7%9A%84%E4%BF%AE%E6%94%B9%E4%B8%8E%E6%9E%84%E9%80%A0"><span class="toc-number">1.9.36.7.</span> <span class="toc-text">BST 的修改与构造</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E5%90%8E%E6%80%BB%E7%BB%93"><span class="toc-number">1.9.36.8.</span> <span class="toc-text">最后总结！</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95"><span class="toc-number">1.10.</span> <span class="toc-text">回溯算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80"><span class="toc-number">1.10.1.</span> <span class="toc-text">回溯算法理论基础</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%9B%9E%E6%BA%AF"><span class="toc-number">1.10.1.1.</span> <span class="toc-text">什么是回溯</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF%E6%B3%95%E7%9A%84%E6%95%88%E7%8E%87"><span class="toc-number">1.10.1.2.</span> <span class="toc-text">回溯法的效率</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF%E6%B3%95%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">1.10.1.3.</span> <span class="toc-text">回溯法解决的问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E5%9B%9E%E6%BA%AF%E6%B3%95"><span class="toc-number">1.10.1.4.</span> <span class="toc-text">如何理解回溯法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF%E6%B3%95%E6%A8%A1%E6%9D%BF"><span class="toc-number">1.10.1.5.</span> <span class="toc-text">回溯法模板</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-28"><span class="toc-number">1.10.1.6.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#77-%E7%BB%84%E5%90%88"><span class="toc-number">1.10.2.</span> <span class="toc-text">77. 组合</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-3"><span class="toc-number">1.10.2.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF%E4%B8%89%E9%83%A8%E6%9B%B2"><span class="toc-number">1.10.2.2.</span> <span class="toc-text">回溯三部曲</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-29"><span class="toc-number">1.10.2.3.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#77-%E7%BB%84%E5%90%88%E4%BC%98%E5%8C%96"><span class="toc-number">1.10.3.</span> <span class="toc-text">77. 组合优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%AA%E6%9E%9D%E4%BC%98%E5%8C%96"><span class="toc-number">1.10.3.1.</span> <span class="toc-text">剪枝优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-30"><span class="toc-number">1.10.3.2.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#216-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-iii"><span class="toc-number">1.10.4.</span> <span class="toc-text">216. 组合总和 III</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-4"><span class="toc-number">1.10.4.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF%E4%B8%89%E9%83%A8%E6%9B%B2-2"><span class="toc-number">1.10.4.2.</span> <span class="toc-text">回溯三部曲</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%AA%E6%9E%9D"><span class="toc-number">1.10.4.3.</span> <span class="toc-text">剪枝</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-31"><span class="toc-number">1.10.4.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88"><span class="toc-number">1.10.5.</span> <span class="toc-text">17. 电话号码的字母组合</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-5"><span class="toc-number">1.10.5.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E5%AD%97%E5%92%8C%E5%AD%97%E6%AF%8D%E5%A6%82%E4%BD%95%E6%98%A0%E5%B0%84"><span class="toc-number">1.10.5.2.</span> <span class="toc-text">数字和字母如何映射</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF%E6%B3%95%E6%9D%A5%E8%A7%A3%E5%86%B3n%E4%B8%AAfor%E5%BE%AA%E7%8E%AF%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">1.10.5.3.</span> <span class="toc-text">回溯法来解决 n 个 for 循环的问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-32"><span class="toc-number">1.10.5.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF%E5%91%A8%E6%9C%AB%E6%80%BB%E7%BB%93"><span class="toc-number">1.10.6.</span> <span class="toc-text">回溯周末总结</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%A8%E4%B8%80-5"><span class="toc-number">1.10.6.1.</span> <span class="toc-text">周一</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%A8%E4%BA%8C-5"><span class="toc-number">1.10.6.2.</span> <span class="toc-text">周二</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%A8%E4%B8%89-5"><span class="toc-number">1.10.6.3.</span> <span class="toc-text">周三</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%A8%E5%9B%9B-5"><span class="toc-number">1.10.6.4.</span> <span class="toc-text">周四</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%A8%E4%BA%94-5"><span class="toc-number">1.10.6.5.</span> <span class="toc-text">周五</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%A8%E5%85%AD-5"><span class="toc-number">1.10.6.6.</span> <span class="toc-text">周六</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-33"><span class="toc-number">1.10.6.7.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#39-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C"><span class="toc-number">1.10.7.</span> <span class="toc-text">39. 组合总和</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF%E4%B8%89%E9%83%A8%E6%9B%B2-3"><span class="toc-number">1.10.7.1.</span> <span class="toc-text">回溯三部曲</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%AA%E6%9E%9D%E4%BC%98%E5%8C%96-2"><span class="toc-number">1.10.7.2.</span> <span class="toc-text">剪枝优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-34"><span class="toc-number">1.10.7.3.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#40-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-ii"><span class="toc-number">1.10.8.</span> <span class="toc-text">40. 组合总和 II</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-6"><span class="toc-number">1.10.8.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF%E4%B8%89%E9%83%A8%E6%9B%B2-4"><span class="toc-number">1.10.8.2.</span> <span class="toc-text">回溯三部曲</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-35"><span class="toc-number">1.10.8.3.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#131-%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2"><span class="toc-number">1.10.9.</span> <span class="toc-text">☆131. 分割回文串</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-7"><span class="toc-number">1.10.9.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF%E4%B8%89%E9%83%A8%E6%9B%B2-5"><span class="toc-number">1.10.9.2.</span> <span class="toc-text">回溯三部曲</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2"><span class="toc-number">1.10.9.3.</span> <span class="toc-text">判断回文子串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#java%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81"><span class="toc-number">1.10.9.4.</span> <span class="toc-text">java 完整代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-number">1.10.9.5.</span> <span class="toc-text">优化：动态规划</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-36"><span class="toc-number">1.10.9.6.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#93-%E5%A4%8D%E5%8E%9F-ip-%E5%9C%B0%E5%9D%80"><span class="toc-number">1.10.10.</span> <span class="toc-text">☆93. 复原 IP 地址</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF%E4%B8%89%E9%83%A8%E6%9B%B2-6"><span class="toc-number">1.10.10.1.</span> <span class="toc-text">回溯三部曲</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E5%AD%90%E4%B8%B2%E6%98%AF%E5%90%A6%E5%90%88%E6%B3%95"><span class="toc-number">1.10.10.2.</span> <span class="toc-text">判断子串是否合法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#java%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81-2"><span class="toc-number">1.10.10.3.</span> <span class="toc-text">java 完整代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-37"><span class="toc-number">1.10.10.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#78-%E5%AD%90%E9%9B%86"><span class="toc-number">1.10.11.</span> <span class="toc-text">78. 子集</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-8"><span class="toc-number">1.10.11.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF%E4%B8%89%E9%83%A8%E6%9B%B2-7"><span class="toc-number">1.10.11.2.</span> <span class="toc-text">回溯三部曲</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#java%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81-3"><span class="toc-number">1.10.11.3.</span> <span class="toc-text">java 完整代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-38"><span class="toc-number">1.10.11.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%AC%E5%91%A8%E5%B0%8F%E7%BB%93%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97%E4%BA%8C"><span class="toc-number">1.10.12.</span> <span class="toc-text">本周小结！（回溯算法系列二）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%A8%E4%B8%80-6"><span class="toc-number">1.10.12.1.</span> <span class="toc-text">周一</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%A8%E4%BA%8C-6"><span class="toc-number">1.10.12.2.</span> <span class="toc-text">周二</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%A8%E4%B8%89-6"><span class="toc-number">1.10.12.3.</span> <span class="toc-text">周三</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%A8%E5%9B%9B-6"><span class="toc-number">1.10.12.4.</span> <span class="toc-text">周四</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%A8%E4%BA%94-6"><span class="toc-number">1.10.12.5.</span> <span class="toc-text">周五</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-39"><span class="toc-number">1.10.12.6.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#90-%E5%AD%90%E9%9B%86-ii"><span class="toc-number">1.10.13.</span> <span class="toc-text">90. 子集 II</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%A5%E5%85%85-2"><span class="toc-number">1.10.13.1.</span> <span class="toc-text">补充</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-40"><span class="toc-number">1.10.13.2.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#491-%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">1.10.14.</span> <span class="toc-text">491. 递增子序列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-9"><span class="toc-number">1.10.14.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF%E4%B8%89%E9%83%A8%E6%9B%B2-8"><span class="toc-number">1.10.14.2.</span> <span class="toc-text">回溯三部曲</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%8C%96-2"><span class="toc-number">1.10.14.3.</span> <span class="toc-text">优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-41"><span class="toc-number">1.10.14.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#46-%E5%85%A8%E6%8E%92%E5%88%97"><span class="toc-number">1.10.15.</span> <span class="toc-text">46. 全排列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF%E4%B8%89%E9%83%A8%E6%9B%B2-9"><span class="toc-number">1.10.15.1.</span> <span class="toc-text">回溯三部曲</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-42"><span class="toc-number">1.10.15.2.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#47-%E5%85%A8%E6%8E%92%E5%88%97-ii"><span class="toc-number">1.10.16.</span> <span class="toc-text">47. 全排列 II</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-10"><span class="toc-number">1.10.16.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%93%E5%B1%95-3"><span class="toc-number">1.10.16.2.</span> <span class="toc-text">拓展</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%AC%E5%91%A8%E5%B0%8F%E7%BB%93%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97%E4%B8%89"><span class="toc-number">1.10.17.</span> <span class="toc-text">本周小结！（回溯算法系列三）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%A8%E4%B8%80-7"><span class="toc-number">1.10.17.1.</span> <span class="toc-text">周一</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%A8%E4%BA%8C-7"><span class="toc-number">1.10.17.2.</span> <span class="toc-text">周二</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%A8%E4%B8%89-7"><span class="toc-number">1.10.17.3.</span> <span class="toc-text">周三</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%A8%E5%9B%9B-7"><span class="toc-number">1.10.17.4.</span> <span class="toc-text">周四</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90"><span class="toc-number">1.10.17.5.</span> <span class="toc-text">性能分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-43"><span class="toc-number">1.10.17.6.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#332-%E9%87%8D%E6%96%B0%E5%AE%89%E6%8E%92%E8%A1%8C%E7%A8%8B"><span class="toc-number">1.10.18.</span> <span class="toc-text">☆332. 重新安排行程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-11"><span class="toc-number">1.10.18.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E6%AD%BB%E5%BE%AA%E7%8E%AF"><span class="toc-number">1.10.18.2.</span> <span class="toc-text">如何理解死循环</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%AE%B0%E5%BD%95%E6%98%A0%E5%B0%84%E5%85%B3%E7%B3%BB"><span class="toc-number">1.10.18.3.</span> <span class="toc-text">如何记录映射关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF%E4%B8%89%E9%83%A8%E6%9B%B2-10"><span class="toc-number">1.10.18.4.</span> <span class="toc-text">回溯三部曲</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-44"><span class="toc-number">1.10.18.5.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#51-n-%E7%9A%87%E5%90%8E"><span class="toc-number">1.10.19.</span> <span class="toc-text">☆51. N 皇后</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-12"><span class="toc-number">1.10.19.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF%E4%B8%89%E9%83%A8%E6%9B%B2-11"><span class="toc-number">1.10.19.2.</span> <span class="toc-text">回溯三部曲</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%AA%8C%E8%AF%81%E6%A3%8B%E7%9B%98%E6%98%AF%E5%90%A6%E5%90%88%E6%B3%95"><span class="toc-number">1.10.19.3.</span> <span class="toc-text">验证棋盘是否合法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%8C%E6%95%B4%E7%9A%84java%E4%BB%A3%E7%A0%81"><span class="toc-number">1.10.19.4.</span> <span class="toc-text">完整的 Java 代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-45"><span class="toc-number">1.10.19.5.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#37-%E8%A7%A3%E6%95%B0%E7%8B%AC"><span class="toc-number">1.10.20.</span> <span class="toc-text">☆37. 解数独</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF%E4%B8%89%E9%83%A8%E6%9B%B2-12"><span class="toc-number">1.10.20.1.</span> <span class="toc-text">回溯三部曲</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E6%A3%8B%E7%9B%98%E6%98%AF%E5%90%A6%E5%90%88%E6%B3%95"><span class="toc-number">1.10.20.2.</span> <span class="toc-text">判断棋盘是否合法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%8C%E6%95%B4%E7%9A%84java%E4%BB%A3%E7%A0%81-2"><span class="toc-number">1.10.20.3.</span> <span class="toc-text">完整的 Java 代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-46"><span class="toc-number">1.10.20.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF%E6%B3%95%E6%80%BB%E7%BB%93%E7%AF%87"><span class="toc-number">1.10.21.</span> <span class="toc-text">回溯法总结篇</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E9%97%AE%E9%A2%98"><span class="toc-number">1.10.21.1.</span> <span class="toc-text">组合问题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E9%97%AE%E9%A2%98-2"><span class="toc-number">1.10.21.1.1.</span> <span class="toc-text">组合问题</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C"><span class="toc-number">1.10.21.1.2.</span> <span class="toc-text">组合总和</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%E4%B8%80"><span class="toc-number">1.10.21.1.2.1.</span> <span class="toc-text">组合总和（一）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%E4%BA%8C"><span class="toc-number">1.10.21.1.2.2.</span> <span class="toc-text">组合总和（二）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%E4%B8%89"><span class="toc-number">1.10.21.1.2.3.</span> <span class="toc-text">组合总和（三）</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%9A%E4%B8%AA%E9%9B%86%E5%90%88%E6%B1%82%E7%BB%84%E5%90%88"><span class="toc-number">1.10.21.1.3.</span> <span class="toc-text">多个集合求组合</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%87%E5%89%B2%E9%97%AE%E9%A2%98"><span class="toc-number">1.10.21.2.</span> <span class="toc-text">切割问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%90%E9%9B%86%E9%97%AE%E9%A2%98"><span class="toc-number">1.10.21.3.</span> <span class="toc-text">子集问题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%90%E9%9B%86%E9%97%AE%E9%A2%98%E4%B8%80"><span class="toc-number">1.10.21.3.1.</span> <span class="toc-text">子集问题（一）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%90%E9%9B%86%E9%97%AE%E9%A2%98%E4%BA%8C"><span class="toc-number">1.10.21.3.2.</span> <span class="toc-text">子集问题（二）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">1.10.21.3.3.</span> <span class="toc-text">递增子序列</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98"><span class="toc-number">1.10.21.4.</span> <span class="toc-text">排列问题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98%E4%B8%80"><span class="toc-number">1.10.21.4.1.</span> <span class="toc-text">排列问题（一）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98%E4%BA%8C"><span class="toc-number">1.10.21.4.2.</span> <span class="toc-text">排列问题（二）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A3%8B%E7%9B%98%E9%97%AE%E9%A2%98"><span class="toc-number">1.10.21.5.</span> <span class="toc-text">棋盘问题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#n%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98"><span class="toc-number">1.10.21.5.1.</span> <span class="toc-text">N 皇后问题</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%A3%E6%95%B0%E7%8B%AC%E9%97%AE%E9%A2%98"><span class="toc-number">1.10.21.5.2.</span> <span class="toc-text">解数独问题</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%BB%E9%87%8D%E9%97%AE%E9%A2%98"><span class="toc-number">1.10.21.6.</span> <span class="toc-text">去重问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E6%96%B0%E5%AE%89%E6%8E%92%E8%A1%8C%E7%A8%8B%E5%9B%BE%E8%AE%BA%E9%A2%9D%E5%A4%96%E6%8B%93%E5%B1%95"><span class="toc-number">1.10.21.7.</span> <span class="toc-text">重新安排行程（图论额外拓展）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90-2"><span class="toc-number">1.10.21.8.</span> <span class="toc-text">性能分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-47"><span class="toc-number">1.10.21.9.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95"><span class="toc-number">1.11.</span> <span class="toc-text">贪心算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80"><span class="toc-number">1.11.1.</span> <span class="toc-text">贪心算法理论基础</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B4%AA%E5%BF%83%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">1.11.1.1.</span> <span class="toc-text">贪心的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8%E8%B4%AA%E5%BF%83"><span class="toc-number">1.11.1.2.</span> <span class="toc-text">什么时候用贪心</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E8%A7%A3%E9%A2%98%E6%AD%A5%E9%AA%A4"><span class="toc-number">1.11.1.3.</span> <span class="toc-text">贪心算法解题步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-48"><span class="toc-number">1.11.1.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#455-%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2"><span class="toc-number">1.11.2.</span> <span class="toc-text">455. 分发饼干</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-49"><span class="toc-number">1.11.2.1.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#376-%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97"><span class="toc-number">1.11.3.</span> <span class="toc-text">376. 摆动序列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95-2"><span class="toc-number">1.11.3.1.</span> <span class="toc-text">贪心算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-50"><span class="toc-number">1.11.3.2.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#53-%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C"><span class="toc-number">1.11.4.</span> <span class="toc-text">53. 最大子数组和</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9A%B4%E5%8A%9B%E8%A7%A3%E6%B3%95-5"><span class="toc-number">1.11.4.1.</span> <span class="toc-text">暴力解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B4%AA%E5%BF%83%E8%A7%A3%E6%B3%95"><span class="toc-number">1.11.4.2.</span> <span class="toc-text">贪心解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-51"><span class="toc-number">1.11.4.3.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B4%AA%E5%BF%83%E5%91%A8%E6%80%BB%E7%BB%93%E4%B8%80"><span class="toc-number">1.11.5.</span> <span class="toc-text">贪心周总结一</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%A8%E4%B8%80-8"><span class="toc-number">1.11.5.1.</span> <span class="toc-text">周一</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%A8%E4%BA%8C-8"><span class="toc-number">1.11.5.2.</span> <span class="toc-text">周二</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%A8%E4%B8%89-8"><span class="toc-number">1.11.5.3.</span> <span class="toc-text">周三</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%A8%E5%9B%9B-8"><span class="toc-number">1.11.5.4.</span> <span class="toc-text">周四</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-52"><span class="toc-number">1.11.5.5.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#122-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-ii"><span class="toc-number">1.11.6.</span> <span class="toc-text">122. 买卖股票的最佳时机 II</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-13"><span class="toc-number">1.11.6.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B4%AA%E5%BF%83%E8%A7%A3%E6%B3%95-2"><span class="toc-number">1.11.6.2.</span> <span class="toc-text">贪心解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-53"><span class="toc-number">1.11.6.3.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#55-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F"><span class="toc-number">1.11.7.</span> <span class="toc-text">55. 跳跃游戏</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-14"><span class="toc-number">1.11.7.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-54"><span class="toc-number">1.11.7.2.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#45-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F-ii"><span class="toc-number">1.11.8.</span> <span class="toc-text">☆45. 跳跃游戏 II</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-15"><span class="toc-number">1.11.8.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80"><span class="toc-number">1.11.8.2.</span> <span class="toc-text">方法一</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C"><span class="toc-number">1.11.8.3.</span> <span class="toc-text">√方法二</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-55"><span class="toc-number">1.11.8.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1005-k-%E6%AC%A1%E5%8F%96%E5%8F%8D%E5%90%8E%E6%9C%80%E5%A4%A7%E5%8C%96%E7%9A%84%E6%95%B0%E7%BB%84%E5%92%8C"><span class="toc-number">1.11.9.</span> <span class="toc-text">1005. K 次取反后最大化的数组和</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-16"><span class="toc-number">1.11.9.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-56"><span class="toc-number">1.11.9.2.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B4%AA%E5%BF%83%E5%91%A8%E6%80%BB%E7%BB%93%E4%BA%8C"><span class="toc-number">1.11.10.</span> <span class="toc-text">贪心周总结二</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%A8%E4%B8%80-9"><span class="toc-number">1.11.10.1.</span> <span class="toc-text">周一</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%A8%E4%BA%8C-9"><span class="toc-number">1.11.10.2.</span> <span class="toc-text">周二</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%A8%E4%B8%89-9"><span class="toc-number">1.11.10.3.</span> <span class="toc-text">周三</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%A8%E5%9B%9B-9"><span class="toc-number">1.11.10.4.</span> <span class="toc-text">周四</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-57"><span class="toc-number">1.11.10.5.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#134-%E5%8A%A0%E6%B2%B9%E7%AB%99"><span class="toc-number">1.11.11.</span> <span class="toc-text">☆134. 加油站</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9A%B4%E5%8A%9B%E8%A7%A3%E6%B3%95-6"><span class="toc-number">1.11.11.1.</span> <span class="toc-text">暴力解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B4%AA%E5%BF%83%E8%A7%A3%E6%B3%95%E6%96%B9%E6%B3%95%E4%B8%80"><span class="toc-number">1.11.11.2.</span> <span class="toc-text">贪心解法（方法一）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B4%AA%E5%BF%83%E8%A7%A3%E6%B3%95%E6%96%B9%E6%B3%95%E4%BA%8C"><span class="toc-number">1.11.11.3.</span> <span class="toc-text">√贪心解法（方法二）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-58"><span class="toc-number">1.11.11.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#135-%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C"><span class="toc-number">1.11.12.</span> <span class="toc-text">☆135. 分发糖果</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-59"><span class="toc-number">1.11.12.1.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#860-%E6%9F%A0%E6%AA%AC%E6%B0%B4%E6%89%BE%E9%9B%B6"><span class="toc-number">1.11.13.</span> <span class="toc-text">860. 柠檬水找零</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-60"><span class="toc-number">1.11.13.1.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#406-%E6%A0%B9%E6%8D%AE%E8%BA%AB%E9%AB%98%E9%87%8D%E5%BB%BA%E9%98%9F%E5%88%97"><span class="toc-number">1.11.14.</span> <span class="toc-text">☆406. 根据身高重建队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-61"><span class="toc-number">1.11.14.1.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B4%AA%E5%BF%83%E5%91%A8%E6%80%BB%E7%BB%93%E4%B8%89"><span class="toc-number">1.11.15.</span> <span class="toc-text">贪心周总结三</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%A8%E4%B8%80-10"><span class="toc-number">1.11.15.1.</span> <span class="toc-text">周一</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%A8%E4%BA%8C-10"><span class="toc-number">1.11.15.2.</span> <span class="toc-text">周二</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%A8%E4%B8%89-10"><span class="toc-number">1.11.15.3.</span> <span class="toc-text">周三</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%A8%E5%9B%9B-10"><span class="toc-number">1.11.15.4.</span> <span class="toc-text">周四</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-62"><span class="toc-number">1.11.15.5.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#452-%E7%94%A8%E6%9C%80%E5%B0%91%E6%95%B0%E9%87%8F%E7%9A%84%E7%AE%AD%E5%BC%95%E7%88%86%E6%B0%94%E7%90%83"><span class="toc-number">1.11.16.</span> <span class="toc-text">452. 用最少数量的箭引爆气球</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F"><span class="toc-number">1.11.16.1.</span> <span class="toc-text">注意</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-63"><span class="toc-number">1.11.16.2.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#435-%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4"><span class="toc-number">1.11.17.</span> <span class="toc-text">☆435. 无重叠区间</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-64"><span class="toc-number">1.11.17.1.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#763-%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4"><span class="toc-number">1.11.18.</span> <span class="toc-text">763. 划分字母区间</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-65"><span class="toc-number">1.11.18.1.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#56-%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4"><span class="toc-number">1.11.19.</span> <span class="toc-text">56. 合并区间</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-66"><span class="toc-number">1.11.19.1.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B4%AA%E5%BF%83%E5%91%A8%E6%80%BB%E7%BB%93%E5%9B%9B"><span class="toc-number">1.11.20.</span> <span class="toc-text">贪心周总结四</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%A8%E4%B8%80-11"><span class="toc-number">1.11.20.1.</span> <span class="toc-text">周一</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%A8%E4%BA%8C-11"><span class="toc-number">1.11.20.2.</span> <span class="toc-text">周二</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%A8%E4%B8%89-11"><span class="toc-number">1.11.20.3.</span> <span class="toc-text">周三</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%A8%E5%9B%9B-11"><span class="toc-number">1.11.20.4.</span> <span class="toc-text">周四</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%A8%E4%BA%94-7"><span class="toc-number">1.11.20.5.</span> <span class="toc-text">周五</span></a></li></ol></li></ol></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li class="active"><a href="/leetcode/carl/%E7%AC%94%E8%AE%B0%E9%9A%8F%E6%83%B3%E5%BD%95/" rel="bookmark" title="代码随想录-笔记">代码随想录-笔记</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="范特东东东" data-src="/images/avatar.jpg"><p class="name" itemprop="name">范特东东东</p><div class="description" itemprop="description"></div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">64</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">23</span> <span class="name">分类</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hqeDE1OQ==" title="https:&#x2F;&#x2F;github.com&#x2F;hjx159"><i class="ic i-github"></i></span> <span class="exturl item xiaohongshu" data-url="aHR0cHM6Ly93d3cueGlhb2hvbmdzaHUuY29tL3VzZXIvcHJvZmlsZS81ZTAyYzhhZDAwMDAwMDAwMDEwMDFmM2U=" title="https:&#x2F;&#x2F;www.xiaohongshu.com&#x2F;user&#x2F;profile&#x2F;5e02c8ad0000000001001f3e"><i class="ic i-xiaohongshu2"></i></span> <span class="exturl item email" data-url="bWFpbHRvOjgxMjE0MzI4MEBxcS5jb20=" title="mailto:812143280@qq.com"><i class="ic i-envelope"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><a href="/categories/photography/" rel="section"><i class="ic i-photography"></i>摄影</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于我</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/framework/spring/spring6/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/java/java-se/java-knowledge/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E5%AE%8B%E7%BA%A2%E5%BA%B7_%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/java/" title="分类于 Java">Java</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/" title="分类于 Java基础">Java基础</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/java-excise/" title="分类于 Java基础-真题">Java基础-真题</a></div><span><a href="/java/java-se/java-excise/%E7%AC%AC02%E7%AB%A0%EF%BC%9A%E9%9A%8F%E5%A0%82%E5%A4%8D%E4%B9%A0%E4%B8%8E%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%A2%98%EF%BC%88%E5%8F%98%E9%87%8F%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%89/" title="宋红康_第02章：变量与运算符">宋红康_第02章：变量与运算符</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/java/" title="分类于 Java">Java</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/" title="分类于 Java基础">Java基础</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/java-excise/" title="分类于 Java基础-真题">Java基础-真题</a></div><span><a href="/java/java-se/java-excise/%E7%AC%AC17%E7%AB%A0%EF%BC%9A%E9%9A%8F%E5%A0%82%E5%A4%8D%E4%B9%A0%E4%B8%8E%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%A2%98%EF%BC%88%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%EF%BC%89/" title="宋红康_第17章：反射机制">宋红康_第17章：反射机制</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/java/" title="分类于 Java">Java</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/" title="分类于 Java基础">Java基础</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/java-excise/" title="分类于 Java基础-真题">Java基础-真题</a></div><span><a href="/java/java-se/java-excise/%E7%AC%AC03%E7%AB%A0%EF%BC%9A%E9%9A%8F%E5%A0%82%E5%A4%8D%E4%B9%A0%E4%B8%8E%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%A2%98%EF%BC%88%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5%EF%BC%89/" title="宋红康_第03章：流程控制语句">宋红康_第03章：流程控制语句</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/mind-map/" title="分类于 思维导图">思维导图</a></div><span><a href="/mind-map/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE%E5%90%88%E9%9B%86/" title="思维导图合集">思维导图合集</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/photography/" title="分类于 摄影">摄影</a></div><span><a href="/photography/%E6%95%85%E5%AE%AB%E9%9B%AA%E6%99%AF/" title="故宫雪景">故宫雪景</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/java/" title="分类于 Java">Java</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/" title="分类于 Java基础">Java基础</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/java-knowledge/" title="分类于 Java基础-知识点">Java基础-知识点</a></div><span><a href="/java/java-se/java-knowledge/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E5%AE%8B%E7%BA%A2%E5%BA%B7_%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/" title="宋红康_第01章_Java语言概述">宋红康_第01章_Java语言概述</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/java/" title="分类于 Java">Java</a> <i class="ic i-angle-right"></i> <a href="/categories/java/juc/" title="分类于 JUC">JUC</a></div><span><a href="/java/juc/JUC%E7%AC%94%E8%AE%B0/" title="JUC 笔记">JUC 笔记</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/java/" title="分类于 Java">Java</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/" title="分类于 Java基础">Java基础</a> <i class="ic i-angle-right"></i> <a href="/categories/java/java-se/java-knowledge/" title="分类于 Java基础-知识点">Java基础-知识点</a></div><span><a href="/java/java-se/java-knowledge/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E5%AE%8B%E7%BA%A2%E5%BA%B7_%E7%AC%AC08%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89/" title="宋红康_第08章_面向对象编程(高级)">宋红康_第08章_面向对象编程(高级)</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/photography/" title="分类于 摄影">摄影</a></div><span><a href="/photography/%E7%B4%AB%E7%AB%B9%E9%99%A2%E5%85%AC%E5%9B%AD/" title="紫竹院公园">紫竹院公园</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/photography/" title="分类于 摄影">摄影</a></div><span><a href="/photography/%E8%93%9D%E4%B8%8E%E9%BB%84/" title="蓝与黄">蓝与黄</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">范特东东东 @ fantedong</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">2m 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">30:52</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"leetcode/carl/笔记随想录/",favicon:{show:"(●´3｀●)欢迎回来",hide:"(〃＞皿＜)你快回来"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hrmmi -->