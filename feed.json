{
    "version": "https://jsonfeed.org/version/1",
    "title": "水文 & 摄影",
    "subtitle": "为了能更好地访问图片，你需要一点魔法",
    "icon": "http://example.com/images/favicon.ico",
    "description": "",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/database/mongodb/MongoDB-JavaGuide/",
            "url": "http://example.com/database/mongodb/MongoDB-JavaGuide/",
            "title": "MongoDB-JavaGuide",
            "date_published": "2023-11-17T12:07:21.834Z",
            "content_html": "<h1 id=\"mongodb常见面试题上\"><a class=\"anchor\" href=\"#mongodb常见面试题上\">#</a> MongoDB 常见面试题（上）</h1>\n<h1 id=\"mongodb常见面试题下\"><a class=\"anchor\" href=\"#mongodb常见面试题下\">#</a> MongoDB 常见面试题（下）</h1>\n",
            "tags": [
                "数据库",
                "MongoDB"
            ]
        },
        {
            "id": "http://example.com/database/elasticsearch/Elasticsearch-JavaGuide/",
            "url": "http://example.com/database/elasticsearch/Elasticsearch-JavaGuide/",
            "title": "Elasticsearch-JavaGuide",
            "date_published": "2023-11-17T12:05:10.564Z",
            "content_html": "",
            "tags": [
                "数据库",
                "Elasticsearch"
            ]
        },
        {
            "id": "http://example.com/database/redis/Redis-JavaGuide/",
            "url": "http://example.com/database/redis/Redis-JavaGuide/",
            "title": "Redis-JavaGuide",
            "date_published": "2023-11-17T12:03:29.258Z",
            "content_html": "<h1 id=\"缓存基础常见面试题\"><a class=\"anchor\" href=\"#缓存基础常见面试题\">#</a> 缓存基础常见面试题</h1>\n<h1 id=\"redis常见面试题上\"><a class=\"anchor\" href=\"#redis常见面试题上\">#</a> Redis 常见面试题（上）</h1>\n<h1 id=\"redis常见面试题下\"><a class=\"anchor\" href=\"#redis常见面试题下\">#</a> Redis 常见面试题（下）</h1>\n<h1 id=\"️重要知识点\"><a class=\"anchor\" href=\"#️重要知识点\">#</a> ⭐️重要知识点</h1>\n",
            "tags": [
                "数据库",
                "Redis"
            ]
        },
        {
            "id": "http://example.com/database/mysql/MySQL-JavaGuide/",
            "url": "http://example.com/database/mysql/MySQL-JavaGuide/",
            "title": "MySQL-JavaGuide",
            "date_published": "2023-11-17T11:50:54.442Z",
            "content_html": "<h1 id=\"mysql\"><a class=\"anchor\" href=\"#mysql\">#</a> MySQL</h1>\n<h2 id=\"数据库基础知识\"><a class=\"anchor\" href=\"#数据库基础知识\">#</a> 数据库基础知识</h2>\n<h3 id=\"数据库-数据库管理系统-数据库系统-数据库管理员\"><a class=\"anchor\" href=\"#数据库-数据库管理系统-数据库系统-数据库管理员\">#</a> 数据库，数据库管理系统，数据库系统，数据库管理员</h3>\n<ul>\n<li><strong>数据库</strong>（DataBase 简称  <code>DB</code> ）：就是信息的集合，或者说是由数据库管理系统管理的数据的集合。</li>\n<li><strong>数据库管理系统</strong>（Database Management System 简称  <code>DBMS</code> ）：是一种操纵和管理数据库的大型软件，通常用于建立、使用和维护数据库。</li>\n<li><strong>数据库系统</strong>（Data Base System，简称  <code>DBS</code> ）：通常由软件、数据库和数据管理员 (DBA) 组成。</li>\n<li><strong>数据库管理员</strong>（Database Administrator, 简称  <code>DBA</code> ）：负责全面管理和控制数据库系统。</li>\n</ul>\n<h3 id=\"元组-码-候选码-主码-外码-主属性-非主属性\"><a class=\"anchor\" href=\"#元组-码-候选码-主码-外码-主属性-非主属性\">#</a> 元组，码，候选码，主码，外码，主属性，非主属性</h3>\n<ul>\n<li><strong>元组</strong>（tuple）：是关系数据库中的基本概念，关系是一张表，表中的<font color='red'>每行（即数据库中的每条记录）就是一个元组</font>，每列就是一个属性。在二维表里，元组也称为行。</li>\n<li><strong>码</strong>：码就是<font color='red'>能唯一标识实体的属性</font>，对应表中的列。</li>\n<li><strong>候选码</strong>：若关系中的<font color='red'>某一属性或属性组的值能唯一标识一个元组，而其任何、子集都不能再标识</font>，则称该属性组为候选码。例如：在学生实体中，“学号” 是能唯一的区分学生实体的，同时又假设 “姓名”、“班级” 的属性组合足以区分学生实体，那么 {学号} 和 {姓名，班级} 都是候选码。</li>\n<li><strong>主码</strong>：主码也叫主键。主码是从候选码中选出来的。<font color='red'>一个实体集中只能有一个主码，但可以有多个候选码</font>。</li>\n<li><strong>外码</strong>：外码也叫外键。如果一个关系中的一个属性是另外一个关系中的主码则这个属性为外码。</li>\n<li><strong>主属性</strong>：<font color='red'>候选码中出现过的属性称为主属性</font>。比如关系 工人（工号，身份证号，姓名，性别，部门）. 显然工号和身份证号都能够唯一标示这个关系，所以都是候选码。工号、身份证号这两个属性就是主属性。如果主码是一个属性组，那么属性组中的属性都是主属性。</li>\n<li><strong>非主属性：</strong><font color='red'>不包含在任何一个候选码中的属性称为非主属性</font>。比如在关系 —— 学生（学号，姓名，年龄，性别，班级）中，主码是 “学号”，那么其他的 “姓名”、“年龄”、“性别”、“班级” 就都可以称为非主属性。</li>\n</ul>\n<h3 id=\"er-图\"><a class=\"anchor\" href=\"#er-图\">#</a> ER 图</h3>\n<p><strong>ER 图</strong> 全称是 Entity Relationship Diagram（<font color='red'>实体联系图</font>），提供了表示实体类型、属性和联系的方法，用来设计数据库。</p>\n<p>ER 图由下面 3 个要素组成：</p>\n<ul>\n<li><strong>实体</strong>：通常是现实世界的业务对象，当然使用一些逻辑对象也可以。比如对于一个校园管理系统，会涉及学生、教师、课程、班级等等实体。在 ER 图中，实体使用<font color='red'>矩形框</font>表示。</li>\n<li><strong>属性</strong>：即某个实体拥有的属性，属性用来描述组成实体的要素，对于产品设计来说可以理解为字段。在 ER 图中，属性使用<font color='red'>椭圆形</font>表示。</li>\n<li><strong>联系</strong>：即实体与实体之间的关系，在 ER 图中用<font color='red'>菱形</font>表示，这个关系不仅有业务关联关系，还能通过数字表示实体之间的数量对照关系。例如，一个班级会有多个学生就是一种实体间的联系。</li>\n</ul>\n<p>下图是一个学生选课的 ER 图，每个学生可以选若干门课程，同一门课程也可以被若干人选择，所以它们之间的关系是<font color='red'>多对多（M: N</font>）。另外，还有其他两种实体之间的关系是：<font color='red'>1 对 1（1:1）</font>、<font color='red'>1 对多（1: N）</font>。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231129163909791.png\" alt=\"image-20231129163909791\" /></p>\n<center>学生与课程之间联系的E-R图</center>\n<h3 id=\"数据库三大范式\"><a class=\"anchor\" href=\"#数据库三大范式\">#</a> <mark>数据库三大范式</mark></h3>\n<p>数据库范式有 3 种：</p>\n<ul>\n<li>\n<p>1NF (第一范式)：<strong><font color='red'>属性不可再分</font></strong>，即每个属性都是不可分割的原子项。</p>\n</li>\n<li>\n<p>2NF (第二范式)：满足第一范式；且 **<font color='red'>不存在部分函数依赖</font>**，即<font color='red'>非主属性必须完全依赖于主属性</font>。</p>\n<blockquote>\n<p>主属性即主键；完全依赖是针对于联合主键的情况，非主键列不能只依赖于主键的一部分；</p>\n</blockquote>\n</li>\n<li>\n<p>3NF (第三范式)：满足第二范式；且 **<font color='red'>不存在传递函数依赖</font>**，即非主属性必须直接依赖于主属性。</p>\n</li>\n</ul>\n<h3 id=\"不推荐使用外键与级联\"><a class=\"anchor\" href=\"#不推荐使用外键与级联\">#</a> 不推荐使用外键与级联</h3>\n<p>对于外键和级联，阿里巴巴开发手册这样说到：</p>\n<blockquote>\n<p>【强制】<strong><font color='red'>不得使用外键与级联，一切外键概念必须在应用层解决</font></strong>。</p>\n<p>说明：以学生和成绩的关系为例，学生表中的 student_id 是主键，那么成绩表中的 student_id 则为外键。如果更新学生表中的 student_id，同时触发成绩表中的 student_id 更新，即为级联更新。</p>\n<ul>\n<li>外键与级联更新适用于单机低并发，<font color='red'>不适合分布式、高并发集群</font>；</li>\n<li><font color='red'>级联更新是强阻塞，存在数据库更新风暴的风险</font>；</li>\n<li><font color='red'>外键影响数据库的插入速度</font>；</li>\n</ul>\n</blockquote>\n<h3 id=\"存储过程\"><a class=\"anchor\" href=\"#存储过程\">#</a> 存储过程</h3>\n<p>我们可以把存储过程看成是<strong>一些 SQL 语句的集合，中间加了点逻辑控制语句</strong>。存储过程在业务比较复杂的时候是非常实用的，比如很多时候我们完成一个操作可能需要写一大串 SQL 语句，这时候我们就可以写有一个存储过程，这样也方便了我们下一次的调用。<font color='red'>存储过程一旦调试完成通过后就能稳定运行</font>，另外，<font color='red'>使用存储过程比单纯 SQL 语句执行要快，因为存储过程是预编译过的</font>。</p>\n<p>存储过程在互联网公司应用不多，因为<font color='red'>存储过程难以调试和扩展，而且没有移植性，还会消耗数据库资源</font>。</p>\n<p>阿里巴巴 Java 开发手册里要求 **<font color='red'>禁止使用存储过程</font>**。</p>\n<h3 id=\"drop-delete-与-truncate-的区别\"><a class=\"anchor\" href=\"#drop-delete-与-truncate-的区别\">#</a> drop、delete 与 truncate 的区别</h3>\n<h4 id=\"用法不同\"><a class=\"anchor\" href=\"#用法不同\">#</a> 用法不同</h4>\n<ul>\n<li><code>drop</code>  (丢弃数据):  <code>drop table 表名</code>  ，直接将表都删除掉，在<strong>删除表</strong>的时候使用。</li>\n<li><code>truncate</code>  (清空数据) :  <code>truncate table 表名</code>  ，只删除表中的数据，<font color='red'>再插入数据的时候自增长 id 又从 1 开始</font>，在<strong>清空表</strong>中数据的时候使用。</li>\n<li><code>delete</code> （删除数据） :  <code>delete from 表名 where 列名=值</code> ，<strong>删除某一行</strong>的数据，如果不加  <code>where</code>  子句和 <code>truncate table 表名</code> 作用类似。</li>\n</ul>\n<p>注意：<strong> <code>truncate</code>  和  <code>delete</code>  只删除数据不删除表的结构 (定义)，执行  <code>drop</code>  语句，此表的结构也会删除，也就是执行  <code>drop</code>  之后对应的表不复存在。</strong></p>\n<h4 id=\"属于不同的数据库语言\"><a class=\"anchor\" href=\"#属于不同的数据库语言\">#</a> 属于不同的数据库语言</h4>\n<ul>\n<li>\n<p><code>truncate</code>  和  <code>drop</code>  属于 **DDL (数据定义语言)** 语句，操作立即生效，原数据不放到 rollback segment 中，<font color='red'>不能回滚</font>，操作不触发 trigger。</p>\n</li>\n<li>\n<p>而  <code>delete</code>  语句是 **DML (数据库操作语言)** 语句，这个操作会放到 rollback segement 中，<font color='red'>可以回滚</font>，事务提交之后才生效。</p>\n</li>\n</ul>\n<p><strong>DML 语句和 DDL 语句区别：</strong></p>\n<ul>\n<li>DML 是数据库操作语言（Data Manipulation Language）的缩写，是指<font color='red'>对数据库中表记录的操作</font>，主要包括表记录的插入、更新、删除和查询，是开发人员日常使用最频繁的操作。</li>\n<li>DDL （Data Definition Language）是数据定义语言的缩写，简单来说，就是<font color='red'>对数据库内部的对象进行创建、删除、修改</font>的操作语言。</li>\n<li>二者最大区别：<strong><font color='red'> DML 只是对表内部数据的操作，而不涉及到表的定义、结构的修改</font></strong>，更不会涉及到其他对象。DDL 语句更多的被数据库管理员（DBA）所使用，一般的开发人员很少使用。</li>\n</ul>\n<p>另外，由于 <code>select</code>  不会对表进行破坏，所以有的地方也会把 <code>select</code>  单独区分开叫做数据库查询语言 DQL（Data Query Language）。</p>\n<h4 id=\"执行速度不同\"><a class=\"anchor\" href=\"#执行速度不同\">#</a> 执行速度不同</h4>\n<p>一般来说： <code>drop</code>  &gt;  <code>truncate</code>  &gt;  <code>delete</code> （这个我没有设计测试过）。</p>\n<ul>\n<li><code>delete</code>  命令执行的时候<font color='red'>会产生数据库的 <code>binlog</code>  日志，而日志记录是需要消耗时间的</font>，但是也有个<font color='red'>好处是方便数据回滚恢复</font>。</li>\n<li><code>truncate</code>  命令执行的时候<font color='red'>不会产生数据库日志</font>，因此比 <code>delete</code>  要快。除此之外，还<font color='red'>会把表的自增值重置和索引恢复到初始大小等</font>。</li>\n<li><code>drop</code>  命令会<font color='red'>把表占用的空间全部释放掉</font>。</li>\n</ul>\n<p>Tips：你应该更多地关注在使用场景上，而不是执行效率。</p>\n<h3 id=\"数据库设计通常分为哪几步\"><a class=\"anchor\" href=\"#数据库设计通常分为哪几步\">#</a> 数据库设计通常分为哪几步？</h3>\n<ol>\n<li><strong>需求分析</strong>：分析用户的需求，包括数据、功能和性能需求。</li>\n<li><strong>概念结构设计</strong>：主要采用 E-R 模型进行设计，包括画 <code> E-R 图</code> 。</li>\n<li><strong>逻辑结构设计</strong>：通过将 E-R 图转换成 <code>表</code> ，实现从 E-R 模型到关系模型的转换。</li>\n<li><strong>物理结构设计</strong>：主要是为所设计的数据库<font color='red'>选择合适的存储结构和存取路径</font>。</li>\n<li><strong>数据库实施</strong>：包括编程、测试和试运行</li>\n<li><strong>数据库的运行和维护</strong>：系统的运行与数据库的日常维护。</li>\n</ol>\n<h2 id=\"nosql非关系型数据库基础\"><a class=\"anchor\" href=\"#nosql非关系型数据库基础\">#</a> NoSQL（非关系型数据库）基础</h2>\n<h3 id=\"nosql-是什么\"><a class=\"anchor\" href=\"#nosql-是什么\">#</a> NoSQL 是什么？</h3>\n<p><code>NoSQL</code> （Not Only SQL）非关系型的数据库，主要针对的是<font color='red'>键值、文档、图形类型</font>数据存储。并且，NoSQL 数据库<font color='red'>天生支持分布式，数据冗余和数据分片</font>等特性，<font color='red'>旨在提供可扩展、高可用、高性能的数据存储解决方案</font>。</p>\n<p>一个常见的误解是 NoSQL 数据库或非关系型数据库不能很好地存储关系型数据。<font color='red'>NoSQL 数据库可以存储关系型数据</font>— 它们与关系型数据库的存储方式不同。</p>\n<p>NoSQL 数据库代表：HBase 、Cassandra、MongoDB、Redis。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/sql-nosql-tushi.png\" alt=\"img\" /></p>\n<h3 id=\"sql数据库-和-nosql数据库-的区别\"><a class=\"anchor\" href=\"#sql数据库-和-nosql数据库-的区别\">#</a> <mark>SQL 数据库 和 NoSQL 数据库 的区别</mark></h3>\n<p>即关系型数据库与非关系型数据库的区别：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"></th>\n<th>SQL 数据库</th>\n<th>NoSQL 数据库</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">发展历程</td>\n<td>开发于 1970 年代，重点是<font color='red'>减少数据重复</font></td>\n<td>开发于 2000 年代后期，重点是<font color='red'>提升可扩展性</font>，<font color='red'>减少大规模数据的存储成本</font></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">例子</td>\n<td><code>Oracle</code> 、 <code>MySQL</code> 、Microsoft SQL Server 、PostgreSQL</td>\n<td>文档： <code>MongoDB</code> 、CouchDB，键值： <code>Redis</code>  、DynamoDB，宽列：Cassandra 、  <code>HBase</code> ，图表： <code>Neo4j </code> 、 Amazon Neptune、Giraph</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">数据存储模型</td>\n<td><font color='red'>结构化存储</font>，具有固定行和列的表格</td>\n<td><font color='red'>非结构化存储</font>。文档：JSON 文档，键值：键值对，宽列：包含行和动态列的表，图：节点和边</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">数据模式</td>\n<td><font color='red'>必须先定义好表结构，才能添加数据</font></td>\n<td><font color='red'>数据可以在任何时候任何地方添加，不需要预先定义</font></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">事务支持</td>\n<td>支持对事务原子性细粒度控制，并且易于回滚事务</td>\n<td><font color='red'>没有事务这个概念</font>，每一个数据集都是原子级别的</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ACID 属性</td>\n<td>提供<font color='red'>原子性、一致性、隔离性、持久性</font>(ACID) 属性</td>\n<td><font color='red'>通常不支持 ACID 事务</font>，为了可扩展、高性能进行了权衡，少部分支持比如 MongoDB 。不过，MongoDB 对 ACID 事务 的支持和 MySQL 还是有所区别的。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">查询速度</td>\n<td><font color='red'>数据存储在磁盘中，查询速度较慢</font></td>\n<td><font color='red'>数据存储在缓存中，且不需要经过 SQL 层的解析，查询速度较快</font></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">性能</td>\n<td>性能通常取决于磁盘子系统。要获得最佳性能，通常需要<font color='red'>优化查询、索引、表结构</font>。</td>\n<td>性能通常由底层硬件集群大小、网络延迟以及调用应用程序来决定。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">扩展</td>\n<td><font color='red'>垂直</font>（使用性能更强大的服务器进行扩展）、读写分离、分库分表</td>\n<td><font color='red'>横向</font>（增加服务器的方式横向扩展，通常是基于分片机制）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">用途</td>\n<td>普通企业级的项目的数据存储</td>\n<td>用途广泛比如图数据库支持分析和遍历连接数据之间的关系、键值数据库可以处理大量数据扩展和极高的状态变化</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">查询语法</td>\n<td><font color='red'>结构化查询语言 (SQL)</font></td>\n<td>数据访问语法可能<font color='red'>因数据库而异</font></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"nosql-数据库的优势\"><a class=\"anchor\" href=\"#nosql-数据库的优势\">#</a> NoSQL 数据库的优势</h3>\n<p>NoSQL 数据库非常适合许多现代应用程序，例如移动、Web 和游戏等应用程序，它们需要灵活、可扩展、高性能和功能强大的数据库以提供卓越的用户体验。</p>\n<ul>\n<li><strong>灵活性：</strong> NoSQL 数据库通常提供灵活的架构，以实现更快速、更多的迭代开发。<font color='red'>灵活的数据模型</font>使 NoSQL 数据库成为 **<font color='red'>半结构化和非结构化数据</font>** 的理想之选。</li>\n<li><strong>可扩展性：</strong> NoSQL 数据库通常被设计为<font color='red'>通过使用分布式硬件集群来横向扩展</font>，而不是通过添加昂贵和强大的服务器来纵向扩展。</li>\n<li><strong>高性能：</strong> NoSQL 数据库<font color='red'>针对特定的数据模型和访问模式进行了优化</font>，这与尝试使用关系数据库完成类似功能相比可实现更高的性能。</li>\n<li><strong>强大的功能：</strong> NoSQL 数据库提供功能<font color='red'>强大的 API 和数据类型</font>，专门针对其各自的数据模型而构建。</li>\n</ul>\n<h3 id=\"nosql-数据库有哪些类型\"><a class=\"anchor\" href=\"#nosql-数据库有哪些类型\">#</a> NoSQL 数据库有哪些类型？</h3>\n<p>NoSQL 数据库主要可以分为下面四种类型：</p>\n<ul>\n<li><strong>键值</strong> ：键值数据库是一种较简单的数据库，其中<font color='red'>每个项都包含键和值</font>。这是极为灵活的 NoSQL 数据库类型，因为应用可以完全控制 value 字段中存储的内容，没有任何限制。 <code>Redis</code>  和 DynanoDB 是两款非常流行的键值数据库。</li>\n<li><strong>文档</strong> ：文档数据库中的数据被存储在类似于  <code>JSON</code> （JavaScript 对象表示法）对象的文档中，非常清晰直观。<font color='red'>每个文档包含成对的字段和值</font>。这些值通常可以是各种类型，包括字符串、数字、布尔值、数组或对象等，并且它们的<font color='red'>结构通常与开发者在代码中使用的对象保持一致</font>。 <code>MongoDB</code>  就是一款非常流行的文档数据库。</li>\n<li><strong>图形</strong> ：图形数据库旨在轻松构建和运行与高度连接的数据集一起使用的应用程序。图形数据库的典型使用案例包括社交网络、推荐引擎、欺诈检测和知识图谱。 <code>Neo4j</code>  和 Giraph 是两款非常流行的图形数据库。</li>\n<li><strong>宽列</strong> ：宽列存储数据库<font color='red'>非常适合需要存储大量的数据</font>。Cassandra 和  <code>HBase</code>  是两款非常流行的宽列存储数据库。</li>\n</ul>\n<p>下面这张图片来源于 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWFybi5taWNyb3NvZnQuY29tL2VuLXVzL2RvdG5ldC9hcmNoaXRlY3R1cmUvY2xvdWQtbmF0aXZlL3JlbGF0aW9uYWwtdnMtbm9zcWwtZGF0YQ==\">微软的官方文档 | 关系数据与 NoSQL 数据</span>。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/types-of-nosql-datastores.png\" alt=\"NoSQL 数据模型\" /></p>\n<h2 id=\"mysql-常见面试题\"><a class=\"anchor\" href=\"#mysql-常见面试题\">#</a> MySQL 常见面试题</h2>\n<h3 id=\"mysql基础\"><a class=\"anchor\" href=\"#mysql基础\">#</a> MySQL 基础</h3>\n<h4 id=\"什么是关系型数据库\"><a class=\"anchor\" href=\"#什么是关系型数据库\">#</a> 什么是关系型数据库？</h4>\n<p>顾名思义， <code>关系型数据库（RDBMS，Relational Database Management System）</code> 就是<font color='red'>一种建立在<u>关系模型</u>的基础上的数据库</font>。关系模型表明了数据库中所存储的<font color='red'>数据之间的联系（一对一、一对多、多对多）</font>。</p>\n<p>关系型数据库中，我们的数据都被存放在了各种表中（比如用户表），表中的每一行就存放着一条数据（比如一个用户的信息）。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/5e3c1a71724a38245aa43b02_99bf70d46cc247be878de9d3a88f0c44.png\" alt=\"关系型数据库表关系\" /></p>\n<p>大部分关系型数据库都使用 SQL 来操作数据库中的数据。并且，大部分关系型数据库都支持<font color='red'>事务的四大特性 (ACID)</font>。</p>\n<p>常见的关系型数据库：MySQL、PostgreSQL、Oracle、SQL Server、SQLite（微信本地的聊天记录的存储就是用的 SQLite） ......。</p>\n<h4 id=\"什么是-sql\"><a class=\"anchor\" href=\"#什么是-sql\">#</a> 什么是 SQL？</h4>\n<p>SQL 是一种 <code>结构化查询语言(Structured Query Language)</code> ，专门用来与数据库打交道，目的是提供一种<font color='red'>从数据库中读写数据</font>的简单有效的方法。</p>\n<p>几乎所有的主流关系数据库都支持 SQL ，适用性非常强。并且，一些非关系型数据库也兼容 SQL 或者使用的是类似于 SQL 的查询语言。</p>\n<p>SQL 可以帮助我们：</p>\n<ul>\n<li>新建数据库、数据表、字段；</li>\n<li>在数据库中增加，删除，修改，查询数据；</li>\n<li>新建视图、函数、存储过程；</li>\n<li>对数据库中的数据进行简单的数据分析；</li>\n<li>搭配 Hive，Spark SQL 做大数据；</li>\n<li>搭配 SQLFlow 做机器学习；</li>\n<li>......</li>\n</ul>\n<h4 id=\"什么是-mysql\"><a class=\"anchor\" href=\"#什么是-mysql\">#</a> 什么是 MySQL？</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/20210327143351823.png\" alt=\"img\" /></p>\n<p><strong>MySQL 是一种关系型数据库，主要用于持久化存储我们的系统中的一些数据比如用户信息。</strong></p>\n<p>由于 MySQL 是开源免费并且比较成熟的数据库，因此，MySQL 被大量使用在各种系统中。任何人都可以在 GPL (General Public License) 的许可下下载并根据个性化的需要对其进行修改。MySQL 的默认端口号是<strong> 3306</strong>。</p>\n<h4 id=\"mysql-有什么优点\"><a class=\"anchor\" href=\"#mysql-有什么优点\">#</a> MySQL 有什么优点？</h4>\n<p>这个问题本质上是在问 MySQL 如此流行的原因。</p>\n<p>MySQL 主要具有下面这些优点：</p>\n<ol>\n<li>成熟稳定，功能完善。</li>\n<li>开源免费。</li>\n<li>文档丰富，既有详细的官方文档，又有非常多优质文章可供参考学习。</li>\n<li>开箱即用，操作简单，维护成本低。</li>\n<li>兼容性好，支持常见的操作系统，支持多种开发语言。</li>\n<li>社区活跃，生态完善。</li>\n<li><strong>事务支持</strong>优秀， InnoDB 存储引擎默认使用 REPEATABLE-READ 并不会有任何性能损失，并且 InnoDB 实现的 REPEATABLE-READ 隔离级别其实是可以解决幻读问题发生的。</li>\n<li>支持<strong>分库分表、读写分离、高可用</strong>。</li>\n</ol>\n<h4 id=\"mysql-中主键和-unique-的区别\"><a class=\"anchor\" href=\"#mysql-中主键和-unique-的区别\">#</a> <mark>MySQL 中主键和 unique 的区别</mark></h4>\n<p>主键和 UNIQUE 约束<font color='red'>都能保证某个列或者列组合的唯⼀性</font>，但是有以下不同：</p>\n<ul>\n<li>\n<p><font color='red'>⼀张表中只能定义⼀个主键</font>，却可以定义多个 UNIQUE 约束！</p>\n</li>\n<li>\n<p><font color='red'>主键列不允许存放 NULL</font>，⽽声明了 UNIQUE 属性的列可以存放 NULL ，⽽且 NULL 可以重复地出现在多条记录中！</p>\n</li>\n</ul>\n<h3 id=\"mysql字段类型\"><a class=\"anchor\" href=\"#mysql字段类型\">#</a> MySQL 字段类型</h3>\n<h4 id=\"整数类型的-unsigned-属性有什么用\"><a class=\"anchor\" href=\"#整数类型的-unsigned-属性有什么用\">#</a> 整数类型的 UNSIGNED 属性有什么用？</h4>\n<p><strong>UNSIGNED 属性来表示不允许负值的无符号整数，因此可以将正整数的上限提高一倍</strong>，因为它不需要存储负数值。</p>\n<p>例如， TINYINT UNSIGNED 类型的取值范围是 0 ~ 255，而普通的 TINYINT 类型的值范围是 -128 ~ 127。INT UNSIGNED 类型的取值范围是 0 ~ 4,294,967,295，而普通的 INT 类型的值范围是 2,147,483,648 ~ 2,147,483,647。</p>\n<p>对于<font color='red'>从 0 开始递增的 ID 列</font>，使用 UNSIGNED 属性可以非常适合，因为不允许负值并且可以拥有更大的上限范围，提供了更多的 ID 值可用。</p>\n<h4 id=\"char-和-varchar-的区别是什么\"><a class=\"anchor\" href=\"#char-和-varchar-的区别是什么\">#</a> CHAR 和 VARCHAR 的区别是什么？</h4>\n<p><strong>CHAR 是定长字符串，VARCHAR 是变长字符串。</strong></p>\n<ul>\n<li>CHAR 在存储时会在右边<font color='red'>填充空格</font>以达到指定的长度，检索时会<font color='red'>去掉空格</font>；VARCHAR 在存储时需要<font color='red'>使用 1 或 2 个额外字节记录字符串的长度</font>，检索时不需要处理。</li>\n<li>CHAR 更适合存储<font color='red'>长度较短或者长度都差不多</font>的字符串，例如 Bcrypt 算法、MD5 算法加密后的密码、身份证号码。VARCHAR 类型适合存储<font color='red'>长度不确定或者差异较大</font>的字符串，例如用户昵称、文章标题等。</li>\n<li>CHAR (M) 和 VARCHAR (M) 的 M 都代表能够保存的字符数的最大值，<font color='red'>无论是字母、数字还是中文，每个都只占用一个字符</font>。</li>\n</ul>\n<h4 id=\"varchar100和-varchar10的区别是什么\"><a class=\"anchor\" href=\"#varchar100和-varchar10的区别是什么\">#</a> VARCHAR (100) 和 VARCHAR (10) 的区别是什么？</h4>\n<p>VARCHAR (100) 和 VARCHAR (10) 都是变长类型，表示能存储最多 100 个字符和 10 个字符。因此，<font color='red'>VARCHAR (100) 可以满足更大范围的字符存储需求</font>，有更好的业务拓展性。而 VARCHAR (10) 存储超过 10 个字符时，就需要修改表结构才可以。</p>\n<p>虽说 VARCHAR (100) 和 VARCHAR (10) 能存储的字符范围不同，但二者存储相同的字符串，所占用磁盘的存储空间其实是一样的，这也是很多人容易误解的一点。</p>\n<p>不过，<font color='red'>VARCHAR (100) 会消耗更多的内存</font>。这是因为 VARCHAR 类型在内存中操作时，<font color='red'>通常会分配固定大小的内存块</font>来保存值，即使用字符类型中定义的长度。例如在进行排序的时候，VARCHAR (100) 是按照 100 这个长度来进行的，也就会消耗更多内存。</p>\n<h4 id=\"decimal-和-floatdouble-的区别是什么\"><a class=\"anchor\" href=\"#decimal-和-floatdouble-的区别是什么\">#</a> DECIMAL 和 FLOAT/DOUBLE 的区别是什么？</h4>\n<p><strong>DECIMAL 是定点数，可以存储精确的小数值；FLOAT/DOUBLE 是浮点数，只能存储近似的小数值。</strong></p>\n<p>在 Java 中，MySQL 的 DECIMAL 类型对应的是 Java 类  <code>java.math.BigDecimal</code> 。</p>\n<h4 id=\"为什么不推荐使用-text-和-blob\"><a class=\"anchor\" href=\"#为什么不推荐使用-text-和-blob\">#</a> 为什么不推荐使用 TEXT 和 BLOB？</h4>\n<p>TEXT 类型类似于 CHAR（0-255 字节）和 VARCHAR（0-65,535 字节），但可以存储更长的字符串，即<font color='cornflowerblue'>长文本数据</font>，例如博客内容。</p>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>可存储大小</th>\n<th>用途</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>TINYTEXT</td>\n<td>0-255 字节</td>\n<td>一般文本字符串</td>\n</tr>\n<tr>\n<td>TEXT</td>\n<td>0-65,535 字节</td>\n<td>长文本字符串</td>\n</tr>\n<tr>\n<td>MEDIUMTEXT</td>\n<td>0-16,772,150 字节</td>\n<td>较大文本数据</td>\n</tr>\n<tr>\n<td>LONGTEXT</td>\n<td>0-4,294,967,295 字节</td>\n<td>极大文本数据</td>\n</tr>\n</tbody>\n</table>\n<p>BLOB 类型主要用于存储<font color='cornflowerblue'>二进制大对象，例如图片、音视频等文件</font>。</p>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>可存储大小</th>\n<th>用途</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>TINYBLOB</td>\n<td>0-255 字节</td>\n<td>短文本二进制字符串</td>\n</tr>\n<tr>\n<td>BLOB</td>\n<td>0-65KB</td>\n<td>二进制字符串</td>\n</tr>\n<tr>\n<td>MEDIUMBLOB</td>\n<td>0-16MB</td>\n<td>二进制形式的长文本数据</td>\n</tr>\n<tr>\n<td>LONGBLOB</td>\n<td>0-4GB</td>\n<td>二进制形式的极大文本数据</td>\n</tr>\n</tbody>\n</table>\n<p>在日常开发中，很少使用 TEXT 类型，但偶尔会用到，而 BLOB 类型则基本不常用。<font color='red'>如果预期长度范围可以通过 VARCHAR 来满足，建议避免使用 TEXT</font>。</p>\n<p>数据库规范通常不推荐使用 BLOB 和 TEXT 类型，这两种类型具有一些缺点和限制，例如：</p>\n<ul>\n<li><font color='red'>不能有默认值</font></li>\n<li>在使用临时表时<font color='red'>无法使用内存临时表，只能在磁盘上创建临时表</font>（《高性能 MySQL》书中有提到）</li>\n<li><font color='red'>检索效率较低</font></li>\n<li><font color='red'>不能直接创建索引</font>，需要指定前缀长度</li>\n<li><font color='red'>会消耗大量的网络和 IO 带宽</font></li>\n<li>可能导致表上的<font color='red'> DML 操作变慢</font></li>\n<li>……</li>\n</ul>\n<h4 id=\"datetime-和-timestamp-的区别是什么\"><a class=\"anchor\" href=\"#datetime-和-timestamp-的区别是什么\">#</a> DATETIME 和 TIMESTAMP 的区别是什么？</h4>\n<p><strong>DATETIME 类型没有时区信息，TIMESTAMP 和时区有关</strong>。</p>\n<p><font color='red'>TIMESTAMP 只需要使用 4 个字节的存储空间，但是 DATETIME 需要耗费 8 个字节的存储空间</font>。但是，这样同样造成了一个问题，<font color='red'>Timestamp 表示的时间范围更小</font>。</p>\n<ul>\n<li>DATETIME：1000-01-01 00:00:00 ~ 9999-12-31 23:59:59</li>\n<li>Timestamp：1970-01-01 00:00:01 ~ 2037-12-31 23:59:59</li>\n</ul>\n<h4 id=\"null-和-的区别是什么\"><a class=\"anchor\" href=\"#null-和-的区别是什么\">#</a> NULL 和 '' 的区别是什么？</h4>\n<p><code>NULL</code>  跟  <code>''</code> (空字符串) 是两个完全不一样的值，区别如下：</p>\n<ul>\n<li><strong> <code>NULL</code>  代表一个不确定的值，但占用空间</strong>。就算是两个  <code>NULL</code> ，它俩也不一定相等。例如， <code>SELECT NULL=NULL</code>  的结果为 false，但是在我们使用 <code>DISTINCT</code> ， <code>GROUP BY</code> ， <code>ORDER BY</code>  时， <code>NULL</code>  又被认为是相等的。</li>\n<li><strong> <code>''</code>  是长度为 0 的字符串，不占用空间</strong>。</li>\n<li><font color='red'> <code>NULL</code>  会影响聚合函数的结果</font>。例如， <code>SUM</code> 、 <code>AVG</code> 、 <code>MIN</code> 、 <code>MAX</code>  等聚合函数会忽略  <code>NULL</code>  值。 <code>COUNT</code>  的处理方式取决于参数的类型。如果参数是  <code>*</code> ( <code>COUNT(*)</code> )，则会统计所有的记录数，包括  <code>NULL</code>  值；如果参数是某个字段名 ( <code>COUNT(列名)</code> )，则会忽略  <code>NULL</code>  值，只统计非空值的个数。</li>\n<li><font color='red'>查询  <code>NULL</code>  值时，必须使用  <code>IS NULL</code>  或  <code>IS NOT NULLl</code>  来判断</font>，而不能使用 =、!=、 &lt;、&gt; 之类的比较运算符。而 <code>''</code>  是可以使用这些比较运算符的。</li>\n</ul>\n<p><strong>因此，MySQL 不建议使用  <code>NULL</code>  作为列默认值。</strong></p>\n<h4 id=\"boolean-类型如何表示\"><a class=\"anchor\" href=\"#boolean-类型如何表示\">#</a> Boolean 类型如何表示？</h4>\n<p>MySQL 中没有专门的布尔类型，而是<strong>用 TINYINT (1) 类型来表示布尔值</strong>。TINYINT (1) 类型可以存储 0 或 1，分别对应 false 或 true。</p>\n<h3 id=\"mysql基础架构\"><a class=\"anchor\" href=\"#mysql基础架构\">#</a> MySQL 基础架构</h3>\n<blockquote>\n<p>配合 <a href=\"\">SQL 语句在 MySQL 中的执行过程</a> 这篇文章来理解 MySQL 基础架构。</p>\n</blockquote>\n<p>一个 SQL 语句在 MySQL 中的执行流程，包括 SQL 的查询在 MySQL 内部会怎么流转，SQL 语句的更新是怎么完成的。</p>\n<p>在分析之前先看看 MySQL 的基础架构，知道了 MySQL 由那些组件组成，以及这些组件的作用是什么，可以帮助我们理解和解决这些问题。</p>\n<h4 id=\"1-mysql-基础架构分析\"><a class=\"anchor\" href=\"#1-mysql-基础架构分析\">#</a> 1、MySQL 基础架构分析</h4>\n<h5 id=\"11-架构概览\"><a class=\"anchor\" href=\"#11-架构概览\">#</a> 1.1、架构概览</h5>\n<p>下图是 MySQL 的一个简要架构图，可以很清晰地看到客户端的一条 SQL 语句在 MySQL 内部是如何执行的。</p>\n<p>从图中可以看出，MySQL 主要由下面几部分构成：</p>\n<ul>\n<li><strong>连接器：</strong><font color='red'>连接管理、身份认证和权限</font>相关 (登录 MySQL 的时候)。</li>\n<li>** 查询缓存：** 执行查询语句的时候，会<font color='red'>先查询缓存，命中则直接返回</font>（<font color='red'>MySQL 8.0 版本后移除</font>，因为这个功能不太实用）。</li>\n<li><strong>分析器：</strong><font color='red'>对 SQL 语句进行词法分析、语法分析</font>。说白了就是要先看 SQL 语句要干嘛，再检查 SQL 语句语法是否正确。</li>\n<li><strong>优化器：</strong><font color='red'>执行计划生产，索引选择</font>。按照 MySQL 认为<font color='red'>最优的方案</font>去执行。</li>\n<li>** 执行器：** 执行语句，然后<font color='red'>从存储引擎返回数据</font>。</li>\n<li><strong>插件式存储引擎</strong>：主要负责<font color='red'>数据的存储和读取</font>，采用的是 <code>插件式架构</code> ，支持 InnoDB、MyISAM、Memory 等多种存储引擎。</li>\n</ul>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/13526879-3037b144ed09eb88.png\" alt=\"img\" /></p>\n<center>MySQL 简要架构图</center>\n<p>MySQL 主要分为 Server 层和存储引擎层：</p>\n<ul>\n<li><strong>Server 层</strong>：主要包括<font color='red'>连接器、查询缓存、分析器、优化器、执行器</font>等，所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图，函数等，还有一个通用的日志模块 **<font color='red'> binlog 日志模块</font>**。</li>\n<li><strong>存储引擎层</strong>：主要负责<font color='red'>数据的存储和读取</font>，采用可以替换的插件式架构，支持 <font color='red'>InnoDB、MyISAM、Memory</font> 等多个存储引擎。其中 InnoDB 引擎有自有的日志模块 **<font color='red'> redolog 日志模块</font><strong>。</strong><font color='red'>现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5 版本开始就被当做默认存储引擎了</font>**。</li>\n</ul>\n<h5 id=\"12-server-层的组件介绍\"><a class=\"anchor\" href=\"#12-server-层的组件介绍\">#</a> 1.2、Server 层的组件介绍</h5>\n<h6 id=\"1连接器\"><a class=\"anchor\" href=\"#1连接器\">#</a> 1）连接器</h6>\n<p>连接器主要和 **<font color='red'>身份认证和权限相关</font>** 的功能相关，就好比一个级别很高的门卫一样。</p>\n<p>主要负责用户登录数据库，进行用户的身份认证，包括校验账户密码，权限等操作。如果用户账户密码已通过，连接器会到权限表中查询该用户的所有权限，之后在这个连接里的权限逻辑判断都<font color='red'>仅依赖起始连接成功时读取到的权限数据</font>。也就是说，<font color='red'>后续只要这个连接不断开，即使管理员修改了该用户的权限，该用户也是不受影响的</font>。</p>\n<h6 id=\"2查询缓存\"><a class=\"anchor\" href=\"#2查询缓存\">#</a> 2）查询缓存</h6>\n<blockquote>\n<p><strong>从 MySQL8.0 后移除</strong></p>\n</blockquote>\n<p>查询缓存主要 **<font color='red'>用来缓存所执行的 SELECT 语句以及该语句的结果集</font>**。</p>\n<p>若连接成功建立，<font color='red'>执行查询语句的时候，会先查询缓存</font>。</p>\n<ul>\n<li>MySQL 会先校验这个 SQL 是否执行过，<font color='red'>以 Key-Value 的形式缓存在内存中，Key 是查询语句，Value 是结果集</font>。</li>\n<li>如果缓存 key 被命中，就会直接返回给客户端。</li>\n<li>如果缓存 key 没有命中，就会执行后续的操作，<font color='red'>完成后也会把结果缓存起来，方便下一次调用</font>。</li>\n</ul>\n<p><strong><font color='red'>MySQL 查询不建议使用缓存，因为表更新会清空表上的所有查询缓存，导致查询缓存频繁失效</font></strong>。假如你对一个表更新的话，这个表上的所有的查询缓存都会被清空。对于不经常更新的数据来说，使用缓存还是可以的。</p>\n<p>MySQL 8.0 版本后删除了缓存的功能，官方也是认为该功能在实际的应用场景比较少，所以干脆直接删掉了。</p>\n<h6 id=\"3分析器\"><a class=\"anchor\" href=\"#3分析器\">#</a> 3）分析器</h6>\n<p><font color='red'>MySQL 没有命中缓存，那么就会进入分析器</font>。</p>\n<p><strong><font color='red'>第一步，词法分析</font></strong>：一条 SQL 语句有多个字符串组成，首先要<font color='red'>提取关键字</font>，比如 select，提出查询的表，提出字段名，提出查询条件等等。</p>\n<p><strong><font color='red'>第二步，语法分析</font></strong>：主要就是判断你输入的 SQL 是否正确，<font color='red'>判断是否符合 MySQL 的语法</font>。</p>\n<p>完成这 2 步之后，MySQL 就准备开始执行了，但是如何执行，怎么执行是最好的结果呢？这个时候就需要优化器上场了。</p>\n<h6 id=\"4优化器\"><a class=\"anchor\" href=\"#4优化器\">#</a> 4）优化器</h6>\n<p>优化器的作用就是 **<font color='red'>按照它认为的最优执行方案去执行</font>**，比如多个索引的时候该<font color='red'>如何选择索引</font>，多表查询的时候<font color='red'>如何选择关联顺序</font>等。</p>\n<p>可以说，经过了优化器之后，这个语句具体该如何执行就已经定下来。</p>\n<h6 id=\"5执行器\"><a class=\"anchor\" href=\"#5执行器\">#</a> 5）执行器</h6>\n<p>当选择了执行方案后，MySQL 就准备开始执行了。首先执行前会校验该用户有没有权限，如果没有权限，就会返回错误信息。<strong><font color='red'>如果有权限，就会去调用存储引擎的接口，返回执行结果</font></strong>。</p>\n<h4 id=\"2-sql-执行过程分析\"><a class=\"anchor\" href=\"#2-sql-执行过程分析\">#</a> 2、SQL 执行过程分析</h4>\n<h5 id=\"21-dql-查询语句\"><a class=\"anchor\" href=\"#21-dql-查询语句\">#</a> 2.1、DQL 查询语句</h5>\n<blockquote>\n<p>select</p>\n</blockquote>\n<p>针对 select 语句：</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">select</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">from</span> tb_student  A <span class=\"token keyword\">where</span> A<span class=\"token punctuation\">.</span>age<span class=\"token operator\">=</span><span class=\"token string\">'18'</span> <span class=\"token operator\">and</span> A<span class=\"token punctuation\">.</span>name<span class=\"token operator\">=</span><span class=\"token string\">' 张三 '</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>结合上面的说明，我们分析下这个语句的执行流程：</p>\n<ol>\n<li><strong>检查该语句是否有权限</strong>：\n<ul>\n<li>如果没有权限，直接返回错误信息。</li>\n<li>如果有权限，在 MySQL8.0 版本以前，会<strong>查询缓存</strong>，以这条 SQL 语句为 key 在内存中查询是否有结果，有则直接返回，无则执行下一步。</li>\n</ul>\n</li>\n<li><strong>通过分析器对 SQL 语句进行词法分析、语法分析</strong>。\n<ul>\n<li><font color='red'>提取关键元素</font>，比如提取上面这个语句是查询 select，提取需要查询的表名为 tb_student，需要查询所有的列，查询条件是这个表的 id='1'。</li>\n<li><font color='red'>判断是否有语法错误</font>，比如关键词是否正确等等，如果检查没问题就执行下一步。</li>\n</ul>\n</li>\n<li><strong>优化器确定执行方案</strong>。上面的 SQL 语句，可以有两种执行方案：a. 先查询学生表中姓名为 “张三” 的学生，然后判断是否年龄是 18。b. 先找出学生中年龄 18 岁的学生，然后再查询姓名为 “张三” 的学生。那么<font color='red'>优化器根据优化算法选择执行效率最好的一个方案（优化器认为，有时候不一定最好）</font>。那么确认了执行计划后就准备开始执行了。</li>\n<li>执行语句之前，先进行权限校验，如果没有权限就会返回错误信息。<strong>如果有权限，执行器就会调用存储引擎接口，返回执行结果</strong>。</li>\n</ol>\n<h5 id=\"22-dml-更新语句\"><a class=\"anchor\" href=\"#22-dml-更新语句\">#</a> 2.2、DML 更新语句</h5>\n<blockquote>\n<p>以 update 为例</p>\n</blockquote>\n<p>针对 update 语句：</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">update</span> tb_student A <span class=\"token keyword\">set</span> A<span class=\"token punctuation\">.</span>age<span class=\"token operator\">=</span><span class=\"token string\">'19'</span> <span class=\"token keyword\">where</span> A<span class=\"token punctuation\">.</span>name<span class=\"token operator\">=</span><span class=\"token string\">' 张三 '</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p><font color='red'>这条语句也基本上会沿着上一个查询的流程走，只不过<strong>执行更新的时候肯定要记录日志</strong>，这就会引入日志模块了</font>。</p>\n<p>MySQL 自带的日志模块是 <strong><font color='cornflowerblue'>binlog（归档日志）</font></strong>，所有的存储引擎都可以使用。而常用的 InnoDB 引擎还自带了一个日志模块 <strong><font color='cornflowerblue'>redo log（重做日志）</font></strong>。</p>\n<p>我们就以 InnoDB 模式下来探讨这个语句的执行流程：</p>\n<ol>\n<li>\n<p><font color='red'>先查询到这一条数据</font>（根据 name = 张三），如果有缓存，也是会用到缓存。</p>\n</li>\n<li>\n<p>然后拿到查询的语句，<font color='red'>把 age 改为 19</font>，然后<font color='red'>调用存储引擎 API 接口，写入这一行数据</font>。InnoDB 引擎把数据保存在内存中，同时 **<font color='red'>InnoDB 引擎记录 redo log，此时 redo log 进入 prepare 状态</font>**。然后告诉执行器，执行完成了，随时可以提交。</p>\n</li>\n<li>\n<p><strong><font color='red'>执行器收到 InnoDB 引擎的通知后，记录 binlog</font></strong>。然后 **<font color='red'>执行器调用引擎接口，提交 redo log 为提交状态</font>**。</p>\n</li>\n<li>\n<p>更新完成。</p>\n</li>\n</ol>\n<hr />\n<p>为什么要用两个日志模块，用一个日志模块不行吗？</p>\n<p>这是因为最开始 MySQL 并没有 InnoDB 引擎（InnoDB 引擎是其他公司以插件形式插入 MySQL 的），MySQL 自带的引擎是 MyISAM。但是我们知道<font color='red'> redo log 是 InnoDB 引擎特有的，其他存储引擎都没有，这就导致会没有 crash-safe 的能力</font>（crash-safe 的能力即使数据库发生异常重启，之前提交的记录都不会丢失），<font color='red'>而 binlog 日志只能用来归档</font>。</p>\n<p>并不是说只用一个日志模块不可以，只是 **<font color='red'> InnoDB 引擎就是通过 redo log 来支持事务的</font>**。那么，又会有同学问，我用两个日志模块，但是不要这么复杂行不行，为什么 redo log 要引入 prepare 预提交状态？这里我们用反证法来说明下为什么要这么做？</p>\n<ul>\n<li>先写 redo log 直接提交，然后写 binlog：假设写完 redo log 后，机器挂了，binlog 日志没有被写入，那么机器重启后，这台机器会通过 redo log 恢复数据，但是这个时候 binlog 并没有记录该数据，后续进行机器备份的时候，就会丢失这一条数据，同时主从同步也会丢失这一条数据。</li>\n<li>先写 binlog，然后写 redo log：假设写完了 binlog，机器异常重启了，由于没有 redo log，本机是无法恢复这一条记录的，但是 binlog 又有记录，那么和上面同样的道理，就会产生数据不一致的情况。</li>\n</ul>\n<p><strong><font color='red'>redo log 两阶段提交的方式可以保证数据的一致性</font></strong>。写完 binlog 后，然后再提交 redo log 就会防止出现上述的问题，从而保证了数据的一致性。那么问题来了，有没有一个极端的情况呢？<font color='red'>假设 redo log 处于 prepare 状态，binlog 也已经写完了，这个时候发生了异常重启会怎么样呢？</font> 这个就要依赖于 MySQL 的处理机制了：</p>\n<ul>\n<li>判断 redo log 是否完整，如果判断是完整的，就立即提交。</li>\n<li>如果 redo log 只是 prepare，但不是 commit 状态，这个时候就会去判断 binlog 是否完整，如果完整就提交 redo log, 不完整就回滚事务。</li>\n</ul>\n<p>这样就解决了数据一致性的问题。</p>\n<h4 id=\"3-小结\"><a class=\"anchor\" href=\"#3-小结\">#</a> 3、小结</h4>\n<ul>\n<li>MySQL 主要分为 <font color='cornflowerblue'>Server 层</font>和<font color='cornflowerblue'>引擎层</font>，Server 层主要包括<font color='red'>连接器、查询缓存、分析器、优化器、执行器</font>，同时还有一个<font color='red'>归档日志模块（binlog）</font>，这个日志模块所有执行引擎都可以共用，<font color='red'>而重做日志模块（redolog）只有 InnoDB 有</font>。</li>\n<li>Server 层中各组件的功能：\n<ul>\n<li><strong>连接器</strong>：管理连接、权限验证；</li>\n<li><strong>查询缓存</strong>：命中缓存则直接返回结果；</li>\n<li><strong>分析器</strong>：对 SQL 进行词法分析、语法分析；</li>\n<li><strong>优化器</strong>：执行计划生成、选择索引；</li>\n<li><strong>执行器</strong>：操作引擎、返回结果；</li>\n<li><strong>存储引擎</strong>：存储数据、提供读写接口。</li>\n</ul>\n</li>\n<li>引擎层是插件式的，目前主要包括，<font color='red'>MyISAM、InnoDB、Memory</font>等。</li>\n<li><font color='gree'>查询语句</font>的执行流程如下：<font color='red'>权限校验 ---&gt; 查询缓存（如果命中，直接返回）---&gt; 分析器 ---&gt; 优化器 ---&gt;<strong> 权限校验</strong> ---&gt; 执行器 ---&gt; 引擎</font></li>\n<li><font color='gree'>更新语句</font>执行流程如下：<font color='red'>分析器 ----&gt; 权限校验 ----&gt; 执行器 ---&gt; 引擎 ---<strong>redo log (prepare 状态)</strong>---&gt;<strong>binlog</strong>---&gt;<strong>redo log (commit 状态)</strong></font></li>\n<li>笼统点的回答，<strong>一条 SQL 的执行过程</strong>：\n<ol>\n<li>客户端请求 -&gt;</li>\n<li>连接器（验证用户身份，给予权限） -&gt;</li>\n<li>查询缓存（存在缓存则直接返回，不存在则执行后续操作）-&gt;</li>\n<li>分析器（对 SQL 进行词法分析、语法分析） -&gt;</li>\n<li>优化器（选择最优的 SQL 执行方案） -&gt;</li>\n<li>执行器（先检查用户是否有执行权限，有的话才调用引擎接口，执行 SQL）-&gt;</li>\n<li>从引擎层获取数据返回（如果开启查询缓存，则会缓存查询结果）</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"mysql存储引擎\"><a class=\"anchor\" href=\"#mysql存储引擎\">#</a> MySQL 存储引擎</h3>\n<h4 id=\"mysql-体系结构\"><a class=\"anchor\" href=\"#mysql-体系结构\">#</a> MySQL 体系结构</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231125095453053.png\" alt=\"image-20231125095453053\" /></p>\n<ol>\n<li>\n<p>连接层：负责客户端和连接服务，例如连接处理、授权认证、及相关的安全方案</p>\n</li>\n<li>\n<p>服务层：负责 SQL 接口，SQL 的解析和优化，并完成缓存的查询，部分内置函数的执行。</p>\n<blockquote>\n<p>所有跨存储引擎的功能也在这一层实现，如过程、函数等。</p>\n</blockquote>\n</li>\n<li>\n<p>引擎层：负责 MySQL 中数据的存储和读取，根据需要选择合适的存储引擎，索引就是在这一层实现的。</p>\n</li>\n<li>\n<p>存储层：负责将数据持久化地存储到文件系统中，并完成与存储引擎的交互。</p>\n</li>\n</ol>\n<h4 id=\"存储引擎介绍\"><a class=\"anchor\" href=\"#存储引擎介绍\">#</a> 存储引擎介绍</h4>\n<p>存储引擎的特点：</p>\n<ul>\n<li>存储引擎就是<font color='red'>存储数据、<strong>建立索引</strong>、更新 / 查询数据</font>的实现方式。</li>\n<li>存储引擎<font color='red'>是基于表的</font>，而不是基于库的。</li>\n<li><font color='red'>默认的存储引擎是 InnoDB</font>。</li>\n</ul>\n<p>与存储引擎有关的 SQL 语句：</p>\n<ul>\n<li>\n<p>建表时指定存储引擎：</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">create</span> <span class=\"token keyword\">table</span> 表名<span class=\"token punctuation\">(</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">)</span> <span class=\"token keyword\">engine</span><span class=\"token operator\">=</span><span class=\"token keyword\">InnoDB</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure></li>\n<li>\n<p>查询建表语句：</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">show</span> <span class=\"token keyword\">create</span> <span class=\"token keyword\">table</span> 表名<span class=\"token punctuation\">;</span></pre></td></tr></table></figure></li>\n<li>\n<p>查看当前数据库支持的存储引擎：</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">show</span> engines<span class=\"token punctuation\">;</span></pre></td></tr></table></figure></li>\n</ul>\n<h4 id=\"常用的存储引擎\"><a class=\"anchor\" href=\"#常用的存储引擎\">#</a> <mark>常用的存储引擎</mark></h4>\n<p>重点介绍三种存储引擎 InnoDB、MyISAM、Memory 的特点。</p>\n<h5 id=\"innodb\"><a class=\"anchor\" href=\"#innodb\">#</a> InnoDB</h5>\n<p>（1）介绍</p>\n<p>MySQL 5.5 版本开始，<strong><font color='red'>默认使用 InnoDB 作为存储引擎</font></strong>。它<font color='red'>擅长处理事务，具有崩溃恢复的特性</font>，是一种兼顾<font color='red'>高可靠性、高性能</font>的通用存储引擎。</p>\n<p>（2）特点</p>\n<ul>\n<li><strong><font color='#B32015'>支持事务</font></strong>：\n<ul>\n<li>DML 操作遵循 ACID 模型</li>\n<li>实现了 SQL 标准定义了<font color='red'>四个隔离级别</font>，具有<font color='red'>提交 (commit) 和回滚 (rollback) 事务</font>的能力</li>\n<li>提供<font color='red'>一组用来记录事务性活动的日志文件</font></li>\n<li>InnoDB 默认使用的 REPEATABLE-READ（可重读）隔离级别是<font color='red'>可以解决幻读问题</font>发生的（基于 MVCC 和 Next-Key Lock）</li>\n</ul>\n</li>\n<li><strong><font color='#B32015'>支持行级锁</font></strong>：因此 InnoDB <font color='red'>并发写的性能更高</font></li>\n<li><strong><font color='#B32015'>支持外键</font></strong>：<font color='red'>能维护数据的一致性和完整性</font>（级联删除、级联更新），<font color='red'>但对性能有一定的损耗</font>。但阿里的《Java 开发手册》明令禁止使用外键！</li>\n</ul>\n<p>（3）存储文件</p>\n<ul>\n<li><code>.sdi</code> ：表结构</li>\n<li><mark> <code>.ibd 表空间文件</code> </mark>：数据、索引。每张 InnoDB 表对应一个 .ibd 表空间文件</li>\n</ul>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231125113620280.png\" alt=\"image-20231125113620280\" /></p>\n<p>（4）逻辑存储结构</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231125111944812.png\" alt=\"image-20231125111944812\" /></p>\n<ul>\n<li><strong>表空间（Tablespace）</strong>：即<font color='red'> ibd 文件</font>，由多个 Segment 组成</li>\n<li><strong>段（Segment）</strong>：分为<font color='red'>数据段、索引段、回滚段</font>等，由 InnoDB 自身管理，由多个 Extent 组成</li>\n<li><strong>区（Extent）</strong>：<font color='red'>固定大小为 1M，由 64 个连续的 Page 组成</font></li>\n<li><strong>页（Page）</strong>：<font color='red'>固定大小为 16 KB</font>，是 InnoDB 磁盘管理的最小单元</li>\n<li><strong>行（Row）</strong>：<font color='red'>存放行记录数据</font>，由最后一次事务的 id、回滚指针、各个字段的值组成</li>\n</ul>\n<h5 id=\"myisam\"><a class=\"anchor\" href=\"#myisam\">#</a> MyISAM</h5>\n<p>（1）介绍</p>\n<p>MyISAM 是 MySQL <font color='red'>早期的</font>默认存储引擎。</p>\n<p>（2）特点</p>\n<ul>\n<li>不支持事务与外键，仅支持表级锁</li>\n<li>灵活的 AUTO_INCREMENT 字段处理</li>\n<li>可被转换为压缩、只读表来节省空间</li>\n</ul>\n<p>（3）存储文件</p>\n<ul>\n<li><code>.sdi</code> ：表结构</li>\n<li><code>.MYD</code> ：数据</li>\n<li><code>.MYI</code> ：索引</li>\n</ul>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231125113606459.png\" alt=\"image-20231125113606459\" /></p>\n<h5 id=\"memory\"><a class=\"anchor\" href=\"#memory\">#</a> Memory</h5>\n<p>（1）介绍</p>\n<p>Memory 引擎表的 **<font color='red'>数据存储在内存中</font>**，由于受到硬件问题、或断电问题的影响，只能将这些表作为<font color='red'>临时表或缓存</font>使用。</p>\n<p>（2）特点</p>\n<ul>\n<li>数据存放在内存中</li>\n<li>默认采用 <font color='red'>hash 索引</font> 结构</li>\n</ul>\n<p>（3）文件</p>\n<ul>\n<li><code>.sdi</code> ：表结构</li>\n</ul>\n<h5 id=\"特点对比\"><a class=\"anchor\" href=\"#特点对比\">#</a> <mark>特点对比</mark></h5>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231125113958109.png\" alt=\"image-20231125113958109\" /></p>\n<p>MySQL 中常用的三种存储引擎分别是：InnoDB、MyISAM、MEMORY，区别如下：</p>\n<ul>\n<li><font color='cornflowerblue'>InnoDB</font>：<strong><font color='red'>支持事务处理、行级锁、外键，拥有崩溃修复能力、并发控制</font></strong>。如果需要<font color='red'>对事务的完整性要求比较高</font>（比如银行），<font color='red'>要求实现并发控制</font>（比如售票），那选择 InnoDB 有很大的优势。如果<font color='red'>需要频繁的更新、删除操作</font>的数据库，也可以选择 InnoDB，因为支持事务的提交（commit）和回滚（rollback）。</li>\n<li><font color='cornflowerblue'>MyISAM</font>：<strong><font color='red'>插入数据快，空间和内存使用比较低</font></strong>。如果表主要是用于<font color='red'>插入新记录和读出记录</font>，那么选择 MyISAM 能实现处理高效率。如果应用的<font color='red'>完整性、并发性要求比较低</font>，也可以使用。</li>\n<li><font color='cornflowerblue'>MEMORY</font>：<strong><font color='red'>所有的数据都在内存中，数据的处理速度快，但是安全性不高</font></strong>。如果<font color='red'>需要很快的读写速度，对数据的安全性要求较低</font>，可以选择 MEMOEY。它对表的大小有要求，<font color='red'>不能建立太大的表</font>。所以，这类数据库只使用在相对较小的数据库表。如果只是<font color='red'>临时存放数据，数据量不大，并且不需要较高的数据安全性</font>，可以选择将数据保存在内存中的 Memory 引擎，MySQL 中使用该引擎 **<font color='red'>作为临时表，存放查询的中间结果</font>**。</li>\n</ul>\n<h4 id=\"存储引擎选择\"><a class=\"anchor\" href=\"#存储引擎选择\">#</a> 存储引擎选择</h4>\n<ul>\n<li>InnoDB：适用于<font color='red'>较多的数据更新操作</font>，对<font color='red'>事务、并发、数据完整性</font>要求较高的核心数据。</li>\n<li>MyISAM：适用于<font color='red'>大量的数据读操作</font>，常被 MongoDB 取代。</li>\n<li>Memory：因为访问速度快，适用于<font color='red'>临时表、缓存</font>，但<font color='red'>对表大小有限制</font>（太大的表无法缓存到内存中），并且<font color='red'>无法保障数据的安全性</font>，常被 Redis 取代。</li>\n</ul>\n<h4 id=\"面试题\"><a class=\"anchor\" href=\"#面试题\">#</a> 面试题</h4>\n<h5 id=\"mysql-支持哪些存储引擎默认使用哪个\"><a class=\"anchor\" href=\"#mysql-支持哪些存储引擎默认使用哪个\">#</a> MySQL 支持哪些存储引擎？默认使用哪个？</h5>\n<p>MySQL 支持多种存储引擎，你可以通过  <code>show engines</code>  命令来查看 MySQL 支持的所有存储引擎。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20220510105408703.png\" alt=\"查看 MySQL 提供的所有存储引擎\" /></p>\n<p>从上图我们可以查看出，<strong>MySQL 5.5.5 之后，默认的存储引擎是 InnoDB</strong>。并且，<strong>只有 InnoDB 支持事务、行级锁、外键</strong>。</p>\n<p>MySQL 5.5.5 之前，MyISAM 是 MySQL 的默认存储引擎。5.5.5 版本之后，InnoDB 是 MySQL 的默认存储引擎。</p>\n<h5 id=\"mysql-存储引擎架构了解吗\"><a class=\"anchor\" href=\"#mysql-存储引擎架构了解吗\">#</a> MySQL 存储引擎架构了解吗？</h5>\n<p>MySQL 存储引擎采用的是<strong>插件式架构，支持多种存储引擎</strong>。我们甚至可以为不同的数据库表设置不同的存储引擎以适应不同场景的需要。<strong>存储引擎是基于表的，而不是数据库。</strong></p>\n<h5 id=\"myisam-和-innodb-有什么区别\"><a class=\"anchor\" href=\"#myisam-和-innodb-有什么区别\">#</a> <mark>MyISAM 和 InnoDB 有什么区别？</mark></h5>\n<p>MySQL 5.5 之前，MyISAM 引擎是 MySQL 的默认存储引擎，可谓是风光一时。</p>\n<p>虽然，MyISAM 的性能还行，各种特性也还不错（比如全文索引、压缩、空间函数等）。但是，<strong><font color='red'>MyISAM 不支持事务、行级锁和外键，而且最大的缺陷就是崩溃后无法自动恢复数据</font></strong>。</p>\n<p>MySQL 5.5 版本之后，InnoDB 是 MySQL 的默认存储引擎。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231108152443561.png\" alt=\"image-20231108152443561\" /></p>\n<p>言归正传！咱们下面还是来简单对比一下两者：</p>\n<p><strong>1. 是否支持事务</strong></p>\n<ul>\n<li>\n<p>MyISAM 不支持事务，但<font color='red'>每次查询都是原子的</font>；</p>\n</li>\n<li>\n<p>InnoDB 支持 ACID 的事务，实现了四种隔离级别。具有提交 ( <code>commit</code> ) 和回滚 ( <code>rollback</code> ) 事务的能力；</p>\n<blockquote>\n<p>并且 InnoDB 默认的 RR 隔离级别是可以解决幻读问题发生的（基于 MVCC 和 Next-Key Lock）。</p>\n</blockquote>\n</li>\n</ul>\n<p>关于 MySQL 事务的详细介绍：<a href=\"#==4%E7%A7%8D%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB==\">4 种隔离级别</a>。</p>\n<p><strong>2. 是否支持行级锁</strong></p>\n<ul>\n<li>MyISAM 只支持表级锁，即每次操作都是对整个表加锁；</li>\n<li>InnoDB 不仅支持表级锁，<font color='red'>还支持行级锁（默认），因此支持并发写</font>；</li>\n</ul>\n<p><strong>3. 是否支持外键</strong></p>\n<ul>\n<li>MyISAM 不支持外键约束；</li>\n<li><font color='red'>InnoDB 支持外键约束</font>；</li>\n</ul>\n<p>外键对于维护数据一致性非常有帮助，但是<font color='red'>外键对性能有一定的损耗</font>。因此，通常情况下，我们是不建议在实际生产项目中使用外键的，在业务代码中进行约束即可！</p>\n<p><strong>4. 是否存储表的总行数</strong></p>\n<ul>\n<li><font color='red'>MyISAM 存储表的总行数</font></li>\n<li>InnoDB 不存储表的总行数</li>\n</ul>\n<p><strong>5. 存储文件</strong></p>\n<ul>\n<li>一个 MyISAM 表有三个文件：表结构文件（.sdi)、数据文件（.MYD）、索引文件（.MYI）</li>\n<li>一个 InnoDB 表有两个文件：表结构文件（.sdi)、<font color='red'>数据和索引文件（ <code>.ibd 表空间文件</code> ）</font></li>\n</ul>\n<p><strong>6. 是否采用聚集索引</strong></p>\n<ul>\n<li><font color='red'>MyISAM 采用非聚集索引</font>，索引文件的数据域存储的是指向数据文件的指针。辅索引与主索引基本一致，但是辅索引不用保证唯一性；</li>\n<li><font color='red'>InnoDB 主键索采用聚集索引（索引的数域存数据文件本身），辅助索引的数域存储主键的值</font>。因此从索引查找数据时，需要先通过辅助索引找到主键值，再访问聚集索引。因此最好使用自增主键，防止插入数据时乱序，导致页分裂，性能低下。</li>\n</ul>\n<p><strong>7. 是否支持数据库异常崩溃后的安全恢复</strong></p>\n<ul>\n<li>\n<p>MyISAM 不支持</p>\n</li>\n<li>\n<p><font color='red'>InnoDB 支持数据库异常崩溃后的安全恢复</font></p>\n<blockquote>\n<p>使用 InnoDB 的数据库在异常崩溃后，数据库重新启动时会保证数据库恢复到崩溃前的状态。这个恢复的过程依赖于 InnoDB 的<strong>重做日志模块 <code>redo log</code> </strong>。</p>\n</blockquote>\n</li>\n</ul>\n<p><strong>8. 是否支持 MVCC</strong></p>\n<p><font color='red'>MVCC 可以看作是行级锁的一个升级，可以有效减少加锁操作，提高性能</font>。</p>\n<ul>\n<li>MyISAM 不支持，它连行级锁都不支持</li>\n<li><font color='red'>InnoDB 支持 MVCC</font></li>\n</ul>\n<p><strong>9. 索引实现不一样</strong></p>\n<p>虽然 MyISAM 引擎和 InnoDB 引擎<font color='red'>都是使用 B+Tree 作为索引结构</font>，但是两者的实现方式不太一样。</p>\n<ul>\n<li>\n<p>MyISAM 中，B+Tree 叶节点的 data 域存放的是<font color='gree'>数据记录的地址</font>。在索引检索的时候，首先按照 B+Tree 搜索算法搜索索引，如果指定的 Key 存在，则取出其 data 域的值，然后以 data 域的值为地址读取相应的数据记录。这被称为 **<font color='#B32015'>非聚集索引</font>**。</p>\n</li>\n<li>\n<p>InnoDB 中，<font color='red'>其数据文件本身就是（主）索引文件</font>，按 B+Tree 组织的一个索引结构，树的叶节点中 key 域是主键，data 域是<font color='gree'>完整的数据记录</font>，这被称为 **<font color='#B32015'>聚集索引</font><strong>。而<font color='red'>其余的索引都作为</strong>辅助索引 **</font>，树的叶节点中 key 域是非主键字段，data 域存放的是<font color='gree'>主键</font>。</p>\n<blockquote>\n<ul>\n<li>\n<p>在根据主索引搜索时，直接找到 key 所在的节点即可取出完整的数据记录；</p>\n</li>\n<li>\n<p>而在根据辅助索引查找时，则需要先取出主键的值，然后再走一遍主索引，称为<strong>二次查询（回表）</strong>。</p>\n</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n<p><strong>10. 性能有差别</strong></p>\n<ul>\n<li>\n<p>MyISAM 的读写不能并发，<font color='red'>它的处理能力跟核数没关系</font></p>\n</li>\n<li>\n<p><font color='red'>InnoDB 的性能比 MyISAM 更强大</font>，不管是在读写混合模式下还是只读模式下。且随着 CPU 核数的增加，InnoDB 的读写能力呈线性增长。</p>\n</li>\n</ul>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/innodb-myisam-performance-comparison.png\" alt=\"InnoDB 和 MyISAM 性能对比\" /></p>\n<p><strong>总结</strong> ：</p>\n<ul>\n<li><strong>InnoDB 支持事务处理，而 MyISAM 不支持</strong>。</li>\n<li><strong>InnoDB 支持行级锁，而 MyISAM 只支持表级锁</strong>。</li>\n<li><strong>InnoDB 支持外键，而 MyISAM 不支持</strong>。</li>\n<li><font color='red'>InnoDB 支持 MVCC</font>，而 MyISAM 不支持。</li>\n<li>虽然 MyISAM 引擎和 InnoDB 引擎都是使用 B+Tree 作为索引结构，但是<font color='red'>两者的索引实现方式不太一样</font>。</li>\n<li><font color='red'>InnoDB 支持数据库异常崩溃后的安全恢复</font>，而 MyISAM 不支持。</li>\n<li><font color='red'>InnoDB 的性能比 MyISAM 更强大</font>。</li>\n</ul>\n<p>最后，再分享一张图片给你，这张图片详细对比了常见的几种 MySQL 存储引擎。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/comparison-of-common-mysql-storage-engines.png\" alt=\"常见的几种 MySQL 存储引擎对比\" /></p>\n<h5 id=\"myisam-和-innodb-如何选择\"><a class=\"anchor\" href=\"#myisam-和-innodb-如何选择\">#</a> MyISAM 和 InnoDB 如何选择？</h5>\n<p><strong>大多数情况使用的都是 InnoDB 存储引擎</strong>。在某些读密集的情况下，使用 MyISAM 也是合适的。不过，前提是你的项目不介意<font color='red'> MyISAM 不支持事务、崩溃恢复</font>等缺点（可是～我们一般都会介意啊！）。</p>\n<h3 id=\"innodb-引擎\"><a class=\"anchor\" href=\"#innodb-引擎\">#</a> <mark>InnoDB 引擎</mark></h3>\n<p>从 MySQL 5.5 版本开始默认使用 InnoDB 作为存储引擎，它擅长处理事务，具有自动崩溃恢复的特性，在日常开发中使用非常广泛。</p>\n<h4 id=\"逻辑存储结构\"><a class=\"anchor\" href=\"#逻辑存储结构\">#</a> 逻辑存储结构</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231125111944812.png\" alt=\"image-20231125111944812\" /></p>\n<ul>\n<li><strong>表空间（Tablespace）</strong>：\n<ul>\n<li>是 InnoDB 逻辑存储结构的最高层</li>\n<li><font color='red'>每张表都有一个对应的表空间</font>（.ibd 文件），前提是用户启用了参数 innodb_file_per_table（在 8.0 版本中默认开启）</li>\n<li>即<font color='red'> ibd 文件</font>，由多个 Segment 组成</li>\n</ul>\n</li>\n<li><strong>段（Segment）</strong>：\n<ul>\n<li>分为<font color='red'>数据段（Leaf node segment）、索引段（Non-leaf node segment）、回滚段（Rollback segment）</font>等</li>\n<li>数据段即 B + 树的叶子节点，索引段即 B + 树的非叶子节点</li>\n<li>由 InnoDB 自身管理，由多个 Extent 组成</li>\n</ul>\n</li>\n<li><strong>区（Extent）</strong>：\n<ul>\n<li>是表空间的单元结构</li>\n<li><font color='red'>固定大小为 1M，由 64 个连续的 Page 组成</font></li>\n</ul>\n</li>\n<li><strong>页（Page）</strong>：\n<ul>\n<li>是 InnoDB 磁盘管理的最小单元</li>\n<li><font color='red'>固定大小为 16 KB</font></li>\n<li>为了保证页的连续性，InnoDB 一次性从磁盘申请 4~5 个区</li>\n</ul>\n</li>\n<li><strong>行（Row）</strong>：\n<ul>\n<li>InnoDB 的数据是按行存放的，Row 存放的就是<font color='red'>行记录数据</font></li>\n<li>组成情况：\n<ul>\n<li><font color='red'>Trx_id</font>：最后一次事务的 id。每次对某行记录改动时，都会把对应的事务 id 赋值给 Trx_id</li>\n<li><font color='red'>Roll_pointer</font>：回滚指针。每次对某行记录改动时，都会把旧版本写入 undo 日志中，该列相当于一个指针，指向该记录修改前的信息</li>\n<li><font color='red'>各个字段的值</font></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"架构\"><a class=\"anchor\" href=\"#架构\">#</a> <mark>架构</mark></h4>\n<h5 id=\"概述\"><a class=\"anchor\" href=\"#概述\">#</a> 概述</h5>\n<p>下面是 InnoDB 架构图，左侧为内存结构，右侧为磁盘结构。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231125133202521.png\" alt=\"image-20231125133202521\" /></p>\n<h5 id=\"内存结构\"><a class=\"anchor\" href=\"#内存结构\">#</a> 内存结构</h5>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231125133305129.png\" alt=\"image-20231125133305129\" /></p>\n<h6 id=\"buffer-pool缓冲池\"><a class=\"anchor\" href=\"#buffer-pool缓冲池\">#</a> Buffer Pool（缓冲池)</h6>\n<p>简称 BP，<font color='red'>是主内存中的一块区域</font>，<strong><font color='red'>作用是缓存表数据与索引</font></strong>。InnoDB 是基于磁盘文件存储的，为了弥补在物理硬盘与内存之间的 IO 访问速度差值，<font color='red'>需要把经常使用的数据加载到 BP 中</font>，避免每次访问都进行磁盘 IO。具体地，在执行增删改查时，<font color='red'>先操作 BP 中的数据（若无则从磁盘加载并缓存），然后再以一定频率刷新到磁盘</font>，从而减少磁盘 IO，加快处理速度。</p>\n<hr />\n<p><strong><font color='b'>Buffer Pool 的组成：</font></strong></p>\n<ul>\n<li><font color='cornflowerblue'>缓存页（Page）</font>：用于缓存<font color='red'>表数据与索引</font></li>\n<li><font color='cornflowerblue'>控制块</font>：用来描述缓存页，与缓存页一一对应。存储着<font color='red'>对应缓存页的所属表空间、数据页编号、以及在 Buffer Pool 中的地址</font>等信息。</li>\n</ul>\n<p><font color='red'>BP 以 Page 为单位，默认大小是 128 M</font>，Page 默认大小是 16 K，而<font color='red'>控制块的大小约为 Page 的 5%，大概是 800 byte</font>。</p>\n<blockquote>\n<p>注：BP 大小为 128M 指的就是缓存页（Page）的大小。而控制块则一般占 5%，所以每次会多申请 6M 的内存空间。</p>\n</blockquote>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/1680014940345-c4b81c48-94d1-46cd-97bd-fa4f242e91cf.jpeg\" alt=\"03.jpg\" /></p>\n<p>在专用服务器上，通常将多达 80％ 的物理内存分配给 Buffer Pool。可以通过以下参数设置：</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">show</span> variables <span class=\"token operator\">like</span> <span class=\"token string\">'innodb_buffer_pool_size'</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><hr />\n<p><strong><font color='b'>如何判断一个页是否缓存在 BP 中？</font></strong></p>\n<p>MySQL 中有一个哈希表数据结构，它的 k-v 结构是<font color='red'>（表空间号 + 数据页号，缓冲页对应的控制块）</font>。</p>\n<p>因此，当需要访问某个页的数据时，先从哈希表中根据 表空间号 + 数据页号 看看是否存在对应缓冲页的控制块。</p>\n<ul>\n<li>如果有，则直接使用；</li>\n<li>如果没有，就从<font color='red'>free 链表</font>中选出一个空闲的缓冲页，然后把磁盘中对应的页加载到该缓冲页的位置；</li>\n</ul>\n<img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/1680015043156-2f7c1410-3f41-4d8f-892c-d8384a8cd752.jpeg\" alt=\"10.jpg\" style=\"zoom:67%;\" />\n<hr />\n<p><strong><font color='b'>Page 分类</font></strong></p>\n<p><font color='red'>Buffer Pool 以 Page 为单位</font>，底层采用 <strong><font color='red'>链表</font></strong> 来管理 Page。在 InnoDB 访问表记录和索引时会在 Page 中缓存，以后使用时，可以减少磁盘 IO 操作。</p>\n<p>根据状态，将 Page 分为三种类型：</p>\n<ul>\n<li><font color='cornflowerblue'>free page</font>：空闲 page，未被使用。</li>\n<li><font color='cornflowerblue'>clean page</font>：被使用 page，但<font color='red'>数据在刷盘后没有被修改过</font>，与磁盘的数据保持一致。</li>\n<li><strong><font color='cornflowerblue'>dirty page</font></strong>：<font color='red'>脏页</font>，被使用 page，但<font color='red'>数据在刷盘后被修改过</font>，与磁盘的数据产生了不一致。</li>\n</ul>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/1680015221485-20f5036b-94b6-4125-8cf9-304a2deaf4e7.jpeg\" alt=\"05.jpg\" /></p>\n<hr />\n<p><strong><font color='b'>Page 管理</font></strong></p>\n<p>InnoDB 通过三种链表结构来维护和管理上述三类 Page 对应的<font color='red'>控制块</font>：</p>\n<ul>\n<li>\n<p><font color='cornflowerblue'>free list</font>：**<font color='red'>空闲</font>** 缓冲区，管理 free page</p>\n<ul>\n<li>Buffer Pool 的初始化过程中，先向操作系统申请连续的内存空间，然后把它划分成若干个【控制块 &amp; 缓冲页】的键值对</li>\n<li><font color='red'>free list 把所有<u>空闲的缓冲页对应的控制块</u>作为一个个的节点放到链表中</font></li>\n<li><font color='red'>基节点</font>: free list 中只有一个基节点，它不记录任何缓存页的信息（单独申请空间），只记录当前 free list 的头节点地址、尾节点地址，以及当前 free list 的节点个数</li>\n<li>从磁盘中将数据页进行缓存的流程：\n<ol>\n<li>从 free list 中取出一个空闲的控制块（对应缓冲页）</li>\n<li>根据数据页所在的表空间、页号之类的信息，填写该控制块的信息</li>\n<li>把该缓冲页对应的 free list 节点（即控制块）从链表中移除，表示该缓冲页已经被使用了</li>\n</ol>\n</li>\n</ul>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/1680015343358-c3d841dd-7c74-4b96-b01f-56109ffa94bc.jpeg\" alt=\"07.jpg\" /></p>\n</li>\n<li>\n<p><font color='cornflowerblue'>flush list</font>：**<font color='red'>需要刷盘</font>** 的缓冲区，管理 dirty page，按修改时间排序</p>\n<blockquote>\n<p>注：脏页既存在于 flush list，也在 LRU list 中，但是两种互不影响。<font color='red'>LRU list 负责管理 page 的可用性和释放，而 flush list 负责管理脏页的刷盘操作</font>。</p>\n</blockquote>\n<ul>\n<li>InnoDB 为了提高处理效率，在每次修改缓冲页后，并不是立刻把修改刷新到磁盘上，而是在未来的某个时间点进行刷盘操作。</li>\n<li>所以需要使用 flush list 存储脏页，凡是<font color='red'><u>被修改过的缓冲页对应的控制块</u></font>都会作为节点加入到 flush list 中。</li>\n<li>flush list 的结构与 free list 相似</li>\n</ul>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/1680015501833-6f3d1fcb-2894-4f32-b551-fd4495b9788c.jpeg\" alt=\"08.jpg\" /></p>\n</li>\n<li>\n<p><font color='cornflowerblue'>lru list</font>：**<font color='red'>正在使用</font>** 的缓冲区，管理 clean page 和 dirty page</p>\n<blockquote>\n<p>有点复杂，略了...</p>\n</blockquote>\n</li>\n</ul>\n<hr />\n<h6 id=\"change-buffer更改缓冲区\"><a class=\"anchor\" href=\"#change-buffer更改缓冲区\">#</a> Change Buffer（更改缓冲区）</h6>\n<blockquote>\n<p>略了...</p>\n</blockquote>\n<p>可以在 Buffer Pool 中进行合并处理，减少磁盘 IO。</p>\n<h6 id=\"adaptive-hash-index自适应hash索引\"><a class=\"anchor\" href=\"#adaptive-hash-index自适应hash索引\">#</a> Adaptive Hash Index（自适应 hash 索引）</h6>\n<blockquote>\n<p>参数：adaptive_hash_index</p>\n</blockquote>\n<p>InnoDB 会监控对表上各索引页的查询，<font color='red'>如果观察到 hash 索引可以提升索引页的查询速度，则自动建立 hash 索引</font>，无需人工参与，称之为自适应 hash 索引。</p>\n<ul>\n<li><font color='red'>hash 索引的等值匹配性能高于 B + 树的</font>：因为 hash 索引一般只需要一次 IO 即可；而 B + 树，可能需要几次匹配</li>\n<li>但是，<font color='red'>hash 索引又不适合做范围查询、模糊匹配等</font></li>\n</ul>\n<h6 id=\"log-buffer日志缓冲区\"><a class=\"anchor\" href=\"#log-buffer日志缓冲区\">#</a> Log Buffer（日志缓冲区）</h6>\n<p>作用：</p>\n<ul>\n<li>\n<p><font color='red'>用来保存要写入到磁盘中的日志数据（ <code>redo log</code> 、 <code>undo log</code> ），数据会定期刷新到磁盘中</font>，默认大小为 16MB。如果需要更新、插入或删除许多行的事务，增加日志缓冲区的大小可以节省磁盘 I/O</p>\n</li>\n<li>\n<p>用来优化每次更新操作之后都要写入 redo log 而产生的磁盘 IO 问题</p>\n</li>\n<li>\n<p>Log Buffer 空间满了后会自动写入磁盘。可以通过将 <code>innodb_log_buffer_size</code>  参数调大，以减少磁盘 IO 频率</p>\n</li>\n</ul>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/1680016593449-c23ff9d8-4c0f-48d4-9a55-b66b0a922895.jpeg\" alt=\"14.jpg\" /></p>\n<h5 id=\"磁盘结构\"><a class=\"anchor\" href=\"#磁盘结构\">#</a> 磁盘结构</h5>\n<blockquote>\n<p>实在是太抽象了，略了。。。</p>\n</blockquote>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231125133316649.png\" alt=\"image-20231125133316649\" /></p>\n<h6 id=\"system-tablespace系统表空间\"><a class=\"anchor\" href=\"#system-tablespace系统表空间\">#</a> System Tablespace (系统表空间)</h6>\n<h6 id=\"file-per-table-tablespaces每个表的文件表空间\"><a class=\"anchor\" href=\"#file-per-table-tablespaces每个表的文件表空间\">#</a> File-Per-Table Tablespaces（每个表的文件表空间）</h6>\n<h6 id=\"general-tablespaces通用表空间\"><a class=\"anchor\" href=\"#general-tablespaces通用表空间\">#</a> General Tablespaces（通用表空间）</h6>\n<h6 id=\"undo-tablespaces撤销表空间\"><a class=\"anchor\" href=\"#undo-tablespaces撤销表空间\">#</a> Undo Tablespaces（撤销表空间）</h6>\n<h6 id=\"temporary-tables临时表空间\"><a class=\"anchor\" href=\"#temporary-tables临时表空间\">#</a> Temporary Tables（临时表空间）</h6>\n<h6 id=\"doublewrite-buffer-files双写缓冲区文件\"><a class=\"anchor\" href=\"#doublewrite-buffer-files双写缓冲区文件\">#</a> Doublewrite Buffer Files（双写缓冲区文件）</h6>\n<h6 id=\"redo-log重做日志\"><a class=\"anchor\" href=\"#redo-log重做日志\">#</a> Redo Log（重做日志）</h6>\n<h5 id=\"后台线程\"><a class=\"anchor\" href=\"#后台线程\">#</a> 后台线程</h5>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231125133329251.png\" alt=\"image-20231125133329251\" /></p>\n<h6 id=\"master-thread核心后台线程\"><a class=\"anchor\" href=\"#master-thread核心后台线程\">#</a> Master Thread（核心后台线程）</h6>\n<p><font color='red'>负责调度其他线程</font>，还<font color='red'>负责将缓冲池中的数据异步刷新到磁盘中</font>，保持数据的一致性，还包括<font color='red'>脏页的刷新、合并插入缓存、undo 页的回收</font>。</p>\n<h6 id=\"io-threadio线程\"><a class=\"anchor\" href=\"#io-threadio线程\">#</a> IO Thread（IO 线程）</h6>\n<p>在 InnoDB 存储引擎中大量使用了 AIO 来处理 IO 请求，这样可以极大地提高数据库的性能，而 IO Thread 主要<font color='red'>负责这些 IO 请求的回调</font>。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231125150451252.png\" alt=\"image-20231125150451252\" /></p>\n<h6 id=\"purge-thread回收线程\"><a class=\"anchor\" href=\"#purge-thread回收线程\">#</a> Purge Thread（回收线程）</h6>\n<p>主要用于<font color='red'>回收事务已经提交了的 undo log</font>，在事务提交之后，undo log 可能不用了，就用它来回收。</p>\n<h6 id=\"page-cleaner-thread脏页刷新线程\"><a class=\"anchor\" href=\"#page-cleaner-thread脏页刷新线程\">#</a> Page Cleaner Thread（脏页刷新线程）</h6>\n<p>协助 Master Thread <font color='red'>刷新脏页</font>到磁盘，可以减轻 Master Thread 的工作压力，减少阻塞。</p>\n<h4 id=\"事务原理\"><a class=\"anchor\" href=\"#事务原理\">#</a> <mark>事务原理</mark></h4>\n<h5 id=\"事务基础\"><a class=\"anchor\" href=\"#事务基础\">#</a> 事务基础</h5>\n<p>关于事务的基础知识，具体可见<a href=\"#==MySQL%E4%BA%8B%E5%8A%A1==\"> MySQL 事务</a>。</p>\n<ul>\n<li>\n<p><strong>原子性</strong>（ <code>Atomicity</code> ）：事务是不可分割的最小操作单元，内部的所有操作要么全部成功，要么全部失败（要么全部 commit 成功，要么全部失败 rollback）；</p>\n</li>\n<li>\n<p><strong>一致性</strong>（ <code>Consistency</code> ）：事务完成前后，数据库必须保持一致状态，即都是合理的数据状态。例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；</p>\n</li>\n<li>\n<p><strong>隔离性</strong>（ <code>Isolation</code> ）：数据库提供的隔离机制，可以保证事务在不受外部并发操作影响的独立环境下运行。即并发访问数据库时，一个事务不会干扰其他事务的运行，该事务所做的修改在最终提交前，对其他事务是不可见的。各并发事务之间，数据库是独立的；</p>\n</li>\n<li>\n<p><strong>持久性</strong>（ <code>Durability</code> ）：事务一旦提交，它对数据库中数据的更改就是持久的。即使数据库发生故障，这种更改也不会丢失。</p>\n</li>\n</ul>\n<p>那么实际上，<font color='red'>InnoDB 引擎是如何保证事务的四大特性（ACID）的呢？</font>而对于这四大特性，实际上分为两个部分：</p>\n<ul>\n<li>原子性（A）、一致性（C）、持久性（D）：由 InnoDB 中的 <font color='red'>redo log 日志和 undo log 日志</font>来保证</li>\n<li>隔离性（I）：通过数据库的<font color='red'>锁和 MVCC</font>来保证的</li>\n</ul>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231125152532382.png\" alt=\"image-20231125152532382\" /></p>\n<h5 id=\"redo-log\"><a class=\"anchor\" href=\"#redo-log\">#</a> redo log</h5>\n<p>redo log 是重做日志，<strong><font color='red'>记录事务提交时数据页的物理修改</font></strong>。当刷新脏页到磁盘发生错误时，进行数据恢复，用来实现事务的持久性。由两部分组成：</p>\n<ul>\n<li><font color='cornflowerblue'>redo log buffer</font>：<font color='red'>在内存中</font>的缓冲区</li>\n<li><font color='cornflowerblue'>redo log file</font>：<font color='red'>在磁盘中</font>的文件</li>\n</ul>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/1680016593449-c23ff9d8-4c0f-48d4-9a55-b66b0a922895.jpeg\" alt=\"14.jpg\" /></p>\n<p><img data-src=\"https://oss.javaguide.cn/github/javaguide/03.png\" alt=\"img\" /></p>\n<hr />\n<p><strong><font color='b'>如果没有 redo log，可能会存在什么问题？</font></strong></p>\n<p>在 InnoDB 中的内存结构中，主要的内存区域就是 Buffer Pool（缓冲池），在缓冲池中缓存了很多的数据页。</p>\n<p>当我们在一个事务中，执行多个增删改的操作时，InnoDB 会先操作缓冲池中的数据，如果缓冲区没有对应的数据，会通过后台线程将磁盘中的数据加载到缓冲区中，然后修改缓冲池中的数据，修改后的数据页我们称为<font color='red'>脏页</font>。而脏页则会在一定的时机，通过后台线程刷新到磁盘中，从而保证缓冲区与磁盘的数据一致。</p>\n<p>但缓冲区的脏页数据并不是实时刷新的，而是一段时间之后将缓冲区的数据刷新到磁盘中，<font color='red'>假如将脏页刷盘的过程出错了，但提示给用户事务提交成功，而数据却没有持久化下来，这就出现问题了，<strong>没有保证事务的持久性</strong></font>。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231126165158628.png\" alt=\"image-20231126165158628\" /></p>\n<p><strong><font color='b'>redo log 是如何确保事务的持久性的？</font></strong></p>\n<p>有了 redo log 之后，</p>\n<ul>\n<li><font color='red'>当对缓冲区的数据进行增删改之后，会首先将对缓冲页的变化记录在  <code>redo log buffer</code>  中</font></li>\n<li><font color='red'>在<u>每次</u>事务提交时，会将内存中的  <code>redo log buffer</code>  的数据刷新到磁盘文件  <code>redo log file</code>  中</font></li>\n<li>过一段时间之后，<strong><font color='red'>如果刷新缓冲区的脏页到磁盘时发生错误，此时就可以借助于 redo log 进行数据恢复，这样就保证了事务的持久性</font></strong></li>\n<li>而<font color='red'>如果脏页成功刷新到磁盘，或者涉及到的数据已经落盘，此时 redo log 就可以删除了，所以存在的两个 redo log 文件是循环写的</font></li>\n</ul>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231126165234873.png\" alt=\"image-20231126165234873\" /></p>\n<p><strong><font color='b'>为什么每次提交事务，要刷新 redo log 到磁盘中，而不是直接将 buffer pool 中的脏页刷新到磁盘呢？</font></strong></p>\n<p>因为在业务操作中，我们<font color='red'>操作数据一般都是随机读写磁盘的</font>，而不是顺序读写磁盘。 而 redo log 在向磁盘文件中写入数据，<font color='red'>日志文件都是顺序写的</font>。<strong><font color='red'>顺序写的效率，要远大于随机写</font></strong>。这种<font color='red'>先写日志的方式</font>，称之为 <code>WAL（Write-Ahead Logging）</code> 。</p>\n<hr />\n<h5 id=\"undo-log\"><a class=\"anchor\" href=\"#undo-log\">#</a> undo log</h5>\n<p>undo log（回滚日志）是在执行 DML 语句的时候产生的便于数据回滚的日志，用于<font color='red'>记录数据被修改前的信息</font>。</p>\n<p>与 redo log 记录物理日志不一样，<font color='red'>undo log 是逻辑日志，记录的是逻辑相反的操作信息</font>。可以认为当 delete 一条记录时，undo log 中会记录一条对应的 insert 记录；反之亦然，当 update 一条记录时，它记录一条对应相反的 update 记录。<font color='red'>当执行 rollback 时，就可以从 undo log 中的逻辑记录读取到相应的内容并进行回滚</font>。</p>\n<p>undo log 主要有两个作用：</p>\n<ol>\n<li>\n<p><strong><font color='red'>提供事务回滚（保证事务的原子性）</font></strong>：当事务回滚时将数据恢复到修改前的样子</p>\n</li>\n<li>\n<p><strong><font color='red'>MVCC（多版本并发控制）</font></strong>：当读取记录时，若该记录被其他事务占用，或者当前版本对该事务不可见，则可以通过 undo log <font color='red'>读取之前的版本数据</font>，以此实现非锁定读</p>\n</li>\n</ol>\n<p>undo log 销毁：undo log 在事务执行时产生，事务提交时，并不会立即删除 undo log，因为这些日志可能还用于 MVCC。</p>\n<p>undo log 存储：undo log 采用段的方式进行管理和记录，存放在前面介绍的 rollback segment 回滚段中，内部包含 1024 个 undo log segment。</p>\n<h5 id=\"innodb-如何实现事务\"><a class=\"anchor\" href=\"#innodb-如何实现事务\">#</a> <mark>InnoDB 如何实现事务</mark></h5>\n<p>InnoDB 通过 Buffer Pool、Log Buffer、Redo Log、Undo Log 来实现事务，以一条 update 语句为例：</p>\n<ol>\n<li>\n<p>InnoDB 在收到一条 update 语句后，会先根据条件找到数据所在的页，并将该页缓存在  <code>Buffer Pool</code>  中</p>\n</li>\n<li>\n<p>针对 update 语句生成  <code>Undo Log</code>  日志，用于后续事务回滚</p>\n</li>\n<li>\n<p><code>执行器</code> 执行 update 语句，修改 Buffer Pool 中的数据，即内存中的数据</p>\n</li>\n<li>\n<p>针对 update 语句生成一个  <code>Redo Log</code>  对象，并写入  <code>Log Buffer</code>  中</p>\n</li>\n<li>\n<p>如果事务提交，那么将 Log Buffer 中的 Redo Log 对象持久化到磁盘中的  <code>Redo Log File</code>  中</p>\n<blockquote>\n<p>后续还有其他机制将 Buffer Pool 中所修改的数据页持久化到磁盘中（脏页刷盘）</p>\n</blockquote>\n</li>\n<li>\n<p>如果事务回滚，则利用 Undo Log 日志进行回滚</p>\n</li>\n</ol>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/1680016593449-c23ff9d8-4c0f-48d4-9a55-b66b0a922895.jpeg\" alt=\"14.jpg\" /></p>\n<h4 id=\"对-mvcc-的实现方式\"><a class=\"anchor\" href=\"#对-mvcc-的实现方式\">#</a> <mark>对 MVCC 的实现方式</mark></h4>\n<h5 id=\"innodb-为什么要采用-mvcc快照读\"><a class=\"anchor\" href=\"#innodb-为什么要采用-mvcc快照读\">#</a> <mark>InnoDB 为什么要采用 MVCC 快照读 ？</mark></h5>\n<p>这是因为一个事务的操作有可能成功 commit，也有可能失败 rollback。在一个事务 commit 之前，被其他事务读到还没提交的变更记录，会产生数据不一样的现象（<font color='red'>脏读</font>），这种情况就是 InnoDB 最低的隔离级别 READ UNCOMMITTED，可以读到没有 commit 的数据。</p>\n<p><font color='red'>那么如果想要不产生脏读，容易想到的是采用锁的方式</font>，当一个事务更改某行记录，就加上锁，其他并发事务等待该事务执行完毕才能读取到该行记录。但是这样做的话 **<font color='red'>会产生大量的锁占用与等待，效率是非常低下的，因此 InnoDB 采用了 MVCC 的方式</font>**。</p>\n<p>简单的说，在 RU 隔离级别下，若 A 事务变更某行记录，InnoDB 会产生对应的 undo log，如果接下来 A 事务进行回滚，InnoDB 可以根据 undo log 将记录回滚到事务开始之前的状态。在 A 事务没有结束时，如果 B 事务来查询该行记录，B 事务会根据 A 事务变更后的记录值（在内存中）加上 undo log “计算” 出 A 事务开始前的该行记录值，从而读取到该行记录的一个快照，其中<font color='red'>并不会产生锁与等待</font>。</p>\n<p>如果是 RR 的隔离级别（默认隔离级别），B 事务进行过程中看到的始终会是 B 事务开始前的记录行快照信息，不管 B 事务进行过程中 A 事务有没有完成；</p>\n<p>如果是 RC 的隔离级别，B 事务进行过程中，可以看到 A 事务提交对记录行修改值（即如果 A 事务没有完成，B 查询到的是 A 事务开始前的记录值，如果 A 事务完成了，B 事务查询到的是 A 事务完成后的记录值），在这种情况下会产生不可重复读的现象，即同一次事务中多次查询看到的结果会不一样。</p>\n<h5 id=\"基本概念\"><a class=\"anchor\" href=\"#基本概念\">#</a> 基本概念</h5>\n<h6 id=\"快照读一致性u非锁定读u\"><a class=\"anchor\" href=\"#快照读一致性u非锁定读u\">#</a> 快照读（一致性<u>非锁定读</u>）</h6>\n<p>就是<font color='red'>简单的  <code>SELECT</code>  语句（不加锁）</font>，是非阻塞读。</p>\n<p><font color='red'>快照即记录的历史版本</font>，每行记录可能存在多个历史版本（多版本技术），读取的是记录数据的可见版本。</p>\n<p>快照读的情况下，如果读取的记录正在执行 UPDATE/DELETE 操作，<font color='red'>读取操作不会因此去等待记录上 X 锁的释放，而是会去读取行的一个快照（历史数据）</font>。</p>\n<p>只有在事务隔离级别 RC (读取已提交) 和 RR（可重读）下，InnoDB 才会使用快照读（一致性非锁定读）：</p>\n<ul>\n<li><font color='gree'>在 RC 级别下</font>，快照读总是<font color='red'>读取被锁定行的最新一份快照数据</font>。</li>\n<li><font color='gree'>在 RR 级别下</font>，快照读总是 **<font color='red'>读取本事务开始时的行数据版本（快照）</font>**。</li>\n<li><font color='gree'>在 SERIALIZABLE 级别下</font>，<font color='red'>快照读退化成当前读</font>。</li>\n</ul>\n<p>快照读比较<font color='red'>适合对数据一致性要求不是特别高，且追求极致性能的业务场景</font>。</p>\n<hr />\n<p>对于快照读的实现，通常做法是加一个 **<font color='red'>版本号或者时间戳字段</font>**，</p>\n<ul>\n<li>更新数据时，<font color='red'>版本号 + 1 或者更新时间戳</font>。</li>\n<li>查询数据时，将当前可见的版本号与对应记录的版本号进行比对，<font color='red'>如果记录的版本小于可见版本，则表示该记录可见</font></li>\n</ul>\n<p>在 InnoDB 中，<font color='cornflowerblue'>多版本控制（multi versioning）</font>就是对快照读的实现。如果读取的行正在执行  <code>DELETE</code>  或  <code>UPDATE</code>  操作，这时读取操作不会去等待行上 X 锁的释放。相反地，InnoDB 会去读取行的一个快照数据，对于这种读取历史数据的方式，我们叫它快照读（snapshot read）。</p>\n<h6 id=\"当前读一致性u锁定读u\"><a class=\"anchor\" href=\"#当前读一致性u锁定读u\">#</a> 当前读（一致性<u>锁定读</u>）</h6>\n<p><font color='red'>读取行记录时会添加 X 锁或 S 锁</font>，以防其他并发事务修改当前记录，因此 **<font color='red'>读取的是记录的最新版本</font>**，是悲观锁的一种操作。</p>\n<ul>\n<li><code>select ... lock in share mode</code> ：对记录加  <code>S</code>  锁，其它事务也可以加  <code>S</code>  锁，但如果加  <code>X</code>  锁则会被阻塞</li>\n<li><code>select ... for update</code> 、 <code>insert</code> 、 <code>update</code> 、 <code>delete</code> ：对记录加  <code>X</code>  锁，且其它事务不能加任何锁</li>\n</ul>\n<p>当前读的一些常见 SQL 语句类型如下：</p>\n<blockquote>\n<p><code>select ... for update</code>  仅适用于 InnoDB，且必须在事务块 (BEGIN/COMMIT) 中才能生效。在进行事务操作时，通过 for update 语句，MySQL 会对查询结果集中每行数据都添加 **<font color='#B32015'>排他锁</font>**，<font color='red'>其他线程对该记录的更新与删除操作都会阻塞</font>。排他锁包含行锁、表锁。</p>\n<p>InnoDB 行锁是通过给索引上的索引项加锁来实现的，只有通过索引条件检索数据，InnoDB 才使用行级锁，否则，InnoDB 将使用表锁。</p>\n<p><code>select ... for share</code> ：我选择一些记录，这些记录可以 share，<font color='red'>其他事务也可以读</font>，但是如果你要修改，不好意思，我加了一个 s 锁，你是<font color='red'>不可以修改</font>的。这个语句的应用场景之一是 **<font color='red'>用来读取到最新的数据</font>**。</p>\n<p><code>select ... for update</code> ：我选择一些记录，这些 select 的记录是我下一步要 update 的，你要读或者修改这些记录，不好意思，我加的是 x 锁，你<font color='red'>读不了也改不了</font>。只有我当前事务提交了，这些记录你才可以读到或者修改。这个语句的应用场景之一是 **<font color='red'>为了防止更新丢失</font>**。</p>\n</blockquote>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># 对读的记录加一个 S 锁（MySQL 5.7 和 MySQL 8.0）</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">SELECT</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">LOCK</span> <span class=\"token operator\">IN</span> <span class=\"token keyword\">SHARE</span> <span class=\"token keyword\">MODE</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token comment\"># 对读的记录加一个 S 锁（MySQL 8.0）</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">SELECT</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">FOR</span> <span class=\"token keyword\">SHARE</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token comment\"># 对读的记录加一个 X 锁</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token keyword\">SELECT</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">FOR</span> <span class=\"token keyword\">UPDATE</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token comment\"># 对修改的记录加一个 X 锁</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token keyword\">INSERT</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token keyword\">UPDATE</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token keyword\">DELETE</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr></table></figure><hr />\n<p>在快照读下，即时读取的记录已被其它事务加上  <code>X</code>  锁，这时记录也是可以被读取的，即读取的快照数据。上面说了，在 RR 隔离级别下 MVCC 防止了部分幻读。这里的 “部分” 是指在 <code>快照读</code> 情况下，只能读取到第一次查询之前所插入的数据（根据 Read View 判断数据可见性，Read View 在第一次查询时生成）。</p>\n<p>但是！<font color='red'>如果是 <code>当前读</code> ，每次读取的都是最新数据，这时如果两次查询中间有其它事务插入数据，就会产生幻读</font>。</p>\n<p>所以，<strong><font color='#B32015'>InnoDB 在实现 RR 隔离级别时，如果执行的是 <code>当前读</code> ，则会对读取的记录使用  <code>临键锁（Next-key Lock）</code> ，来防止其它并发事务在间隙间插入数据</font></strong>。</p>\n<hr />\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231127104552414.png\" alt=\"image-20231127104552414\" /></p>\n<p>在测试中，即使是在默认的 RR 隔离级别下，事务 A 中依然可以读取到事务 B 最新提交的内容，因为在查询语句后面加上了  <code>lock in share mode</code>  共享锁，此时是当前读操作。当然，当我们加排他锁的时候，也是当前读操作。</p>\n<h6 id=\"mvcc多版本并发控制\"><a class=\"anchor\" href=\"#mvcc多版本并发控制\">#</a> MVCC（多版本并发控制）</h6>\n<p>MVCC 的全称是  <code>Multi-Version Concurrency Control</code> ，是一种并发控制机制，用于在多个并发事务同时读写数据库时保持数据的一致性和隔离性。<strong><font color='#B32015'>MVCC 在每个数据行上维护多个版本的数据，形成一条由 undo log 组成的版本链</font></strong>，使得读写操作没有冲突。</p>\n<p>MVCC 解决的问题：<strong><font color='#B32015'>读 — 写冲突的无锁并发控制</font></strong>。为事务分配单向增长的时间戳，为每个数据修改保存一个版本（与事务时间戳相关联）。读操作只读取该事务开始前的数据库快照。</p>\n<ul>\n<li>\n<p><font color='red'>能解决并发读 - 写问题</font>：可以做到读操作不阻塞写操作，同时写操作也不会阻塞读操作</p>\n</li>\n<li>\n<p><font color='red'>能解决脏读、幻读、不可重复读</font>等一致性问题，但<font color='red'>不能解决写 - 写中的修改丢失问题</font>。</p>\n</li>\n</ul>\n<hr />\n<p>1、读操作（SELECT）：</p>\n<p>当一个事务执行读操作时，它会使用<font color='red'>快照读取</font>。<strong><font color='red'>在 InnoDB 默认的 RR 隔离级别下，快照读取是基于事务开始时数据库中的状态创建的</font></strong>，因此事务不会读取到其他事务尚未提交的修改。具体工作情况如下：</p>\n<blockquote>\n<p>在 RR 级别下</p>\n</blockquote>\n<ul>\n<li>对于读取操作，事务会查找符合条件的数据行，并选择符合事务开始时间的数据版本进行读取。</li>\n<li>如果某个数据行有多个版本，事务会<font color='red'>选择不晚于事务开始时间的最新版本</font>，确保事务只读取在它开始之前已经存在的数据。</li>\n<li><font color='red'>事务读取的是快照数据，因此其他并发事务对数据行的修改不会影响当前事务的读取操作，当前事务对快照数据的修改也不会影响实际的数据行</font>。</li>\n</ul>\n<p>2、写操作（INSERT、UPDATE、DELETE）：</p>\n<p><strong><font color='red'>当一个事务执行写操作时，它会为要修改的数据行创建一个新的版本（快照数据），对其修改后再写入数据库</font></strong>。具体工作情况如下：</p>\n<ul>\n<li>对于写操作，事务会为要修改的数据行创建一个新的版本，并将修改后的数据写入新版本。</li>\n<li><font color='red'>新版本的数据会带有当前事务的版本号</font>，以便其他事务能够正确读取相应版本的数据。</li>\n<li><font color='red'>原始版本的数据仍然存在，供其他事务使用快照读取，这保证了其他事务不受当前事务的写操作影响</font>。</li>\n</ul>\n<p>3、事务的提交和回滚（COMMIT、ROLLBACK）：</p>\n<ul>\n<li>当一个事务提交时，它所做的修改将成为数据库的最新版本，并且对其他事务可见。</li>\n<li>当一个事务回滚时，它所做的修改将被撤销，对其他事务不可见。</li>\n</ul>\n<p>4、版本的回收：</p>\n<p><font color='red'>为了防止数据库中的版本无限增长，MVCC 会定期进行版本的回收。回收机制会删除已经不再需要的旧版本数据，从而释放空间</font>。</p>\n<p><strong><font color='#B32015'>MVCC 通过<u>创建数据的多个版本</u>和使用<u>快照读取</u>来实现并发控制</font></strong>。<font color='red'>读操作使用旧版本数据的快照，写操作创建新版本，并确保原始版本仍然可用</font>。这样，不同的事务可以在一定程度上并发执行，而不会相互干扰，从而提高了数据库的并发性能和数据一致性。</p>\n<h5 id=\"innodb-对-mvcc-的实现方式\"><a class=\"anchor\" href=\"#innodb-对-mvcc-的实现方式\">#</a> <mark>InnoDB 对 MVCC 的实现方式</mark></h5>\n<p>InnoDB 对 MVCC 的具体实现依赖于：<strong>隐藏字段、ReadView、undo log</strong>。</p>\n<ul>\n<li>在内部实现中，InnoDB 通过数据行的  <code>DB_TRX_ID</code>  和  <code>ReadView</code>  来判断数据的可见性。</li>\n<li>如不可见，则通过数据行的  <code>DB_ROLL_PTR</code>  找到  <code>undo log</code>  中的历史版本。</li>\n<li>每个事务读到的数据版本可能是不一样的，在同一个事务中，用户只能看到该事务创建  <code>ReadView</code>  之前已经提交的修改和该事务本身做的修改。</li>\n</ul>\n<blockquote>\n<p>这里看不懂没关系，先看下文</p>\n</blockquote>\n<h6 id=\"隐藏字段\"><a class=\"anchor\" href=\"#隐藏字段\">#</a> 隐藏字段</h6>\n<p>InnoDB 为每行记录添加了三个隐藏字段：</p>\n<blockquote>\n<p>前两个字段是肯定会添加的，是否添加最后一个字段 DB_ROW_ID，得看当前表有没有主键或者唯一非空索引，若有则不会添加该隐藏字段。</p>\n</blockquote>\n<ul>\n<li>\n<p><code>DB_TRX_ID</code> （6 字节）：<font color='red'>插入这行记录或者最后一次修改该记录的事务 id</font>；</p>\n<blockquote>\n<p>delete 操作在内部被视为更新（即逻辑删除），会在记录头 Record header 中的 deleted_flag 字段将其标记为已删除</p>\n</blockquote>\n</li>\n<li>\n<p><code>DB_ROLL_PTR</code> （7 字节）：<font color='red'>回滚指针，指向该行对应的 undo log，即上一个版本（存于回滚段中）</font></p>\n<blockquote>\n<p>如果该行记录未被更新，则为空；</p>\n</blockquote>\n</li>\n<li>\n<p><code>DB_ROW_ID</code> （6 字节）：<font color='red'>当前行记录隐含的自增 ID</font>，如果当前表没有设置主键且没有唯一非空索引时，InnoDB 会使用 DB_ROW_ID 来<strong>生成一个聚集索引</strong>；</p>\n</li>\n</ul>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/816762-20210616144139574-1740941399.jpg\" alt=\"img\" /></p>\n<p>如上图，DB_ROW_ID 是数据库默认为该行记录生成的唯一隐式主键，DB_TRX_ID 是当前操作该记录的事务 ID，而 DB_ROLL_PTR 是一个回滚指针，用于配合 undo log，指向上一个旧版本。</p>\n<h6 id=\"undo-log-2\"><a class=\"anchor\" href=\"#undo-log-2\">#</a> undo log</h6>\n<p><strong><font color='b'>undo log 介绍</font></strong></p>\n<p>undo log（回滚日志）是在执行 DML 语句的时候产生的便于数据回滚的日志，用于<font color='red'>记录数据被修改前的信息</font>。</p>\n<p>与 redo log 记录物理日志不同，<font color='red'>undo log 是逻辑日志，记录的是逻辑相反的操作信息</font>。因此当执行 rollback 时，就可以直接从 undo log 中的逻辑记录读取到相应的内容并进行回滚。</p>\n<p>undo log 主要有两个作用：</p>\n<ol>\n<li>\n<p><strong><font color='red'>提供事务回滚（保证事务的原子性）</font></strong>：当事务回滚时将数据恢复到修改前的样子</p>\n</li>\n<li>\n<p><strong><font color='red'>MVCC（多版本并发控制）</font></strong>：当读取记录时，若该记录被其他事务占用，或者当前版本对该事务不可见，则可以通过 undo log <font color='red'>读取之前的版本数据</font>，以此实现非锁定读</p>\n</li>\n</ol>\n<p>在 InnoDB 中 undo log 分为两种：</p>\n<ul>\n<li>\n<p><code>insert undo log</code> ：在<font color='red'> insert 操作</font>中产生的 undo log。因为 insert 操作的记录只对事务本身可见，只在回滚时需要，因此<font color='red'> insert undo log 在事务提交后可以直接删除，不需要进行 purge 操作</font>。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/317e91e1-1ee1-42ad-9412-9098d5c6a9ad-dc43aed3.png\" alt=\"img\" /></p>\n<center>（insert 时的数据初始状态）</center>\n</li>\n<li>\n<p><code>update undo log</code> ：<font color='red'>update 或 delete 操作</font>中产生的 undo log。update undo log 不仅在回滚时需要，可能需要提供 MVCC 机制，因此不能在事务提交时就进行删除。<font color='red'>事务提交时放入 undo log 链表，等待 purge 线程进行最后的删除</font>。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/c52ff79f-10e6-46cb-b5d4-3c9cbcc1934a-b60a6e78.png\" alt=\"img\" /></p>\n<center>（数据第一次被修改时）</center>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/6a276e7a-b0da-4c7b-bdf7-c0c7b7b3b31c-2e496ea1.png\" alt=\"img\" /></p>\n<center>（数据第二次被修改时）</center>\n</li>\n</ul>\n<hr />\n<p><strong><font color='b'>版本链</font></strong></p>\n<p><strong><font color='red'>不同事务或者相同事务对同一记录行的修改，会使该记录行的 undo log 成为一条链表，链首就是最新的记录，链尾就是最早的旧记录</font></strong>。</p>\n<p>有一张表原始数据为：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231128102126782.png\" alt=\"image-20231128102126782\" /></p>\n<blockquote>\n<p><code>DB_TRX_ID</code> ：代表最近修改事务 ID，记录插入这条记录或最后一次修改该记录的事务 ID，是自增的。<br />\n <code>DB_ROLL_PTR</code> ：由于这条数据是刚刚才插入的，没有被更新过，所以该字段值为 null。</p>\n</blockquote>\n<p>然后，有四个并发事务同时在访问这张表。</p>\n<p>A. 第一步：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231128102320440.png\" alt=\"image-20231128102320440\" /></p>\n<p>当事务 2 执行第一条修改语句时：</p>\n<ol>\n<li>先记录 undo log 日志，记录数据变更之前的样子；</li>\n<li>然后更新记录，并且记录本次操作的事务 ID 与回滚指针。其中回滚指针用来指定如果发生回滚，回滚到哪一个版本；</li>\n</ol>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231128102520925.png\" alt=\"image-20231128102520925\" /></p>\n<p>B. 第二步</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231128102822352.png\" alt=\"image-20231128102822352\" /></p>\n<p>当事务 3 执行第一条修改语句时：</p>\n<ol>\n<li>先记录 undo log 日志，记录数据变更之前的样子；</li>\n<li>然后更新记录，并且记录本次操作的事务 ID 与回滚指针；</li>\n</ol>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231128103013206.png\" alt=\"image-20231128103013206\" /></p>\n<p>C. 第三步</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231128103104640.png\" alt=\"image-20231128103104640\" /></p>\n<p>当事务 4 执行第一条修改语句时：</p>\n<ol>\n<li>先记录 undo log 日志，记录数据变更之前的样子；</li>\n<li>然后更新记录，并且记录本次操作的事务 ID 与回滚指针；</li>\n</ol>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231128103205546.png\" alt=\"image-20231128103205546\" /></p>\n<h6 id=\"read-view\"><a class=\"anchor\" href=\"#read-view\">#</a> Read View</h6>\n<p>Read View 说白了就是<font color='red'>事务进行快照读操作时产生的读视图</font>。在该事务执行快照读的那一刻，会生成一个当前数据库系统的快照，该快照记录并维护了系统当前活跃事务的 ID（当每个事务开启时，都会被分配一个 ID, 这个 ID 是递增的，所以最新的事务，ID 值越大）。</p>\n<p>Read View 是用来做 **<font color='red'>可见性判断</font><strong>的，里面保存了</strong><font color='red'>当前对本事务不可见的其他活跃的（未提交的）事务</font>**。当某个事务执行快照读的时候，会对该记录创建一个 Read View，把它比作条件<font color='red'>用来判断当前事务能够看到哪个版本的数据</font>，既可能是当前最新的数据，也有可能是该行记录在 undo log 里面的某个版本的数据。</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">class</span> <span class=\"token class-name\">ReadView</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>  <span class=\"token comment\">/* ... */</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">private</span><span class=\"token operator\">:</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>  trx_id_t m_low_limit_id<span class=\"token punctuation\">;</span>      <span class=\"token comment\">/* 表示目前出现过的最大的事务 ID + 1，大于等于这个 ID 的事务均不可见 */</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>  trx_id_t m_up_limit_id<span class=\"token punctuation\">;</span>       <span class=\"token comment\">/* 表示活跃事务列表 m_ids 中最小的事务 ID，小于这个 ID 的事务均可见 */</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>  trx_id_t m_creator_trx_id<span class=\"token punctuation\">;</span>    <span class=\"token comment\">/* 创建该 Read View 的事务 ID */</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>  trx_id_t m_low_limit_no<span class=\"token punctuation\">;</span>      <span class=\"token comment\">/* 事务 Number, 小于该 Number 的 Undo Logs 均可以被 Purge */</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>  ids_t m_ids<span class=\"token punctuation\">;</span>                  <span class=\"token comment\">/* 创建 Read View 时的活跃事务列表 */</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>  m_closed<span class=\"token punctuation\">;</span>                     <span class=\"token comment\">/* 标记 Read View 是否 close */</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>主要有以下字段：</p>\n<ul>\n<li>\n<p><code>m_ids</code> ：<font color='red'>ReadView 创建时，其他活跃的（即未提交的）事务 ID 列表</font>。创建 ReadView 时，将当前所有未提交的事务的 ID 记录下来，后续即使它们修改了行记录的值，对于当前事务也是不可见的</p>\n<blockquote>\n<p>不包括当前事务自己和已提交的事务（正在内存中）</p>\n</blockquote>\n</li>\n<li>\n<p><code>m_low_limit_id</code> ：<font color='red'>目前出现过的最大的事务 ID + 1</font>，即下一个将被分配的事务 ID</p>\n<blockquote>\n<p>大于等于这个 ID 的数据版本均不可见</p>\n</blockquote>\n</li>\n<li>\n<p><code>m_up_limit_id</code> ：<font color='red'>活跃事务列表 m_ids 中最小的事务 ID</font>，如果 m_ids 为空，则  <code>m_up_limit_id = m_low_limit_id</code></p>\n<blockquote>\n<p>小于这个 ID 的数据版本均可见</p>\n</blockquote>\n</li>\n<li>\n<p><code>m_creator_trx_id</code> ：<font color='red'>创建该 ReadView 的事务 ID</font></p>\n</li>\n</ul>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/trans_visible-048192c5.png\" alt=\"trans_visible\" /></p>\n<center>事务可见性示意图</center>\n<h6 id=\"数据可见性算法\"><a class=\"anchor\" href=\"#数据可见性算法\">#</a> 数据可见性算法</h6>\n<p>在 InnoDB 中，<font color='red'>创建一个新事务后，执行每个 select 语句前，都会创建一个 Read View</font>。<strong><font color='#B32015'>Read View 中保存了当前数据库系统中正处于活跃（即没有 commit）的事务的 ID 号</font></strong>。</p>\n<p>简单的说，保存的是系统中当前不应该被本事务看到的其他事务的 ID 列表（即 m_ids）。<font color='red'>当用户在本事务中要读取某个记录行的时候，InnoDB 会将该记录行的  <code>DB_TRX_ID</code>  与 Read View 中的一些变量及当前事务 ID 进行比较，判断是否满足可见性条件</font>。具体的比较算法如下：</p>\n<blockquote>\n<p>参与比较的对象：</p>\n<ol>\n<li><code>DB_TRX_ID</code> ：<font color='red'>表示插入这行记录或者最后一次修改该行记录的事务 id</font></li>\n<li><code>m_creator_trx_id</code> ：<font color='red'>表示创建该 ReadView 的事务 ID</font></li>\n<li><code>m_up_limit_id</code> ：ReadView 中的一个变量，<font color='red'>表示活跃事务列表 m_ids 中最小的事务 ID</font>。事务 ID 小于它的事务均已提交，因此小于这个 ID 的数据版本均可见</li>\n<li><code>m_low_limit_id</code> ：ReadView 中的一个变量，表示下一个将被分配的事务 ID，即<font color='red'>目前出现过的最大的事务 ID + 1</font>。事务 ID 大于它的事务均未提交，因此大于等于这个 ID 的数据版本均不可见</li>\n</ol>\n</blockquote>\n<p><code>changes_visible()</code>  返回 true 代表可见， false 代表不可见。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231128104943951.png\" alt=\"image-20231128104943951\" /></p>\n<table>\n<thead>\n<tr>\n<th>步骤</th>\n<th>条件</th>\n<th>是否可以访问该版本</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0</td>\n<td>DB_TRX_ID == m_creator_trx_id</td>\n<td>可见</td>\n<td>表明最新修改该行记录的事务（DB_TRX_ID）就是创建 ReadView 的当前事务！</td>\n</tr>\n<tr>\n<td>1</td>\n<td>DB_TRX_ID &lt; m_up_limit_id</td>\n<td>可见</td>\n<td>表明最新修改该行记录的事务（DB_TRX_ID）在<u>当前事务</u>创建  ReadView 之前就提交了，因此该行记录的值对当前事务是可见的。</td>\n</tr>\n<tr>\n<td>2</td>\n<td>DB_TRX_ID &gt;= m_low_limit_id</td>\n<td>不可见</td>\n<td>表明最新修改该行的事务（DB_TRX_ID）在<u>当前事务</u>创建 ReadView 之后才修改该行，所以该记录行的值对当前事务不可见。<font color='red'>跳到步骤 5</font></td>\n</tr>\n<tr>\n<td>3</td>\n<td>m_ids 为空</td>\n<td>可见</td>\n<td>说明当前不存在活跃的事务，表明在当前事务创建 ReadView 之前，修改该行的事务就已经提交了，所以该记录行的值对当前事务是可见的</td>\n</tr>\n<tr>\n<td>4</td>\n<td>m_up_limit_id &lt;= DB_TRX_ID &lt; m_low_limit_id</td>\n<td>1. 如果 DB_TRX_ID 在 m_ids 中，不可见；</br>2. 如果 DB_TRX_ID 不在 m_ids 中，可见；</td>\n<td>表明最新修改该行的事务（DB_TRX_ID）在<u>当前事务</u>创建 ReadView 的时候可能处于 “活动状态” 或者 “已提交状态”，因此就要对活跃事务列表 m_ids 进行查找，分为两种情况：</br>1. 如果在活跃事务列表 m_ids 中能找到 DB_TRX_ID，表明：① 在当前事务创建 ReadView 前，该记录行的值被事务 ID 为 DB_TRX_ID 的事务修改了，但没有提交；或者 ② 在当前事务创建 ReadView 后，该记录行的值被事务 ID 为 DB_TRX_ID 的事务修改了。这些情况下，这个记录行的值对当前事务都是不可见的。<font color='red'>跳到步骤 5</font></br>2. 在活跃事务列表中找不到，则表明 “id 为 DB_TRX_ID 的事务” 在修改 “该记录行的值” 后，在 “当前事务” 创建 ReadView 前就已经提交了，所以记录行对当前事务可见</td>\n</tr>\n<tr>\n<td>5</td>\n<td></td>\n<td></td>\n<td>在该行记录的 DB_ROLL_PTR 指针所指向的 undo log 取出快照记录，用其中的 DB_TRX_ID <font color='red'>跳到步骤 1</font> 重新开始判断，直到找到满足的快照版本或返回空</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"rc-和-rr-下-mvcc-的差异\"><a class=\"anchor\" href=\"#rc-和-rr-下-mvcc-的差异\">#</a> <mark>RC 和 RR 下 MVCC 的差异</mark></h5>\n<p>在事务隔离级别 RC 和 RR 下，虽然 InnoDB 都通过 MVCC 来读取快照数据（一致性非锁定读），但它们<font color='red'>生成 ReadView 的时机不同</font>：</p>\n<ul>\n<li>RC：<strong>在事务中的<font color='red'>每一次执行快照读时</font>，都会生成并设置新的 Read View，所以会导致不可重复读</strong>！</li>\n<li>RR：<strong>仅在事务中的<font color='red'>第一次执行快照读时</font>，生成一个 Read View（m_ids 列表），后续复用该 ReadView。<font color='red'>因此在一个事务中，执行两次相同的 select 语句，查询到的结果是一样的</font></strong>。</li>\n</ul>\n<h6 id=\"rc-下-readview-的生成情况\"><a class=\"anchor\" href=\"#rc-下-readview-的生成情况\">#</a> RC 下 ReadView 的生成情况</h6>\n<p>具体示例略了...</p>\n<h6 id=\"rr-下-readview-的生成情况\"><a class=\"anchor\" href=\"#rr-下-readview-的生成情况\">#</a> RR 下 ReadView 的生成情况</h6>\n<p>具体示例略了...</p>\n<h5 id=\"mvccnext-key-lock-防止幻读\"><a class=\"anchor\" href=\"#mvccnext-key-lock-防止幻读\">#</a> <mark>MVCC➕Next-key Lock 防止幻读</mark></h5>\n<blockquote>\n<p>幻读：一个事务读取了几行数据，接着另一个并发事务<font color='red'>插入</font>了一些数据。第一个事务在随后的查询中就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</p>\n</blockquote>\n<p><strong><font color='#B32015'>InnoDB 在 RR 级别下通过 MVCC 和 临键锁（Next-key Lock）来解决幻读问题</font></strong>：</p>\n<p>1、<strong><font color='red'>执行普通 select 时会以 MVCC <u>快照读</u>的方式读取数据</font></strong></p>\n<blockquote>\n<p>理所当然能防止 “幻读”</p>\n</blockquote>\n<p>在快照读的情况下，RR 隔离级别只会在事务开启后的第一次查询时生成 Read View ，并复用直至事务提交。所以在生成 Read View 之后其它事务所做的更新、插入记录版本对当前事务并不可见，实现了可重复读和<font color='red'>防止快照读下的 “幻读”</font>。</p>\n<p>2、<strong><font color='red'>执行 select...for update/lock in share mode、insert、update、delete 等当前读</font></strong></p>\n<blockquote>\n<p>得益于临键锁（Next-key Lock）才能防止 “幻读”</p>\n</blockquote>\n<p>在当前读下，读取的都是最新的数据，如果其它事务有插入新的记录，并且刚好在当前事务查询范围内，就会产生幻读！InnoDB 使用 <strong><font color='red'>临键锁（Next-key Lock）</font></strong> 来防止幻读。<strong><font color='red'>当执行当前读时，会锁定读取到的记录，同时会锁定它们的间隙，防止其它并发事务在查询范围内插入数据</font></strong>。只要我不让你插入，就不会发生幻读。</p>\n<h3 id=\"mysql索引\"><a class=\"anchor\" href=\"#mysql索引\">#</a> <mark>MySQL 索引</mark></h3>\n<h4 id=\"索引原理\"><a class=\"anchor\" href=\"#索引原理\">#</a> <mark>索引原理</mark></h4>\n<p>索引（Index）是<font color='red'>一种帮助 MySQL 高效获取数据的有序数据结构</font>，协助 MySQL 快速查询、更新表中数据。MySQL 支持多种类型的索引，包括 B-tree 索引、哈希索引、全文索引等。</p>\n<p>索引的基本原理如下：</p>\n<ol>\n<li>把创建索引列的内容进行排序</li>\n<li>对排序的结果生成倒排表</li>\n<li>在倒排表内容上拼接上数据行地址</li>\n<li>查询数据时，先拿到倒排表内容，在取出数据行地址，从而拿到具体的数据</li>\n</ol>\n<p>数据是以文件的形式存放在磁盘上面的，每一行数据都有它的磁盘地址，如果没有索引的话，我们要从千万行数据里面检索一条数据，只能依次遍历这张表的全部数据， 直到找到这条数据。</p>\n<p>但是有了索引之后，只需要在索引里面去检索这条数据就行了，因为它是特殊的专门用来快速检索的数据结构，我们找到数据存放的磁盘地址以后，就可以拿到数据了。</p>\n<h4 id=\"索引介绍\"><a class=\"anchor\" href=\"#索引介绍\">#</a> 索引介绍</h4>\n<p><strong>索引是一种帮助存储引擎快速查询和检索数据的数据结构（有序）。</strong></p>\n<p>索引的底层数据结构存在很多种类型，常见的索引结构有：红黑树、B 树、B + 树、Hash。</p>\n<p><font color='red'>在 MySQL 中，Innodb 和 MyIsam，都使用 B + 树 作为索引结构</font>。</p>\n<h4 id=\"索引的优缺点\"><a class=\"anchor\" href=\"#索引的优缺点\">#</a> 索引的优缺点</h4>\n<p><strong>优点</strong>：</p>\n<ul>\n<li>使用索引可以大大<font color='red'>加快数据的检索速度</font>（大大减少检索的数据量），这也是创建索引的最主要的原因。</li>\n<li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</li>\n</ul>\n<p><strong>缺点</strong>：</p>\n<ul>\n<li><font color='red'>创建和维护索引需要耗费许多时间</font>。当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低 SQL 执行效率。</li>\n<li>索引需要使用物理文件存储，也会耗费一定空间。</li>\n</ul>\n<h4 id=\"索引的底层数据结构选型\"><a class=\"anchor\" href=\"#索引的底层数据结构选型\">#</a> <mark>索引的底层数据结构选型</mark></h4>\n<p>不同存储引擎对索引结构的支持情况：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231117203129938.png\" alt=\"image-20231117203129938\" /></p>\n<h5 id=\"hash-表\"><a class=\"anchor\" href=\"#hash-表\">#</a> Hash 表</h5>\n<p>哈希索引使用哈希算法<font color='red'>将索引列的值映射到哈希表中</font>，然后通过哈希表的查找算法快速定位到目标数据。哈希索引的优点是查找速度非常快，但是它<font color='red'>不支持范围查找，只适用于等值查找</font>。</p>\n<p>哈希表是键值对的集合，通过键 (key) 即可快速取出对应的值 (value)，因此哈希表可以快速检索数据（接近 O（1））。</p>\n<p>通过哈希算法，我们可以快速找到 key 对应的 index，找到了 index 也就找到了对应的 value。</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>hash <span class=\"token operator\">=</span> <span class=\"token function\">hashfunc</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>index <span class=\"token operator\">=</span> hash <span class=\"token operator\">%</span> array_size</pre></td></tr></table></figure><p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/mysql20210513092328171.png\" alt=\"img\" /></p>\n<p>但是！哈希算法有个 <strong>Hash 冲突</strong> 问题，也就是说多个不同的 key 最后得到的 index 相同。通常情况下，我们常用的解决办法是<strong>链地址法</strong>。链地址法就<font color='red'>是将哈希冲的突数据存放在链表中</font>。</p>\n<p>比如 JDK1.8 之前  <code>HashMap</code>  就是通过链地址法来解决哈希冲突的。不过，JDK1.8 以后  <code>HashMap</code>  为了减少链表过长时搜索时间过长引入了红黑树。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/mysql20210513092224836.png\" alt=\"img\" /></p>\n<p>为了减少 Hash 冲突的发生，一个好的哈希函数应该 “均匀地” 将数据分布在整个可能的哈希值集合中。</p>\n<hr />\n<p>InnoDB 存储引擎不直接支持常规的哈希索引，但存在一种特殊的<strong>自适应哈希索引（Adaptive Hash Index）</strong>，结合了 B+Tree 和哈希索引的特点，以便更好地适应实际应用中的数据访问模式和性能需求。自适应哈希索引的<font color='red'>每个哈希桶实际上是一个小型的 B+Tree 结构</font>。这个 B+Tree 结构可以存储多个键值对，而不仅仅是一个键。这有助于减少哈希冲突链的长度，提高了索引的效率。关于 Adaptive Hash Index 的详细介绍，可以查看 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvcmE0djFYUjVwelNXYy1xdEdPLWRCZw==\">MySQL 各种 “Buffer” 之 Adaptive Hash Index</span> 这篇文章。</p>\n<p>既然哈希表这么快，为什么 MySQL 没有使用其作为索引的数据结构呢？主要是<strong>因为 Hash 索引不支持排序、范围查询</strong>。假如我们要对表中的数据进行排序或者进行范围查询，那 Hash 索引可就不行了。并且，每次 IO 只能取一个。</p>\n<p>试想一种情况:</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token constant\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token constant\">FROM</span> tb1 <span class=\"token constant\">WHERE</span> id <span class=\"token operator\">&lt;</span> <span class=\"token number\">500</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>在这种范围查询中，直接遍历比 500 小的叶子节点就够了。而 Hash 索引是根据 hash 算法来定位的，难不成还要把 1 - 499 的数据，每个都进行一次 hash 计算来定位吗？这就是 Hash 最大的缺点了。</p>\n<h5 id=\"全文索引full-text\"><a class=\"anchor\" href=\"#全文索引full-text\">#</a> 全文索引（Full-text）</h5>\n<p>全文索引是一种特殊的索引类型，它可以用于对文本数据进行全文检索。全文索引的基本原理是<font color='red'>将文本数据分词，然后将每个词作为关键字建立索引</font>。全文索引可以用于<font color='red'>对文本数据进行模糊匹配、关键字搜索</font>等操作。</p>\n<h5 id=\"二叉查找树bst\"><a class=\"anchor\" href=\"#二叉查找树bst\">#</a> 二叉查找树（BST）</h5>\n<p>二叉查找树（Binary Search Tree）是一种基于二叉树的数据结构，它具有以下特点：</p>\n<ol>\n<li>左子树所有节点的值均小于根节点的值。</li>\n<li>右子树所有节点的值均大于根节点的值。</li>\n<li>左右子树也分别为二叉查找树。</li>\n</ol>\n<p>二叉查找树的时间复杂度：</p>\n<ul>\n<li>当二叉查找树平衡时，也就是树的每个节点的左右子树深度相差不超过 1 的时候，查询的时间复杂度为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(logn)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span>，具有比较高的效率。</li>\n<li>然而，当二叉查找树不平衡时，例如在最坏情况下（有序插入节点），树会退化成线性链表（也被称为<font color='red'>斜树</font>），相当于<font color='red'>全表扫描</font>，导致查询效率急剧下降，时间复杂退化为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mtext>（</mtext><mi>N</mi><mtext>）</mtext></mrow><annotation encoding=\"application/x-tex\">O（N）</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mord cjk_fallback\">（</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mord cjk_fallback\">）</span></span></span></span>。</li>\n</ul>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/oblique-tree.png\" alt=\"斜树\" /></p>\n<center>斜树</center>\n<p>也就是说，<strong>二叉查找树的性能非常依赖于它的平衡程度，这就导致其不适合作为 MySQL 底层索引的数据结构。</strong></p>\n<p>为了解决这个问题，并提高查询效率，人们发明了多种在二叉查找树基础上的改进型数据结构，如平衡二叉树、B-Tree、B+Tree 等。</p>\n<h5 id=\"avl-树自平衡的bst\"><a class=\"anchor\" href=\"#avl-树自平衡的bst\">#</a> AVL 树（自平衡的 BST）</h5>\n<p>AVL 树的特点是<font color='red'>保证任何节点的左右子树高度之差不超过 1</font>，因此也被称为高度平衡二叉树。<font color='red'>它的查找、插入和删除在平均和最坏情况下的时间复杂度都是 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(logn)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></font>。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/avl-tree.png\" alt=\"AVL 树\" /></p>\n<p>AVL 树采用了<font color='red'>旋转操作</font>来保持平衡。主要有四种旋转操作：LL 旋转、RR 旋转、LR 旋转和 RL 旋转。其中 LL 旋转和 RR 旋转分别用于处理左左和右右失衡，而 LR 旋转和 RL 旋转则用于处理左右和右左失衡。</p>\n<p>由于 AVL 树<font color='red'>需要频繁地进行旋转操作来保持平衡</font>，因此会有较大的计算开销进而降低了查询性能。并且， 在使用 AVL 树时，每个树节点仅存储一个数据，而每次进行磁盘 IO 时只能读取一个节点的数据，如果需要查询的数据分布在多个节点上，那么就需要进行多次磁盘 IO。 <strong>磁盘 IO 是一项耗时的操作，在设计数据库索引时，我们需要优先考虑如何最大限度地减少磁盘 IO 操作的次数。</strong></p>\n<p>实际应用中，AVL 树使用的并不多。</p>\n<h5 id=\"红黑树自平衡的bst\"><a class=\"anchor\" href=\"#红黑树自平衡的bst\">#</a> 红黑树（自平衡的 BST）</h5>\n<p>与 AVL 树一样，红黑树也是一种自平衡二叉查找树，通过在插入和删除节点时进行<font color='red'>颜色变换、旋转操作</font>，使得树始终保持平衡状态，它具有以下特点：</p>\n<ol>\n<li>每个节点非红即黑；</li>\n<li>根节点总是黑色的；</li>\n<li>每个叶子节点都是黑色的空节点（NIL 节点）；</li>\n<li>如果节点是红色的，则它的子节点必须是黑色的（反之不一定）；</li>\n<li>从根节点到叶节点或空子节点的每条路径，必须包含相同数目的黑色节点（即相同的黑色高度）。</li>\n</ol>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/red-black-tree.png\" alt=\"红黑树\" /></p>\n<p>和 AVL 树不同的是，<strong><font color='red'>红黑树并不追求严格的平衡，而是大致的平衡，因此红黑树的查询效率稍有下降</font></strong>。因为红黑树的平衡性相对较弱，可能会导致树的高度较高，这可能会导致一些数据需要进行多次磁盘 IO 操作才能查询到，这也是 MySQL 没有选择红黑树的主要原因。</p>\n<p>也正因如此，<strong><font color='red'>红黑树的插入和删除操作效率大大提高了</font></strong><font color='red'>，因为红黑树在插入和删除节点时只需进行 O (1) 次数的旋转和变色操作，即可保持基本平衡状态</font>，而不需要像 AVL 树一样进行 O (logn) 次数的旋转操作。</p>\n<p>红黑树的应用还是比较广泛的，<font color='red'>TreeMap、TreeSet 以及 JDK1.8 的 HashMap 底层都用到了红黑树</font>。对于数据在内存中的这种情况来说，红黑树的表现是非常优异的。</p>\n<h5 id=\"b树-b树\"><a class=\"anchor\" href=\"#b树-b树\">#</a> <mark>B 树 &amp; B + 树</mark></h5>\n<blockquote>\n<p>最常用</p>\n</blockquote>\n<p>B 树全称为<strong>多路平衡查找树</strong> ，B+ 树是 B 树的一种变体，其中 B 是  <code>Balanced</code> （平衡）的意思。</p>\n<p><font color='red'>目前大部分数据库系统及文件系统都采用 B-Tree 或其变种 B+Tree 作为<u>索引结构</u></font>。</p>\n<p>B-tree 索引可以在<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(log n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span> 的时间复杂度内查找数据，基本原理如下：</p>\n<ol>\n<li>将索引列的值按照一定的顺序存储在 B-tree 中</li>\n<li>然后通过 B-tree 的查找算法快速定位到目标数据</li>\n<li>B-tree 索引的叶子节点存储了指向数据行的指针，因此可以通过 B-tree 索引快速定位到目标数据行</li>\n</ol>\n<p><strong>B 树与 B + 树的区别</strong>：</p>\n<ul>\n<li>\n<p><strong><font color='red'>B 树的所有节点都存放<u>索引列值（key）</u>和数据（data）</font></strong>；而 **<font color='red'> B+ 树只有叶子节点才同时存放 key 和 data，其他内节点只存放 key</font>**。</p>\n<blockquote>\n<p>这样 B+ 树中每个内节点可以存储更多 key 值，从而降低 B + 树的高度，提高检索效率。</p>\n</blockquote>\n</li>\n<li>\n<p><font color='red'>B 树的叶子节点都是独立的</font>；而 <strong><font color='red'>B+ 树的所有叶子节点构成一个<u>有序的双向链表</u></font></strong>。</p>\n<blockquote>\n<p>因此 B+ 树可以按照 key 来有序遍历全部记录，且便于区间查找和搜索。</p>\n</blockquote>\n</li>\n<li>\n<p>B 树的检索的过程相当于对范围内的每个节点的 key 做二分查找，可能还没有到达叶子节点，检索就结束了。而 <strong><font color='red'>B+ 树的检索效率就很稳定了，任何查找都是从根节点到叶子节点的过程，叶子节点的顺序检索很明显</font></strong>。</p>\n</li>\n<li>\n<p>在 B 树中进行范围查询时，首先找到要查找的下限，然后对 B 树进行中序遍历，直到找到查找的上限；而 <strong><font color='red'>B+ 树的范围查询，只需要对有序的双向链表进行遍历即可</font></strong>。</p>\n</li>\n</ul>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/249993-20170525154141810-591706803.png\" alt=\"img\" /></p>\n<center>B树索引（3阶）</center>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/249993-20170531161139243-491884410.png\" alt=\"img\" /></p>\n<center>（B+树索引）</center>\n<p>综上，B + 树与 B 树相比，具备 **<font color='red'>更高，更稳定的查询效率、更适用于范围查询</font>** 这些优势。</p>\n<h5 id=\"mysql-选择-b-树作为索引结构的原因\"><a class=\"anchor\" href=\"#mysql-选择-b-树作为索引结构的原因\">#</a> <mark>MySQL 选择 B+ 树作为索引结构的原因</mark></h5>\n<p><strong>1、为什么不使用二叉查找树（BST）？</strong></p>\n<p>二叉查找树可能因为失衡严重出现<font color='red'>“斜树”，退化为线性链表，相当于全表扫描</font>，高度太高了，查找效率不稳定。</p>\n<p><strong>2、为什么不使用平衡二叉树？</strong></p>\n<p>平衡二叉树解决了二叉树高度太高，查找效率不稳定的问题。但是，平衡二叉树的<font color='red'>每个节点只存储一个键值和数据，如果数据非常的多，二叉树的结点将会非常多，高度也会很高，查找效率降低</font>。</p>\n<p><strong>3、为什么不使用 B 树？</strong></p>\n<ul>\n<li>\n<p><strong><font color='red'>B 树只适合随机检索</font></strong>，而 B + 树同时支持随机检索和顺序 / 范围检索；</p>\n</li>\n<li>\n<p><strong><font color='red'>B + 树的空间利用率更高</font></strong>：因为 B + 树的内部节点（非叶子节点，也称索引节点）不存储数据，只存储索引值，相比较 B 树来说，B + 树一个节点可存储更多的索引值，使得整颗 B + 树变得更矮，减少 I/O 次数，磁盘读写代价更低，I/O 读写次数是影响索引检索效率的最大因素；</p>\n</li>\n<li>\n<p><strong><font color='red'>B + 树查询效率更加稳定</font></strong>：因为在 B + 树中，顺序检索比较明显，随机检索时，由于 B + 树所有的 data 域（结点中存储数据元素的部分）都在根节点，任何关键字的查找都必须走一条从根节点到叶节点的路，所有关键字的查找路径相同，导致每一个关键字的查询效率基本相同，时间复杂度固定为 O (log n)；而 B 树搜索有可能会在非叶子节点结束，越靠近根节点的记录查找时间越短，其性能等价于在关键字全集内做一次二分查找，查询时间复杂度不固定，与 key 在树中的位置有关，最好情况为 O (1)；</p>\n</li>\n<li>\n<p><strong><font color='red'>B + 树范围查询性能更优</font></strong>：因为 B + 树的叶子节点使用了指针顺序（链表）从小到大地连接在一起，B + 树叶节点两两相连可大大增加区间访问性，只要遍历叶子节点就可以实现整棵树的遍历；而 B 树的叶子节点是相互独立的，每个节点 key（索引）和 data 在一起，则无法查找区间；</p>\n<p>根据空间局部性原理：如果一个存储器的某个位置被访问，那么将它附近的位置也会被访问。若访问节点 key 为 50，则 key 为 55、60、62 的节点将来也可能被访问，可利用磁盘预读原理提前将这些数据读入内存，减少了磁盘 IO 的次数。当然 B + 树也能够很好的完成范围查询，比如同时也会查询 key 值在 50-70 之间的节点。</p>\n</li>\n<li>\n<p><strong><font color='red'>B + 树增删文件（节点）时效率更高</font></strong>：因为 B + 树的叶子节点包含了所有关键字，并以有序的链表结构存储。</p>\n</li>\n</ul>\n<h4 id=\"索引分类\"><a class=\"anchor\" href=\"#索引分类\">#</a> 索引分类</h4>\n<p>按照<font color='gree'>数据结构</font>分类：</p>\n<ul>\n<li><strong><font color='cornflowerblue'>B + 树索引</font></strong>：MySQL 里<font color='red'>默认的</font>索引类型。<font color='red'>只有叶子节点存储 value，非叶子节点只有指针和 key</font>。存储引擎 MyISAM 和 InnoDB 实现索引都是使用 B+Tree，但二者实现方式不一样。</li>\n<li><font color='cornflowerblue'>hash 索引</font>：类似键值对的形式，一次即可定位。</li>\n<li><font color='cornflowerblue'>R 树索引</font>：一般不会使用，<font color='red'>仅支持 geometry 数据类型</font>，优势在于范围查找，效率较低，通常使用搜索引擎如 ElasticSearch 代替。</li>\n<li><font color='cornflowerblue'>全文索引</font>：<font color='red'>对文本的内容进行分词，进行搜索</font>。目前只有  <code>CHAR</code> 、 <code>VARCHAR</code>  ， <code>TEXT</code>  列上可以创建全文索引。<font color='red'>一般不会使用，效率较低</font>，通常使用搜索引擎如 ElasticSearch 代替。</li>\n</ul>\n<p>按照<font color='gree'>底层存储方式</font>划分：</p>\n<ul>\n<li>\n<p><strong><font color='cornflowerblue'>聚集索引</font></strong>：聚集索引的<strong>叶子节点存储的是<u>整行记录</u></strong>。<font color='red'>可以直接查找到数据，查询速度快。每个表只能有一个聚集索引</font>。例如 <font color='red'>InnoDB 引擎中的主键索引</font>。</p>\n<blockquote>\n<p>在 MySQL 中，InnoDB 引擎表的  <code>.ibd</code>  表空间文件包含了该表的索引和数据，因此该表的索引 (B + 树) 的每个非叶子节点存储索引，叶子节点存储索引和索引对应的数据。</p>\n</blockquote>\n</li>\n<li>\n<p><strong><font color='cornflowerblue'>非聚集索引</font></strong>：非聚集索引的<strong>叶子节点存储的是<u>索引列的值、指向对应行记录的指针</u></strong>。查询速度相对较慢。<font color='red'>MyISAM 引擎，无论主键还是非主键，使用的都是非聚集索引</font>。</p>\n</li>\n</ul>\n<p>按照<font color='gree'>应用维度</font>划分：</p>\n<ul>\n<li><font color='cornflowerblue'>主键索引</font>：加速查询 + 列值唯一（不可以有 NULL）+ 表中只有一个。</li>\n<li><font color='cornflowerblue'>普通索引</font>：仅加速查询。</li>\n<li><font color='cornflowerblue'>唯一索引</font>：加速查询 + 列值唯一（可以有 NULL）。</li>\n<li><font color='cornflowerblue'>覆盖索引</font>：一个索引包含（或者说覆盖）所有需要查询的字段的值。</li>\n<li><font color='cornflowerblue'>联合索引</font>：<font color='red'>多列值组成一个索引</font>，专门用于组合搜索，其效率大于索引合并。</li>\n<li><font color='cornflowerblue'>全文索引</font>：对文本的内容进行分词，进行搜索。目前只有  <code>CHAR</code> 、 <code>VARCHAR</code>  ， <code>TEXT</code>  列上可以创建全文索引。一般不会使用，效率较低，通常使用搜索引擎如 ElasticSearch 代替。</li>\n</ul>\n<p>MySQL 8.x 中实现的<font color='gree'>索引新特性</font>：</p>\n<ul>\n<li><font color='cornflowerblue'>隐藏索引</font>：也称为不可见索引，不会被优化器使用，但是仍然需要维护，通常会软删除和灰度发布的场景中使用。主键不能设置为隐藏（包括显式设置或隐式设置）。</li>\n<li><font color='cornflowerblue'>降序索引</font>：之前的版本就支持通过 desc 来指定索引为降序，但实际上创建的仍然是常规的升序索引。直到 MySQL 8.x 版本才开始真正支持降序索引。另外，在 MySQL 8.x 版本中，不再对 GROUP BY 语句进行隐式排序。</li>\n<li><font color='cornflowerblue'>函数索引</font>：从 MySQL 8.0.13 版本开始支持在索引中使用函数或者表达式的值，也就是在索引中可以包含函数或者表达式。</li>\n</ul>\n<h5 id=\"主键索引\"><a class=\"anchor\" href=\"#主键索引\">#</a> 主键索引</h5>\n<p>数据表的<font color='red'>主键列</font>使用的就是主键索引。</p>\n<p>一张数据表有只能有一个主键，并且主键不能为 null，不能重复。</p>\n<p>在 MySQL 的 InnoDB 的表中，当没有显示的指定表的主键时，InnoDB 会自动先检查表中是否有唯一索引且不允许存在 null 值的字段，如果有，则选择该字段为默认的主键，否则 InnoDB 将会自动创建一个 6 Byte 的自增主键。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/cluster-index.png\" alt=\"主键索引\" /></p>\n<center>主键索引</center>\n<h5 id=\"二级索引\"><a class=\"anchor\" href=\"#二级索引\">#</a> 二级索引</h5>\n<p>二级索引（Secondary Index）又称为辅助索引，是一种非聚集索引，因为<strong>二级索引的叶子节点仅仅存储<u>索引列的值、对应行记录的主键 key</u></strong>。也就是说，<font color='red'>通过二级索引，可以定位主键的位置，再根据主键索引查找行记录 data，这就是<strong>二次查询（回表）</strong>，因此二级索引的查询速度较慢</font>。</p>\n<p>唯一索引，普通索引，前缀索引、全文索引都属于二级索引：</p>\n<ol>\n<li><font color='cornflowerblue'>唯一索引 (Unique Key)</font>：唯一索引也是一种约束。<font color='red'>唯一索引的属性列不能出现重复的数据，但是允许数据为 NULL，一张表允许创建多个唯一索引</font>。建立唯一索引的目的大部分时候都是<font color='red'>为了该属性列的数据的唯一性，而不是为了查询效率</font>。</li>\n<li><font color='cornflowerblue'>普通索引 (Index)</font>：普通索引的唯一作用就是<font color='red'>为了快速查询数据</font>，一张表允许创建多个普通索引，并允许数据重复和 NULL。</li>\n<li><font color='cornflowerblue'>前缀索引 (Prefix)</font>：前缀索引只适用于字符串类型的数据。前缀索引是<font color='red'>对文本的前几个字符创建索引，相比普通索引建立的数据更小</font>，因为只取前几个字符。</li>\n<li><font color='cornflowerblue'>全文索引 (Full Text)</font>：全文索引主要是<font color='red'>为了检索大文本数据中的关键字信息</font>，是目前搜索引擎数据库使用的一种技术。Mysql 5.6 之前只有 MYISAM 引擎支持全文索引，5.6 之后 InnoDB 也支持了全文索引。</li>\n</ol>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/no-cluster-index.png\" alt=\"二级索引\" /></p>\n<center>二级索引</center>\n<h5 id=\"聚集索引\"><a class=\"anchor\" href=\"#聚集索引\">#</a> 聚集索引</h5>\n<p>聚集索引（Clustered Index）的<strong>叶子节点存储的是<u>整行记录</u></strong>。<font color='red'>可以直接查找到数据，查询速度快。每个表只能有一个聚集索引</font>。例如 <font color='red'>InnoDB 引擎中的主键索引</font>。</p>\n<p>在 MySQL 中，<font color='red'>InnoDB 引擎的表的  <code>.ibd</code>  表空间文件就包含了该表的索引和数据</font>，对于 InnoDB 引擎表来说，该表的索引 (B + 树) 的每个非叶子节点存储索引，叶子节点存储索引和索引对应的数据。</p>\n<p>优点：</p>\n<ul>\n<li><strong>查询速度非常快</strong>：因为整个 B+ 树本身就是一颗多叉平衡树，叶子节点也都是有序的，定位到索引的节点，就相当于定位到了数据。<font color='red'>相比于非聚集索引， 聚集索引少了一次读取数据的 IO 操作</font>。</li>\n<li><strong>对排序查找和范围查找优化</strong>：对于主键的排序查找和范围查找速度非常快。</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li><strong>依赖于有序的数据</strong>：因为 B+ 树是多路平衡树，如果索引的数据不是有序的，那么就<font color='red'>需要在插入时排序</font>，如果数据是整型还好，否则类似于字符串或 UUID 这种又长又难比较的数据，<font color='red'>插入或查找的速度肯定比较慢</font>。</li>\n<li><strong>修改更新的代价大</strong>：如果索引列的数据被修改，那么对应的索引也将会被修改，而且聚集索引的叶子节点还存放着数据，修改代价肯定是较大的。所以对于主键索引来说，主键一般都是不可被修改的。</li>\n</ul>\n<h5 id=\"非聚集索引\"><a class=\"anchor\" href=\"#非聚集索引\">#</a> 非聚集索引</h5>\n<p>非聚集索引（Non-Clustered Index）的<strong>叶子节点存储的是<u>索引列的值、指向对应行记录的指针</u></strong>。查询速度相对较慢。二级索引 (辅助索引) 就属于非聚集索引。<font color='red'>MyISAM 引擎，无论主键还是非主键，使用的都是非聚集索引</font>。</p>\n<p>非聚集索引的叶子节点并不一定存放数据的指针，因为<font color='red'>二级索引的叶子节点就存放的是主键，根据主键再回表查数据</font>。</p>\n<p>优点：</p>\n<ul>\n<li><strong>更新代价比聚集索引要小</strong>：因为非聚集索引的<font color='red'>叶子节点是不存放数据的</font></li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>\n<p><strong>依赖于有序的数据</strong>：跟聚簇索引一样，非聚簇索引也依赖于有序的数据</p>\n</li>\n<li>\n<p><strong><font color='orange'>可能会二次查询 (回表查询)</font></strong>: 这应该是非聚簇索引最大的缺点了。<strong><font color='red'>当查到非聚集索引对应的指针或主键后，可能还需要根据指针或主键再到数据文件或表中查询</font></strong>。</p>\n<blockquote>\n<p><strong>非聚集索引不一定回表查询。</strong></p>\n<p>试想一种情况，用户准备使用 SQL 查询用户名，而用户名字段正好建立了索引。</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">SELECT</span> name <span class=\"token keyword\">FROM</span> <span class=\"token keyword\">table</span> <span class=\"token keyword\">WHERE</span> name<span class=\"token operator\">=</span><span class=\"token string\">'guang19'</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>那么这个<font color='red'>索引的 key 本身就是要查询的字段</font>，查到对应的 name 直接返回就行了，无需回表查询。</p>\n<p>即使是 MYISAM 也是这样，虽然 MYISAM 的主键索引确实需要回表，因为它的主键索引的叶子节点存放的是指针。但是！<strong>如果 SQL 查的就是主键呢？</strong></p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">SELECT</span> id <span class=\"token keyword\">FROM</span> <span class=\"token keyword\">table</span> <span class=\"token keyword\">WHERE</span> id<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>主键索引本身的 key 就是主键，查到返回就行了。这种情况就称之为<strong>覆盖索引</strong>了。</p>\n</blockquote>\n</li>\n</ul>\n<p>这是 MySQL 的 InnoDB、MyISAM 表的文件截图：</p>\n<blockquote>\n<p><strong>InnoDB、MyISAM、Memory 这三种存储引擎的存储文件内容</strong>：</p>\n<ul>\n<li>无论哪种引擎，<font color='gree'>表的结构</font>都存储在  <code>.sdi</code>  文件中</li>\n<li>对于 InnoDB，表的索引和数据都存储在  <code>.ibd 表空间文件</code> 中</li>\n<li>对于 MyISAM，表的索引存储在  <code>.MYI</code>  文件中，表的数据存储在  <code>.MYD</code>  文件中</li>\n<li>对于 Memory，表的索引和数据都存储在 <code>内存</code> 中</li>\n</ul>\n</blockquote>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/mysql20210420165311654.png\" alt=\"MySQL 表的文件\" /></p>\n<h5 id=\"聚集索引和非聚集索引的区别\"><a class=\"anchor\" href=\"#聚集索引和非聚集索引的区别\">#</a> <mark>聚集索引和非聚集索引的区别</mark></h5>\n<p>聚集索引：</p>\n<ul>\n<li>\n<p>数据存储方式：表中的数据与索引按顺序存放在一块，<font color='red'>找到索引也就找到了数据</font>，即数据的物理存放顺序与索引顺序是一致的</p>\n</li>\n<li>\n<p>叶节点的 k-v：<font color='red'>（主键，行记录）</font></p>\n</li>\n<li>\n<p>唯一性：<font color='red'>表中只能有一个聚集索引，通常是主键</font>（因为主键要求其值在表中唯一且非空）</p>\n</li>\n<li>\n<p>查询性能：<font color='red'>范围查询、排序查询的性能高</font>，但<font color='red'>插入速度严重依赖于插入顺序</font>；<font color='red'>更新主键的代价很高</font>。</p>\n<blockquote>\n<p><font color='red'>按照主键顺序插入</font>是最快的方式，否则将会出现<font color='red'>页分裂</font>，严重影响性能。因此，对于 InnoDB 表，我们一般都会定义一个<font color='red'>自增的 ID 列为主键</font>。</p>\n<p>更新主键会导致被更新的行移动。因此对于 InnoDB 表，<font color='red'>一般定义主键为不可更新</font>。</p>\n</blockquote>\n</li>\n</ul>\n<p>非聚集索引：</p>\n<ul>\n<li>数据存储方式：<font color='red'>索引和实际数据的物理存储是分离的</font>，索引中存储了指向实际数据行的指针</li>\n<li>叶节点的 k-v：<font color='red'>（索引列，指向行记录的指针）</font></li>\n<li>唯一性：<font color='red'>表可以有多个非聚集索引，包括唯一索引</font>。非聚集索引不要求索引列的值唯一</li>\n<li>查询性能：<font color='red'>插入数据的速度快</font>，但<font color='red'>查询可能涉及回表，速度较慢</font></li>\n</ul>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231119111458997.png\" alt=\"image-20231119111458997\" /></p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/mysql20210420165326946.png\" alt=\"聚簇索引和非聚簇索引\" /></p>\n<h5 id=\"倒排索引\"><a class=\"anchor\" href=\"#倒排索引\">#</a> <mark>倒排索引</mark></h5>\n<p>先讲正排索引，意思就是我们的所有文档都有唯一一个文档 id，根据文档里的内容算出每个文档中关键字的内容和次数，类似于通过 key 去找 value 的形式，如果正牌索引，我们每次寻找关键字查询，就得搜索所有的文档去看是否有这个关键字，这样查询效率太慢了。</p>\n<p>于是有了倒排索引，是通过关键字去查文档，我们建立一个索引库，里面的 key 是关键字，value 是每个文档的 id，倒排在构建索引的时候较为耗时且维护成本较高，但是搜索耗时短，所以我们可以定时去更新索引库。</p>\n<p>正排索引和倒排索引是搜索引擎中的两种索引类型。</p>\n<ul>\n<li>正排索引：每个文档都有一个唯一的文档 ID，<font color='red'>按照文档 ID 等有序的方式将每个文档存储在索引中</font>，通过文档 ID 进行检索。这种方式类似于数据库表的行，可以很方便地根据文档 ID 检索到具体的文档，但是<font color='red'>不适合处理大规模文档库的情况</font>。</li>\n<li>倒排索引：<font color='red'>按照单词或关键字将文档进行索引</font>，并记录包含该词汇的文档列表。</li>\n</ul>\n<p><font color='red'>倒排索引的优势在于查找包含某个项的文档，即用于搜索查询</font>；相反，<font color='red'>正排索引的优势是确定哪些项是否存在单个文档里</font>。</p>\n<p>二者均是在 index-time 时创建，保存在 Lucene 文件中（序列化到磁盘）。</p>\n<h5 id=\"覆盖索引\"><a class=\"anchor\" href=\"#覆盖索引\">#</a> <mark>覆盖索引</mark></h5>\n<blockquote>\n<p>我们都知道 InnoDB 中索引分为两类：</p>\n<ul>\n<li><font color='red'>聚集索引（主键索引）</font>：（<font color='gree'>主键</font>，除主键外的完整行记录）</li>\n<li><font color='red'>非聚集索引（辅助索引 / 普通索引）</font>：（索引列的值，<font color='gree'>主键</font>）</li>\n</ul>\n<p>想要搞清除什么是覆盖索引，首先得弄懂 **<font color='#B32015'>回表查询</font>**：当使用<u>普通索引（辅助索引）</u>进行查询时，先得到行记录的主键值（<font color='red'>但仍未得到所需的所有列数据</font>），然后再根据主键值到<u>聚集索引（主键索引）</u>中找到对应的完整行记录。</p>\n<p>由于<font color='red'>回表导致多次扫描索引树，会降低查询效率</font>。那么如何避免回表查询？</p>\n<p><font color='red'>常用的方法是：将查询需要的字段添加到索引中，建立<u>联合索引</u></font>。比如上面提到的查询语句，可以将 (NAME,CITY) 做成一个联合索引，这样在首次扫描索引树的时候就能从索引树本身获取到需要的所有信息，从而避免了回表。这里使用的方法就是<strong>覆盖索引</strong>。</p>\n<hr />\n<p>举个回表查询的例子，对于 InnoDB 表 EMPLOYEE，由三个字段（ID、NAME、CITY）组成，其中在 ID 上建立了主键索引（聚集索引），在 NAME 上建立了普通索引。</p>\n<p>现在需要进行一次如下的查询：</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">select</span> NAME<span class=\"token punctuation\">,</span>CITY <span class=\"token keyword\">from</span> EMPLOYEE <span class=\"token keyword\">where</span> NAME<span class=\"token operator\">=</span><span class=\"token string\">\"Lee\"</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>首先通过普通索引去找到 NAME=&quot;Lee&quot; 对应的叶节点，获取到行记录的主键值（ID=8）。而该查询语句还需要获取 CITY 字段的值，于是 MySQL 要再根据该主键值（ID=8）通过主键索引查找，从而获得完整的数据。这个过程就是所谓的<strong>回表查询</strong>。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/4cfbd83c40884036b46e895d31a70726.png\" alt=\"在这里插入图片描述\" /></p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/28608822ef07481187c583b22bc3c80a.png\" alt=\"在这里插入图片描述\" /></p>\n</blockquote>\n<p>如果一个 **<font color='#B32015'>索引包含了所有需要查询的字段</font>**，就称之为覆盖索引（Covering Index）。在 InnoDB 中，如果不是主键索引，叶子节点存储的是索引列值 + 主键。最终还是要 “回表”，也就是要通过主键再查找一次，这样就会比较慢。<font color='red'>而覆盖索引就是把要查询出的列和索引是对应的，不做回表操作！因为所查询的字段都在当前索引的叶子节点上存在，可以直接作为结果返回了。</font></p>\n<p>** 覆盖索引，即需要查询的字段正好是索引的字段，那么直接根据该索引就可以查到数据了，而无需回表查询。** 因此，<font color='red'>应该尽量使用覆盖索引，减少 <code>select *</code> </font>。</p>\n<blockquote>\n<p>如主键索引，如果一条 SQL 需要查询主键，那么正好根据主键索引就可以查到主键。再如普通索引，如果一条 SQL 需要查询 name，name 字段正好有索引，那么直接根据这个索引就可以查到数据，也无需回表。</p>\n</blockquote>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/mysql20210420165341868.png\" alt=\"覆盖索引\" /></p>\n<h5 id=\"联合索引\"><a class=\"anchor\" href=\"#联合索引\">#</a> 联合索引</h5>\n<p>使用表中的<strong>多个字段创建索引</strong>，就是 联合索引，也叫 组合索引 或 复合索引。</p>\n<p>以  <code>score</code>  和  <code>name</code>  两个字段建立联合索引：</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">ALTER</span> <span class=\"token keyword\">TABLE</span> <span class=\"token identifier\"><span class=\"token punctuation\">`</span>cus_order<span class=\"token punctuation\">`</span></span> <span class=\"token keyword\">ADD</span> <span class=\"token keyword\">INDEX</span> id_score_name<span class=\"token punctuation\">(</span>score<span class=\"token punctuation\">,</span> name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h4 id=\"最左前缀匹配原则\"><a class=\"anchor\" href=\"#最左前缀匹配原则\">#</a> <mark>最左前缀匹配原则</mark></h4>\n<p>最左前缀法则：<strong><font color='#B32015'>查询条件中的各个列必须是联合索引中从最左边开始的连续子列。</font></strong></p>\n<ul>\n<li><font color='red'>如果跳跃了<u>中间的某一列</u>，那么联合索引将会<u>部分失效</u>（后面的字段索引都失效）。</font></li>\n<li><strong>如果跳跃了<u>最左列</u>，那么联合索引将会<u>全部失效</u>，转而进行全表扫描！</strong></li>\n</ul>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231117221133910.png\" alt=\"image-20231117221133910\" /></p>\n<blockquote>\n<p>注意：<strong>联合索引的最左边字段必须在 SQL 的查询条件中存在，但是与 SQL 的查询条件中编写的字段先后顺序无关</strong>。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231117221449634.png\" alt=\"image-20231117221449634\" /></p>\n<center>因此对于这种情况，联合索引是全部生效的！</center>\n</blockquote>\n<p>所以，<strong>在使用联合索引时，可以将区分度高的字段放在最左边，这也可以过滤更多数据</strong>。</p>\n<p><strong>在联合索引的使用中，如果 SQL 出现范围查询（如  <code>&gt;</code> 、 <code>&lt;</code>  ），那么范围查询右侧的列索引会失效！</strong></p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231117221945853.png\" alt=\"image-20231117221945853\" /></p>\n<blockquote>\n<p>但对于 <strong> <code>&gt;=</code> </strong>、<strong> <code>&lt;=</code> </strong>、<strong> <code>BETWEEN</code> </strong>、<strong> <code>like</code> </strong> 前缀匹配的范围查询，并不会停止匹配。</p>\n</blockquote>\n<h4 id=\"索引下推\"><a class=\"anchor\" href=\"#索引下推\">#</a> 索引下推</h4>\n<p><strong>索引下推（Index Condition Pushdown）</strong> 是 <strong>MySQL 5.6</strong> 版本中提供的一项索引优化功能，可以在非聚簇索引遍历过程中，对索引中包含的字段先做判断，过滤掉不符合条件的记录，减少回表次数。</p>\n<h4 id=\"索引失效\"><a class=\"anchor\" href=\"#索引失效\">#</a> <mark>索引失效</mark></h4>\n<p><strong><font color='red'>索引失效后导致使用全表扫描来查询数据</font></strong>，这也是慢查询的主要原因之一，查询中导致索引失效的常见情况有这些：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/iaIdQfEric9Twmk46GNqLLRSboGCk9Pkk48jba0ibtuuic2ic9elp0r52TBmB0AbBKFK0sOZ9gf3GWPLicL34Chqrevw\" alt=\"img\" /></p>\n<ol>\n<li><strong><font color='#B32015'>MySQL 自身评估使用全表扫描的查询速度比使用索引的更快</font></strong>：MySQL 在查询时，会评估全表扫描的查询效率与使用索引的效率，如果全表扫描更快，则放弃索引，走全表扫描。这种情况一般是  <code>SELECT *</code>  语句。</li>\n</ol>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231118133740655.png\" alt=\"image-20231118133740655\" /></p>\n<ol start=\"2\">\n<li>\n<p><strong><font color='#B32015'>创建了联合索引，但查询条件未遵循<u>最左前缀匹配原则</u>，或者涉及范围查询（如 <code>&gt;</code> 、 <code>&lt;</code> ）</font></strong>。</p>\n<blockquote>\n<p>指路→<a href=\"#==%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80%E5%8C%B9%E9%85%8D%E5%8E%9F%E5%88%99==\">最左前缀匹配原则</a></p>\n</blockquote>\n</li>\n</ol>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231118133951572.png\" alt=\"image-20231118133951572\" /></p>\n<center>未遵循最左前缀匹配原则</center>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231117221945853.png\" alt=\"image-20231117221945853\" /></p>\n<center>涉及范围查询</center>\n<ol start=\"3\">\n<li><strong><font color='#B32015'>查询条件中，对索引列进行了数学运算、函数等操作</font></strong>：<font color='red'>因为索引保存的是索引字段的原始值</font>，而不是表达式计算后的值 / 函数计算后的值，自然无法走索引了，只能通过把索引字段的取值都取出来，然后依次进行表达式计算 / 函数计算来进行条件判断，因此采用的就是<font color='red'>全表扫描</font>的方式。</li>\n</ol>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231118133046959.png\" alt=\"image-20231118133046959\" /></p>\n<ol start=\"4\">\n<li><strong><font color='#B32015'>查询条件中，对索引列进行以 % 开头的 LIKE 模糊查询</font></strong>：当我们使用左或者左右模糊匹配的时候，也就是 like % xx 或者 like % xx% 这两种方式都会造成索引失效。<font color='red'>因为索引 B+ 树是按照「索引值」有序排列存储的，只能根据前缀进行比较</font>。</li>\n</ol>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231118133112182.png\" alt=\"image-20231118133112182\" /></p>\n<ol start=\"5\">\n<li><strong><font color='#B32015'>查询条件中，OR 前后存在非索引的列</font></strong>：因为 OR 的含义就是两个只要满足一个即可，因此只有一个条件列是索引列是没有意义的，<font color='red'>只要有一个条件列不是索引列，就会进行全表扫描</font>。要想使用 OR，又想让索引生效，只能将 OR 条件中的每个列都加上索引。</li>\n</ol>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231118133312921.png\" alt=\"image-20231118133312921\" /></p>\n<center>age没有索引，id、phone有索引</center>\n<ol start=\"6\">\n<li>\n<p><strong><font color='#B32015'>查询条件中，IN /NOT IN 的取值范围较大</font></strong>：导致索引失效，走全表扫描；</p>\n</li>\n<li>\n<p><strong><font color='#B32015'>发生<span class=\"exturl\" data-url=\"aHR0cHM6Ly9qYXZhZ3VpZGUuY24vZGF0YWJhc2UvbXlzcWwvaW5kZXgtaW52YWxpZGF0aW9uLWNhdXNlZC1ieS1pbXBsaWNpdC1jb252ZXJzaW9uLmh0bWw=\">隐式类型转换</span></font></strong>：<font color='red'>当索引列是字符串类型时，若查询条件中数据不加单引号，虽然对于查询结果没什么影响，但是数据库会进行隐式类型转换，导致索引列失效</font>。</p>\n</li>\n</ol>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231118132957838.png\" alt=\"image-20231118132957838\" /></p>\n<ol start=\"8\">\n<li>……</li>\n</ol>\n<p>推荐阅读这篇文章：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvbXdNRTNxdWtIQkZ1bDU3V1FMa09ZZw==\">美团暑期实习一面：MySQl 索引失效的场景有哪些？</span>。</p>\n<h4 id=\"索引的正确使用建议\"><a class=\"anchor\" href=\"#索引的正确使用建议\">#</a> <mark>索引的正确使用建议</mark></h4>\n<blockquote>\n<p>索引设计原则</p>\n</blockquote>\n<h5 id=\"避免索引失效\"><a class=\"anchor\" href=\"#避免索引失效\">#</a> 避免索引失效</h5>\n<blockquote>\n<p>上一节</p>\n</blockquote>\n<h5 id=\"针对数据量大且查询频繁的表建立索引\"><a class=\"anchor\" href=\"#针对数据量大且查询频繁的表建立索引\">#</a> 针对数据量大，且查询频繁的表建立索引</h5>\n<p>基数较小的表，索引效果较差，没有必要在此列建立索引。</p>\n<h5 id=\"选择合适的字段创建索引\"><a class=\"anchor\" href=\"#选择合适的字段创建索引\">#</a> 选择合适的字段创建索引</h5>\n<ul>\n<li>\n<p><strong>不为 NULL 的字段</strong>：索引字段的数据应该尽量不为 NULL，因为<font color='red'>对于数据值为 NULL 的字段，数据库较难优化</font>。如果字段频繁被查询，但又避免不了为 NULL，<font color='red'>建议使用 0,1,true,false </font>这样语义较为清晰的短值或短字符作为替代。</p>\n</li>\n<li>\n<p><strong>被频繁查询的字段</strong>：我们创建索引的字段应该是查询操作非常频繁的字段。</p>\n</li>\n<li>\n<p><strong>常作为查询条件（where）、排序（order by）、分组（group by）操作的字段</strong>：被作为 WHERE 条件查询的字段，应该被考虑建立索引。索引已经排序，这样查询可以利用索引的排序，加快排序查询时间。</p>\n</li>\n<li>\n<p><strong>被经常频繁用于连接子句中的字段</strong>：经常用于连接的字段可能是一些外键列，对于外键列并不一定要建立外键，只是说该列涉及到表与表的关系。对于频繁被连接查询的字段，可以考虑建立索引，<font color='red'>提高多表连接查询的效率</font>。</p>\n</li>\n</ul>\n<h5 id=\"被频繁更新的字段应该慎重建立索引\"><a class=\"anchor\" href=\"#被频繁更新的字段应该慎重建立索引\">#</a> 被频繁更新的字段应该慎重建立索引</h5>\n<p>因为字段的更新会导致索引的更新，而维护索引的成本也是不小的。因此如果一个字段不被经常查询，反而被经常修改，那么就更不应该在这种字段上建立索引了。</p>\n<h5 id=\"限制每张表上的索引数量\"><a class=\"anchor\" href=\"#限制每张表上的索引数量\">#</a> 限制每张表上的索引数量</h5>\n<p>索引需要额外的磁盘空间，并降低写操作的性能。<font color='red'>在修改表内容的时候，索引会进行更新甚至重构，索引列越多，这个时间就会越长</font>。所以只保持需要的索引有利于查询即可。</p>\n<p><font color='red'>建议单张表索引不超过 5 个！</font></p>\n<p><font color='red'>索引可以增加查询效率，但同样也会降低插入和更新的效率</font>，甚至有些情况下会降低查询效率。</p>\n<h5 id=\"尽量考虑联合索引而不是单列索引\"><a class=\"anchor\" href=\"#尽量考虑联合索引而不是单列索引\">#</a> 尽量考虑联合索引，而不是单列索引</h5>\n<p>因为索引是需要占用磁盘空间的，可以简单理解为每个索引都对应着一颗 B+ 树。如果一个表的字段过多，索引过多，那么当这个表的数据达到一个体量后，索引占用的空间也是很多的，且修改索引时，耗费的时间也是较多的。<font color='red'>如果是联合索引，多个字段在一个索引上，那么将会节约很大磁盘空间，且修改数据的操作效率也会提升</font>。</p>\n<h5 id=\"注意避免冗余索引\"><a class=\"anchor\" href=\"#注意避免冗余索引\">#</a> 注意避免冗余索引</h5>\n<p>冗余索引指的是索引的功能相同，能够命中索引 (a, b) 就肯定能命中索引 (a) ，那么索引 (a) 就是冗余索引。如（name,city ）和（name ）这两个索引就是冗余索引，能够命中前者的查询肯定是能够命中后者的。在大多数情况下，都应该尽量扩展已有的索引而不是创建新索引。</p>\n<h5 id=\"针对字符串类型的字段使用前缀索引短索引\"><a class=\"anchor\" href=\"#针对字符串类型的字段使用前缀索引短索引\">#</a> 针对字符串类型的字段，使用前缀索引（短索引）</h5>\n<p><font color='red'>前缀索引（短索引）仅限于字符串类型，只对字符串的一部分前缀建立索引，大大节约索引空间，提高索引效率</font>。</p>\n<h5 id=\"删除长期未使用的索引\"><a class=\"anchor\" href=\"#删除长期未使用的索引\">#</a> 删除长期未使用的索引</h5>\n<p>不用的索引会造成不必要的性能损耗。MySQL 5.7 可以通过查询  <code>sys</code>  库的  <code>schema_unused_indexes</code>  视图来查询哪些索引从未被使用。</p>\n<h5 id=\"不能有效区分数据的字段不适合做索引列\"><a class=\"anchor\" href=\"#不能有效区分数据的字段不适合做索引列\">#</a> 不能有效区分数据的字段不适合做索引列</h5>\n<p>如性别（男 / 女 / 未知），最多也就三种，区分度实在太低。</p>\n<h5 id=\"利用-explain-命令分析-sql-是否走索引查询\"><a class=\"anchor\" href=\"#利用-explain-命令分析-sql-是否走索引查询\">#</a> 利用 EXPLAIN 命令分析 SQL 是否走索引查询</h5>\n<p>我们可以使用 <strong> <code>EXPLAIN</code>  命令</strong>来分析 SQL 的<strong>执行计划</strong> ，这样就知道语句是否命中索引了。执行计划是指<strong>一条 SQL 语句在经过 MySQL 查询优化器的优化后，具体的执行方式</strong>。</p>\n<p><code>EXPLAIN</code>  并不会真的去执行相关的语句，而是通过 <strong>查询优化器</strong> 对语句进行分析，找出最优的查询方案，并显示对应的信息。</p>\n<p><code>EXPLAIN</code>  的输出格式如下：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231118141340551.png\" alt=\"image-20231118141340551\" /></p>\n<p>各个字段的含义如下：</p>\n<table>\n<thead>\n<tr>\n<th><strong>列名</strong></th>\n<th><strong>含义</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>id</td>\n<td>SELECT 查询的序列标识符</td>\n</tr>\n<tr>\n<td>select_type</td>\n<td>SELECT 关键字对应的查询类型</td>\n</tr>\n<tr>\n<td>table</td>\n<td>用到的表名</td>\n</tr>\n<tr>\n<td>partitions</td>\n<td>匹配的分区，对于未分区的表，值为 NULL</td>\n</tr>\n<tr>\n<td><strong>type</strong></td>\n<td><font color='red'>表的访问方法</font></td>\n</tr>\n<tr>\n<td>possible_keys</td>\n<td><font color='red'>可能用到的索引</font></td>\n</tr>\n<tr>\n<td><strong>key</strong></td>\n<td><font color='red'>实际用到的索引</font></td>\n</tr>\n<tr>\n<td>key_len</td>\n<td><font color='red'>所选索引的长度</font></td>\n</tr>\n<tr>\n<td>ref</td>\n<td>当使用索引等值查询时，与索引作比较的列或常量</td>\n</tr>\n<tr>\n<td>rows</td>\n<td>预计要读取的行数</td>\n</tr>\n<tr>\n<td>filtered</td>\n<td>按表条件过滤后，留存的记录数的百分比</td>\n</tr>\n<tr>\n<td><strong>Extra</strong></td>\n<td><font color='red'>附加信息</font></td>\n</tr>\n</tbody>\n</table>\n<p>篇幅问题，我这里只是简单介绍了一下 MySQL 执行计划，详细介绍请看：<a href=\"\">MySQL 执行计划分析</a>这篇文章。</p>\n<h3 id=\"mysql执行计划\"><a class=\"anchor\" href=\"#mysql执行计划\">#</a> MySQL 执行计划</h3>\n<h4 id=\"各个字段\"><a class=\"anchor\" href=\"#各个字段\">#</a> 各个字段</h4>\n<h5 id=\"id\"><a class=\"anchor\" href=\"#id\">#</a> id</h5>\n<p>SELECT 标识符，是查询中 SELECT 的序号，用来标识整个查询中 SELELCT 语句的顺序。</p>\n<ul>\n<li><font color='red'>id 如果相同，从上往下依次执行</font>。</li>\n<li>id 不同，<font color='red'>id 值越大，执行优先级越高</font>，如果行引用其他行的并集结果，则该值可以为 NULL。</li>\n</ul>\n<h5 id=\"select_type\"><a class=\"anchor\" href=\"#select_type\">#</a> select_type</h5>\n<p>查询的类型，主要用于区分普通查询、联合查询、子查询等复杂的查询，常见的值有：</p>\n<ul>\n<li><strong>SIMPLE</strong>：<font color='red'>简单查询</font>，不包含 UNION 或者子查询。</li>\n<li><strong>PRIMARY</strong>：查询中如果包含子查询或其他部分，<font color='red'>外层的 SELECT </font>将被标记为 PRIMARY。</li>\n<li><strong>SUBQUERY</strong>：<font color='red'>子查询中的第一个 SELECT</font>。</li>\n<li><strong>UNION</strong>：在 UNION 语句中，<font color='red'>UNION 之后出现的 SELECT</font>。</li>\n<li><strong>DERIVED</strong>：<font color='red'>在 FROM 中出现的子查询</font>将被标记为 DERIVED。</li>\n<li><strong>UNION RESULT</strong>：UNION 查询的结果。</li>\n</ul>\n<h5 id=\"table\"><a class=\"anchor\" href=\"#table\">#</a> table</h5>\n<p>查询用到的表名，每行都有对应的表名，表名除了正常的表之外，也可能是以下列出的值：</p>\n<ul>\n<li><strong> <code>&lt;unionM,N&gt;</code> </strong> : 本行引用了 id 为 M 和 N 的行的 UNION 结果；</li>\n<li><strong> <code>&lt;derivedN&gt;</code> </strong> : 本行引用了 id 为 N 的表所产生的的派生表结果。派生表有可能产生自 FROM 语句中的子查询。</li>\n<li><strong> <code>&lt;subqueryN&gt;</code> </strong> : 本行引用了 id 为 N 的表所产生的的物化子查询结果。</li>\n</ul>\n<h5 id=\"type重要\"><a class=\"anchor\" href=\"#type重要\">#</a> <mark>type（重要）</mark></h5>\n<p>查询执行的类型，描述了查询是如何执行的。所有值的顺序从最优到最差排序为：system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL</p>\n<p>常见的几种类型具体含义如下（<strong>按照执行效率从低到高的顺序</strong>）：</p>\n<ul>\n<li>\n<p><font color='cornflowerblue'>All（全表扫描）</font>：最坏的情况，因为采用了<font color='red'>全表扫描</font>的方式</p>\n</li>\n<li>\n<p><font color='cornflowerblue'>index（全索引扫描）</font>：<font color='red'>查询遍历了整棵索引树</font>，和 all 差不多，只不过扫描的是索引，而索引一般在内存中，速度更快。只不过 index <font color='red'>对索引表进行全扫描</font>。这样做的好处是不再需要对数据进行排序，但是开销依然很大。</p>\n<blockquote>\n<p>所以要尽量避免全表扫描和全索引扫描。</p>\n</blockquote>\n</li>\n<li>\n<p><font color='cornflowerblue'>range（对索引进行范围扫描）</font>：一般在 where 子句中使用 &lt;、&gt;、in、between 等关键词，只检索给定范围的行，属于范围查找。执行计划中的 key 列表示哪个索引被使用了。</p>\n<blockquote>\n<p><strong><font color='red'>从这一级别开始，索引的作用会越来越明显，因此我们需要尽量让 SQL 查询可以使用到 range 这一级别及以上的 type 访问方式</font></strong>。</p>\n</blockquote>\n</li>\n<li>\n<p><font color='cornflowerblue'>ref（非唯一索引扫描）</font>：<font color='red'>采用了非唯一索引，或者是唯一索引的非唯一性前缀</font>，<font color='red'>查询结果可能返回多条符合条件的行</font>。因为虽然使用了索引，但<font color='red'>该索引列的值并不唯一，有重复</font>。这样即使使用索引快速查找到了第一条数据，仍然不能停止，要进行目标值附近的小范围扫描。但它的<font color='red'>好处是它并不需要扫全表，因为索引是有序的，即便有重复值，也是在一个非常小的范围内扫描</font>。</p>\n</li>\n<li>\n<p><font color='cornflowerblue'>eq_ref（唯一索引扫描）</font>：<font color='red'>使用主键索引或唯一索引</font>时产生的访问方式，<font color='red'>通常使用在多表联查中</font>。比如，对两张表进行联查，关联条件是两张表的 user_id 相等，且 user_id 是唯一索引，那么使用 EXPLAIN 进行执行计划查看的时候，type 就会显示 eq_ref。</p>\n</li>\n<li>\n<p><font color='cornflowerblue'>const</font>：<font color='red'>使用了主键或者唯一索引与常量值进行比较</font>，表中最多只有一行匹配的记录，一次查询就可以找到。比如 select name from product where id=1。</p>\n</li>\n</ul>\n<p>需要说明的是 const 类型和 eq_ref 都使用了主键或唯一索引，不过这两个类型有所区别，<strong><font color='red'>const 是与常量进行比较，查询效率会更快；而 eq_ref 通常用于多表联查中</font></strong>。</p>\n<ul>\n<li><font color='cornflowerblue'>system</font>：如果表使用的引擎对于表行数统计是精确的（如：MyISAM），且表中只有一行记录的情况下，访问方法是 system ，是 const 的一种特例。</li>\n</ul>\n<p>下面这个不知道性能如何...</p>\n<ul>\n<li><strong>index_merge</strong>：当查询条件使用了多个索引时，表示开启了 Index Merge 优化，此时执行计划中的 key 列列出了使用到的索引。</li>\n</ul>\n<h5 id=\"possible_keys\"><a class=\"anchor\" href=\"#possible_keys\">#</a> possible_keys</h5>\n<p>possible_keys 列表示<font color='red'> MySQL 执行查询时可能用到的索引</font>。如果这一列为 NULL ，则表示没有可能用到的索引；这种情况下，需要检查 WHERE 语句中所使用的的列，看是否可以通过给这些列中某个或多个添加索引的方法来提高查询性能。</p>\n<h5 id=\"key重要\"><a class=\"anchor\" href=\"#key重要\">#</a> key（重要）</h5>\n<p>key 列表示<font color='red'> MySQL 实际使用到的索引</font>。如果为 NULL，则表示未用到索引。</p>\n<h5 id=\"key_len\"><a class=\"anchor\" href=\"#key_len\">#</a> key_len</h5>\n<p>key_len 列表示 MySQL 实际使用的索引的最大长度；当使用到联合索引时，有可能是多个列的长度和。在满足需求的前提下越短越好。如果 key 列显示 NULL ，则 key_len 列也显示 NULL 。</p>\n<h5 id=\"rows\"><a class=\"anchor\" href=\"#rows\">#</a> rows</h5>\n<p>rows 列表示根据表统计信息及选用情况，大致估算出找到所需的记录或所需读取的行数，数值越小越好。</p>\n<h5 id=\"extra重要\"><a class=\"anchor\" href=\"#extra重要\">#</a> <mark>Extra（重要）</mark></h5>\n<p>这列包含了 MySQL 解析查询的额外信息，通过这些信息，可以更准确的理解 MySQL 到底是如何执行查询的。常见的值如下：</p>\n<ul>\n<li><strong><font color='cornflowerblue'>Using filesort</font></strong>：在排序时使用了外部的索引排序，没有用到表内索引进行排序。</li>\n<li><strong><font color='cornflowerblue'>Using temporary</font></strong>：MySQL 需要创建临时表来存储查询的结果，常见于 ORDER BY 和 GROUP BY。</li>\n<li><strong><font color='cornflowerblue'>Using index</font></strong>：表明查询使用了覆盖索引，不用回表，查询效率非常高。</li>\n<li><strong>Using index condition</strong>：表示查询优化器选择使用了索引条件下推这个特性。</li>\n<li><strong>Using where</strong>：表明查询使用了 WHERE 子句进行条件过滤。一般在没有使用到索引的时候会出现。</li>\n<li><strong>Using join buffer (Block Nested Loop)</strong>：连表查询的方式，表示当被驱动表的没有使用索引的时候，MySQL 会先将驱动表读出来放到 join buffer 中，再遍历被驱动表与驱动表进行查询。</li>\n</ul>\n<p>这里提醒下，当 Extra 列包含 Using filesort 或 Using temporary 时，MySQL 的性能可能会存在问题，需要尽可能避免。</p>\n<h4 id=\"explain的结果有哪些有哪些信息去告诉你怎么优化\"><a class=\"anchor\" href=\"#explain的结果有哪些有哪些信息去告诉你怎么优化\">#</a> <mark>explain 的结果有哪些？有哪些信息去告诉你怎么优化？</mark></h4>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231130210942311.png\" alt=\"image-20231130210942311\" /></p>\n<p>对于执行计划，参数有：</p>\n<ul>\n<li><code>possible_keys</code> ：可能用到的索引；</li>\n<li><code>key</code> ：<font color='red'>实际用的索引</font>。如果这一项为 NULL，说明没有使用索引；</li>\n<li><code>key_len</code> ：索引的长度；</li>\n<li><code>rows</code> ：扫描的数据行数；</li>\n<li><code>type</code> ：<font color='red'>数据扫描类型</font>；</li>\n<li><code>Extra</code> ：<font color='red'>MySQL 解析查询的额外信息</font>；</li>\n</ul>\n<h5 id=\"type-字段\"><a class=\"anchor\" href=\"#type-字段\">#</a> type 字段</h5>\n<p>type 字段描述了<font color='red'>找到所需数据时使用的扫描方式</font>是什么，常见扫描类型的 **<font color='#B32015'>执行效率从低到高的顺序为</font>**：</p>\n<ul>\n<li>\n<p><font color='cornflowerblue'>All（全表扫描）</font>：最坏的情况，因为采用了<font color='red'>全表扫描</font>的方式</p>\n</li>\n<li>\n<p><font color='cornflowerblue'>index（全索引扫描）</font>： 和 all 差不多，只不过 index <font color='red'>对索引表进行全扫描</font>。这样做的好处是不再需要对数据进行排序，但是开销依然很大。</p>\n<blockquote>\n<p>所以要尽量避免全表扫描和全索引扫描。</p>\n</blockquote>\n</li>\n<li>\n<p><font color='cornflowerblue'>range（索引范围扫描）</font>：一般在 where 子句中使用 &lt;、&gt;、in、between 等关键词，只检索给定范围的行，属于范围查找。</p>\n<blockquote>\n<p><strong><font color='red'>从这一级别开始，索引的作用会越来越明显，因此我们需要尽量让 SQL 查询可以使用到 range 这一级别及以上的 type 访问方式</font></strong>。</p>\n</blockquote>\n</li>\n<li>\n<p><font color='cornflowerblue'>ref（非唯一索引扫描）</font>：采用了非唯一索引，或者是唯一索引的非唯一性前缀，<font color='red'>返回的数据可能是多条</font>。因为虽然使用了索引，但<font color='red'>该索引列的值并不唯一，有重复</font>。这样即使使用索引快速查找到了第一条数据，仍然不能停止，要进行目标值附近的小范围扫描。但它的<font color='red'>好处是它并不需要扫全表，因为索引是有序的，即便有重复值，也是在一个非常小的范围内扫描</font>。</p>\n</li>\n<li>\n<p><font color='cornflowerblue'>eq_ref（唯一索引扫描）</font>：<font color='red'>使用主键索引或唯一索引</font>时产生的访问方式，<font color='red'>通常使用在多表联查中</font>。比如，对两张表进行联查，关联条件是两张表的 user_id 相等，且 user_id 是唯一索引，那么使用 EXPLAIN 进行执行计划查看的时候，type 就会显示 eq_ref。</p>\n</li>\n<li>\n<p><font color='cornflowerblue'>const（结果只有一条的主键或唯一索引扫描）</font>：<font color='red'>使用了主键或者唯一索引与常量值进行比较</font>，比如 select name from product where id=1。</p>\n</li>\n</ul>\n<p>需要说明的是 const 类型和 eq_ref 都使用了主键或唯一索引，不过这两个类型有所区别，<strong><font color='red'>const 是与常量进行比较，查询效率会更快；而 eq_ref 通常用于多表联查中</font></strong>。</p>\n<h5 id=\"extra-字段\"><a class=\"anchor\" href=\"#extra-字段\">#</a> Extra 字段</h5>\n<p>这里说几个重要的参考指标：</p>\n<ul>\n<li><font color='cornflowerblue'>Using filesort</font>：当查询语句中包含 group by 操作，而且无法利用索引完成排序操作的时候，这时<font color='red'>不得不选择相应的排序算法进行，甚至可能会通过文件排序，效率是很低的</font>，所以要避免这种问题的出现。</li>\n<li><font color='cornflowerblue'>Using temporary</font>：<font color='red'>使用临时表保存中间结果</font>，MySQL 在对查询结果排序时使用临时表，常见于排序 order by 和分组查询 group by。效率低，要避免这种问题的出现。</li>\n<li><font color='cornflowerblue'>Using index</font>：所需数据只需在索引即可全部获得，不须要再到表中取数据，也就是<font color='red'>使用了覆盖索引，避免了回表操作</font>，效率不错。</li>\n</ul>\n<h3 id=\"mysql查询缓存\"><a class=\"anchor\" href=\"#mysql查询缓存\">#</a> MySQL 查询缓存</h3>\n<h4 id=\"介绍\"><a class=\"anchor\" href=\"#介绍\">#</a> 介绍</h4>\n<p><font color='red'>执行查询语句的时候，会先查询缓存</font>。不过，<strong><font color='#B32015'>MySQL 8.0 版本后移除</font></strong>，因为这个功能不太实用。</p>\n<p><code>my.cnf</code>  加入以下配置，重启 MySQL 开启查询缓存：</p>\n<figure class=\"highlight properties\"><figcaption data-lang=\".properties\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token key attr-name\">query_cache_type</span><span class=\"token punctuation\">=</span><span class=\"token value attr-value\">1</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token key attr-name\">query_cache_size</span><span class=\"token punctuation\">=</span><span class=\"token value attr-value\">600000</span></pre></td></tr></table></figure><p>MySQL 执行以下命令也可以开启查询缓存：</p>\n<figure class=\"highlight properties\"><figcaption data-lang=\".properties\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token key attr-name\">set</span> <span class=\"token value attr-value\">global  query_cache_type=1;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token key attr-name\">set</span> <span class=\"token value attr-value\">global  query_cache_size=600000;</span></pre></td></tr></table></figure><p>如上，<strong><font color='red'>开启查询缓存后，在同样的查询条件以及数据情况下，会直接在缓存中返回结果</font></strong>。这里的查询条件包括查询本身、当前要查询的数据库、客户端协议版本号等一些可能影响结果的信息。</p>\n<p><strong>查询缓存不命中的情况：</strong></p>\n<ol>\n<li><font color='red'>任何两个查询在任何字符上的不同</font>都会导致缓存不命中。</li>\n<li>如果查询中包含任何<font color='red'>用户自定义函数、存储函数、用户变量、临时表、MySQL 库中的系统表</font>，其查询结果也不会被缓存。</li>\n<li>缓存建立之后，MySQL 的查询缓存系统会跟踪查询中涉及的每张表，<font color='red'>如果这些表（数据或结构）发生变化，那么相关的所有缓存数据都将失效</font>。</li>\n</ol>\n<p>** 缓存虽然能够提升数据库的查询性能，但是缓存同时也带来了额外的开销，每次查询后都要做一次缓存操作，失效后还要销毁。** 因此，开启查询缓存要谨慎，尤其对于写密集的应用来说更是如此。如果开启，要注意合理控制缓存空间大小，一般来说其大小设置为几十 MB 比较合适。</p>\n<p>此外，还可以通过  <code>sql_cache</code>  和  <code>sql_no_cache</code>  来控制某个查询语句是否需要缓存：</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">select</span> sql_no_cache <span class=\"token function\">count</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">from</span> usr<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h4 id=\"总结\"><a class=\"anchor\" href=\"#总结\">#</a> 总结</h4>\n<p><font color='red'>MySQL 中的查询缓存虽然能够提升数据库的查询性能，但是查询同时也带来了额外的开销，每次查询后都要做一次缓存操作，失效后还要销毁</font>。</p>\n<p>查询缓存是一个适用较少情况的缓存机制。如果你的应用对数据库的更新很少，那么查询缓存将会作用显著。比较典型的如博客系统，一般博客<font color='red'>更新相对较慢，数据表相对稳定不变，这时候查询缓存的作用会比较明显</font>。</p>\n<p>简单总结一下查询缓存的<font color='gree'>适用场景</font>：</p>\n<ul>\n<li>表数据修改不频繁、数据较静态</li>\n<li>查询（Select）重复度高</li>\n<li>查询结果集小于 1 MB</li>\n</ul>\n<p>对于一个更新频繁的系统来说，查询缓存缓存的作用是很微小的，在某些情况下开启查询缓存会带来性能的下降。</p>\n<p>简单总结一下查询缓存<font color='gree'>不适用的场景</font>：</p>\n<ul>\n<li>表中的数据、表结构或者索引变动频繁</li>\n<li>重复的查询很少</li>\n<li>查询的结果集很大</li>\n</ul>\n<p>《高性能 MySQL》这样写到：</p>\n<blockquote>\n<p>根据我们的经验，<strong><font color='red'>在高并发压力环境中查询缓存会导致系统性能的下降，甚至僵死</font></strong>。如果你一定要使用查询缓存，那么不要设置太大内存，而且只有在明确收益的时候才使用（数据库内容修改次数较少）。</p>\n</blockquote>\n<p>确实是这样的！<strong><font color='red'>实际项目中，更建议使用本地缓存（比如 Caffeine）或者分布式缓存（比如 Redis），性能更好，更通用一些。</font></strong></p>\n<h3 id=\"mysql三大日志\"><a class=\"anchor\" href=\"#mysql三大日志\">#</a> <mark>MySQL 三大日志</mark></h3>\n<blockquote>\n<p>binlog、redo log、undo log</p>\n</blockquote>\n<h4 id=\"简介\"><a class=\"anchor\" href=\"#简介\">#</a> <mark>简介</mark></h4>\n<p><code>MySQL</code>  日志 主要包括错误日志、查询日志、事务日志、二进制日志几大类。其中，比较重要的还要属：</p>\n<ul>\n<li>二进制日志： <code>binlog</code> （归档日志）</li>\n<li>事务日志： <code>redo log</code> （重做日志）、  <code>undo log</code> （回滚日志）</li>\n</ul>\n<p>下面对这三种日志进行简介：</p>\n<ul>\n<li><strong><font color='cornflowerblue'>binlog（二进制日志 / 归档日志）</font></strong>：<font color='red'>是逻辑日志，记录了语句的原始逻辑</font>。无论用哪种存储引擎，<font color='red'>只要表发生了数据更新，都会产生 binlog 日志</font>。<strong><font color='red'>主要用于主从复制（读写分离）</font></strong>，在主从复制中，从库利用主库上的 binlog 进行重播，实现主从数据同步。</li>\n<li><strong><font color='cornflowerblue'>redo log（重做日志）</font></strong>：<font color='red'>是物理日志，记录了在某个数据页上做了什么修改</font>。防止在发生故障的时间点，尚有脏页未写入磁盘，在重启 mysql 服务的时候，<strong><font color='red'>根据 redo log 进行重做，从而确保事务的持久性（D）</font></strong>。</li>\n<li><strong><font color='cornflowerblue'>undo log（回滚日志）</font></strong>：<font color='red'>是逻辑日志，记录的是逻辑相反的操作信息</font>。可以 **<font color='red'>用于回滚</font><strong>，当执行 rollback 时，就可以从 undo log 中的逻辑记录读取到相应的内容并进行回滚，以确保事务的原子性（A）。同时</strong><font color='red'>可以提供 MVCC 下的读（即非锁定读 / 快照读）</font>**。</li>\n</ul>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/01.png\" alt=\"img\" /></p>\n<h4 id=\"redo-log重做日志-2\"><a class=\"anchor\" href=\"#redo-log重做日志-2\">#</a> redo log（重做日志）</h4>\n<p><code>redo log</code> （重做日志）<font color='red'>是 InnoDB 存储引擎独有的</font>，它让 <code>MySQL</code>  拥有了<strong>崩溃恢复能力</strong>。</p>\n<p>比如  <code>MySQL</code>  实例挂了或宕机了，重启时， <code>InnoDB</code>  存储引擎会使用 <code>redo log</code>  恢复数据，保证数据的持久性与完整性。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/02.png\" alt=\"img\" /></p>\n<p>InnoDB 表的读写流程：</p>\n<ol>\n<li><font color='red'>MySQL 中数据以页为单位</font>，你查询一条记录，会从硬盘把一页的数据加载出来，加载出来的数据叫<strong>数据页</strong>，会放入到 <strong>缓冲池 Buffer Pool</strong> 中。</li>\n<li>后续的查询都是先从 缓冲池 Buffer Pool 中找，没有命中再去硬盘加载，减少硬盘  <code>IO</code>  开销，提升性能。更新表数据的时候，也是如此，发现缓冲池 Buffer Pool 里存在要更新的数据，就直接在缓冲池 Buffer Pool 里更新。</li>\n<li>然后会把 “在某个数据页上做了什么修改” 记录到 ** 重做日志缓存（ <code>redo log buffer</code> ）** 里</li>\n<li>最后，清空 redo log buffer，并刷盘到 <strong>redo log file</strong> 中</li>\n</ol>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/03.png\" alt=\"img\" /></p>\n<h5 id=\"刷盘时机\"><a class=\"anchor\" href=\"#刷盘时机\">#</a> 刷盘时机</h5>\n<blockquote>\n<p>小贴士：<font color='red'>每条 redo 记录由 “表空间号 + 数据页号 + 偏移量 + 修改数据长度 + 具体修改的数据” 组成</font>。</p>\n</blockquote>\n<p>InnoDB 将 redo log buffer 刷到磁盘上有几种情况：</p>\n<ol>\n<li>\n<p><strong>事务提交</strong>：当事务提交时，redo log buffer 里的 redo log 会被刷新到磁盘（可以通过 <code>innodb_flush_log_at_trx_commit</code>  参数控制，后文会提到）。</p>\n</li>\n<li>\n<p><strong>log buffer 空间不足时</strong>：当 log buffer 的容量被占满大约一半时，就需要把这些日志刷新到磁盘上。</p>\n</li>\n<li>\n<p><strong>事务日志缓冲区（transaction log buffer）满时</strong>：InnoDB 使用一个事务日志缓冲区来暂时存储事务的重做日志条目。当缓冲区满时，会触发日志的刷新，将日志写入磁盘。</p>\n</li>\n<li>\n<p><strong>定期执行 Checkpoint（检查点）操作时</strong>：InnoDB 定期会执行检查点操作，将内存中的<font color='red'>脏数据（已修改但尚未写入磁盘的数据）</font>刷新到磁盘，并且会将相应的重做日志一同刷新，以确保数据的一致性。</p>\n</li>\n<li>\n<p><strong><font color='#B32015'>后台线程会周期性刷盘</font></strong>：InnoDB 启动了一个后台线程，负责周期性（每隔 1 秒）地把 redo log buffer 中的内容写到<strong>文件系统缓存（page cache）</strong>，然后调用 <strong> <code>fsync</code> </strong> 刷盘。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/04.png\" alt=\"img\" /></p>\n</li>\n<li>\n<p><strong>正常关闭服务器时</strong>：MySQL 关闭的时候，redo log 都会刷入到磁盘里去。</p>\n</li>\n</ol>\n<p>总之，InnoDB 在多种情况下会刷新重做日志，以保证数据的持久性和一致性。</p>\n<hr />\n<p>我们要注意设置正确的 **<font color='red'>刷盘策略参数  <code>innodb_flush_log_at_trx_commit</code> </font>**。根据 MySQL 配置的刷盘策略的不同，MySQL 宕机之后可能会存在轻微的数据丢失问题。该参数的取值有 3 种，也就是共有 3 种刷盘策略：</p>\n<ul>\n<li>\n<p><strong>0</strong>：设置为 0 的时候，表示<font color='red'>每次事务提交时不进行刷盘操作</font>，而是等待后台线程定期（1 秒）刷盘。这种方式性能最高，但是也最不安全，因为如果 MySQL 挂了或宕机了，可能会丢失最近 1 秒内的事务。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/06.png\" alt=\"img\" /></p>\n</li>\n<li>\n<p><strong>1</strong>：设置为 1 的时候，表示<font color='red'>每次事务提交时都将进行刷盘操作</font>。这种方式性能最低，但是也最安全，因为只要事务提交成功，redo log 记录就一定在磁盘里，不会有任何数据丢失。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/07.png\" alt=\"img\" /></p>\n</li>\n<li>\n<p><strong>2</strong>：设置为 2 的时候，表示<font color='red'>每次事务提交时都只把 log buffer 里的 redo log 内容写入 page cache（文件系统缓存）</font>。page cache 是专门用来缓存文件的，这里被缓存的文件就是 redo log 文件。这种方式的性能和安全性都介于前两者中间。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/09.png\" alt=\"img\" /></p>\n</li>\n</ul>\n<h5 id=\"日志文件组\"><a class=\"anchor\" href=\"#日志文件组\">#</a> 日志文件组</h5>\n<p>硬盘上存储的  <code>redo log</code>  是以一个<strong>日志文件组</strong>的形式出现的，每个日志文件的大小都一样。</p>\n<p>比如可以配置为一组 4 个文件，每个文件的大小是 1GB，那么整个  <code>redo log</code>  日志文件组可以记录 4G 的内容。</p>\n<p>它采用的是<font color='red'>环形数组形式</font>，从头开始写，写到末尾又回到头循环写，如下图所示。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/10.png\" alt=\"img\" /></p>\n<p>在日志文件组中还有两个重要的属性：</p>\n<ul>\n<li><strong>write pos</strong> ：当前记录的写入位置，一边写一边后移</li>\n<li><strong>checkpoint</strong>：当前要擦除的位置，也是往后推移</li>\n</ul>\n<p>每次刷盘  <code>redo log</code>  记录到<strong>日志文件组</strong>中， <code>write pos</code>  位置就会后移更新。</p>\n<p>每次 MySQL 加载<strong>日志文件组</strong>恢复数据时，会清空加载过的  <code>redo log</code>  记录，并把  <code>checkpoint</code>  后移更新。</p>\n<p><code>write pos</code>  和  <code>checkpoint</code>  之间的还空着的部分可以用来写入新的  <code>redo log</code>  记录。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/11.png\" alt=\"img\" /></p>\n<p>如果  <code>write pos</code>  追上  <code>checkpoint</code>  ，表示<strong>日志文件组</strong>满了，这时候不能再写入新的  <code>redo log</code>  记录， <code>MySQL</code>  得停下来，清空一些记录，把  <code>checkpoint</code>  推进一下。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/12.png\" alt=\"img\" /></p>\n<p>在 MySQL 8.0.30 之前，可以通过  <code>innodb_log_files_in_group</code>  和  <code>innodb_log_file_size</code>  配置日志文件组的文件数和文件大小。</p>\n<p>但在 MySQL 8.0.30 及之后的版本中，这两个变量已被废弃，即使被指定也是用来计算  <code>innodb_redo_log_capacity</code>  的值。而<font color='red'>日志文件组的文件数则固定为 32，文件大小则为  <code>innodb_redo_log_capacity / 32</code> </font>。</p>\n<h5 id=\"小结\"><a class=\"anchor\" href=\"#小结\">#</a> 小结</h5>\n<p>思考一个问题：<strong>只要每次把修改后的数据页直接刷盘不就好了，还有  <code>redo log</code>  什么事？</strong></p>\n<p>它们不都是刷盘么？差别在哪里？</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token number\">1</span> <span class=\"token class-name\">Byte</span> <span class=\"token operator\">=</span> <span class=\"token number\">8</span>bit</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token number\">1</span> <span class=\"token constant\">KB</span> <span class=\"token operator\">=</span> <span class=\"token number\">1024</span> <span class=\"token class-name\">Byte</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token number\">1</span> <span class=\"token constant\">MB</span> <span class=\"token operator\">=</span> <span class=\"token number\">1024</span> <span class=\"token constant\">KB</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token number\">1</span> <span class=\"token constant\">GB</span> <span class=\"token operator\">=</span> <span class=\"token number\">1024</span> <span class=\"token constant\">MB</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token number\">1</span> <span class=\"token constant\">TB</span> <span class=\"token operator\">=</span> <span class=\"token number\">1024</span> <span class=\"token constant\">GB</span></pre></td></tr></table></figure><p>实际上，<font color='red'>数据页大小是 <code>16KB</code> ，刷盘比较耗时</font>，可能就修改了数据页里的几  <code>Byte</code>  数据，有必要把完整的数据页刷盘吗？</p>\n<p>而且数据页刷盘是随机写，因为一个数据页对应的位置可能在硬盘文件的随机位置，所以性能是很差。</p>\n<p>如果是写  <code>redo log</code> ，一行记录可能就占几十  <code>Byte</code> ，只包含表空间号、数据页号、磁盘文件偏移量、更新值，再加上是顺序写，所以刷盘速度很快。</p>\n<p>所以<font color='red'>用  <code>redo log</code>  形式记录修改内容，性能会远远超过刷数据页的方式，这也让数据库的并发能力更强</font>。</p>\n<blockquote>\n<p>其实内存的数据页在一定时机也会刷盘，我们把这称为<strong>页合并</strong>，讲  <code>Buffer Pool</code>  的时候会对这块细说</p>\n</blockquote>\n<h4 id=\"binlog归档日志\"><a class=\"anchor\" href=\"#binlog归档日志\">#</a> binlog（归档日志）</h4>\n<p><code>redo log</code>  它是物理日志，记录内容是 “在某个数据页上做了什么修改”，属于  <code>InnoDB</code>  存储引擎。</p>\n<p>而 <font color='red'> <code>binlog</code>  是逻辑日志，记录内容是语句的原始逻辑，会记录所有涉及更新数据的逻辑操作，并且是顺序写。</font>类似于 “给 ID=2 这一行的 c 字段加 1”，属于 <code>MySQL Server</code>  层。</p>\n<p>不管用什么存储引擎，<font color='red'>只要发生了表数据更新，都会产生  <code>binlog</code>  日志</font>。</p>\n<p>可以说 <code>MySQL</code>  数据库的<font color='red'>数据备份、主备、主主、主从</font>都离不开 <code>binlog</code> ，需要依靠 <code>binlog</code>  来<strong>同步数据，保证数据一致性</strong>。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/01-20220305234724956.png\" alt=\"img\" /></p>\n<h5 id=\"记录格式\"><a class=\"anchor\" href=\"#记录格式\">#</a> 记录格式</h5>\n<p><code>binlog</code>  日志有三种格式，可以通过 <code>binlog_format</code>  参数指定。</p>\n<ul>\n<li>\n<p><strong>statement</strong>：记录的是 **<font color='red'>SQL 语句原文</font>**。比如执行一条 <code>update T set update_time=now() where id=1</code> ，记录的内容如下：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/02-20220305234738688.png\" alt=\"img\" /></p>\n<p>同步数据时，会执行记录的 SQL 语句，但是有个问题， <code>update_time=now()</code>  这里会获取当前系统时间，直接执行会导致与原库的数据不一致。为了解决这种问题，我们需要指定为 <code>row</code> 。</p>\n</li>\n<li>\n<p><strong>row</strong>：<font color='red'>防止数据不一致</font>，记录的是 **<font color='red'>包含具体操作数据的 SQL 语句</font>**，需要通过工具 <code>mysqlbinlog</code>  解析。这样就能保证同步数据的一致性，通常情况下都是指定为 <code>row</code> ，这样可以<font color='red'>为数据库的恢复与同步带来更好的可靠性</font>。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/03-20220305234742460.png\" alt=\"img\" /></p>\n<p>但是这种格式，<font color='red'>需要更大的容量来记录，比较占用空间</font>，恢复与同步时会更消耗 IO 资源，影响执行速度。</p>\n</li>\n<li>\n<p><strong>mixed</strong>：一种折中的方案，记录的是 **<font color='red'>前两者的混合</font>**。MySQL 会<font color='red'>判断这条 SQL 语句是否可能引起数据不一致，如果是，就用 <code>row</code>  格式，否则就用 <code>statement</code>  格式</font>。</p>\n</li>\n</ul>\n<h5 id=\"写入机制\"><a class=\"anchor\" href=\"#写入机制\">#</a> 写入机制</h5>\n<p><code>binlog</code>  的写入时机也非常简单，<strong>事务执行过程中，先把日志写到 <code>binlog cache</code> ，事务提交的时候，再把 <code>binlog cache</code>  写到 <code>binlog</code>  文件中</strong>。</p>\n<p>因为一个事务的 <code>binlog</code>  不能被拆开，无论这个事务多大，也要确保一次性写入，所以系统会给每个线程分配一个块内存作为 <code>binlog cache</code> 。</p>\n<p>我们可以通过 <code>binlog_cache_size</code>  参数控制单个线程 binlog cache 大小，如果存储内容超过了这个参数，就要暂存到磁盘（ <code>Swap</code> ）。</p>\n<hr />\n<p><code>binlog</code>  日志刷盘流程如下：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/04-20220305234747840.png\" alt=\"img\" /></p>\n<ul>\n<li><strong>write：把 binlog 日志写入到文件系统的 page cache，并没有把数据持久化到磁盘，所以速度比较快</strong></li>\n<li><strong>fsync：将数据持久化到磁盘的操作</strong></li>\n</ul>\n<hr />\n<p>write 和 fsync 的时机，可以由 ** 参数 <code>sync_binlog</code> ** 控制，默认是 1。</p>\n<p>为 0 的时候，表示每次提交事务都只 <code>write</code> ，由系统自行判断什么时候执行 <code>fsync</code> 。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/05-20220305234754405.png\" alt=\"img\" /></p>\n<p>虽然性能得到提升，但是机器宕机， <code>page cache</code>  里面的 binlog 会丢失。</p>\n<p>为了安全起见，可以设置为 <code>1</code> ，表示每次提交事务都会执行 <code>fsync</code> ，就如同 <strong>redo log 日志刷盘流程</strong> 一样。</p>\n<hr />\n<p>还有一种折中方式，可以设置为 <code>N(N&gt;1)</code> ，表示每次提交事务都 <code>write</code> ，但累积 <code>N</code>  个事务后才 <code>fsync</code> 。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/06-20220305234801592.png\" alt=\"img\" /></p>\n<p>在出现 <code>IO</code>  瓶颈的场景里，将 <code>sync_binlog</code>  设置成一个比较大的值，可以提升性能。</p>\n<p>同样的，如果机器宕机，会丢失最近 <code>N</code>  个事务的 <code>binlog</code>  日志。</p>\n<h4 id=\"两阶段提交\"><a class=\"anchor\" href=\"#两阶段提交\">#</a> <mark>两阶段提交</mark></h4>\n<blockquote>\n<p>解决 redo log 和 binlog 的一致性问题</p>\n</blockquote>\n<p>在执行更新语句过程，会记录  <code>redo log</code>  与  <code>binlog</code>  两块日志，以基本的事务为单位，<font color='red'> <code>redo log</code>  在事务执行过程中可以不断写入，而 <code>binlog</code>  只有在提交事务时才写入</font>，所以 <code>redo log</code>  与 <code>binlog</code>  的写入时机不一样。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/01-20220305234816065.png\" alt=\"img\" /></p>\n<hr />\n<p>为了解决两份日志之间的逻辑一致问题， <code>InnoDB</code>  存储引擎使用 <strong>两阶段提交</strong> 方案。原理很简单，<font color='red'>将  <code>redo log</code>  的写入拆成了两个步骤  <code>prepare</code>  和  <code>commit</code>  </font>。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/04-20220305234956774.png\" alt=\"img\" /></p>\n<p><font color='red'>使用两阶段提交后，写入  <code>binlog</code>  时发生异常也不会有影响，因为 MySQL 根据  <code>redo log</code>  日志恢复数据时，发现  <code>redo log</code>  还处于  <code>prepare</code>  阶段，并且没有对应  <code>binlog</code>  日志，就会回滚该事务</font>。</p>\n<hr />\n<p>再看一个场景， <code>redo log</code>  设置  <code>commit</code>  阶段发生异常，此时不会回滚事务。它会执行下图框住的逻辑，虽然 <code>redo log</code>  是处于 <code>prepare</code>  阶段，但是能通过事务 <code>id</code>  找到对应的 <code>binlog</code>  日志，所以 <code>MySQL</code>  认为是完整的，就会提交事务恢复数据。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/06-20220305234907651.png\" alt=\"img\" /></p>\n<hr />\n<p>这意味着一个事务到底有没有成功，看  <code>redo log</code>  里面有没有 commit 记录，如果有 commit 记录，那么  <code>binlog</code>  一定是持久化成功了，也就是说事务成功了。</p>\n<h4 id=\"undo-log回滚日志\"><a class=\"anchor\" href=\"#undo-log回滚日志\">#</a> undo log（回滚日志）</h4>\n<p>我们知道如果想要保证事务的原子性，就需要在异常发生时，对已经执行的操作进行<strong>回滚</strong>。在 MySQL 中，恢复机制是通过 ** 回滚日志（undo log）** 实现的。</p>\n<p>所有事务进行的修改都会先记录到这个回滚日志中，然后再执行相关的操作。如果执行过程中遇到异常的话，我们直接利用回滚日志中的信息将数据回滚到修改之前的样子即可！</p>\n<p>并且，回滚日志会先于数据持久化到磁盘上。这样就保证了即使遇到数据库突然宕机等情况，当用户再次启动数据库的时候，数据库还能够通过查询回滚日志来回滚将之前未完成的事务。</p>\n<p>另外， <code>MVCC</code>  的实现依赖于：<strong>隐藏字段、Read View、undo log</strong>。在内部实现中， <code>InnoDB</code>  通过数据行的  <code>DB_TRX_ID</code>  和  <code>Read View</code>  来判断数据的可见性，如不可见，则通过数据行的  <code>DB_ROLL_PTR</code>  找到  <code>undo log</code>  中的历史版本。每个事务读到的数据版本可能是不一样的，在同一个事务中，用户只能看到该事务创建  <code>Read View</code>  之前已经提交的修改和该事务本身做的修改。</p>\n<h4 id=\"总结-2\"><a class=\"anchor\" href=\"#总结-2\">#</a> 总结</h4>\n<p>InnoDB 引擎使用 <strong>redo log (重做日志)</strong> 保证事务的<strong>持久性</strong>，使用 <strong>undo log (回滚日志)</strong> 来保证事务的<strong>原子性</strong>。</p>\n<p>MySQL 数据库的<strong>数据备份、主备、主主、主从</strong>都离不开 <code>binlog</code> ，需要依靠 <code>binlog</code>  来同步数据，保证数据一致性。</p>\n<h4 id=\"常见面试题\"><a class=\"anchor\" href=\"#常见面试题\">#</a> 常见面试题</h4>\n<h5 id=\"mysql-中常见的日志有哪些\"><a class=\"anchor\" href=\"#mysql-中常见的日志有哪些\">#</a> <mark>MySQL 中常见的日志有哪些？</mark></h5>\n<p>MySQL 中常见的日志有以下几种：</p>\n<ul>\n<li><strong><font color='cornflowerblue'>归档日志（binlog）</font></strong>：记录了所有修改了数据库结构或数据内容的操作，以便在主从复制时将这些操作同步到从库。二进制日志是<font color='red'>逻辑日志</font>，记录的是对<font color='red'>数据库结构或数据内容</font>的修改。</li>\n<li><strong><font color='cornflowerblue'>重做日志（redo log）</font></strong>：redo log 是 MySQL 的一种日志，<strong>是 InnoDB 存储引擎独有的，它让 MySQL 拥有了崩溃恢复能力</strong>。<font color='red'>redo log 只记录该存储引擎中表的修改，而 binlog 是在数据库层面产生的，所有存储引擎对数据库进行修改都会产生 binlog</font>。redo log 是<font color='red'>物理日志</font>，记录的是对<font color='red'>数据页</font>的修改，而不是对数据的修改。</li>\n<li><strong><font color='cornflowerblue'>回滚日志（undo log）</font></strong>：<strong>是 InnoDB 存储引擎独有的</strong>，记录了所有修改了数据的操作，以便在事务回滚时撤销这些操作。回滚日志是<font color='red'>逻辑日志</font>，记录的是对<font color='red'>数据</font>的修改，而不是对数据页的修改。</li>\n<li>错误日志（errorlog）：记录了 MySQL 服务器启动、运行过程中出现的错误信息。</li>\n<li><font color='cornflowerblue'>慢查询日志（slow query log）</font>：<font color='red'>记录了执行时间超过指定阈值的 DQL 语句</font>，因此可以查看该日志来优化 DQL 语句。慢查询日志<font color='red'>默认是不开启的</font>。</li>\n<li>一般查询日志（general log）：记录了 MySQL 服务器接收到的所有 SQL 语句，包括执行时间、执行结果等信息。一般查询日志可以用于调试和安全审计。</li>\n<li>中继日志（relay log）：是 MySQL 主从复制结构中<font color='red'>从节点上的日志，用于保存主节点传输过来的数据变更事件，然后将这些事件应用于从节点</font>。</li>\n</ul>\n<h5 id=\"慢查询日志有什么用\"><a class=\"anchor\" href=\"#慢查询日志有什么用\">#</a> 慢查询日志有什么用？</h5>\n<p>用来<font color='red'>记录在 MySQL 中响应时间超过阀值的语句</font>，具体指运行时间超过 long_query_time 值的 SQL，则会被记录到慢查询日志中。long_query_time 的默认值为 10，意思是运行 10 秒以上的 SQL 语句。慢查询日志<font color='red'>可以帮助开发人员找出哪些语句的执行效率低，以便进行优化</font>。</p>\n<h5 id=\"mysql-如何优化一个慢查询语句\"><a class=\"anchor\" href=\"#mysql-如何优化一个慢查询语句\">#</a> <mark>MySQL 如何优化一个慢查询语句？</mark></h5>\n<p>指路→<a href=\"#==%E6%85%A2%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E4%BC%98%E5%8C%96==\">慢查询语句优化</a></p>\n<h5 id=\"binlog-主要记录了什么\"><a class=\"anchor\" href=\"#binlog-主要记录了什么\">#</a> binlog 主要记录了什么？</h5>\n<p>binlog 是 MySQL 的二进制日志，主要<font color='red'>记录了对 MySQL 数据库进行的所有更改操作，包括插入、更新和删除操作</font>。binlog 可以用于数据恢复、数据同步和数据备份等方面 。</p>\n<h5 id=\"介绍一下redo-log以及它如何保证事务的持久性\"><a class=\"anchor\" href=\"#介绍一下redo-log以及它如何保证事务的持久性\">#</a> 介绍一下 redo log，以及它如何保证事务的持久性？</h5>\n<p>redo log 是 MySQL 的一种日志，<strong>是 InnoDB 存储引擎独有的，它让 MySQL 拥有了崩溃恢复能力</strong>。<font color='red'>redo log 只记录该存储引擎中表的修改，而 binlog 是在数据库层面产生的，所有存储引擎对数据库进行修改都会产生 binlog</font>。</p>\n<p>redo log 是 MySQL 数据库用于保证事务的持久性的机制之一。在执行一个事务时，<font color='red'>MySQL 会将事务所做出的修改操作先写入 redo log 而不是直接保存到磁盘</font>，也就是 <code>WAL（write ahead log)机制</code> 。这是因为将数据直接写入磁盘的开销较大，而将修改操作写入 redo log 可以大幅减少磁盘 IO 的次数。</p>\n<blockquote>\n<p>WAL（write ahead log）机制的基本思想：</p>\n<p>在修改数据之前，先将修改操作记录到一个日志文件中，然后再将修改操作应用到数据库中。这样，即使在修改数据的过程中出现了故障，也可以通过日志文件来恢复数据 。</p>\n</blockquote>\n<p>当一个事务提交后，<font color='red'>MySQL 会从 redo log 中读取相应的修改操作，并将其写入磁盘</font>。<font color='red'>只要 redo log 已经持久化（即已经写入磁盘），那么就可以保证故障发生后能够完成数据恢复</font>。如果 MySQL 在执行修改操作时遇到了宕机等问题，在重启后会重新应用 redo log 里未被应用的操作，从而实现事务的持久性。</p>\n<h5 id=\"数据页是什么\"><a class=\"anchor\" href=\"#数据页是什么\">#</a> 数据页是什么？</h5>\n<p>数据页是 InnoDB 存储引擎中的一个重要概念，它<strong>是 InnoDB 存储引擎中的最小存储单位。InnoDB 存储引擎将表空间分为多个大小相等的数据页，每个数据页默认大小为 16KB</strong>。在 InnoDB 存储引擎中，每个表都有一个独立的表空间，表空间由多个数据文件组成。当表中的数据发生变化时，InnoDB 存储引擎会将修改操作记录到 redo log 中，并将修改操作应用到内存中的数据页中。当内存中的数据页被修改后，InnoDB 存储引擎会将修改操作异步刷新到磁盘上的数据文件中，从而保证了数据的持久性。</p>\n<h5 id=\"页修改之后为什么不直接刷盘呢\"><a class=\"anchor\" href=\"#页修改之后为什么不直接刷盘呢\">#</a> 页修改之后为什么不直接刷盘呢？</h5>\n<p>在数据库中，将修改的数据直接刷盘（写入磁盘）可能会产生一些性能开销。这是因为在执行随机磁盘 IO 的过程中，磁盘的寻址时间和磁道切换时间等所需的开销较大，说明磁盘 IO 时需要耗费较长的时间。因此<strong>直接刷盘会导致大量的磁盘 I/O，降低系统的性能</strong>。</p>\n<p>为了避免这种情况，InnoDB 存储引擎采用了一种称为 “ <code>脏页刷盘</code> ” 的机制。<font color='red'>在数据库缓存中，如果一个数据页上的数据已经被修改了，但还没有被同步写入磁盘，那么这个数据页就被称为 “ <code>脏页</code> ”</font>。 <code>脏页刷盘</code> 机制是指 InnoDB 存储引擎在<font color='red'>将内存中的数据页刷新到磁盘上</font>时，会根据一定的策略来决定哪些数据页需要被刷新到磁盘上，哪些数据页可以暂时不刷新。</p>\n<ul>\n<li><font color='red'>当内存中的数据页被修改前，InnoDB 存储引擎会将修改操作记录到 redo log 中，并将修改操作应用到内存中的数据页中</font>。</li>\n<li><font color='red'>当内存中的数据页被修改后，InnoDB 存储引擎会将修改操作异步刷新到磁盘上的数据文件中，从而保证了数据的持久性</font>。在这个过程中，InnoDB 存储引擎会根据一定的策略来决定哪些数据页需要被刷新到磁盘上，哪些数据页可以暂时不刷新。这样可以避免大量的磁盘 I/O，提高系统的性能。</li>\n</ul>\n<h5 id=\"binlog-和-redolog-有什么区别\"><a class=\"anchor\" href=\"#binlog-和-redolog-有什么区别\">#</a> binlog 和 redolog 有什么区别？</h5>\n<p>binlog 和 redolog 都是 MySQL 数据库中的日志文件，用于记录数据库的修改操作。它们的主要区别在于：</p>\n<ol>\n<li>\n<p>binlog 是 MySQL 的归档日志，用于<font color='red'>记录所有的修改操作，包括数据的增删改操作和表结构的变更操作等</font>。binlog 的作用是<font color='red'>用于数据恢复、主从复制和数据同步</font>等场景。</p>\n</li>\n<li>\n<p>redolog 是 InnoDB 存储引擎的事务日志，用于<font color='red'>记录事务的修改操作</font>。redolog 的作用是<font color='red'>用于保证事务的原子性、一致性和持久性</font>。当一个事务提交时，会将该事务所做的所有修改操作先记录在 redo log 中并刷到磁盘上，然后再将这些修改操作同步到数据库的数据文件中。</p>\n</li>\n</ol>\n<p>区别:</p>\n<ul>\n<li>binlog 是整个<font color='red'>数据库实例级别</font>的，记录了对整个数据库实例进行的所有更改操作，而 redolog 是每个<font color='red'>InnoDB 存储引擎实例级别</font>的，只记录了在该存储引擎实例中发生的事务更改操作。</li>\n<li>binlog 是对<font color='red'>数据库执行的语句级别</font>的日志，redolog 是对<font color='red'>事务级别</font>的日志，记录了事务的具体操作信息。</li>\n<li>binlog 通常<font color='red'>用于 JDBC 等客户端进行异地灾难恢复</font>，而 redolog<font color='red'>用于保证事务的 ACID 属性（原子性、一致性、隔离性和持久性）</font>。</li>\n</ul>\n<p>因为<font color='red'> binlog 记录了所有的修改操作，所以它比 redolog 更加全面，但也更加耗费磁盘空间</font>。而 <font color='red'>redolog 只记录了事务的修改操作，所以它比 binlog 更加高效，但也更加局限</font>。</p>\n<h5 id=\"undo-log-如何保证事务的原子性\"><a class=\"anchor\" href=\"#undo-log-如何保证事务的原子性\">#</a> undo log 如何保证事务的原子性？</h5>\n<p>undo log <font color='red'>是 InnoDB 存储引擎的</font>回滚日志，<font color='red'>用于记录事务的回滚操作</font>。</p>\n<p>当一个事务需要回滚时，InnoDB 存储引擎会根据 undo log 中的信息将数据页恢复到事务开始之前的状态。因此，undo log 可以保证事务的原子性。</p>\n<p>在 InnoDB 存储引擎中，每个事务都有一个对应的 undo log，用于记录该事务所做的修改操作。当事务提交时，InnoDB 存储引擎会将 undo log 中的信息删除，从而释放磁盘空间。如果事务回滚，则 InnoDB 存储引擎会根据 undo log 中的信息将数据页恢复到事务开始之前的状态。这样可以保证事务的原子性。</p>\n<h3 id=\"mysql事务\"><a class=\"anchor\" href=\"#mysql事务\">#</a> <mark>MySQL 事务</mark></h3>\n<h4 id=\"事务\"><a class=\"anchor\" href=\"#事务\">#</a> 事务</h4>\n<p><font color='red'>事务是一个完整的业务逻辑，内部的所有操作要么全部成功，要么全部失败</font>。</p>\n<h4 id=\"数据库事务\"><a class=\"anchor\" href=\"#数据库事务\">#</a> 数据库事务</h4>\n<p><font color='red'>对于数据库来说，事务是由批量的 DML 语句所构成的逻辑整体，要么全执行成功，要么全执行失败</font>。</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># 开启一个事务</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">START</span> <span class=\"token keyword\">TRANSACTION</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token comment\"># 多条 SQL 语句</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>SQL1<span class=\"token punctuation\">,</span>SQL2<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token comment\">## 提交事务</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token keyword\">COMMIT</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230424112420132.png\" alt=\"image-20230424112420132\" /></p>\n<h4 id=\"acid-特征\"><a class=\"anchor\" href=\"#acid-特征\">#</a> <mark>ACID 特征</mark></h4>\n<p>关系型数据库（例如： <code>MySQL</code> 、 <code>SQL Server</code> 、 <code>Oracle</code>  等）事务都有 <strong>ACID</strong> 特性：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230424112518237.png\" alt=\"image-20230424112518237\" /></p>\n<ul>\n<li>\n<p><strong>原子性</strong>（ <code>Atomicity</code> ）：事务是不可分割的最小操作单元，内部的所有操作要么全部成功，要么全部失败；</p>\n<blockquote>\n<p><font color='red'>由 Undo Log 日志保证</font>，记录了需要回滚的日志信息，事务回滚时撤销已经执行成功的 SQL 语句。</p>\n</blockquote>\n</li>\n<li>\n<p><strong>一致性</strong>（ <code>Consistency</code> ）：事务完成前后，数据库必须保持一致状态，即都是合理的数据状态。例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；</p>\n<blockquote>\n<p><font color='red'>由 A、I、D 共同保证</font></p>\n</blockquote>\n</li>\n<li>\n<p><strong>隔离性</strong>（ <code>Isolation</code> ）：数据库提供的隔离机制，可以保证事务在不受外部并发操作影响的独立环境下运行。即并发访问数据库时，一个事务所做的修改在最终提交前，对其他并发事务是不可见的。各并发事务之间，数据库是独立的；</p>\n<blockquote>\n<p><font color='red'>由 MVCC 保证</font></p>\n</blockquote>\n</li>\n<li>\n<p><strong>持久性</strong>（ <code>Durability</code> ）：事务一旦提交，它对数据库中数据的更改就是持久的。即使数据库发生故障，这种更改也不会丢失。</p>\n<blockquote>\n<p><font color='red'>由 内存 + Redo Log 保证</font>，MySQL 修改数据同时在内存和 Redo Log 记录这次操作，宕机时可从 Redo Log 恢复数据。</p>\n</blockquote>\n</li>\n</ul>\n<blockquote>\n<p>**A、I、D 是手段，C 才是目的！** 只有保证了事务的原子性、隔离性、持久性之后，一致性才能得到保障。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230424112548870.png\" alt=\"image-20230424112548870\" /></p>\n</blockquote>\n<h4 id=\"4个一致性问题\"><a class=\"anchor\" href=\"#4个一致性问题\">#</a> <mark>4 个一致性问题</mark></h4>\n<p>多个事务并发运行，经常会操作相同的数据来完成各自的任务（例如多个客户端并发地访问同一个表），如果事务之间没有设置合理的隔离级别，可能会导致以下 4 种问题。</p>\n<h5 id=\"脏读dirty-read\"><a class=\"anchor\" href=\"#脏读dirty-read\">#</a> 脏读（Dirty read）</h5>\n<p>一个事务读取并修改了数据，这个修改对其他并发事务来说是可见的，即使该事务还没有提交。这时另一个并发事务读取了这个还未提交的数据，但是第一个事务突然回滚，导致数据并没有被提交到数据库。那第二个事务读取到的就是脏数据，这也就是脏读的由来。</p>\n<p>例如：事务 1 读取某表中的数据 A=20，事务 1 修改 A=A-1，事务 2 读取到 A = 19, 事务 1 回滚导致对 A 的修改并为提交到数据库， A 的值还是 20。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230424112618536.png\" alt=\"脏读\" /></p>\n<center> 脏读（Dirty read）</center>\n<h5 id=\"丢失修改lost-to-modify\"><a class=\"anchor\" href=\"#丢失修改lost-to-modify\">#</a> 丢失修改（Lost to modify）</h5>\n<p>在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。</p>\n<p>例如：事务 1 读取某表中的数据 A=20，事务 2 也读取 A=20，事务 1 先修改 A=A-1，事务 2 后来也修改 A=A-1，最终结果 A=19，事务 1 的修改被丢失。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230424112636565.png\" alt=\"image-20230424112636565\" /></p>\n<center>丢失修改（Lost to modify）</center>\n<h5 id=\"不可重复读unrepeatable-read\"><a class=\"anchor\" href=\"#不可重复读unrepeatable-read\">#</a> 不可重复读（Unrepeatable read）</h5>\n<p>在一个事务内多次读同一数据。在一个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。</p>\n<p>例如：事务 1 读取某表中的数据 A=20，事务 2 也读取 A=20，事务 1 修改 A=A-1，事务 2 再次读取 A =19，此时读取的结果和第一次读取的结果不同。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230424112650372.png\" alt=\"image-20230424112650372\" /></p>\n<center>不可重复读（Unrepeatable read）</center>\n<h5 id=\"幻读phantom-read\"><a class=\"anchor\" href=\"#幻读phantom-read\">#</a> 幻读（Phantom read）</h5>\n<p>一个事务读取了几行数据，接着另一个并发事务<font color='red'>插入</font>了一些数据时。第一个事务在随后的查询中就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</p>\n<p>例如：事务 2 读取某个范围的数据，事务 1 在这个范围插入了新的数据，事务 2 再次读取这个范围的数据发现相比于第一次读取的结果多了新的数据。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230424112700267.png\" alt=\"image-20230424112700267\" /></p>\n<center>幻读（Phantom read）</center>\n<h4 id=\"不可重复读和幻读的区别\"><a class=\"anchor\" href=\"#不可重复读和幻读的区别\">#</a> 不可重复读和幻读的区别</h4>\n<ul>\n<li><font color='red'>不可重复读的重点是<u>字段值修改</u>或<u>记录减少</u></font>。比如多次读取一条记录，发现其中某些字段的值被修改了。</li>\n<li><font color='red'>幻读的重点在于<u>记录新增</u></font>。比如多次执行同一条查询语句（DQL）时，发现查到的记录增加了。</li>\n</ul>\n<p>幻读其实可以看作是不可重复读的一种特殊情况，区分二者的原因是二者的解决方案不一样。</p>\n<p>举个例子：执行  <code>delete</code>  和  <code>update</code>  操作的时候，可以直接对记录加锁，保证事务安全。而执行  <code>insert</code>  操作的时候，由于记录锁（Record Lock）只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁（Gap Lock）。也就是说执行  <code>insert</code>  操作的时候需要依赖 Next-Key Lock（Record Lock+Gap Lock） 进行加锁来保证不出现幻读。</p>\n<h4 id=\"并发事务的控制方式隔离性\"><a class=\"anchor\" href=\"#并发事务的控制方式隔离性\">#</a> 并发事务的控制方式（隔离性）</h4>\n<p>MySQL 中并发事务的控制方式无非就两种：<strong>锁</strong> 和 <strong>多版本并发控制（MVCC）</strong>。</p>\n<p>锁可以看作是悲观控制的模式，多版本并发控制（MVCC，Multiversion concurrency control）可以看作是乐观控制的模式。</p>\n<h5 id=\"锁\"><a class=\"anchor\" href=\"#锁\">#</a> 锁</h5>\n<p>通过锁来显示地控制共享资源，而不是通过调度手段。MySQL 中主要是通过<strong>读写锁</strong>来实现并发控制。</p>\n<ul>\n<li><strong>共享锁（S 锁）</strong>：又称<font color='red'>读锁</font>。事务在读取记录的时候获取共享锁，允许多个事务同时获取（锁兼容）。</li>\n<li><strong>排他锁（X 锁）</strong>：又称<font color='red'>写锁 / 独占锁</font>。事务在修改记录的时候获取排他锁，不允许多个事务同时获取。如果一个记录已经被加了排他锁，那其他事务不能再对这条记录加任何类型的锁（锁不兼容）。</li>\n</ul>\n<p>读写锁可以做到读读并行，但是<font color='red'>无法做到读写并行、写写并行</font>。</p>\n<p>另外，根据根据锁粒度的不同，又被分为<strong>表级锁 (table-level locking)<strong> 和</strong>行级锁 (row-level locking)</strong>。<font color='red'>InnoDB 不光支持表级锁，还支持行级锁</font>，默认为行级锁。行级锁的粒度更小，仅对相关的记录上锁即可（对一行或者多行记录加锁）。所以对于并发写入操作来说，InnoDB 的性能更高。</p>\n<p><font color='red'>不论是表级锁还是行级锁，都存在共享锁（Share Lock，S 锁）和排他锁（Exclusive Lock，X 锁）这两类</font>。</p>\n<h5 id=\"多版本并发控制mvcc\"><a class=\"anchor\" href=\"#多版本并发控制mvcc\">#</a> 多版本并发控制（MVCC）</h5>\n<p><strong>MVCC</strong> 是多版本并发控制方法，即<font color='red'>对一份数据会存储多个版本</font>，通过事务的可见性来保证事务能看到自己应该看到的版本。<font color='red'>通常会有一个全局的版本分配器来为每一行数据设置版本号，版本号是唯一的</font>。</p>\n<p>MVCC 在 MySQL 中实现所依赖的手段主要是：</p>\n<ul>\n<li><strong>undo log</strong>：记录某行数据的多个版本的数据。</li>\n<li><strong>read view</strong> 和 <strong>隐藏字段</strong>：判断当前版本数据的可见性。</li>\n</ul>\n<p>关于 InnoDB 对 MVCC 的具体实现可以看这篇文章：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9qYXZhZ3VpZGUuY24vZGF0YWJhc2UvbXlzcWwvaW5ub2RiLWltcGxlbWVudGF0aW9uLW9mLW12Y2MuaHRtbA==\">InnoDB 存储引擎对 MVCC 的实现</span> 。</p>\n<h4 id=\"4种隔离级别\"><a class=\"anchor\" href=\"#4种隔离级别\">#</a> <mark>4 种隔离级别</mark></h4>\n<p>SQL 标准为事务定义了四种隔离级别：</p>\n<ul>\n<li>\n<p><strong>READ-UNCOMMITTED（读未提交）</strong>：最低的隔离级别，<font color='red'>允许当前事务读取其他并发事务尚未提交的数据</font>，存在脏读、不可重复读、幻读问题。</p>\n<blockquote>\n<p>用户本来应该读取到 id=1 的用户 age 应该是 10，结果读取到了其他事务还没有提交的事务，结果读取 age=20，这就是脏读。</p>\n</blockquote>\n</li>\n<li>\n<p><strong>READ-COMMITTED（读已提交）</strong>：<font color='red'>允许当前事务读取其他并发事务已经提交的数据</font>。可以避免脏读，但是存在不可重复读、幻读问题。</p>\n<blockquote>\n<p>用户开启事务读取 id=1 的用户，查询到 age=16，再次读取发现结果 age=20，在同一个事务里同一个查询读取到不同的结果，叫做不可重复读。</p>\n</blockquote>\n</li>\n<li>\n<p><strong>REPEATABLE-READ（可重复读）</strong>：MySQL 的默认隔离级别，<font color='red'>当前事务对同一数据的多次读取结果都是一样的</font>（都是复用事务刚开始时的数据读取结果副本），除非数据被本身事务所修改。可以避免脏读和不可重复读，但幻读仍有可能发生。</p>\n</li>\n<li>\n<p><strong>SERIALIZABLE（串行化 / 序列化）</strong>：最高的隔离级别，完全服从 ACID 的隔离级别。<font color='red'>所有的事务依次串行执行</font>，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。</p>\n</li>\n</ul>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231118212951118.png\" alt=\"image-20231118212951118\" /></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">隔离级别</th>\n<th style=\"text-align:center\">脏读</th>\n<th style=\"text-align:center\">不可重复读</th>\n<th style=\"text-align:center\">幻读</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">READ-UNCOMMITTED</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">READ-COMMITTED</td>\n<td style=\"text-align:center\">×</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">REPEATABLE-READ</td>\n<td style=\"text-align:center\">×</td>\n<td style=\"text-align:center\">×</td>\n<td style=\"text-align:center\">√/×（InnoDB）</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">SERIALIZABLE</td>\n<td style=\"text-align:center\">×</td>\n<td style=\"text-align:center\">×</td>\n<td style=\"text-align:center\">×</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"mysql-的隔离级别是基于锁和-mvcc-机制共同实现的\"><a class=\"anchor\" href=\"#mysql-的隔离级别是基于锁和-mvcc-机制共同实现的\">#</a> MySQL 的隔离级别是基于锁和 MVCC 机制共同实现的</h4>\n<p>SERIALIZABLE 隔离级别是通过锁来实现的，READ-COMMITTED 和 REPEATABLE-READ 隔离级别是基于 MVCC 实现的。不过，SERIALIZABLE 之外的其他隔离级别可能也需要用到锁机制，就比如 REPEATABLE-READ 在当前读情况下需要使用加锁读来保证不会出现幻读。</p>\n<h4 id=\"mysqlinnodb的默认隔离级别是-repeatable-read可重读\"><a class=\"anchor\" href=\"#mysqlinnodb的默认隔离级别是-repeatable-read可重读\">#</a> MySQL（InnoDB）的默认隔离级别是 REPEATABLE-READ（可重读）</h4>\n<p>MySQL（InnoDB）默认支持的隔离级别是 <strong>REPEATABLE-READ（可重读）</strong>。</p>\n<p>可以通过 <code>SELECT @@tx_isolation;</code>  命令来查看，MySQL 8.0 该命令改为 <code>SELECT @@transaction_isolation;</code></p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>mysql<span class=\"token operator\">></span> <span class=\"token keyword\">SELECT</span> @<span class=\"token variable\">@tx_isolation</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token operator\">+</span><span class=\"token comment\">-----------------+</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token operator\">|</span> @<span class=\"token variable\">@tx_isolation</span>  <span class=\"token operator\">|</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token operator\">+</span><span class=\"token comment\">-----------------+</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token operator\">|</span> <span class=\"token keyword\">REPEATABLE</span><span class=\"token operator\">-</span><span class=\"token keyword\">READ</span> <span class=\"token operator\">|</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token operator\">+</span><span class=\"token comment\">-----------------+</span></pre></td></tr></table></figure><p>关于 MySQL 事务隔离级别的详细介绍，可以看看我写的这篇文章：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9qYXZhZ3VpZGUuY24vZGF0YWJhc2UvbXlzcWwvdHJhbnNhY3Rpb24taXNvbGF0aW9uLWxldmVsLmh0bWw=\">MySQL 事务隔离级别详解</span>。</p>\n<h4 id=\"mysql-事务隔离级别与一致性问题的演示\"><a class=\"anchor\" href=\"#mysql-事务隔离级别与一致性问题的演示\">#</a> MySQL 事务隔离级别与一致性问题的演示</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/2019-31-1%25E8%2584%258F%25E8%25AF%25BB(%25E8%25AF%25BB%25E6%259C%25AA%25E6%258F%2590%25E4%25BA%25A4)%25E5%25AE%259E%25E4%25BE%258B.jpg\" alt=\"img\" /></p>\n<center>脏读（读未提交）</center>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/2019-31-2%25E8%25AF%25BB%25E5%25B7%25B2%25E6%258F%2590%25E4%25BA%25A4%25E5%25AE%259E%25E4%25BE%258B.jpg\" alt=\"img\" /></p>\n<center>避免脏读（读已提交）</center>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/2019-32-1%25E4%25B8%258D%25E5%258F%25AF%25E9%2587%258D%25E5%25A4%258D%25E8%25AF%25BB%25E5%25AE%259E%25E4%25BE%258B.jpg\" alt=\"img\" /></p>\n<center>不可重复读（读已提交）</center>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/2019-33-2%25E5%258F%25AF%25E9%2587%258D%25E5%25A4%258D%25E8%25AF%25BB.jpg\" alt=\"img\" /></p>\n<center>可重复读</center>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/phantom_read.png\" alt=\"img\" /></p>\n<center>幻读</center>\n<p>SQL 脚本 1 在第一次查询工资为 500 的记录时只有一条，SQL 脚本 2 插入了一条工资为 500 的记录，提交之后；SQL 脚本 1 在同一个事务中再次使用当前读查询发现出现了两条工资为 500 的记录这种就是幻读。</p>\n<p><font color='red'>幻读的解决方法：核心思想就是一个事务在操作某张表数据的时候，另外一个事务不允许新增或者删除这张表中的数据了</font>。解决幻读的方式主要有以下几种：</p>\n<ol>\n<li>将事务隔离级别调整为  <code>SERIALIZABLE</code>  。</li>\n<li>在可重复读的事务级别下，给事务操作的这张表添加<font color='red'>表锁</font>。</li>\n<li>在可重复读的事务级别下，给事务操作的这张表添加  <code>Next-key Lock（Record Lock+Gap Lock）</code> 。</li>\n</ol>\n<h3 id=\"mysql锁\"><a class=\"anchor\" href=\"#mysql锁\">#</a> <mark>MySQL 锁</mark></h3>\n<h4 id=\"概述-2\"><a class=\"anchor\" href=\"#概述-2\">#</a> 概述</h4>\n<p>在数据库中，数据是一种供许多用户共享的资源，必须保证数据并发访问的一致性、有效性。</p>\n<p>MySQL 中的锁，按照锁的粒度分，分为以下三类：</p>\n<ul>\n<li>\n<p><font color='cornflowerblue'>全局锁</font>：锁定<font color='red'>整个数据库</font>。</p>\n</li>\n<li>\n<p><font color='cornflowerblue'>表级锁</font>：每次操作锁住<font color='red'>整张表</font>。</p>\n<ul>\n<li>表锁：</li>\n<li>元数据锁（meta data lock，MDL）：加锁过程是系统自动控制的</li>\n<li>意向锁：不与行级锁冲突，由 InnoDB 自动添加，无需用户干预。\n<ul>\n<li>意向共享锁（IS）</li>\n<li>意向排他锁（IX）</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><font color='cornflowerblue'>行级锁</font>：每次操作锁住对应的<font color='red'>行数据</font>，其<font color='red'>实现依赖于索引</font>，而不是记录。</p>\n<ul>\n<li>行锁 / 记录锁（Record Lock）：存在于包括主键索引在内的唯一索引中，锁定<font color='red'>单条索引记录</font></li>\n<li>间隙锁（Gap Lock）：存在于非唯一索引中，锁定<font color='red'>开区间</font>范围内的一段间隔</li>\n<li>临键锁（Next-Key Lock）：存在于非唯一索引中，锁定<font color='red'>左开右闭</font>的索引区间</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"全局锁\"><a class=\"anchor\" href=\"#全局锁\">#</a> 全局锁</h4>\n<h5 id=\"介绍-2\"><a class=\"anchor\" href=\"#介绍-2\">#</a> 介绍</h5>\n<p>全局锁就是<font color='red'>对整个数据库实例加锁，加锁后整个实例就处于只读状态，后续的 DML 的写语句，DDL 语句，已经更新操作的事务提交语句都将被阻塞</font>。</p>\n<p>典型的使用场景是做<font color='red'>全库的逻辑备份</font>，对所有的表进行锁定，从而获取一致性视图，保证数据的完整性。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231119154827391.png\" alt=\"image-20231119154827391\" /></p>\n<center>不加MySQL全局锁会导致备份数据的不一致</center>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231119154907407.png\" alt=\"image-20231119154907407\" /></p>\n<center>加了MySQL全局锁后只能执行DQL语句，数据库处于只读状态，保证了数据的一致性和完整性</center>\n<h5 id=\"语法\"><a class=\"anchor\" href=\"#语法\">#</a> 语法</h5>\n<ol>\n<li>\n<p>添加全局锁：</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>flush <span class=\"token keyword\">tables</span> <span class=\"token keyword\">with</span> <span class=\"token keyword\">read</span> <span class=\"token keyword\">lock</span> <span class=\"token punctuation\">;</span></pre></td></tr></table></figure></li>\n<li>\n<p>数据备份（退出 mysql，在 Windows 的 cmd 窗口中执行）：</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>mysqldump <span class=\"token parameter variable\">-uroot</span> –p1234 itcast <span class=\"token operator\">></span> itcast.sql <span class=\"token punctuation\">;</span></pre></td></tr></table></figure></li>\n<li>\n<p>释放锁：</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">unlock</span> <span class=\"token keyword\">tables</span> <span class=\"token punctuation\">;</span></pre></td></tr></table></figure></li>\n</ol>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231119155453030.png\" alt=\"image-20231119155453030\" /></p>\n<h5 id=\"特点\"><a class=\"anchor\" href=\"#特点\">#</a> 特点</h5>\n<p>数据库中加全局锁，是一个比较重的操作，存在以下问题：</p>\n<ul>\n<li>如果在<font color='gree'>主库</font>上备份，那么<font color='red'>在备份期间都不能执行更新，业务基本上就得停摆</font>。</li>\n<li>如果在<font color='gree'>从库</font>上备份，那么<font color='red'>在备份期间从库不能执行主库同步过来的二进制日志（binlog），会导致主从延迟</font>。</li>\n</ul>\n<p>为了解决上述问题，在 InnoDB 引擎中可以在备份时加上参数  <code>--single-transaction</code>  参数来完成 **<font color='#B32015'>不加锁的一致性数据备份</font>**。</p>\n<blockquote>\n<p><strong>快照读</strong></p>\n</blockquote>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>mysqldump --single-transaction <span class=\"token parameter variable\">-uroot</span> –p123456 itcast <span class=\"token operator\">></span> itcast.sql</pre></td></tr></table></figure><h4 id=\"表级锁\"><a class=\"anchor\" href=\"#表级锁\">#</a> 表级锁</h4>\n<h5 id=\"介绍-3\"><a class=\"anchor\" href=\"#介绍-3\">#</a> 介绍</h5>\n<p>表级锁，即锁住整张表，MyISAM、InnoDB、BDB 等存储引擎都支持，主要分为以下三类：</p>\n<blockquote>\n<p><strong>每类表级锁，都分为<font color='cyan'>共享锁（S 锁 / 读锁）</font>和<font color='cyan'>排他锁（X 锁 / 写锁）</font></strong></p>\n</blockquote>\n<ul>\n<li><font color='cornflowerblue'>表锁</font></li>\n<li><font color='cornflowerblue'>元数据锁</font>（meta data lock，MDL）</li>\n<li><font color='cornflowerblue'>意向锁</font></li>\n</ul>\n<h5 id=\"表锁\"><a class=\"anchor\" href=\"#表锁\">#</a> 表锁</h5>\n<p>对于表锁，分为两类：</p>\n<blockquote>\n<p>结论:</p>\n<ul>\n<li>读锁不会阻塞其他客户端的读，但是会阻塞写。</li>\n<li>写锁既会阻塞其他客户端的读，又会阻塞其他客户端的写。</li>\n</ul>\n</blockquote>\n<ul>\n<li>\n<p><font color='cyan'>表锁共享锁（Shared）</font>：又称<font color='red'>读锁</font></p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231119161818290.png\" alt=\"image-20231119161818290\" /></p>\n<center>左侧为客户端一，对指定表加了读锁，只能读不能写。<font color='red'>不会影响右侧客户端二的读，但是会阻塞右侧客户端的写</font></font>。</center>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231119161947749.png\" alt=\"image-20231119161947749\" /></p>\n</li>\n<li>\n<p><font color='cyan'>表锁排他锁（eXclusive）</font>：又称<font color='red'>写锁</font></p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231119162023867.png\" alt=\"image-20231119162023867\" /></p>\n<center>左侧为客户端一，对指定表加了写锁，可以读和写。<font color='red'>但是会阻塞右侧客户端的读和写</font>。</center>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231119162246255.png\" alt=\"image-20231119162246255\" /></p>\n</li>\n</ul>\n<p>语法：</p>\n<ul>\n<li>\n<p>加锁：</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">lock</span> <span class=\"token keyword\">tables</span> 表名<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> <span class=\"token keyword\">read</span><span class=\"token operator\">/</span><span class=\"token keyword\">write</span></pre></td></tr></table></figure></li>\n<li>\n<p>释放锁：客户端断开连接，或者</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">unlock</span> <span class=\"token keyword\">tables</span></pre></td></tr></table></figure></li>\n</ul>\n<h5 id=\"元数据锁\"><a class=\"anchor\" href=\"#元数据锁\">#</a> 元数据锁</h5>\n<blockquote>\n<p>全称为 meta data lock，简写 MDL，这里的元数据，大家可以简单理解为就是一张表的表结构。</p>\n</blockquote>\n<p><strong><font color='red'>MDL 加锁过程是系统自动控制的</font></strong>，无需显式使用，在访问一张表的时候会自动加上。</p>\n<p>MDL 锁<font color='red'>主要作用是维护表元数据的数据一致性，在表上有活动事务的时候，不可以对元数据进行写入操作</font>。<strong><font color='#B32015'>为了避免 DML 与 DDL 冲突，保证读写的正确性</font></strong>。也就是说，某一张表涉及到未提交的事务时，是不能够修改这张表的表结构的。</p>\n<p>在 MySQL5.5 中引入了 MDL，</p>\n<ul>\n<li><font color='red'>当对一张表的数据进行增删改查（DML、DQL）的时候，加<font color='cyan'> MDL 共享锁</font></font></li>\n<li><font color='red'>当对表结构进行变更操作（DDL）的时候，加<font color='cyan'> MDL 排他锁</font></font></li>\n</ul>\n<p>举个例子，对于常见的 SQL 操作，所添加的 MDL 锁：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231119172457594.png\" alt=\"image-20231119172457594\" /></p>\n<h5 id=\"意向锁\"><a class=\"anchor\" href=\"#意向锁\">#</a> 意向锁</h5>\n<h6 id=\"介绍-4\"><a class=\"anchor\" href=\"#介绍-4\">#</a> 介绍</h6>\n<p>为了避免 DML 在执行时，加的行锁与表锁的冲突，在 InnoDB 中引入了意向锁，<font color='red'>使得表锁不用检查每行数据是否加锁</font>，减少表锁的检查。</p>\n<p>意向锁的工作机制如下：</p>\n<ol>\n<li>客户端在<font color='red'>执行 DML 时，会对涉及的记录加行锁，同时对该表加上<u>意向锁</u></font></li>\n<li>其他客户端在尝试对该表加表锁时，<font color='red'>会根据该表上所加的<u>意向锁</u>来判定是否可以成功加表锁，而不用逐行判断行锁情况了</font>。</li>\n</ol>\n<h6 id=\"分类\"><a class=\"anchor\" href=\"#分类\">#</a> 分类</h6>\n<blockquote>\n<p><font color='red'>意向锁之间不会互斥。并且一旦事务提交了，意向锁就自动释放了</font>。</p>\n</blockquote>\n<ul>\n<li>\n<p><font color='cyan'>意向共享锁 (IS)</font>: 由语句 <code>select ... lock in share mode</code>  添加。</p>\n<blockquote>\n<p>与表锁共享锁 (read) 兼容，与表锁排他锁 (write) 互斥。</p>\n</blockquote>\n</li>\n<li>\n<p><font color='cyan'>意向排他锁 (IX)</font>: 由 <code>insert</code> 、 <code>update</code> 、 <code>delete</code> 、 <code>select...for update</code>  添加。</p>\n<blockquote>\n<p>与表锁共享锁 (read) 及表锁排他锁 (write) 都互斥。</p>\n</blockquote>\n</li>\n</ul>\n<h6 id=\"演示\"><a class=\"anchor\" href=\"#演示\">#</a> 演示</h6>\n<p>可以通过以下 SQL，查看意向锁及行锁的加锁情况：</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">select</span> object_schema<span class=\"token punctuation\">,</span>object_name<span class=\"token punctuation\">,</span>index_name<span class=\"token punctuation\">,</span>lock_type<span class=\"token punctuation\">,</span>lock_mode<span class=\"token punctuation\">,</span>lock_data <span class=\"token keyword\">from</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>performance_schema<span class=\"token punctuation\">.</span>data_locks<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231119185250184.png\" alt=\"image-20231119185250184\" /></p>\n<center>意向共享锁与表锁共享锁(read)是兼容的</center>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231119185354166.png\" alt=\"image-20231119185354166\" /></p>\n<center>意向排他锁与表锁共享锁(read)、表锁排他锁(write)都是互斥的</center>\n<h4 id=\"行级锁\"><a class=\"anchor\" href=\"#行级锁\">#</a> 行级锁</h4>\n<h5 id=\"介绍-5\"><a class=\"anchor\" href=\"#介绍-5\">#</a> 介绍</h5>\n<p>行级锁，每次操作<font color='red'>锁住对应的行数据</font>。锁定粒度最小，<font color='red'>发生锁冲突的概率最低，并发度最高</font>。</p>\n<p><strong><font color='#B32015'>只有 InnoDB 存储引擎支持行级锁</font></strong>。InnoDB 的数据是基于索引组织的，<strong><font color='red'>行锁是通过对索引上的索引项加锁来实现的，而不是对记录加的锁</font></strong>。</p>\n<p>对于行级锁，主要分为以下三类：</p>\n<ul>\n<li>\n<p><font color='cornflowerblue'>行锁（Record Lock）</font>：也称记录锁，<font color='red'>锁定单个行记录</font>，防止其他事务对此行进行 <code>update</code>  和 <code>delete</code> 。</p>\n<blockquote>\n<p>在 RC、RR 隔离级别下都支持。</p>\n<p><strong>与表级锁类似，行锁也分为<font color='cyan'>共享锁（S 锁 / 读锁）</font>和<font color='cyan'>排他锁（X 锁 / 写锁）</font></strong></p>\n</blockquote>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231119190445520.png\" alt=\"image-20231119190445520\" /></p>\n<ul>\n<li>\n<p><font color='cyan'>行锁共享锁（S）</font>：允许一个事务去读一行，阻止其他事务获得相同数据集的排它锁。</p>\n</li>\n<li>\n<p><font color='cyan'>行锁排他锁（X）</font>：允许获取排他锁的事务更新数据，阻止其他事务获得相同数据集的共享锁和排他锁。</p>\n<blockquote>\n<p>两种行锁的兼容情况如下：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231119192050128.png\" alt=\"image-20231119192050128\" /></p>\n<p>对于常见的 SQL 语句，在执行时，所加的行锁如下：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231119192231878.png\" alt=\"image-20231119192231878\" /></p>\n</blockquote>\n</li>\n</ul>\n</li>\n<li>\n<p><font color='cornflowerblue'>间隙锁（Gap Lock）</font>：<font color='red'>锁定索引记录的间隙（不含记录）</font>，确保索引记录间隙不变，<strong><font color='#B32015'>防止其他事务在这个间隙进行 <code>insert</code> ，产生幻读</font></strong>。</p>\n<blockquote>\n<p>在 RR 隔离级别下支持。</p>\n</blockquote>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231119191003502.png\" alt=\"image-20231119191003502\" /></p>\n</li>\n<li>\n<p><font color='cornflowerblue'>临键锁（Next-Key Lock）</font>：<font color='red'>行锁和间隙锁组合，锁住记录的同时也锁住数据前面的所有间隙</font>。</p>\n<blockquote>\n<p>在 RR 隔离级别下支持。还记得在 MySQL 事务的隔离级别中提到的下表吗？当时之所以说<strong> InnoDB 引擎中的 RR 隔离级别可以避免幻读现象</strong>，就是因为 InnoDB 引擎支持行级锁中的临键锁（next-key）！</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231119190721496.png\" alt=\"image-20231119190721496\" /></p>\n</blockquote>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231119191537038.png\" alt=\"image-20231119191537038\" /></p>\n</li>\n</ul>\n<h5 id=\"行锁演示\"><a class=\"anchor\" href=\"#行锁演示\">#</a> 行锁演示</h5>\n<ul>\n<li>针对唯一索引进行检索时，对已存在的记录进行等值匹配时，将会自动将临键锁（next-key）<font color='red'>优化为行锁</font>。</li>\n<li>InnoDB 的行锁是针对于索引加的锁，不通过索引条件检索数据，那么 InnoDB 将对表中的所有记录加锁，此时就会<font color='red'>升级为表锁</font>。</li>\n</ul>\n<hr />\n<p>可以通过以下 SQL，查看意向锁及行锁的加锁情况：</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">select</span> object_schema<span class=\"token punctuation\">,</span>object_name<span class=\"token punctuation\">,</span>index_name<span class=\"token punctuation\">,</span>lock_type<span class=\"token punctuation\">,</span>lock_mode<span class=\"token punctuation\">,</span>lock_data <span class=\"token keyword\">from</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>performance_schema<span class=\"token punctuation\">.</span>data_locks<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231119193115917.png\" alt=\"image-20231119193115917\" /></p>\n<center>普通的select语句，执行时，不会加锁。</center>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231119193133442.png\" alt=\"image-20231119193133442\" /></p>\n<center>select...lock in share mode，加共享锁，共享锁与共享锁之间兼容。</center>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231119193207569.png\" alt=\"image-20231119193207569\" /></p>\n<center>共享锁与排他锁之间互斥。</center>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231119193242470.png\" alt=\"image-20231119193242470\" /></p>\n<center>排他锁之间互斥</center>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231119193535207.png\" alt=\"image-20231119193535207\" /></p>\n<center>根据name字段进行更新时，由于name字段是没有索引的，此时行锁会升级为表锁（因为行锁是对索引项加的锁）</center>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231119193708274.png\" alt=\"image-20231119193708274\" /></p>\n<center><font color='red'>对name字段创建索引，再对其进行更新，可以避免行锁升级为表锁</font></center>\n<h5 id=\"间隙锁临键锁演示\"><a class=\"anchor\" href=\"#间隙锁临键锁演示\">#</a> 间隙锁 &amp; 临键锁演示</h5>\n<p>默认情况下，InnoDB 的事务隔离级别为 <font color='red'>REPEATABLE-READ（可重复读）</font>，InnoDB 使用 <font color='cornflowerblue'>临键锁（next-key）</font>进行搜索和索引扫描，以防出现幻读。</p>\n<ul>\n<li>\n<p>索引上的等值查询（唯一索引），给不存在的记录加锁时，优化为间隙锁</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231119195154766.png\" alt=\"image-20231119195154766\" /></p>\n</li>\n<li>\n<p>索引上的等值查询（非唯一的普通索引），向右遍历时最后一个值不满足查询需求时，临键锁（next-key）退化为间隙锁</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231119195335874.png\" alt=\"image-20231119195335874\" /></p>\n</li>\n<li>\n<p>索引上的范围查询 (唯一索引)-- 会访问到不满足条件的第一个值为止</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231119195724781.png\" alt=\"image-20231119195724781\" /></p>\n</li>\n</ul>\n<blockquote>\n<p><strong>间隙锁唯一目的是防止其他事务插入间隙</strong>。</p>\n<p><strong>间隙锁可以共存</strong>，一个事务采用的间隙锁不会阻止另一个事务在同一间隙上采用间隙锁。</p>\n</blockquote>\n<h4 id=\"总结-3\"><a class=\"anchor\" href=\"#总结-3\">#</a> 总结</h4>\n<img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231119200231781.png\" alt=\"image-20231119200231781\" style=\"zoom: 67%;\" />\n<h4 id=\"面试题-2\"><a class=\"anchor\" href=\"#面试题-2\">#</a> 面试题</h4>\n<p>锁是一种常见的并发事务的控制方式。</p>\n<h5 id=\"表级锁和行级锁了解吗有什么区别\"><a class=\"anchor\" href=\"#表级锁和行级锁了解吗有什么区别\">#</a> 表级锁和行级锁了解吗？有什么区别？</h5>\n<p><font color='red'>MyISAM 仅仅支持表级锁</font>，在并发写的情况下性能非常差。<strong><font color='red'>InnoDB 不仅支持表级锁，还支持行级锁</font></strong>，默认为行级锁。</p>\n<p>行级锁的粒度更小，仅对相关的记录上锁即可（一行或者多行记录），所以对于并发写操作来说，InnoDB 的性能更高。</p>\n<ul>\n<li>\n<p><strong>表级锁：</strong></p>\n<ul>\n<li>是 **<font color='red'>针对非索引字段</font>** 加的锁，对当前操作的整张表加锁</li>\n<li>优点：<font color='red'>加锁快，资源消耗也比较少，不会出现死锁</font>。</li>\n<li>缺点：<font color='red'>触发锁冲突的概率最高，高并发下效率极低</font>。</li>\n<li><font color='red'>MyISAM 和 InnoDB 引擎都支持表级锁</font>。</li>\n</ul>\n</li>\n<li>\n<p><strong>行级锁：</strong></p>\n<ul>\n<li>MySQL 中锁定粒度最小的一种锁，是 **<font color='#B32015'>针对索引字段</font>** 加的锁，只针对当前操作的行记录进行加锁。</li>\n<li>优点：<font color='red'>能大大减少数据库操作的锁冲突</font>。其加锁粒度最小，<font color='red'>并发度高</font>。</li>\n<li>缺点：<font color='red'>加锁慢，加锁的开销大，会出现死锁</font>。</li>\n<li><font color='red'>行级锁和存储引擎有关，仅有 InnoDB 引擎支持行级锁</font>。</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"行级锁的使用有什么注意事项\"><a class=\"anchor\" href=\"#行级锁的使用有什么注意事项\">#</a> 行级锁的使用有什么注意事项？</h5>\n<p>InnoDB 的行锁是针对索引字段加的锁，表级锁是针对非索引字段加的锁。</p>\n<p><strong><font color='#B32015'>行级锁退化成表级锁</font></strong>：<font color='red'>当我们执行  <code>UPDATE</code> 、 <code>DELETE</code>  语句时，如果  <code>WHERE</code>  条件中字段没有命中唯一索引或者索引失效的话，就会导致扫描全表对表中的所有行记录进行加锁</font>。这个在我们日常工作开发中经常会遇到，一定要多多注意！！！</p>\n<p>不过，很多时候<font color='red'>即使用了索引也有可能会走全表扫描，这是因为 MySQL 优化器的原因，它认为全表扫描的效率比使用索引更高</font>。</p>\n<h5 id=\"innodb-有哪几类行级锁\"><a class=\"anchor\" href=\"#innodb-有哪几类行级锁\">#</a> InnoDB 有哪几类行级锁？</h5>\n<p>InnoDB 行级锁是通过对索引数据页上的<font color='red'>索引项</font>加锁实现的，MySQL InnoDB 支持三种行锁定方式：</p>\n<ul>\n<li><strong><font color='#B32015'>记录锁（Record Lock）</font></strong>：也被称为行锁，锁的是已经存在的单个行记录。</li>\n<li><strong><font color='#B32015'>间隙锁（Gap Lock）</font></strong>：锁定一个范围，不包括记录本身。<font color='red'>为了避免插入新记录</font>，需要依赖间隙锁。</li>\n<li><strong><font color='#B32015'>临键锁（Next-Key Lock）</font></strong>：可以理解为<font color='red'>行锁 + 间隙锁</font> 的组合，锁定一个行记录，及其之前的所有间隙范围。主要目的是 **<font color='red'>为了解决幻读问题</font>**（MySQL 事务部分提到过）。</li>\n</ul>\n<p><strong>在 InnoDB 默认的隔离级别 REPEATABLE-READ（可重复读）下，行级锁默认使用的是<u>临键锁（Next-Key）</u>。</strong></p>\n<blockquote>\n<p>但是，如果操作的索引是唯一索引或主键，InnoDB 会将临键锁（Next-Key）降级为<u>记录锁（Record Lock）</u>，即仅锁住索引本身，而不是范围。</p>\n</blockquote>\n<h5 id=\"共享锁和排他锁呢\"><a class=\"anchor\" href=\"#共享锁和排他锁呢\">#</a> 共享锁和排他锁呢？</h5>\n<p><font color='red'>不论是表级锁还是行级锁</font>，都存在共享锁（Share Lock，S 锁）和排他锁（eXclusive Lock，X 锁）这两类：</p>\n<ul>\n<li><strong>共享锁（S 锁）</strong>：又称<font color='red'>读锁</font>，事务在读取记录的时候获取共享锁，允许多个事务同时获取（锁兼容）。</li>\n<li><strong>排他锁（X 锁）</strong>：又称<font color='red'>写锁 / 独占锁</font>，事务在修改记录的时候获取排他锁，不允许多个事务同时获取。如果一个记录已经被加了排他锁，那其他事务不能再对这条事务加任何类型的锁（锁不兼容）。</li>\n</ul>\n<p><font color='red'>排他锁与任何的锁都不兼容，共享锁仅和共享锁兼容</font>。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"></th>\n<th style=\"text-align:left\">S 锁</th>\n<th style=\"text-align:left\">X 锁</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">S 锁</td>\n<td style=\"text-align:left\"><font color='red'>不冲突</font></td>\n<td style=\"text-align:left\">冲突</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">X 锁</td>\n<td style=\"text-align:left\">冲突</td>\n<td style=\"text-align:left\">冲突</td>\n</tr>\n</tbody>\n</table>\n<p><font color='red'>由于 MVCC（多版本并发控制）的存在，对于一般的  <code>SELECT</code>  语句，InnoDB 不会加任何锁</font>。不过，可以通过以下语句<font color='red'>显式地加共享锁或排他锁</font>：</p>\n<ul>\n<li>共享锁（MySQL 5.7 和 MySQL 8.0）： <code>SELECT ... LOCK IN SHARE MODE;</code></li>\n<li>共享锁（MySQL 8.0）： <code>SELECT ... FOR SHARE;</code></li>\n<li>排他锁： <code>SELECT ... FOR UPDATE;</code></li>\n</ul>\n<h5 id=\"意向锁有什么作用\"><a class=\"anchor\" href=\"#意向锁有什么作用\">#</a> 意向锁有什么作用？</h5>\n<p>意向锁是一种表级锁，<strong><font color='red'>作用是快速判断是否可以对某个表使用表锁，而不用逐行检查是否有行级锁</font></strong>。</p>\n<blockquote>\n<p><font color='red'>意向锁之间不会互斥。并且一旦事务提交了，意向锁就自动释放了</font>。</p>\n</blockquote>\n<ul>\n<li>\n<p><font color='cyan'>意向共享锁 (IS 锁)</font>: 事务有意向对表中的某些记录加共享锁（S 锁），加共享锁前必须先取得该表的 IS 锁。由语句 <code>select ... lock in share mode</code>  添加。</p>\n<blockquote>\n<p>与表锁共享锁 (read) 兼容，与表锁排他锁 (write) 互斥。</p>\n</blockquote>\n</li>\n<li>\n<p><font color='cyan'>意向排他锁 (IX 锁)</font>: 事务有意向对表中的某些记录加排他锁（X 锁），加排他锁之前必须先取得该表的 IX 锁。由 <code>insert</code> 、 <code>update</code> 、 <code>delete</code> 、 <code>select...for update</code>  添加。</p>\n<blockquote>\n<p>与表锁共享锁 (read) 及表锁排他锁 (write) 都互斥。</p>\n</blockquote>\n</li>\n</ul>\n<p><strong>意向锁是由存储引擎自己维护的，用户无法手动操作意向锁。<font color='red'>在为数据行加共享锁 / 排他锁之前，InooDB 会先获取该数据行所在数据表的对应意向锁</font>。</strong></p>\n<p><font color='red'>意向锁之间是互相兼容的</font>。</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>IS 锁</th>\n<th>IX 锁</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>IS 锁</td>\n<td>兼容</td>\n<td>兼容</td>\n</tr>\n<tr>\n<td>IX 锁</td>\n<td>兼容</td>\n<td>兼容</td>\n</tr>\n</tbody>\n</table>\n<p><font color='red'>意向锁与表级别的共享锁和排它锁的互斥情况如下：</font></p>\n<blockquote>\n<p>意向锁不会与行级别的共享锁和排他锁互斥</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>IS 锁</th>\n<th>IX 锁</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>S 锁</td>\n<td><font color='red'>兼容</font></td>\n<td>互斥</td>\n</tr>\n<tr>\n<td>X 锁</td>\n<td>互斥</td>\n<td>互斥</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"快照读和当前读有什么区别\"><a class=\"anchor\" href=\"#快照读和当前读有什么区别\">#</a> 快照读和当前读有什么区别？</h5>\n<p><strong><font color='#B32015'>快照读</font></strong>（<font color='red'>一致性<u>非锁定读</u></font>）就是<font color='red'>简单的  <code>SELECT</code>  语句</font>。</p>\n<p><font color='red'>快照即记录的历史版本</font>，每行记录可能存在多个历史版本（多版本技术）。</p>\n<p>快照读的情况下，如果读取的记录正在执行 UPDATE/DELETE 操作，<font color='red'>读取操作不会因此去等待记录上 X 锁的释放，而是会去读取行的一个快照</font>。</p>\n<p>只有在事务隔离级别 RC (读取已提交) 和 RR（可重读）下，InnoDB 才会使用快照读（一致性非锁定读）：</p>\n<ul>\n<li><font color='gree'>在 RC 级别下</font>，对于快照数据，一致性非锁定读总是<font color='red'>读取被锁定行的最新一份快照数据</font>。</li>\n<li><font color='gree'>在 RR 级别下</font>，对于快照数据，一致性非锁定读总是 **<font color='red'>读取本事务开始时的行数据版本</font>**。</li>\n</ul>\n<p>快照读比较<font color='red'>适合对数据一致性要求不是特别高，且追求极致性能的业务场景</font>。</p>\n<hr />\n<p><strong><font color='#B32015'>当前读</font></strong>（<font color='red'>一致性<u>锁定读</u></font>）就是<font color='red'>给行记录加 X 锁或 S 锁</font>。</p>\n<p>当前读的一些常见 SQL 语句类型如下：</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># 对读的记录加一个 X 锁</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">SELECT</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">FOR</span> <span class=\"token keyword\">UPDATE</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token comment\"># 对读的记录加一个 S 锁（MySQL 5.7 和 MySQL 8.0）</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">SELECT</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">LOCK</span> <span class=\"token operator\">IN</span> <span class=\"token keyword\">SHARE</span> <span class=\"token keyword\">MODE</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token comment\"># 对读的记录加一个 S 锁（MySQL 8.0）</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token keyword\">SELECT</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">FOR</span> <span class=\"token keyword\">SHARE</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token comment\"># 对修改的记录加一个 X 锁</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token keyword\">INSERT</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token keyword\">UPDATE</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token keyword\">DELETE</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr></table></figure><h3 id=\"mysql性能优化\"><a class=\"anchor\" href=\"#mysql性能优化\">#</a> MySQL 性能优化</h3>\n<h4 id=\"能用-mysql-直接存储文件比如图片吗\"><a class=\"anchor\" href=\"#能用-mysql-直接存储文件比如图片吗\">#</a> 能用 MySQL 直接存储文件（比如图片）吗？</h4>\n<p>虽然可以直接将文件对应的二进制数据存储到 MySQL 中，不过还是建议不要在数据库中存储文件。因为会<font color='red'>严重影响数据库性能，消耗过多存储空间</font>。</p>\n<p>可以选择使用云服务厂商提供的开箱即用的 **<font color='#B32015'>文件存储服务</font>**，成熟稳定，价格也比较低。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/oss-search.png\" alt=\"img\" /></p>\n<p>也可以选择<font color='red'>自建文件存储服务</font>，实现起来也不难，基于 FastDFS、MinIO（推荐） 等开源项目就可以实现分布式文件服务。</p>\n<p><strong><font color='#B32015'>数据库只存储文件地址信息，文件本身由文件存储服务负责存储。</font></strong></p>\n<p>相关阅读：<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuNTFjdG8uY29tL2FydGljbGUvNzE2OTc4Lmh0bWw=\">Spring Boot 整合 MinIO 实现分布式文件服务</span> 。</p>\n<h4 id=\"mysql-如何存储-ip-地址\"><a class=\"anchor\" href=\"#mysql-如何存储-ip-地址\">#</a> MySQL 如何存储 IP 地址？</h4>\n<p>可以将 IP 地址 **<font color='red'>转换成整形数据存储</font>**，性能更好，占用空间也更小。</p>\n<p>MySQL 提供了两个（互逆的）方法来处理 ip 地址：</p>\n<ul>\n<li><code>INET_ATON()</code> ：把 ip 转为无符号整型（4-8 位）</li>\n<li><code>INET_NTOA()</code> ：把整型的 ip 转为地址</li>\n</ul>\n<p>插入数据前，先用  <code>INET_ATON()</code>  把 ip 地址转为整型。显示数据时，使用  <code>INET_NTOA()</code>  把整型的 ip 地址转为地址显示即可。</p>\n<h4 id=\"常见的-sql-优化手段\"><a class=\"anchor\" href=\"#常见的-sql-优化手段\">#</a> 常见的 SQL 优化手段</h4>\n<blockquote>\n<p>指路→<a href=\"#==SQL%E4%BC%98%E5%8C%96==\">SQL 优化</a></p>\n</blockquote>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/javamianshizhibei-sql-optimization.png\" alt=\"常见的 SQL 优化手段\" /></p>\n<h4 id=\"如何分析-sql-的性能\"><a class=\"anchor\" href=\"#如何分析-sql-的性能\">#</a> 如何分析 SQL 的性能？</h4>\n<p>可以使用  <code>EXPLAIN</code>  命令来分析 SQL 的 <strong><font color='#B32015'>执行计划</font></strong> 。执行计划是指一条 SQL 语句在经过 MySQL 查询优化器的优化后的具体的执行方式。</p>\n<p><code>EXPLAIN</code>  并不会真的去执行相关的语句，而是通过 <strong><font color='#B32015'>查询优化器</font></strong> 对语句进行分析，找出最优的查询方案，并显示对应的信息。</p>\n<blockquote>\n<p>指路→[利用 EXPLAIN 命令分析 SQL 是否走索引查询](# 利用 EXPLAIN 命令分析 SQL 是否走索引查询)</p>\n</blockquote>\n<h4 id=\"读写分离-分库分表\"><a class=\"anchor\" href=\"#读写分离-分库分表\">#</a> <mark>读写分离、分库分表</mark></h4>\n<h5 id=\"读写分离\"><a class=\"anchor\" href=\"#读写分离\">#</a> 读写分离</h5>\n<blockquote>\n<p>解决的问题：<font color='red'>数据库读并发</font></p>\n</blockquote>\n<h6 id=\"什么是读写分离\"><a class=\"anchor\" href=\"#什么是读写分离\">#</a> 什么是读写分离？</h6>\n<p>见名思意，根据读写分离的名字，我们就可以知道：读写分离主要是为了 **<font color='#B32015'>将对数据库的读写操作分散到不同的数据库节点上。</font>** 这样的话，就能够<font color='red'>小幅提升写性能，大幅提升读性能</font>。</p>\n<p>我简单画了一张图来帮助不太清楚读写分离的小伙伴理解。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/read-and-write-separation.png\" alt=\"读写分离示意图\" /></p>\n<center>读写分离示意图</center>\n<p>一般情况下，我们都会选择 **<font color='#B32015'>一主多从</font>**，也就是<font color='red'>一台主数据库负责写，其他的从数据库负责读</font>。<font color='red'>主库和从库之间会进行数据实时同步（<strong>主从复制</strong>），以保证从库中数据的准确性</font>。这样的架构实现起来比较简单，并且也符合系统的<font color='red'>写少读多</font>的特点。</p>\n<h6 id=\"如何实现读写分离\"><a class=\"anchor\" href=\"#如何实现读写分离\">#</a> 如何实现读写分离？</h6>\n<p>不论是使用哪一种读写分离具体的实现方案，想要实现读写分离一般包含如下几步：</p>\n<ol>\n<li>部署多台数据库，选择其中的一台作为主数据库，其他的一台或者多台作为从数据库。</li>\n<li>保证主数据库和从数据库之间的数据是实时同步的（主从复制）。</li>\n<li>系统将写请求交给主数据库处理，读请求交给从数据库处理。</li>\n</ol>\n<p>落实到项目本身的话，常用的方式有两种：</p>\n<ol>\n<li>\n<p><strong><font color='cornflowerblue'>代理方式</font></strong></p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/read-and-write-separation-proxy.png\" alt=\"代理方式实现读写分离\" /></p>\n<center>代理方式实现读写分离</center>\n<p>我们可以在应用和数据中间加了一个 **<font color='red'>代理层</font>**。</p>\n<p>应用程序所有的数据请求都交给代理层处理，<font color='red'>代理层负责分离读写请求，将它们路由到对应的数据库中</font>。</p>\n<p>提供类似功能的中间件有 <strong>MySQL Router</strong>（官方）、<strong>Atlas</strong>（基于 MySQL Proxy）、<strong>MaxScale</strong>、<strong>MyCat</strong>。</p>\n</li>\n<li>\n<p><strong><font color='cornflowerblue'>第三方组件方式</font></strong></p>\n<blockquote>\n<p>推荐的方式</p>\n</blockquote>\n<p>在这种方式中，我们可以通过引入第三方组件来帮助我们读写请求。</p>\n<p>这也是我比较<font color='red'>推荐的一种方式</font>。这种方式目前在各种互联网公司中用的最多的，相关的实际的案例也非常多。</p>\n<p>如果你要采用这种方式的话，推荐使用  <code>sharding-jdbc</code>  ，直接引入 jar 包即可使用，非常方便。同时，也节省了很多运维的成本。</p>\n<blockquote>\n<p>你可以在 shardingsphere 官方找到 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9zaGFyZGluZ3NwaGVyZS5hcGFjaGUub3JnL2RvY3VtZW50L2xlZ2FjeS8zLngvZG9jdW1lbnQvY24vbWFudWFsL3NoYXJkaW5nLWpkYmMvdXNhZ2UvcmVhZC13cml0ZS1zcGxpdHRpbmcv\">sharding-jdbc 关于读写分离的操作</span>。</p>\n</blockquote>\n</li>\n</ol>\n<h6 id=\"主从复制的原理\"><a class=\"anchor\" href=\"#主从复制的原理\">#</a> <mark>主从复制的原理</mark></h6>\n<p><font color='red'>MySQL  <code>binlog</code> （二进制日志文件）主要记录了 MySQL 数据库中数据的所有变化（数据库执行的所有 DDL 和 DML 语句）</font>。</p>\n<p>binlog 主要有两个作用：</p>\n<ol>\n<li><strong><font color='#B32015'>主从复制</font></strong></li>\n<li><strong><font color='#B32015'>数据恢复</font></strong></li>\n</ol>\n<p>因此，<strong><font color='red'>可以根据主库的 MySQL binlog 日志就能够将主库的数据同步复制到从库中</font></strong>。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231129103209731.png\" alt=\"image-20231129103209731\" /></p>\n<center>MySQL主从复制</center>\n<ol>\n<li>\n<p>master 将数据库中数据的变化写入到  <code>binlog</code>  中</p>\n</li>\n<li>\n<p>slave 连接 master</p>\n</li>\n<li>\n<p>slave 会创建一个  <code>I/O 线程</code>  向 master 请求更新的 binlog</p>\n</li>\n<li>\n<p>master 会创建一个  <code>binlog dump 线程</code>  来发送 binlog，由 slave 中的 I/O 线程负责接收</p>\n</li>\n<li>\n<p>slave 的 I/O 线程将接收的 binlog 写入到  <code>relay log</code> （中继日志）中</p>\n</li>\n<li>\n<p>slave 的  <code>SQL 线程</code>  读取 relay log 同步数据本地（也就是再执行一遍 SQL ）</p>\n</li>\n</ol>\n<blockquote>\n<p>扩展：阿里开源的一个叫做 canal 的工具可以帮助我们同步 MySQL 数据到其他数据源（例如 Elasticsearch/MySQL）。其原理就是模拟 MySQL 主从复制的过程，解析 binlog 将数据同步到其他的数据源。</p>\n<p>另外，像咱们常用的分布式缓存组件 Redis 也是通过主从复制实现的读写分离。</p>\n</blockquote>\n<p>小结一下：</p>\n<p><strong><font color='#B32015'>MySQL 主从复制依赖于 binlog。另外，常见的一些同步 MySQL 数据到其他数据源的工具（比如 canal）的底层一般也是依赖 binlog 。</font></strong></p>\n<h6 id=\"如何避免主从同步延迟\"><a class=\"anchor\" href=\"#如何避免主从同步延迟\">#</a> 如何避免主从同步延迟？</h6>\n<p>读写分离对于提升数据库的并发非常有效，但也同时引来一个问题：主库和从库的数据存在延迟，比如你写完主库之后，主库的数据同步到从库是需要时间的，这个时间差就导致了主库和从库的数据不一致性问题。这也就是我们经常说的 **<font color='#B32015'>主从同步延迟</font>** 。</p>\n<p>如果我们的业务场景无法容忍主从同步延迟的话，应该<u>如何避免</u>呢？</p>\n<p>这里提供两种方案：</p>\n<p>（1）<strong><font color='cornflowerblue'>强制将读请求路由到 master 处理</font></strong></p>\n<blockquote>\n<p>使用最多的一种方式</p>\n</blockquote>\n<p>既然 slave 的数据过期了，那就直接从 master 读取呗！这种方案虽然会增加 master 的压力，但是实现起来比较简单，也是我了解到的 **<font color='red'>使用最多的一种方式</font>**。</p>\n<p>比如  <code>Sharding-JDBC</code>  就是采用的这种方案。通过使用 Sharding-JDBC 的  <code>HintManager</code>  分片键值管理器，我们可以强制使用 master。</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token class-name\">HintManager</span> hintManager <span class=\"token operator\">=</span> <span class=\"token class-name\">HintManager</span><span class=\"token punctuation\">.</span><span class=\"token function\">getInstance</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>hintManager<span class=\"token punctuation\">.</span><span class=\"token function\">setMasterRouteOnly</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token comment\">// 继续 JDBC 操作</span></pre></td></tr></table></figure><p>对于这种方案，<font color='red'>可以将那些必须获取最新数据的读请求都交给 master 处理</font>。</p>\n<p>（2）<font color='cornflowerblue'>延迟读取</font></p>\n<blockquote>\n<p>没办法完全避免主从延迟，只能说可以减少出现延迟的概率而已，实际项目中一般不会使用</p>\n</blockquote>\n<p>还有一些朋友肯定会想既然主从同步存在延迟，那我就在延迟之后读取啊，比如主从同步延迟 0.5s, 那我就 1s 之后再读取数据。这样多方便啊！<strong><font color='red'>方便是方便，但是也很扯淡</font></strong>。</p>\n<p>不过，如果你是这样设计业务流程就会好很多：对于一些对数据比较敏感的场景，<font color='red'>可以在完成写请求之后，避免立即进行请求操作</font>。比如你支付成功之后，跳转到一个支付成功的页面，当你点击返回之后才返回自己的账户。</p>\n<h6 id=\"主从同步延迟的原因如何尽量减少延迟\"><a class=\"anchor\" href=\"#主从同步延迟的原因如何尽量减少延迟\">#</a> 主从同步延迟的原因？如何尽量减少延迟？</h6>\n<p>MySQL 主从同步延迟指的是<font color='red'>从库的数据落后于主库的数据</font>。这种情况可能有以下<font color='gree'>2 个原因</font>：</p>\n<ol>\n<li>从库 I/O 线程接收 binlog 的速度跟不上主库写入 binlog 的速度，导致从库 relay log 的数据滞后于主库 binlog 的数据；</li>\n<li>从库 SQL 线程执行 relay log 的速度跟不上从库 I/O 线程接收 binlog 的速度，导致从库的数据滞后于从库 relay log 的数据。</li>\n</ol>\n<p>与主从同步有关的<font color='gree'>3 个时间点</font>：</p>\n<ol>\n<li>主库执行完一个事务，写入 binlog，将这个时刻记为 T1；</li>\n<li>从库 I/O 线程接收到 binlog 并写入 relay log 的时刻记为 T2；</li>\n<li>从库 SQL 线程读取 relay log 同步数据本地的时刻记为 T3。</li>\n</ol>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231129113009937.png\" alt=\"image-20231129113009937\" /></p>\n<p>结合我们上面讲到的主从复制原理，可以得出<font color='gree'>2 个结论</font>：</p>\n<ul>\n<li>T2 和 T1 的差值反映了<font color='red'>从库 I/O 线程的性能和网络传输的效率</font>，这个差值越小说明从库 I/O 线程的性能和网络传输效率越高。</li>\n<li>T3 和 T2 的差值反映了<font color='red'>从库 SQL 线程执行的速度</font>，这个差值越小，说明从库 SQL 线程执行速度越快。</li>\n</ul>\n<p>这里列举主从同步延迟的<font color='gree'>几种常见情况</font>：</p>\n<ol>\n<li><strong>从库机器性能比主库差</strong>：从库接收 binlog 并写入 relay log 以及执行 SQL 语句的速度会比较慢（也就是 T2-T1 和 T3-T2 的值会较大），进而导致延迟。解决方法是<font color='red'>选择与主库一样规格或更高规格的机器作为从库，或者对从库进行性能优化</font>，比如调整参数、增加缓存、使用 SSD 等。</li>\n<li><strong>从库处理的读请求过多</strong>：从库需要执行主库的所有写操作，同时还要响应读请求，如果读请求过多，会占用从库的 CPU、内存、网络等资源，影响从库的复制效率（也就是 T2-T1 和 T3-T2 的值会较大，和前一种情况类似）。解决方法是<font color='red'>引入缓存（推荐）、使用一主多从的架构，将读请求分散到不同的从库，或者使用其他系统来提供查询的能力</font>，比如将 binlog 接入到 Hadoop、Elasticsearch 等系统中。</li>\n<li><strong>大事务</strong>：<font color='red'>运行时间比较长，长时间未提交的事务</font>就可以称为大事务。由于大事务执行时间长，并且从库上的大事务会比主库上的大事务花费更多的时间和资源，因此非常容易造成主从延迟。解决办法是<font color='red'>避免大批量修改数据，尽量分批进行</font>。类似的情况还有执行时间较长的慢 SQL，实际项目<font color='red'>遇到慢 SQL 应该进行优化</font>。</li>\n<li><strong>从库太多</strong>：主库需要将 binlog 同步到所有的从库，如果从库数量太多，会增加同步的时间和开销（也就是 T2-T1 的值会比较大，但这里是因为主库同步压力大导致的）。解决方案是<font color='red'>减少从库的数量，或者将从库分为不同的层级，让上层的从库再同步给下层的从库，减少主库的压力</font>。</li>\n<li><strong>网络延迟</strong>：如果主从之间的网络传输速度慢，或者出现丢包、抖动等问题，那么就会影响 binlog 的传输效率，导致从库延迟。解决方法是<font color='red'>优化网络环境</font>，比如提升带宽、降低延迟、增加稳定性等。</li>\n<li><strong>单线程复制</strong>：MySQL5.5 及之前，只支持单线程复制。为了优化复制性能，MySQL 5.6 引入了 <strong>多线程复制</strong>，MySQL 5.7 还进一步完善了多线程复制。</li>\n<li><strong>复制模式</strong>：<font color='red'>MySQL 默认的复制是异步的，必然会存在延迟问题</font>。全同步复制不存在延迟问题，但性能太差了。<font color='red'>半同步复制是一种折中方案，相对于异步复制，半同步复制提高了数据的安全性，减少了主从延迟（还是有一定程度的延迟）</font>。MySQL 5.5 开始，MySQL 以插件的形式支持 <strong>semi-sync 半同步复制</strong>。并且，MySQL 5.7 引入了 <strong>增强半同步复制</strong> 。</li>\n<li>……</li>\n</ol>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly90aW1lLmdlZWtiYW5nLm9yZy9jb2x1bW4vaW50cm8vMTAwMDIwODAxP2NvZGU9aWVZOEhlUlNsRHNGYnVSdGdnYkJRR3hkVGgtMWpNQVNxRUllcXpIQUtySSUzRA==\">《MySQL 实战 45 讲》</span>这个专栏中的<span class=\"exturl\" data-url=\"aHR0cHM6Ly90aW1lLmdlZWtiYW5nLm9yZy9jb2x1bW4vYXJ0aWNsZS83NzYzNg==\">读写分离有哪些坑？</span>这篇文章也有对主从延迟解决方案这一话题进行探讨，感兴趣的可以阅读学习一下。</p>\n<h5 id=\"分库分表\"><a class=\"anchor\" href=\"#分库分表\">#</a> 分库分表</h5>\n<blockquote>\n<p>解决的问题：<font color='red'>数据库存储</font></p>\n</blockquote>\n<p>读写分离主要应对的是数据库读并发，没有解决数据库存储问题。试想一下：** 如果 MySQL 一张表的数据量过大怎么办？** 换言之，<strong>我们该如何解决 MySQL 的存储压力呢？</strong></p>\n<p>答案之一就是 **<font color='#B32015'>分库分表</font>**。</p>\n<h6 id=\"分库\"><a class=\"anchor\" href=\"#分库\">#</a> 分库</h6>\n<p>分库就是<font color='red'>将数据库中的数据分散到不同的数据库上</font>，可以分为两种：</p>\n<ul>\n<li>\n<p><strong><font color='cornflowerblue'>垂直分库</font></strong></p>\n<p>就是把单一数据库 **<font color='red'>按照业务进行划分</font>**，不同的业务使用不同的数据库，进而将一个数据库的压力分担到多个数据库。</p>\n<p>举个例子：说你将数据库中的用户表、订单表和商品表分别单独拆分为用户数据库、订单数据库和商品数据库。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231129114419366.png\" alt=\"image-20231129114419366\" /></p>\n<center>垂直分库</center>\n</li>\n<li>\n<p><strong><font color='cornflowerblue'>水平分库</font></strong></p>\n<p>就是把同一个表 **<font color='red'>按一定规则拆分</font>** 到不同的数据库中，每个库可以位于不同的服务器上，这样就实现了水平扩展，解决了单表的存储和性能瓶颈的问题。</p>\n<p>举个例子：订单表数据量太大，你对订单表进行了水平切分（水平分表），然后将切分后的 2 张订单表分别放在两个不同的数据库。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/horizontal-slicing-database-53fbc43a.png\" alt=\"水平分库\" /></p>\n<center>水平分库</center>\n</li>\n</ul>\n<h6 id=\"分表\"><a class=\"anchor\" href=\"#分表\">#</a> 分表</h6>\n<p>分表就是<font color='red'>对单表的数据进行拆分</font>，也可以分为两种：</p>\n<ul>\n<li>\n<p><strong><font color='cornflowerblue'>垂直分表</font></strong></p>\n<p>是 **<font color='red'>对列的拆分</font>**，把一张列比较多的表拆分为多张表。</p>\n<p>举个例子：我们可以将用户信息表中的一些列单独抽出来作为一个表。</p>\n</li>\n<li>\n<p><strong><font color='cornflowerblue'>水平分表</font></strong></p>\n<p>是 **<font color='red'>对行的拆分</font>**，把一张行比较多的表拆分为多张表，可以解决单一表数据量过大的问题。</p>\n<p>举个例子：我们可以将用户信息表拆分成多个用户信息表。</p>\n<p>水平拆分只能解决单表数据量大的问题，为了提升性能，我们通常会选择将拆分后的多张表放在不同的数据库中。也就是说，<font color='red'>水平分表通常和水平分库同时出现</font>。</p>\n</li>\n</ul>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/two-forms-of-sub-table-3475ce44.png\" alt=\"分表\" /></p>\n<center>分表</center>\n<h6 id=\"什么情况下需要分库分表\"><a class=\"anchor\" href=\"#什么情况下需要分库分表\">#</a> 什么情况下需要分库分表？</h6>\n<p>遇到下面几种场景可以考虑分库分表：</p>\n<ul>\n<li>单表的数据达到千万级别以上，数据库读写速度比较缓慢</li>\n<li>数据库中的数据占用的空间越来越大，备份时间越来越长</li>\n<li>应用的并发量太大</li>\n</ul>\n<h6 id=\"常见的分片算法\"><a class=\"anchor\" href=\"#常见的分片算法\">#</a> 常见的分片算法</h6>\n<p>分片算法主要 **<font color='red'>解决了数据被水平分片之后，数据究竟该存放在哪个表的问题</font>**。</p>\n<ul>\n<li><strong><font color='cornflowerblue'>哈希分片</font></strong>：求指定 key（比如 id） 的哈希，然后根据哈希值确定数据应被放置在哪个表中。哈希分片比较<font color='red'>适合随机读写的场景，不太适合经常需要范围查询的场景</font>。</li>\n<li><strong><font color='cornflowerblue'>范围分片</font></strong>：按照特性的范围区间（比如时间区间、ID 区间）来分配数据，比如 将 id 为 1~299999 的记录分到第一个库， 300000~599999 的分到第二个库。范围分片<font color='red'>适合需要经常进行范围查找的场景，不太适合随机读写的场景（数据未被分散，容易出现热点数据的问题）</font>。</li>\n<li><strong><font color='cornflowerblue'>地理位置分片</font></strong>：很多 NewSQL 数据库都支持地理位置分片算法，也就是<font color='red'>根据地理位置（如城市、地域）来分配数据</font>。</li>\n<li><strong><font color='cornflowerblue'>融合算法</font></strong>：<font color='red'>灵活组合多种分片算法</font>，比如将哈希分片和范围分片组合。</li>\n<li>……</li>\n</ul>\n<h6 id=\"分库分表会带来什么问题\"><a class=\"anchor\" href=\"#分库分表会带来什么问题\">#</a> 分库分表会带来什么问题？</h6>\n<p>记住，你在公司做的任何技术决策，不光是要考虑这个技术能不能满足我们的要求，是否适合当前业务场景，还要重点考虑其带来的成本。</p>\n<p>引入分库分表之后，会给系统带来什么挑战呢？</p>\n<ul>\n<li><strong><font color='red'>join 操作</font></strong>：同一个数据库中的表分布在了不同的数据库中，导致无法使用 join 操作。这样就导致我们需要手动进行数据的封装，比如你在一个数据库中查询到一个数据之后，再根据这个数据去另外一个数据库中找对应的数据。不过，很多大厂的资深 DBA 都是建议<font color='red'>尽量不要使用 join 操作</font>。因为 join 的效率低，并且会对分库分表造成影响。对于需要用到 join 操作的地方，<font color='red'>可以采用多次查询业务层进行数据组装的方法</font>。不过，这种方法需要考虑业务上多次查询的事务性的容忍度。</li>\n<li><strong><font color='red'>事务问题</font></strong>：同一个数据库中的表分布在了不同的数据库中，如果单个操作涉及到多个数据库，那么数据库自带的事务就无法满足我们的要求了。这个时候，我们就<font color='red'>需要引入分布式事务</font>了。关于分布式事务常见解决方案总结，网站上也有对应的总结：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9qYXZhZ3VpZGUuY24vZGlzdHJpYnV0ZWQtc3lzdGVtL2Rpc3RyaWJ1dGVkLXRyYW5zYWN0aW9uLmh0bWw=\">https://javaguide.cn/distributed-system/distributed-transaction.html</span> 。</li>\n<li><strong><font color='red'>分布式 ID</font></strong>：分库之后，数据遍布在不同服务器上的数据库，数据库的<font color='red'>自增主键已经没办法满足生成的主键唯一了</font>。我们如何为不同的数据节点生成全局唯一主键呢？这个时候，我们就需要为我们的系统<font color='red'>引入分布式 ID </font>了。关于分布式 ID 的详细介绍 &amp; 实现方案总结，网站上也有对应的总结：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9qYXZhZ3VpZGUuY24vZGlzdHJpYnV0ZWQtc3lzdGVtL2Rpc3RyaWJ1dGVkLWlkLmh0bWw=\">https://javaguide.cn/distributed-system/distributed-id.html</span> 。</li>\n<li><strong><font color='red'>跨库聚合查询问题</font></strong>：分库分表会导致常规聚合查询操作，如 group by，order by 等变得异常复杂。这是因为这些操作需要在多个分片上进行数据汇总和排序，而不是在单个数据库上进行。为了实现这些操作，<font color='red'>需要编写复杂的业务代码，或者使用中间件来协调分片间的通信和数据传输</font>。这样会增加开发和维护的成本，以及影响查询的性能和可扩展性。</li>\n<li>……</li>\n</ul>\n<p>另外，<font color='red'>引入分库分表之后，一般需要 DBA 的参与，同时还需要更多的数据库服务器</font>，这些都属于成本。</p>\n<h6 id=\"分库分表有没有什么比较推荐的方案\"><a class=\"anchor\" href=\"#分库分表有没有什么比较推荐的方案\">#</a> 分库分表有没有什么比较推荐的方案？</h6>\n<p>Apache  <code>ShardingSphere</code>  是一款分布式的数据库生态系统，<strong><font color='red'>可以将任意数据库转换为分布式数据库，并通过数据分片、弹性伸缩、加密等能力对原有数据库进行增强</font></strong>。</p>\n<p>ShardingSphere 项目（包括 Sharding-JDBC、Sharding-Proxy 和 Sharding-Sidecar）是当当捐入 Apache 的，目前主要由京东数科的一些巨佬维护。</p>\n<p>**ShardingSphere 绝对可以说是当前分库分表的首选！**ShardingSphere 的功能完善，<font color='red'>除了支持读写分离和分库分表，还提供分布式事务、数据库治理、影子库、数据加密和脱敏等功能</font>。</p>\n<p>ShardingSphere 提供的功能如下：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/shardingsphere-features.png\" alt=\"ShardingSphere 提供的功能\" /></p>\n<p>ShardingSphere 的优势如下：</p>\n<ul>\n<li>极致性能：驱动程序端历经长年打磨，效率接近原生 JDBC，性能极致。</li>\n<li>生态兼容：代理端支持任何通过 MySQL/PostgreSQL 协议的应用访问，驱动程序端可对接任意实现 JDBC 规范的数据库。</li>\n<li>业务零侵入：面对数据库替换场景，ShardingSphere 可满足业务无需改造，实现平滑业务迁移。</li>\n<li>运维低成本：在保留原技术栈不变前提下，对 DBA 学习、管理成本低，交互友好。</li>\n<li>安全稳定：基于成熟数据库底座之上提供增量能力，兼顾安全性及稳定性。</li>\n<li>弹性扩展：具备计算、存储平滑在线扩展能力，可满足业务多变的需求。</li>\n<li>开放生态：通过多层次（内核、功能、生态）插件化能力，为用户提供可定制满足自身特殊需求的独有系统。</li>\n</ul>\n<p>另外，ShardingSphere 的生态体系完善，社区活跃，文档完善，更新和发布比较频繁。</p>\n<p>艿艿之前写了一篇分库分表的实战文章，各位朋友可以看看：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvQTJNWU9GVDdTUC03a0dPb244cUphdw==\">《芋道 Spring Boot 分库分表入门》</span> 。</p>\n<h6 id=\"分库分表后数据怎么迁移呢\"><a class=\"anchor\" href=\"#分库分表后数据怎么迁移呢\">#</a> 分库分表后，数据怎么迁移呢？</h6>\n<p>分库分表之后，我们<font color='red'>如何将老库（单库单表）的数据迁移到新库（分库分表后的数据库系统）呢？</font></p>\n<p>比较简单同时也是<font color='red'>非常常用</font>的方案就是 **<font color='cornflowerblue'>停机迁移</font>**，写个脚本将老库的数据写到新库中。比如你在凌晨 2 点，系统使用的人数非常少的时候，挂一个公告说系统要维护升级预计 1 小时。然后，你写一个脚本将老库的数据都同步到新库中。</p>\n<p>如果你<font color='red'>不想停机迁移数据的话</font>，也可以考虑 **<font color='cornflowerblue'>双写方案</font>**。双写方案是针对那种不能停机迁移的场景，实现起来要稍微麻烦一些。具体原理是这样的：</p>\n<ul>\n<li>我们<font color='red'>对老库的更新操作（增删改），同时也要写入新库（双写）</font>。如果操作的数据不存在于新库的话，需要插入到新库中。这样就能保证，咱们新库里的数据是最新的。</li>\n<li>在迁移过程，双写只会让被更新操作过的老库中的数据同步到新库，我们<font color='red'>还需要自己写脚本将老库中的数据和新库的数据做比对</font>。如果新库中没有，那咱们就把数据插入到新库。如果新库有，旧库没有，就把新库对应的数据删除（冗余数据清理）。</li>\n<li>重复上一步的操作，<font color='red'>直到老库和新库的数据一致为止</font>。</li>\n</ul>\n<p>想要在项目中实施双写还是比较麻烦的，很容易会出现问题。我们<font color='red'>可以借助上面提到的数据库同步工具 Canal 做增量数据迁移</font>（还是依赖 binlog，开发和维护成本较低）。</p>\n<h5 id=\"总结-4\"><a class=\"anchor\" href=\"#总结-4\">#</a> 总结</h5>\n<ul>\n<li>\n<p><font color='red'>读写分离主要是为了将对数据库的读写操作分散到不同的数据库节点上</font>。这样的话，就能够小幅提升写性能，大幅提升读性能。</p>\n</li>\n<li>\n<p><font color='red'>读写分离基于主从复制，而 MySQL 主从复制依赖于  <code>binlog</code> </font>。</p>\n</li>\n<li>\n<p>分库就是将数据库中的数据分散到不同的数据库上。分表就是对单表的数据进行拆分，可以是垂直拆分，也可以是水平拆分。</p>\n</li>\n<li>\n<p>引入分库分表之后，需要系统解决事务、分布式 id、无法 join 操作问题。</p>\n</li>\n<li>\n<p><font color='red'>ShardingSphere 绝对可以说是当前分库分表的首选</font>！ShardingSphere 的功能完善，除了支持读写分离和分库分表，还提供分布式事务、数据库治理等功能。另外，ShardingSphere 的生态体系完善，社区活跃，文档完善，更新和发布比较频繁。</p>\n</li>\n</ul>\n<h2 id=\"mysql-高性能优化规范建议\"><a class=\"anchor\" href=\"#mysql-高性能优化规范建议\">#</a> MySQL 高性能优化规范建议</h2>\n<h3 id=\"命名规范\"><a class=\"anchor\" href=\"#命名规范\">#</a> 命名规范</h3>\n<ul>\n<li>\n<p>所有数据库对象名称必须使用<font color='red'>小写字母</font>并用<font color='red'>下划线分割</font></p>\n</li>\n<li>\n<p>所有数据库对象名称<font color='red'>禁止使用 MySQL 保留关键字</font>（如果表名中包含关键字查询时，需要将其用单引号括起来）</p>\n</li>\n<li>\n<p>数据库对象的命名要能做到<font color='red'>见名识意，并且最后不要超过 32 个字符</font></p>\n</li>\n<li>\n<p><font color='red'>临时库表必须以  <code>tmp_</code>  为前缀并以日期为后缀</font>，<font color='red'>备份表必须以  <code>bak_</code>  为前缀并以日期 (时间戳) 为后缀</font></p>\n</li>\n<li>\n<p>所有存储相同数据的列名和列类型必须一致（一般作为关联列，<font color='red'>如果查询时关联列类型不一致会自动进行数据类型隐式转换，造成列上的索引失效</font>，导致查询效率降低）</p>\n</li>\n</ul>\n<h3 id=\"基本设计规范\"><a class=\"anchor\" href=\"#基本设计规范\">#</a> 基本设计规范</h3>\n<h4 id=\"所有表必须使用-innodb-存储引擎\"><a class=\"anchor\" href=\"#所有表必须使用-innodb-存储引擎\">#</a> 所有表必须使用 InnoDB 存储引擎</h4>\n<p>没有特殊要求（即 InnoDB 无法满足的功能如：列存储，存储空间数据等）的情况下，所有表必须使用 InnoDB 存储引擎（MySQL5.5 之前默认使用 MyISAM，5.6 以后默认的为 InnoDB）。</p>\n<p><font color='red'>InnoDB 支持事务、行级锁、外键约束，有更好的恢复性，高并发下性能更好</font>。</p>\n<h4 id=\"数据库和表的字符集统一使用-utf8\"><a class=\"anchor\" href=\"#数据库和表的字符集统一使用-utf8\">#</a> 数据库和表的字符集统一使用 UTF8</h4>\n<p>兼容性更好，统一字符集可以避免由于字符集转换产生的乱码，<font color='red'>不同的字符集进行比较前需要进行转换会造成索引失效</font>。</p>\n<p>如果数据库中有存储 emoji 表情的需要，字符集需要采用 utf8mb4 字符集。</p>\n<h4 id=\"所有表和字段都需要添加注释\"><a class=\"anchor\" href=\"#所有表和字段都需要添加注释\">#</a> 所有表和字段都需要添加注释</h4>\n<p>使用 comment 从句添加表和列的备注，从一开始就进行<font color='red'>数据字典的维护</font>。</p>\n<h4 id=\"尽量控制单表数据量的大小建议控制在-500-万以内\"><a class=\"anchor\" href=\"#尽量控制单表数据量的大小建议控制在-500-万以内\">#</a> 尽量控制单表数据量的大小，建议控制在 500 万以内</h4>\n<p>500 万并不是 MySQL 数据库的限制，过大会造成修改表结构，备份，恢复都会有很大的问题。</p>\n<p>可以用<font color='red'>历史数据归档（应用于日志数据）</font>，<font color='red'>分库分表（应用于业务数据）</font>等手段来控制数据量大小。</p>\n<h4 id=\"谨慎使用-mysql-分区表\"><a class=\"anchor\" href=\"#谨慎使用-mysql-分区表\">#</a> 谨慎使用 MySQL 分区表</h4>\n<p>分区表在物理上表现为多个文件，在逻辑上表现为一个表；</p>\n<p>谨慎选择分区键，<font color='red'>跨分区查询效率可能更低</font>；</p>\n<p><font color='red'>建议采用物理分表</font>的方式管理大数据。</p>\n<h4 id=\"经常一起使用的列放到一个表中\"><a class=\"anchor\" href=\"#经常一起使用的列放到一个表中\">#</a> 经常一起使用的列放到一个表中</h4>\n<p>避免更多的关联操作。</p>\n<h4 id=\"禁止在表中建立预留字段\"><a class=\"anchor\" href=\"#禁止在表中建立预留字段\">#</a> 禁止在表中建立预留字段</h4>\n<ul>\n<li>预留字段的命名<font color='red'>很难做到见名识义</font>。</li>\n<li>预留字段<font color='red'>无法确认存储的数据类型</font>，所以无法选择合适的类型。</li>\n<li>对预留字段类型的修改，会对表进行锁定。</li>\n</ul>\n<h4 id=\"禁止在数据库中存储文件比如图片这类大的二进制数据\"><a class=\"anchor\" href=\"#禁止在数据库中存储文件比如图片这类大的二进制数据\">#</a> 禁止在数据库中存储文件（比如图片）这类大的二进制数据</h4>\n<p>在数据库中存储文件<font color='red'>会严重影响数据库性能，消耗过多存储空间</font>。</p>\n<p>这类大的二进制数据文件（比如图片）<font color='red'>通常存储于文件服务器，数据库只存储文件地址信息</font>。</p>\n<h4 id=\"不要被数据库范式所束缚\"><a class=\"anchor\" href=\"#不要被数据库范式所束缚\">#</a> 不要被数据库范式所束缚</h4>\n<p>一般来说，设计关系数据库时需要满足第三范式，但<font color='red'>为了满足第三范式，我们可能会拆分出多张表</font>。而在进行查询时需要对多张表进行关联查询，<font color='red'>有时为了提高查询效率，会降低范式的要求，在表中保存一定的冗余信息，也叫做反范式</font>。但要注意反范式一定要适度。</p>\n<h4 id=\"禁止在线上做数据库压力测试\"><a class=\"anchor\" href=\"#禁止在线上做数据库压力测试\">#</a> 禁止在线上做数据库压力测试</h4>\n<h4 id=\"禁止从开发环境-测试环境直接连接生产环境数据库\"><a class=\"anchor\" href=\"#禁止从开发环境-测试环境直接连接生产环境数据库\">#</a> 禁止从开发环境、测试环境直接连接生产环境数据库</h4>\n<p>安全隐患极大，要对生产环境抱有敬畏之心！</p>\n<h3 id=\"字段设计规范\"><a class=\"anchor\" href=\"#字段设计规范\">#</a> 字段设计规范</h3>\n<h4 id=\"优先选择符合存储需要的最小的数据类型\"><a class=\"anchor\" href=\"#优先选择符合存储需要的最小的数据类型\">#</a> 优先选择符合存储需要的最小的数据类型</h4>\n<p>存储字节越小，占用也就空间越小，性能也越好。</p>\n<p><strong>a. 某些字符串可以转换成数字类型存储，比如可以将 IP 地址转换成整型数据。</strong></p>\n<p>数字是连续的，性能更好，占用空间也更小。</p>\n<p>MySQL 提供了两个方法来处理 ip 地址</p>\n<ul>\n<li><code>INET_ATON()</code> ：把 ip 转为无符号整型 (4-8 位)</li>\n<li><code>INET_NTOA()</code>  : 把整型的 ip 转为地址</li>\n</ul>\n<p>插入数据前，先用  <code>INET_ATON()</code>  把 ip 地址转为整型，显示数据时，使用  <code>INET_NTOA()</code>  把整型的 ip 地址转为地址显示即可。</p>\n<p><strong>b. 对于非负型的数据 (如自增 ID、整型 IP、年龄) 来说，要优先使用无符号整型来存储。</strong></p>\n<p><font color='red'>无符号相对于有符号可以多出一倍的存储空间</font></p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>SIGNED <span class=\"token keyword\">INT</span> <span class=\"token operator\">-</span><span class=\"token number\">2147483648</span><span class=\"token operator\">~</span><span class=\"token number\">2147483647</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">UNSIGNED</span> <span class=\"token keyword\">INT</span> <span class=\"token number\">0</span><span class=\"token operator\">~</span><span class=\"token number\">4294967295</span></pre></td></tr></table></figure><p><strong>c. 小数值类型（比如年龄、状态表示如 0/1）优先使用 TINYINT 类型。</strong></p>\n<h4 id=\"避免使用-text-blob-数据类型最常见的-text-类型可以存储-64k-的数据\"><a class=\"anchor\" href=\"#避免使用-text-blob-数据类型最常见的-text-类型可以存储-64k-的数据\">#</a> 避免使用 TEXT、BLOB 数据类型，最常见的 TEXT 类型可以存储 64k 的数据</h4>\n<p><strong>a. 建议把 BLOB 或是 TEXT 列分离到单独的扩展表中。</strong></p>\n<p>MySQL <font color='red'>内存临时表不支持 TEXT、BLOB 这样的大数据类型</font>，如果查询中包含这样的数据，在排序等操作时，就不能使用内存临时表，<font color='red'>必须使用磁盘临时表进行</font>。而且对于这种数据，MySQL 还是要进行二次查询，会使 sql 性能变得很差，但是不是说一定不能使用这样的数据类型。</p>\n<p><font color='red'>如果一定要使用，建议把 BLOB 或是 TEXT 列分离到单独的扩展表中</font>，查询时一定不要使用  <code>select *</code>  而只需要取出必要的列，不需要 TEXT 列的数据时不要对该列进行查询。</p>\n<p><strong>2、TEXT 或 BLOB 类型只能使用前缀索引</strong></p>\n<p>因为 MySQL 对索引字段长度是有限制的，所以 TEXT 类型只能使用前缀索引，并且 TEXT 列上是不能有默认值的。</p>\n<h4 id=\"避免使用-enum-类型\"><a class=\"anchor\" href=\"#避免使用-enum-类型\">#</a> 避免使用 ENUM 类型</h4>\n<ul>\n<li><font color='red'>修改 ENUM 值需要使用 ALTER 语句</font>；</li>\n<li>ENUM 类型的 <font color='red'>ORDER BY 操作效率低</font>，需要额外操作；</li>\n<li>ENUM 数据类型存在一些限制，比如建议不要使用数值作为 ENUM 的枚举值。</li>\n</ul>\n<p>相关阅读：<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzQwNDQyMjI1NS9hbnN3ZXIvMTY2MTY5ODQ5OQ==\">是否推荐使用 MySQL 的 enum 类型？ - 架构文摘 - 知乎</span></p>\n<h4 id=\"尽可能把所有列定义为-not-null\"><a class=\"anchor\" href=\"#尽可能把所有列定义为-not-null\">#</a> 尽可能把所有列定义为 NOT NULL</h4>\n<p>除非有特别的原因使用 NULL 值，应该总是让字段保持 NOT NULL。</p>\n<ul>\n<li>索引 NULL 列需要额外的空间来保存，所以要占用更多的空间；</li>\n<li>进行比较和计算时要对 NULL 值做特别的处理。</li>\n</ul>\n<p>相关阅读：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9vcGVuc291cmNlLmFjdGlvbnNreS5jb20vMjAxOTA3MTAtbXlzcWwv\">技术分享 | MySQL 默认值选型（是空，还是 NULL）</span></p>\n<h4 id=\"一定不要用字符串存储日期\"><a class=\"anchor\" href=\"#一定不要用字符串存储日期\">#</a> 一定不要用字符串存储日期</h4>\n<p>对于日期类型来说，一定不要用字符串存储日期。<font color='red'>可以考虑 DATETIME、TIMESTAMP、数值型时间戳</font>。</p>\n<p>这三种方式都有各自的优势，根据实际场景选择最合适的才是王道。下面再对这三种方式做一个简单的对比，以供大家实际开发中选择正确的存放时间的数据类型：</p>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>存储空间</th>\n<th>日期格式</th>\n<th>日期范围</th>\n<th>是否带时区信息</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>DATETIME</td>\n<td>5~8 字节</td>\n<td>YYYY-MM-DD hh:mm:ss[.fraction]</td>\n<td>1000-01-01 00:00:00[.000000] ～ 9999-12-31 23:59:59[.999999]</td>\n<td>否</td>\n</tr>\n<tr>\n<td>TIMESTAMP</td>\n<td>4~7 字节</td>\n<td>YYYY-MM-DD hh:mm:ss[.fraction]</td>\n<td>1970-01-01 00:00:01[.000000] ～ 2038-01-19 03:14:07[.999999]</td>\n<td>是</td>\n</tr>\n<tr>\n<td>数值型时间戳</td>\n<td>4 字节</td>\n<td>全数字如 1578707612</td>\n<td>1970-01-01 00:00:01 之后的时间</td>\n<td>否</td>\n</tr>\n</tbody>\n</table>\n<p>MySQL 时间类型选择的详细介绍请看这篇：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9qYXZhZ3VpZGUuY24vZGF0YWJhc2UvbXlzcWwvc29tZS10aG91Z2h0cy1vbi1kYXRhYmFzZS1zdG9yYWdlLXRpbWUuaHRtbA==\">MySQL 时间类型数据存储建议</span>。</p>\n<h4 id=\"财务相关的金额类数据必须使用-decimal-类型\"><a class=\"anchor\" href=\"#财务相关的金额类数据必须使用-decimal-类型\">#</a> 财务相关的金额类数据必须使用 decimal 类型</h4>\n<ul>\n<li><strong>非精准浮点</strong>：float,double</li>\n<li><strong>精准浮点</strong>：decimal</li>\n</ul>\n<p>decimal 类型为精准浮点数，在计算时不会丢失精度。占用空间由定义的宽度决定，每 4 个字节可以存储 9 位数字，并且小数点要占用一个字节。并且，decimal 可用于存储比 bigint 更大的整型数据</p>\n<p>不过， 由于 decimal 需要额外的空间和计算开销，应该尽量只在需要对数据进行精确计算时才使用 decimal 。</p>\n<h3 id=\"索引设计规范\"><a class=\"anchor\" href=\"#索引设计规范\">#</a> 索引设计规范</h3>\n<h3 id=\"sql-开发规范\"><a class=\"anchor\" href=\"#sql-开发规范\">#</a> SQL 开发规范</h3>\n<h3 id=\"操作行为规范\"><a class=\"anchor\" href=\"#操作行为规范\">#</a> 操作行为规范</h3>\n<h2 id=\"sql\"><a class=\"anchor\" href=\"#sql\">#</a> SQL</h2>\n<h3 id=\"sql语法基础\"><a class=\"anchor\" href=\"#sql语法基础\">#</a> SQL 语法基础</h3>\n<h4 id=\"基本概念-2\"><a class=\"anchor\" href=\"#基本概念-2\">#</a> 基本概念</h4>\n<h5 id=\"数据库术语\"><a class=\"anchor\" href=\"#数据库术语\">#</a> 数据库术语</h5>\n<ul>\n<li><code>数据库（database）</code>  - 保存有组织的数据的容器（通常是一个文件或一组文件）。</li>\n<li><code>数据表（table）</code>  - 某种特定类型数据的结构化清单。</li>\n<li><code>模式（schema）</code>  - <font color='red'>关于数据库和表的布局及特性的信息</font>。模式<font color='red'>定义了数据在表中如何存储</font>，包含存储什么样的数据，数据如何分解，各部分信息如何命名等信息。数据库和表都有模式。</li>\n<li><code>列（column）</code>  - 表中的一个字段。所有表都是由一个或多个列组成的。</li>\n<li><code>行（row）</code>  - 表中的一个记录。</li>\n<li><code>主键（primary key）</code>  - 一列（或一组列），其值能够唯一标识表中每一行。</li>\n</ul>\n<h5 id=\"sql-语法\"><a class=\"anchor\" href=\"#sql-语法\">#</a> SQL 语法</h5>\n<p><code>SQL（Structured Query Language)</code> ，标准 SQL 由 ANSI 标准委员会管理，从而称为 ANSI SQL。各个 DBMS 都有自己的实现，如 PL/SQL、Transact-SQL 等。</p>\n<h6 id=\"sql-语法结构\"><a class=\"anchor\" href=\"#sql-语法结构\">#</a> SQL 语法结构</h6>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/cb684d4c75fc430e92aaee226069c7da%7Etplv-k3u1fbpfcp-zoom-1.image\" alt=\"img\" /></p>\n<p>SQL 语法结构包括：</p>\n<ul>\n<li><strong> <code>子句</code> </strong> - 是语句和查询的组成成分。（在某些情况下，这些都是可选的。）</li>\n<li><strong> <code>表达式</code> </strong> - 可以产生任何标量值，或由列和行的数据库表</li>\n<li><strong> <code>谓词</code> </strong> - 给需要评估的 SQL 三值逻辑（3VL）（true/false/unknown）或布尔真值指定条件，并限制语句和查询的效果，或改变程序流程。</li>\n<li><strong> <code>查询</code> </strong> - 基于特定条件检索数据。这是 SQL 的一个重要组成部分。</li>\n<li><strong> <code>语句</code> </strong> - 可以持久地影响纲要和数据，也可以控制数据库事务、程序流程、连接、会话或诊断。</li>\n</ul>\n<h6 id=\"sql-语法要点\"><a class=\"anchor\" href=\"#sql-语法要点\">#</a> SQL 语法要点</h6>\n<ul>\n<li><strong>SQL 语句不区分大小写</strong>，但是数据库表名、列名和值是否区分，依赖于具体的 DBMS 以及配置。例如： <code>SELECT</code>  与  <code>select</code>  、 <code>Select</code>  是相同的。</li>\n<li><strong>多条 SQL 语句必须以分号（ <code>;</code> ）分隔</strong>。</li>\n<li>处理 SQL 语句时，<strong>所有空格都被忽略</strong>。</li>\n</ul>\n<p>SQL 语句可以写成一行，也可以分写为多行。</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">-- 一行 SQL 语句</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">UPDATE</span> <span class=\"token keyword\">user</span> <span class=\"token keyword\">SET</span> username<span class=\"token operator\">=</span><span class=\"token string\">'robot'</span><span class=\"token punctuation\">,</span> password<span class=\"token operator\">=</span><span class=\"token string\">'robot'</span> <span class=\"token keyword\">WHERE</span> username <span class=\"token operator\">=</span> <span class=\"token string\">'root'</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token comment\">-- 多行 SQL 语句</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token keyword\">UPDATE</span> <span class=\"token keyword\">user</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token keyword\">SET</span> username<span class=\"token operator\">=</span><span class=\"token string\">'robot'</span><span class=\"token punctuation\">,</span> password<span class=\"token operator\">=</span><span class=\"token string\">'robot'</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token keyword\">WHERE</span> username <span class=\"token operator\">=</span> <span class=\"token string\">'root'</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>SQL 支持三种注释：</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">## 注释 1</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token comment\">-- 注释 2</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token comment\">/* 注释 3 */</span></pre></td></tr></table></figure><h5 id=\"sql-分类\"><a class=\"anchor\" href=\"#sql-分类\">#</a> SQL 分类</h5>\n<h6 id=\"数据定义语言ddl\"><a class=\"anchor\" href=\"#数据定义语言ddl\">#</a> 数据定义语言（DDL）</h6>\n<p>数据定义语言（Data Definition Language，DDL）是 SQL 语言集中负责数据结构定义与数据库对象定义的语言。</p>\n<p>DDL 的主要功能是<strong>定义数据库对象</strong>。</p>\n<p>DDL 的核心指令是  <code>CREATE</code> 、 <code>ALTER</code> 、 <code>DROP</code> 。</p>\n<h6 id=\"数据操纵语言dml\"><a class=\"anchor\" href=\"#数据操纵语言dml\">#</a> 数据操纵语言（DML）</h6>\n<p>数据操纵语言（Data Manipulation Language, DML）是用于数据库操作，对数据库其中的对象和数据运行访问工作的编程语句。</p>\n<p>DML 的主要功能是 访问数据，因此其语法都是以<strong>读写数据库</strong>为主。</p>\n<p>DML 的核心指令是  <code>INSERT</code> 、 <code>DELETE</code> 、 <code>UPDATE</code> 、 <code>SELECT</code> 。这四个指令合称 CRUD (Create, Read, Update, Delete)，即增删改查。</p>\n<h6 id=\"事务控制语言tcl\"><a class=\"anchor\" href=\"#事务控制语言tcl\">#</a> 事务控制语言（TCL）</h6>\n<p>事务控制语言 (Transaction Control Language, TCL) 用于<strong>管理数据库中的事务</strong>。这些用于管理由 DML 语句所做的更改。它还允许将语句分组为逻辑事务。</p>\n<p>TCL 的核心指令是  <code>COMMIT</code> 、 <code>ROLLBACK</code> 。</p>\n<h6 id=\"数据控制语言dcl\"><a class=\"anchor\" href=\"#数据控制语言dcl\">#</a> 数据控制语言（DCL）</h6>\n<p>数据控制语言 (Data Control Language, DCL) 是一种可对数据访问权进行控制的指令，它可以控制特定用户账户对数据表、查看表、预存程序、用户自定义函数等数据库对象的控制权。</p>\n<p>DCL 的核心指令是  <code>GRANT</code> 、 <code>REVOKE</code> 。</p>\n<p>DCL 以<strong>控制用户的访问权限</strong>为主，因此其指令作法并不复杂，可利用 DCL 控制的权限有： <code>CONNECT</code> 、 <code>SELECT</code> 、 <code>INSERT</code> 、 <code>UPDATE</code> 、 <code>DELETE</code> 、 <code>EXECUTE</code> 、 <code>USAGE</code> 、 <code>REFERENCES</code> 。</p>\n<p>根据不同的 DBMS 以及不同的安全性实体，其支持的权限控制也有所不同。</p>\n<p><strong>我们先来介绍 DML 语句用法。 DML 的主要功能是读写数据库实现增删改查。</strong></p>\n<h4 id=\"增删改查\"><a class=\"anchor\" href=\"#增删改查\">#</a> 增删改查</h4>\n<p>增删改查，又称为 CRUD，数据库基本操作中的基本操作。</p>\n<h5 id=\"插入数据\"><a class=\"anchor\" href=\"#插入数据\">#</a> 插入数据</h5>\n<p><code>INSERT INTO</code>  语句用于向表中插入新记录。</p>\n<p><strong>插入完整的行</strong></p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># 插入一行</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">INSERT</span> <span class=\"token keyword\">INTO</span> <span class=\"token keyword\">user</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">VALUES</span> <span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'root'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'root'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'xxxx@163.com'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token comment\"># 插入多行</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">INSERT</span> <span class=\"token keyword\">INTO</span> <span class=\"token keyword\">user</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token keyword\">VALUES</span> <span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'root'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'root'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'xxxx@163.com'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token number\">12</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'user1'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'user1'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'xxxx@163.com'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token number\">18</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'user2'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'user2'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'xxxx@163.com'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p><strong>插入行的一部分</strong></p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">INSERT</span> <span class=\"token keyword\">INTO</span> <span class=\"token keyword\">user</span><span class=\"token punctuation\">(</span>username<span class=\"token punctuation\">,</span> password<span class=\"token punctuation\">,</span> email<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">VALUES</span> <span class=\"token punctuation\">(</span><span class=\"token string\">'admin'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'admin'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'xxxx@163.com'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p><strong>插入查询出来的数据</strong></p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">INSERT</span> <span class=\"token keyword\">INTO</span> <span class=\"token keyword\">user</span><span class=\"token punctuation\">(</span>username<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">SELECT</span> name</pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">FROM</span> account<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h5 id=\"更新数据\"><a class=\"anchor\" href=\"#更新数据\">#</a> 更新数据</h5>\n<p><code>UPDATE</code>  语句用于更新表中的记录。</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">UPDATE</span> <span class=\"token keyword\">user</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">SET</span> username<span class=\"token operator\">=</span><span class=\"token string\">'robot'</span><span class=\"token punctuation\">,</span> password<span class=\"token operator\">=</span><span class=\"token string\">'robot'</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">WHERE</span> username <span class=\"token operator\">=</span> <span class=\"token string\">'root'</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h5 id=\"删除数据\"><a class=\"anchor\" href=\"#删除数据\">#</a> 删除数据</h5>\n<ul>\n<li><code>DELETE</code>  语句用于删除表中的记录。</li>\n<li><code>TRUNCATE TABLE</code>  可以清空表，也就是删除所有行。</li>\n</ul>\n<p><strong>删除表中的指定数据</strong></p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">DELETE</span> <span class=\"token keyword\">FROM</span> <span class=\"token keyword\">user</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">WHERE</span> username <span class=\"token operator\">=</span> <span class=\"token string\">'robot'</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p><strong>清空表中的数据</strong></p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">TRUNCATE</span> <span class=\"token keyword\">TABLE</span> <span class=\"token keyword\">user</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h5 id=\"查询数据\"><a class=\"anchor\" href=\"#查询数据\">#</a> 查询数据</h5>\n<p><code>SELECT</code>  语句用于从数据库中查询数据。</p>\n<p><code>DISTINCT</code>  用于返回唯一不同的值。它<font color='red'>作用于所有列</font>，也就是说所有列的值都相同才算相同。</p>\n<p><code>LIMIT</code>  限制返回的行数。可以有两个参数，<strong><font color='red'>第一个参数为起始行从 0 开始</font></strong>；<font color='red'>第二个参数为返回的总行数</font>。</p>\n<ul>\n<li><code>ASC</code>  ：升序（默认）</li>\n<li><code>DESC</code>  ：降序</li>\n</ul>\n<p><strong>查询单列</strong></p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">SELECT</span> prod_name</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">FROM</span> products<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p><strong>查询多列</strong></p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">SELECT</span> prod_id<span class=\"token punctuation\">,</span> prod_name<span class=\"token punctuation\">,</span> prod_price</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">FROM</span> products<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p><strong>查询所有列</strong></p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">FROM</span> products<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p><strong>查询不同的值</strong></p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">SELECT</span> <span class=\"token keyword\">DISTINCT</span> vend_id </pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">FROM</span> products<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p><strong>限制查询结果</strong></p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">-- 返回前 5 行</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> mytable <span class=\"token keyword\">LIMIT</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> mytable <span class=\"token keyword\">LIMIT</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token comment\">-- 返回第 3 ~ 5 行</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> mytable <span class=\"token keyword\">LIMIT</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h4 id=\"排序\"><a class=\"anchor\" href=\"#排序\">#</a> 排序</h4>\n<p><code>order by</code>  用于对结果集按照一个列或者多个列进行排序。 <code>默认升序</code> 对记录进行排序，如果需要按照降序对记录进行排序，可以使用  <code>desc</code>  关键字。</p>\n<p><code>order by</code>  对多列排序的时候，先排序的列放前面，后排序的列放后面。并且，<font color='red'>不同的列可以有不同的排序规则</font>。</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> products</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">ORDER</span> <span class=\"token keyword\">BY</span> prod_price <span class=\"token keyword\">DESC</span><span class=\"token punctuation\">,</span> prod_name <span class=\"token keyword\">ASC</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h4 id=\"分组\"><a class=\"anchor\" href=\"#分组\">#</a> 分组</h4>\n<p><strong> <code>group by</code> </strong> ：</p>\n<ul>\n<li><code>group by</code>  子句将记录分组到汇总行中。</li>\n<li><code>group by</code>  为每个组返回一个记录。</li>\n<li><code>group by</code>  通常还涉及聚合 <code>count</code> ， <code>max</code> ， <code>sum</code> ， <code>avg</code>  等。</li>\n<li><code>group by</code>  可以按一列或多列进行分组。</li>\n<li><code>group by</code>  按分组字段进行排序后， <code>order by</code>  可以以汇总字段来进行排序。</li>\n</ul>\n<p><strong>分组</strong></p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">SELECT</span> cust_name<span class=\"token punctuation\">,</span> <span class=\"token function\">COUNT</span><span class=\"token punctuation\">(</span>cust_address<span class=\"token punctuation\">)</span> <span class=\"token keyword\">AS</span> addr_num</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">FROM</span> Customers <span class=\"token keyword\">GROUP</span> <span class=\"token keyword\">BY</span> cust_name<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p><strong>分组后排序</strong></p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">SELECT</span> cust_name<span class=\"token punctuation\">,</span> <span class=\"token function\">COUNT</span><span class=\"token punctuation\">(</span>cust_address<span class=\"token punctuation\">)</span> <span class=\"token keyword\">AS</span> addr_num</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">FROM</span> Customers <span class=\"token keyword\">GROUP</span> <span class=\"token keyword\">BY</span> cust_name</pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">ORDER</span> <span class=\"token keyword\">BY</span> cust_name <span class=\"token keyword\">DESC</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p><strong> <code>having</code> </strong>：</p>\n<ul>\n<li><code>having</code>  <font color='red'>用于对汇总的  <code>group by</code>  结果进行过滤</font>。</li>\n<li><code>having</code>  一般都是和  <code>group by</code>  连用。</li>\n<li><code>where</code>  和  <code>having</code>  可以在相同的查询中。</li>\n</ul>\n<p><strong>使用 WHERE 和 HAVING 过滤数据</strong></p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">SELECT</span> cust_name<span class=\"token punctuation\">,</span> <span class=\"token function\">COUNT</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">AS</span> num</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">FROM</span> Customers</pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">WHERE</span> cust_email <span class=\"token operator\">IS</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">GROUP</span> <span class=\"token keyword\">BY</span> cust_name</pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">HAVING</span> <span class=\"token function\">COUNT</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">>=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p><strong> <code>having</code>  vs  <code>where</code> </strong> ：</p>\n<ul>\n<li><code>where</code> ：\n<ul>\n<li><font color='red'>过滤指定的<u>行</u></font></li>\n<li><font color='red'>后面不能加聚合函数</font>（分组函数）</li>\n<li><font color='red'>在 <code>group by</code>  前使用</font></li>\n</ul>\n</li>\n<li><code>having</code> ：\n<ul>\n<li><font color='red'>过滤<u>分组</u></font></li>\n<li>一般都是和  <code>group by</code>  连用，<font color='red'>不能单独使用</font></li>\n<li><font color='red'>在  <code>group by</code>  之后使用</font></li>\n</ul>\n</li>\n</ul>\n<h4 id=\"子查询\"><a class=\"anchor\" href=\"#子查询\">#</a> 子查询</h4>\n<p>子查询是嵌套在较大查询中的 SQL 查询，也称内部查询或内部选择，包含子查询的语句也称为外部查询或外部选择。简单来说，子查询就是指<font color='red'>将一个  <code>select</code>  查询（子查询）的结果作为另一个 SQL 语句（主查询）的<u>数据来源</u>或者<u>判断条件</u></font>。</p>\n<p>子查询可以嵌入  <code>SELECT</code> 、 <code>INSERT</code> 、 <code>UPDATE</code>  和  <code>DELETE</code>  语句中，也可以和  <code>=</code> 、 <code>&lt;</code> 、 <code>&gt;</code> 、 <code>IN</code> 、 <code>BETWEEN</code> 、 <code>EXISTS</code>  等运算符一起使用。</p>\n<p>子查询常用在  <code>WHERE</code>  子句和  <code>FROM</code>  子句后边：</p>\n<ul>\n<li>\n<p>当用于 <strong> <code>WHERE</code> </strong> 子句后边时，根据不同的运算符，子查询可以返回单行单列、多行单列、单行多列数据。子查询就是要<font color='red'>返回能够作为  <code>WHERE</code>  子句查询条件的值</font>。</p>\n<blockquote>\n<p>用于  <code>WHERE</code>  子句的子查询的基本语法如下：</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">select</span> column_name <span class=\"token punctuation\">[</span><span class=\"token punctuation\">,</span> column_name <span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">from</span>   table1 <span class=\"token punctuation\">[</span><span class=\"token punctuation\">,</span> table2 <span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">where</span>  column_name operator</pre></td></tr><tr><td data-num=\"4\"></td><td><pre> <span class=\"token punctuation\">(</span><span class=\"token keyword\">select</span> column_name <span class=\"token punctuation\">[</span><span class=\"token punctuation\">,</span> column_name <span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre> <span class=\"token keyword\">from</span> table1 <span class=\"token punctuation\">[</span><span class=\"token punctuation\">,</span> table2 <span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre> <span class=\"token punctuation\">[</span><span class=\"token keyword\">where</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><ul>\n<li>子查询需要放在括号 <code>( )</code>  内。</li>\n<li><code>operator</code>  表示用于 where 子句的运算符。</li>\n</ul>\n</blockquote>\n</li>\n<li>\n<p>当用于 <strong> <code>FROM</code> </strong> 子句后边时，一般返回多行多列数据，相当于<font color='red'>返回一张临时表</font>，这样才符合  <code>FROM</code>  后面是表的规则。这种做法能够实现<font color='red'>多表联合查询</font>。</p>\n<blockquote>\n<p>用于  <code>FROM</code>  子句的子查询的基本语法如下：</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">select</span> column_name <span class=\"token punctuation\">[</span><span class=\"token punctuation\">,</span> column_name <span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">from</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">select</span> column_name <span class=\"token punctuation\">[</span><span class=\"token punctuation\">,</span> column_name <span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>   <span class=\"token keyword\">from</span> table1 <span class=\"token punctuation\">[</span><span class=\"token punctuation\">,</span> table2 <span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>   <span class=\"token punctuation\">[</span><span class=\"token keyword\">where</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">as</span> temp_table_name</pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">where</span>  condition</pre></td></tr></table></figure><p>用于  <code>FROM</code>  的子查询返回的结果相当于一张临时表，所以<strong>需要使用  <code>AS</code>  关键字为该临时表起一个名字</strong>。</p>\n</blockquote>\n</li>\n</ul>\n<blockquote>\n<p>注意：MYSQL 数据库从 4.1 版本才开始支持子查询，早期版本是不支持的。</p>\n</blockquote>\n<p><strong>子查询的子查询</strong></p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">SELECT</span> cust_name<span class=\"token punctuation\">,</span> cust_contact</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">FROM</span> customers</pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">WHERE</span> cust_id <span class=\"token operator\">IN</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">SELECT</span> cust_id</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>                  <span class=\"token keyword\">FROM</span> orders</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>                  <span class=\"token keyword\">WHERE</span> order_num <span class=\"token operator\">IN</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">SELECT</span> order_num</pre></td></tr><tr><td data-num=\"6\"></td><td><pre>                                      <span class=\"token keyword\">FROM</span> orderitems</pre></td></tr><tr><td data-num=\"7\"></td><td><pre>                                      <span class=\"token keyword\">WHERE</span> prod_id <span class=\"token operator\">=</span> <span class=\"token string\">'RGAN01'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>内部查询首先在其父查询之前执行，以便可以将内部查询的结果传递给外部查询。执行过程可以参考下图：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/c439da1f5d4e4b00bdfa4316b933d764%7Etplv-k3u1fbpfcp-zoom-1.image\" alt=\"img\" /></p>\n<h5 id=\"where\"><a class=\"anchor\" href=\"#where\">#</a> WHERE</h5>\n<ul>\n<li><code>WHERE</code>  子句用于过滤记录，即缩小访问数据的范围。</li>\n<li><code>WHERE</code>  后跟一个返回  <code>true</code>  或  <code>false</code>  的条件。</li>\n<li><code>WHERE</code>  可以与  <code>SELECT</code> ， <code>UPDATE</code>  和  <code>DELETE</code>  一起使用。</li>\n<li>可以在  <code>WHERE</code>  子句中使用的操作符。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>运算符</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>=</td>\n<td>等于</td>\n</tr>\n<tr>\n<td>&lt;&gt;</td>\n<td>不等于。注释：在 SQL 的一些版本中，该操作符可被写成！=</td>\n</tr>\n<tr>\n<td>&gt;</td>\n<td>大于</td>\n</tr>\n<tr>\n<td>&lt;</td>\n<td>小于</td>\n</tr>\n<tr>\n<td>&gt;=</td>\n<td>大于等于</td>\n</tr>\n<tr>\n<td>&lt;=</td>\n<td>小于等于</td>\n</tr>\n<tr>\n<td>BETWEEN</td>\n<td>在某个范围内</td>\n</tr>\n<tr>\n<td>LIKE</td>\n<td>搜索某种模式</td>\n</tr>\n<tr>\n<td>IN</td>\n<td>指定针对某个列的多个可能值</td>\n</tr>\n</tbody>\n</table>\n<p><strong> <code>SELECT</code>  语句中的  <code>WHERE</code>  子句</strong></p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> Customers</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">WHERE</span> cust_name <span class=\"token operator\">=</span> <span class=\"token string\">'Kids Place'</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p><strong> <code>UPDATE</code>  语句中的  <code>WHERE</code>  子句</strong></p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">UPDATE</span> Customers</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">SET</span> cust_name <span class=\"token operator\">=</span> <span class=\"token string\">'Jack Jones'</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">WHERE</span> cust_name <span class=\"token operator\">=</span> <span class=\"token string\">'Kids Place'</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p><strong> <code>DELETE</code>  语句中的  <code>WHERE</code>  子句</strong></p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">DELETE</span> <span class=\"token keyword\">FROM</span> Customers</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">WHERE</span> cust_name <span class=\"token operator\">=</span> <span class=\"token string\">'Kids Place'</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h5 id=\"in-和-between\"><a class=\"anchor\" href=\"#in-和-between\">#</a> IN 和 BETWEEN</h5>\n<ul>\n<li><code>IN</code>  操作符在  <code>WHERE</code>  子句中使用，作用是<font color='red'>在指定的几个特定值中任选一个值</font>。</li>\n<li><code>BETWEEN</code>  操作符在  <code>WHERE</code>  子句中使用，作用是<font color='red'>选取介于某个范围内的值</font>。</li>\n</ul>\n<p><strong>IN 示例</strong></p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">FROM</span> products</pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">WHERE</span> vend_id <span class=\"token operator\">IN</span> <span class=\"token punctuation\">(</span><span class=\"token string\">'DLL01'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'BRS01'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p><strong>BETWEEN 示例</strong></p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">FROM</span> products</pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">WHERE</span> prod_price <span class=\"token operator\">BETWEEN</span> <span class=\"token number\">3</span> <span class=\"token operator\">AND</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h5 id=\"and-or-not\"><a class=\"anchor\" href=\"#and-or-not\">#</a> AND、OR、NOT</h5>\n<ul>\n<li><code>AND</code> 、 <code>OR</code> 、 <code>NOT</code>  是用于对过滤条件的逻辑处理指令。</li>\n<li><font color='red'> <code>AND</code>  优先级高于  <code>OR</code> </font>，为了明确处理顺序，可以使用  <code>()</code> 。</li>\n<li><code>AND</code>  操作符表示左右条件都要满足。</li>\n<li><code>OR</code>  操作符表示左右条件满足任意一个即可。</li>\n<li><code>NOT</code>  操作符用于否定一个条件。</li>\n</ul>\n<p><strong>AND 示例</strong></p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">SELECT</span> prod_id<span class=\"token punctuation\">,</span> prod_name<span class=\"token punctuation\">,</span> prod_price</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">FROM</span> products</pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">WHERE</span> vend_id <span class=\"token operator\">=</span> <span class=\"token string\">'DLL01'</span> <span class=\"token operator\">AND</span> prod_price <span class=\"token operator\">&lt;=</span> <span class=\"token number\">4</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p><strong>OR 示例</strong></p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">SELECT</span> prod_id<span class=\"token punctuation\">,</span> prod_name<span class=\"token punctuation\">,</span> prod_price</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">FROM</span> products</pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">WHERE</span> vend_id <span class=\"token operator\">=</span> <span class=\"token string\">'DLL01'</span> <span class=\"token operator\">OR</span> vend_id <span class=\"token operator\">=</span> <span class=\"token string\">'BRS01'</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p><strong>NOT 示例</strong></p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">FROM</span> products</pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">WHERE</span> prod_price <span class=\"token operator\">NOT</span> <span class=\"token operator\">BETWEEN</span> <span class=\"token number\">3</span> <span class=\"token operator\">AND</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h5 id=\"like\"><a class=\"anchor\" href=\"#like\">#</a> LIKE</h5>\n<ul>\n<li><code>LIKE</code>  操作符在  <code>WHERE</code>  子句中使用，作用是<font color='red'>确定字符串是否匹配模式</font>。</li>\n<li>只有字段是文本值时才使用  <code>LIKE</code> 。</li>\n<li><code>LIKE</code>  支持两个通配符匹配选项： <code>%</code>  和  <code>_</code> 。</li>\n<li>不要滥用通配符，通配符位于开头处匹配会非常慢。</li>\n<li><code>%</code>  表示任何字符<font color='red'>出现任意次数</font>。</li>\n<li><code>_</code>  表示任何字符<font color='red'>出现一次</font>。</li>\n</ul>\n<p><strong>% 示例</strong></p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">SELECT</span> prod_id<span class=\"token punctuation\">,</span> prod_name<span class=\"token punctuation\">,</span> prod_price</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">FROM</span> products</pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">WHERE</span> prod_name <span class=\"token operator\">LIKE</span> <span class=\"token string\">'%bean bag%'</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p><strong>_ 示例</strong></p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">SELECT</span> prod_id<span class=\"token punctuation\">,</span> prod_name<span class=\"token punctuation\">,</span> prod_price</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">FROM</span> products</pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">WHERE</span> prod_name <span class=\"token operator\">LIKE</span> <span class=\"token string\">'__ inch teddy bear'</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h4 id=\"连接\"><a class=\"anchor\" href=\"#连接\">#</a> 连接</h4>\n<h5 id=\"简介-2\"><a class=\"anchor\" href=\"#简介-2\">#</a> 简介</h5>\n<p><code>JOIN</code>  是 “连接” 的意思，顾名思义，SQL JOIN 子句用于将两个或者多个表联合起来进行查询。</p>\n<p>连接表时<font color='red'>需要在每个表中选择一个字段，并对这些字段的值进行比较，值相同的两条记录将合并为一条</font>。<strong>连接表的本质就是将不同表的记录合并起来，形成一张新表。当然，这张新表只是临时的，它仅存在于本次查询期间</strong>。</p>\n<h5 id=\"语法-2\"><a class=\"anchor\" href=\"#语法-2\">#</a> 语法</h5>\n<p>使用  <code>JOIN</code>  连接两个表的基本语法如下：</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">select</span> table1<span class=\"token punctuation\">.</span>column1<span class=\"token punctuation\">,</span> table2<span class=\"token punctuation\">.</span>column2<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">from</span> table1 <span class=\"token keyword\">join</span> table2</pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">on</span> table1<span class=\"token punctuation\">.</span>common_column1 <span class=\"token operator\">=</span> table2<span class=\"token punctuation\">.</span>common_column2<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p><code>table1.common_column1 = table2.common_column2</code>  是<font color='red'>连接条件</font>，只有满足此条件的记录才会合并为一行。您可以使用多个运算符来连接表，例如 =、&gt;、&lt;、&lt;&gt;、&lt;=、&gt;=、!=、 <code>between</code> 、 <code>like</code>  或者  <code>not</code> ，但是最常见的是使用 =。</p>\n<p><font color='red'>当两个表中有同名的字段时，为了帮助数据库引擎区分是哪个表的字段，在书写同名字段名时需要加上表名</font>。当然，如果书写的字段名在两个表中是唯一的，也可以不使用以上格式，只写字段名即可。</p>\n<p>另外，<font color='red'>如果两张表的关联字段名相同，也可以使用  <code>USING</code>  子句来代替  <code>ON</code> </font>，举个例子：</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># join....on</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">select</span> c<span class=\"token punctuation\">.</span>cust_name<span class=\"token punctuation\">,</span> o<span class=\"token punctuation\">.</span>order_num</pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">from</span> Customers c <span class=\"token keyword\">inner</span> <span class=\"token keyword\">join</span> Orders o</pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">on</span> c<span class=\"token punctuation\">.</span>cust_id <span class=\"token operator\">=</span> o<span class=\"token punctuation\">.</span>cust_id</pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">order</span> <span class=\"token keyword\">by</span> c<span class=\"token punctuation\">.</span>cust_name<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token comment\"># 如果两张表的关联字段名相同，也可以使用 USING 子句：join....using ()</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token keyword\">select</span> c<span class=\"token punctuation\">.</span>cust_name<span class=\"token punctuation\">,</span> o<span class=\"token punctuation\">.</span>order_num</pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token keyword\">from</span> Customers c <span class=\"token keyword\">inner</span> <span class=\"token keyword\">join</span> Orders o</pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token keyword\">using</span><span class=\"token punctuation\">(</span>cust_id<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token keyword\">order</span> <span class=\"token keyword\">by</span> c<span class=\"token punctuation\">.</span>cust_name<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p><strong> <code>ON</code>  和  <code>WHERE</code>  的区别</strong>：</p>\n<ul>\n<li>连接表时，SQL 会根据连接条件生成一张新的临时表。<font color='red'> <code>ON</code>  是连接条件</font>，它决定临时表的生成。</li>\n<li><code>WHERE</code>  是在临时表生成以后，再对临时表中的数据进行过滤，生成最终的结果集，这个时候已经没有 JOIN-ON 了。</li>\n</ul>\n<p>所以总结来说就是：<strong><font color='#B32015'>SQL 先根据 ON 生成一张临时表，然后再根据 WHERE 对临时表进行筛选</font></strong>。</p>\n<h5 id=\"分类-2\"><a class=\"anchor\" href=\"#分类-2\">#</a> 分类</h5>\n<p>SQL 允许在  <code>JOIN</code>  左边加上一些修饰性的关键词，从而形成不同类型的连接，如下表所示：</p>\n<table>\n<thead>\n<tr>\n<th>连接类型</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>(INNER) JOIN</code> ：内连接</td>\n<td>（<strong>默认连接方式</strong>）只有当<font color='red'>两个表都存在满足条件</font>的记录时才会返回行。</td>\n</tr>\n<tr>\n<td><code>LEFT (OUTER) JOIN</code> ：左 (外) 连接</td>\n<td>以左表为基础，将左表中的所有记录与右表进行连接。即使右表中没有与左表匹配的记录，左连接仍然会 **<font color='red'>返回左表中的所有记录，而右表中未匹配的对应列值则为 NULL</font>**.</td>\n</tr>\n<tr>\n<td><code>RIGHT (OUTER) JOIN</code> ：右 (外) 连接</td>\n<td>以右表为基础，将右表中的所有记录与左表进行连接。即使左表中没有与右表匹配的记录，右连接仍然会 **<font color='red'>返回右表中的所有记录，而左表中未匹配的对应列值则为 NULL</font>**。</td>\n</tr>\n<tr>\n<td><code>FULL (OUTER) JOIN</code> ：全 (外) 连接</td>\n<td>只要<font color='red'>其中有一个表存在满足条件</font>的记录，就返回行。</td>\n</tr>\n<tr>\n<td><code>SELF JOIN</code> ：自连接</td>\n<td><font color='red'>将一个表连接到自身</font>，就像该表是两个表一样。为了区分两个表，在 SQL 语句中需要至少重命名一个表。</td>\n</tr>\n<tr>\n<td><code>CROSS JOIN</code> ：交叉连接</td>\n<td>从两个或者多个连接表中返回记录集的<font color='red'>笛卡尔积</font>。</td>\n</tr>\n</tbody>\n</table>\n<p>下图展示了 LEFT JOIN、RIGHT JOIN、INNER JOIN、OUTER JOIN 相关的 7 种用法。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/701670942f0f45d3a3a2187cd04a12ad~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"\" /></p>\n<p>对于  <code>(INNER) JOIN</code>  来说，还有一种隐式的写法，称为 “<strong>隐式内连接</strong>”，也就是没有  <code>(INNER) JOIN</code>  关键字，使用  <code>WHERE</code>  语句实现内连接的功能</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># 隐式内连接</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">select</span> c<span class=\"token punctuation\">.</span>cust_name<span class=\"token punctuation\">,</span> o<span class=\"token punctuation\">.</span>order_num</pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">from</span> Customers c<span class=\"token punctuation\">,</span> Orders o</pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">where</span> c<span class=\"token punctuation\">.</span>cust_id <span class=\"token operator\">=</span> o<span class=\"token punctuation\">.</span>cust_id</pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">order</span> <span class=\"token keyword\">by</span> c<span class=\"token punctuation\">.</span>cust_name<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token comment\"># 显式内连接</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token keyword\">select</span> c<span class=\"token punctuation\">.</span>cust_name<span class=\"token punctuation\">,</span> o<span class=\"token punctuation\">.</span>order_num</pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token keyword\">from</span> Customers c <span class=\"token keyword\">inner</span> <span class=\"token keyword\">join</span> Orders o</pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token keyword\">using</span><span class=\"token punctuation\">(</span>cust_id<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token keyword\">order</span> <span class=\"token keyword\">by</span> c<span class=\"token punctuation\">.</span>cust_name<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h4 id=\"组合\"><a class=\"anchor\" href=\"#组合\">#</a> 组合</h4>\n<p><code>UNION</code>  运算符<font color='red'>将两个或更多查询的结果组合起来，并生成一个结果集</font>，其中包含来自  <code>UNION</code>  中参与查询的提取行。</p>\n<p><code>UNION</code>  基本规则：</p>\n<ul>\n<li>所有查询的<font color='red'>列数和列顺序必须相同</font>。</li>\n<li>每个查询中涉及表的<font color='red'>列的数据类型必须相同或兼容</font>。</li>\n<li>通常<font color='red'>返回的列名取自第一个查询</font>。</li>\n</ul>\n<p>默认地， <code>UNION</code>  操作符选取不同的值。如果允许重复的值，请使用  <code>UNION ALL</code> 。</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">SELECT</span> column_name<span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span> <span class=\"token keyword\">FROM</span> table1</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">UNION</span> <span class=\"token keyword\">ALL</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">SELECT</span> column_name<span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span> <span class=\"token keyword\">FROM</span> table2<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p><code>UNION</code>  结果集中的列名总是等于  <code>UNION</code>  中第一个  <code>SELECT</code>  语句中的列名。</p>\n<p><code>JOIN</code>  vs  <code>UNION</code> ：</p>\n<ul>\n<li><code>JOIN</code>  中连接表的列可能不同，但在  <code>UNION</code>  中，所有查询的列数和列顺序必须相同。</li>\n<li><code>UNION</code>  将查询之后的行放在一起（<font color='red'>垂直放置</font>），但  <code>JOIN</code>  将查询之后的列放在一起（水平放置），即它构成一个笛卡尔积。</li>\n</ul>\n<h4 id=\"函数\"><a class=\"anchor\" href=\"#函数\">#</a> 函数</h4>\n<p>不同数据库的函数往往各不相同，因此不可移植。本节主要<font color='red'>以 MysSQL 的函数为例</font>。</p>\n<h5 id=\"文本处理\"><a class=\"anchor\" href=\"#文本处理\">#</a> 文本处理</h5>\n<table>\n<thead>\n<tr>\n<th>函数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>LEFT()</code> 、 <code>RIGHT()</code></td>\n<td>左边或者右边的字符</td>\n</tr>\n<tr>\n<td><code>LOWER()</code> 、 <code>UPPER()</code></td>\n<td>转换为小写或者大写</td>\n</tr>\n<tr>\n<td><code>LTRIM()</code> 、 <code>RTRIM()</code></td>\n<td>去除左边或者右边的空格</td>\n</tr>\n<tr>\n<td><code>LENGTH()</code></td>\n<td>长度</td>\n</tr>\n<tr>\n<td><code>SOUNDEX()</code></td>\n<td><font color='red'>转换为语音值</font></td>\n</tr>\n</tbody>\n</table>\n<p>其中， <strong> <code>SOUNDEX()</code> </strong> 可以将一个字符串转换为描述其语音表示的字母数字模式。</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">FROM</span> mytable</pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">WHERE</span> SOUNDEX<span class=\"token punctuation\">(</span>col1<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> SOUNDEX<span class=\"token punctuation\">(</span><span class=\"token string\">'apple'</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><h5 id=\"日期和时间处理\"><a class=\"anchor\" href=\"#日期和时间处理\">#</a> 日期和时间处理</h5>\n<ul>\n<li>日期格式： <code>YYYY-MM-DD</code></li>\n<li>时间格式： <code>HH:MM:SS</code></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>函 数</th>\n<th>说 明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>AddDate()</code></td>\n<td>增加一个日期（天、周等）</td>\n</tr>\n<tr>\n<td><code>AddTime()</code></td>\n<td>增加一个时间（时、分等）</td>\n</tr>\n<tr>\n<td><code>CurDate()</code></td>\n<td>返回当前日期</td>\n</tr>\n<tr>\n<td><code>CurTime()</code></td>\n<td>返回当前时间</td>\n</tr>\n<tr>\n<td><code>Date()</code></td>\n<td>返回日期时间的日期部分</td>\n</tr>\n<tr>\n<td><code>DateDiff()</code></td>\n<td>计算两个日期之差</td>\n</tr>\n<tr>\n<td><code>Date_Add()</code></td>\n<td>高度灵活的日期运算函数</td>\n</tr>\n<tr>\n<td><code>Date_Format()</code></td>\n<td>返回一个格式化的日期或时间串</td>\n</tr>\n<tr>\n<td><code>Day()</code></td>\n<td>返回一个日期的天数部分</td>\n</tr>\n<tr>\n<td><code>DayOfWeek()</code></td>\n<td>对于一个日期，返回对应的星期几</td>\n</tr>\n<tr>\n<td><code>Hour()</code></td>\n<td>返回一个时间的小时部分</td>\n</tr>\n<tr>\n<td><code>Minute()</code></td>\n<td>返回一个时间的分钟部分</td>\n</tr>\n<tr>\n<td><code>Month()</code></td>\n<td>返回一个日期的月份部分</td>\n</tr>\n<tr>\n<td><code>Now()</code></td>\n<td>返回当前日期和时间</td>\n</tr>\n<tr>\n<td><code>Second()</code></td>\n<td>返回一个时间的秒部分</td>\n</tr>\n<tr>\n<td><code>Time()</code></td>\n<td>返回一个日期时间的时间部分</td>\n</tr>\n<tr>\n<td><code>Year()</code></td>\n<td>返回一个日期的年份部分</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"数值处理\"><a class=\"anchor\" href=\"#数值处理\">#</a> 数值处理</h5>\n<table>\n<thead>\n<tr>\n<th>函数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>SIN()</td>\n<td>正弦</td>\n</tr>\n<tr>\n<td>COS()</td>\n<td>余弦</td>\n</tr>\n<tr>\n<td>TAN()</td>\n<td>正切</td>\n</tr>\n<tr>\n<td>ABS()</td>\n<td>绝对值</td>\n</tr>\n<tr>\n<td>SQRT()</td>\n<td>平方根</td>\n</tr>\n<tr>\n<td>MOD()</td>\n<td>余数</td>\n</tr>\n<tr>\n<td>EXP()</td>\n<td>指数</td>\n</tr>\n<tr>\n<td>PI()</td>\n<td>圆周率</td>\n</tr>\n<tr>\n<td>RAND()</td>\n<td>随机数</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"汇总\"><a class=\"anchor\" href=\"#汇总\">#</a> 汇总</h5>\n<table>\n<thead>\n<tr>\n<th>函 数</th>\n<th>说 明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>AVG()</code></td>\n<td>返回某列的平均值</td>\n</tr>\n<tr>\n<td><code>COUNT()</code></td>\n<td>返回某列的行数</td>\n</tr>\n<tr>\n<td><code>MAX()</code></td>\n<td>返回某列的最大值</td>\n</tr>\n<tr>\n<td><code>MIN()</code></td>\n<td>返回某列的最小值</td>\n</tr>\n<tr>\n<td><code>SUM()</code></td>\n<td>返回某列值之和</td>\n</tr>\n</tbody>\n</table>\n<p><code>AVG()</code>  会忽略 NULL 行。</p>\n<p>使用  <code>DISTINCT</code>  可以让汇总函数值汇总不同的值。</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">SELECT</span> <span class=\"token function\">AVG</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">DISTINCT</span> col1<span class=\"token punctuation\">)</span> <span class=\"token keyword\">AS</span> avg_col</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">FROM</span> mytable</pre></td></tr></table></figure><p><strong>接下来，我们来介绍 DDL 语句用法。DDL 的主要功能是定义数据库对象（如：数据库、数据表、视图、索引等）</strong></p>\n<h4 id=\"数据定义\"><a class=\"anchor\" href=\"#数据定义\">#</a> <mark>数据定义</mark></h4>\n<h5 id=\"数据库database\"><a class=\"anchor\" href=\"#数据库database\">#</a> 数据库（DATABASE）</h5>\n<h6 id=\"创建数据库\"><a class=\"anchor\" href=\"#创建数据库\">#</a> 创建数据库</h6>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">DATABASE</span> test<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h6 id=\"删除数据库\"><a class=\"anchor\" href=\"#删除数据库\">#</a> 删除数据库</h6>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">DROP</span> <span class=\"token keyword\">DATABASE</span> test<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h6 id=\"选择数据库\"><a class=\"anchor\" href=\"#选择数据库\">#</a> 选择数据库</h6>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">USE</span> test<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h5 id=\"数据表table\"><a class=\"anchor\" href=\"#数据表table\">#</a> 数据表（TABLE）</h5>\n<h6 id=\"创建数据表\"><a class=\"anchor\" href=\"#创建数据表\">#</a> 创建数据表</h6>\n<p><strong>普通创建</strong></p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">TABLE</span> <span class=\"token keyword\">user</span> <span class=\"token punctuation\">(</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>  id <span class=\"token keyword\">int</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">unsigned</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span> <span class=\"token keyword\">COMMENT</span> <span class=\"token string\">'Id'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>  username <span class=\"token keyword\">varchar</span><span class=\"token punctuation\">(</span><span class=\"token number\">64</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span> <span class=\"token keyword\">DEFAULT</span> <span class=\"token string\">'default'</span> <span class=\"token keyword\">COMMENT</span> <span class=\"token string\">'用户名'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>  password <span class=\"token keyword\">varchar</span><span class=\"token punctuation\">(</span><span class=\"token number\">64</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span> <span class=\"token keyword\">DEFAULT</span> <span class=\"token string\">'default'</span> <span class=\"token keyword\">COMMENT</span> <span class=\"token string\">'密码'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>  email <span class=\"token keyword\">varchar</span><span class=\"token punctuation\">(</span><span class=\"token number\">64</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span> <span class=\"token keyword\">DEFAULT</span> <span class=\"token string\">'default'</span> <span class=\"token keyword\">COMMENT</span> <span class=\"token string\">'邮箱'</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token punctuation\">)</span> <span class=\"token keyword\">COMMENT</span><span class=\"token operator\">=</span><span class=\"token string\">'用户表'</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p><strong>根据已有的表创建新表</strong></p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">TABLE</span> vip_user <span class=\"token keyword\">AS</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> <span class=\"token keyword\">user</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h6 id=\"删除数据表\"><a class=\"anchor\" href=\"#删除数据表\">#</a> 删除数据表</h6>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">DROP</span> <span class=\"token keyword\">TABLE</span> <span class=\"token keyword\">user</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h6 id=\"修改数据表\"><a class=\"anchor\" href=\"#修改数据表\">#</a> 修改数据表</h6>\n<p><strong>添加列</strong></p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">ALTER</span> <span class=\"token keyword\">TABLE</span> <span class=\"token keyword\">user</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">ADD</span> age <span class=\"token keyword\">int</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p><strong>删除列</strong></p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">ALTER</span> <span class=\"token keyword\">TABLE</span> <span class=\"token keyword\">user</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">DROP</span> <span class=\"token keyword\">COLUMN</span> age<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p><strong>修改列</strong></p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">ALTER</span> <span class=\"token keyword\">TABLE</span> <span class=\"token identifier\"><span class=\"token punctuation\">`</span>user<span class=\"token punctuation\">`</span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">MODIFY</span> <span class=\"token keyword\">COLUMN</span> age <span class=\"token keyword\">tinyint</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p><strong>添加主键</strong></p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">ALTER</span> <span class=\"token keyword\">TABLE</span> <span class=\"token keyword\">user</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">ADD</span> <span class=\"token keyword\">PRIMARY</span> <span class=\"token keyword\">KEY</span> <span class=\"token punctuation\">(</span>id<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p><strong>删除主键</strong></p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">ALTER</span> <span class=\"token keyword\">TABLE</span> <span class=\"token keyword\">user</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">DROP</span> <span class=\"token keyword\">PRIMARY</span> <span class=\"token keyword\">KEY</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h5 id=\"视图view\"><a class=\"anchor\" href=\"#视图view\">#</a> 视图（VIEW）</h5>\n<p>定义：</p>\n<ul>\n<li>视图是基于 SQL 语句的结果集的可视化的表。</li>\n<li>视图是<strong>虚拟的表，本身不包含数据</strong>，也就不能对其进行索引操作。对视图的操作和对普通表的操作一样。</li>\n</ul>\n<p>作用：</p>\n<ul>\n<li>简化复杂的 SQL 操作，比如复杂的联结；</li>\n<li>只使用实际表的一部分数据；</li>\n<li><font color='red'>通过只给用户访问视图的权限，保证数据的安全性</font>；</li>\n<li>更改数据格式和表示。</li>\n</ul>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/ec4c975296ea4a7097879dac7c353878%7Etplv-k3u1fbpfcp-zoom-1.image\" alt=\"mysql视图\" /></p>\n<h6 id=\"创建视图\"><a class=\"anchor\" href=\"#创建视图\">#</a> 创建视图</h6>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">VIEW</span> top_10_user_view <span class=\"token keyword\">AS</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">SELECT</span> id<span class=\"token punctuation\">,</span> username</pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">FROM</span> <span class=\"token keyword\">user</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">WHERE</span> id <span class=\"token operator\">&lt;</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h6 id=\"删除视图\"><a class=\"anchor\" href=\"#删除视图\">#</a> 删除视图</h6>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">DROP</span> <span class=\"token keyword\">VIEW</span> top_10_user_view<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h5 id=\"索引index\"><a class=\"anchor\" href=\"#索引index\">#</a> 索引（INDEX）</h5>\n<p><strong>索引是一种用于快速查询和检索数据的数据结构，其本质可以看成是一种排序好的数据结构。</strong></p>\n<p>索引的作用就<font color='red'>相当于书的目录</font>。打个比方：我们在查字典的时候，如果没有目录，那我们就只能一页一页的去找我们需要查的那个字，速度很慢。如果有目录了，我们只需要先去目录里查找字的位置，然后直接翻到那一页就行了。</p>\n<p><strong>优点</strong> ：</p>\n<ul>\n<li>使用索引可以大大<font color='red'>加快数据的检索速度</font>（大大减少检索的数据量）, 这也是创建索引的最主要的原因。</li>\n<li>通过创建<font color='red'>唯一性索引，可以保证数据库表中每一行数据的唯一性</font>。</li>\n</ul>\n<p><strong>缺点</strong> ：</p>\n<ul>\n<li>创建索引和维护索引需要耗费许多时间。当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低 SQL 执行效率。</li>\n<li>索引需要使用物理文件存储，也会耗费一定空间。</li>\n</ul>\n<p>但是，<strong>使用索引一定能提高查询性能吗？</strong></p>\n<p>大多数情况下，索引查询都是比全表扫描要快的。但是<font color='red'>如果数据库的数据量不大，那么使用索引也不一定能够带来很大提升</font>。</p>\n<p>关于索引的详细介绍，请看我写的 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9qYXZhZ3VpZGUuY24vZGF0YWJhc2UvbXlzcWwvbXlzcWwtaW5kZXguaHRtbA==\">MySQL 索引详解 open in new window</span> 这篇文章。</p>\n<h6 id=\"创建索引\"><a class=\"anchor\" href=\"#创建索引\">#</a> 创建索引</h6>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">INDEX</span> user_index</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">ON</span> <span class=\"token keyword\">user</span> <span class=\"token punctuation\">(</span>id<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h6 id=\"添加索引\"><a class=\"anchor\" href=\"#添加索引\">#</a> 添加索引</h6>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">ALTER</span> <span class=\"token keyword\">table</span> <span class=\"token keyword\">user</span> <span class=\"token keyword\">ADD</span> <span class=\"token keyword\">INDEX</span> user_index<span class=\"token punctuation\">(</span>id<span class=\"token punctuation\">)</span></pre></td></tr></table></figure><h6 id=\"创建唯一索引\"><a class=\"anchor\" href=\"#创建唯一索引\">#</a> 创建唯一索引</h6>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">UNIQUE</span> <span class=\"token keyword\">INDEX</span> user_index</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">ON</span> <span class=\"token keyword\">user</span> <span class=\"token punctuation\">(</span>id<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h6 id=\"删除索引\"><a class=\"anchor\" href=\"#删除索引\">#</a> 删除索引</h6>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">ALTER</span> <span class=\"token keyword\">TABLE</span> <span class=\"token keyword\">user</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">DROP</span> <span class=\"token keyword\">INDEX</span> user_index<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h5 id=\"约束\"><a class=\"anchor\" href=\"#约束\">#</a> 约束</h5>\n<p>SQL 约束<strong>用于规定表中的数据规则</strong>。</p>\n<p>如果存在违反约束的数据行为，行为会被约束终止。</p>\n<p>约束可以在创建表时规定（通过 CREATE TABLE 语句），或者在表创建之后规定（通过 ALTER TABLE 语句）。</p>\n<p>约束类型：</p>\n<ul>\n<li><code>NOT NULL</code>  - 指示某列不能存储 NULL 值。</li>\n<li><code>UNIQUE</code>  - 保证某列的每行必须有唯一的值。</li>\n<li><code>PRIMARY KEY</code>  - NOT NULL 和 UNIQUE 的结合。确保某列（或两个列多个列的结合）有唯一标识，有助于更容易更快速地找到表中的一个特定的记录。</li>\n<li><code>FOREIGN KEY</code>  - 保证一个表中的数据匹配另一个表中的值的参照完整性。</li>\n<li><code>CHECK</code>  - 保证列中的值符合指定的条件。</li>\n<li><code>DEFAULT</code>  - 规定没有给列赋值时的默认值。</li>\n</ul>\n<p>创建表时使用约束条件：</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">TABLE</span> Users <span class=\"token punctuation\">(</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>  Id <span class=\"token keyword\">INT</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">UNSIGNED</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span> <span class=\"token keyword\">AUTO_INCREMENT</span> <span class=\"token keyword\">COMMENT</span> <span class=\"token string\">'自增Id'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>  Username <span class=\"token keyword\">VARCHAR</span><span class=\"token punctuation\">(</span><span class=\"token number\">64</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span> <span class=\"token keyword\">UNIQUE</span> <span class=\"token keyword\">DEFAULT</span> <span class=\"token string\">'default'</span> <span class=\"token keyword\">COMMENT</span> <span class=\"token string\">'用户名'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>  Password <span class=\"token keyword\">VARCHAR</span><span class=\"token punctuation\">(</span><span class=\"token number\">64</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span> <span class=\"token keyword\">DEFAULT</span> <span class=\"token string\">'default'</span> <span class=\"token keyword\">COMMENT</span> <span class=\"token string\">'密码'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>  Email <span class=\"token keyword\">VARCHAR</span><span class=\"token punctuation\">(</span><span class=\"token number\">64</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span> <span class=\"token keyword\">DEFAULT</span> <span class=\"token string\">'default'</span> <span class=\"token keyword\">COMMENT</span> <span class=\"token string\">'邮箱地址'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>  Enabled <span class=\"token keyword\">TINYINT</span><span class=\"token punctuation\">(</span><span class=\"token number\">4</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">DEFAULT</span> <span class=\"token boolean\">NULL</span> <span class=\"token keyword\">COMMENT</span> <span class=\"token string\">'是否有效'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>  <span class=\"token keyword\">PRIMARY</span> <span class=\"token keyword\">KEY</span> <span class=\"token punctuation\">(</span>Id<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token punctuation\">)</span> <span class=\"token keyword\">ENGINE</span><span class=\"token operator\">=</span><span class=\"token keyword\">InnoDB</span> <span class=\"token keyword\">AUTO_INCREMENT</span><span class=\"token operator\">=</span><span class=\"token number\">2</span> <span class=\"token keyword\">DEFAULT</span> <span class=\"token keyword\">CHARSET</span><span class=\"token operator\">=</span>utf8mb4 <span class=\"token keyword\">COMMENT</span><span class=\"token operator\">=</span><span class=\"token string\">'用户表'</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p><strong>接下来，我们来介绍 TCL 语句用法。TCL 的主要功能是管理数据库中的事务。</strong></p>\n<h4 id=\"事务处理\"><a class=\"anchor\" href=\"#事务处理\">#</a> 事务处理</h4>\n<p>不能回退  <code>SELECT</code>  语句，回退  <code>SELECT</code>  语句也没意义；也不能回退  <code>CREATE</code>  和  <code>DROP</code>  语句。</p>\n<p><strong>MySQL 默认是隐式提交</strong>，每执行一条语句就把这条语句当成一个事务然后进行提交。当出现  <code>START TRANSACTION</code>  语句时，会关闭隐式提交；当  <code>COMMIT</code>  或  <code>ROLLBACK</code>  语句执行后，事务会自动关闭，重新恢复隐式提交。</p>\n<p>通过  <code>set autocommit=0</code>  可以取消自动提交，直到  <code>set autocommit=1</code>  才会提交；<font color='red'> <code>autocommit</code>  标记是针对每个连接而不是针对服务器的</font>。</p>\n<p>指令：</p>\n<ul>\n<li><code>START TRANSACTION</code>  - 指令用于<font color='red'>标记事务的起始点</font>。</li>\n<li><code>SAVEPOINT</code>  - 指令用于<font color='red'>创建保留点</font>。</li>\n<li><code>ROLLBACK TO</code>  - 指令用于<font color='red'>回滚到指定的保留点</font>；如果没有设置保留点，则回退到  <code>START TRANSACTION</code>  语句处。</li>\n<li><code>COMMIT</code>  - <font color='red'>提交事务</font>。</li>\n</ul>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">-- 开始事务</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">START</span> <span class=\"token keyword\">TRANSACTION</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token comment\">-- 插入操作 A</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">INSERT</span> <span class=\"token keyword\">INTO</span> <span class=\"token identifier\"><span class=\"token punctuation\">`</span>user<span class=\"token punctuation\">`</span></span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token keyword\">VALUES</span> <span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'root1'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'root1'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'xxxx@163.com'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token comment\">-- 创建保留点 updateA</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token keyword\">SAVEPOINT</span> updateA<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token comment\">-- 插入操作 B</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token keyword\">INSERT</span> <span class=\"token keyword\">INTO</span> <span class=\"token identifier\"><span class=\"token punctuation\">`</span>user<span class=\"token punctuation\">`</span></span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token keyword\">VALUES</span> <span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'root2'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'root2'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'xxxx@163.com'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre></pre></td></tr><tr><td data-num=\"15\"></td><td><pre><span class=\"token comment\">-- 回滚到保留点 updateA</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre><span class=\"token keyword\">ROLLBACK</span> <span class=\"token keyword\">TO</span> updateA<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre></pre></td></tr><tr><td data-num=\"18\"></td><td><pre><span class=\"token comment\">-- 提交事务，只有操作 A 生效</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre><span class=\"token keyword\">COMMIT</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p><strong>接下来，我们来介绍 DCL 语句用法。DCL 的主要功能是控制用户的访问权限。</strong></p>\n<h4 id=\"权限控制\"><a class=\"anchor\" href=\"#权限控制\">#</a> 权限控制</h4>\n<p>要授予用户帐户权限，可以用 <code>GRANT</code>  命令。有撤销用户的权限，可以用 <code>REVOKE</code>  命令。这里以 MySQl 为例，介绍权限控制实际应用。</p>\n<p><code>GRANT</code>  授予权限语法：</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">GRANT</span> privilege<span class=\"token punctuation\">,</span><span class=\"token punctuation\">[</span>privilege<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> <span class=\"token keyword\">ON</span> privilege_level</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">TO</span> <span class=\"token keyword\">user</span> <span class=\"token punctuation\">[</span>IDENTIFIED <span class=\"token keyword\">BY</span> password<span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">[</span><span class=\"token keyword\">REQUIRE</span> tsl_option<span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token punctuation\">[</span><span class=\"token keyword\">WITH</span> <span class=\"token punctuation\">[</span>GRANT_OPTION <span class=\"token operator\">|</span> resource_option<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>简单解释一下：</p>\n<ol>\n<li>在 <code>GRANT</code>  关键字后指定一个或多个权限。如果授予用户多个权限，则每个权限由逗号分隔。</li>\n<li><code>ON privilege_level</code>  确定权限应用级别。MySQL 支持 global（ <code>*.*</code> ），database（ <code>database.*</code> ），table（ <code>database.table</code> ）和列级别。如果使用列权限级别，则必须在每个权限之后指定一个或逗号分隔列的列表。</li>\n<li><code>user</code>  是要授予权限的用户。如果用户已存在，则 <code>GRANT</code>  语句将修改其权限。否则， <code>GRANT</code>  语句将创建一个新用户。可选子句 <code>IDENTIFIED BY</code>  允许您为用户设置新的密码。</li>\n<li><code>REQUIRE tsl_option</code>  指定用户是否必须通过 SSL，X059 等安全连接连接到数据库服务器。</li>\n<li>可选  <code>WITH GRANT OPTION</code>  子句允许您授予其他用户或从其他用户中删除您拥有的权限。此外，您可以使用 <code>WITH</code>  子句分配 MySQL 数据库服务器的资源，例如，设置用户每小时可以使用的连接数或语句数。这在 MySQL 共享托管等共享环境中非常有用。</li>\n</ol>\n<p><code>REVOKE</code>  撤销权限语法：</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">REVOKE</span>   privilege_type <span class=\"token punctuation\">[</span><span class=\"token punctuation\">(</span>column_list<span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>        <span class=\"token punctuation\">[</span><span class=\"token punctuation\">,</span> priv_type <span class=\"token punctuation\">[</span><span class=\"token punctuation\">(</span>column_list<span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">ON</span> <span class=\"token punctuation\">[</span>object_type<span class=\"token punctuation\">]</span> privilege_level</pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">FROM</span> <span class=\"token keyword\">user</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">user</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr></table></figure><p>简单解释一下：</p>\n<ol>\n<li>在  <code>REVOKE</code>  关键字后面指定要从用户撤消的权限列表。您需要用逗号分隔权限。</li>\n<li>指定在  <code>ON</code>  子句中撤销特权的特权级别。</li>\n<li>指定要撤消  <code>FROM</code>  子句中的权限的用户帐户。</li>\n</ol>\n<p><code>GRANT</code>  和  <code>REVOKE</code>  可在几个层次上控制访问权限：</p>\n<ul>\n<li>整个服务器，使用  <code>GRANT ALL</code>  和  <code>REVOKE ALL</code> ；</li>\n<li>整个数据库，使用  <code>ON database.*</code> ；</li>\n<li>特定的表，使用  <code>ON database.table</code> ；</li>\n<li>特定的列；</li>\n<li>特定的存储过程。</li>\n</ul>\n<p>新创建的账户没有任何权限。账户用  <code>username@host</code>  的形式定义， <code>username@%</code>  使用的是默认主机名。MySQL 的账户信息保存在 mysql 这个数据库中。</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">USE</span> mysql<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">SELECT</span> <span class=\"token keyword\">user</span> <span class=\"token keyword\">FROM</span> <span class=\"token keyword\">user</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>下表说明了可用于 <code>GRANT</code>  和 <code>REVOKE</code>  语句的所有允许权限：</p>\n<table>\n<thead>\n<tr>\n<th><strong>特权</strong></th>\n<th><strong>说明</strong></th>\n<th><strong>级别</strong></th>\n<th></th>\n<th></th>\n<th></th>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>全局</strong></td>\n<td>数据库</td>\n<td><strong>表</strong></td>\n<td><strong>列</strong></td>\n<td><strong>程序</strong></td>\n<td><strong>代理</strong></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>ALL [PRIVILEGES]</td>\n<td>授予除 GRANT OPTION 之外的指定访问级别的所有权限</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>ALTER</td>\n<td>允许用户使用 ALTER TABLE 语句</td>\n<td>X</td>\n<td>X</td>\n<td>X</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>ALTER ROUTINE</td>\n<td>允许用户更改或删除存储的例程</td>\n<td>X</td>\n<td>X</td>\n<td></td>\n<td></td>\n<td>X</td>\n<td></td>\n</tr>\n<tr>\n<td>CREATE</td>\n<td>允许用户创建数据库和表</td>\n<td>X</td>\n<td>X</td>\n<td>X</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>CREATE ROUTINE</td>\n<td>允许用户创建存储的例程</td>\n<td>X</td>\n<td>X</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>CREATE TABLESPACE</td>\n<td>允许用户创建，更改或删除表空间和日志文件组</td>\n<td>X</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>CREATE TEMPORARY TABLES</td>\n<td>允许用户使用 CREATE TEMPORARY TABLE 创建临时表</td>\n<td>X</td>\n<td>X</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>CREATE USER</td>\n<td>允许用户使用 CREATE USER，DROP USER，RENAME USER 和 REVOKE ALL PRIVILEGES 语句。</td>\n<td>X</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>CREATE VIEW</td>\n<td>允许用户创建或修改视图。</td>\n<td>X</td>\n<td>X</td>\n<td>X</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>DELETE</td>\n<td>允许用户使用 DELETE</td>\n<td>X</td>\n<td>X</td>\n<td>X</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>DROP</td>\n<td>允许用户删除数据库，表和视图</td>\n<td>X</td>\n<td>X</td>\n<td>X</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>EVENT</td>\n<td>启用事件计划程序的事件使用。</td>\n<td>X</td>\n<td>X</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>EXECUTE</td>\n<td>允许用户执行存储的例程</td>\n<td>X</td>\n<td>X</td>\n<td>X</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>FILE</td>\n<td>允许用户读取数据库目录中的任何文件。</td>\n<td>X</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>GRANT OPTION</td>\n<td>允许用户拥有授予或撤消其他帐户权限的权限。</td>\n<td>X</td>\n<td>X</td>\n<td>X</td>\n<td></td>\n<td>X</td>\n<td>X</td>\n</tr>\n<tr>\n<td>INDEX</td>\n<td>允许用户创建或删除索引。</td>\n<td>X</td>\n<td>X</td>\n<td>X</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>INSERT</td>\n<td>允许用户使用 INSERT 语句</td>\n<td>X</td>\n<td>X</td>\n<td>X</td>\n<td>X</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>LOCK TABLES</td>\n<td>允许用户对具有 SELECT 权限的表使用 LOCK TABLES</td>\n<td>X</td>\n<td>X</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>PROCESS</td>\n<td>允许用户使用 SHOW PROCESSLIST 语句查看所有进程。</td>\n<td>X</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>PROXY</td>\n<td>启用用户代理。</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>REFERENCES</td>\n<td>允许用户创建外键</td>\n<td>X</td>\n<td>X</td>\n<td>X</td>\n<td>X</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>RELOAD</td>\n<td>允许用户使用 FLUSH 操作</td>\n<td>X</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>REPLICATION CLIENT</td>\n<td>允许用户查询以查看主服务器或从属服务器的位置</td>\n<td>X</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>REPLICATION SLAVE</td>\n<td>允许用户使用复制从属从主服务器读取二进制日志事件。</td>\n<td>X</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>SELECT</td>\n<td>允许用户使用 SELECT 语句</td>\n<td>X</td>\n<td>X</td>\n<td>X</td>\n<td>X</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>SHOW DATABASES</td>\n<td>允许用户显示所有数据库</td>\n<td>X</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>SHOW VIEW</td>\n<td>允许用户使用 SHOW CREATE VIEW 语句</td>\n<td>X</td>\n<td>X</td>\n<td>X</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>SHUTDOWN</td>\n<td>允许用户使用 mysqladmin shutdown 命令</td>\n<td>X</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>SUPER</td>\n<td>允许用户使用其他管理操作，例如 CHANGE MASTER TO，KILL，PURGE BINARY LOGS，SET GLOBAL 和 mysqladmin 命令</td>\n<td>X</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>TRIGGER</td>\n<td>允许用户使用 TRIGGER 操作。</td>\n<td>X</td>\n<td>X</td>\n<td>X</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>UPDATE</td>\n<td>允许用户使用 UPDATE 语句</td>\n<td>X</td>\n<td>X</td>\n<td>X</td>\n<td>X</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>USAGE</td>\n<td>相当于 “没有特权”</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"创建账户\"><a class=\"anchor\" href=\"#创建账户\">#</a> 创建账户</h5>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">USER</span> myuser IDENTIFIED <span class=\"token keyword\">BY</span> <span class=\"token string\">'mypassword'</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h5 id=\"修改账户名\"><a class=\"anchor\" href=\"#修改账户名\">#</a> 修改账户名</h5>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">UPDATE</span> <span class=\"token keyword\">user</span> <span class=\"token keyword\">SET</span> <span class=\"token keyword\">user</span><span class=\"token operator\">=</span><span class=\"token string\">'newuser'</span> <span class=\"token keyword\">WHERE</span> <span class=\"token keyword\">user</span><span class=\"token operator\">=</span><span class=\"token string\">'myuser'</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>FLUSH <span class=\"token keyword\">PRIVILEGES</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h5 id=\"删除账户\"><a class=\"anchor\" href=\"#删除账户\">#</a> 删除账户</h5>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">DROP</span> <span class=\"token keyword\">USER</span> myuser<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h5 id=\"查看权限\"><a class=\"anchor\" href=\"#查看权限\">#</a> 查看权限</h5>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">SHOW</span> GRANTS <span class=\"token keyword\">FOR</span> myuser<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h5 id=\"授予权限\"><a class=\"anchor\" href=\"#授予权限\">#</a> 授予权限</h5>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">GRANT</span> <span class=\"token keyword\">SELECT</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">INSERT</span> <span class=\"token keyword\">ON</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">.</span><span class=\"token operator\">*</span> <span class=\"token keyword\">TO</span> myuser<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h5 id=\"删除权限\"><a class=\"anchor\" href=\"#删除权限\">#</a> 删除权限</h5>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">REVOKE</span> <span class=\"token keyword\">SELECT</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">INSERT</span> <span class=\"token keyword\">ON</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">.</span><span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> myuser<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h5 id=\"更改密码\"><a class=\"anchor\" href=\"#更改密码\">#</a> 更改密码</h5>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">SET</span> PASSWORD <span class=\"token keyword\">FOR</span> myuser <span class=\"token operator\">=</span> <span class=\"token string\">'mypass'</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h4 id=\"存储过程-2\"><a class=\"anchor\" href=\"#存储过程-2\">#</a> 存储过程</h4>\n<p><img data-src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/60afdc9c9a594f079727ec64a2e698a3~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"mysql存储过程\" /></p>\n<p>使用存储过程的好处：</p>\n<ul>\n<li>代码封装，保证了一定的安全性；</li>\n<li><font color='red'>代码复用</font>；</li>\n<li>由于是<font color='red'>预先编译</font>，因此具有很高的性能。</li>\n</ul>\n<p>创建存储过程：</p>\n<ul>\n<li>命令行中创建存储过程需要自定义分隔符，因为命令行是以  <code>;</code>  为结束符，而存储过程中也包含了分号，因此会错误把这部分分号当成是结束符，造成语法错误。</li>\n<li>包含  <code>in</code> 、 <code>out</code>  和  <code>inout</code>  三种参数。</li>\n<li>给变量赋值都需要用  <code>select into</code>  语句。</li>\n<li>每次只能给一个变量赋值，不支持集合的操作。</li>\n</ul>\n<p>需要注意的是：<strong>阿里巴巴《Java 开发手册》强制禁止使用存储过程。因为存储过程难以调试和扩展，更没有移植性。</strong></p>\n<p><img data-src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/93a5e011ade4450ebfa5d82057532a49~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"img\" /></p>\n<p>至于到底要不要在项目中使用，还是要看项目实际需求，权衡好利弊即可！</p>\n<h5 id=\"创建存储过程\"><a class=\"anchor\" href=\"#创建存储过程\">#</a> 创建存储过程</h5>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">DROP</span> <span class=\"token keyword\">PROCEDURE</span> <span class=\"token keyword\">IF</span> <span class=\"token keyword\">EXISTS</span> <span class=\"token identifier\"><span class=\"token punctuation\">`</span>proc_adder<span class=\"token punctuation\">`</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">DELIMITER</span> <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">DEFINER</span><span class=\"token operator\">=</span><span class=\"token identifier\"><span class=\"token punctuation\">`</span>root<span class=\"token punctuation\">`</span></span><span class=\"token variable\">@`localhost`</span> <span class=\"token keyword\">PROCEDURE</span> <span class=\"token identifier\"><span class=\"token punctuation\">`</span>proc_adder<span class=\"token punctuation\">`</span></span><span class=\"token punctuation\">(</span><span class=\"token operator\">IN</span> a <span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">IN</span> b <span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">OUT</span> sum <span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">BEGIN</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token keyword\">DECLARE</span> c <span class=\"token keyword\">int</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token keyword\">if</span> a <span class=\"token operator\">is</span> <span class=\"token boolean\">null</span> <span class=\"token keyword\">then</span> <span class=\"token keyword\">set</span> a <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token keyword\">end</span> <span class=\"token keyword\">if</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token keyword\">if</span> b <span class=\"token operator\">is</span> <span class=\"token boolean\">null</span> <span class=\"token keyword\">then</span> <span class=\"token keyword\">set</span> b <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token keyword\">end</span> <span class=\"token keyword\">if</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    <span class=\"token keyword\">set</span> sum  <span class=\"token operator\">=</span> a <span class=\"token operator\">+</span> b<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token keyword\">END</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre><span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre><span class=\"token keyword\">DELIMITER</span> <span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h5 id=\"使用存储过程\"><a class=\"anchor\" href=\"#使用存储过程\">#</a> 使用存储过程</h5>\n<figure class=\"highlight less\"><figcaption data-lang=\"less\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>set <span class=\"token variable\">@b</span>=5<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>call proc_<span class=\"token function\">adder</span><span class=\"token punctuation\">(</span>2<span class=\"token punctuation\">,</span><span class=\"token variable\">@b</span><span class=\"token punctuation\">,</span><span class=\"token variable\">@s</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>select <span class=\"token variable\">@s</span> as sum<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h4 id=\"游标\"><a class=\"anchor\" href=\"#游标\">#</a> 游标</h4>\n<p>游标（cursor）是<strong>一个存储在 DBMS 服务器上的数据库查询，它不是一条  <code>SELECT</code>  语句，而是被该语句检索出来的结果集</strong>。</p>\n<p>在存储过程中使用游标可以对一个结果集进行移动遍历。</p>\n<p>游标主要用于交互式应用，其中用户需要滚动屏幕上的数据，并对数据进行浏览或做出更改。</p>\n<p>使用游标的几个明确步骤：</p>\n<ul>\n<li>在使用游标前，必须<font color='red'>声明 (定义)</font>它。这个过程实际上没有检索数据， 它只是定义要使用的  <code>SELECT</code>  语句和游标选项。</li>\n<li>一旦声明，就必须<font color='red'>打开游标以供使用</font>。这个过程用前面定义的 SELECT 语句把数据实际检索出来。</li>\n<li>对于填有数据的游标，根据需要<font color='red'>取出 (检索) 各行</font>。</li>\n<li>在结束游标使用时，必须<font color='red'>关闭游标</font>，可能的话，<font color='red'>释放游标</font>(有赖于具体的 DBMS)。</li>\n</ul>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">DELIMITER</span> $</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">CREATE</span>  <span class=\"token keyword\">PROCEDURE</span> getTotal<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">BEGIN</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token keyword\">DECLARE</span> total <span class=\"token keyword\">INT</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token comment\">-- 创建接收游标数据的变量</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token keyword\">DECLARE</span> sid <span class=\"token keyword\">INT</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token keyword\">DECLARE</span> sname <span class=\"token keyword\">VARCHAR</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token comment\">-- 创建总数变量</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token keyword\">DECLARE</span> sage <span class=\"token keyword\">INT</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token comment\">-- 创建结束标志变量</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token keyword\">DECLARE</span> done <span class=\"token keyword\">INT</span> <span class=\"token keyword\">DEFAULT</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    <span class=\"token comment\">-- 创建游标</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    <span class=\"token keyword\">DECLARE</span> cur <span class=\"token keyword\">CURSOR</span> <span class=\"token keyword\">FOR</span> <span class=\"token keyword\">SELECT</span> id<span class=\"token punctuation\">,</span>name<span class=\"token punctuation\">,</span>age <span class=\"token keyword\">from</span> cursor_table <span class=\"token keyword\">where</span> age<span class=\"token operator\">></span><span class=\"token number\">30</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    <span class=\"token comment\">-- 指定游标循环结束时的返回值</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    <span class=\"token keyword\">DECLARE</span> <span class=\"token keyword\">CONTINUE</span> <span class=\"token keyword\">HANDLER</span> <span class=\"token keyword\">FOR</span> <span class=\"token operator\">NOT</span> FOUND <span class=\"token keyword\">SET</span> done <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>    <span class=\"token keyword\">SET</span> total <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>    <span class=\"token keyword\">OPEN</span> cur<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>    <span class=\"token keyword\">FETCH</span> cur <span class=\"token keyword\">INTO</span> sid<span class=\"token punctuation\">,</span> sname<span class=\"token punctuation\">,</span> sage<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>    <span class=\"token keyword\">WHILE</span><span class=\"token punctuation\">(</span><span class=\"token operator\">NOT</span> done<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>    <span class=\"token keyword\">DO</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>        <span class=\"token keyword\">SET</span> total <span class=\"token operator\">=</span> total <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>        <span class=\"token keyword\">FETCH</span> cur <span class=\"token keyword\">INTO</span> sid<span class=\"token punctuation\">,</span> sname<span class=\"token punctuation\">,</span> sage<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>    <span class=\"token keyword\">END</span> <span class=\"token keyword\">WHILE</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>    <span class=\"token keyword\">CLOSE</span> cur<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>    <span class=\"token keyword\">SELECT</span> total<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre><span class=\"token keyword\">END</span> $</pre></td></tr><tr><td data-num=\"28\"></td><td><pre><span class=\"token keyword\">DELIMITER</span> <span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre></pre></td></tr><tr><td data-num=\"30\"></td><td><pre><span class=\"token comment\">-- 调用存储过程</span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre><span class=\"token keyword\">call</span> getTotal<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h4 id=\"触发器\"><a class=\"anchor\" href=\"#触发器\">#</a> 触发器</h4>\n<p>触发器是一种与表操作有关的数据库对象，<font color='red'>当触发器所在表上出现指定事件时，将调用该对象</font>，即表的操作事件触发表上的触发器的执行。</p>\n<p>触发器<font color='red'>可以用来进行审计跟踪，把修改记录到另外一张表中</font>。</p>\n<p>使用触发器的优点：</p>\n<ul>\n<li>SQL 触发器提供了另一种检查数据完整性的方法。</li>\n<li>SQL 触发器可以捕获数据库层中业务逻辑中的错误。</li>\n<li>SQL 触发器提供了另一种运行计划任务的方法。通过使用 SQL 触发器，您不必等待运行计划任务，因为在对表中的数据进行更改之前或之后会自动调用触发器。</li>\n<li>SQL 触发器对于审计表中数据的更改非常有用。</li>\n</ul>\n<p>使用触发器的缺点：</p>\n<ul>\n<li>SQL 触发器只能提供扩展验证，并且不能替换所有验证。必须在应用程序层中完成一些简单的验证。例如，您可以使用 JavaScript 在客户端验证用户的输入，或者使用服务器端脚本语言（如 JSP，PHP，<span class=\"exturl\" data-url=\"aHR0cDovL0FTUC5ORVQ=\">ASP.NET</span>，Perl）在服务器端验证用户的输入。</li>\n<li>从客户端应用程序调用和执行 SQL 触发器是不可见的，因此很难弄清楚数据库层中发生了什么。</li>\n<li>SQL 触发器可能会增加数据库服务器的开销。</li>\n</ul>\n<p><strong>MySQL 不允许在触发器中使用 CALL 语句 ，也就是不能调用存储过程</strong>。</p>\n<blockquote>\n<p>注意：在 MySQL 中，分号  <code>;</code>  是语句结束的标识符，遇到分号表示该段语句已经结束，MySQL 可以开始执行了。因此，解释器遇到触发器执行动作中的分号后就开始执行，然后会报错，因为没有找到和 BEGIN 匹配的 END。</p>\n<p>这时就会用到  <code>DELIMITER</code>  命令（DELIMITER 是定界符，分隔符的意思）。它是一条命令，不需要语句结束标识，语法为： <code>DELIMITER new_delemiter</code> 。 <code>new_delemiter</code>  可以设为 1 个或多个长度的符号，默认的是分号  <code>;</code> ，我们可以把它修改为其他符号，如  <code>$</code>  -  <code>DELIMITER $</code>  。在这之后的语句，以分号结束，解释器不会有什么反应，只有遇到了  <code>$</code> ，才认为是语句结束。注意，使用完之后，我们还应该记得把它给修改回来。</p>\n</blockquote>\n<p>在 MySQL 5.7.2 版之前，可以为每个表定义最多六个触发器。</p>\n<ul>\n<li><code>BEFORE INSERT</code>  - 在将数据插入表格之前激活。</li>\n<li><code>AFTER INSERT</code>  - 将数据插入表格后激活。</li>\n<li><code>BEFORE UPDATE</code>  - 在更新表中的数据之前激活。</li>\n<li><code>AFTER UPDATE</code>  - 更新表中的数据后激活。</li>\n<li><code>BEFORE DELETE</code>  - 在从表中删除数据之前激活。</li>\n<li><code>AFTER DELETE</code>  - 从表中删除数据后激活。</li>\n</ul>\n<p>但是，从 MySQL 版本 5.7.2 + 开始，可以为同一触发事件和操作时间定义多个触发器。</p>\n<p><strong> <code>NEW</code>  和  <code>OLD</code> </strong> ：</p>\n<ul>\n<li>MySQL 中定义了  <code>NEW</code>  和  <code>OLD</code>  关键字，用来<strong>表示触发器的所在表中，触发了触发器的那一行数据</strong>。</li>\n<li>在  <code>INSERT</code>  型触发器中， <code>NEW</code>  用来表示将要（ <code>BEFORE</code> ）或已经（ <code>AFTER</code> ）插入的新数据；</li>\n<li>在  <code>UPDATE</code>  型触发器中， <code>OLD</code>  用来表示将要或已经被修改的原数据， <code>NEW</code>  用来表示将要或已经修改为的新数据；</li>\n<li>在  <code>DELETE</code>  型触发器中， <code>OLD</code>  用来表示将要或已经被删除的原数据；</li>\n<li>使用方法：  <code>NEW.columnName</code>  （columnName 为相应数据表某一列名）</li>\n</ul>\n<h5 id=\"创建触发器\"><a class=\"anchor\" href=\"#创建触发器\">#</a> 创建触发器</h5>\n<blockquote>\n<p>提示：为了理解触发器的要点，有必要先了解一下创建触发器的指令。</p>\n</blockquote>\n<p><code>CREATE TRIGGER</code>  指令用于创建触发器。</p>\n<p>语法：</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">TRIGGER</span> trigger_name</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>trigger_time</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>trigger_event</pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">ON</span> table_name</pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">FOR EACH ROW</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token keyword\">BEGIN</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>  trigger_statements</pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token keyword\">END</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>说明：</p>\n<ul>\n<li><code>trigger_name</code>  ：触发器名</li>\n<li><code>trigger_time</code>  : 触发器的触发时机。取值为  <code>BEFORE</code>  或  <code>AFTER</code> 。</li>\n<li><code>trigger_event</code>  : 触发器的监听事件。取值为  <code>INSERT</code> 、 <code>UPDATE</code>  或  <code>DELETE</code> 。</li>\n<li><code>table_name</code>  : 触发器的监听目标。指定在哪张表上建立触发器。</li>\n<li><code>FOR EACH ROW</code> : 行级监视，Mysql 固定写法，其他 DBMS 不同。</li>\n<li><code>trigger_statements</code> : 触发器执行动作。是一条或多条 SQL 语句的列表，列表内的每条语句都必须用分号  <code>;</code>  来结尾。</li>\n</ul>\n<p>当触发器的触发条件满足时，将会执行  <code>BEGIN</code>  和  <code>END</code>  之间的触发器执行动作。</p>\n<p>示例：</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">DELIMITER</span> $</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">TRIGGER</span> <span class=\"token identifier\"><span class=\"token punctuation\">`</span>trigger_insert_user<span class=\"token punctuation\">`</span></span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">AFTER</span> <span class=\"token keyword\">INSERT</span> <span class=\"token keyword\">ON</span> <span class=\"token identifier\"><span class=\"token punctuation\">`</span>user<span class=\"token punctuation\">`</span></span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">FOR EACH ROW</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">BEGIN</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token keyword\">INSERT</span> <span class=\"token keyword\">INTO</span> <span class=\"token identifier\"><span class=\"token punctuation\">`</span>user_history<span class=\"token punctuation\">`</span></span><span class=\"token punctuation\">(</span>user_id<span class=\"token punctuation\">,</span> operate_type<span class=\"token punctuation\">,</span> operate_time<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token keyword\">VALUES</span> <span class=\"token punctuation\">(</span>NEW<span class=\"token punctuation\">.</span>id<span class=\"token punctuation\">,</span> <span class=\"token string\">'add a user'</span><span class=\"token punctuation\">,</span>  <span class=\"token function\">now</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token keyword\">END</span> $</pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token keyword\">DELIMITER</span> <span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h5 id=\"查看触发器\"><a class=\"anchor\" href=\"#查看触发器\">#</a> 查看触发器</h5>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">SHOW</span> TRIGGERS<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h5 id=\"删除触发器\"><a class=\"anchor\" href=\"#删除触发器\">#</a> 删除触发器</h5>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">DROP</span> <span class=\"token keyword\">TRIGGER</span> <span class=\"token keyword\">IF</span> <span class=\"token keyword\">EXISTS</span> trigger_insert_user<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h3 id=\"sql优化\"><a class=\"anchor\" href=\"#sql优化\">#</a> <mark>SQL 优化</mark></h3>\n<h4 id=\"慢查询语句优化\"><a class=\"anchor\" href=\"#慢查询语句优化\">#</a> <mark>慢查询语句优化</mark></h4>\n<ol>\n<li><font color='red'>尽量覆盖索引</font>，避免 select *，减少回表</li>\n<li><font color='red'>避免索引失效</font>，例如：联合索引需要满足最左前缀匹配原则、不要使用左模糊匹配、表达式运算、函数计算、隐式类型转换等...</li>\n<li><font color='red'>分页查询优化</font>：该方案适用于主键自增的表，可以把 Limit 查询转换成某个位置的查询。select * from tb_sku where id&gt;20000 limit 10;</li>\n<li><font color='red'>将字段多的表分解成多个表</font>：有些字段使用频率高，有些低，数据量大时，会由于使用频率低的存在而变慢，可以考虑分开</li>\n<li><font color='red'>对于经常联合查询的表，可以考虑建立中间表</font></li>\n<li><font color='red'>优化器使用 MRR【Multi-Range Read】</font>：将 ID 或键值读到 buffer 排序，通过<font color='red'>把「随机磁盘读」，转化为「顺序磁盘读」，减少磁盘 IO</font>，从而提高了索引查询的性能</li>\n<li><font color='red'>读写分离（主库写，从库读）</font></li>\n<li>检查<font color='red'>所查字段是否冗余</font></li>\n<li>检查<font color='red'>表中数据是否过多</font>，是否应该进行分库分表了</li>\n<li>检查<font color='red'>数据库实例所在机器的性能是否太低</font>，是否可以适当增加资源</li>\n</ol>\n<h4 id=\"插入数据-2\"><a class=\"anchor\" href=\"#插入数据-2\">#</a> 插入数据</h4>\n<h5 id=\"insert\"><a class=\"anchor\" href=\"#insert\">#</a> insert</h5>\n<p>如果我们需要一次性往数据库表中插入多条记录，</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">insert</span> <span class=\"token keyword\">into</span> tb_test <span class=\"token keyword\">values</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token string\">'tom'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">insert</span> <span class=\"token keyword\">into</span> tb_test <span class=\"token keyword\">values</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token string\">'cat'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">insert</span> <span class=\"token keyword\">into</span> tb_test <span class=\"token keyword\">values</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token string\">'jerry'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr></table></figure><p>可以从以下三个方面进行优化：</p>\n<ol>\n<li>\n<p><font color='red'>批量插入</font></p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">Insert</span> <span class=\"token keyword\">into</span> tb_test <span class=\"token keyword\">values</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token string\">'Tom'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token string\">'Cat'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token string\">'Jerry'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure></li>\n<li>\n<p><font color='red'>手动控制事务</font>：避免事务的频繁开启与提交</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">start</span> <span class=\"token keyword\">transaction</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">insert</span> <span class=\"token keyword\">into</span> tb_test <span class=\"token keyword\">values</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token string\">'Tom'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token string\">'Cat'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token string\">'Jerry'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">insert</span> <span class=\"token keyword\">into</span> tb_test <span class=\"token keyword\">values</span><span class=\"token punctuation\">(</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span><span class=\"token string\">'Tom'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">,</span><span class=\"token string\">'Cat'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">(</span><span class=\"token number\">6</span><span class=\"token punctuation\">,</span><span class=\"token string\">'Jerry'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">insert</span> <span class=\"token keyword\">into</span> tb_test <span class=\"token keyword\">values</span><span class=\"token punctuation\">(</span><span class=\"token number\">7</span><span class=\"token punctuation\">,</span><span class=\"token string\">'Tom'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">(</span><span class=\"token number\">8</span><span class=\"token punctuation\">,</span><span class=\"token string\">'Cat'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">(</span><span class=\"token number\">9</span><span class=\"token punctuation\">,</span><span class=\"token string\">'Jerry'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">commit</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure></li>\n<li>\n<p><font color='red'>主键顺序插入</font>：性能要高于乱序插入</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>主键乱序插入 : <span class=\"token number\">8</span> <span class=\"token number\">1</span> <span class=\"token number\">9</span> <span class=\"token number\">21</span> <span class=\"token number\">88</span> <span class=\"token number\">2</span> <span class=\"token number\">4</span> <span class=\"token number\">15</span> <span class=\"token number\">89</span> <span class=\"token number\">5</span> <span class=\"token number\">7</span> <span class=\"token number\">3</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>主键顺序插入 : <span class=\"token number\">1</span> <span class=\"token number\">2</span> <span class=\"token number\">3</span> <span class=\"token number\">4</span> <span class=\"token number\">5</span> <span class=\"token number\">7</span> <span class=\"token number\">8</span> <span class=\"token number\">9</span> <span class=\"token number\">15</span> <span class=\"token number\">21</span> <span class=\"token number\">88</span> <span class=\"token number\">89</span></pre></td></tr></table></figure></li>\n</ol>\n<h5 id=\"批量插入\"><a class=\"anchor\" href=\"#批量插入\">#</a> 批量插入</h5>\n<p>如果一次性需要插入大批量数据 (比如：几百万的记录)，使用 insert 语句插入性能较低，此时可以使用 MySQL 数据库提供的 <font color='red'> <code>load</code>  指令</font>进行插入。</p>\n<blockquote>\n<p>在 load 时，主键顺序插入性能高于乱序插入</p>\n</blockquote>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">-- 客户端连接服务端时，加上参数 -–local-infile</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>mysql –<span class=\"token operator\">-</span><span class=\"token keyword\">local</span><span class=\"token operator\">-</span><span class=\"token keyword\">infile</span> <span class=\"token operator\">-</span>u root <span class=\"token operator\">-</span>p</pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token comment\">-- 设置全局参数 local_infile 为 1，开启从本地加载文件导入数据的开关</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">set</span> <span class=\"token keyword\">global</span> local_infile <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token comment\">-- 执行 load 指令将准备好的数据，加载到表结构中</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token keyword\">load</span> <span class=\"token keyword\">data</span> <span class=\"token keyword\">local</span> <span class=\"token keyword\">infile</span> <span class=\"token string\">'/root/sql1.log'</span> <span class=\"token keyword\">into</span> <span class=\"token keyword\">table</span> tb_user <span class=\"token keyword\">fields</span> <span class=\"token keyword\">terminated</span> <span class=\"token keyword\">by</span> <span class=\"token string\">','</span> <span class=\"token keyword\">lines</span> <span class=\"token keyword\">terminated</span> <span class=\"token keyword\">by</span> <span class=\"token string\">'\\n'</span> <span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h4 id=\"主键优化\"><a class=\"anchor\" href=\"#主键优化\">#</a> <mark>主键优化</mark></h4>\n<blockquote>\n<p>想知道为什么主键顺序插入的效率比主键乱序插入的更高，首先得明白主键是如何设计的！</p>\n</blockquote>\n<h5 id=\"innodb表数据的组织方式\"><a class=\"anchor\" href=\"#innodb表数据的组织方式\">#</a> InnoDB 表数据的组织方式</h5>\n<p><font color='red'>在 InnoDB 存储引擎中，表数据都是根据<u>主键顺序</u>组织存放的</font>，这种存储方式的表称为<strong>索引组织表 (index organized table IOT)</strong>。</p>\n<p><font color='red'>行数据，都是存储在聚集索引的叶子节点上的</font>。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231119103453582.png\" alt=\"image-20231119103453582\" /></p>\n<p>之前也讲解过 InnoDB 的逻辑结构图：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231119103710336.png\" alt=\"image-20231119103710336\" /></p>\n<p><font color='red'>在 InnoDB 引擎中，row 数据是记录在逻辑结构 page 页中的</font>，而每一个页的大小是固定的，默认 16K。也就意味着，一个页中所存储的行也是有限的，<font color='red'>如果插入的 row 数据在该页存储不下，将会存储到下一个页中，页与页之间会通过指针连接</font>。</p>\n<h5 id=\"页分裂\"><a class=\"anchor\" href=\"#页分裂\">#</a> 页分裂</h5>\n<blockquote>\n<p>主键乱序插入时会产生的操作，比较耗费性能！</p>\n</blockquote>\n<p>页可以为空，也可以填充一半，也可以填充 100%。每个页包含了 2-N 行数据 (如果一行数据过大，会行溢出)，<font color='red'>页内的行数据根据主键排列</font>。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231119104317288.png\" alt=\"image-20231119104317288\" /></p>\n<center>按照主键顺序插入</center>\n<p><strong>页分裂</strong>：当行数据是<font color='red'>按照主键乱序插入</font>时，<strong><font color='red'>由于索引结构的叶子节点需要维护有序</font></strong>，在插入某行数据时，如果<font color='red'>当前所有页都满了</font>，会导致<font color='red'>某页需要将后一半数据移动到一个新开辟的页中</font>，然后<font color='red'>再插入行数据</font>，最后需要<font color='red'>重新设置页之间的指针</font>。</p>\n<p>因此，<strong><font color='red'>页分裂是一种比较耗费性能的操作，所以尽量按照主键顺序插入！</font></strong></p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231119105153488.png\" alt=\"image-20231119105153488\" /></p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231119105216568.png\" alt=\"image-20231119105216568\" /></p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231119105221673.png\" alt=\"image-20231119105221673\" /></p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231119105227518.png\" alt=\"image-20231119105227518\" /></p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231119105234837.png\" alt=\"image-20231119105234837\" /></p>\n<center>按照主键乱序插入</center>\n<h5 id=\"页合并\"><a class=\"anchor\" href=\"#页合并\">#</a> 页合并</h5>\n<p>当删除一条行记录时，并非物理删除，而是将其标记（flaged）为<font color='red'>逻辑删除</font>，并且它的空间变得允许被其他行记录声明使用。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231119110526526.png\" alt=\"image-20231119110526526\" /></p>\n<p><strong><font color='red'>当页中删除的记录达到 MERGE_THRESHOLD（默认为页的 50%），InnoDB 会开始寻找最靠近的页看看是否可以将两个页合并，以优化空间使用</font></strong>。</p>\n<blockquote>\n<p>MERGE_THRESHOLD：合并页的阈值，可以自己设置，在创建表或者创建索引时指定。</p>\n</blockquote>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231119110615283.png\" alt=\"image-20231119110615283\" /></p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231119110628033.png\" alt=\"image-20231119110628033\" /></p>\n<p>删除数据，并将页合并之后，再次插入新的数据 21，则直接插入 3# 页。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231119110703491.png\" alt=\"image-20231119110703491\" /></p>\n<h5 id=\"主键使用原则\"><a class=\"anchor\" href=\"#主键使用原则\">#</a> 主键使用原则</h5>\n<ul>\n<li>\n<p><strong>尽量降低主键的长度</strong>：对于一张表，只有一个主键索引，可以有多个二级索引。而二级索引的叶子节点中存放的就是主键，因此<font color='red'>如果主键的长度较长，会导致二级索引占用大量磁盘空间，查询时也会耗费较多的磁盘 IO</font>。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231119111458997.png\" alt=\"image-20231119111458997\" /></p>\n</li>\n<li>\n<p><strong>尽量按照主键顺序插入数据</strong>：能够避免按照主键乱序插入数据时的页分裂操作，提高插入性能！</p>\n</li>\n<li>\n<p><strong>尽量选择使用 AUTO_INCREMENT 自增主键</strong>：不要使用 UUID 做主键，或者其他自然主键，如身份证号。因为它们都是<font color='red'>无序</font>的，导致乱序插入，存在页分裂现象。而且它们的<font color='red'>长度较长</font>，构建索引需要的空间较大，在查询时会耗费大量的磁盘 IO。</p>\n</li>\n<li>\n<p><strong>尽量避免对主键的修改</strong>：修改主键，还需要修改对应的主键索引、二级索引，代价较大！</p>\n</li>\n</ul>\n<h4 id=\"order-by-优化\"><a class=\"anchor\" href=\"#order-by-优化\">#</a> order by 优化</h4>\n<p>MySQL 有两种排序方式：</p>\n<ul>\n<li><code>Using filesort</code> ：通过表的索引或全表扫描读取满足条件的数据行，然后<font color='red'>在 sort buffer（排序缓冲区）中完成排序操作</font>，所有不是通过索引直接返回排序结果的排序都叫 FileSort 排序。</li>\n<li><code>Using index</code> ：<font color='red'>通过有序索引顺序扫描直接返回有序数据</font>，<font color='red'>不需要额外排序，操作效率高</font>。</li>\n</ul>\n<p>因此在优化排序操作时，<font color='red'>尽量优化为 Using index</font>。</p>\n<p>经过测试（黑马 MySQL - 进阶篇），总结一下 order by 优化原则：</p>\n<ul>\n<li><strong>根据排序字段建立合适的索引</strong>：这样才会 Using index 排序</li>\n<li>多字段排序时，也遵循<strong>联合索引的最左前缀匹配法则</strong>；</li>\n<li><strong>尽量使用覆盖索引</strong>：避免 select * ；</li>\n<li>多字段排序，一个升序一个降序，此时需要注意<strong>联合索引在创建时的规则（ASC/DESC）</strong>；</li>\n<li>如果不可避免的出现 filesort，大数据量排序时，可以<strong>适当增大排序缓冲区大小 sort_buffer_size</strong> (默认 256k)，否则会在磁盘空间中排序，效率低！</li>\n</ul>\n<h4 id=\"group-by-优化\"><a class=\"anchor\" href=\"#group-by-优化\">#</a> group by 优化</h4>\n<p>在分组操作中，需要通过以下两点进行优化：</p>\n<ul>\n<li>可以<strong>通过索引来提高效率</strong></li>\n<li>联合索引的使用，也需要<strong>遵循最左前缀法则</strong>的</li>\n</ul>\n<h4 id=\"limit-优化\"><a class=\"anchor\" href=\"#limit-优化\">#</a> limit 优化</h4>\n<p>在数据量比较大时，进行 limit 分页查询存在问题：越往后，分页查询效率越低。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231119121326947.png\" alt=\"image-20231119121326947\" /></p>\n<p>优化思路：<strong>覆盖索引 + 子查询</strong></p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">explain</span> <span class=\"token keyword\">select</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">from</span> tb_sku t <span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">select</span> id <span class=\"token keyword\">from</span> tb_sku <span class=\"token keyword\">order</span> <span class=\"token keyword\">by</span> id <span class=\"token keyword\">limit</span> <span class=\"token number\">2000000</span><span class=\"token punctuation\">,</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span> a <span class=\"token keyword\">where</span> t<span class=\"token punctuation\">.</span>id <span class=\"token operator\">=</span> a<span class=\"token punctuation\">.</span>id<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h4 id=\"count-优化\"><a class=\"anchor\" href=\"#count-优化\">#</a> count 优化</h4>\n<p>如果数据量很大，在执行 count 操作时，是非常耗时的。</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">select</span> <span class=\"token function\">count</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">from</span> tb_user <span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>下面对比一下 MyISAM、InnoDB 是如何执行 count 操作的：</p>\n<ul>\n<li>\n<p><font color='cornflowerblue'>MyISAM 引擎</font>：<font color='red'>把表的总行数存在了磁盘上</font>，因此执行 count (*) 的时候会直接返回这个数，效率很高。但是如果是带条件的 count，MyISAM 也慢。</p>\n</li>\n<li>\n<p><font color='cornflowerblue'>InnoDB 引擎</font>：执行 count (*) 的时候，需要<font color='red'>把数据一行一行地从引擎里面读出来，然后累积计数</font>。</p>\n<blockquote>\n<p>InnoDB 对 count 的优化思路：<font color='red'>自己维护计数</font>（可以借助于 redis 进行，但是如果是带条件的 count 又比较麻烦了）。</p>\n</blockquote>\n</li>\n</ul>\n<p>count () 是一个聚合函数，对于返回的结果集，一行行地判断，如果 count 函数的参数不是 NULL，累计值就加 1，否则不加，最后返回累计值。</p>\n<p>count 用法：count（*）、count（主键）、count（字段）、count（数字）</p>\n<blockquote>\n<p>按照效率排序的话，count (字段) &lt; count (主键 id) &lt; count (1) ≈ count (*)，所以<strong>尽量使用 count (*)</strong></p>\n</blockquote>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231119131552752.png\" alt=\"image-20231119131552752\" /></p>\n<h4 id=\"update-优化\"><a class=\"anchor\" href=\"#update-优化\">#</a> update 优化</h4>\n<p>执行 Update 语句时，条件一定要根据索引字段进行更新，否则会出现行锁升级为表锁，导致并发性能降低！</p>\n<p>InnoDB 的行锁是针对索引加的锁，不是针对记录加的锁，并且该索引不能失效，否则会从行锁升级为表锁。</p>\n<h4 id=\"一些优化原则\"><a class=\"anchor\" href=\"#一些优化原则\">#</a> 一些优化原则</h4>\n<h5 id=\"尽量使用覆盖索引避免-select\"><a class=\"anchor\" href=\"#尽量使用覆盖索引避免-select\">#</a> 尽量使用覆盖索引，避免 select *</h5>\n<p>** 覆盖索引，即需要查询的字段正好是索引的字段，那么直接根据该索引，就可以查到数据了，而无需回表查询。** 因此，<font color='red'>应该尽量使用覆盖索引，减少 <code>select *</code> </font>。</p>\n<h5 id=\"分页优化\"><a class=\"anchor\" href=\"#分页优化\">#</a> 分页优化</h5>\n<h5 id=\"尽量避免多表做join\"><a class=\"anchor\" href=\"#尽量避免多表做join\">#</a> 尽量避免多表做 join</h5>\n<h5 id=\"建议不要使用外键与级联\"><a class=\"anchor\" href=\"#建议不要使用外键与级联\">#</a> 建议不要使用外键与级联</h5>\n<h5 id=\"选择合适的字段类型\"><a class=\"anchor\" href=\"#选择合适的字段类型\">#</a> 选择合适的字段类型</h5>\n<h5 id=\"尽量用-union-all-代替-union\"><a class=\"anchor\" href=\"#尽量用-union-all-代替-union\">#</a> 尽量用 UNION ALL 代替 UNION</h5>\n<h5 id=\"批量操作\"><a class=\"anchor\" href=\"#批量操作\">#</a> 批量操作</h5>\n<h5 id=\"show-profle-分析-sql-执行性能\"><a class=\"anchor\" href=\"#show-profle-分析-sql-执行性能\">#</a> Show Profle 分析 SQL 执行性能</h5>\n<h5 id=\"优化慢sql\"><a class=\"anchor\" href=\"#优化慢sql\">#</a> 优化慢 SQL</h5>\n<h5 id=\"正确使用索引\"><a class=\"anchor\" href=\"#正确使用索引\">#</a> 正确使用索引</h5>\n<blockquote>\n<p>指路→<a href=\"#%E7%B4%A2%E5%BC%95%E7%9A%84%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8%E5%BB%BA%E8%AE%AE\">索引的正确使用建议</a></p>\n</blockquote>\n<h3 id=\"sql常见面试题\"><a class=\"anchor\" href=\"#sql常见面试题\">#</a> SQL 常见面试题</h3>\n",
            "tags": [
                "数据库",
                "MySQL"
            ]
        },
        {
            "id": "http://example.com/photography/%E6%97%A5%E8%90%BD%E6%94%B6%E9%9B%86%E8%AE%A1%E5%88%92/",
            "url": "http://example.com/photography/%E6%97%A5%E8%90%BD%E6%94%B6%E9%9B%86%E8%AE%A1%E5%88%92/",
            "title": "日落收集计划",
            "date_published": "2023-11-14T16:39:51.099Z",
            "content_html": "<p><img data-src=\"https://pic.imgdb.cn/item/6553a0abc458853aef3aa4f3.jpg\" alt=\"\" /><br />\n<img data-src=\"https://pic.imgdb.cn/item/6553a403c458853aef45fdc7.jpg\" alt=\"落日窗花\" title=\"落日窗花\" /></p>\n",
            "tags": [
                "摄影"
            ]
        },
        {
            "id": "http://example.com/photography/%E8%88%B9%E5%A4%AB%E8%9C%80%E9%BB%8D/",
            "url": "http://example.com/photography/%E8%88%B9%E5%A4%AB%E8%9C%80%E9%BB%8D/",
            "title": "船夫蜀黍",
            "date_published": "2023-11-14T16:37:21.388Z",
            "content_html": "<p><img data-src=\"https://pic.imgdb.cn/item/6553a275c458853aef40b302.jpg\" alt=\"上船！\" title=\"上船！\" /><br />\n<img data-src=\"https://pic.imgdb.cn/item/6553a275c458853aef40b256.jpg\" alt=\"看啥呢\" title=\"看啥呢\" /></p>\n",
            "tags": [
                "摄影"
            ]
        },
        {
            "id": "http://example.com/photography/%E4%B8%80%E4%BA%9B%E8%93%9D%E8%89%B2/",
            "url": "http://example.com/photography/%E4%B8%80%E4%BA%9B%E8%93%9D%E8%89%B2/",
            "title": "一些蓝色",
            "date_published": "2023-11-14T16:30:42.887Z",
            "content_html": "<p><img data-src=\"https://pic.imgdb.cn/item/6553a0aac458853aef3aa386.jpg\" alt=\"1号蓝嘉宾\" title=\"1号蓝嘉宾\" /><br />\n<img data-src=\"https://pic.imgdb.cn/item/6553a0abc458853aef3aa631.jpg\" alt=\"2号蓝嘉宾\" title=\"2号蓝嘉宾\" /></p>\n<p><img data-src=\"https://pic.imgdb.cn/item/6553a0abc458853aef3aa4aa.jpg\" alt=\"3号蓝嘉宾\" title=\"3号蓝嘉宾\" /></p>\n",
            "tags": [
                "摄影"
            ]
        },
        {
            "id": "http://example.com/photography/%E8%93%9D%E4%B8%8E%E9%BB%84/",
            "url": "http://example.com/photography/%E8%93%9D%E4%B8%8E%E9%BB%84/",
            "title": "蓝与黄",
            "date_published": "2023-11-14T16:20:56.108Z",
            "content_html": "<p><img data-src=\"https://pic.imgdb.cn/item/65539e35c458853aef322d09.jpg\" alt=\"一直在用的头像\" title=\"一直在用的头像hh\" /><br />\n<img data-src=\"https://pic.imgdb.cn/item/65539e33c458853aef3224f3.jpg\" alt=\"老电影的最后一幕\" title=\"老电影的最后一幕\" /></p>\n",
            "tags": [
                "摄影"
            ]
        },
        {
            "id": "http://example.com/photography/%E6%9C%9D%E9%98%B3%E5%85%AC%E5%9B%AD/",
            "url": "http://example.com/photography/%E6%9C%9D%E9%98%B3%E5%85%AC%E5%9B%AD/",
            "title": "朝阳公园",
            "date_published": "2023-11-12T08:06:56.973Z",
            "content_html": "<p><img data-src=\"https://pic.imgdb.cn/item/6554c7d9c458853aefd85660.jpg\" alt=\"&quot;婚纱照&quot;\" title=\"婚纱照\" /></p>\n<p><img data-src=\"https://pic.imgdb.cn/item/6554c7d9c458853aefd857b8.jpg\" alt=\"&quot;鸽子&quot;\" title=\"鸽子\" /></p>\n<p><img data-src=\"https://pic.imgdb.cn/item/6554c7d9c458853aefd85a3b.jpg\" alt=\"灯塔？喇叭？\" title=\"灯塔？喇叭？\" /><br />\n<img data-src=\"https://pic.imgdb.cn/item/6554c7dac458853aefd85b87.jpg\" alt=\"旋转跳跃~\" title=\"旋转跳跃~\" height=\"700px\" /></p>\n<p><img data-src=\"https://pic.imgdb.cn/item/6554c873c458853aefdaf78e.jpg\" alt=\"&quot;我不停歇~&quot;\" title=\"我不停歇~\" height=\"700px\" /></p>\n<p><img data-src=\"https://pic.imgdb.cn/item/6554c872c458853aefdaf5dd.jpg\" alt=\"&quot;波光粼粼粼粼粼&quot;\" title=\"波光粼粼粼粼粼\" height=\"700px\" /></p>\n<p><img data-src=\"https://pic.imgdb.cn/item/6554c8c4c458853aefdc3eb4.png\" alt=\"1681754285877.png\" height=\"700px\" /></p>\n<p><img data-src=\"https://pic.imgdb.cn/item/6554c8c4c458853aefdc402e.jpg\" alt=\"&quot;野蛮生长&quot;\" title=\"野蛮生长\" /></p>\n<p><img data-src=\"https://pic.imgdb.cn/item/6554c873c458853aefdafa16.jpg\" alt=\"&quot;光影出版社&quot;\" title=\"光影出版社\" /></p>\n<p><img data-src=\"https://pic.imgdb.cn/item/6554c873c458853aefdaf8ee.jpg\" alt=\"&quot;&quot;\" /></p>\n<p><img data-src=\"https://pic.imgdb.cn/item/6554c7d8c458853aefd854e9.jpg\" alt=\"&quot;售票亭&quot;\" title=\"售票亭\" /></p>\n<p><img data-src=\"https://pic.imgdb.cn/item/6554c8c3c458853aefdc3a13.jpg\" alt=\"&quot;麦门!&quot;\" title=\"麦门!\" /></p>\n",
            "tags": [
                "摄影"
            ]
        },
        {
            "id": "http://example.com/photography/%E8%AF%BE%E4%B8%8A%E6%91%B8%E9%B1%BC/",
            "url": "http://example.com/photography/%E8%AF%BE%E4%B8%8A%E6%91%B8%E9%B1%BC/",
            "title": "课上摸鱼",
            "date_published": "2023-11-12T03:50:08.798Z",
            "content_html": "<p><img data-src=\"https://store.heytapimage.com/cdo-portal/feedback/202311/14/d14ad5b8a21733d0ad00c6f42a36a476.jpeg\" alt=\"无聊的嵌入式\" title=\"无聊的嵌入式\" /><br />\n<img data-src=\"https://store.heytapimage.com/cdo-portal/feedback/202311/14/898b619d3706f71c0881abb448891fa3.jpeg\" alt=\"早自习\" title=\"早自习\" /></p>\n",
            "tags": [
                "摄影"
            ]
        },
        {
            "id": "http://example.com/java/juc/JUC%E7%AC%94%E8%AE%B0/",
            "url": "http://example.com/java/juc/JUC%E7%AC%94%E8%AE%B0/",
            "title": "JUC 笔记",
            "date_published": "2023-11-12T03:12:33.234Z",
            "content_html": "<h1 id=\"java-并发概述\"><a class=\"anchor\" href=\"#java-并发概述\">#</a> Java 并发概述</h1>\n<hr />\n<h2 id=\"什么是进程和线程\"><a class=\"anchor\" href=\"#什么是进程和线程\">#</a> 什么是进程和线程？</h2>\n<h3 id=\"何为进程\"><a class=\"anchor\" href=\"#何为进程\">#</a> 何为进程？</h3>\n<p><strong>进程是程序的一次执行过程，是系统进行资源分配的基本单位</strong>。系统运行一个程序即是一个进程从创建，运行到消亡的过程。</p>\n<p>在 Java 中，当我们启动 main 函数时其实就是启动了一个 JVM 的进程，而 main 函数所在的线程就是这个进程中的一个线程，也称<font color='red'>主线程</font>。</p>\n<p>如下图所示，在 Windows 中通过查看任务管理器的方式，我们就可以清楚看到 Windows 当前运行的进程（ <code>.exe</code>  文件的运行）。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231008000329935.png\" alt=\"进程示例图片-Windows\" /></p>\n<h3 id=\"何为线程\"><a class=\"anchor\" href=\"#何为线程\">#</a> 何为线程？</h3>\n<p><strong>线程属于进程中的一个实体，是一个基本的 CPU 执行单元，是系统独立调度的基本单位</strong>。一个进程在其执行的过程中可以产生多个线程。与进程不同的是，<font color='red'>同类的多个线程共享进程的<strong>堆</strong>和<strong>方法区</strong>资源，但每个线程有自己的<strong>程序计数器</strong>、<strong>虚拟机栈</strong>和<strong>本地方法栈</strong></font>。所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为<font color='red'>轻量级进程</font>。</p>\n<p>Java 程序天生就是多线程程序，我们可以通过 JMX 来看看一个普通的 Java 程序有哪些线程，代码如下。</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">MultiThread</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>\t<span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>\t\t<span class=\"token comment\">// 获取 Java 线程管理 MXBean</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>\t<span class=\"token class-name\">ThreadMXBean</span> threadMXBean <span class=\"token operator\">=</span> <span class=\"token class-name\">ManagementFactory</span><span class=\"token punctuation\">.</span><span class=\"token function\">getThreadMXBean</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>\t\t<span class=\"token comment\">// 不需要获取同步的 monitor 和 synchronizer 信息，仅获取线程和线程堆栈信息</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>\t\t<span class=\"token class-name\">ThreadInfo</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> threadInfos <span class=\"token operator\">=</span> threadMXBean<span class=\"token punctuation\">.</span><span class=\"token function\">dumpAllThreads</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>\t\t<span class=\"token comment\">// 遍历线程信息，仅打印线程 ID 和线程名称信息</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>\t\t<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">ThreadInfo</span> threadInfo <span class=\"token operator\">:</span> threadInfos<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>\t\t\t<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"[\"</span> <span class=\"token operator\">+</span> threadInfo<span class=\"token punctuation\">.</span><span class=\"token function\">getThreadId</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token string\">\"] \"</span> <span class=\"token operator\">+</span> threadInfo<span class=\"token punctuation\">.</span><span class=\"token function\">getThreadName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>\t\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>上述程序输出如下（输出内容可能不同，不用太纠结下面每个线程的作用，只用知道 main 线程执行 main 方法即可）：</p>\n<figure class=\"highlight text\"><figcaption data-lang=\"text\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>[5] Attach Listener //添加事件</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>[4] Signal Dispatcher // 分发处理给 JVM 信号的线程</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>[3] Finalizer //调用对象 finalize 方法的线程</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>[2] Reference Handler //清除 reference 线程</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>[1] main //main 线程,程序入口</pre></td></tr></table></figure><p>从上面的输出内容可以看出：<strong>一个 Java 程序（进程）的运行是 main 线程和多个其他线程同时运行</strong>。</p>\n<h2 id=\"进程和线程的关系区别优缺点\"><a class=\"anchor\" href=\"#进程和线程的关系区别优缺点\">#</a> 进程和线程的关系，区别，优缺点？</h2>\n<ul>\n<li><strong>调度</strong>：线程是调度的基本单位（PC，状态码，通用寄存器，线程栈及栈指针）；进程是拥有资源的基本单位（打开文件，堆，静态区，代码段等）。</li>\n<li><strong>并发性</strong>：一个进程内多个线程可以并发（最好和 CPU 核数相等）；多个进程可以并发。</li>\n<li><strong>拥有资源</strong>：线程不拥有系统资源，但一个进程的多个线程可以共享隶属进程的资源；进程是拥有资源的独立单位。</li>\n<li><strong>系统开销</strong>：线程创建销毁只需要处理 PC 值，状态码，通用寄存器值，线程栈及栈指针即可；进程创建和销毁需要重新分配及销毁 task_struct 结构。</li>\n</ul>\n<h3 id=\"图解进程与线程的关系\"><a class=\"anchor\" href=\"#图解进程与线程的关系\">#</a> 图解进程与线程的关系</h3>\n<p>下图是 Java 8 后的的内存结构（运行时数据区），通过下图我们从 JVM 的角度来说一下线程和进程之间的关系。</p>\n<p><img data-src=\"https://oss.javaguide.cn/github/javaguide/java/jvm/java-runtime-data-areas-jdk1.8.png\" alt=\"Java 运行时数据区域（JDK1.8 之后）\" /></p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231008002249305.png\" alt=\"image-20231008002249305\" /></p>\n<p>从上图可以看出：一个进程中可以有多个线程，多个线程共享进程的<strong>堆</strong>和<strong>方法区 (JDK1.8 之后的元空间)<strong> 资源，但是每个线程有自己的</strong>程序计数器</strong>、<strong>虚拟机栈</strong> 和 <strong>本地方法栈</strong>。</p>\n<p>进程与线程的对比总结：</p>\n<ul>\n<li><strong>线程是进程划分成的更小的运行单位</strong>。</li>\n<li>线程和进程最大的不同在于，<strong>各进程基本上是独立的，而各线程则不一定</strong>，因为同一进程中的线程极有可能会相互影响。</li>\n<li><strong>线程执行开销小，上下文切换的成本低</strong>，但不利于资源的管理和保护；而进程正相反。</li>\n</ul>\n<h3 id=\"为什么程序计数器的私有的\"><a class=\"anchor\" href=\"#为什么程序计数器的私有的\">#</a> 为什么程序计数器的私有的？</h3>\n<p>程序计数器主要有下面两个作用：</p>\n<ol>\n<li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</li>\n<li>在多线程的情况下，程序计数器用于<font color='red'>记录当前线程执行的位置</font>，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</li>\n</ol>\n<p>需要注意的是，如果执行的是 native 方法，那么程序计数器记录的是 undefined 地址，<font color='red'>只有执行的是 Java 代码时，程序计数器记录的才是下一条指令的地址</font>。</p>\n<p>所以，程序计数器私有主要是<strong>为了线程切换后能恢复到正确的执行位置</strong>。</p>\n<h3 id=\"为什么虚拟机栈和本地方法栈是私有的\"><a class=\"anchor\" href=\"#为什么虚拟机栈和本地方法栈是私有的\">#</a> 为什么虚拟机栈和本地方法栈是私有的？</h3>\n<ul>\n<li>\n<p>** 虚拟机栈：** 每个 Java 方法在执行之前会创建一个栈帧用于<font color='red'>存储调用方法的局部变量表、操作数栈、常量池引用等信息</font>。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231008001952766.png\" alt=\"image-20231008001952766\" /></p>\n</li>\n<li>\n<p>** 本地方法栈：** 和虚拟机栈所发挥的作用非常相似，区别是：** 虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。** 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</p>\n</li>\n</ul>\n<p>所以，<strong>为了保证线程中的局部变量不被别的线程访问到</strong>，虚拟机栈和本地方法栈是线程私有的。</p>\n<h3 id=\"为什么堆和方法区是共享的\"><a class=\"anchor\" href=\"#为什么堆和方法区是共享的\">#</a> 为什么堆和方法区是共享的？</h3>\n<ul>\n<li><strong>堆</strong>：是进程中最大的一块内存，主要用于<strong>存放新创建的对象</strong> (几乎所有对象都在这里分配内存)</li>\n<li><strong>方法区</strong>：主要用于<strong>存放已被加载的类信息、常量等数据</strong>。</li>\n</ul>\n<h2 id=\"并发和并行的区别\"><a class=\"anchor\" href=\"#并发和并行的区别\">#</a> 并发和并行的区别？</h2>\n<ul>\n<li><strong>并发</strong>：两个及两个以上的作业在同一 <strong>时间段</strong> 内执行。</li>\n<li><strong>并行</strong>：两个及两个以上的作业在同一 <strong>时刻</strong> 执行。</li>\n</ul>\n<p>最关键的点是：是否是 <strong>同时</strong> 执行。</p>\n<h2 id=\"同步和异步的区别\"><a class=\"anchor\" href=\"#同步和异步的区别\">#</a> 同步和异步的区别？</h2>\n<ul>\n<li><strong>同步</strong>：发出一个调用之后，在没有得到结果之前，该调用就<strong>不可以返回，一直等待</strong></li>\n<li><strong>异步</strong>：调用在发出之后，不用等待返回结果，该调用<strong>直接返回</strong></li>\n</ul>\n<h2 id=\"为什么要使用多线程\"><a class=\"anchor\" href=\"#为什么要使用多线程\">#</a> 为什么要使用多线程？</h2>\n<p>先从总体上来说：</p>\n<ul>\n<li><strong>从计算机底层来说：</strong> 线程可以比作是轻量级的进程，是程序执行的最小单位，<font color='red'>线程间的切换和调度的成本远远小于进程</font>。另外，多核 CPU 时代意味着多个线程可以同时运行，这减少了线程上下文切换的开销。</li>\n<li><strong>从当代互联网发展趋势来说：</strong> 现在的系统动不动就要求百万级甚至千万级的并发量，而<font color='red'>多线程并发编程正是开发高并发系统的基础</font>，利用好多线程机制可以大大提高系统整体的并发能力以及性能。</li>\n</ul>\n<p>再深入到计算机底层来探讨：</p>\n<ul>\n<li><strong>单核时代</strong>：在单核时代多线程主要是<font color='red'>为了提高单进程利用 CPU 和 IO 系统的效率</font>。 假设只运行了一个 Java 进程的情况，当我们请求 IO 的时候，如果 Java 进程中只有一个线程，此线程被 IO 阻塞则整个进程被阻塞。CPU 和 IO 设备只有一个在运行，那么可以简单地说系统整体效率只有 50%。当使用多线程的时候，一个线程被 IO 阻塞，其他线程还可以继续使用 CPU。从而提高了 Java 进程利用系统资源的整体效率。</li>\n<li><strong>多核时代</strong>：多核时代多线程主要是<font color='red'>为了提高进程利用多核 CPU 的能力</font>。举个例子：假如我们要计算一个复杂的任务，我们只用一个线程的话，不论系统有几个 CPU 核心，都只会有一个 CPU 核心被利用到。而创建多个线程，这些线程可以被映射到底层多个 CPU 上执行，在任务中的多个线程没有资源竞争的情况下，任务执行的效率会有显著性的提高，约等于（单核时执行时间 / CPU 核心数）。</li>\n</ul>\n<h2 id=\"多线程会带来什么问题\"><a class=\"anchor\" href=\"#多线程会带来什么问题\">#</a> 多线程会带来什么问题？</h2>\n<p>并发编程的目的就是为了能提高程序的执行效率，提高程序运行速度。但是并发编程并不总是能提高程序运行速度的，而且并发编程可能会遇到很多问题，比如：<font color='red'>内存泄漏、死锁、线程不安全</font>等。</p>\n<h2 id=\"如何理解线程安全和不安全\"><a class=\"anchor\" href=\"#如何理解线程安全和不安全\">#</a> 如何理解线程安全和不安全？</h2>\n<p>线程安全和不安全是在多线程环境下对于同一份数据的访问<font color='red'>是否能保证共享资源的正确性和一致性</font>的描述。</p>\n<ul>\n<li>线程安全：在多线程环境下，对于同一份数据，不管有多少个线程同时访问，都能保证这份数据的正确性和一致性。</li>\n<li>线程不安全：在多线程环境下，对于同一份数据，多个线程同时访问时可能会导致数据混乱、错误或者丢失。</li>\n</ul>\n<h2 id=\"单核-cpu-上运行多个线程效率一定会高吗\"><a class=\"anchor\" href=\"#单核-cpu-上运行多个线程效率一定会高吗\">#</a> 单核 CPU 上运行多个线程效率一定会高吗？</h2>\n<p>单核 CPU 同时运行多个线程的效率是否会高，<font color='red'>取决于线程的类型和任务的性质</font>。</p>\n<p>一般来说，有两种类型的线程：</p>\n<ul>\n<li><font color='cornflowerblue'>CPU 密集型</font>：主要进行计算和逻辑处理，需要占用大量的 CPU 资源。</li>\n<li><font color='cornflowerblue'>IO 密集型</font>：主要进行输入输出操作，如读写文件、网络通信等，需要等待 IO 设备的响应，而不占用太多的 CPU 资源。</li>\n</ul>\n<p><font color='red'>在单核 CPU 上，同一时刻只能有一个线程在运行，其他线程需要等待 CPU 的时间片分配</font>。如果线程是 CPU 密集型的，那么多个线程同时运行会导致频繁的线程切换，增加了系统的开销，降低了效率。如果线程是 IO 密集型的，那么多个线程同时运行可以利用 CPU 在等待 IO 时的空闲时间，提高了效率。</p>\n<p>因此，<strong>对于单核 CPU 来说，如果任务是 CPU 密集型的，那么多线程会影响效率；如果任务是 IO 密集型的，那么多线程会提高效率</strong>。当然，这里的 “多” 也要适度，不能超过系统能够承受的上限。</p>\n<h1 id=\"线程\"><a class=\"anchor\" href=\"#线程\">#</a> 线程</h1>\n<h2 id=\"线程的创建方式\"><a class=\"anchor\" href=\"#线程的创建方式\">#</a> 线程的创建方式</h2>\n<h3 id=\"继承-thread-类\"><a class=\"anchor\" href=\"#继承-thread-类\">#</a> 继承 Thread 类</h3>\n<p>Thread 创建线程方式：创建线程类，匿名内部类方式</p>\n<ul>\n<li><strong>start () 方法底层其实是给 CPU 注册当前线程，并且触发 run () 方法执行</strong></li>\n<li>线程的启动必须调用 start () 方法，如果线程直接调用 run () 方法，相当于变成了普通类的执行，此时主线程将只有执行该线程</li>\n<li>建议线程先创建子线程，主线程的任务放在之后，否则主线程（main）永远是先执行完</li>\n</ul>\n<p>Thread 构造器：</p>\n<ul>\n<li><code>public Thread()</code></li>\n<li><code>public Thread(String name)</code></li>\n</ul>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">ThreadDemo</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>        <span class=\"token class-name\">Thread</span> t <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">MyThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>        t<span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>       \t<span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">100</span> <span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span> <span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>            <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"main线程\"</span> <span class=\"token operator\">+</span> i<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>        <span class=\"token comment\">//main 线程输出放在上面 就变成有先后顺序了，因为是 main 线程驱动的子线程运行</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token keyword\">class</span> <span class=\"token class-name\">MyThread</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Thread</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    <span class=\"token annotation punctuation\">@Override</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">100</span> <span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span> <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>            <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"子线程输出：\"</span><span class=\"token operator\">+</span>i<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>继承 Thread 类的优缺点：</p>\n<ul>\n<li>优点：编码简单</li>\n<li>缺点：线程类已经继承了 Thread 类，<font color='red'>无法继承其他类了</font>，功能不能通过继承拓展（单继承的局限性）</li>\n</ul>\n<h3 id=\"实现-runnable-接口\"><a class=\"anchor\" href=\"#实现-runnable-接口\">#</a> 实现 Runnable 接口</h3>\n<p>Runnable 创建线程方式：创建线程类，匿名内部类方式</p>\n<p>Thread 的构造器：</p>\n<ul>\n<li><code>public Thread(Runnable target)</code></li>\n<li><code>public Thread(Runnable target, String name)</code></li>\n</ul>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">ThreadDemo</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>        <span class=\"token class-name\">Runnable</span> target <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">MyRunnable</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>        <span class=\"token class-name\">Thread</span> t1 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span>target<span class=\"token punctuation\">,</span><span class=\"token string\">\"1号线程\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>\t\tt1<span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>        <span class=\"token class-name\">Thread</span> t2 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span>target<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//Thread-0</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">MyRunnable</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Runnable</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token annotation punctuation\">@Override</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">10</span> <span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span> <span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>            <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Thread</span><span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token string\">\"->\"</span> <span class=\"token operator\">+</span> i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p><strong>Thread 类本身也是实现了 Runnable 接口</strong>，Thread 类中持有 Runnable 的属性，执行线程 run 方法底层是调用 Runnable#run：</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Thread</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Runnable</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">private</span> <span class=\"token class-name\">Runnable</span> target<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    </pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>target <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>          \t<span class=\"token comment\">// 底层调用的是 Runnable 的 run 方法</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>            target<span class=\"token punctuation\">.</span><span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>Runnable 方式的优缺点：</p>\n<ul>\n<li>缺点：代码复杂一点。</li>\n<li>优点：\n<ol>\n<li>线程任务类只是实现了 Runnable 接口，可以继续继承其他类，<font color='red'>避免了单继承的局限性</font></li>\n<li>同一个线程任务对象可以被包装成多个线程对象</li>\n<li>适合多个线程去共享同一个资源</li>\n<li>实现解耦操作，线程任务代码可以被多个线程共享，<font color='red'>线程任务代码和线程独立</font></li>\n<li>线程池可以放入实现 Runnable 或 Callable 线程任务对象</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"实现-callable-接口\"><a class=\"anchor\" href=\"#实现-callable-接口\">#</a> 实现 Callable 接口</h3>\n<p>实现 Callable 接口：</p>\n<ol>\n<li>定义一个线程任务类实现 Callable 接口，声明线程执行的结果类型</li>\n<li>重写线程任务类的 call 方法，这个方法可以直接返回执行的结果</li>\n<li>创建一个 Callable 的线程任务对象</li>\n<li>把 Callable 的线程任务对象<strong>包装成一个 FutureTask 对象</strong></li>\n<li>把 FutureTask 对象包装成 Thread 对象</li>\n<li>调用线程的 start () 方法启动线程</li>\n</ol>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">ThreadDemo</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>        <span class=\"token class-name\">Callable</span> call <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">MyCallable</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>        <span class=\"token class-name\">FutureTask</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">></span></span> task <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">FutureTask</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span>call<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>        <span class=\"token class-name\">Thread</span> t <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span>task<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>        t<span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>        <span class=\"token keyword\">try</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>            <span class=\"token class-name\">String</span> s <span class=\"token operator\">=</span> task<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 获取 call 方法返回的结果（正常 / 异常结果）</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>            <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span>  <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Exception</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>            e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre></pre></td></tr><tr><td data-num=\"15\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">MyCallable</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Callable</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">></span></span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>    <span class=\"token annotation punctuation\">@Override</span><span class=\"token comment\">// 重写线程任务类方法</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token class-name\">String</span> <span class=\"token function\">call</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">Exception</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>        <span class=\"token keyword\">return</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token string\">\"->\"</span> <span class=\"token operator\">+</span> <span class=\"token string\">\"Hello World\"</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p><code>public FutureTask(Callable&lt;V&gt; callable)</code> ：未来任务对象，在线程执行完后得到线程的执行结果</p>\n<ul>\n<li>FutureTask 就是 Runnable 对象，因为 <strong>Thread 类只能执行 Runnable 实例的任务对象</strong>，所以把 Callable 包装成未来任务对象</li>\n<li>线程池部分详解了 FutureTask 的源码</li>\n</ul>\n<p><code>public V get()</code> ：同步等待 task 执行完毕的结果，如果在线程中获取另一个线程执行结果，会阻塞等待，用于线程同步</p>\n<ul>\n<li>get () 线程会阻塞等待任务执行完成</li>\n<li>run () 执行完后会把结果设置到 FutureTask 的一个成员变量，get () 线程可以获取到该变量的值</li>\n</ul>\n<p>优缺点：</p>\n<ul>\n<li>优点：同 Runnable，并且<font color='red'>能得到线程执行的结果</font></li>\n<li>缺点：编码复杂</li>\n</ul>\n<h3 id=\"runnable-和-callable-的区别\"><a class=\"anchor\" href=\"#runnable-和-callable-的区别\">#</a> Runnable 和 Callable 的区别？</h3>\n<ol>\n<li>接口类型：Runnable 是一个接口类型，而 Callable 是一个<font color='red'>通用接口类型</font>。</li>\n<li>返回值：Runnable 接口的 run () 方法没有返回值，它只能执行某个任务。Callable 接口的<font color='red'> call () 方法可以返回一个结果</font>。</li>\n<li>异常处理：Runnable 接口的 run () 方法不能抛出任何已检查异常，而 Callable 接口的<font color='red'> call () 方法可以抛出异常</font>。</li>\n<li>使用方式：Runnable 接口通常用于创建多线程任务，它不能直接返回结果或抛出异常。Callable 接口通常用于创建线程任务，它可以返回结果或抛出异常。</li>\n<li>多线程执行返回的结果：Runnable 接口无法直接获取执行结果，而<font color='red'> Callable 接口通过 Future 接口的 get () 方法可以获取线程执行的结果</font>。</li>\n</ol>\n<h2 id=\"thread-类的常用-api\"><a class=\"anchor\" href=\"#thread-类的常用-api\">#</a> Thread 类的常用 API</h2>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>public void  <code>start()</code></td>\n<td><strong>启动一个新线程，Java 虚拟机调用此线程的 run () 方法</strong></td>\n</tr>\n<tr>\n<td>public void  <code>run()</code></td>\n<td>线程启动后，调用该方法</td>\n</tr>\n<tr>\n<td>public void  <code>setName(String name)</code></td>\n<td>给当前线程取名字</td>\n</tr>\n<tr>\n<td>public void  <code>getName()</code></td>\n<td>获取当前线程的名字。线程存在默认名称：子线程是 Thread - 索引，主线程是 main</td>\n</tr>\n<tr>\n<td>public final int  <code>getPriority()</code></td>\n<td>返回此线程的优先级</td>\n</tr>\n<tr>\n<td>public final void  <code>setPriority(int priority)</code></td>\n<td>更改此线程的优先级，常用 1 5 10</td>\n</tr>\n<tr>\n<td>public void  <code>interrupt()</code></td>\n<td>中断这个线程，异常处理机制</td>\n</tr>\n<tr>\n<td>public boolean  <code>isInterrupted()</code></td>\n<td>判断当前线程是否被打断，不清除打断标记</td>\n</tr>\n<tr>\n<td>public final void  <code>join()</code></td>\n<td>等待这个线程结束</td>\n</tr>\n<tr>\n<td>public final void  <code>join(long millis)</code></td>\n<td>等待这个线程死亡 millis 毫秒，0 意味着永远等待</td>\n</tr>\n<tr>\n<td>public final native boolean  <code>isAlive()</code></td>\n<td>线程是否存活（还没有运行完毕）</td>\n</tr>\n<tr>\n<td>public final void  <code>setDaemon(boolean on)</code></td>\n<td>将此线程标记为守护线程或用户线程</td>\n</tr>\n<tr>\n<td>public <strong>static</strong> boolean  <code>interrupted()</code></td>\n<td>判断当前线程是否被打断，清除打断标记</td>\n</tr>\n<tr>\n<td>public <strong>static</strong> Thread  <code>currentThread()</code></td>\n<td>获取当前线程对象</td>\n</tr>\n<tr>\n<td>public <strong>static</strong> void  <code>sleep(long time)</code></td>\n<td>让当前线程休眠 time 毫秒，同时让出 CPU 时间片。<strong>Thread.sleep(0)</strong> : 让操作系统立刻重新进行一次 CPU 竞争</td>\n</tr>\n<tr>\n<td>public <strong>static</strong> native void  <code>yield()</code></td>\n<td>提示线程调度器<strong>让出当前线程对 CPU 的使用</strong></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"start-与-run\"><a class=\"anchor\" href=\"#start-与-run\">#</a> start () 与 run ()</h3>\n<p><strong>直接调用  <code>start()</code>  方法的话，可启动新的线程（进入 Runnable 状态），通过新线程间接执行  <code>run()</code>  方法。</strong></p>\n<p><strong>直接调用  <code>run()</code>  方法的话，是在 main 线程下作为普通方法执行，不会启动新线程。</strong></p>\n<p>run () 方法中的异常不能抛出，只能 try/catch</p>\n<ul>\n<li>因为父类中没有抛出任何异常，子类不能比父类抛出更多的异常</li>\n<li><strong>异常不能跨线程传播回 main () 中</strong>，因此必须在本地进行处理</li>\n</ul>\n<h3 id=\"sleep-与-yield\"><a class=\"anchor\" href=\"#sleep-与-yield\">#</a> sleep () 与 yield ()</h3>\n<p>sleep：</p>\n<ul>\n<li>调用 sleep 会让当前线程从  <code>Running</code>  进入  <code>Timed Waiting</code>  状态（计时等待）</li>\n<li>sleep () 方法的过程中，<strong>线程不会释放对象锁</strong></li>\n<li>其它线程可以使用 interrupt 方法打断正在睡眠的线程，这时 sleep 方法会抛出 InterruptedException</li>\n<li><font color='red'>睡眠结束后的线程未必会立刻得到执行，需要抢占 CPU</font></li>\n<li>建议用 TimeUnit 的 sleep 代替 Thread 的 sleep 来获得更好的可读性</li>\n</ul>\n<p>yield：</p>\n<ul>\n<li>调用 yield 会让提示线程调度器<font color='red'>让出当前线程对 CPU 的使用</font></li>\n<li>具体的实现依赖于操作系统的任务调度器</li>\n<li><strong>会放弃 CPU 资源，但不会释放锁资源</strong></li>\n</ul>\n<h3 id=\"sleep-与-wait\"><a class=\"anchor\" href=\"#sleep-与-wait\">#</a> sleep () 与 wait ()</h3>\n<p>共同点：两者都可以暂停线程的执行。</p>\n<p>区别：</p>\n<ul>\n<li><strong> <code>sleep()</code>  方法没有释放锁，而  <code>wait()</code>  方法释放了锁</strong>。</li>\n<li><font color='red'> <code>wait()</code>  通常被用于线程间交互 / 通信， <code>sleep()</code>  通常被用于暂停执行</font>。</li>\n<li><code>wait()</code>  方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的  <code>notify()</code>  或者  <code>notifyAll()</code>  方法。 <code>sleep()</code>  方法执行完成后，线程会自动苏醒，或者也可以使用  <code>wait(long timeout)</code>  超时后线程会自动苏醒。</li>\n<li><font color='red'> <code>sleep()</code>  是  <code>Thread</code>  类的静态本地方法， <code>wait()</code>  则是  <code>Object</code>  类的本地方法</font></li>\n</ul>\n<h2 id=\"说说线程的生命周期和状态\"><a class=\"anchor\" href=\"#说说线程的生命周期和状态\">#</a> 说说线程的生命周期和状态？</h2>\n<p>在  <code>java.lang.Thread.State</code>  这个枚举类中给出了 Java 线程的六种线程状态：</p>\n<table>\n<thead>\n<tr>\n<th>线程状态</th>\n<th>导致状态发生条件</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><font color='cornflowerblue'>NEW（初始）</font></td>\n<td>线程刚被创建，但还没有调用  <code>start()</code>  。只有线程对象，没有线程特征。</td>\n</tr>\n<tr>\n<td><font color='cornflowerblue'>RUNNABLE（运行）</font></td>\n<td>线程调用了  <code>start()</code>  ，可能正在运行，也可能在等待运行，这取决于操作系统处理器。</td>\n</tr>\n<tr>\n<td><font color='cornflowerblue'>BLOCKED（锁阻塞）</font></td>\n<td>需要等待锁释放。当一个线程试图获取一个对象锁，而该对象锁被其他的线程持有，则该线程进入 Blocked 状态；当该线程持有锁时，该线程将变成 Runnable 状态。</td>\n</tr>\n<tr>\n<td><font color='cornflowerblue'>WAITING（无限等待）</font></td>\n<td>表示该线程需要等待其他线程做出一些特定动作（通知或中断）。一个线程在等待另一个线程时，该线程进入 Waiting 状态，进入这个状态后不能自动唤醒，必须等待另一个线程调用 notify 或者 notifyAll 方法才能唤醒。</td>\n</tr>\n<tr>\n<td><font color='cornflowerblue'>TIME_WAITING（计时等待）</font></td>\n<td>可以在指定的时间后自行返回，而不是像 WAITING 那样一直等待。有几个方法有超时参数，调用将进入 Timed Waiting 状态，这一状态将一直保持到超时期满或者接收到唤醒通知。带有超时参数的常用方法有 Thread.sleep 、Object.wait</td>\n</tr>\n<tr>\n<td><font color='cornflowerblue'>TERMINATED（终止）</font></td>\n<td>表示该线程已经运行完毕。run 方法正常退出而死亡，或者因为没有捕获的异常终止了 run 方法而死亡。</td>\n</tr>\n</tbody>\n</table>\n<p>Java 线程状态转移图：</p>\n<blockquote>\n<p>图源：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvVU9yWHFsX0xoT0Q4ZGhUcV9FUEkwdw==\">挑错 |《Java 并发编程的艺术》中关于线程状态的三处错误</span></p>\n</blockquote>\n<p><img data-src=\"https://oss.javaguide.cn/github/javaguide/java/concurrent/640.png\" alt=\"Java 线程状态变迁图\" /></p>\n<p>由上图可以看出：线程创建之后它将处于 <strong>NEW（新建）</strong> 状态，调用  <code>start()</code>  方法后开始运行，线程这时候处于 <strong>READY（可运行）</strong> 状态。可运行状态的线程获得了 CPU 时间片（timeslice）后就处于 <strong>RUNNING（运行）</strong> 状态。</p>\n<ul>\n<li>\n<p>当线程执行  <code>wait()</code>  方法之后，线程进入 <strong>WAITING（无限等待）</strong> 状态，需要依靠其他线程的通知才能够返回到 RUNNABLE 状态。</p>\n</li>\n<li>\n<p><strong>TIMED_WAITING (计时等待)</strong> 状态相当于在 WAITING 状态的基础上增加了超时限制，比如通过  <code>sleep（long millis）</code> 方法或  <code>wait（long millis）</code> 方法可以将线程置于 TIMED_WAITING 状态。当超时时间结束后，线程将会返回到 RUNNABLE 状态。</p>\n</li>\n<li>\n<p>当线程进入  <code>synchronized</code>  方法 / 块或者调用  <code>wait</code>  后（被  <code>notify</code> ）重新进入  <code>synchronized</code>  方法 / 块，但是锁被其它线程占有，这个时候线程就会进入 <strong>BLOCKED（锁阻塞）</strong> 状态。</p>\n</li>\n<li>\n<p>线程在执行完了  <code>run()</code>  方法之后将会进入到 <strong>TERMINATED（终止）</strong> 状态。</p>\n</li>\n</ul>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20220524203355448.png\" alt=\"image-20220524203355448\" /></p>\n<h2 id=\"什么是线程上下文切换\"><a class=\"anchor\" href=\"#什么是线程上下文切换\">#</a> 什么是线程上下文切换？</h2>\n<p>线程在执行过程中会有自己的运行条件和状态（也称上下文），在上下文切换过程中，需要保存和恢复的资源包括：</p>\n<ul>\n<li><font color='cornflowerblue'>寄存器</font></li>\n<li><font color='cornflowerblue'>程序计数器（PC）</font>：保存当前任务执行的下一条指令的地址，以便在切换回来时继续执行。</li>\n<li><font color='cornflowerblue'>栈指针（SP）</font></li>\n<li><font color='cornflowerblue'>内存管理单元（MMU）</font>：保存当前任务的页表、段表等内存管理信息，以便在切换回来时继续使用该任务的内存映射。</li>\n<li><font color='cornflowerblue'>文件描述符表</font></li>\n<li><font color='cornflowerblue'>环境变量</font></li>\n</ul>\n<p>当出现如下情况的时候，线程会从占用 CPU 状态中退出：</p>\n<ul>\n<li>主动让出 CPU，比如调用了  <code>sleep()</code> ,  <code>wait()</code>  等。</li>\n<li>时间片用完，因为操作系统要防止一个线程或者进程长时间占用 CPU 导致其他线程或者进程饿死。</li>\n<li>调用了阻塞类型的系统中断，比如请求 IO，线程被阻塞。</li>\n<li>被终止或结束运行。</li>\n</ul>\n<p>这其中前三种都会发生线程切换，线程切换意味着<strong>需要保存当前线程的上下文，留待线程下次占用 CPU 时恢复现场。并加载下一个将要占用 CPU 的线程上下文</strong>。这就是所谓的上下文切换。</p>\n<p>上下文切换是现代操作系统的基本功能，因其每次需要保存信息恢复信息，这将会占用 CPU，内存等系统资源进行处理，也就意味着效率会有一定损耗，<font color='red'>如果频繁切换就会造成整体效率低下</font>。</p>\n<h2 id=\"什么是线程死锁\"><a class=\"anchor\" href=\"#什么是线程死锁\">#</a> 什么是线程死锁？</h2>\n<blockquote>\n<p>面试题：<span class=\"exturl\" data-url=\"aHR0cHM6Ly90b3AuaW50ZXJ2aWV3Z3VpZGUuY24vaXNzdWUvMzAz\">说说你了解的死锁？包括死锁产生原因、必要条件、处理方法、死锁恢复以及死锁预防等（死锁相关问题大总结，超全！）</span></p>\n</blockquote>\n<p>线程死锁描述的是这样一种情况：多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。</p>\n<p>如下图所示，线程 A 持有资源 2，线程 B 持有资源 1，他们同时都想申请对方的资源，所以<strong>这两个线程就会互相等待，而进入死锁状态</strong>。</p>\n<p><img data-src=\"https://oss.javaguide.cn/github/javaguide/java/2019-4%E6%AD%BB%E9%94%811.png\" alt=\"线程死锁示意图 \" /></p>\n<h3 id=\"死锁产生的原因\"><a class=\"anchor\" href=\"#死锁产生的原因\">#</a> 死锁产生的原因</h3>\n<p>理论上认为死锁产生有以下四个必要条件，缺一不可：</p>\n<ol>\n<li><strong>互斥</strong>：该资源任意一个时刻只由一个线程占用。</li>\n<li><strong>请求并保持</strong>：一个线程因请求资源而阻塞时，对已获得的资源保持不放。</li>\n<li><strong>不剥夺</strong>：线程已获得的资源在未使用完之前，不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。</li>\n<li><strong>循环等待</strong>：若干线程之间形成一种头尾相接的循环等待资源关系。</li>\n</ol>\n<h3 id=\"如何预防-避免死锁\"><a class=\"anchor\" href=\"#如何预防-避免死锁\">#</a> 如何预防、避免死锁？</h3>\n<p><font color='red'>如何预防死锁？</font>破坏死锁的产生的必要条件即可：</p>\n<ol>\n<li>破坏请求并保持条件：<strong>一次性申请所有的资源</strong>。</li>\n<li>破坏不剥夺条件：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以<strong>主动释放自身占有的资源</strong>。</li>\n<li>破坏循环等待条件：靠<strong>按序申请资源</strong>来预防。按某一顺序申请资源，释放资源则反序释放。</li>\n</ol>\n<p><font color='red'>如何避免死锁？</font>避免死锁就是<strong>在资源分配时，借助于算法（比如银行家算法）对资源分配进行计算评估，使其进入安全状态</strong>。</p>\n<blockquote>\n<p><strong>安全状态</strong>：指的是系统能够按照某种线程推进顺序（P1、P2、P3.....Pn）来为每个线程分配所需资源，直到<font color='red'>满足每个线程对资源的最大需求，使每个线程都可顺利完成</font>。称  <code>&lt;P1、P2、P3.....Pn&gt;</code>  序列为安全序列。</p>\n</blockquote>\n<h2 id=\"为什么-wait-定义在-object-类中而不是-thread-类中\"><a class=\"anchor\" href=\"#为什么-wait-定义在-object-类中而不是-thread-类中\">#</a> 为什么 wait () 定义在 Object 类中，而不是 Thread 类中？</h2>\n<p><strong> <code>wait()</code>  是让获得对象锁的线程实现等待，会自动释放当前线程占有的对象锁</strong>。每个对象（ <code>Object</code> ）都拥有对象锁，既然要释放当前线程占有的对象锁，并让其进入 WAITING 状态，自然是要操作对应的对象（ <code>Object</code> ）而非当前的线程（ <code>Thread</code> ）。</p>\n<p>类似的问题：为什么  <code>sleep()</code>  方法定义在  <code>Thread</code>  中？</p>\n<p>因为 <strong> <code>sleep()</code>  是让当前线程暂停执行，不涉及到对象类，也不需要获得对象锁</strong>。</p>\n<h2 id=\"可以直接调用-thread-类的-run-吗\"><a class=\"anchor\" href=\"#可以直接调用-thread-类的-run-吗\">#</a> 可以直接调用 Thread 类的 run () 吗？</h2>\n<p>new 一个  <code>Thread</code> ，线程进入了新建状态。调用  <code>start()</code>  方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。<font color='red'>  <code>start()</code>  会执行线程的相应准备工作，然后自动执行  <code>run()</code>  方法的内容</font>，这是真正的多线程工作。但是，<font color='red'>直接执行  <code>run()</code>  方法，会把  <code>run()</code>  方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它</font>，所以这并不是多线程工作。</p>\n<p>总结：</p>\n<ul>\n<li><strong>直接调用  <code>start()</code>  方法的话，可启动新的线程（进入 Runnable 状态），通过新线程间接执行  <code>run()</code>  方法。</strong></li>\n<li><strong>直接调用  <code>run()</code>  方法的话，是在 main 线程下作为普通方法执行，不会启动新线程。</strong></li>\n</ul>\n<h1 id=\"同步\"><a class=\"anchor\" href=\"#同步\">#</a> 同步</h1>\n<h2 id=\"临界区\"><a class=\"anchor\" href=\"#临界区\">#</a> 临界区</h2>\n<p><font color='cornflowerblue'>临界资源</font>：一次仅允许一个进程使用的资源成为临界资源</p>\n<p><font color='cornflowerblue'>临界区</font>：访问临界资源的代码块</p>\n<p><font color='cornflowerblue'>竞态条件</font>：多个线程在临界区内执行，由于代码的执行序列不同而导致结果无法预测，称之为发生了竞态条件</p>\n<p>一个程序运行多个线程是没有问题，多个线程读共享资源也没有问题，<font color='red'>在多个线程对共享资源读写操作时发生指令交错，就会出现问题</font></p>\n<p>为了避免临界区的竞态条件发生（解决线程安全问题）：</p>\n<ul>\n<li>阻塞式的解决方案：synchronized，lock</li>\n<li>非阻塞式的解决方案：原子变量</li>\n</ul>\n<p><font color='cornflowerblue'>管程（monitor）</font>：也称监视器，指的是<font color='red'>管理共享变量以及对共享变量的操作过程，让它们支持并发</font>。翻译为 Java 就是 **<font color='red'>管理类的成员变量和成员方法，让这个类是线程安全的</font>**。实现了<font color='red'>同一时刻，只有一个线程在执行管程的某个子程序</font>。</p>\n<p><strong>synchronized：对象锁，保证了临界区内代码的原子性</strong>，采用互斥的方式让同一时刻至多只有一个线程能持有对象锁，其它线程获取这个对象锁时会阻塞，保证拥有锁的线程可以安全的执行临界区内的代码，不用担心线程上下文切换。</p>\n<p>互斥和同步都可以采用 synchronized 关键字来完成，区别：</p>\n<ul>\n<li><font color='cornflowerblue'>互斥</font>：同一时刻只能有一个线程执行临界区代码</li>\n<li><font color='cornflowerblue'>同步</font>：是由于线程执行的先后、顺序不同，需要一个线程等待其它线程运行到某个点</li>\n</ul>\n<p>性能：</p>\n<ul>\n<li>线程安全：性能差</li>\n<li>线程不安全：性能好，假如开发中不会存在多线程安全问题，建议使用线程不安全的设计类</li>\n</ul>\n<hr />\n<blockquote>\n<p>以下内容，参考《<span class=\"exturl\" data-url=\"aHR0cDovL3huLS1KVk0tbnE2aHUyMmUubWQ=\">JVM 笔记.md</span>》的第五章</p>\n</blockquote>\n<h2 id=\"乐观锁和悲观锁\"><a class=\"anchor\" href=\"#乐观锁和悲观锁\">#</a> 乐观锁和悲观锁</h2>\n<h3 id=\"数据库悲观锁和乐观锁的原理和应用场景分别有什么\"><a class=\"anchor\" href=\"#数据库悲观锁和乐观锁的原理和应用场景分别有什么\">#</a> 数据库悲观锁和乐观锁的原理和应用场景分别有什么？</h3>\n<ul>\n<li>\n<p><font color='cornflowerblue'>悲观锁</font>：<strong>先获取锁，再进行业务操作</strong>。例如  <code>synchronized</code>  和  <code>ReentrantLock</code> 。一般就是利用类似 SELECT … FOR UPDATE 这样的语句，对数据加锁，避免其他事务意外修改数据。<br />\n当数据库执行 SELECT … FOR UPDATE 时会获取被 select 中的数据行的行锁， select for update 获取的行锁会在当前事务结束时自动释放，因此必须在事务中使用。</p>\n</li>\n<li>\n<p><font color='cornflowerblue'>乐观锁</font>：<strong>先进行业务操作，只在最后实际更新数据时检查数据是否被更新过</strong>。Java 并发包中的 AtomicFieldUpdater 类似，也是利用 CAS 机制，并不会对数据加锁，而是通过对比数据的时间戳或者版本号，来实现乐观锁需要的版本判断。</p>\n</li>\n</ul>\n<h2 id=\"synchronized-关键字\"><a class=\"anchor\" href=\"#synchronized-关键字\">#</a> synchronized 关键字</h2>\n<blockquote>\n<p><strong>独占锁</strong>（悲观锁）</p>\n</blockquote>\n<h3 id=\"为什么把-jdk-16-之前的-synchronized-称为重量级锁\"><a class=\"anchor\" href=\"#为什么把-jdk-16-之前的-synchronized-称为重量级锁\">#</a> 为什么把 JDK 1.6 之前的 synchronized 称为重量级锁？</h3>\n<ol>\n<li>JDK 1.6 之前的 synchronized 是重量级锁主要是因为：其实现方式会导致性能上的较大损耗。</li>\n<li>在 JDK 1.6 之前，synchronized 关键字<strong>使用的是对象级别的锁</strong>，即每个对象都有一个相关的锁。<strong>在获取和释放锁的过程中需要进行用户态和内核态的切换，这个切换的代价比较高，消耗的时间比较多</strong>，因此被称为重量级锁。</li>\n<li>在 JDK 1.6 之前的 synchronized <strong>在获取锁时使用的是互斥量（Mutex）来实现，这是一种悲观锁，即当某个线程获取了锁之后，其他的线程将被阻塞，直到该线程释放锁</strong>。这种阻塞和唤醒线程的操作需要操作系统层面的支持，因此会有较高的开销。</li>\n<li>另外，JDK 1.6 之前的 synchronized 的实现没有进行优化，每一次锁的获取和释放都需要进行同步操作，无法做到细粒度的控制，导致锁的粒度较大，同一时间只能一个线程访问被锁定的代码块，效率较低。</li>\n</ol>\n<p>因此，JDK 1.6 之前的 synchronized 被称为重量级锁，主要是因为它在性能和资源消耗方面存在一些不足之处。不过随着 JDK 的不断更新，synchronized 的实现方式得到了改善，JDK 1.6 之后引入了偏向锁、轻量级锁等优化措施，使得 synchronized 的性能也得到了提升。</p>\n<h3 id=\"synchronized-锁升级过程偏向锁-轻量级锁-重量级锁\"><a class=\"anchor\" href=\"#synchronized-锁升级过程偏向锁-轻量级锁-重量级锁\">#</a> synchronized 锁升级过程（偏向锁、轻量级锁、重量级锁）</h3>\n<ol>\n<li><font color='cornflowerblue'>偏向锁</font>：</li>\n</ol>\n<ul>\n<li>在锁对象初始化时，对象头中的 Mark Word 会记录当前线程 ID，表示该锁对象偏向于该线程。</li>\n<li>当另一个线程也尝试获取这个锁对象时，会检查该对象头的 Mark Word，\n<ul>\n<li>如果记录的线程 ID 是自己，表示可以直接获取锁。</li>\n<li>如果记录的线程 ID 不是自己，会<strong>撤销偏向锁，升级为轻量级锁</strong>。</li>\n</ul>\n</li>\n</ul>\n<ol start=\"2\">\n<li><font color='cornflowerblue'>轻量级锁</font>：</li>\n</ol>\n<ul>\n<li>当多个线程尝试获取锁对象时，JVM 会为参与竞争的各个线程的栈帧中各自分配 ** 锁记录（ <code>Lock Record</code> ）** 空间，并将锁对象的 Mark Word 拷贝到其中，称为  <code>Displaced Mark Word</code> 。</li>\n<li>然后，一个线程使用 CAS 操作尝试将对象头的 Mark Word 替换为指向自己线程栈帧中的锁记录的指针。\n<ul>\n<li>如果 CAS 成功，表示获取锁成功。</li>\n<li>如果 CAS 失败，那么当前线程也不会阻塞，而是通过<strong>自旋</strong>的方式不断尝试获取锁，当达到一定次数仍未获得锁时，会进一步<strong>膨胀为重量级锁</strong>。</li>\n</ul>\n</li>\n</ul>\n<ol start=\"3\">\n<li><font color='cornflowerblue'>重量级锁</font>：</li>\n</ol>\n<ul>\n<li>当一个线程尝试获取对象锁时，发现对象已经是轻量级锁状态，但是锁的拥有者不是自己时，此时线程会进入<strong> BLOCKED（锁阻塞）状态</strong>，开始<strong>锁膨胀</strong>流程。</li>\n<li>升级为重量级锁时，虚拟机会在操作系统层面申请一个 ** 互斥量（Mutex）** 来保护整个对象。</li>\n<li>获取重量级锁失败的线程将会进入阻塞状态，只有当拥有锁的线程释放锁后，其他线程才有机会获取锁。</li>\n</ul>\n<p>需要注意的是，锁的升级过程中是逐级升级的，即从<strong>偏向锁 -&gt; 轻量级锁 -&gt; 重量级锁</strong>。而且<strong>锁只能升级，不能降级</strong>。这是为了防止频繁锁的请求和释放造成的性能损耗。</p>\n<h1 id=\"内存\"><a class=\"anchor\" href=\"#内存\">#</a> 内存</h1>\n<h2 id=\"java-内存模型jmm\"><a class=\"anchor\" href=\"#java-内存模型jmm\">#</a> Java 内存模型（JMM）</h2>\n<h2 id=\"volatile-关键字\"><a class=\"anchor\" href=\"#volatile-关键字\">#</a> volatile 关键字</h2>\n<h3 id=\"volatile实现什么能力怎么实现的\"><a class=\"anchor\" href=\"#volatile实现什么能力怎么实现的\">#</a> volatile 实现什么能力，怎么实现的？</h3>\n<ul>\n<li><strong>能保证变量的可见性</strong>：如果我们将变量声明为  <code>volatile</code> ，表明这个变量是共享且不稳定的，<font color='red'>每次读写都强制发生在主内存中</font>。</li>\n<li><strong>禁止指令重排</strong>：当一个变量被  <code>volatile</code>  修饰时，编译器和处理器会禁止对其进行指令重排，从而保证程序的正确性。</li>\n</ul>\n<h2 id=\"happens-before-原则\"><a class=\"anchor\" href=\"#happens-before-原则\">#</a> happens-before 原则</h2>\n<h1 id=\"无锁\"><a class=\"anchor\" href=\"#无锁\">#</a> 无锁</h1>\n<h2 id=\"cas\"><a class=\"anchor\" href=\"#cas\">#</a> CAS</h2>\n<h2 id=\"atomic-原子类\"><a class=\"anchor\" href=\"#atomic-原子类\">#</a> Atomic 原子类</h2>\n<ol>\n<li>\n<p><strong>Atomic 原子类是  <code>Java.util.concurrent</code>  包中的一个类，用于提供<u>线程安全</u>的<u>原子操作</u></strong>。</p>\n</li>\n<li>\n<p>Atomic 原子类可以保证在多线程环境下对变量的原子操作，即操作过程不会被其他线程中断，从而避免了竞态条件的发生。</p>\n</li>\n<li>\n<p>Atomic 原子类<font color='red'>提供了一系列的方法，可以对变量进行读取、写入、比较并设置等操作</font>，如 get、set、compareAndSet 等。</p>\n</li>\n<li>\n<p>Atomic 原子类<font color='red'>支持不同的数据类型</font>，</p>\n<ul>\n<li><font color='cornflowerblue'>基本类型</font>的原子类： <code>AtomicInteger</code> （整型）、 <code>AtomicLong</code> （长整型）、 <code>AtomicBoolean</code> （布尔型）</li>\n<li><font color='cornflowerblue'>数组类型</font>的原子类： <code>AtomicIntegerArray</code> （整型数组）、 <code>AtomicLongArray</code> （长整型数组）、 <code>AtomicReferenceArray</code> （引用类型数组）</li>\n<li><font color='cornflowerblue'>引用类型</font>的原子类： <code>AtomicReference</code> （引用类型）、 <code>AtomicStampedReference</code> （原子更新带有版本号的引用类型）、 <code>AtomicMarkableReference</code> （原子更新带有标记的引用类型）</li>\n</ul>\n</li>\n<li>\n<p>Atomic 原子类的内部实现<strong>基于 CAS（Compare-and-Swap）算法</strong>，该算法<font color='red'>通过比较内存中的值与期望值是否一致来判断是否更新</font>。</p>\n</li>\n<li>\n<p>Atomic 原子类的使用场景包括计数器、线程安全的累加器、标志位的设置等。</p>\n</li>\n<li>\n<p>Atomic 原子类 **<font color='red'>在高并发场景下可以提高性能，避免了使用锁造成的线程等待和上下文切换的开销</font>**。</p>\n</li>\n</ol>\n<h2 id=\"threadlocal-类\"><a class=\"anchor\" href=\"#threadlocal-类\">#</a> ThreadLocal 类</h2>\n<img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/1-af0577dc.png\" alt=\"img\"  />\n<h3 id=\"有什么用\"><a class=\"anchor\" href=\"#有什么用\">#</a> 有什么用？</h3>\n<p><strong> <code>ThreadLocal</code>  类可以让每个线程拥有自己单独的变量副本，分配在堆内的 TLAB 中，使得每个线程中的变量相互独立，从而保证线程安全。</strong></p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/68747470733a2f2f7365617a65616e2e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f696d672f4a6176612f4a564d2d4a617661382545352538362538352545352541442539382545372542422539332545362539452538342545352539422542452e706e67\" alt=\"img\" /></p>\n<p><font color='red'> <code>ThreadLocal</code>  变量是 private static 类型的，访问这个变量的每个线程都会在 TLAB 中存储这个变量的本地副本，所以是线程安全的</font>。他们可以使用  <code>get()</code>  和  <code>set()</code>  方法来获取默认值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题。</p>\n<h3 id=\"如何使用\"><a class=\"anchor\" href=\"#如何使用\">#</a> 如何使用？</h3>\n<p>下面简单演示一下如何在项目中实际使用  <code>ThreadLocal</code>  。</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">java<span class=\"token punctuation\">.</span>text<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">SimpleDateFormat</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">java<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">Random</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">ThreadLocalExample</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Runnable</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>     <span class=\"token comment\">// SimpleDateFormat 不是线程安全的，所以每个线程都要有自己独立的副本</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">ThreadLocal</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">SimpleDateFormat</span><span class=\"token punctuation\">></span></span> formatter <span class=\"token operator\">=</span> <span class=\"token class-name\">ThreadLocal</span><span class=\"token punctuation\">.</span><span class=\"token function\">withInitial</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">SimpleDateFormat</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"yyyyMMdd HHmm\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">InterruptedException</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>        <span class=\"token class-name\">ThreadLocalExample</span> obj <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ThreadLocalExample</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i<span class=\"token operator\">=</span><span class=\"token number\">0</span> <span class=\"token punctuation\">;</span> i<span class=\"token operator\">&lt;</span><span class=\"token number\">10</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>            <span class=\"token class-name\">Thread</span> t <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">,</span> <span class=\"token string\">\"\"</span><span class=\"token operator\">+</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>            <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Random</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">nextInt</span><span class=\"token punctuation\">(</span><span class=\"token number\">1000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>            t<span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>    <span class=\"token annotation punctuation\">@Override</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Thread Name= \"</span><span class=\"token operator\">+</span><span class=\"token class-name\">Thread</span><span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">+</span><span class=\"token string\">\" default Formatter = \"</span><span class=\"token operator\">+</span>formatter<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toPattern</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>        <span class=\"token keyword\">try</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>            <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Random</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">nextInt</span><span class=\"token punctuation\">(</span><span class=\"token number\">1000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">InterruptedException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>            e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>        <span class=\"token comment\">//formatter pattern is changed here by thread, but it won't reflect to other threads</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>        formatter<span class=\"token punctuation\">.</span><span class=\"token function\">set</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">SimpleDateFormat</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Thread Name= \"</span><span class=\"token operator\">+</span><span class=\"token class-name\">Thread</span><span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">+</span><span class=\"token string\">\" formatter = \"</span><span class=\"token operator\">+</span>formatter<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toPattern</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre></pre></td></tr><tr><td data-num=\"32\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h3 id=\"原理\"><a class=\"anchor\" href=\"#原理\">#</a> 原理</h3>\n<p>从  <code>Thread</code>  类源代码入手。</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Thread</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Runnable</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token comment\">//......</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token comment\">// 与此线程有关的 ThreadLocal 值。由 ThreadLocal 类维护</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token class-name\">ThreadLocal<span class=\"token punctuation\">.</span>ThreadLocalMap</span> threadLocals <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token comment\">// 与此线程有关的 InheritableThreadLocal 值。由 InheritableThreadLocal 类维护</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token class-name\">ThreadLocal<span class=\"token punctuation\">.</span>ThreadLocalMap</span> inheritableThreadLocals <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token comment\">//......</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>从上面  <code>Thread</code>  类的源代码有<font color='red'>一个 threadLocals 变量和一个 inheritableThreadLocals 变量</font>，它们都是 <strong>ThreadLocalMap</strong> 类型的变量，可以理解为  <code>ThreadLocal</code>  类实现的定制化  <code>HashMap</code> 。</p>\n<ul>\n<li>默认情况下这两个变量都是 null</li>\n<li>只有当前线程调用  <code>ThreadLocal</code>  类的  <code>set()</code>  或  <code>get()</code>  方法时才创建它们，实际上调用的是  <code>ThreadLocalMap</code>  类对应的  <code>get()</code> 、 <code>set()</code>  方法。</li>\n</ul>\n<p><code>ThreadLocal</code>  类的 <code>set()</code>  方法</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">set</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">T</span> value<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token comment\">// 获取当前请求的线程</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token class-name\">Thread</span> t <span class=\"token operator\">=</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token comment\">// 取出 Thread 类内部的 threadLocals 变量 (哈希表结构)</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token class-name\">ThreadLocalMap</span> map <span class=\"token operator\">=</span> <span class=\"token function\">getMap</span><span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>map <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>        <span class=\"token comment\">// 将需要存储的值放入到这个哈希表中</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>        map<span class=\"token punctuation\">.</span><span class=\"token function\">set</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token keyword\">else</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>        <span class=\"token function\">createMap</span><span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">,</span> value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token class-name\">ThreadLocalMap</span> <span class=\"token function\">getMap</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Thread</span> t<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    <span class=\"token keyword\">return</span> t<span class=\"token punctuation\">.</span>threadLocals<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>结论：<strong>最终的变量是存放在当前线程的  <code>ThreadLocalMap</code>  中，而不是  <code>ThreadLocal</code>  上</strong>。</p>\n<ul>\n<li><code>ThreadLocal</code>  可以理解为只是  <code>ThreadLocalMap</code>  的封装，传递了变量值。</li>\n<li><code>ThrealLocal</code>  类中可以通过 <code>Thread.currentThread()</code>  获取到当前线程对象后，直接通过 <code>getMap(Thread t)</code>  可以访问到该线程的 <code>ThreadLocalMap</code>  对象。</li>\n</ul>\n<p><strong>每个 <code>Thread</code>  中都具备一个 <code>ThreadLocalMap</code> ，可以存储（key= <code>ThreadLocal</code>  对象，value= Object 对象）的键值对。</strong></p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token class-name\">ThreadLocalMap</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">ThreadLocal</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span><span class=\"token punctuation\">></span></span> firstKey<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Object</span> firstValue<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token comment\">//......</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>比如我们在同一个线程中声明了两个  <code>ThreadLocal</code>  对象的话，  <code>Thread</code>  内部都是使用仅有的那个  <code>ThreadLocalMap</code>  存放数据的，key 就是  <code>ThreadLocal</code>  对象，value 就是  <code>ThreadLocal</code>  对象调用 <code>set()</code>  方法设置的值。</p>\n<p><code>ThreadLocal</code>  数据结构如下图所示：</p>\n<p><img data-src=\"https://oss.javaguide.cn/github/javaguide/java/concurrent/threadlocal-data-structure.png\" alt=\"ThreadLocal 数据结构\" /></p>\n<p><code>ThreadLocalMap</code>  是  <code>ThreadLocal</code>  的静态内部类。</p>\n<p><img data-src=\"https://oss.javaguide.cn/github/javaguide/java/concurrent/thread-local-inner-class.png\" alt=\"ThreadLocal内部类\" /></p>\n<h3 id=\"内存泄露问题\"><a class=\"anchor\" href=\"#内存泄露问题\">#</a> 内存泄露问题</h3>\n<p><code>ThreadLocalMap</code>  中使用的<font color='red'> key 为  <code>ThreadLocal</code>  的弱引用</font>，而 value 是强引用。所以，如果  <code>ThreadLocal</code>  没有被外部强引用的情况下，<font color='red'>在垃圾回收的时候，key 会被清理掉</font>，而 value 不会被清理掉。这样一来， <code>ThreadLocalMap</code>  中就<font color='red'>会出现 key 为 null 的 Entry</font>。假如我们不做任何措施的话，<font color='red'>value 永远无法被 GC 回收</font>，这个时候就可能会产生<strong>内存泄露</strong>。</p>\n<p><code>ThreadLocalMap</code>  实现中已经考虑了这种情况，在调用  <code>set()</code> 、 <code>get()</code> 、 <code>remove()</code>  方法的时候，会清理掉 key 为 null 的记录。使用完  <code>ThreadLocal</code>  方法后最好手动调用  <code>remove()</code>  方法。</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">static</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Entry</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">WeakReference</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">ThreadLocal</span><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span><span class=\"token punctuation\">></span><span class=\"token punctuation\">></span></span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token comment\">/** The value associated with this ThreadLocal. */</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token class-name\">Object</span> value<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token class-name\">Entry</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">ThreadLocal</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span><span class=\"token punctuation\">></span></span> k<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Object</span> v<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>        <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>k<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>        value <span class=\"token operator\">=</span> v<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p><strong>弱引用介绍：</strong></p>\n<blockquote>\n<p>如果一个对象只具有弱引用，那就类似于<strong>可有可无的生活用品</strong>。弱引用与软引用的区别在于：<font color='red'>只具有弱引用的对象拥有更短暂的生命周期</font>。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，<font color='red'>不管当前内存空间足够与否，都会回收它的内存</font>。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。</p>\n<p>弱引用可以和一个<font color='red'>引用队列（ReferenceQueue）</font>联合使用，如果弱引用所引用的对象被垃圾回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p>\n</blockquote>\n<h3 id=\"你的理解小结\"><a class=\"anchor\" href=\"#你的理解小结\">#</a> 你的理解？（小结）</h3>\n<p>ThreadLocal 提供了一种方式，在多线程环境下，<strong>每个线程都可以独立地维护自己的变量副本，互不干扰</strong>。</p>\n<p>在多线程编程中，共享变量的访问可能会引发线程安全的问题。比如多个线程同时修改同一个变量，可能会导致数据不一致或者竞态条件等问题。而 ThreadLocal 则可以解决这个问题，它为每个线程提供了一个独立的变量副本，每个线程都可以访问和修改自己的变量副本，而不会影响其他线程的副本。这样就避免了多个线程之间的竞争和冲突。</p>\n<p>ThreadLocal 的工作原理是，<strong>在每个线程内部维护一个  <code>ThreadLocalMap</code> ，用于存储线程局部变量的副本，（key=ThreadLocal 对象，value=Object 对象）</strong>。</p>\n<p>当线程需要访问这个变量时，首先通过 ThreadLocal 对象获取当前线程的副本，如果不存在则创建一个新的副本，并存储到 Map 中。而<font color='red'>线程对变量的访问和修改都是通过 ThreadLocal 对象进行，保了线程间的隔离性</font>。</p>\n<p>ThreadLocal 的典型应用场景包括：</p>\n<ul>\n<li><font color='red'>数据库连接管理</font>：每个线程都可以拥有自己的数据库连接，避免了多个线程之间的数据库连接竞争和冲突。</li>\n<li><font color='red'>用户身份信息传递</font>：将用户身份信息存储在 ThreadLocal 中，可以在多个方法中方便地获取和传递，避免了显式地传递参数。</li>\n<li><font color='red'>事务管理</font>：将事务对象存储在 ThreadLocal 中，可以在多个方法中共享同一个事务，避免了事务对象的传递和管理。</li>\n</ul>\n<p>需要注意的是，使用 ThreadLocal 时<font color='red'>要注意及时清理资源，避免内存泄漏问题</font>。一般可以通过在 ThreadLocal 使用完毕后，调用  <code>remove()</code>  方法进行清理。</p>\n<h1 id=\"同步器\"><a class=\"anchor\" href=\"#同步器\">#</a> 同步器</h1>\n<h2 id=\"aqs-抽象类\"><a class=\"anchor\" href=\"#aqs-抽象类\">#</a> AQS 抽象类</h2>\n<h3 id=\"简介\"><a class=\"anchor\" href=\"#简介\">#</a> 简介</h3>\n<p>AQS 的全称为  <code>AbstractQueuedSynchronizer</code>  ，翻译过来的意思就是<font color='red'>抽象队列同步器</font>。这个类在  <code>java.util.concurrent.locks</code>  包下面。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/AQS.png\" alt=\"img\" /></p>\n<p>AQS 就是一个抽象类，主要用来<strong>简单且高效地构造出大量的同步器</strong>，<font color='red'>比如  <code>ReentrantLock</code> ， <code>Semaphore</code> ，其他的诸如  <code>ReentrantReadWriteLock</code> ， <code>SynchronousQueue</code>  等等皆是基于 AQS 的</font>。</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">abstract</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">AbstractQueuedSynchronizer</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">AbstractOwnableSynchronizer</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\"><span class=\"token namespace\">java<span class=\"token punctuation\">.</span>io<span class=\"token punctuation\">.</span></span>Serializable</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h3 id=\"底层原理\"><a class=\"anchor\" href=\"#底层原理\">#</a> 底层原理</h3>\n<h4 id=\"核心思想\"><a class=\"anchor\" href=\"#核心思想\">#</a> 核心思想</h4>\n<p>AQS 核心思想是：</p>\n<ul>\n<li>如果被请求的共享资源是<font color='gree'>空闲</font>的，则将当前请求资源的线程设置为有效的<font color='red'>工作线程</font>，并且将共享资源设置为<font color='red'>锁定状态</font>。</li>\n<li>如果被请求的共享资源<font color='gree'>被占用</font>了，那么就需要<font color='red'>一套线程阻塞等待以及被唤醒时锁分配的机制</font>，这个机制是基于 <strong>CLH 队列锁</strong> （Craig, Landin, and Hagersten locks） 实现的，即<font color='red'>将暂时获取不到锁的线程加入到队列中</font>。</li>\n</ul>\n<p>CLH 锁是<font color='red'>对自旋锁的一种改进</font>，是一个 **<font color='red'>虚拟的双向 FIFO 队列</font>**（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。<strong>AQS 将每个请求共享资源的线程封装成 CLH 队列锁的一个结点（Node）来实现锁的分配</strong>。每个结点包含：</p>\n<ul>\n<li><font color='cornflowerblue'>thread</font>：线程的引用</li>\n<li><font color='cornflowerblue'>waitStatus</font>：当前节点在队列中的状态</li>\n<li><font color='cornflowerblue'>prev</font>：前驱节点</li>\n<li><font color='cornflowerblue'>next</font>：后继节点</li>\n</ul>\n<p>CLH 队列结构如下：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/clh-queue-structure.png\" alt=\"CLH 队列结构\" /></p>\n<p>AQS( <code>AbstractQueuedSynchronizer</code> ) 的核心原理图：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231013130403824.png\" alt=\"image-20231013130403824\" /></p>\n<p>AQS 使用 <strong>int 成员变量  <code>state</code>  表示同步状态</strong>，通过内置的 <strong>双向 FIFO 线程等待队列</strong> 来完成获取资源线程的排队工作。</p>\n<ul>\n<li>\n<p><code>state</code>  变量由  <code>volatile</code>  修饰，保证线程可见性，用于展示当前临界资源的获锁情况。</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">// 共享变量，使用 volatile 修饰保证线程可见性</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">private</span> <span class=\"token keyword\">volatile</span> <span class=\"token keyword\">int</span> state<span class=\"token punctuation\">;</span></pre></td></tr></table></figure></li>\n<li>\n<p>另外，状态信息  <code>state</code>  可以通过  <code>protected</code>  类型的 <code>getState()</code> 、 <code>setState()</code>  和 <code>compareAndSetState()</code>  进行操作。并且，这几个方法都是  <code>final</code>  修饰的，在子类中无法被重写。</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">// 返回同步状态的当前值</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">protected</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> <span class=\"token function\">getState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>     <span class=\"token keyword\">return</span> state<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre> <span class=\"token comment\">// 设置同步状态的值</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token keyword\">protected</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">void</span> <span class=\"token function\">setState</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> newState<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>     state <span class=\"token operator\">=</span> newState<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token comment\">// 原子地（CAS 操作）将同步状态值设置为给定值 update 如果当前同步状态的值等于 expect（期望值）</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token keyword\">protected</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">compareAndSetState</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> expect<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> update<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>      <span class=\"token keyword\">return</span> unsafe<span class=\"token punctuation\">.</span><span class=\"token function\">compareAndSwapInt</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> stateOffset<span class=\"token punctuation\">,</span> expect<span class=\"token punctuation\">,</span> update<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure></li>\n</ul>\n<hr />\n<p>以<strong>可重入式的独占锁</strong>  <code>ReentrantLock</code>  为例，它的内部维护了一个  <code>state</code>  变量，<font color='red'>表示这个锁被多少个线程所持有</font>。</p>\n<ul>\n<li>\n<p><code>state</code>  的<font color='red'>初始值为 0</font>，表示锁处于未锁定状态。</p>\n</li>\n<li>\n<p>当线程 A 调用  <code>lock()</code>  方法时，会尝试通过  <code>tryAcquire()</code>  方法独占该锁，并让  <code>state</code>  的值<font color='red'>加 1</font>。</p>\n<ul>\n<li>如果成功了，那么线程 A 就获取到了锁。</li>\n<li>如果失败了，那么线程 A 就会<font color='red'>被加入到一个等待队列（CLH 队列）中</font>，直到其他线程释放该锁。</li>\n</ul>\n</li>\n<li>\n<p>假设线程 A 获取锁成功了，<strong><font color='red'>释放锁之前，A 线程自己是可以重复获取此锁的</font></strong>（ <code>state</code>  会累加）。</p>\n<blockquote>\n<p>这就是<strong>可重入性</strong>的体现：<strong>一个线程可以多次获取同一个锁而不会被阻塞</strong>。但是，这也意味着，一个线程必须释放与获取的次数相同的锁，才能让  <code>state</code>  的值回到 0，也就是让锁恢复到未锁定状态。只有这样，其他等待的线程才能有机会获取该锁。</p>\n</blockquote>\n</li>\n</ul>\n<p>线程 A 尝试获取  <code>ReentrantLock</code>  锁的过程如下图所示：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/aqs-exclusive-mode-acquire-lock.png\" alt=\"AQS 独占模式获取锁\" /></p>\n<center>（AQS 独占模式获取锁）</center>\n<hr />\n<p>再以倒计时器  <code>CountDownLatch</code>  以例，</p>\n<ul>\n<li>\n<p>任务分为 N 个子线程去执行， <code>state</code>  也初始化为 N（<font color='red'>表示子线程的个数</font>）。</p>\n</li>\n<li>\n<p>这 N 个子线程开始执行任务，每执行完一个子线程，就调用一次  <code>countDown()</code>  方法。该方法会尝试使用 CAS 操作，让  <code>state</code>  的值减少 1。</p>\n</li>\n<li>\n<p>当所有的子线程都执行完毕后（即  <code>state</code>  的值变为 0）， <code>CountDownLatch</code>  会调用  <code>unpark()</code>  方法，唤醒主线程。</p>\n<blockquote>\n<p>park () 和 unpark () 是 LockSupport 类中的方法：</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token class-name\">LockSupport</span><span class=\"token punctuation\">.</span><span class=\"token function\">park</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 暂停当前线程</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token class-name\">LockSupport</span><span class=\"token punctuation\">.</span><span class=\"token function\">unpark</span><span class=\"token punctuation\">(</span>暂停线程对象<span class=\"token punctuation\">)</span> <span class=\"token comment\">// 恢复某个线程的运行</span></pre></td></tr></table></figure></blockquote>\n</li>\n<li>\n<p>主线程被唤醒后就可以从  <code>CountDownLatch</code>  中的  <code>await()</code>  方法（而非 AQS 中的）返回，继续执行后续的操作。</p>\n</li>\n</ul>\n<h4 id=\"资源共享方式\"><a class=\"anchor\" href=\"#资源共享方式\">#</a> 资源共享方式</h4>\n<p>AQS 定义两种资源共享方式：</p>\n<ul>\n<li><code>Exclusive</code> ：<strong>独占式</strong>，只有一个线程能执行，如 <code>ReentrantLock</code></li>\n<li><code>Share</code> ：<strong>共享式</strong>，多个线程可同时执行，如 <code>Semaphore</code> / <code>CountDownLatch</code></li>\n</ul>\n<p><font color='red'>一般来说，自定义同步器的共享方式要么是独占，要么是共享</font>，他们也只需实现 <code>tryAcquire-tryRelease</code> 、 <code>tryAcquireShared-tryReleaseShared</code>  中的一种即可。<font color='red'>但 AQS 也支持自定义同步器同时实现独占和共享两种方式</font>，如 <code>ReentrantReadWriteLock</code> 。</p>\n<h4 id=\"自定义同步器\"><a class=\"anchor\" href=\"#自定义同步器\">#</a> 自定义同步器</h4>\n<p>同步器的设计是基于<font color='red'>模板方法模式</font>的，如果需要自定义同步器一般的方式是这样：</p>\n<ol>\n<li><strong><font color='red'>继承  <code>AbstractQueuedSynchronizer</code> （AQS 抽象类），并重写指定的钩子方法</font></strong>。</li>\n<li>将 AQS 组合在自定义同步组件的实现中，并调用其模板方法，而这些模板方法会调用使用者重写的方法。</li>\n</ol>\n<p><strong>AQS 使用了模板方法模式，自定义同步器时，需要重写下面几个 AQS 提供的钩子方法：</strong></p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">// 独占方式。尝试获取资源，成功则返回 true，失败则返回 false。</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">protected</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">tryAcquire</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token comment\">// 独占方式。尝试释放资源，成功则返回 true，失败则返回 false。</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">protected</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">tryRelease</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token comment\">// 共享方式。尝试获取资源。负数表示失败；0 表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token keyword\">protected</span> <span class=\"token keyword\">int</span> <span class=\"token function\">tryAcquireShared</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token comment\">// 共享方式。尝试释放资源，成功则返回 true，失败则返回 false。</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token keyword\">protected</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">tryReleaseShared</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token comment\">// 该线程是否正在独占资源。只有用到 condition 才需要去实现它。</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token keyword\">protected</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">isHeldExclusively</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p><strong>钩子方法</strong>是一种<font color='red'>被声明在抽象类中</font>的方法，一般使用<font color='red'>  <code>protected</code>  关键字</font>修饰，它可以是空方法（由子类实现），也可以是默认实现的方法。模板设计模式通过钩子方法控制固定步骤的实现。</p>\n<p><strong><font color='red'>除了上面提到的钩子方法之外，AQS 类中的其他方法都是  <code>final</code>  ，所以无法被其他类重写</font></strong>。</p>\n<h3 id=\"常见同步工具类\"><a class=\"anchor\" href=\"#常见同步工具类\">#</a> 常见同步工具类</h3>\n<p>下面介绍几个基于 AQS 的常见同步工具类：</p>\n<ul>\n<li><font color='cornflowerblue'>Semaphore（信号量）</font>：共享式，AQS 的  <code>state</code>  值为  <code>permits</code> ，表示许可证的数量，只有拿到许可证的线程才能执行。可以用来控制同时访问特定资源的线程数量。</li>\n<li><font color='cornflowerblue'>CountDownLatch（倒计时器）</font>：共享式，AQS 的  <code>state</code>  值为  <code>count</code> ，表示允许  <code>count</code>  个线程阻塞在一个地方，直至所有线程的任务都执行完毕。</li>\n<li><font color='cornflowerblue'>CyclicBarrier（循环栅栏）</font></li>\n</ul>\n<h4 id=\"semaphore信号量\"><a class=\"anchor\" href=\"#semaphore信号量\">#</a> Semaphore（信号量）</h4>\n<blockquote>\n<p><strong>共享式</strong>的资源访问方式</p>\n</blockquote>\n<h5 id=\"简介-2\"><a class=\"anchor\" href=\"#简介-2\">#</a> 简介</h5>\n<p><strong> <code>Semaphore</code>  (信号量) 是共享锁，默认构造 AQS 的  <code>state</code>  值为  <code>permits</code> ，理解为许可证的数量，只有拿到许可证的线程才能执行</strong>。</p>\n<p>Semaphore 的使用简单，我们这里假设有 N (N&gt;5) 个线程来获取  <code>Semaphore</code>  中的共享资源。下面的代码将  <code>permits</code>  初始化为 5，表示同一时刻只有 5 个线程能获取到共享资源，其他线程都会阻塞，只有获取到共享资源的线程才能执行。等到有线程释放了共享资源，其他阻塞的线程才能获取到。</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">// 初始共享资源数量</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">final</span> <span class=\"token class-name\">Semaphore</span> semaphore <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Semaphore</span><span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token comment\">// 获取 1 个许可</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>semaphore<span class=\"token punctuation\">.</span><span class=\"token function\">acquire</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token comment\">// 释放 1 个许可</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>semaphore<span class=\"token punctuation\">.</span><span class=\"token function\">release</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p><font color='red'>当初始的  <code>permits</code>  为 1 的时候， <code>Semaphore</code>  退化为独占锁</font>。</p>\n<p><code>Semaphore</code>  有两种模式：</p>\n<ul>\n<li><font color='cornflowerblue'>公平模式</font>：调用  <code>acquire()</code>  方法的顺序就是获取许可证的顺序，遵循 <font color='red'>FIFO</font></li>\n<li><font color='cornflowerblue'>非公平模式</font>：<font color='red'>抢占式</font>，也是<font color='red'>默认</font>的模式。</li>\n</ul>\n<p><strong> <code>Semaphore</code>  的两个构造方法如下，二者都必须提供  <code>permits</code>  ，其中第二个构造方法可以通过提供  <code>fair</code>  指定是公平模式 / 非公平模式，默认非公平模式。</strong></p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token class-name\">Semaphore</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> <span class=\"token keyword\">permits</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>  \tsync <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">NonfairSync</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">permits</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token class-name\">Semaphore</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> <span class=\"token keyword\">permits</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">boolean</span> fair<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>  \tsync <span class=\"token operator\">=</span> fair <span class=\"token operator\">?</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">FairSync</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">permits</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">:</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">NonfairSync</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">permits</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p><code>Semaphore</code>  通常用于那些对资源有明确访问数量限制的场景比如限流（仅限于单机模式，<font color='red'>实际项目中推荐使用 Redis +Lua 来做限流</font>）。</p>\n<h5 id=\"原理-2\"><a class=\"anchor\" href=\"#原理-2\">#</a> 原理</h5>\n<p>线程调用  <code>semaphore.acquire()</code>  尝试获取许可证，</p>\n<ul>\n<li>如果  <code>permits &gt;= 0</code>  的话，则表示可以获取成功。使用<font color='red'> CAS 操作</font>去修改  <code>permits</code>  的值减 1。</li>\n<li>如果  <code>permits &lt; 0</code>  的话，则表示许可证数量不足。此时会<font color='red'>创建一个 Node 节点加入 CLH 队列锁，挂起当前线程</font>。</li>\n</ul>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">/**</pre></td></tr><tr><td data-num=\"2\"></td><td><pre> *  获取 1 个许可证</pre></td></tr><tr><td data-num=\"3\"></td><td><pre> */</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">acquire</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">InterruptedException</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre> \t sync<span class=\"token punctuation\">.</span><span class=\"token function\">acquireSharedInterruptibly</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token comment\">/**</pre></td></tr><tr><td data-num=\"8\"></td><td><pre> * 共享模式下获取许可证，获取成功则返回，失败则加入阻塞队列，挂起线程</pre></td></tr><tr><td data-num=\"9\"></td><td><pre> */</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">void</span> <span class=\"token function\">acquireSharedInterruptibly</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> arg<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token keyword\">throws</span> <span class=\"token class-name\">InterruptedException</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Thread</span><span class=\"token punctuation\">.</span><span class=\"token function\">interrupted</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>      <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">InterruptedException</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>        <span class=\"token comment\">// 尝试获取许可证，arg 为获取许可证个数，当可用许可证数减当前获取的许可证数结果小于 0, 则创建一个节点加入阻塞队列，挂起当前线程。</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">tryAcquireShared</span><span class=\"token punctuation\">(</span>arg<span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>      <span class=\"token function\">doAcquireSharedInterruptibly</span><span class=\"token punctuation\">(</span>arg<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>线程调用  <code>semaphore.release()</code>  尝试释放许可证，</p>\n<ul>\n<li>并使用<font color='red'> CAS 操作</font>去修改  <code>permits</code>  的值加 1。</li>\n<li>释放许可证成功之后，同时会<font color='red'>唤醒 CLH 队列锁 中的一个线程</font>。</li>\n<li>被唤醒的线程会重新尝试获取许可证，修改  <code>permits</code>  的值减 1，\n<ul>\n<li>如果  <code>permits &gt;= 0</code>  则获取令牌成功</li>\n<li>如果  <code>permits &lt; 0</code>  则重新进入阻塞队列，挂起线程</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">// 释放一个许可证</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">release</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>  \tsync<span class=\"token punctuation\">.</span><span class=\"token function\">releaseShared</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token comment\">// 释放共享锁，同时会唤醒同步队列中的一个线程。</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">releaseShared</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> arg<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token comment\">// 释放共享锁</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">tryReleaseShared</span><span class=\"token punctuation\">(</span>arg<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>      <span class=\"token comment\">// 唤醒同步队列中的一个线程</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>      <span class=\"token function\">doReleaseShared</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>      <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h4 id=\"countdownlatch倒计时器\"><a class=\"anchor\" href=\"#countdownlatch倒计时器\">#</a> CountDownLatch（倒计时器）</h4>\n<blockquote>\n<p><strong>共享式</strong>的资源访问方式</p>\n</blockquote>\n<h5 id=\"简介-3\"><a class=\"anchor\" href=\"#简介-3\">#</a> 简介</h5>\n<p><strong> <code>CountDownLatch</code> （倒计时器）是共享锁，默认构造 AQS 的  <code>state</code>  值为  <code>count</code> ，理解为允许  <code>count</code>  个线程阻塞在一个地方，直至所有线程的任务都执行完毕</strong>。</p>\n<p><code>CountDownLatch</code>  是 **<font color='red'>一次性</font>** 的，<font color='red'> <code>count</code>  只能在构造方法中初始化一次，之后没有任何机制再次对其设置值</font>，当  <code>CountDownLatch</code>  使用完毕后，它不能再次被使用。</p>\n<h5 id=\"原理-3\"><a class=\"anchor\" href=\"#原理-3\">#</a> 原理</h5>\n<ul>\n<li>\n<p>当线程调用  <code>countDown()</code>  方法时，其实调用了  <code>tryReleaseShared()</code>  方法以 CAS 的操作来减少  <code>count</code> ，直至  <code>count</code>  为 0</p>\n</li>\n<li>\n<p>当调用  <code>await()</code>  方法的时候，如果  <code>count</code>  不为 0，那就证明任务还没有执行完毕， <code>await()</code>  方法就会一直阻塞。也就是说  <code>await()</code>  方法之后的语句不会被执行。</p>\n</li>\n<li>\n<p>直到  <code>count</code>  个线程调用了  <code>countDown()</code> ，使  <code>count</code>  值被减为 0。或者调用  <code>await()</code>  的线程被中断，该线程才会从阻塞中被唤醒， <code>await()</code>  方法之后的语句得到执行。</p>\n</li>\n</ul>\n<h5 id=\"应用场景\"><a class=\"anchor\" href=\"#应用场景\">#</a> 应用场景</h5>\n<p><code>CountDownLatch</code>  的作用就是允许 count 个线程阻塞在一个地方，直至所有线程的任务都执行完毕。之前在项目中，有一个<font color='red'>使用多线程读取多个文件</font>处理的场景，我用到了  <code>CountDownLatch</code>  。具体场景是下面这样的：</p>\n<p>我们要读取处理 6 个文件，这 6 个任务都是<font color='red'>没有执行顺序依赖</font>的任务，但是我们需要返回给用户的时候将这几个文件的处理结果进行统计整理。</p>\n<p>为此我们定义了一个线程池和 count 为 6 的  <code>CountDownLatch</code>  对象 。</p>\n<ul>\n<li>使用线程池处理读取任务</li>\n<li>每一个线程处理完，调用  <code>CountDownLatch</code>  对象的  <code>countDown()</code>  将 count 减 1</li>\n<li>当所有线程处理完，调用  <code>CountDownLatch</code>  对象的  <code>await()</code>  方法。直到所有文件读取完之后，才会接着执行后面的逻辑。</li>\n</ul>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">CountDownLatchExample1</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token comment\">// 处理文件的数量</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> threadCount <span class=\"token operator\">=</span> <span class=\"token number\">6</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">InterruptedException</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>        <span class=\"token comment\">// 创建一个具有固定线程数量的线程池对象（推荐使用构造方法创建）</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>        <span class=\"token class-name\">ExecutorService</span> threadPool <span class=\"token operator\">=</span> <span class=\"token class-name\">Executors</span><span class=\"token punctuation\">.</span><span class=\"token function\">newFixedThreadPool</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>        <span class=\"token keyword\">final</span> <span class=\"token class-name\">CountDownLatch</span> countDownLatch <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">CountDownLatch</span><span class=\"token punctuation\">(</span>threadCount<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> threadCount<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>            <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> threadnum <span class=\"token operator\">=</span> i<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>            threadPool<span class=\"token punctuation\">.</span><span class=\"token function\">execute</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>                <span class=\"token keyword\">try</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>                    <span class=\"token comment\">// 处理文件的业务操作</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>                    <span class=\"token comment\">//......</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>                <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">InterruptedException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>                    e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>                <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">finally</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>                    <span class=\"token comment\">// 表示一个文件已经被完成</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>                    countDownLatch<span class=\"token punctuation\">.</span><span class=\"token function\">countDown</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>                <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>            <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>        countDownLatch<span class=\"token punctuation\">.</span><span class=\"token function\">await</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>        threadPool<span class=\"token punctuation\">.</span><span class=\"token function\">shutdown</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"finish\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><hr />\n<p>有没有可以改进的地方呢？** 可以使用  <code>CompletableFuture</code>  类来改进！**Java8 的  <code>CompletableFuture</code>  提供了很多对多线程友好的方法，使用它可以很方便地为我们编写多线程程序，什么异步、串行、并行或者等待所有线程执行完任务什么的都非常方便。</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token class-name\">CompletableFuture</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Void</span><span class=\"token punctuation\">></span></span> task1 <span class=\"token operator\">=</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token class-name\">CompletableFuture</span><span class=\"token punctuation\">.</span><span class=\"token function\">supplyAsync</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">-></span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>        <span class=\"token comment\">// 自定义业务操作</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token class-name\">CompletableFuture</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Void</span><span class=\"token punctuation\">></span></span> task6 <span class=\"token operator\">=</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token class-name\">CompletableFuture</span><span class=\"token punctuation\">.</span><span class=\"token function\">supplyAsync</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">-></span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token comment\">// 自定义业务操作</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token class-name\">CompletableFuture</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Void</span><span class=\"token punctuation\">></span></span> headerFuture<span class=\"token operator\">=</span><span class=\"token class-name\">CompletableFuture</span><span class=\"token punctuation\">.</span><span class=\"token function\">allOf</span><span class=\"token punctuation\">(</span>task1<span class=\"token punctuation\">,</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">,</span>task6<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token keyword\">try</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    headerFuture<span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre><span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Exception</span> ex<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>    <span class=\"token comment\">//......</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre><span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"all done. \"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>上面的代码还可以继续优化，当任务过多的时候，把每一个 task 都列出来不太现实，可以考虑<font color='red'>通过循环来添加任务</font>。</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">// 文件夹位置</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">></span></span> filePaths <span class=\"token operator\">=</span> <span class=\"token class-name\">Arrays</span><span class=\"token punctuation\">.</span><span class=\"token function\">asList</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token comment\">// 异步处理所有文件</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">CompletableFuture</span><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">></span><span class=\"token punctuation\">></span></span> fileFutures <span class=\"token operator\">=</span> filePaths<span class=\"token punctuation\">.</span><span class=\"token function\">stream</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span>filePath <span class=\"token operator\">-></span> <span class=\"token function\">doSomeThing</span><span class=\"token punctuation\">(</span>filePath<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token punctuation\">.</span><span class=\"token function\">collect</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Collectors</span><span class=\"token punctuation\">.</span><span class=\"token function\">toList</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token comment\">// 将他们合并起来</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token class-name\">CompletableFuture</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Void</span><span class=\"token punctuation\">></span></span> allFutures <span class=\"token operator\">=</span> <span class=\"token class-name\">CompletableFuture</span><span class=\"token punctuation\">.</span><span class=\"token function\">allOf</span><span class=\"token punctuation\">(</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    fileFutures<span class=\"token punctuation\">.</span><span class=\"token function\">toArray</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">CompletableFuture</span><span class=\"token punctuation\">[</span>fileFutures<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h4 id=\"cyclicbarrier循环栅栏\"><a class=\"anchor\" href=\"#cyclicbarrier循环栅栏\">#</a> CyclicBarrier（循环栅栏）</h4>\n<blockquote>\n<p><strong>共享式</strong>的资源访问方式</p>\n</blockquote>\n<h5 id=\"简介-4\"><a class=\"anchor\" href=\"#简介-4\">#</a> 简介</h5>\n<p><strong> <code>CyclicBarrier</code> （循环栅栏）和  <code>CountDownLatch</code>  非常类似，也是共享锁，内部通过一个  <code>count</code>  变量作为计数器，其初始值也是  <code>parties</code>  属性（表示拦截的线程数量）的初始值</strong>。</p>\n<p><code>CyclicBarrier</code>  也可以实现线程间的技术等待，但是它的功能比  <code>CountDownLatch</code>  更加复杂和强大，主要应用场景类似。</p>\n<blockquote>\n<p><code>CountDownLatch</code>  的实现是基于 AQS 的，而 <strong> <code>CycliBarrier</code>  是基于  <code>ReentrantLock</code> ( <code>ReentrantLock</code>  也属于 AQS 同步器) 和  <code>Condition</code>  的</strong>。</p>\n</blockquote>\n<p><code>CyclicBarrier</code>  的字面意思是<font color='red'>可循环使用（Cyclic）的屏障（Barrier）</font>。它要做的事情是：让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。</p>\n<h5 id=\"原理-4\"><a class=\"anchor\" href=\"#原理-4\">#</a> 原理</h5>\n<blockquote>\n<p>难！</p>\n</blockquote>\n<p>每当一个线程到了栅栏这里了，那么就将 count 减 1。当 count 值为 0 时，表示这是这一代最后一个线程到达栅栏，就尝试执行我们构造方法中输入的任务。</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">// 每次拦截的线程数</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> parties<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token comment\">// 计数器</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">private</span> <span class=\"token keyword\">int</span> count<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>结合源码来简单看看。</p>\n<p>1、 <code>CyclicBarrier</code>  默认的构造方法是  <code>CyclicBarrier(int parties)</code> ，参数  <code>parties</code>  表示屏障拦截的线程数量，每个线程调用  <code>await()</code>  方法告诉  <code>CyclicBarrier</code>  我已经到达了屏障，然后当前线程被阻塞。</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token class-name\">CyclicBarrier</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> parties<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">this</span><span class=\"token punctuation\">(</span>parties<span class=\"token punctuation\">,</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token class-name\">CyclicBarrier</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> parties<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Runnable</span> barrierAction<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>parties <span class=\"token operator\">&lt;=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">IllegalArgumentException</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>parties <span class=\"token operator\">=</span> parties<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>count <span class=\"token operator\">=</span> parties<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>barrierCommand <span class=\"token operator\">=</span> barrierAction<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>其中，<strong> <code>parties</code>  就代表了需要拦截的线程数量，当拦截的线程数量达到这个值的时候就打开栅栏，让所有线程通过</strong>。</p>\n<p>2、当调用  <code>CyclicBarrier</code>  对象调用  <code>await()</code>  方法时，实际上调用的是   <code>dowait(false, 0L)</code>  方法。 <code>await()</code>  方法就像树立起一个栅栏的行为一样，将线程挡住了，当拦住的线程数量达到  <code>parties</code>  的值时，栅栏才会打开，线程才得以通过执行。</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">await</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">InterruptedException</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">BrokenBarrierException</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>  <span class=\"token keyword\">try</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    \t<span class=\"token keyword\">return</span> <span class=\"token function\">dowait</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0L</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>  <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">TimeoutException</span> toe<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>   \t <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Error</span><span class=\"token punctuation\">(</span>toe<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// cannot happen</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>  <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p><code>dowait(false, 0L)</code>  方法源码分析如下：</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">// 当线程数量或者请求数量达到 count 时 await 之后的方法才会被执行。上面的示例中 count 的值就为 5。</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">private</span> <span class=\"token keyword\">int</span> count<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token comment\">/**</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>     * Main barrier code, covering the various policies.</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>     */</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token keyword\">private</span> <span class=\"token keyword\">int</span> <span class=\"token function\">dowait</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">boolean</span> timed<span class=\"token punctuation\">,</span> <span class=\"token keyword\">long</span> nanos<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>        <span class=\"token keyword\">throws</span> <span class=\"token class-name\">InterruptedException</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">BrokenBarrierException</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>               <span class=\"token class-name\">TimeoutException</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>        <span class=\"token keyword\">final</span> <span class=\"token class-name\">ReentrantLock</span> lock <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>lock<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>        <span class=\"token comment\">// 锁住</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>        lock<span class=\"token punctuation\">.</span><span class=\"token function\">lock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>        <span class=\"token keyword\">try</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>            <span class=\"token keyword\">final</span> <span class=\"token class-name\">Generation</span> g <span class=\"token operator\">=</span> generation<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>g<span class=\"token punctuation\">.</span>broken<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>                <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">BrokenBarrierException</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>            <span class=\"token comment\">// 如果线程中断了，抛出异常</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Thread</span><span class=\"token punctuation\">.</span><span class=\"token function\">interrupted</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>                <span class=\"token function\">breakBarrier</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>                <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">InterruptedException</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>            <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>            <span class=\"token comment\">//cout 减 1</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>            <span class=\"token keyword\">int</span> index <span class=\"token operator\">=</span> <span class=\"token operator\">--</span>count<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>            <span class=\"token comment\">// 当 count 数量减为 0 之后说明最后一个线程已经到达栅栏了，也就是达到了可以执行 await 方法之后的条件</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>index <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>  <span class=\"token comment\">// tripped</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>                <span class=\"token keyword\">boolean</span> ranAction <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>                <span class=\"token keyword\">try</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>                    <span class=\"token keyword\">final</span> <span class=\"token class-name\">Runnable</span> command <span class=\"token operator\">=</span> barrierCommand<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>                    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>command <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre>                        command<span class=\"token punctuation\">.</span><span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"32\"></td><td><pre>                    ranAction <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"33\"></td><td><pre>                    <span class=\"token comment\">// 将 count 重置为 parties 属性的初始化值</span></pre></td></tr><tr><td data-num=\"34\"></td><td><pre>                    <span class=\"token comment\">// 唤醒之前等待的线程</span></pre></td></tr><tr><td data-num=\"35\"></td><td><pre>                    <span class=\"token comment\">// 下一波执行开始</span></pre></td></tr><tr><td data-num=\"36\"></td><td><pre>                    <span class=\"token function\">nextGeneration</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"37\"></td><td><pre>                    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"38\"></td><td><pre>                <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">finally</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"39\"></td><td><pre>                    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>ranAction<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"40\"></td><td><pre>                        <span class=\"token function\">breakBarrier</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"41\"></td><td><pre>                <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"42\"></td><td><pre>            <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"43\"></td><td><pre></pre></td></tr><tr><td data-num=\"44\"></td><td><pre>            <span class=\"token comment\">// loop until tripped, broken, interrupted, or timed out</span></pre></td></tr><tr><td data-num=\"45\"></td><td><pre>            <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"46\"></td><td><pre>                <span class=\"token keyword\">try</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"47\"></td><td><pre>                    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>timed<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"48\"></td><td><pre>                        trip<span class=\"token punctuation\">.</span><span class=\"token function\">await</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"49\"></td><td><pre>                    <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>nanos <span class=\"token operator\">></span> <span class=\"token number\">0L</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"50\"></td><td><pre>                        nanos <span class=\"token operator\">=</span> trip<span class=\"token punctuation\">.</span><span class=\"token function\">awaitNanos</span><span class=\"token punctuation\">(</span>nanos<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"51\"></td><td><pre>                <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">InterruptedException</span> ie<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"52\"></td><td><pre>                    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>g <span class=\"token operator\">==</span> generation <span class=\"token operator\">&amp;&amp;</span> <span class=\"token operator\">!</span> g<span class=\"token punctuation\">.</span>broken<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"53\"></td><td><pre>                        <span class=\"token function\">breakBarrier</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"54\"></td><td><pre>                        <span class=\"token keyword\">throw</span> ie<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"55\"></td><td><pre>                    <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"56\"></td><td><pre>                        <span class=\"token comment\">// We're about to finish waiting even if we had not</span></pre></td></tr><tr><td data-num=\"57\"></td><td><pre>                        <span class=\"token comment\">// been interrupted, so this interrupt is deemed to</span></pre></td></tr><tr><td data-num=\"58\"></td><td><pre>                        <span class=\"token comment\">// \"belong\" to subsequent execution.</span></pre></td></tr><tr><td data-num=\"59\"></td><td><pre>                        <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">interrupt</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"60\"></td><td><pre>                    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"61\"></td><td><pre>                <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"62\"></td><td><pre></pre></td></tr><tr><td data-num=\"63\"></td><td><pre>                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>g<span class=\"token punctuation\">.</span>broken<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"64\"></td><td><pre>                    <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">BrokenBarrierException</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"65\"></td><td><pre></pre></td></tr><tr><td data-num=\"66\"></td><td><pre>                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>g <span class=\"token operator\">!=</span> generation<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"67\"></td><td><pre>                    <span class=\"token keyword\">return</span> index<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"68\"></td><td><pre></pre></td></tr><tr><td data-num=\"69\"></td><td><pre>                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>timed <span class=\"token operator\">&amp;&amp;</span> nanos <span class=\"token operator\">&lt;=</span> <span class=\"token number\">0L</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"70\"></td><td><pre>                    <span class=\"token function\">breakBarrier</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"71\"></td><td><pre>                    <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">TimeoutException</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"72\"></td><td><pre>                <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"73\"></td><td><pre>            <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"74\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">finally</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"75\"></td><td><pre>            lock<span class=\"token punctuation\">.</span><span class=\"token function\">unlock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"76\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"77\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h3 id=\"面试题aqs-的底层原理是什么\"><a class=\"anchor\" href=\"#面试题aqs-的底层原理是什么\">#</a> 【面试题】AQS 的底层原理是什么？</h3>\n<blockquote>\n<p>互联网、美团 / 阿里、后端、Java。</p>\n</blockquote>\n<p>**AQS（AbstractQueuedSynchronizer，抽象队列同步器）** 的底层是通过 Java 中的<font color='red'>  <code>Lock</code>  接口和  <code>Condition</code>  接口</font>实现的。AQS 是一个抽象类，提供了一种灵活的机制来<font color='red'>实现线程间的同步和互斥操作</font>。它提供了两种同步模式：<font color='cornflowerblue'>独占模式（Exclusive）</font>和<font color='cornflowerblue'>共享模式（Shared）</font>。</p>\n<p>在 AQS 的底层实现中，主要使用了一个 ** 虚拟的双向 FIFO 队列（CLH 队列锁）** 来维护等待获取锁的线程队列。当一个线程请求获取锁时，如果锁已经被其他线程占用，则该线程会被加入到队列中，并进入等待状态。当持有锁的线程释放锁时，AQS 会从队列中选择一个线程唤醒并允许其获取锁。</p>\n<p>AQS 还提供了一些核心的方法，如 acquire 、 release 和 tryAcquire 等，用于实现具体的同步操作。这些方法通过内置的 ** 状态变量（state）** 来记录锁的状态，并根据不同的情况进行相应的操作。</p>\n<h3 id=\"讲讲你对-aqs-的理解\"><a class=\"anchor\" href=\"#讲讲你对-aqs-的理解\">#</a> 讲讲你对 AQS 的理解</h3>\n<p>AQS（AbstractQueuedSynchronizer）是 Java 并发包中一个重要的工具类，它<font color='red'>提供了实现锁、同步器的基础框架</font>。</p>\n<ol>\n<li>AQS 是一个<strong>抽象类</strong>，它定义了锁和同步器的基本接口和方法。它的子类可以通过继承 AQS 并重写其中的方法来实现自定义的同步器。</li>\n<li>AQS 通过一个 ** 状态变量（state）** 来表示锁的状态。state 的具体含义对于不同的同步器会有不同的解释，例如，ReentrantLock 中 的 state 表示持有锁的线程数量。</li>\n<li><font color='red'>AQS 使用一个 ** 双向队列（CLH 队列锁）** 来管理等待获取资源的线程</font>。每个等待线程会被包装成一个 &quot;Node&quot; 对象，并且会按照一定的顺序排队。</li>\n<li>AQS <font color='red'>提供了两个主要的方法： <code>acquire()</code>  和  <code>release()</code> </font>。\n<ul>\n<li>acquire () 方法用于获取资源，而 release () 方法用于释放资源。</li>\n<li>当一个线程调用 acquire () 方法时，如果资源已经被其他线程占用，那么该线程将会被加入到 CLH 队列 中进行等待。</li>\n</ul>\n</li>\n<li><font color='red'>Condition 是 AQS 的一个补充接口，它提供了更为细粒度的等待 / 通知机制</font>。Condition 对象可以通过 AQS 的 newCondition () 方法创建。Condition 底层的实现依赖于 AQS ，并且使用 AQS 队列来管理等待线程。</li>\n<li><font color='red'>Condition 的底层原理是基于 AQS 的状态和 CLH 队列</font>。当一个线程调用 Condition 的 await 方法时，该线程会释放持有的 AQS 状态（比如锁），并且进入 Condition 维护的等待队列中等待通知。当另一个线程执行相应的通知操作时，被唤醒的线程可以重新竞争资源。</li>\n</ol>\n<p>总的来说，</p>\n<ul>\n<li>AQS 是 Java 并发包中实现锁和同步器的基础框架。它使用一个双向队列来管理等待获取资源的线程，并提供 acquire 和 release 等方法来获取和释放资源。</li>\n<li>Condition 是 AQS 的补充接口，提供了更为细粒度的等待 / 通知机制。Condition 底层的实现依赖于 AQS 的状态和 CLH 队列。</li>\n</ul>\n<h2 id=\"reentrantlock-类\"><a class=\"anchor\" href=\"#reentrantlock-类\">#</a> ReentrantLock 类</h2>\n<blockquote>\n<p><strong>可重入</strong>式的<strong>独占锁</strong>（悲观锁）</p>\n</blockquote>\n<h3 id=\"简介-5\"><a class=\"anchor\" href=\"#简介-5\">#</a> 简介</h3>\n<p><code>ReentrantLock</code>  实现了  <code>Lock</code>  接口，是一个<font color='red'>可重入</font>且<font color='red'>独占式</font>的锁，和  <code>synchronized</code>  关键字类似。不过， <code>ReentrantLock</code>  更灵活、更强大，增加了<font color='red'>轮询、超时、中断、公平锁和非公平锁</font>等高级功能。</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">ReentrantLock</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Lock</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\"><span class=\"token namespace\">java<span class=\"token punctuation\">.</span>io<span class=\"token punctuation\">.</span></span>Serializable</span> <span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p><code>ReentrantLock</code>  里面有一个<strong>继承自 AQS（ <code>AbstractQueuedSynchronizer</code> ）的内部类  <code>Sync</code> </strong>，添加锁和释放锁的大部分操作实际上都是其中实现的。 <code>Sync</code>  有两个子类：</p>\n<ul>\n<li><font color='cornflowerblue'>公平锁  <code>FairSync</code>  </font></li>\n<li><font color='cornflowerblue'>非公平锁  <code>NonfairSync</code>  </font></li>\n</ul>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/reentrantlock-class-diagram.png\" alt=\"img\" /></p>\n<p><font color='red'> <code>ReentrantLock</code>  默认使用非公平锁</font>，也可以通过构造器来显式的指定使用公平锁。</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">// 传入一个 boolean 值，true 时为公平锁，false 时为非公平锁</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token class-name\">ReentrantLock</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">boolean</span> fair<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    sync <span class=\"token operator\">=</span> fair <span class=\"token operator\">?</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">FairSync</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">:</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">NonfairSync</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>从上面的内容可以看出， <code>ReentrantLock</code>  的底层就是由 AQS 来实现的。</p>\n<h3 id=\"公平锁和非公平锁有什么区别\"><a class=\"anchor\" href=\"#公平锁和非公平锁有什么区别\">#</a> 公平锁和非公平锁有什么区别？</h3>\n<p><strong>公平锁</strong>:</p>\n<ul>\n<li>锁被释放之后，<strong><font color='red'>先申请的线程先得到锁</font></strong>。</li>\n<li><font color='red'>性能较差一些</font>，因为公平锁为了保证时间上的绝对顺序，上下文切换更频繁。</li>\n</ul>\n<p><strong>非公平锁</strong>：</p>\n<ul>\n<li>锁被释放之后，<strong><font color='red'>后申请的线程可能会先获取到锁</font></strong>，是随机或者按照其他优先级排序的。</li>\n<li><font color='red'>性能更好</font>，但可能会导致某些线程永远无法获取到锁。</li>\n<li>例如： <code>synchronized</code></li>\n</ul>\n<h3 id=\"synchronized-和-reentrantlock-有何异同\"><a class=\"anchor\" href=\"#synchronized-和-reentrantlock-有何异同\">#</a> synchronized 和 ReentrantLock 有何异同？</h3>\n<h4 id=\"都是可重入锁\"><a class=\"anchor\" href=\"#都是可重入锁\">#</a> 都是可重入锁</h4>\n<p><strong>可重入锁</strong>也叫递归锁，是指<font color='red'>线程可以再次获取自己的内部锁</font>。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，<font color='red'>如果是不可重入锁的话，就会造成死锁</font>。</p>\n<p>JDK 提供的所有现成的  <code>Lock</code>  实现类，包括  <code>synchronized</code>  关键字锁都是可重入的。</p>\n<hr />\n<p>在下面的代码中， <code>method1()</code>  和  <code>method2()</code>  都被  <code>synchronized</code>  关键字修饰， <code>method1()</code>  调用了 <code>method2()</code> 。</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">SynchronizedDemo</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">synchronized</span> <span class=\"token keyword\">void</span> <span class=\"token function\">method1</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"方法1\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>        <span class=\"token function\">method2</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">synchronized</span> <span class=\"token keyword\">void</span> <span class=\"token function\">method2</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"方法2\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>由于  <code>synchronized</code>  锁是可重入的，同一个线程在调用  <code>method1()</code>  时可以直接获得当前对象的锁，执行  <code>method2()</code>  的时候可以再次获取这个对象的锁，不会产生死锁问题。假如 <code>synchronized</code>  是不可重入锁的话，由于该对象的锁已被当前线程所持有且无法释放，这就导致线程在执行  <code>method2()</code>  时获取锁失败，会出现死锁问题。</p>\n<h4 id=\"synchronized-依赖于-jvm而-reentrantlock-依赖于-api\"><a class=\"anchor\" href=\"#synchronized-依赖于-jvm而-reentrantlock-依赖于-api\">#</a> synchronized 依赖于 JVM，而 ReentrantLock 依赖于 API</h4>\n<p><code>synchronized</code>  是依赖于 JVM 实现的，前面我们也讲到了虚拟机团队在 JDK1.6 为  <code>synchronized</code>  关键字进行了很多优化，但是<font color='red'>这些优化都是在虚拟机层面实现的</font>，并没有直接暴露给我们。</p>\n<p><code>ReentrantLock</code>  是 JDK 层面实现的（也就是<font color='red'> API 层面，需要 lock () 和 unlock () 方法配合 try/finally 语句块来完成</font>），所以我们可以通过查看它的源代码，来看它是如何实现的。</p>\n<h4 id=\"reentrantlock-比-synchronized-增加了一些高级功能\"><a class=\"anchor\" href=\"#reentrantlock-比-synchronized-增加了一些高级功能\">#</a> ReentrantLock 比 synchronized 增加了一些高级功能</h4>\n<p>相比  <code>synchronized</code> ， <code>ReentrantLock</code>  增加了一些高级功能。主要来说主要有三点：</p>\n<ul>\n<li><strong>等待可中断</strong> :  <code>ReentrantLock</code>  提供了一种能够中断等待锁的线程的机制，通过  <code>lock.lockInterruptibly()</code>  来实现这个机制。也就是说<font color='red'>正在等待的线程可以选择放弃等待，改为处理其他事情</font>。</li>\n<li><strong>可实现公平锁</strong> :  <code>ReentrantLock</code>  可以指定是公平锁还是非公平锁。<font color='red'>而 <code>synchronized</code>  只能是非公平锁</font>。所谓的公平锁就是先等待的线程先获得锁。 <code>ReentrantLock</code>  默认情况是非公平的，可以通过  <code>ReentrantLock</code>  类的 <code>ReentrantLock(boolean fair)</code>  构造方法来指定是否是公平的。</li>\n<li><strong>可实现选择性通知（锁可以绑定多个条件）</strong>:  <code>synchronized</code>  关键字与 <code>wait()</code>  和 <code>notify()</code> / <code>notifyAll()</code>  方法相结合可以实现等待 / 通知机制。 <code>ReentrantLock</code>  类当然也可以实现，但是需要借助于 <code>Condition</code>  接口与 <code>newCondition()</code>  方法。</li>\n</ul>\n<p>关于  <code>Condition</code>  接口的补充：</p>\n<blockquote>\n<p><code>Condition</code>  接口是 JDK1.5 之后才有的，它具有很好的灵活性，比如可以实现多路通知功能。也就是在一个 <code>Lock</code>  对象中可以创建多个 <code>Condition</code>  实例（即对象监视器），<strong>线程对象可以注册在指定的 <code>Condition</code>  中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。 在使用 <code>notify()/notifyAll()</code>  方法进行通知时，被通知的线程是由 JVM 选择的，用 <code>ReentrantLock</code>  类结合 <code>Condition</code>  实例可以实现 “选择性通知”</strong> ，这个功能非常重要，而且是  <code>Condition</code>  接口默认提供的。</p>\n<p>而 <code>synchronized</code>  关键字就相当于整个  <code>Lock</code>  对象中只有一个 <code>Condition</code>  实例，所有的线程都注册在它一个身上。如果执行 <code>notifyAll()</code>  方法的话就会通知所有处于等待状态的线程，这样会造成很大的效率问题。而 <code>Condition</code>  实例的 <code>signalAll()</code>  方法，只会唤醒注册在该 <code>Condition</code>  实例中的所有等待线程。</p>\n</blockquote>\n<h3 id=\"可中断锁和不可中断锁有什么区别\"><a class=\"anchor\" href=\"#可中断锁和不可中断锁有什么区别\">#</a> 可中断锁和不可中断锁有什么区别？</h3>\n<blockquote>\n<p>等待可中断</p>\n</blockquote>\n<p><strong>可中断锁</strong>：获取锁的过程中可以被中断，不需要一直等到获取锁之后 才能进行其他逻辑处理。 <code>ReentrantLock</code>  就属于是可中断锁。</p>\n<p><strong>不可中断锁</strong>：一旦线程申请了锁，就只能等到拿到锁以后才能进行其他的逻辑处理。  <code>synchronized</code>  就属于是不可中断锁。</p>\n<h3 id=\"介绍下-reentrantlock-的底层原理可重入-公平锁和非公平锁的原理\"><a class=\"anchor\" href=\"#介绍下-reentrantlock-的底层原理可重入-公平锁和非公平锁的原理\">#</a> 介绍下 ReentrantLock 的底层原理（可重入、公平锁和非公平锁的原理）</h3>\n<ol>\n<li>可重入的原理：<font color='red'>ReentrantLock 通过一个计数器（<strong>状态变量 state</strong>）来记录锁的持有线程数</font>。当一个线程第一次获取锁时，计数器加 1，当该线程再次获取锁时，计数器再次加 1。当线程释放锁时，计数器减 1。只有当计数器值为 0 时，表示锁完全释放，其他线程可以获取该锁。</li>\n<li>公平锁和非公平锁的原理：ReentrantLock 提供了公平锁（ <code>FairSync</code> ）和非公平锁（ <code>NonfairSync</code> ）两种模式。</li>\n</ol>\n<ul>\n<li>公平锁模式：当多个线程等待获取锁时，<font color='red'>按照线程的申请顺序来获取锁</font>。即先到先得的原则，保证等待时间越久的线程越早获取锁。</li>\n<li>非公平锁模式：当多个线程等待获取锁时，不按照线程的申请顺序来获取锁。即存在一个竞争机制，<font color='red'>新来的线程有机会抢占锁</font>，这样可以提高吞吐量。</li>\n</ul>\n<ol start=\"3\">\n<li>在底层实现上，公平锁和非公平锁的区别在于线程获取锁的方式：</li>\n</ol>\n<ul>\n<li>公平锁先检查队列中是否有正在等待的线程，如果有，则按照 FIFO 的顺序选择锁的持有者。</li>\n<li>非公平锁先尝试直接获取锁，\n<ul>\n<li>如果失败，则再进入同步队列等待。</li>\n<li>如果失败，则进入队列等待，但在这个等待过程中，可能会允许新来的线程抢占锁。</li>\n</ul>\n</li>\n</ul>\n<p>总结：</p>\n<ul>\n<li>ReentrantLock 通过计数器实现可重入的机制，保证同一个线程可以多次获取同一个锁。</li>\n<li>公平锁和非公平锁的区别在于锁的获取方式，公平锁按照线程等待的顺序进行获取，而非公平锁允许在锁释放时新来的线程有机会优先获取锁。</li>\n</ul>\n<h1 id=\"线程池\"><a class=\"anchor\" href=\"#线程池\">#</a> 线程池</h1>\n<h2 id=\"线程池-2\"><a class=\"anchor\" href=\"#线程池-2\">#</a> 线程池</h2>\n<h3 id=\"简介-6\"><a class=\"anchor\" href=\"#简介-6\">#</a> 简介</h3>\n<p>顾名思义，线程池就是<strong>管理一系列线程的资源池</strong>。当有任务要处理时，直接从线程池中获取线程来处理，<font color='red'>处理完之后线程并不会立即被销毁，而是等待下一个任务</font>。</p>\n<p>池化技术的主要思想：<strong>为了减少每次获取资源的消耗</strong>，提高对资源的利用率。</p>\n<p>借用《Java 并发编程的艺术》来说一下<font color='red'>使用线程池的好处</font>：</p>\n<ul>\n<li><strong>降低资源消耗</strong>。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li>\n<li><strong>提高响应速度</strong>。当任务到达时，任务可以不需要等到线程创建就能立即执行。</li>\n<li><strong>提高线程的可管理性</strong>。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li>\n</ul>\n<h3 id=\"executor-框架\"><a class=\"anchor\" href=\"#executor-框架\">#</a> Executor 框架</h3>\n<h4 id=\"简介-7\"><a class=\"anchor\" href=\"#简介-7\">#</a> 简介</h4>\n<p><code>Executor</code>  框架是 Java5 之后引进的，<font color='red'>通过  <code>Executor</code>  来启动线程比使用  <code>Thread</code>  的  <code>start</code>  方法更好</font>。除了更易管理，效率更好（<font color='red'>用线程池实现，节约开销</font>）外，还有关键的一点：<strong><font color='red'>有助于避免 this 逃逸问题</font></strong>。</p>\n<blockquote>\n<p><strong>this 逃逸</strong>：在构造函数返回之前，其他线程就持有该对象的引用，调用尚未构造完全的对象的方法，可能引发令人疑惑的错误。</p>\n</blockquote>\n<p><code>Executor</code>  框架不仅包括了<font color='red'>线程池的管理</font>，还提供了<font color='red'>线程工厂、队列、拒绝策略</font>等， <code>Executor</code>  框架让并发编程变得更加简单。</p>\n<h4 id=\"三大部分\"><a class=\"anchor\" href=\"#三大部分\">#</a> 三大部分</h4>\n<h5 id=\"任务runnablecallable\"><a class=\"anchor\" href=\"#任务runnablecallable\">#</a> 任务（ <code>Runnable</code> / <code>Callable</code> ）</h5>\n<p>执行任务需要实现 <strong> <code>Runnable</code>  接口</strong> 或 <strong> <code>Callable</code>  接口</strong>，对应的实现类可以被 <strong> <code>ThreadPoolExecutor</code> </strong> 或 <strong> <code>ScheduledThreadPoolExecutor</code> </strong> 执行。</p>\n<h5 id=\"任务的执行executor\"><a class=\"anchor\" href=\"#任务的执行executor\">#</a> 任务的执行（ <code>Executor</code> ）</h5>\n<p>如下图所示，包括任务执行机制的核心接口  <code>Executor</code> ，以及继承自它的  <code>ExecutorService</code>  接口。</p>\n<p><strong> <code>ThreadPoolExecutor</code>  和  <code>ScheduledThreadPoolExecutor</code>  是两个关键的实现类。</strong></p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/executor-class-diagram.png\" alt=\"img\" /></p>\n<p><code>ThreadPoolExecutor</code>  类描述：</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">//AbstractExecutorService 类实现了 ExecutorService 接口</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">ThreadPoolExecutor</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">AbstractExecutorService</span></pre></td></tr></table></figure><p><code>ScheduledThreadPoolExecutor</code>  类描述:</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">//ScheduledExecutorService 继承 ExecutorService 接口</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">ScheduledThreadPoolExecutor</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>        <span class=\"token keyword\">extends</span> <span class=\"token class-name\">ThreadPoolExecutor</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>        <span class=\"token keyword\">implements</span> <span class=\"token class-name\">ScheduledExecutorService</span></pre></td></tr></table></figure><h5 id=\"异步计算的结果future\"><a class=\"anchor\" href=\"#异步计算的结果future\">#</a> 异步计算的结果（ <code>Future</code> ）</h5>\n<p><strong> <code>Future</code>  接口</strong>及<strong>其实现类 <code>FutureTask</code>  类</strong>都可以代表异步计算的结果。</p>\n<p>当我们把  <code>Runnable</code>  接口或  <code>Callable</code>  接口的实现类提交给  <code>ThreadPoolExecutor</code>  或  <code>ScheduledThreadPoolExecutor</code>  执行时，在内部调用  <code>submit()</code>  方法时会返回一个  <code>FutureTask</code>  对象。</p>\n<h4 id=\"如何使用-2\"><a class=\"anchor\" href=\"#如何使用-2\">#</a> 如何使用</h4>\n<p><code>Executor</code>  框架的使用示意图：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231020143912018.png\" alt=\"image-20231020143912018\" /></p>\n<ol>\n<li>\n<p>主线程首先要创建实现了  <code>Runnable</code>  接口或者  <code>Callable</code>  接口的任务对象。</p>\n</li>\n<li>\n<p>把创建完成的实现了  <code>Runnable</code>  /  <code>Callable</code>  接口的对象直接交给  <code>ExecutorService</code>  的  <code>execute()</code>  或者  <code>submit()</code>  执行。</p>\n<blockquote>\n<p>由于  <code>FutureTask</code>  实现了  <code>Runnable</code> ，我们也可以直接创建  <code>FutureTask</code> ，然后交给  <code>ExecutorService</code>  执行。</p>\n</blockquote>\n</li>\n<li>\n<p>如果执行的是  <code>ExecutorService.submit（）</code> ，将返回一个实现了  <code>Future</code>  接口的  <code>FutureTask</code>  对象。</p>\n</li>\n<li>\n<p>最后，主线程可以执行  <code>FutureTask.get()</code>  方法来等待任务执行完成。主线程也可以执行  <code>FutureTask.cancel（boolean mayInterruptIfRunning）</code> 来取消此任务的执行。</p>\n</li>\n</ol>\n<h3 id=\"threadpoolexecutor-类\"><a class=\"anchor\" href=\"#threadpoolexecutor-类\">#</a> <mark>ThreadPoolExecutor 类</mark></h3>\n<blockquote>\n<p>线程池实现类  <code>ThreadPoolExecutor</code>  是  <code>Executor</code>  框架最核心的类。</p>\n</blockquote>\n<h4 id=\"构造方法\"><a class=\"anchor\" href=\"#构造方法\">#</a> 构造方法</h4>\n<p><code>ThreadPoolExecutor</code>  类中提供的<font color='red'>四个构造方法</font>。我们来看最长的那个，其余三个都是在这个构造方法的基础上产生（其他几个构造方法说白点都是给定某些默认参数的构造方法，比如默认制定拒绝策略是什么）。</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">/**</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>     * 用给定的初始参数创建一个新的 ThreadPoolExecutor。</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>     */</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token class-name\">ThreadPoolExecutor</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> corePoolSize<span class=\"token punctuation\">,</span><span class=\"token comment\">// 线程池的核心线程数量</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>                              <span class=\"token keyword\">int</span> maximumPoolSize<span class=\"token punctuation\">,</span><span class=\"token comment\">// 线程池的最大线程数</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>                              <span class=\"token keyword\">long</span> keepAliveTime<span class=\"token punctuation\">,</span><span class=\"token comment\">// 当线程数大于核心线程数时，多余的空闲线程存活的最长时间</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>                              <span class=\"token class-name\">TimeUnit</span> unit<span class=\"token punctuation\">,</span><span class=\"token comment\">// 时间单位</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>                              <span class=\"token class-name\">BlockingQueue</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Runnable</span><span class=\"token punctuation\">></span></span> workQueue<span class=\"token punctuation\">,</span><span class=\"token comment\">// 任务队列，用来储存等待执行任务的队列</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>                              <span class=\"token class-name\">ThreadFactory</span> threadFactory<span class=\"token punctuation\">,</span><span class=\"token comment\">// 线程工厂，用来创建线程，一般默认即可</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>                              <span class=\"token class-name\">RejectedExecutionHandler</span> handler<span class=\"token comment\">// 拒绝策略，当提交的任务过多而不能及时处理时，我们可以定制策略来处理任务</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>                               <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>corePoolSize <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span> <span class=\"token operator\">||</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>            maximumPoolSize <span class=\"token operator\">&lt;=</span> <span class=\"token number\">0</span> <span class=\"token operator\">||</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>            maximumPoolSize <span class=\"token operator\">&lt;</span> corePoolSize <span class=\"token operator\">||</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>            keepAliveTime <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>            <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">IllegalArgumentException</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>workQueue <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">||</span> threadFactory <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">||</span> handler <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>            <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">NullPointerException</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>corePoolSize <span class=\"token operator\">=</span> corePoolSize<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>maximumPoolSize <span class=\"token operator\">=</span> maximumPoolSize<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>workQueue <span class=\"token operator\">=</span> workQueue<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>keepAliveTime <span class=\"token operator\">=</span> unit<span class=\"token punctuation\">.</span><span class=\"token function\">toNanos</span><span class=\"token punctuation\">(</span>keepAliveTime<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>threadFactory <span class=\"token operator\">=</span> threadFactory<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>handler <span class=\"token operator\">=</span> handler<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h4 id=\"常见参数\"><a class=\"anchor\" href=\"#常见参数\">#</a> <mark>常见参数</mark></h4>\n<p><code>ThreadPoolExecutor</code>  3 个最重要的参数：</p>\n<ul>\n<li><strong> <code>corePoolSize</code>  :</strong> <font color='gree'>核心线程数量</font>。<font color='red'>当任务队列未达到队列容量时</font>，最大可以同时运行的线程数量。</li>\n<li><strong> <code>maximumPoolSize</code> </strong> : <font color='gree'>最大线程数量</font>。<font color='red'>任务队列中存放的任务达到队列容量的时候</font>，当前可以同时运行的线程数量变为最大线程数。</li>\n<li><strong> <code>workQueue</code> </strong>：<font color='gree'>任务队列</font>。新任务来的时候会先判断<font color='red'>当前运行的线程数量是否达到核心线程数</font>，如果达到的话，新任务就会被存放在队列中。</li>\n</ul>\n<p>其他常见参数:</p>\n<ul>\n<li><strong> <code>keepAliveTime</code> </strong>：<font color='gree'>当线程数大于  <code>corePoolSize</code>  时，多余的空闲线程存活的最长时间</font>。\n<ul>\n<li>当线程池中的线程数量大于  <code>corePoolSize</code>  时，如果这时没有新的任务提交，多余的空闲线程不会立即销毁，而是会等待，直到等待的时间超过了  <code>keepAliveTime</code>  才会被回收销毁。</li>\n<li>线程池回收线程时，会对核心线程和非核心线程一视同仁，直到线程池中线程的数量等于  <code>corePoolSize</code>  ，回收过程才会停止。</li>\n</ul>\n</li>\n<li><strong> <code>unit</code> </strong>： <code>keepAliveTime</code>  参数的<font color='gree'>时间单位</font>。</li>\n<li><strong> <code>threadFactory</code> </strong> :<font color='gree'>线程工厂</font>，用来创建线程，一般默认即可。</li>\n<li><strong> <code>handler</code> </strong>：<font color='gree'>饱和策略</font>。当提交的任务过多而不能及时处理时，我们可以定制策略来处理任务。</li>\n</ul>\n<p>对线程池中各个参数的相互关系的理解：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231018163149255.png\" alt=\"image-20231018163149255\" /></p>\n<h4 id=\"饱和策略\"><a class=\"anchor\" href=\"#饱和策略\">#</a> 饱和策略</h4>\n<p>如果当前同时运行的线程数量达到  <code>maximumPoolSize</code> ，并且  <code>workQueue</code>  也被放满任务时， <code>ThreadPoolTaskExecutor</code>  定义一些策略：</p>\n<ul>\n<li>ThreadPoolExecutor.<strong> <code>AbortPolicy</code> </strong>：<font color='red'>默认的饱和策略</font>。抛出  <code>RejectedExecutionException</code>  异常来<font color='gree'>拒绝新任务的处理</font>。</li>\n<li>ThreadPoolExecutor.<strong> <code>CallerRunsPolicy</code> </strong>：它既<font color='gree'>不会抛弃任务</font>，也不会抛出异常，而是<font color='gree'>将任务回退给调用者，使用调用者的线程来执行任务</font>。直接在调用 <code>execute</code>  方法的调用者线程中运行 ( <code>run</code> ) 任务。如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。如果您的应用程序可以承受此延迟并且你要求任何一个任务请求都要被执行的话，你可以选择这个策略。</li>\n<li>ThreadPoolExecutor.<strong> <code>DiscardPolicy</code> </strong>：不处理新任务，<font color='gree'>直接丢弃掉</font>。</li>\n<li>ThreadPoolExecutor.<strong> <code>DiscardOldestPolicy</code> </strong>：此策略将<font color='gree'>丢弃最早的未处理的任务请求</font>。</li>\n</ul>\n<hr />\n<p>举个例子：</p>\n<p>Spring 通过  <code>ThreadPoolTaskExecutor</code>  或者我们直接通过  <code>ThreadPoolExecutor</code>  的构造函数创建线程池的时候，当我们不指定  <code>RejectedExecutionHandler</code>  饱和策略来配置线程池的时候，默认使用的是  <code>AbortPolicy</code> 。在这种饱和策略下，如果队列满了， <code>ThreadPoolExecutor</code>  将抛出  <code>RejectedExecutionException</code>  异常来拒绝新来的任务 ，这代表你将丢失对这个任务的处理。</p>\n<p>如果不想丢弃任务的话，可以使用  <code>CallerRunsPolicy</code> 。和其他的几个策略不同，它既不会抛弃任务，也不会抛出异常，而是将任务回退给调用者，使用调用者的线程来执行任务。</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">CallerRunsPolicy</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">RejectedExecutionHandler</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>        <span class=\"token keyword\">public</span> <span class=\"token class-name\">CallerRunsPolicy</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>        <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">rejectedExecution</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Runnable</span> r<span class=\"token punctuation\">,</span> <span class=\"token class-name\">ThreadPoolExecutor</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>e<span class=\"token punctuation\">.</span><span class=\"token function\">isShutdown</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>                <span class=\"token comment\">// 直接主线程执行，而不是线程池中的线程执行</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>                r<span class=\"token punctuation\">.</span><span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>            <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h4 id=\"线程池的创建方式\"><a class=\"anchor\" href=\"#线程池的创建方式\">#</a> 线程池的创建方式</h4>\n<h5 id=\"方式1threadpoolexecutor-类的构造函数\"><a class=\"anchor\" href=\"#方式1threadpoolexecutor-类的构造函数\">#</a> 方式 1：ThreadPoolExecutor 类的构造函数</h5>\n<blockquote>\n<p>推荐！</p>\n</blockquote>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231015003053159.png\" alt=\"image-20231015003053159\" /></p>\n<h5 id=\"方式2executor-框架的-executors-工具类\"><a class=\"anchor\" href=\"#方式2executor-框架的-executors-工具类\">#</a> 方式 2：Executor 框架的 Executors 工具类</h5>\n<blockquote>\n<p>不推荐～</p>\n</blockquote>\n<p>我们可以创建多种类型的  <code>ThreadPoolExecutor</code> ：</p>\n<ul>\n<li><strong> <code>FixedThreadPool</code> </strong>：该方法返回一个<font color='red'>固定线程数量</font>的线程池。\n<ul>\n<li>该线程池中的线程数量始终不变。</li>\n<li>当有一个新的任务提交时，\n<ul>\n<li>若线程池中有空闲线程，则立即执行。</li>\n<li>若线程池中没有空间线程，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong> <code>SingleThreadExecutor</code> ：</strong> 该方法返回一个<font color='red'>只有一个线程</font>的线程池。\n<ul>\n<li>若多于一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。</li>\n</ul>\n</li>\n<li><strong> <code>CachedThreadPool</code> ：</strong> 该方法返回一个<font color='red'>会根据需要创建线程</font>的线程池。\n<ul>\n<li>初始大小为 0。</li>\n<li>当有新任务提交时，如果当前线程池中没有线程可用，它会创建一个新的线程来处理该任务。</li>\n<li>如果在一段时间内（默认为 60 秒）没有新任务提交，核心线程会超时并被销毁，从而缩小线程池的大小。</li>\n</ul>\n</li>\n<li><strong> <code>ScheduledThreadPool</code> </strong>：该方法返回一个用来<font color='red'>在给定的延迟后，或者定期执行任务</font>的线程池。</li>\n</ul>\n<p>对应  <code>Executors</code>  工具类中的方法如图所示：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/executors-inner-threadpool.png\" alt=\"img\" /></p>\n<p>在《阿里巴巴 Java 开发手册》“并发处理” 这一章节，明确指出<strong>线程资源必须通过线程池提供，不允许在应用中自行显式创建线程</strong>。</p>\n<blockquote>\n<p>原因：<font color='red'>使用线程池可以减少在创建和销毁线程上所消耗的开销</font>，解决资源不足的问题。如果不使用线程池，有可能会造成系统创建大量同类线程而导致消耗完内存或者 “过度切换” 的问题。</p>\n</blockquote>\n<p>另外，《阿里巴巴 Java 开发手册》中<strong>强制线程池不允许使用  <code>Executors</code>  工具类去创建，而是通过  <code>ThreadPoolExecutor</code>  构造函数的方式</strong>。这样的处理方式让写的同学更加明确线程池的运行规则，<font color='red'>规避资源耗尽（OOM）的风险</font>。</p>\n<p><code>Executors</code>  工具类返回线程池对象的弊端如下 (后文会详细介绍到)：</p>\n<ul>\n<li><strong> <code>FixedThreadPool</code>  和  <code>SingleThreadExecutor</code> </strong>：使用的是无界的  <code>LinkedBlockingQueue</code> ，任务队列最大长度为  <code>Integer.MAX_VALUE</code> ，<font color='red'>可能堆积大量的请求，从而导致 OOM</font>。</li>\n<li><strong> <code>CachedThreadPool</code> </strong>：使用的是同步队列  <code>SynchronousQueue</code> ，允许创建的线程数量为  <code>Integer.MAX_VALUE</code>  ，如果任务数量过多且执行速度较慢，<font color='red'>可能会创建大量的线程，从而导致 OOM</font>。</li>\n<li><strong> <code>ScheduledThreadPool</code>  和  <code>SingleThreadScheduledExecutor</code> </strong> : 使用的无界的延迟阻塞队列 <code>DelayedWorkQueue</code> ，任务队列最大长度为  <code>Integer.MAX_VALUE</code> ，可能堆积大量的请求，从而导致 OOM 。</li>\n</ul>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">// 无界队列 LinkedBlockingQueue</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token class-name\">ExecutorService</span> <span class=\"token function\">newFixedThreadPool</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> nThreads<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ThreadPoolExecutor</span><span class=\"token punctuation\">(</span>nThreads<span class=\"token punctuation\">,</span> nThreads<span class=\"token punctuation\">,</span><span class=\"token number\">0L</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">TimeUnit</span><span class=\"token punctuation\">.</span><span class=\"token constant\">MILLISECONDS</span><span class=\"token punctuation\">,</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">LinkedBlockingQueue</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Runnable</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token comment\">// 无界队列 LinkedBlockingQueue</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token class-name\">ExecutorService</span> <span class=\"token function\">newSingleThreadExecutor</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">FinalizableDelegatedExecutorService</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">ThreadPoolExecutor</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">0L</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">TimeUnit</span><span class=\"token punctuation\">.</span><span class=\"token constant\">MILLISECONDS</span><span class=\"token punctuation\">,</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">LinkedBlockingQueue</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Runnable</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre></pre></td></tr><tr><td data-num=\"15\"></td><td><pre><span class=\"token comment\">// 同步队列 SynchronousQueue，没有容量，最大线程数是 Integer.MAX_VALUE`</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token class-name\">ExecutorService</span> <span class=\"token function\">newCachedThreadPool</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>    <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ThreadPoolExecutor</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">Integer</span><span class=\"token punctuation\">.</span><span class=\"token constant\">MAX_VALUE</span><span class=\"token punctuation\">,</span><span class=\"token number\">60L</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">TimeUnit</span><span class=\"token punctuation\">.</span><span class=\"token constant\">SECONDS</span><span class=\"token punctuation\">,</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">SynchronousQueue</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Runnable</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre></pre></td></tr><tr><td data-num=\"20\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre></pre></td></tr><tr><td data-num=\"22\"></td><td><pre><span class=\"token comment\">// DelayedWorkQueue（延迟阻塞队列）</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token class-name\">ScheduledExecutorService</span> <span class=\"token function\">newScheduledThreadPool</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> corePoolSize<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>    <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ScheduledThreadPoolExecutor</span><span class=\"token punctuation\">(</span>corePoolSize<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token class-name\">ScheduledThreadPoolExecutor</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> corePoolSize<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>    <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>corePoolSize<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Integer</span><span class=\"token punctuation\">.</span><span class=\"token constant\">MAX_VALUE</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">NANOSECONDS</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>          <span class=\"token keyword\">new</span> <span class=\"token class-name\">DelayedWorkQueue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h4 id=\"常用的阻塞队列\"><a class=\"anchor\" href=\"#常用的阻塞队列\">#</a> 常用的阻塞队列</h4>\n<blockquote>\n<p>即任务队列。难！</p>\n</blockquote>\n<p>新任务来的时候会先判断当前运行的线程数量是否达到 <code>corePoolSize</code> ，如果达到的话，新任务就会被存放在阻塞队列  <code>workQueue</code>  中。</p>\n<p>不同的线程池会选用不同的阻塞队列，我们可以结合内置线程池来分析：</p>\n<ul>\n<li>\n<p><strong>无界阻塞队列  <code>LinkedBlockingQueue</code> </strong>：</p>\n<ul>\n<li>容量为  <code>Integer.MAX_VALUE</code></li>\n<li><code>FixedThreadPool</code>  和  <code>SingleThreadExector</code>  这两种线程池都是用的是无界队列，因此二者的任务队列永远不会被放满。</li>\n<li><code>FixedThreadPool</code>  最多只能创建  <code>corePoolSize</code>  个线程</li>\n<li><code>SingleThreadExector</code>  只能创建 1 个线程</li>\n</ul>\n</li>\n<li>\n<p><strong>同步队列  <code>SynchronousQueue</code> </strong>：</p>\n<ul>\n<li><font color='red'>容量为 0，不存储元素</font>。</li>\n<li>目的是保证对于提交的任务，如果有空闲线程，则使用空闲线程来处理；否则新建一个线程来处理任务。</li>\n<li><code>CachedThreadPool</code>  线程池使用的是同步队列。</li>\n<li>也就是说， <code>CachedThreadPool</code>  的最大线程数是  <code>Integer.MAX_VALUE</code>  ，可以理解为线程数是可以无限扩展的，可能会创建大量线程，从而导致 OOM 。</li>\n</ul>\n</li>\n<li>\n<p><strong>延迟阻塞队列  <code>DelayedWorkQueue</code> </strong>：</p>\n<ul>\n<li>该队列的<font color='red'>内部元素并不是按照放入的时间排序，而是会按照延迟的时间长短对任务进行排序</font>。内部采用的是 “堆” 的数据结构，可以保证每次出队的任务都是当前队列中执行时间最靠前的。</li>\n<li><code>ScheduledThreadPool</code>  和  <code>SingleThreadScheduledExecutor</code>  这两种线程池使用的是延迟阻塞队列。</li>\n<li><code>DelayedWorkQueue</code>  添加元素满了之后会自动<font color='red'>扩容原来容量的 1/2</font>，即永远不会阻塞，最大扩容可达  <code>Integer.MAX_VALUE</code> ，所以最多只能创建  <code>corePoolSize</code>  个线程。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"线程池原理分析\"><a class=\"anchor\" href=\"#线程池原理分析\">#</a> <mark>线程池原理分析</mark></h3>\n<p>我们上面讲解了  <code>Executor</code>  框架以及  <code>ThreadPoolExecutor</code>  类，下面让我们实战一下，来通过写一个  <code>ThreadPoolExecutor</code>  的小 Demo 来回顾上面的内容。</p>\n<h4 id=\"threadpoolexecutor-示例代码\"><a class=\"anchor\" href=\"#threadpoolexecutor-示例代码\">#</a> ThreadPoolExecutor 示例代码</h4>\n<p>首先创建一个  <code>Runnable</code>  接口的实现类（也可以是  <code>Callable</code>  接口的实现类）</p>\n<p><code>MyRunnable.java</code> ：</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">java<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">Date</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token comment\">/**</pre></td></tr><tr><td data-num=\"4\"></td><td><pre> * 这是一个简单的 Runnable 类，需要大约 5 秒钟来执行其任务。</pre></td></tr><tr><td data-num=\"5\"></td><td><pre> * @author shuang.kou</pre></td></tr><tr><td data-num=\"6\"></td><td><pre> */</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">MyRunnable</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Runnable</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> command<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token class-name\">MyRunnable</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> s<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>command <span class=\"token operator\">=</span> s<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    <span class=\"token annotation punctuation\">@Override</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Thread</span><span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token string\">\" Start. Time = \"</span> <span class=\"token operator\">+</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Date</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>        <span class=\"token function\">processCommand</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Thread</span><span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token string\">\" End. Time = \"</span> <span class=\"token operator\">+</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Date</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>    <span class=\"token keyword\">private</span> <span class=\"token keyword\">void</span> <span class=\"token function\">processCommand</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>        <span class=\"token keyword\">try</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>            <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">5000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">InterruptedException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>            e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>    <span class=\"token annotation punctuation\">@Override</span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token class-name\">String</span> <span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"32\"></td><td><pre>        <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>command<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"33\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"34\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>编写测试程序，我们这里以阿里巴巴推荐的使用  <code>ThreadPoolExecutor</code>  构造函数自定义参数的方式来创建线程池。</p>\n<p><code>ThreadPoolExecutorDemo.java</code> ：</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">java<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span>concurrent<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">ArrayBlockingQueue</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">java<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span>concurrent<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">ThreadPoolExecutor</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">java<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span>concurrent<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">TimeUnit</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">ThreadPoolExecutorDemo</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> <span class=\"token constant\">CORE_POOL_SIZE</span> <span class=\"token operator\">=</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> <span class=\"token constant\">MAX_POOL_SIZE</span> <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> <span class=\"token constant\">QUEUE_CAPACITY</span> <span class=\"token operator\">=</span> <span class=\"token number\">100</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">Long</span> <span class=\"token constant\">KEEP_ALIVE_TIME</span> <span class=\"token operator\">=</span> <span class=\"token number\">1L</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>        <span class=\"token comment\">// 使用阿里巴巴推荐的创建线程池的方式</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>        <span class=\"token comment\">// 通过 ThreadPoolExecutor 构造函数自定义参数创建</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>        <span class=\"token class-name\">ThreadPoolExecutor</span> executor <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ThreadPoolExecutor</span><span class=\"token punctuation\">(</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>                <span class=\"token constant\">CORE_POOL_SIZE</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>                <span class=\"token constant\">MAX_POOL_SIZE</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>                <span class=\"token constant\">KEEP_ALIVE_TIME</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>                <span class=\"token class-name\">TimeUnit</span><span class=\"token punctuation\">.</span><span class=\"token constant\">SECONDS</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>                <span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayBlockingQueue</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token constant\">QUEUE_CAPACITY</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>                <span class=\"token keyword\">new</span> <span class=\"token class-name\">ThreadPoolExecutor<span class=\"token punctuation\">.</span>CallerRunsPolicy</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>            <span class=\"token comment\">// 创建 WorkerThread 对象（WorkerThread 类实现了 Runnable 接口）</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>            <span class=\"token class-name\">Runnable</span> worker <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">MyRunnable</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"\"</span> <span class=\"token operator\">+</span> i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>            <span class=\"token comment\">// 执行 Runnable</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>            executor<span class=\"token punctuation\">.</span><span class=\"token function\">execute</span><span class=\"token punctuation\">(</span>worker<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>        <span class=\"token comment\">// 终止线程池</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>        executor<span class=\"token punctuation\">.</span><span class=\"token function\">shutdown</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre>        <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>executor<span class=\"token punctuation\">.</span><span class=\"token function\">isTerminated</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"32\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"33\"></td><td><pre>        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Finished all threads\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"34\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"35\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>上面的代码指定了：</p>\n<ul>\n<li><code>corePoolSize</code> : 核心线程数为 5。</li>\n<li><code>maximumPoolSize</code> ：最大线程数 10</li>\n<li><code>keepAliveTime</code>  : 等待时间为 1L。</li>\n<li><code>unit</code> : 等待时间的单位为 TimeUnit.SECONDS。</li>\n<li><code>workQueue</code> ：任务队列为  <code>ArrayBlockingQueue</code> ，并且容量为 100;</li>\n<li><code>handler</code> : 饱和策略为  <code>CallerRunsPolicy</code> 。</li>\n</ul>\n<p>输出结构：</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>pool<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token operator\">-</span>thread<span class=\"token operator\">-</span><span class=\"token number\">3</span> <span class=\"token class-name\">Start<span class=\"token punctuation\">.</span> Time</span> <span class=\"token operator\">=</span> <span class=\"token class-name\">Sun</span> <span class=\"token class-name\">Apr</span> <span class=\"token number\">12</span> <span class=\"token number\">11</span><span class=\"token operator\">:</span><span class=\"token number\">14</span><span class=\"token operator\">:</span><span class=\"token number\">37</span> <span class=\"token constant\">CST</span> <span class=\"token number\">2020</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>pool<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token operator\">-</span>thread<span class=\"token operator\">-</span><span class=\"token number\">5</span> <span class=\"token class-name\">Start<span class=\"token punctuation\">.</span> Time</span> <span class=\"token operator\">=</span> <span class=\"token class-name\">Sun</span> <span class=\"token class-name\">Apr</span> <span class=\"token number\">12</span> <span class=\"token number\">11</span><span class=\"token operator\">:</span><span class=\"token number\">14</span><span class=\"token operator\">:</span><span class=\"token number\">37</span> <span class=\"token constant\">CST</span> <span class=\"token number\">2020</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>pool<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token operator\">-</span>thread<span class=\"token operator\">-</span><span class=\"token number\">2</span> <span class=\"token class-name\">Start<span class=\"token punctuation\">.</span> Time</span> <span class=\"token operator\">=</span> <span class=\"token class-name\">Sun</span> <span class=\"token class-name\">Apr</span> <span class=\"token number\">12</span> <span class=\"token number\">11</span><span class=\"token operator\">:</span><span class=\"token number\">14</span><span class=\"token operator\">:</span><span class=\"token number\">37</span> <span class=\"token constant\">CST</span> <span class=\"token number\">2020</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>pool<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token operator\">-</span>thread<span class=\"token operator\">-</span><span class=\"token number\">1</span> <span class=\"token class-name\">Start<span class=\"token punctuation\">.</span> Time</span> <span class=\"token operator\">=</span> <span class=\"token class-name\">Sun</span> <span class=\"token class-name\">Apr</span> <span class=\"token number\">12</span> <span class=\"token number\">11</span><span class=\"token operator\">:</span><span class=\"token number\">14</span><span class=\"token operator\">:</span><span class=\"token number\">37</span> <span class=\"token constant\">CST</span> <span class=\"token number\">2020</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>pool<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token operator\">-</span>thread<span class=\"token operator\">-</span><span class=\"token number\">4</span> <span class=\"token class-name\">Start<span class=\"token punctuation\">.</span> Time</span> <span class=\"token operator\">=</span> <span class=\"token class-name\">Sun</span> <span class=\"token class-name\">Apr</span> <span class=\"token number\">12</span> <span class=\"token number\">11</span><span class=\"token operator\">:</span><span class=\"token number\">14</span><span class=\"token operator\">:</span><span class=\"token number\">37</span> <span class=\"token constant\">CST</span> <span class=\"token number\">2020</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>pool<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token operator\">-</span>thread<span class=\"token operator\">-</span><span class=\"token number\">3</span> <span class=\"token class-name\">End<span class=\"token punctuation\">.</span> Time</span> <span class=\"token operator\">=</span> <span class=\"token class-name\">Sun</span> <span class=\"token class-name\">Apr</span> <span class=\"token number\">12</span> <span class=\"token number\">11</span><span class=\"token operator\">:</span><span class=\"token number\">14</span><span class=\"token operator\">:</span><span class=\"token number\">42</span> <span class=\"token constant\">CST</span> <span class=\"token number\">2020</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>pool<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token operator\">-</span>thread<span class=\"token operator\">-</span><span class=\"token number\">4</span> <span class=\"token class-name\">End<span class=\"token punctuation\">.</span> Time</span> <span class=\"token operator\">=</span> <span class=\"token class-name\">Sun</span> <span class=\"token class-name\">Apr</span> <span class=\"token number\">12</span> <span class=\"token number\">11</span><span class=\"token operator\">:</span><span class=\"token number\">14</span><span class=\"token operator\">:</span><span class=\"token number\">42</span> <span class=\"token constant\">CST</span> <span class=\"token number\">2020</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>pool<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token operator\">-</span>thread<span class=\"token operator\">-</span><span class=\"token number\">1</span> <span class=\"token class-name\">End<span class=\"token punctuation\">.</span> Time</span> <span class=\"token operator\">=</span> <span class=\"token class-name\">Sun</span> <span class=\"token class-name\">Apr</span> <span class=\"token number\">12</span> <span class=\"token number\">11</span><span class=\"token operator\">:</span><span class=\"token number\">14</span><span class=\"token operator\">:</span><span class=\"token number\">42</span> <span class=\"token constant\">CST</span> <span class=\"token number\">2020</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>pool<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token operator\">-</span>thread<span class=\"token operator\">-</span><span class=\"token number\">5</span> <span class=\"token class-name\">End<span class=\"token punctuation\">.</span> Time</span> <span class=\"token operator\">=</span> <span class=\"token class-name\">Sun</span> <span class=\"token class-name\">Apr</span> <span class=\"token number\">12</span> <span class=\"token number\">11</span><span class=\"token operator\">:</span><span class=\"token number\">14</span><span class=\"token operator\">:</span><span class=\"token number\">42</span> <span class=\"token constant\">CST</span> <span class=\"token number\">2020</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>pool<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token operator\">-</span>thread<span class=\"token operator\">-</span><span class=\"token number\">1</span> <span class=\"token class-name\">Start<span class=\"token punctuation\">.</span> Time</span> <span class=\"token operator\">=</span> <span class=\"token class-name\">Sun</span> <span class=\"token class-name\">Apr</span> <span class=\"token number\">12</span> <span class=\"token number\">11</span><span class=\"token operator\">:</span><span class=\"token number\">14</span><span class=\"token operator\">:</span><span class=\"token number\">42</span> <span class=\"token constant\">CST</span> <span class=\"token number\">2020</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>pool<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token operator\">-</span>thread<span class=\"token operator\">-</span><span class=\"token number\">2</span> <span class=\"token class-name\">End<span class=\"token punctuation\">.</span> Time</span> <span class=\"token operator\">=</span> <span class=\"token class-name\">Sun</span> <span class=\"token class-name\">Apr</span> <span class=\"token number\">12</span> <span class=\"token number\">11</span><span class=\"token operator\">:</span><span class=\"token number\">14</span><span class=\"token operator\">:</span><span class=\"token number\">42</span> <span class=\"token constant\">CST</span> <span class=\"token number\">2020</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>pool<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token operator\">-</span>thread<span class=\"token operator\">-</span><span class=\"token number\">5</span> <span class=\"token class-name\">Start<span class=\"token punctuation\">.</span> Time</span> <span class=\"token operator\">=</span> <span class=\"token class-name\">Sun</span> <span class=\"token class-name\">Apr</span> <span class=\"token number\">12</span> <span class=\"token number\">11</span><span class=\"token operator\">:</span><span class=\"token number\">14</span><span class=\"token operator\">:</span><span class=\"token number\">42</span> <span class=\"token constant\">CST</span> <span class=\"token number\">2020</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>pool<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token operator\">-</span>thread<span class=\"token operator\">-</span><span class=\"token number\">4</span> <span class=\"token class-name\">Start<span class=\"token punctuation\">.</span> Time</span> <span class=\"token operator\">=</span> <span class=\"token class-name\">Sun</span> <span class=\"token class-name\">Apr</span> <span class=\"token number\">12</span> <span class=\"token number\">11</span><span class=\"token operator\">:</span><span class=\"token number\">14</span><span class=\"token operator\">:</span><span class=\"token number\">42</span> <span class=\"token constant\">CST</span> <span class=\"token number\">2020</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>pool<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token operator\">-</span>thread<span class=\"token operator\">-</span><span class=\"token number\">3</span> <span class=\"token class-name\">Start<span class=\"token punctuation\">.</span> Time</span> <span class=\"token operator\">=</span> <span class=\"token class-name\">Sun</span> <span class=\"token class-name\">Apr</span> <span class=\"token number\">12</span> <span class=\"token number\">11</span><span class=\"token operator\">:</span><span class=\"token number\">14</span><span class=\"token operator\">:</span><span class=\"token number\">42</span> <span class=\"token constant\">CST</span> <span class=\"token number\">2020</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>pool<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token operator\">-</span>thread<span class=\"token operator\">-</span><span class=\"token number\">2</span> <span class=\"token class-name\">Start<span class=\"token punctuation\">.</span> Time</span> <span class=\"token operator\">=</span> <span class=\"token class-name\">Sun</span> <span class=\"token class-name\">Apr</span> <span class=\"token number\">12</span> <span class=\"token number\">11</span><span class=\"token operator\">:</span><span class=\"token number\">14</span><span class=\"token operator\">:</span><span class=\"token number\">42</span> <span class=\"token constant\">CST</span> <span class=\"token number\">2020</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>pool<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token operator\">-</span>thread<span class=\"token operator\">-</span><span class=\"token number\">1</span> <span class=\"token class-name\">End<span class=\"token punctuation\">.</span> Time</span> <span class=\"token operator\">=</span> <span class=\"token class-name\">Sun</span> <span class=\"token class-name\">Apr</span> <span class=\"token number\">12</span> <span class=\"token number\">11</span><span class=\"token operator\">:</span><span class=\"token number\">14</span><span class=\"token operator\">:</span><span class=\"token number\">47</span> <span class=\"token constant\">CST</span> <span class=\"token number\">2020</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>pool<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token operator\">-</span>thread<span class=\"token operator\">-</span><span class=\"token number\">4</span> <span class=\"token class-name\">End<span class=\"token punctuation\">.</span> Time</span> <span class=\"token operator\">=</span> <span class=\"token class-name\">Sun</span> <span class=\"token class-name\">Apr</span> <span class=\"token number\">12</span> <span class=\"token number\">11</span><span class=\"token operator\">:</span><span class=\"token number\">14</span><span class=\"token operator\">:</span><span class=\"token number\">47</span> <span class=\"token constant\">CST</span> <span class=\"token number\">2020</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>pool<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token operator\">-</span>thread<span class=\"token operator\">-</span><span class=\"token number\">5</span> <span class=\"token class-name\">End<span class=\"token punctuation\">.</span> Time</span> <span class=\"token operator\">=</span> <span class=\"token class-name\">Sun</span> <span class=\"token class-name\">Apr</span> <span class=\"token number\">12</span> <span class=\"token number\">11</span><span class=\"token operator\">:</span><span class=\"token number\">14</span><span class=\"token operator\">:</span><span class=\"token number\">47</span> <span class=\"token constant\">CST</span> <span class=\"token number\">2020</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>pool<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token operator\">-</span>thread<span class=\"token operator\">-</span><span class=\"token number\">3</span> <span class=\"token class-name\">End<span class=\"token punctuation\">.</span> Time</span> <span class=\"token operator\">=</span> <span class=\"token class-name\">Sun</span> <span class=\"token class-name\">Apr</span> <span class=\"token number\">12</span> <span class=\"token number\">11</span><span class=\"token operator\">:</span><span class=\"token number\">14</span><span class=\"token operator\">:</span><span class=\"token number\">47</span> <span class=\"token constant\">CST</span> <span class=\"token number\">2020</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>pool<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token operator\">-</span>thread<span class=\"token operator\">-</span><span class=\"token number\">2</span> <span class=\"token class-name\">End<span class=\"token punctuation\">.</span> Time</span> <span class=\"token operator\">=</span> <span class=\"token class-name\">Sun</span> <span class=\"token class-name\">Apr</span> <span class=\"token number\">12</span> <span class=\"token number\">11</span><span class=\"token operator\">:</span><span class=\"token number\">14</span><span class=\"token operator\">:</span><span class=\"token number\">47</span> <span class=\"token constant\">CST</span> <span class=\"token number\">2020</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre><span class=\"token class-name\">Finished</span> all threads  <span class=\"token comment\">// 任务全部执行完了才会跳出来，因为 executor.isTerminated () 判断为 true 了才会跳出 while 循环，当且仅当调用 shutdown () 方法后，并且所有提交的任务完成后返回为 true</span></pre></td></tr></table></figure><h4 id=\"线程池原理分析处理任务的流程\"><a class=\"anchor\" href=\"#线程池原理分析处理任务的流程\">#</a> <mark>线程池原理分析（处理任务的流程）</mark></h4>\n<p>在示例代码中，我们使用  <code>executor.execute(worker)</code>  来提交一个任务到线程池中去。为了搞懂线程池的原理，我们需要首先分析一下  <code>execute()</code>  方法，源码如下：</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">// 存放线程池的运行状态 (runState) 和线程池内有效线程的数量 (workerCount)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>   <span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">AtomicInteger</span> ctl <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">AtomicInteger</span><span class=\"token punctuation\">(</span><span class=\"token function\">ctlOf</span><span class=\"token punctuation\">(</span><span class=\"token constant\">RUNNING</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> <span class=\"token function\">workerCountOf</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> c<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>        <span class=\"token keyword\">return</span> c <span class=\"token operator\">&amp;</span> <span class=\"token constant\">CAPACITY</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token comment\">// 任务队列</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">BlockingQueue</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Runnable</span><span class=\"token punctuation\">></span></span> workQueue<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">execute</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Runnable</span> command<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>        <span class=\"token comment\">// 如果任务为 null，则抛出异常。</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>command <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>            <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">NullPointerException</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>        <span class=\"token comment\">//ctl 中保存的线程池当前的一些状态信息</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>        <span class=\"token keyword\">int</span> c <span class=\"token operator\">=</span> ctl<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>        <span class=\"token comment\">//  下面会涉及到 3 步 操作</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>        <span class=\"token comment\">// 1. 首先判断当前线程池中执行的任务数量是否小于 corePoolSize</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>        <span class=\"token comment\">// 如果小于的话，通过 addWorker (command, true) 新建一个线程，并将任务 (command) 添加到该线程中；然后，启动该线程从而执行任务。</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">workerCountOf</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;</span> corePoolSize<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">addWorker</span><span class=\"token punctuation\">(</span>command<span class=\"token punctuation\">,</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>                <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>            c <span class=\"token operator\">=</span> ctl<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>        <span class=\"token comment\">// 2. 如果当前执行的任务数量大于等于 corePoolSize 的时候就会走到这里，表明创建新的线程失败。</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>        <span class=\"token comment\">// 通过 isRunning 方法判断线程池状态，线程池处于 RUNNING 状态并且队列可以加入任务，该任务才会被加入进去</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isRunning</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> workQueue<span class=\"token punctuation\">.</span><span class=\"token function\">offer</span><span class=\"token punctuation\">(</span>command<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>            <span class=\"token keyword\">int</span> recheck <span class=\"token operator\">=</span> ctl<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>            <span class=\"token comment\">// 再次获取线程池状态，如果线程池状态不是 RUNNING 状态就需要从任务队列中移除任务，并尝试判断线程是否全部执行完毕。同时执行拒绝策略。</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token function\">isRunning</span><span class=\"token punctuation\">(</span>recheck<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">remove</span><span class=\"token punctuation\">(</span>command<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre>                <span class=\"token function\">reject</span><span class=\"token punctuation\">(</span>command<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"32\"></td><td><pre>                <span class=\"token comment\">// 如果当前工作线程数量为 0，新创建一个线程并执行。</span></pre></td></tr><tr><td data-num=\"33\"></td><td><pre>            <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">workerCountOf</span><span class=\"token punctuation\">(</span>recheck<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"34\"></td><td><pre>                <span class=\"token function\">addWorker</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"35\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"36\"></td><td><pre>        <span class=\"token comment\">//3. 通过 addWorker (command, false) 新建一个线程，并将任务 (command) 添加到该线程中；然后，启动该线程从而执行任务。</span></pre></td></tr><tr><td data-num=\"37\"></td><td><pre>        <span class=\"token comment\">// 传入 false 代表增加线程时判断当前线程数是否少于 maxPoolSize</span></pre></td></tr><tr><td data-num=\"38\"></td><td><pre>        <span class=\"token comment\">// 如果 addWorker (command, false) 执行失败，则通过 reject () 执行相应的拒绝策略的内容。</span></pre></td></tr><tr><td data-num=\"39\"></td><td><pre>        <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token function\">addWorker</span><span class=\"token punctuation\">(</span>command<span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"40\"></td><td><pre>            <span class=\"token function\">reject</span><span class=\"token punctuation\">(</span>command<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"41\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><hr />\n<p><strong>简单分析一下整个流程</strong>：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/thread-pool-principle.png\" alt=\"图解线程池实现原理\" /></p>\n<ol>\n<li>\n<p>如果 当前运行的线程数 ＜  <code>corePoolSize</code>  ，那么就会<font color='red'>新建一个线程</font>来执行任务。</p>\n</li>\n<li>\n<p>如果  <code>corePoolSize</code>  ≤ 当前运行的线程数 ＜  <code>maximumPoolSize</code> ，那么就<font color='red'>把该任务放入到任务队列里等待执行</font>。</p>\n<ol>\n<li><font color='red'>如果向任务队列添加任务失败（即任务队列已经满了），就新建一个线程</font>来执行任务。</li>\n</ol>\n</li>\n<li>\n<p>如果 当前运行的线程数 ==  <code>maximumPoolSize</code> ，此时任务队列、线程池都满了，那么会根据<font color='red'>饱和策略</font>来处理无法接收的任务，比如抛出异常或者丢弃任务。</p>\n</li>\n</ol>\n<hr />\n<p>在  <code>execute()</code>  方法中，多次调用  <code>addWorker()</code>  方法，该方法主要用来<font color='red'>创建新的工作线程</font>，如果创建和启动工作线程成功则返回 true ，否则返回 false。</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">// 全局锁，并发操作必备</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">ReentrantLock</span> mainLock <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ReentrantLock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token comment\">// 跟踪线程池的最大大小，只有在持有全局锁 mainLock 的前提下才能访问此集合</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token keyword\">private</span> <span class=\"token keyword\">int</span> largestPoolSize<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token comment\">// 工作线程集合，存放线程池中所有的（活跃的）工作线程，只有在持有全局锁 mainLock 的前提下才能访问此集合</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">HashSet</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Worker</span><span class=\"token punctuation\">></span></span> workers <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">HashSet</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token comment\">// 获取线程池状态</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> <span class=\"token function\">runStateOf</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> c<span class=\"token punctuation\">)</span>     <span class=\"token punctuation\">&#123;</span> <span class=\"token keyword\">return</span> c <span class=\"token operator\">&amp;</span> <span class=\"token operator\">~</span><span class=\"token constant\">CAPACITY</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token comment\">// 判断线程池的状态是否为 Running</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">isRunning</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> c<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>        <span class=\"token keyword\">return</span> c <span class=\"token operator\">&lt;</span> <span class=\"token constant\">SHUTDOWN</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre></pre></td></tr><tr><td data-num=\"14\"></td><td><pre></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    <span class=\"token comment\">/**</pre></td></tr><tr><td data-num=\"16\"></td><td><pre>     * 添加新的工作线程到线程池</pre></td></tr><tr><td data-num=\"17\"></td><td><pre>     * @param firstTask 要执行</pre></td></tr><tr><td data-num=\"18\"></td><td><pre>     * @param core 参数为 true 的话表示使用线程池的基本大小，为 false 使用线程池最大大小</pre></td></tr><tr><td data-num=\"19\"></td><td><pre>     * @return 添加成功就返回 true 否则返回 false</pre></td></tr><tr><td data-num=\"20\"></td><td><pre>     */</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>   <span class=\"token keyword\">private</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">addWorker</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Runnable</span> firstTask<span class=\"token punctuation\">,</span> <span class=\"token keyword\">boolean</span> core<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>        retry<span class=\"token operator\">:</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>            <span class=\"token comment\">// 这两句用来获取线程池的状态</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>            <span class=\"token keyword\">int</span> c <span class=\"token operator\">=</span> ctl<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>            <span class=\"token keyword\">int</span> rs <span class=\"token operator\">=</span> <span class=\"token function\">runStateOf</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>            <span class=\"token comment\">// Check if queue empty only if necessary.</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>rs <span class=\"token operator\">>=</span> <span class=\"token constant\">SHUTDOWN</span> <span class=\"token operator\">&amp;&amp;</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>                <span class=\"token operator\">!</span> <span class=\"token punctuation\">(</span>rs <span class=\"token operator\">==</span> <span class=\"token constant\">SHUTDOWN</span> <span class=\"token operator\">&amp;&amp;</span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre>                   firstTask <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">&amp;&amp;</span></pre></td></tr><tr><td data-num=\"32\"></td><td><pre>                   <span class=\"token operator\">!</span> workQueue<span class=\"token punctuation\">.</span><span class=\"token function\">isEmpty</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"33\"></td><td><pre>                <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"34\"></td><td><pre></pre></td></tr><tr><td data-num=\"35\"></td><td><pre>            <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"36\"></td><td><pre>               <span class=\"token comment\">// 获取线程池中工作的线程的数量</span></pre></td></tr><tr><td data-num=\"37\"></td><td><pre>                <span class=\"token keyword\">int</span> wc <span class=\"token operator\">=</span> <span class=\"token function\">workerCountOf</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"38\"></td><td><pre>                <span class=\"token comment\">//core 参数为 false 的话表明队列也满了，线程池大小变为 maximumPoolSize</span></pre></td></tr><tr><td data-num=\"39\"></td><td><pre>                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>wc <span class=\"token operator\">>=</span> <span class=\"token constant\">CAPACITY</span> <span class=\"token operator\">||</span></pre></td></tr><tr><td data-num=\"40\"></td><td><pre>                    wc <span class=\"token operator\">>=</span> <span class=\"token punctuation\">(</span>core <span class=\"token operator\">?</span> corePoolSize <span class=\"token operator\">:</span> maximumPoolSize<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"41\"></td><td><pre>                    <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"42\"></td><td><pre>               <span class=\"token comment\">// 原子操作将 workcount 的数量加 1</span></pre></td></tr><tr><td data-num=\"43\"></td><td><pre>                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">compareAndIncrementWorkerCount</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"44\"></td><td><pre>                    <span class=\"token keyword\">break</span> retry<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"45\"></td><td><pre>                <span class=\"token comment\">// 如果线程的状态改变了就再次执行上述操作</span></pre></td></tr><tr><td data-num=\"46\"></td><td><pre>                c <span class=\"token operator\">=</span> ctl<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"47\"></td><td><pre>                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">runStateOf</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> rs<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"48\"></td><td><pre>                    <span class=\"token keyword\">continue</span> retry<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"49\"></td><td><pre>                <span class=\"token comment\">// else CAS failed due to workerCount change; retry inner loop</span></pre></td></tr><tr><td data-num=\"50\"></td><td><pre>            <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"51\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"52\"></td><td><pre>        <span class=\"token comment\">// 标记工作线程是否启动成功</span></pre></td></tr><tr><td data-num=\"53\"></td><td><pre>        <span class=\"token keyword\">boolean</span> workerStarted <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"54\"></td><td><pre>        <span class=\"token comment\">// 标记工作线程是否创建成功</span></pre></td></tr><tr><td data-num=\"55\"></td><td><pre>        <span class=\"token keyword\">boolean</span> workerAdded <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"56\"></td><td><pre>        <span class=\"token class-name\">Worker</span> w <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"57\"></td><td><pre>        <span class=\"token keyword\">try</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"58\"></td><td><pre></pre></td></tr><tr><td data-num=\"59\"></td><td><pre>            w <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Worker</span><span class=\"token punctuation\">(</span>firstTask<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"60\"></td><td><pre>            <span class=\"token keyword\">final</span> <span class=\"token class-name\">Thread</span> t <span class=\"token operator\">=</span> w<span class=\"token punctuation\">.</span>thread<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"61\"></td><td><pre>            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>t <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"62\"></td><td><pre>              <span class=\"token comment\">// 加锁</span></pre></td></tr><tr><td data-num=\"63\"></td><td><pre>                <span class=\"token keyword\">final</span> <span class=\"token class-name\">ReentrantLock</span> mainLock <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>mainLock<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"64\"></td><td><pre>                mainLock<span class=\"token punctuation\">.</span><span class=\"token function\">lock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"65\"></td><td><pre>                <span class=\"token keyword\">try</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"66\"></td><td><pre>                   <span class=\"token comment\">// 获取线程池状态</span></pre></td></tr><tr><td data-num=\"67\"></td><td><pre>                    <span class=\"token keyword\">int</span> rs <span class=\"token operator\">=</span> <span class=\"token function\">runStateOf</span><span class=\"token punctuation\">(</span>ctl<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"68\"></td><td><pre>                   <span class=\"token comment\">//rs &lt; SHUTDOWN 如果线程池状态依然为 RUNNING, 并且线程的状态是存活的话，就会将工作线程添加到工作线程集合中</span></pre></td></tr><tr><td data-num=\"69\"></td><td><pre>                  <span class=\"token comment\">//(rs=SHUTDOWN &amp;&amp; firstTask == null) 如果线程池状态小于 STOP，也就是 RUNNING 或者 SHUTDOWN 状态下，同时传入的任务实例 firstTask 为 null，则需要添加到工作线程集合和启动新的 Worker</span></pre></td></tr><tr><td data-num=\"70\"></td><td><pre>                   <span class=\"token comment\">//firstTask == null 证明只新建线程而不执行任务</span></pre></td></tr><tr><td data-num=\"71\"></td><td><pre>                    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>rs <span class=\"token operator\">&lt;</span> <span class=\"token constant\">SHUTDOWN</span> <span class=\"token operator\">||</span></pre></td></tr><tr><td data-num=\"72\"></td><td><pre>                        <span class=\"token punctuation\">(</span>rs <span class=\"token operator\">==</span> <span class=\"token constant\">SHUTDOWN</span> <span class=\"token operator\">&amp;&amp;</span> firstTask <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"73\"></td><td><pre>                        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">.</span><span class=\"token function\">isAlive</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// precheck that t is startable</span></pre></td></tr><tr><td data-num=\"74\"></td><td><pre>                            <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">IllegalThreadStateException</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"75\"></td><td><pre>                        workers<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>w<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"76\"></td><td><pre>                       <span class=\"token comment\">// 更新当前工作线程的最大容量</span></pre></td></tr><tr><td data-num=\"77\"></td><td><pre>                        <span class=\"token keyword\">int</span> s <span class=\"token operator\">=</span> workers<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"78\"></td><td><pre>                        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>s <span class=\"token operator\">></span> largestPoolSize<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"79\"></td><td><pre>                            largestPoolSize <span class=\"token operator\">=</span> s<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"80\"></td><td><pre>                      <span class=\"token comment\">// 工作线程是否启动成功</span></pre></td></tr><tr><td data-num=\"81\"></td><td><pre>                        workerAdded <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"82\"></td><td><pre>                    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"83\"></td><td><pre>                <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">finally</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"84\"></td><td><pre>                    <span class=\"token comment\">// 释放锁</span></pre></td></tr><tr><td data-num=\"85\"></td><td><pre>                    mainLock<span class=\"token punctuation\">.</span><span class=\"token function\">unlock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"86\"></td><td><pre>                <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"87\"></td><td><pre>                <span class=\"token comment\">//// 如果成功添加工作线程，则调用 Worker 内部的线程实例 t 的 Thread#start () 方法启动真实的线程实例</span></pre></td></tr><tr><td data-num=\"88\"></td><td><pre>                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>workerAdded<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"89\"></td><td><pre>                    t<span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"90\"></td><td><pre>                  <span class=\"token comment\">/// 标记线程启动成功</span></pre></td></tr><tr><td data-num=\"91\"></td><td><pre>                    workerStarted <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"92\"></td><td><pre>                <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"93\"></td><td><pre>            <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"94\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">finally</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"95\"></td><td><pre>           <span class=\"token comment\">// 线程启动失败，需要从工作线程中移除对应的 Worker</span></pre></td></tr><tr><td data-num=\"96\"></td><td><pre>            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span> workerStarted<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"97\"></td><td><pre>                <span class=\"token function\">addWorkerFailed</span><span class=\"token punctuation\">(</span>w<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"98\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"99\"></td><td><pre>        <span class=\"token keyword\">return</span> workerStarted<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"100\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>现在，对于上述示例代码，分析如下：我们模拟了 10 个任务，配置的核心线程数为 5、等待队列容量为 100 ，所以每次只可能存在 5 个任务同时执行，剩下的 5 个任务会被放到等待队列中去。当前的 5 个任务中如果有任务被执行完了，线程池就会去拿新的任务执行。</p>\n<h3 id=\"几个常见的对比\"><a class=\"anchor\" href=\"#几个常见的对比\">#</a> 几个常见的对比</h3>\n<h4 id=\"runnable-vs-callable\"><a class=\"anchor\" href=\"#runnable-vs-callable\">#</a> Runnable vs Callable</h4>\n<p><code>Runnable</code>  接口自 Java 1.0 以来一直存在，但  <code>Callable</code>  接口仅在 Java 1.5 中引入，目的是为了处理  <code>Runnable</code>  接口不支持的用例。</p>\n<p><strong> <code>Runnable</code>  接口无返回值，且不会向上抛出异常，但是  <code>Callable</code>  接口可以</strong>。</p>\n<blockquote>\n<p>所以，如果任务不需要返回结果或抛出异常，则推荐使用  <code>Runnable</code>  接口，这样代码看起来会更加简洁。</p>\n</blockquote>\n<p>工具类  <code>Executors</code>  可以实现将  <code>Runnable</code>  对象转换成  <code>Callable</code>  对象。</p>\n<ul>\n<li><code>Executors.callable(Runnable task)</code></li>\n<li><code>Executors.callable(Runnable task, Object result)</code> ）</li>\n</ul>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token annotation punctuation\">@FunctionalInterface</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">interface</span> <span class=\"token class-name\">Runnable</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>   <span class=\"token comment\">/**</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    * 被线程执行，没有返回值，也无法抛出异常</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    */</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">abstract</span> <span class=\"token keyword\">void</span> <span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token annotation punctuation\">@FunctionalInterface</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">interface</span> <span class=\"token class-name\">Callable</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">V</span><span class=\"token punctuation\">></span></span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token comment\">/**</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>     * 计算结果，或在无法这样做时抛出异常。</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>     * @return 计算得出的结果</pre></td></tr><tr><td data-num=\"6\"></td><td><pre>     * @throws 如果无法计算结果，则抛出异常</pre></td></tr><tr><td data-num=\"7\"></td><td><pre>     */</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token class-name\">V</span> <span class=\"token function\">call</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">Exception</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h4 id=\"execute-vs-submit\"><a class=\"anchor\" href=\"#execute-vs-submit\">#</a> execute() vs submit()</h4>\n<table>\n<thead>\n<tr>\n<th></th>\n<th style=\"text-align:center\"><code>execute()</code></th>\n<th style=\"text-align:center\"><code>submit()</code></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>声明位置</td>\n<td style=\"text-align:center\"><code>Executor</code>  接口</td>\n<td style=\"text-align:center\"><code>ExecutorService</code>  接口</td>\n</tr>\n<tr>\n<td>接收参数</td>\n<td style=\"text-align:center\"><code>Runnable</code></td>\n<td style=\"text-align:center\"><code>Runnable</code>  或  <code>Callable&lt;T&gt;</code></td>\n</tr>\n<tr>\n<td>返回值类型</td>\n<td style=\"text-align:center\"><strong>void</strong></td>\n<td style=\"text-align:center\"><strong> <code>Future</code> </strong></td>\n</tr>\n<tr>\n<td>能否处理异常</td>\n<td style=\"text-align:center\"><strong>无法处理异常</strong></td>\n<td style=\"text-align:center\">借助  <code>Future.get()</code>  可以捕获并处理异常</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>\n<p><code>execute()</code>  方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功</p>\n</li>\n<li>\n<p><code>submit()</code>  方法用于提交需要返回值的任务。线程池会返回一个  <code>Future</code>  类型的对象，通过这个  <code>Future</code>  对象可以判断任务是否执行成功。</p>\n<ul>\n<li>可以通过  <code>Future</code>  的  <code>get()</code>  方法来获取返回值，该方法会阻塞当前线程直到任务完成。</li>\n<li>而使用  <code>Future</code>  的  <code>get（long timeout，TimeUnit unit）</code> 方法的话，如果在  <code>timeout</code>  时间内任务还没有执行完，就会抛出  <code>java.util.concurrent.TimeoutException</code> 。</li>\n</ul>\n</li>\n</ul>\n<p>示例 1：使用  <code>get()</code>  方法获取返回值。</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token class-name\">ExecutorService</span> executorService <span class=\"token operator\">=</span> <span class=\"token class-name\">Executors</span><span class=\"token punctuation\">.</span><span class=\"token function\">newFixedThreadPool</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token class-name\">Future</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">></span></span> submit <span class=\"token operator\">=</span> executorService<span class=\"token punctuation\">.</span><span class=\"token function\">submit</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token keyword\">try</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>        <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">5000L</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">InterruptedException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>        e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token keyword\">return</span> <span class=\"token string\">\"abc\"</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token class-name\">String</span> s <span class=\"token operator\">=</span> submit<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>executorService<span class=\"token punctuation\">.</span><span class=\"token function\">shutdown</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>输出：</p>\n<figure class=\"highlight plain\"><figcaption data-lang=\"plain\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>abc</pre></td></tr></table></figure><p>示例 2：使用  <code>get（long timeout，TimeUnit unit）</code> 方法获取返回值。</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token class-name\">ExecutorService</span> executorService <span class=\"token operator\">=</span> <span class=\"token class-name\">Executors</span><span class=\"token punctuation\">.</span><span class=\"token function\">newFixedThreadPool</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token class-name\">Future</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">></span></span> submit <span class=\"token operator\">=</span> executorService<span class=\"token punctuation\">.</span><span class=\"token function\">submit</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token keyword\">try</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>        <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">5000L</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">InterruptedException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>        e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token keyword\">return</span> <span class=\"token string\">\"abc\"</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token class-name\">String</span> s <span class=\"token operator\">=</span> submit<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">TimeUnit</span><span class=\"token punctuation\">.</span><span class=\"token constant\">SECONDS</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>executorService<span class=\"token punctuation\">.</span><span class=\"token function\">shutdown</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>输出：</p>\n<figure class=\"highlight plain\"><figcaption data-lang=\"plain\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>Exception in thread \"main\" java.util.concurrent.TimeoutException</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>\tat java.util.concurrent.FutureTask.get(FutureTask.java:205)</pre></td></tr></table></figure><h4 id=\"shutdown-vs-shutdownnow\"><a class=\"anchor\" href=\"#shutdown-vs-shutdownnow\">#</a> shutdown() vs shutdownNow()</h4>\n<ul>\n<li>\n<p><strong> <code>shutdown()</code> </strong>：</p>\n<ul>\n<li>关闭线程池，线程池的状态变为  <code>SHUTDOWN</code></li>\n<li><strong>线程池不再接受新任务了，但是队列里的任务得执行完毕</strong></li>\n</ul>\n</li>\n<li>\n<p><strong> <code>shutdownNow()</code> </strong>：</p>\n<ul>\n<li>关闭线程池，线程池的状态变为  <code>STOP</code></li>\n<li><strong>线程池会终止当前正在运行的任务，并停止处理排队的任务，并返回正在等待执行的 List</strong></li>\n</ul>\n</li>\n</ul>\n<h4 id=\"isshutdown-vs-isterminated\"><a class=\"anchor\" href=\"#isshutdown-vs-isterminated\">#</a> isShutdown() vs isTerminated()</h4>\n<ul>\n<li>\n<p><strong> <code>isShutDown()</code> </strong>：当调用  <code>shutdown()</code>  方法后，返回为 true</p>\n</li>\n<li>\n<p><strong> <code>isTerminated()</code> </strong>：当调用  <code>shutdown()</code>  方法后，<strong>并且所有提交的任务完成后</strong>，返回为 true</p>\n</li>\n</ul>\n<h3 id=\"几种常见的内置线程池\"><a class=\"anchor\" href=\"#几种常见的内置线程池\">#</a> 几种常见的内置线程池</h3>\n<blockquote>\n<p>即上文提到的  <code>Executor</code>  框架的  <code>Executors</code>  工具类中所提供的线程池</p>\n</blockquote>\n<h4 id=\"fixedthreadpool\"><a class=\"anchor\" href=\"#fixedthreadpool\">#</a> FixedThreadPool</h4>\n<h5 id=\"介绍\"><a class=\"anchor\" href=\"#介绍\">#</a> 介绍</h5>\n<p><code>FixedThreadPool</code>  被称为可重用<strong>固定线程数</strong>的线程池。通过  <code>Executors</code>  类中的相关源代码来看一下相关实现：</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">/**</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>     * 创建一个可重用固定数量线程的线程池</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>     */</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token class-name\">ExecutorService</span> <span class=\"token function\">newFixedThreadPool</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> nThreads<span class=\"token punctuation\">,</span> <span class=\"token class-name\">ThreadFactory</span> threadFactory<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>        <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ThreadPoolExecutor</span><span class=\"token punctuation\">(</span>nThreads<span class=\"token punctuation\">,</span> nThreads<span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>                                      <span class=\"token number\">0L</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">TimeUnit</span><span class=\"token punctuation\">.</span><span class=\"token constant\">MILLISECONDS</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>                                      <span class=\"token keyword\">new</span> <span class=\"token class-name\">LinkedBlockingQueue</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Runnable</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>                                      threadFactory<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>可以看出 <font color='red'> <code>corePoolSize</code>  和  <code>maximumPoolSize</code>  都被设置为  <code>nThreads</code> </font>，这个  <code>nThreads</code>  参数是我们使用的时候自己传递的。</p>\n<p>即使  <code>maximumPoolSize</code>  的值比  <code>corePoolSize</code>  大，也至多只会创建  <code>corePoolSize</code>  个线程。这是因为 <code>FixedThreadPool</code>  <font color='red'>使用的是容量为  <code>Integer.MAX_VALUE</code>  的  <code>LinkedBlockingQueue</code> （<strong>无界队列</strong>），任务队列永远不会被放满</font>。</p>\n<h5 id=\"处理任务的流程\"><a class=\"anchor\" href=\"#处理任务的流程\">#</a> 处理任务的流程</h5>\n<p><code>FixedThreadPool</code>  的  <code>execute()</code>  方法运行示意图：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/FixedThreadPool-f8172448.png\" alt=\"FixedThreadPool的execute()方法运行示意图\" /></p>\n<ol>\n<li>\n<p>如果当前运行的线程数小于  <code>corePoolSize</code> ， 如果再来新任务的话，就创建新的线程来执行任务；</p>\n</li>\n<li>\n<p>当前运行的线程数等于  <code>corePoolSize</code>  后， 如果再来新任务的话，会将任务加入  <code>LinkedBlockingQueue</code> ；</p>\n</li>\n<li>\n<p>线程池中的线程执行完手头的任务后，会在循环中反复从  <code>LinkedBlockingQueue</code>  中获取任务来执行；</p>\n</li>\n</ol>\n<h5 id=\"为什么不推荐使用\"><a class=\"anchor\" href=\"#为什么不推荐使用\">#</a> 为什么不推荐使用？</h5>\n<p><code>FixedThreadPool</code>  使用无界队列  <code>LinkedBlockingQueue</code> （队列的容量为  <code>Integer.MAX_VALUE</code> ）作为线程池的工作队列会对线程池带来如下影响：</p>\n<ol>\n<li>当线程池中的线程数达到  <code>corePoolSize</code>  后，新任务将在无界队列中等待，因此线程池中的线程数不会超过  <code>corePoolSize</code> ；</li>\n<li>由于使用无界队列时  <code>maximumPoolSize</code>  将是一个无效参数，因为不可能存在任务队列满的情况。所以，通过创建  <code>FixedThreadPool</code>  的源码可以看出创建的  <code>FixedThreadPool</code>  的  <code>corePoolSize</code>  和  <code>maximumPoolSize</code>  被设置为同一个值。</li>\n<li>由于 1 和 2，使用无界队列时  <code>keepAliveTime</code>  将是一个无效参数；</li>\n<li>运行中的  <code>FixedThreadPool</code> （未执行  <code>shutdown()</code>  或  <code>shutdownNow()</code> ）不会拒绝任务，<strong>在任务比较多的时候会导致 OOM（内存溢出）</strong>。</li>\n</ol>\n<h4 id=\"singlethreadexecutor\"><a class=\"anchor\" href=\"#singlethreadexecutor\">#</a> SingleThreadExecutor</h4>\n<h5 id=\"介绍-2\"><a class=\"anchor\" href=\"#介绍-2\">#</a> 介绍</h5>\n<p><code>SingleThreadExecutor</code>  是<strong>只有一个线程</strong>的线程池。下面看看 SingleThreadExecutor 的实现：</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">/**</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>     * 返回只有一个线程的线程池</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>     */</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token class-name\">ExecutorService</span> <span class=\"token function\">newSingleThreadExecutor</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">ThreadFactory</span> threadFactory<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>        <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">FinalizableDelegatedExecutorService</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>            <span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">ThreadPoolExecutor</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>                                    <span class=\"token number\">0L</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">TimeUnit</span><span class=\"token punctuation\">.</span><span class=\"token constant\">MILLISECONDS</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>                                    <span class=\"token keyword\">new</span> <span class=\"token class-name\">LinkedBlockingQueue</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Runnable</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>                                    threadFactory<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>可以看出<font color='red'>  <code>corePoolSize</code>  和  <code>maximumPoolSize</code>  都被设置为 1</font>，其他参数和  <code>FixedThreadPool</code>  相同。</p>\n<h5 id=\"处理任务的流程-2\"><a class=\"anchor\" href=\"#处理任务的流程-2\">#</a> 处理任务的流程</h5>\n<p><code>SingleThreadExecutor</code>  的运行示意图：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/SingleThreadExecutor-7ffd92c2.png\" alt=\"SingleThreadExecutor的运行示意图\" /></p>\n<ol>\n<li>如果当前运行的线程数少于  <code>corePoolSize</code> ，则创建一个新的线程执行任务；</li>\n<li>当前线程池中有一个运行的线程后，将任务加入  <code>LinkedBlockingQueue</code></li>\n<li>线程执行完当前的任务后，会在循环中反复从  <code>LinkedBlockingQueue</code>  中获取任务来执行；</li>\n</ol>\n<h5 id=\"为什么不推荐使用-2\"><a class=\"anchor\" href=\"#为什么不推荐使用-2\">#</a> 为什么不推荐使用？</h5>\n<p><code>SingleThreadExecutor</code>  和  <code>FixedThreadPool</code>  一样，<strong>使用的都是容量为  <code>Integer.MAX_VALUE</code>  的  <code>LinkedBlockingQueue</code> （无界队列）<strong>作为线程池的工作队列。说简单点，就是</strong>可能会导致 OOM</strong>。</p>\n<h4 id=\"cachedthreadpool\"><a class=\"anchor\" href=\"#cachedthreadpool\">#</a> CachedThreadPool</h4>\n<h5 id=\"介绍-3\"><a class=\"anchor\" href=\"#介绍-3\">#</a> 介绍</h5>\n<p><code>CachedThreadPool</code>  是一个会<strong>根据需要创建新线程</strong>的线程池。下面通过源码来看看实现：</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">/**</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>     * 创建一个线程池，根据需要创建新线程，但会在先前构建的线程可用时重用它。</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>     */</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token class-name\">ExecutorService</span> <span class=\"token function\">newCachedThreadPool</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">ThreadFactory</span> threadFactory<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>        <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ThreadPoolExecutor</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">Integer</span><span class=\"token punctuation\">.</span><span class=\"token constant\">MAX_VALUE</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>                                      <span class=\"token number\">60L</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">TimeUnit</span><span class=\"token punctuation\">.</span><span class=\"token constant\">SECONDS</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>                                      <span class=\"token keyword\">new</span> <span class=\"token class-name\">SynchronousQueue</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Runnable</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>                                      threadFactory<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p><font color='red'> <code>corePoolSize</code>  被设置为空（0）， <code>maximumPoolSize</code>  被设置为  <code>Integer.MAX.VALUE</code> ，即它是无界的</font>。这也就意味着如果主线程提交任务的速度高于  <code>maximumPool</code>  中线程处理任务的速度时， <code>CachedThreadPool</code>  会不断创建新的线程。极端情况下，这样<strong>会导致耗尽 cpu 和内存资源</strong>。</p>\n<h5 id=\"处理任务的流程-3\"><a class=\"anchor\" href=\"#处理任务的流程-3\">#</a> 处理任务的流程</h5>\n<p><code>CachedThreadPool</code>  的  <code>execute()</code>  方法的执行示意图：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231021003533603.png\" alt=\"image-20231021003533603\" /></p>\n<ol>\n<li>首先执行  <code>SynchronousQueue.offer(Runnable task)</code>  提交任务到任务队列。如果当前  <code>maximumPool</code>  中有闲线程正在执行  <code>SynchronousQueue.poll(keepAliveTime,TimeUnit.NANOSECONDS)</code> ，那么主线程执行 offer 操作与空闲线程执行的  <code>poll</code>  操作配对成功，主线程把任务交给空闲线程执行， <code>execute()</code>  方法执行完成，否则执行下面的步骤 2；</li>\n<li>当初始  <code>maximumPool</code>  为空，或者  <code>maximumPool</code>  中没有空闲线程时，将没有线程执行  <code>SynchronousQueue.poll(keepAliveTime,TimeUnit.NANOSECONDS)</code> 。这种情况下，步骤 1 将失败，此时  <code>CachedThreadPool</code>  会创建新线程执行任务，execute 方法执行完成；</li>\n</ol>\n<h5 id=\"为什么不推荐使用-3\"><a class=\"anchor\" href=\"#为什么不推荐使用-3\">#</a> 为什么不推荐使用？</h5>\n<p><code>CachedThreadPool</code>  使用的是同步队列  <code>SynchronousQueue</code> ，<strong>允许创建的线程数量为  <code>Integer.MAX_VALUE</code>  ，可能会创建大量线程，从而导致 OOM</strong>。</p>\n<h4 id=\"scheduledthreadpool\"><a class=\"anchor\" href=\"#scheduledthreadpool\">#</a> ScheduledThreadPool</h4>\n<h5 id=\"介绍-4\"><a class=\"anchor\" href=\"#介绍-4\">#</a> 介绍</h5>\n<p><code>ScheduledThreadPool</code>  用来<strong>在给定的延迟后运行任务或者定期执行任务</strong>。这个在实际项目中基本不会被用到，也<font color='red'>不推荐使用</font>，大家只需要简单了解一下即可。</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token class-name\">ScheduledExecutorService</span> <span class=\"token function\">newScheduledThreadPool</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> corePoolSize<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ScheduledThreadPoolExecutor</span><span class=\"token punctuation\">(</span>corePoolSize<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token class-name\">ScheduledThreadPoolExecutor</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> corePoolSize<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>corePoolSize<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Integer</span><span class=\"token punctuation\">.</span><span class=\"token constant\">MAX_VALUE</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">NANOSECONDS</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>          <span class=\"token keyword\">new</span> <span class=\"token class-name\">DelayedWorkQueue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p><code>ScheduledThreadPool</code>  是通过  <code>ScheduledThreadPoolExecutor</code>  创建的，** 使用的  <code>DelayedWorkQueue</code> （延迟阻塞队列）** 作为线程池的任务队列。</p>\n<p><code>DelayedWorkQueue</code>  的内部元素并不是按照放入时间排序的，而是<font color='red'>按照延迟时间长短对任务进行排序的</font>，内部采用的是 “堆” 的数据结构，可以保证<font color='red'>每次出队的任务都是当前队列中执行时间最靠前的</font>。 <code>DelayedWorkQueue</code>  添加元素<font color='red'>满了之后会自动扩容原来容量的 1/2</font>，即永远不会阻塞，最大扩容可达  <code>Integer.MAX_VALUE</code> ，所以最多只能创建核心线程数的线程。</p>\n<p><code>ScheduledThreadPoolExecutor</code>  继承了  <code>ThreadPoolExecutor</code> ，所以创建  <code>ScheduledThreadExecutor</code>  本质也是创建一个  <code>ThreadPoolExecutor</code>  线程池，只是传入的参数不相同。</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">ScheduledThreadPoolExecutor</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>        <span class=\"token keyword\">extends</span> <span class=\"token class-name\">ThreadPoolExecutor</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>        <span class=\"token keyword\">implements</span> <span class=\"token class-name\">ScheduledExecutorService</span></pre></td></tr></table></figure><h5 id=\"scheduledthreadpoolexecutor-和-timer-对比\"><a class=\"anchor\" href=\"#scheduledthreadpoolexecutor-和-timer-对比\">#</a> ScheduledThreadPoolExecutor 和 Timer 对比</h5>\n<ul>\n<li>\n<p><code>Timer</code>  对系统时钟的变化敏感， <code>ScheduledThreadPoolExecutor</code>  不是；</p>\n</li>\n<li>\n<p><code>Timer</code>  只有一个执行线程，因此长时间运行的任务可以延迟其他任务。  <code>ScheduledThreadPoolExecutor</code>  可以配置任意数量的线程。 此外，如果你想（通过提供  <code>ThreadFactory</code> ），你可以完全控制创建的线程；</p>\n</li>\n<li>\n<p>在 <code>TimerTask</code>  中抛出的运行时异常会杀死一个线程，从而导致  <code>Timer</code>  死机即计划任务将不再运行。 <code>ScheduledThreadExecutor</code>  不仅捕获运行时异常，还允许您在需要时处理它们（通过重写  <code>afterExecute</code>  方法 <code>ThreadPoolExecutor</code> ）。抛出异常的任务将被取消，但其他任务将继续运行。</p>\n</li>\n</ul>\n<h3 id=\"如何设计一个能根据任务优先级来执行的线程池\"><a class=\"anchor\" href=\"#如何设计一个能根据任务优先级来执行的线程池\">#</a> 如何设计一个能根据任务优先级来执行的线程池？</h3>\n<p>这是一个常见的面试问题，本质其实还是在考察求职者对于<font color='red'>线程池</font>以及<font color='red'>阻塞队列（任务队列）</font>的掌握。上面也提到了，<strong><font color='red'>不同的线程池会选用不同的阻塞队列作为任务队列</font></strong>。比如  <code>FixedThreadPool</code>  使用的是  <code>LinkedBlockingQueue</code> （无界队列），由于该队列永远不会被放满，因此  <code>FixedThreadPool</code>  最多只能创建  <code>corePoolSize</code>  个线程。</p>\n<p>假如我们需要实现一个优先级任务线程池的话，那可以<strong>考虑使用  <code>PriorityBlockingQueue</code>  （优先级阻塞队列）作为任务队列</strong>（ <code>ThreadPoolExecutor</code>  的构造函数有一个 <code>workQueue</code>  参数可以传入任务队列）。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/common-parameters-of-threadpool-workqueue.jpg\" alt=\"ThreadPoolExecutor构造函数\" /></p>\n<p><strong>优先级阻塞队列  <code>PriorityBlockingQueue</code> </strong>：<font color='red'>一个支持优先级的无界阻塞队列</font>，可以看作是<font color='red'>线程安全</font>的  <code>PriorityQueue</code> ，两者底层都是使用<font color='red'>小顶堆形式的二叉堆</font>，即值最小的元素优先出队。不过， <code>PriorityQueue</code>  不<font color='red'>支持阻塞操作</font>。</p>\n<p>要想让  <code>PriorityBlockingQueue</code>  实现对任务的排序，<strong><font color='red'>传入的任务必须是具备排序能力的</font></strong>，方式有两种：</p>\n<ol>\n<li>让任务实现  <code>Comparable</code>  接口，并重写  <code>compareTo</code>  方法来指定任务之间的优先级比较规则。</li>\n<li>(推荐！)<strong> 创建  <code>PriorityBlockingQueue</code>  时传入一个  <code>Comparator</code>  对象来指定任务之间的排序规则</strong>。</li>\n</ol>\n<p>不过，<strong><font color='red'>这存在一些风险和问题</font></strong>，比如：</p>\n<ul>\n<li>\n<p><code>PriorityBlockingQueue</code>  是无界的，可能堆积大量的请求，从而导致 <font color='red'>OOM</font> 。</p>\n<blockquote>\n<p>解决方法：继承  <code>PriorityBlockingQueue</code>  并<strong>重写一下  <code>offer</code>  (入队) 方法</strong>的逻辑，当插入的元素数量超过指定值就返回 false</p>\n</blockquote>\n</li>\n<li>\n<p>可能会导致<font color='red'>饥饿问题</font>，即低优先级的任务长时间得不到执行。</p>\n<blockquote>\n<p>解决方法：可以通过优化设计来解决（比较麻烦），比如<strong>等待时间过长的任务会被移除并重新添加到队列中，但是优先级会被提升</strong></p>\n</blockquote>\n</li>\n<li>\n<p>由于需要对队列中的元素进行排序操作以及保证线程安全（并发控制采用的是可重入锁  <code>ReentrantLock</code>  ），因此会<font color='red'>降低性能</font>。</p>\n<blockquote>\n<p>解决方法：性能方面的影响是<strong>没法避免</strong>的，毕竟需要对任务进行排序操作。并且，对于大部分业务场景来说，这点性能影响是可以接受的</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"面试题线程池有了解吗线程池大概的原理\"><a class=\"anchor\" href=\"#面试题线程池有了解吗线程池大概的原理\">#</a> 【面试题】线程池有了解吗？线程池大概的原理？</h3>\n<blockquote>\n<p>互联网、米哈游、后端、Java。考察的是<strong>线程池的常见参数、处理任务的流程</strong>。</p>\n</blockquote>\n<p>线程池的核心参数如下：</p>\n<ul>\n<li><strong><font color='gree'>corePoolSize</font></strong>：核心线程数</li>\n<li><strong><font color='gree'>maximumPoolSize</font></strong>：最大线程数</li>\n<li><strong><font color='gree'>workQueue</font></strong>：任务的阻塞队列</li>\n<li><font color='gree'>keepAliveTime</font>：当线程池中的线程数量超过 corePoolSize 时，多余的空闲线程在超过 keepAliveTime 时间后会被终止。</li>\n<li><font color='gree'>threadFactory</font>：线程工厂，用于创建新的线程。</li>\n<li><font color='gree'>handler</font>：拒绝策略（饱和策略），当线程池无法接收新的任务时，采取的处理方式。</li>\n</ul>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231018163149255.png\" alt=\"image-20231018163149255\" /></p>\n<p>线程池处理一个新任务的执行流程：</p>\n<ol>\n<li>\n<p>如果 当前运行的线程数 ＜  <code>corePoolSize</code>  ，那么就会<font color='red'>新建一个线程</font>来执行任务。</p>\n</li>\n<li>\n<p>如果  <code>corePoolSize</code>  ≤ 当前运行的线程数 ＜  <code>maximumPoolSize</code> ，那么就<font color='red'>把该任务放入到任务队列里等待执行</font>。</p>\n<blockquote>\n<p>随着不断添加任务，<font color='red'>如果任务队列满了，就新建一个线程</font>来执行任务。</p>\n</blockquote>\n</li>\n<li>\n<p>如果 当前运行的线程数 ==  <code>maximumPoolSize</code> ，此时任务队列、线程池都满了，那么根据<font color='red'>拒绝策略（饱和策略）</font>来处理无法接收的任务，比如抛出异常或者丢弃任务。</p>\n</li>\n</ol>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/thread-pool-principle.png\" alt=\"图解线程池实现原理\" /></p>\n<ol start=\"4\">\n<li>当线程执行完任务后，会从任务队列中获取下一个任务继续执行，直到任务队列为空。</li>\n<li>当空闲线程的时间超过  <code>keepAliveTime</code>  时，如果线程池中的线程数量超过  <code>corePoolSize</code> ，则多余的空闲线程会被终止，直到线程数量等于  <code>corePoolSize</code>  为止。</li>\n</ol>\n<h3 id=\"面试题设计一个线程池需要考虑哪些因素\"><a class=\"anchor\" href=\"#面试题设计一个线程池需要考虑哪些因素\">#</a> 【面试题】设计一个线程池需要考虑哪些因素？</h3>\n<blockquote>\n<p>互联网、米哈游、后端情景题、系统设计。考察的是<strong>线程池的特征</strong>，比较综合全面</p>\n</blockquote>\n<p>设计一个线程池需要考虑以下几个方面：</p>\n<ol>\n<li><font color='gree'>线程池的大小</font>：线程池的大小应该根据系统的负载情况和任务的性质来确定。\n<ul>\n<li>如果线程池太小，会导致任务排队等待，影响系统的性能</li>\n<li>如果线程池太大，会造成过多的上下文切换。</li>\n</ul>\n</li>\n<li><font color='gree'>任务队列</font>：线程池中的等待任务需要有一个队列来存储。任务队列可以是阻塞队列或非阻塞队列，根据具体的需求来选择。</li>\n<li><font color='gree'>线程工厂</font>：用于创建新的线程。</li>\n<li><font color='gree'>拒绝策略</font>：当线程池中的线程都处于忙碌状态时，新提交的任务会被放入任务队列中等待执行。此时需要设置一个拒绝策略，<font color='red'>防止任务一直被放入队列中而无法执行</font>。常见的拒绝策略有<font color='red'>直接抛出异常、丢弃任务</font>等。</li>\n<li><font color='gree'>饱和策略</font>：当线程池中的线程数量达到最大值时，新提交的任务可能会被拒绝执行。此时需要设置一个饱和策略，<font color='red'>防止线程池过度扩展</font>。常见的饱和策略有<font color='red'>直接抛出异常、丢弃任务</font>等。</li>\n<li><font color='gree'>线程池监控</font>：为了方便对线程池进行监控和管理，可以添加一些监控功能，如<font color='red'>获取当前线程池的状态、获取当前正在执行的任务</font>等。</li>\n</ol>\n<p>基于以上方面，可以设计一个简单的线程池示例代码如下：</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">java<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span>concurrent<span class=\"token punctuation\">.</span></span><span class=\"token operator\">*</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">ThreadPoolExample</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">InterruptedException</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>        <span class=\"token comment\">// 创建一个固定大小的线程池</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>        <span class=\"token class-name\">ExecutorService</span> executorService <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ThreadPoolExecutor</span><span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">,</span> <span class=\"token number\">10</span><span class=\"token punctuation\">,</span> <span class=\"token number\">60L</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">TimeUnit</span><span class=\"token punctuation\">.</span><span class=\"token constant\">SECONDS</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">LinkedBlockingQueue</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Runnable</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token number\">100</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>        <span class=\"token comment\">// 提交任务到线程池中执行</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">20</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>            <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> taskId <span class=\"token operator\">=</span> i<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>            executorService<span class=\"token punctuation\">.</span><span class=\"token function\">execute</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>                <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Task \"</span> <span class=\"token operator\">+</span> taskId <span class=\"token operator\">+</span> <span class=\"token string\">\" is running by thread \"</span> <span class=\"token operator\">+</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>            <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>        <span class=\"token comment\">// 关闭线程池</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>        executorService<span class=\"token punctuation\">.</span><span class=\"token function\">shutdown</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h3 id=\"java线程池最佳实践\"><a class=\"anchor\" href=\"#java线程池最佳实践\">#</a> Java 线程池最佳实践</h3>\n<h4 id=\"1-正确声明线程池\"><a class=\"anchor\" href=\"#1-正确声明线程池\">#</a> 1、正确声明线程池</h4>\n<p>** 线程池必须手动通过  <code>ThreadPoolExecutor</code>  的构造函数来声明，避免使用 <code>Executors</code>  类创建线程池，会有 OOM 风险。** 说白了就是：<strong>使用有界队列，控制线程创建数量。</strong></p>\n<p>除了避免 OOM 的原因之外，不推荐使用  <code>Executors</code>  提供的两种快捷的线程池的原因还有：</p>\n<ul>\n<li>实际使用中需要根据自己机器的性能、业务场景来<font color='red'>手动配置线程池的参数</font>比如核心线程数、使用的任务队列、饱和策略等等。</li>\n<li>我们应该显示地给我们的线程池命名，这样有助于我们定位问题。</li>\n</ul>\n<h4 id=\"2-监测线程池运行状态\"><a class=\"anchor\" href=\"#2-监测线程池运行状态\">#</a> 2、监测线程池运行状态</h4>\n<p>你可以通过一些手段来检测线程池的运行状态比如 SpringBoot 中的 <font color='red'>Actuator 组件</font>。</p>\n<p>除此之外，我们还可以利用  <code>ThreadPoolExecutor</code>  的相关 API 做一个简陋的监控。从下图可以看出， <code>ThreadPoolExecutor</code>  提供了获取线程池当前的线程数和活跃线程数、已经执行完成的任务数、正在排队中的任务数等等。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231021094845929.png\" alt=\"image-20231021094845929\" /></p>\n<p>下面是一个简单的 Demo。 <code>printThreadPoolStatus()</code>  会每隔一秒打印出线程池的线程数、活跃线程数、完成的任务数、以及队列中的任务数。</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">/**</pre></td></tr><tr><td data-num=\"2\"></td><td><pre> * 打印线程池的状态</pre></td></tr><tr><td data-num=\"3\"></td><td><pre> *</pre></td></tr><tr><td data-num=\"4\"></td><td><pre> * @param threadPool 线程池对象</pre></td></tr><tr><td data-num=\"5\"></td><td><pre> */</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">printThreadPoolStatus</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">ThreadPoolExecutor</span> threadPool<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token class-name\">ScheduledExecutorService</span> scheduledExecutorService <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ScheduledThreadPoolExecutor</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token function\">createThreadFactory</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"print-images/thread-pool-status\"</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    scheduledExecutorService<span class=\"token punctuation\">.</span><span class=\"token function\">scheduleAtFixedRate</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>        log<span class=\"token punctuation\">.</span><span class=\"token function\">info</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"=========================\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>        log<span class=\"token punctuation\">.</span><span class=\"token function\">info</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"ThreadPool Size: [&#123;&#125;]\"</span><span class=\"token punctuation\">,</span> threadPool<span class=\"token punctuation\">.</span><span class=\"token function\">getPoolSize</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>        log<span class=\"token punctuation\">.</span><span class=\"token function\">info</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Active Threads: &#123;&#125;\"</span><span class=\"token punctuation\">,</span> threadPool<span class=\"token punctuation\">.</span><span class=\"token function\">getActiveCount</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>        log<span class=\"token punctuation\">.</span><span class=\"token function\">info</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Number of Tasks : &#123;&#125;\"</span><span class=\"token punctuation\">,</span> threadPool<span class=\"token punctuation\">.</span><span class=\"token function\">getCompletedTaskCount</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>        log<span class=\"token punctuation\">.</span><span class=\"token function\">info</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Number of Tasks in Queue: &#123;&#125;\"</span><span class=\"token punctuation\">,</span> threadPool<span class=\"token punctuation\">.</span><span class=\"token function\">getQueue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>        log<span class=\"token punctuation\">.</span><span class=\"token function\">info</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"=========================\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">TimeUnit</span><span class=\"token punctuation\">.</span><span class=\"token constant\">SECONDS</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h4 id=\"3-建议不同类别的业务用不同的线程池\"><a class=\"anchor\" href=\"#3-建议不同类别的业务用不同的线程池\">#</a> 3、建议不同类别的业务用不同的线程池</h4>\n<p>很多人在实际项目中都会有类似这样的问题：我的项目中多个业务需要用到线程池，是为每个线程池都定义一个还是说定义一个公共的线程池呢？</p>\n<p>一般建议是<strong>不同的业务使用不同的线程池</strong>，配置线程池的时候根据当前业务的情况对当前线程池进行配置，因为不同的业务的并发以及对资源的使用情况都不同，重心优化系统性能瓶颈相关的业务。</p>\n<p>我们再来看一个真实的事故案例！ (本案例来源自：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jbHViLnBlcmZtYS5jb20vYXJ0aWNsZS82NDY2Mzk=\">《线程池运用不当的一次线上事故》</span> ，很精彩的一个案例)</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/production-accident-threadpool-sharing-example.png\" alt=\"案例代码概览\" /></p>\n<p>上面的代码可能会存在死锁的情况，为什么呢？画个图给大家捋一捋。</p>\n<p>试想这样一种极端情况：假如我们线程池的核心线程数为 n，父任务（扣费任务）数量为 n，父任务下面有两个子任务（扣费任务下的子任务），其中一个已经执行完成，另外一个被放在了任务队列中。由于父任务把线程池核心线程资源用完，所以子任务因为无法获取到线程资源无法正常执行，一直被阻塞在队列中。父任务等待子任务执行完成，而子任务等待父任务释放线程池资源，这也就造成了 <strong>&quot;死锁&quot;</strong> 。</p>\n<p>解决方法也很简单，就是<strong>专门为执行子任务新增加一个线程池</strong>为其服务。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/production-accident-threadpool-sharing-deadlock.png\" alt=\"线程池使用不当导致死锁\" /></p>\n<h4 id=\"4-别忘记给线程池命名\"><a class=\"anchor\" href=\"#4-别忘记给线程池命名\">#</a> 4、别忘记给线程池命名</h4>\n<p>初始化线程池的时候需要<font color='red'>显示命名（设置线程池名称前缀）</font>，有利于定位问题。</p>\n<p>默认情况下创建的线程名字类似  <code>pool-1-thread-n</code>  这样的，没有业务含义，不利于我们定位问题。</p>\n<p>给线程池里的线程命名通常有下面两种方式：</p>\n<p><strong>1、利用 guava 的  <code>ThreadFactoryBuilder</code> </strong></p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token class-name\">ThreadFactory</span> threadFactory <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ThreadFactoryBuilder</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>                        <span class=\"token punctuation\">.</span><span class=\"token function\">setNameFormat</span><span class=\"token punctuation\">(</span>threadNamePrefix <span class=\"token operator\">+</span> <span class=\"token string\">\"-%d\"</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>                        <span class=\"token punctuation\">.</span><span class=\"token function\">setDaemon</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">build</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token class-name\">ExecutorService</span> threadPool <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ThreadPoolExecutor</span><span class=\"token punctuation\">(</span>corePoolSize<span class=\"token punctuation\">,</span> maximumPoolSize<span class=\"token punctuation\">,</span> keepAliveTime<span class=\"token punctuation\">,</span> <span class=\"token class-name\">TimeUnit</span><span class=\"token punctuation\">.</span><span class=\"token constant\">MINUTES</span><span class=\"token punctuation\">,</span> workQueue<span class=\"token punctuation\">,</span> threadFactory<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p><strong>2、自己实现  <code>ThreadFactory</code> </strong></p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">java<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span>concurrent<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">Executors</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">java<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span>concurrent<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">ThreadFactory</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">java<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span>concurrent<span class=\"token punctuation\">.</span>atomic<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">AtomicInteger</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token comment\">/**</pre></td></tr><tr><td data-num=\"5\"></td><td><pre> * 线程工厂，它设置线程名称，有利于我们定位问题。</pre></td></tr><tr><td data-num=\"6\"></td><td><pre> */</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">NamingThreadFactory</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">ThreadFactory</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">AtomicInteger</span> threadNum <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">AtomicInteger</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">ThreadFactory</span> delegate<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">String</span> name<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    <span class=\"token comment\">/**</pre></td></tr><tr><td data-num=\"14\"></td><td><pre>     * 创建一个带名字的线程池生产工厂</pre></td></tr><tr><td data-num=\"15\"></td><td><pre>     */</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token class-name\">NamingThreadFactory</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">ThreadFactory</span> delegate<span class=\"token punctuation\">,</span> <span class=\"token class-name\">String</span> name<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>delegate <span class=\"token operator\">=</span> delegate<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> name<span class=\"token punctuation\">;</span> <span class=\"token comment\">// TODO consider uniquifying this</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>    <span class=\"token annotation punctuation\">@Override</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token class-name\">Thread</span> <span class=\"token function\">newThread</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Runnable</span> r<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>        <span class=\"token class-name\">Thread</span> t <span class=\"token operator\">=</span> delegate<span class=\"token punctuation\">.</span><span class=\"token function\">newThread</span><span class=\"token punctuation\">(</span>r<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>        t<span class=\"token punctuation\">.</span><span class=\"token function\">setName</span><span class=\"token punctuation\">(</span>name <span class=\"token operator\">+</span> <span class=\"token string\">\" [#\"</span> <span class=\"token operator\">+</span> threadNum<span class=\"token punctuation\">.</span><span class=\"token function\">incrementAndGet</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token string\">\"]\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>        <span class=\"token keyword\">return</span> t<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre></pre></td></tr><tr><td data-num=\"28\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h4 id=\"5-正确配置线程池大小\"><a class=\"anchor\" href=\"#5-正确配置线程池大小\">#</a> 5、正确配置线程池大小</h4>\n<h5 id=\"常规操作\"><a class=\"anchor\" href=\"#常规操作\">#</a> 常规操作</h5>\n<p>线程池大小设置过大或者过小都会有问题，合适的才是最好。</p>\n<ul>\n<li>\n<p>** 线程过少会导致大量任务堆积，造成 OOM **。如果同一时间有大量任务 / 请求需要处理，可能会导致大量的请求 / 任务在任务队列中排队等待执行，甚至会出现任务队列满了之后任务 / 请求无法处理的情况，或者大量任务堆积在任务队列导致 OOM。这样很明显是有问题的，CPU 根本没有得到充分利用。</p>\n</li>\n<li>\n<p><strong>线程过多会增加上下文切换成本</strong>。大量线程可能会同时在争取 CPU 资源，这样会导致大量的上下文切换，从而增加线程的执行时间，影响了整体执行效率。</p>\n<blockquote>\n<p>上下文切换：任务从保存到再加载的过程</p>\n</blockquote>\n</li>\n</ul>\n<p>有一个简单并且适用面较广的公式：</p>\n<ul>\n<li>\n<p><strong>CPU 密集型任务 (N+1)</strong>：这种任务消耗的主要是 CPU 资源，可以将线程数设置为 N（CPU 核心数）+1。比 CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU 就会处于空闲状态，而在这种情况下<font color='red'>多出来的一个线程就可以充分利用 CPU 的空闲时间</font>。</p>\n<blockquote>\n<p>CPU 密集型任务：简单理解就是<font color='red'>利用 CPU 计算能力</font>的任务。比如你在内存中对大量数据进行排序。</p>\n</blockquote>\n</li>\n<li>\n<p><strong>I/O 密集型任务 (2N)</strong>：这种任务应用起来，系统会用大部分的时间来处理 I/O 交互，而线程在处理 I/O 的时间段内不会占用 CPU 来处理，这时就可以将 CPU 交出给其它线程使用。<font color='red'>因此在 I/O 密集型任务的应用中，我们可以多配置一些线程</font>，具体的计算方法是 2N。</p>\n<blockquote>\n<p>IO 密集型任务：但凡<font color='red'>涉及到网络读取，文件读取</font>，这类任务都是 IO 密集型，特点是 CPU 计算耗费时间相比于等待 IO 操作完成的时间来说很少，<font color='red'>大部分时间都花在了等待 IO 操作完成上</font>。</p>\n</blockquote>\n</li>\n</ul>\n<h5 id=\"美团骚操作\"><a class=\"anchor\" href=\"#美团骚操作\">#</a> 美团骚操作</h5>\n<p>美团技术团队的思路是<font color='red'>对<strong>线程池的 3 个核心参数</strong>实现自定义可配置</font>。</p>\n<ul>\n<li><strong> <code>corePoolSize</code> </strong>：核心线程数量。当任务队列未达到容量时，可以同时运行的最大线程数量。</li>\n<li><strong> <code>maximumPoolSize</code> </strong>：最大线程数量。当任务队列达到容量时，可以同时运行的最大线程数量。</li>\n<li><strong> <code>workQueue</code> </strong>：任务队列。当新任务来时，如果当前运行的线程数量达到了  <code>corePoolSize</code>  的话，新任务就会被存放在该队列中。</li>\n</ul>\n<blockquote>\n<p>这 3 个参数之所以如此重要，是因为它们基本决定了线程池对任务的处理策略。</p>\n</blockquote>\n<p><code>ThreadPoolExecutor</code>  提供的下面这些方法支持参数的动态配置。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/threadpoolexecutor-methods.png\" alt=\"img\" /></p>\n<ul>\n<li>\n<p>需要注意的是  <code>corePoolSize</code> ， 程序运行期间的时候，我们调用 <code>setCorePoolSize（）</code> 方法的话，线程池会首先判断当前工作线程数是否大于  <code>corePoolSize</code> ，如果大于的话就会回收工作线程。</p>\n</li>\n<li>\n<p>另外，<font color=\"red\">上面并没有动态指定任务队列长度的方法</font>，因此美团自定义了一个叫做 <strong> <code>ResizableCapacityLinkedBlockIngQueue</code> </strong> 的队列。</p>\n<blockquote>\n<p>主要就是把  <code>LinkedBlockingQueue</code>  的 capacity 字段的 final 关键字修饰给去掉了，让它变为可变的</p>\n</blockquote>\n</li>\n</ul>\n<p>最终实现的可动态修改线程池参数效果如下。👏👏👏</p>\n<img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/meituan-dynamically-configuring-thread-pool-parameters.png\" alt=\"动态配置线程池参数最终效果\" style=\"zoom: 50%;\" />\n<p>如果我们的项目也想要实现这种效果的话，可以借助现成的开源项目：</p>\n<ul>\n<li><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL29wZW5nb29meS9oaXBwbzRq\">Hippo4j</span></strong>：异步线程池框架，支持线程池动态变更 &amp; 监控 &amp; 报警，无需修改代码轻松引入。支持多种使用模式，轻松引入，致力于提高系统运行保障能力。</li>\n<li><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2Ryb21hcmEvZHluYW1pYy10cA==\">Dynamic TP</span></strong>：轻量级动态线程池，内置监控告警功能，集成三方中间件线程池管理，基于主流配置中心（已支持 Nacos、Apollo，Zookeeper、Consul、Etcd，可通过 SPI 自定义实现）。</li>\n</ul>\n<h4 id=\"6-记得关闭线程池\"><a class=\"anchor\" href=\"#6-记得关闭线程池\">#</a> 6、记得关闭线程池</h4>\n<p>当线程池不再需要使用时，应该显式地关闭线程池，释放线程资源。</p>\n<p>线程池提供了两个关闭方法：</p>\n<ul>\n<li><strong> <code>shutdown()</code> </strong>：关闭线程池，线程池的状态变为  <code>SHUTDOWN</code>  。线程池不再接受新任务了，但是<strong>队列里的任务得执行完毕</strong>。</li>\n<li><strong> <code>shutdownNow()</code> </strong>：关闭线程池，线程池的状态变为  <code>STOP</code>  。线程池会终止当前正在运行的任务，<strong>停止处理排队的任务</strong>，并返回正在等待执行的 List。</li>\n</ul>\n<p>调用完  <code>shutdownNow</code>  和  <code>shuwdown</code>  方法后，并不代表线程池已经完成关闭操作，它只是异步的通知线程池进行关闭处理。</p>\n<p><strong>如果要同步等待线程池彻底关闭后才继续往下执行，需要调用  <code>awaitTermination()</code>  方法进行同步等待</strong>。</p>\n<ul>\n<li>在调用  <code>awaitTermination()</code>  方法时，应该设置合理的超时时间，以避免程序长时间阻塞而导致性能问题。</li>\n<li>另外，由于线程池中的任务可能会被取消或抛出异常，因此在使用  <code>awaitTermination()</code>  方法时还需要进行异常处理。该方法会抛出  <code>InterruptedException</code>  异常，需要捕获并处理该异常，以避免程序崩溃或者无法正常退出。</li>\n</ul>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">// ...</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token comment\">// 关闭线程池</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>executor<span class=\"token punctuation\">.</span><span class=\"token function\">shutdown</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">try</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token comment\">// 等待线程池关闭，最多等待 5 分钟</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>executor<span class=\"token punctuation\">.</span><span class=\"token function\">awaitTermination</span><span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">TimeUnit</span><span class=\"token punctuation\">.</span><span class=\"token constant\">MINUTES</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>        <span class=\"token comment\">// 如果等待超时，则打印日志</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>err<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"线程池未能在5分钟内完全关闭\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">InterruptedException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token comment\">// 异常处理</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h4 id=\"7-线程池尽量不要放耗时任务\"><a class=\"anchor\" href=\"#7-线程池尽量不要放耗时任务\">#</a> 7、线程池尽量不要放耗时任务</h4>\n<p>线程池本身的目的是为了提高任务执行效率，避免因频繁创建和销毁线程而带来的性能开销。如果将耗时任务提交到线程池中执行，可能会导致线程池中的线程被长时间占用，无法及时响应其他任务，甚至会导致线程池崩溃或者程序假死。</p>\n<p>因此，在使用线程池时，我们应该尽量避免将耗时任务提交到线程池中执行<font color='red'>。对于一些比较耗时的操作，如网络请求、文件读写等，可以采用<strong>异步操作</strong>的方式来处理，以避免阻塞线程池中的线程</font>。</p>\n<h4 id=\"8-线程池使用的一些小坑\"><a class=\"anchor\" href=\"#8-线程池使用的一些小坑\">#</a> 8、线程池使用的一些小坑</h4>\n<h5 id=\"不要重复创建线程池\"><a class=\"anchor\" href=\"#不要重复创建线程池\">#</a> 不要重复创建线程池</h5>\n<p>线程池是可以复用的，一定不要频繁创建线程池（比如一个用户请求到了就单独创建一个线程池）。</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token annotation punctuation\">@GetMapping</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"wrong\"</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token class-name\">String</span> <span class=\"token function\">wrong</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">InterruptedException</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token comment\">// 自定义线程池</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token class-name\">ThreadPoolExecutor</span> executor <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ThreadPoolExecutor</span><span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">,</span><span class=\"token number\">10</span><span class=\"token punctuation\">,</span><span class=\"token number\">1L</span><span class=\"token punctuation\">,</span><span class=\"token class-name\">TimeUnit</span><span class=\"token punctuation\">.</span><span class=\"token constant\">SECONDS</span><span class=\"token punctuation\">,</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayBlockingQueue</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token number\">100</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">ThreadPoolExecutor<span class=\"token punctuation\">.</span>CallerRunsPolicy</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token comment\">//  处理任务</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    executor<span class=\"token punctuation\">.</span><span class=\"token function\">execute</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>      <span class=\"token comment\">// ......</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token keyword\">return</span> <span class=\"token string\">\"OK\"</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>出现这种问题的原因还是对于线程池认识不够，需要加强线程池的基础知识。</p>\n<h5 id=\"使用spring内部线程池时一定要手动自定义\"><a class=\"anchor\" href=\"#使用spring内部线程池时一定要手动自定义\">#</a> 使用 Spring 内部线程池时一定要手动自定义</h5>\n<p>使用 Spring 内部线程池时，一定要手动自定义线程池，配置合理的参数，不然会出现生产问题（一个请求创建一个线程）。</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token annotation punctuation\">@Configuration</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token annotation punctuation\">@EnableAsync</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">ThreadPoolExecutorConfig</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token annotation punctuation\">@Bean</span><span class=\"token punctuation\">(</span>name<span class=\"token operator\">=</span><span class=\"token string\">\"threadPoolExecutor\"</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token class-name\">Executor</span> <span class=\"token function\">threadPoolExecutor</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>        <span class=\"token class-name\">ThreadPoolTaskExecutor</span> threadPoolExecutor <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ThreadPoolTaskExecutor</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>        <span class=\"token keyword\">int</span> processNum <span class=\"token operator\">=</span> <span class=\"token class-name\">Runtime</span><span class=\"token punctuation\">.</span><span class=\"token function\">getRuntime</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">availableProcessors</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 返回可用处理器的 Java 虚拟机的数量</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>        <span class=\"token keyword\">int</span> corePoolSize <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span>processNum <span class=\"token operator\">/</span> <span class=\"token punctuation\">(</span><span class=\"token number\">1</span> <span class=\"token operator\">-</span> <span class=\"token number\">0.2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>        <span class=\"token keyword\">int</span> maxPoolSize <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span>processNum <span class=\"token operator\">/</span> <span class=\"token punctuation\">(</span><span class=\"token number\">1</span> <span class=\"token operator\">-</span> <span class=\"token number\">0.5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>        threadPoolExecutor<span class=\"token punctuation\">.</span><span class=\"token function\">setCorePoolSize</span><span class=\"token punctuation\">(</span>corePoolSize<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 核心池大小</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>        threadPoolExecutor<span class=\"token punctuation\">.</span><span class=\"token function\">setMaxPoolSize</span><span class=\"token punctuation\">(</span>maxPoolSize<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 最大线程数</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>        threadPoolExecutor<span class=\"token punctuation\">.</span><span class=\"token function\">setQueueCapacity</span><span class=\"token punctuation\">(</span>maxPoolSize <span class=\"token operator\">*</span> <span class=\"token number\">1000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 队列程度</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>        threadPoolExecutor<span class=\"token punctuation\">.</span><span class=\"token function\">setThreadPriority</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Thread</span><span class=\"token punctuation\">.</span><span class=\"token constant\">MAX_PRIORITY</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>        threadPoolExecutor<span class=\"token punctuation\">.</span><span class=\"token function\">setDaemon</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>        threadPoolExecutor<span class=\"token punctuation\">.</span><span class=\"token function\">setKeepAliveSeconds</span><span class=\"token punctuation\">(</span><span class=\"token number\">300</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">// 线程空闲时间</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>        threadPoolExecutor<span class=\"token punctuation\">.</span><span class=\"token function\">setThreadNamePrefix</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"test-Executor-\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 线程名字前缀</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>        <span class=\"token keyword\">return</span> threadPoolExecutor<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h5 id=\"线程池和-threadlocal-不要共用\"><a class=\"anchor\" href=\"#线程池和-threadlocal-不要共用\">#</a> 线程池和 ThreadLocal 不要共用</h5>\n<p>线程池和  <code>ThreadLocal</code>  共用，可能会导致线程从  <code>ThreadLocal</code>  获取到的是旧值 / 脏数据。<strong>因为线程池会复用线程对象，与线程对象绑定的类的静态属性  <code>ThreadLocal</code>  变量也会被重用，这就导致一个线程可能获取到其他线程的 <code>ThreadLocal</code>  值</strong>。</p>\n<p>不要以为代码中没有显示使用线程池就不存在线程池了，像常用的 Web 服务器 Tomcat 处理任务为了提高并发量，就使用到了线程池，并且使用的是基于原生 Java 线程池改进完善得到的自定义线程池。</p>\n<p>当然了，你可以将 Tomcat 设置为单线程处理任务。不过，这并不合适，会严重影响其处理任务的速度。</p>\n<figure class=\"highlight properties\"><figcaption data-lang=\".properties\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token key attr-name\">server.tomcat.max-threads</span><span class=\"token punctuation\">=</span><span class=\"token value attr-value\">1</span></pre></td></tr></table></figure><p>解决上述问题比较建议的办法是<strong>使用阿里巴巴开源的   <code>TransmittableThreadLocal</code> ( <code>TTL</code> ) 来代替  <code>ThreadLocal</code> </strong>。</p>\n<blockquote>\n<p>该类继承并加强了 JDK 内置的  <code>InheritableThreadLocal</code>  类，在使用线程池等会池化复用线程的执行组件情况下，提供  <code>ThreadLocal</code>  的值传递功能，解决异步执行时上下文传递的问题。</p>\n<p>项目地址：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2FsaWJhYmEvdHJhbnNtaXR0YWJsZS10aHJlYWQtbG9jYWw=\">https://github.com/alibaba/transmittable-thread-local</span></p>\n</blockquote>\n<h2 id=\"future-接口\"><a class=\"anchor\" href=\"#future-接口\">#</a> Future 接口</h2>\n<h3 id=\"有什么用-2\"><a class=\"anchor\" href=\"#有什么用-2\">#</a> 有什么用？</h3>\n<p><code>Future</code>  类是 **<font color='red'>异步调用思想</font>** 的典型运用，可以将这个耗时任务交给一个子线程去异步执行，同时我们可以干点其他事情，<font color='red'>不用傻傻等待耗时任务执行完成</font>。等我们的事情干完后，再通过  <code>Future</code>  类获取到耗时任务的执行结果。<font color='red'>可以提高程序的执行效率</font>。</p>\n<p>在 Java 中， <code>Future</code>  类只是一个 **<font color='red'>泛型接口</font>**，位于  <code>java.util.concurrent</code>  包下，其中定义了 5 个方法，主要包括下面这 4 个功能：</p>\n<ul>\n<li><font color='gree'>取消任务</font></li>\n<li>判断任务是否被取消</li>\n<li>判断任务是否已经执行完成</li>\n<li><font color='gree'>获取任务执行结果</font></li>\n</ul>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">// V 代表了 Future 执行的任务返回值的类型</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">interface</span> <span class=\"token class-name\">Future</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">V</span><span class=\"token punctuation\">></span></span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token comment\">// 取消任务执行</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token comment\">// 成功取消返回 true，否则返回 false</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token keyword\">boolean</span> <span class=\"token function\">cancel</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">boolean</span> mayInterruptIfRunning<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token comment\">// 判断任务是否被取消</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token keyword\">boolean</span> <span class=\"token function\">isCancelled</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token comment\">// 判断任务是否已经执行完成</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token keyword\">boolean</span> <span class=\"token function\">isDone</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token comment\">// 获取任务执行结果</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token class-name\">V</span> <span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">InterruptedException</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">ExecutionException</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    <span class=\"token comment\">// 指定时间内没有返回计算结果就抛出 TimeOutException 异常</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    <span class=\"token class-name\">V</span> <span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">long</span> timeout<span class=\"token punctuation\">,</span> <span class=\"token class-name\">TimeUnit</span> unit<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">InterruptedException</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">ExecutionException</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">TimeoutException</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>简单理解就是：</p>\n<ul>\n<li>我有一个任务，提交给了  <code>Future</code>  来处理。</li>\n<li>任务执行期间，我可以去做任何想做的事情，还可以取消任务或者获取任务的执行状态。</li>\n<li>一段时间之后，我就可以  <code>Future</code>  那里直接取出任务执行结果。</li>\n</ul>\n<h3 id=\"与-callable-的关系\"><a class=\"anchor\" href=\"#与-callable-的关系\">#</a> 与 Callable 的关系</h3>\n<p><strong> <code>FutureTask</code>  类基本实现了  <code>Future</code>  接口</strong>，常用来封装  <code>Callable</code>  和  <code>Runnable</code> ，具有取消任务、查看任务是否执行完成、获取任务执行结果的方法。 <code>ExecutorService.submit()</code>  方法返回的其实就是  <code>Future</code>  的实现类  <code>FutureTask</code>  。</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">></span></span> <span class=\"token class-name\">Future</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">></span></span> <span class=\"token function\">submit</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Callable</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">></span></span> task<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token class-name\">Future</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span><span class=\"token punctuation\">></span></span> <span class=\"token function\">submit</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Runnable</span> task<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p><code>FutureTask</code>  不光实现了  <code>Future</code>  接口，还实现了  <code>Runnable</code>  接口，因此可以作为任务直接被线程执行。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/completablefuture-class-diagram.jpg\" alt=\"img\" /></p>\n<p><code>FutureTask</code>  有两个构造函数，可传入  <code>Callable</code>  或者  <code>Runnable</code>  对象。实际上，传入  <code>Runnable</code>  对象也会在方法内部转换为  <code>Callable</code>  对象。</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token class-name\">FutureTask</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Callable</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">V</span><span class=\"token punctuation\">></span></span> callable<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>callable <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>        <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">NullPointerException</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>callable <span class=\"token operator\">=</span> callable<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state <span class=\"token operator\">=</span> <span class=\"token constant\">NEW</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token class-name\">FutureTask</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Runnable</span> runnable<span class=\"token punctuation\">,</span> <span class=\"token class-name\">V</span> result<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token comment\">// 通过适配器 RunnableAdapter 来将 Runnable 对象转换成 Callable 对象</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>callable <span class=\"token operator\">=</span> <span class=\"token class-name\">Executors</span><span class=\"token punctuation\">.</span><span class=\"token function\">callable</span><span class=\"token punctuation\">(</span>runnable<span class=\"token punctuation\">,</span> result<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state <span class=\"token operator\">=</span> <span class=\"token constant\">NEW</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p><strong> <code>FutureTask</code>  相当于对  <code>Callable</code>  进行了封装，管理着任务执行的情况，存储了  <code>Callable</code>  的  <code>call</code>  方法的任务执行结果</strong>。</p>\n<h3 id=\"completablefuture-类\"><a class=\"anchor\" href=\"#completablefuture-类\">#</a> CompletableFuture 类</h3>\n<p><code>Future</code>  在实际使用过程中存在一些局限性，比如不支持异步任务的编排组合、获取计算结果的  <code>get()</code>  方法为阻塞调用。</p>\n<p><strong>Java 8 引入  <code>CompletableFuture</code>  类来解决  <code>Future</code>  的这些缺陷</strong>。除了提供了更为好用和强大的  <code>Future</code>  特性之外，还提供了<font color='red'>函数式编程、异步任务编排组合（可以将多个异步任务串联起来，组成一个完整的链式调用）</font>等能力。</p>\n<p>下面我们来简单看看  <code>CompletableFuture</code>  类的定义。</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">CompletableFuture</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">></span></span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Future</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">CompletionStage</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">></span></span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>可以看到， <code>CompletableFuture</code>  同时实现了  <code>Future</code>  接口和  <code>CompletionStage</code>  接口。</p>\n<p><img data-src=\"https://oss.javaguide.cn/github/javaguide/java/concurrent/completablefuture-class-diagram.jpg\" alt=\"img\" /></p>\n<p><font color='red'> <code>CompletionStage</code>  接口描述了一个异步计算的阶段</font>。很多计算可以分成多个阶段或步骤，此时可以通过它将所有步骤组合起来，形成异步计算的流水线。</p>\n<p><code>CompletionStage</code>  接口中的方法比较多， <code>CompletableFuture</code>  的函数式能力就是这个接口赋予的。从这个接口的方法参数你就可以发现其大量使用了 Java8 引入的函数式编程。</p>\n<h1 id=\"并发包juc\"><a class=\"anchor\" href=\"#并发包juc\">#</a> 并发包（J.U.C）</h1>\n<blockquote>\n<p><code>java.util.concurrent</code>  包</p>\n</blockquote>\n<h2 id=\"java常见并发容器\"><a class=\"anchor\" href=\"#java常见并发容器\">#</a> Java 常见并发容器</h2>\n<p>JDK 提供的这些容器大部分在  <code>java.util.concurrent</code>  包中。</p>\n<ul>\n<li><strong> <code>ConcurrentHashMap</code> </strong> : 线程安全的  <code>HashMap</code></li>\n<li><strong> <code>CopyOnWriteArrayList</code> </strong> : 线程安全的  <code>List</code> ，在<font color='red'>读多写少</font>的场合性能非常好，远远好于  <code>Vector</code></li>\n<li><strong> <code>ConcurrentLinkedQueue</code> </strong> : 高效的并发队列，<font color='red'>使用链表实现</font>。可以看做一个线程安全的  <code>LinkedList</code> ，这是一个<font color='red'>非阻塞队列</font></li>\n<li><strong> <code>BlockingQueue</code> </strong> : 这是一个<font color='red'>接口</font>，JDK 内部通过链表、数组等方式实现了这个接口。表示<font color='red'>阻塞队列</font>，非常适合用于作为数据共享的通道</li>\n<li><strong> <code>ConcurrentSkipListMap</code> </strong> : <font color='red'>跳表</font>的实现。这是一个 Map，使用跳表的数据结构进行快速查找</li>\n</ul>\n<h3 id=\"concurrenthashmap\"><a class=\"anchor\" href=\"#concurrenthashmap\">#</a> ConcurrentHashMap</h3>\n<blockquote>\n<p><strong>线程安全的  <code>HashMap</code> </strong></p>\n</blockquote>\n<p><font color='red'> <code>HashMap</code>  不是线程安全的</font>，在并发场景下如果要保证一种可行的方式是使用  <code>Collections.synchronizedMap()</code>  方法来包装我们的  <code>HashMap</code> 。但这是通过使用一个全局的锁来同步不同线程间的并发访问，因此会带来不可忽视的性能问题。</p>\n<p>所以就有了 <strong> <code>HashMap</code>  的线程安全版本</strong> ——  <code>ConcurrentHashMap</code>  的诞生。</p>\n<ul>\n<li>在 JDK 1.7 的时候， <code>ConcurrentHashMap</code>  对整个桶数组进行了分段（Segment），采用的是<strong>分段锁</strong>，每把锁对应一个 Segment。每个  <code>Segment</code>  都是一个类似  <code>HashMap</code>  数组的结构，它可以扩容，它的冲突会转化为链表。但是  <code>Segment</code>  的个数一但初始化就不能改变。</li>\n<li>到了 JDK 1.8 的时候， <code>ConcurrentHashMap</code>  摒弃了  <code>Segment</code>  的概念，而是采用 <strong> <code>Node</code>  数组 + 链表 / 红黑树</strong> 的数据结构来实现，使用 <strong> <code>synchronized</code>  锁 + CAS</strong> 来控制并发。Node 是类似于一个 HashEntry 的结构。它的冲突再达到一定大小时会转化成红黑树，在冲突小于一定数量时又退回链表。</li>\n</ul>\n<h4 id=\"concurrenthashmap-17\"><a class=\"anchor\" href=\"#concurrenthashmap-17\">#</a> ConcurrentHashMap 1.7</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/java7_concurrenthashmap.png\" alt=\"Java 7 ConcurrentHashMap 存储结构\" /></p>\n<p>Java 7 中  <code>ConcurrentHashMap</code>  的存储结构如上图，</p>\n<ul>\n<li><code>ConcurrnetHashMap</code>  由很多个  <code>Segment</code>  组合</li>\n<li>每一个  <code>Segment</code>  是一个类似于  <code>HashMap</code>  的结构  <code>HashEntry</code>  数组，所以每一个  <code>HashEntry</code>  的内部可以进行扩容。</li>\n<li>但是  <code>Segment</code>  的个数一旦<strong>初始化就不能改变</strong>，默认  <code>Segment</code>  的个数是 16 个，你也可以认为  <code>ConcurrentHashMap</code>  默认支持最多 16 个线程并发。</li>\n</ul>\n<h4 id=\"concurrenthashmap-18\"><a class=\"anchor\" href=\"#concurrenthashmap-18\">#</a> ConcurrentHashMap 1.8</h4>\n<h5 id=\"存储结构\"><a class=\"anchor\" href=\"#存储结构\">#</a> 存储结构</h5>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/java8_concurrenthashmap.png\" alt=\"Java8 ConcurrentHashMap 存储结构（图片来自 javadoop）\" /></p>\n<p>可以发现 Java8 的 ConcurrentHashMap 相对于 Java7 来说变化比较大，不再是之前的 Segment 数组 + HashEntry 数组 + 链表，而是 <strong>Node 数组 + 链表 / 红黑树</strong>。<font color='red'>当冲突链表达到一定长度时，链表会转换成红黑树</font>。</p>\n<h5 id=\"初始化-inittable\"><a class=\"anchor\" href=\"#初始化-inittable\">#</a> 初始化 initTable</h5>\n<p>从源码中可以发现  <code>ConcurrentHashMap</code>  的初始化是通过<strong>自旋</strong>和 <strong>CAS 操作</strong>完成的。里面需要注意的是变量  <code>sizeCtl</code>  ，它的值决定着当前的初始化状态。</p>\n<ul>\n<li>\n<p>-1 说明正在初始化</p>\n</li>\n<li>\n<p>-N 说明有 N-1 个线程正在进行扩容</p>\n</li>\n<li>\n<p>0 表示 table 初始化大小，如果 table 没有初始化</p>\n</li>\n<li>\n<p>&gt;0 表示 table 扩容的阈值，如果 table 已经初始化。</p>\n</li>\n</ul>\n<h5 id=\"put\"><a class=\"anchor\" href=\"#put\">#</a> put</h5>\n<ol>\n<li>\n<p>根据 key 计算出 hashcode</p>\n</li>\n<li>\n<p>判断是否需要进行初始化</p>\n</li>\n<li>\n<p>即为当前 key 定位出的 Node，如果为空表示当前位置可以写入数据，利用 CAS 尝试写入，失败则自旋保证成功</p>\n</li>\n<li>\n<p>如果当前位置的  <code>hashcode == MOVED == -1</code> ，则需要进行扩容</p>\n</li>\n<li>\n<p>如果都不满足，则利用 synchronized 锁写入数据</p>\n</li>\n<li>\n<p>如果数量大于  <code>TREEIFY_THRESHOLD</code>  则要执行树化方法，在  <code>treeifyBin</code>  中会首先判断当前数组长度 ≥64 时才会将链表转换为红黑树</p>\n</li>\n</ol>\n<h5 id=\"get\"><a class=\"anchor\" href=\"#get\">#</a> get</h5>\n<ol>\n<li>根据 hash 值计算位置。</li>\n<li>查找到指定位置，如果头节点就是要找的，直接返回它的 value.</li>\n<li>如果头节点 hash 值小于 0 ，说明正在扩容或者是红黑树，查找之。</li>\n<li>如果是链表，遍历查找之。</li>\n</ol>\n<h4 id=\"面试题concurrenthashmap-相对于-hashmap-好在哪里\"><a class=\"anchor\" href=\"#面试题concurrenthashmap-相对于-hashmap-好在哪里\">#</a> 【面试题】concurrentHashMap 相对于 hashMap 好在哪里？</h4>\n<p>ConcurrentHashMap 是 Java 中的一个<strong>线程安全</strong>的 hashMap 实现，它可以在多线程环境下并发地进行读写操作，而<font color='red'>不需要像传统的 hashMap 那样在读写时加锁</font>。</p>\n<p>ConcurrentHashMap 的实现原理主要基于<strong>分段锁</strong>和 CAS 操作。它将整个哈希表分成了多个 Segment（段），每个 Segment 都类似于一个小的 HashMap，它拥有自己的数组和一个独立的锁。在 ConcurrentHashMap 中，读操作不需要锁，可以直接对 Segment 进行读取，而<font color='red'>写操作则只需要锁定对应的 Segment，而不是整个哈希表</font>，这样可以大大提高并发性能。</p>\n<h3 id=\"copyonwritearraylist\"><a class=\"anchor\" href=\"#copyonwritearraylist\">#</a> CopyOnWriteArrayList</h3>\n<blockquote>\n<p><strong>线程安全的  <code>List</code> </strong>，适合读多写少的场景</p>\n</blockquote>\n<p>在 JDK1.5 之前，如果想要使用并发安全的  <code>List</code>  只能选择  <code>Vector</code> 。而  <code>Vector</code>  是一种老旧的集合，已经被淘汰。 <code>Vector</code>  对于增删改查等方法基本都加了  <code>synchronized</code> ，这种方式虽然能够保证同步，但这相当于对整个  <code>Vector</code>  加上了一把大锁，使得每个方法执行的时候都要去获得锁，导致性能非常低下。</p>\n<p>JDK1.5 引入了  <code>Java.util.concurrent</code> （JUC）包，其中提供了很多线程安全且并发性能良好的容器，其中唯一的线程安全  <code>List</code>  实现就是  <code>CopyOnWriteArrayList</code>  。</p>\n<p>对于大部分业务场景来说，读取操作往往是远大于写入操作的。由于读取操作不会对原有数据进行修改，因此，对于每次读取都进行加锁其实是一种资源浪费。相比之下，我们应该允许多个线程同时访问  <code>List</code>  的内部数据，毕竟对于读取操作来说是安全的。</p>\n<p>这种思路与  <code>ReentrantReadWriteLock</code>  读写锁的设计思想非常类似，即读读不互斥、读写互斥、写写互斥（<font color='red'>只有读读不互斥</font>）。 <code>CopyOnWriteArrayList</code>  更进一步地实现了这一思想。为了将读操作性能发挥到极致， <code>CopyOnWriteArrayList</code>  中的<font color='red'>读取操作是完全无需加锁的</font>。更加厉害的是，<font color='red'>写入操作也不会阻塞读取操作，只有写写才会互斥</font>。这样一来，读操作的性能就可以大幅度提升。</p>\n<p><code>CopyOnWriteArrayList</code>  线程安全的核心在于其采用了 <strong>写时复制（Copy-On-Write）</strong> 的策略，从  <code>CopyOnWriteArrayList</code>  的名字就能看出了。</p>\n<p>当需要修改（  <code>add</code> ， <code>set</code> 、 <code>remove</code>  等操作）  <code>CopyOnWriteArrayList</code>  的内容时，<strong><font color='red'>不会直接修改原数组，而是会先创建底层数组的副本，对副本数组进行修改，修改完之后再将修改后的数组赋值回去</font></strong>，这样就可以保证写操作不会影响读操作了。</p>\n<h3 id=\"concurrentlinkedqueue\"><a class=\"anchor\" href=\"#concurrentlinkedqueue\">#</a> ConcurrentLinkedQueue</h3>\n<blockquote>\n<p><strong>线程安全的<font color='red'>非阻塞队列</font></strong></p>\n</blockquote>\n<p>Java 提供的线程安全的  <code>Queue</code>  可以分为阻塞队列和非阻塞队列，其中阻塞队列的典型例子是  <code>BlockingQueue</code> ，非阻塞队列的典型例子是  <code>ConcurrentLinkedQueue</code> ，在实际应用中要根据实际需要选用阻塞队列或者非阻塞队列。</p>\n<p><strong>阻塞队列可以通过加锁来实现，非阻塞队列可以通过 CAS 操作实现。</strong></p>\n<p>从名字可以看出， <code>ConcurrentLinkedQueue</code>  这个队列使用<font color='red'>链表</font>作为其数据结构。 <code>ConcurrentLinkedQueue</code>  应该算是在高并发环境中性能最好的队列了。它之所有能有<font color='red'>很好的性能</font>，是因为其内部复杂的实现。</p>\n<p><code>ConcurrentLinkedQueue</code>  主要使用 <strong>CAS 非阻塞算法</strong>来实现线程安全就好了。</p>\n<p><code>ConcurrentLinkedQueue</code>  适合在对性能要求相对较高，同时对队列的读写存在多个线程同时进行的场景，即如果对队列加锁的成本较高则适合使用<font color='red'>无锁</font>的  <code>ConcurrentLinkedQueue</code>  来替代。</p>\n<h3 id=\"blockingqueue-接口\"><a class=\"anchor\" href=\"#blockingqueue-接口\">#</a> BlockingQueue 接口</h3>\n<blockquote>\n<p><strong>线程安全的<font color='red'>阻塞队列</font></strong>，可用作线程池中的工作队列 <code>workQueue</code></p>\n</blockquote>\n<h4 id=\"简介-8\"><a class=\"anchor\" href=\"#简介-8\">#</a> 简介</h4>\n<p>阻塞队列（ <code>BlockingQueue</code> ）被广泛使用在 “生产者 - 消费者” 问题中，其原因是  <code>BlockingQueue</code>  提供了<font color='red'>可阻塞的插入和移除</font>的方法。</p>\n<ul>\n<li>当队列容器已满，生产者线程会被阻塞，直到队列未满</li>\n<li>当队列容器为空时，消费者线程会被阻塞，直至队列非空时为止</li>\n</ul>\n<p><code>BlockingQueue</code>  是一个<font color='red'>接口</font>，继承自  <code>Queue</code> ，所以其实现类也可以作为  <code>Queue</code>  的实现来使用，而  <code>Queue</code>  又继承自  <code>Collection</code>  接口。下面是  <code>BlockingQueue</code>  的实现类：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/51622268.jpg\" alt=\"BlockingQueue 的实现类\" /></p>\n<p>下面主要介绍一下 3 个常见的  <code>BlockingQueue</code>  的实现类： <code>ArrayBlockingQueue</code> 、 <code>LinkedBlockingQueue</code> 、 <code>PriorityBlockingQueue</code> 。</p>\n<h4 id=\"arrayblockingqueue\"><a class=\"anchor\" href=\"#arrayblockingqueue\">#</a> ArrayBlockingQueue</h4>\n<p><code>ArrayBlockingQueue</code>  是  <code>BlockingQueue</code>  接口的<strong>有界阻塞队列</strong>实现类，底层采用<font color='red'>数组</font>来实现。</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">ArrayBlockingQueue</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">E</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">extends</span> <span class=\"token class-name\">AbstractQueue</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">E</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">implements</span> <span class=\"token class-name\">BlockingQueue</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">E</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">Serializable</span><span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p><code>ArrayBlockingQueue</code>  <font color='red'>一旦创建，容量不能改变</font>。其并发控制采用<font color='red'>可重入锁</font>  <code>ReentrantLock</code>  ，不管是插入操作还是读取操作，都需要获取到锁才能进行操作。</p>\n<ul>\n<li>当队列容量满时，尝试将元素放入队列将导致操作阻塞</li>\n<li>尝试从一个空队列中取一个元素也会同样阻塞</li>\n</ul>\n<p><code>ArrayBlockingQueue</code>  默认情况下不能保证线程访问队列的公平性，所谓公平性是指严格按照线程等待的绝对时间顺序，即最先等待的线程能够最先访问到  <code>ArrayBlockingQueue</code> 。而<font color='red'>非公平性</font>则是指访问  <code>ArrayBlockingQueue</code>  的顺序不是遵守严格的时间顺序，有可能存在，当  <code>ArrayBlockingQueue</code>  可以被访问时，长时间阻塞的线程依然无法访问到  <code>ArrayBlockingQueue</code> 。如果保证公平性，通常会降低吞吐量。</p>\n<p>如果需要获得公平性的  <code>ArrayBlockingQueue</code> ，可采用如下代码：</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token class-name\">ArrayBlockingQueue</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span></span> blockingQueue <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayBlockingQueue</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">,</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h4 id=\"linkedblockingqueue\"><a class=\"anchor\" href=\"#linkedblockingqueue\">#</a> LinkedBlockingQueue</h4>\n<p><code>LinkedBlockingQueue</code>  底层基于 **<font color='red'>单向链表</font><strong>实现的阻塞队列，可以当做</strong>无界阻塞队列 ** 也可以当做有界阻塞队列来使用，同样满足 <strong><font color='red'>FIFO</font></strong> 的特性，与  <code>ArrayBlockingQueue</code>  相比起来具有更高的吞吐量，为了防止  <code>LinkedBlockingQueue</code>  容量迅速增大，损耗大量内存。通常在创建  <code>LinkedBlockingQueue</code>  对象时，会指定其大小，<font color='red'>如果未指定大小，容量等于  <code>Integer.MAX_VALUE</code> </font> 。</p>\n<p>相关构造方法:</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">/**</pre></td></tr><tr><td data-num=\"2\"></td><td><pre> * 某种意义上的无界队列</pre></td></tr><tr><td data-num=\"3\"></td><td><pre> * Creates a &#123;@code LinkedBlockingQueue&#125; with a capacity of</pre></td></tr><tr><td data-num=\"4\"></td><td><pre> * &#123;@link Integer#MAX_VALUE&#125;.</pre></td></tr><tr><td data-num=\"5\"></td><td><pre> */</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token class-name\">LinkedBlockingQueue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token keyword\">this</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">.</span><span class=\"token constant\">MAX_VALUE</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token comment\">/**</pre></td></tr><tr><td data-num=\"11\"></td><td><pre> * 有界队列</pre></td></tr><tr><td data-num=\"12\"></td><td><pre> * Creates a &#123;@code LinkedBlockingQueue&#125; with the given (fixed) capacity.</pre></td></tr><tr><td data-num=\"13\"></td><td><pre> *</pre></td></tr><tr><td data-num=\"14\"></td><td><pre> * @param capacity the capacity of this queue</pre></td></tr><tr><td data-num=\"15\"></td><td><pre> * @throws IllegalArgumentException if &#123;@code capacity&#125; is not greater</pre></td></tr><tr><td data-num=\"16\"></td><td><pre> *         than zero</pre></td></tr><tr><td data-num=\"17\"></td><td><pre> */</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token class-name\">LinkedBlockingQueue</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> capacity<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>capacity <span class=\"token operator\">&lt;=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">IllegalArgumentException</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>capacity <span class=\"token operator\">=</span> capacity<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>    last <span class=\"token operator\">=</span> head <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Node</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">E</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h4 id=\"priorityblockingqueue\"><a class=\"anchor\" href=\"#priorityblockingqueue\">#</a> PriorityBlockingQueue</h4>\n<blockquote>\n<p>线程安全的  <code>PriorityQueue</code></p>\n</blockquote>\n<p><code>PriorityBlockingQueue</code>  是一个<strong>支持优先级的无界阻塞队列</strong>。默认情况下元素采用<font color='red'>自然顺序</font>进行排序，也可以通过自定义类<font color='red'>实现  <code>compareTo()</code>  方法</font>来指定元素排序规则，或者初始化时通过<font color='red'>构造器参数  <code>Comparator</code>  </font>来指定排序规则。</p>\n<p><code>PriorityBlockingQueue</code>  并发控制采用的是<font color='red'>可重入锁</font>  <code>ReentrantLock</code> ，队列为<font color='red'>无界队列</font>（ <code>ArrayBlockingQueue</code>  是有界队列， <code>LinkedBlockingQueue</code>  也可以通过在构造函数中传入  <code>capacity</code>  指定队列最大的容量，但是  <code>PriorityBlockingQueue</code>  只能指定初始的队列大小，后面插入元素的时候，<strong>如果空间不够的话会自动扩容</strong>）。</p>\n<p>简单地说，它就是  <code>PriorityQueue</code>  的线程安全版本。<strong><font color='red'>不可以插入 null 值，同时，插入队列的对象必须是可比较大小的（comparable）</font></strong>，否则报  <code>ClassCastException</code>  异常。它的插入操作 put 方法不会 block，因为它是无界队列（take 方法在队列为空的时候会阻塞）。</p>\n<h3 id=\"concurrentskiplistmap\"><a class=\"anchor\" href=\"#concurrentskiplistmap\">#</a> ConcurrentSkipListMap</h3>\n<blockquote>\n<p><strong>使用跳表实现的 Map</strong></p>\n</blockquote>\n<p>首先要清楚什么是 “跳表”：对于一个单链表，即使链表是有序的，如果我们想要在其中查找某个数据，也只能从头到尾遍历链表，这样效率自然就会很低，跳表就不一样了。跳表是一种<font color='red'>可用来快速查找</font>的数据结构，有点类似于平衡树。它们都可以对元素进行快速的查找。但一个重要的区别是：对平衡树的插入和删除往往很可能导致平衡树进行一次全局的调整。而<font color='red'>对跳表的插入和删除只需要对数据结构的局部进行操作即可</font>。这样带来的好处是：在高并发的情况下，你会需要一个全局锁来保证整个平衡树的线程安全。而对于跳表，你只需要<font color='red'>部分锁即可</font>。这样，在高并发环境下，你就可以拥有<font color='red'>更好的性能</font>。而就查询的性能而言，跳表的<font color='red'>时间复杂度也是 O (logn)</font> 。所以在并发数据结构中，JDK 使用跳表来实现一个 Map。</p>\n<p>跳表的本质：<strong>同时维护了多个链表，并且链表是分层的</strong>。<font color='red'>最低层的链表维护了跳表内所有的元素，每上面一层链表都是下面一层的子集</font>。跳表内的<font color='red'>所有链表的元素都是排序的</font>。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/93666217.jpg\" alt=\"2级索引跳表\" /></p>\n<center>（2级索引跳表）</center>\n<p>从顶级链表开始查找。<font color='red'>一旦发现被查找的元素大于当前链表中的<strong>所有</strong>取值，就会转入下一层链表继续找</font>。这也就是说在查找过程中，搜索是跳跃式的。</p>\n<p>如下图所示，在跳表中查找元素 18。查找 18 的时候原来需要遍历 18 次，现在只需要 7 次即可。针对链表长度比较大的时候，<font color='red'>构建索引</font>对查找效率的提升就会非常明显。</p>\n<p>从上面很容易看出，<strong>跳表是一种利用空间换时间的算法。</strong></p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/32005738.jpg\" alt=\"在跳表中查找元素18\" /></p>\n<center>（在跳表中查找元素18）</center>\n<p>使用跳表实现  <code>Map</code>  和使用哈希算法实现  <code>Map</code>  的另外一个不同之处是：哈希并不会保存元素的顺序，而<strong>跳表内所有的元素都是排序的</strong>。因此在对跳表进行遍历时，你会得到一个有序的结果。所以，如果你的应用需要有序性，那么跳表就是你不二的选择。JDK 中实现这一数据结构的类是  <code>ConcurrentSkipListMap</code> 。</p>\n<h1 id=\"java-io\"><a class=\"anchor\" href=\"#java-io\">#</a> Java IO</h1>\n<h2 id=\"基础知识\"><a class=\"anchor\" href=\"#基础知识\">#</a> 基础知识</h2>\n<p>Java IO 流的 40 多个类都是从如下<strong> 4 个抽象类</strong>基类中派生出来的：</p>\n<ul>\n<li><code>InputStream</code> ：字节输入流</li>\n<li><code>OutputStream</code> ：字节输出流</li>\n<li><code>Reader</code> : 字符输入流</li>\n<li><code>Writer</code> : 字符输出流</li>\n</ul>\n<h2 id=\"设计模式\"><a class=\"anchor\" href=\"#设计模式\">#</a> 设计模式</h2>\n<blockquote>\n<p>从 IO 中能够学习到的设计模式</p>\n</blockquote>\n<h3 id=\"装饰器模式decorator\"><a class=\"anchor\" href=\"#装饰器模式decorator\">#</a> 装饰器模式（Decorator）</h3>\n<p>装饰器模式<strong>可以在不改变原有对象的情况下，拓展其功能</strong>。通过<font color='red'>组合</font>替代继承，来扩展原始类的功能，在一些继承关系比较复杂的场景更加实用。</p>\n<p><font color='red'>对于字节流来说， <code>FilterInputStream</code>  和  <code>FilterOutputStream</code>  是装饰器模式的核心</font>，分别用于增强  <code>InputStream</code>  和  <code>OutputStream</code>  子类对象的功能。</p>\n<p>我们常见的  <code>BufferedInputStream</code>  (字节缓冲输入流)、 <code>DataInputStream</code>  等等都是  <code>FilterInputStream</code>  的子类， <code>BufferedOutputStream</code> （字节缓冲输出流）、 <code>DataOutputStream</code>  等等都是  <code>FilterOutputStream</code>  的子类。</p>\n<h3 id=\"适配器模式adapter\"><a class=\"anchor\" href=\"#适配器模式adapter\">#</a> 适配器模式（Adapter）</h3>\n<p>适配器（Adapter Pattern）模式主要<strong>用于接口互不兼容的类的协调工作</strong>，你可以将其联想到我们日常经常使用的电源适配器。</p>\n<p>适配器模式中存在被适配的对象或者类称为<strong>适配者 (Adaptee)</strong> ，作用于适配者的对象或者类称为<strong>适配器 (Adapter)</strong> 。适配器分为对象适配器和类适配器。</p>\n<ul>\n<li>类适配器：使用继承关系来实现</li>\n<li>对象适配器：使用组合关系来实现</li>\n</ul>\n<h4 id=\"与装饰器模式的区别\"><a class=\"anchor\" href=\"#与装饰器模式的区别\">#</a> 与装饰器模式的区别</h4>\n<p>装饰器模式：更侧重于动态地增强原始类的功能，装饰器类需要跟原始类继承相同的抽象类或者实现相同的接口。并且，装饰器模式支持对原始类嵌套使用多个装饰器。</p>\n<p>适配器模式：更侧重于让接口不兼容而不能交互的类可以一起工作，当我们调用适配器对应的方法时，适配器内部会调用适配者类或者和适配类相关的类的方法，这个过程透明的。就比如说  <code>StreamDecoder</code>  （流解码器）和 <code>StreamEncoder</code> （流编码器）就是分别基于  <code>InputStream</code>  和  <code>OutputStream</code>  来获取  <code>FileChannel</code>  对象并调用对应的  <code>read</code>  方法和  <code>write</code>  方法进行字节数据的读取和写入。</p>\n<h3 id=\"工厂模式factory\"><a class=\"anchor\" href=\"#工厂模式factory\">#</a> 工厂模式（Factory）</h3>\n<p>工厂模式<strong>用于创建对象</strong>，NIO 中大量用到了工厂模式，比如  <code>Files</code>  类的  <code>newInputStream</code>  方法用于创建  <code>InputStream</code>  对象（静态工厂）、  <code>Paths</code>  类的  <code>get</code>  方法创建  <code>Path</code>  对象（静态工厂）、 <code>ZipFileSystem</code>  类（ <code>sun.nio</code>  包下的类，属于  <code>java.nio</code>  相关的一些内部实现）的  <code>getPath</code>  的方法创建  <code>Path</code>  对象（简单工厂）。</p>\n<h3 id=\"观察者模式\"><a class=\"anchor\" href=\"#观察者模式\">#</a> 观察者模式</h3>\n<p>NIO 中的文件目录<strong>监听服务</strong>使用到了观察者模式。</p>\n<p>NIO 中的文件目录监听服务基于  <code>WatchService</code>  接口和  <code>Watchable</code>  接口。<strong> <code>WatchService</code>  属于观察者， <code>Watchable</code>  属于被观察者</strong>。</p>\n<p><code>Watchable</code>  接口定义了一个用于将对象注册到  <code>WatchService</code> （监控服务） 并绑定监听事件的方法  <code>register</code>  。</p>\n<p>常用的监听事件有 3 种：</p>\n<ul>\n<li><code>StandardWatchEventKinds.ENTRY_CREATE</code> ：文件创建。</li>\n<li><code>StandardWatchEventKinds.ENTRY_DELETE</code>  : 文件删除。</li>\n<li><code>StandardWatchEventKinds.ENTRY_MODIFY</code>  : 文件修改。</li>\n</ul>\n<h2 id=\"io-模型\"><a class=\"anchor\" href=\"#io-模型\">#</a> <mark>IO 模型</mark></h2>\n<h3 id=\"何为-io\"><a class=\"anchor\" href=\"#何为-io\">#</a> 何为 IO ？</h3>\n<p>从应用程序的角度来解读一下 I/O。</p>\n<p>根据操作系统相关知识：<font color='red'>为了保证操作系统的稳定性和安全性，一个进程的地址空间划分为<strong>用户空间（User space）<strong>和</strong>内核空间（Kernel space）</strong></font>。</p>\n<blockquote>\n<p><strong>为了限制不同的程序之间的访问能力</strong>，防止它们获取别的程序的内存数据，或者获取外围设备的数据，并发送到网络，CPU 划分出两个权限等级：</p>\n<ul>\n<li>\n<p><strong>用户态</strong>：只能受限地访问内存，且不允许访问外围设备，占用 cpu 的能力被剥夺，cpu 资源可以被其他程序获取。</p>\n</li>\n<li>\n<p><strong>内核态</strong>：cpu 可以访问内存的所有数据，包括外围设备，例如硬盘，网卡，cpu 也可以将自己从一个程序切换到另一个程序。</p>\n</li>\n</ul>\n<p><strong>最大的区别：权限不同</strong>，运行在用户态下的程序不能直接访问操作系统内核数据结构和程序。</p>\n</blockquote>\n<p>像我们平常运行的应用程序都是运行在用户空间，只有内核空间才能进行系统态级别的资源有关的操作，比如文件管理、进程通信、内存管理等等。也就是说，<font color='red'>想要进行 IO 操作，一定是要依赖内核空间的能力</font>。并且，用户空间的程序不能直接访问内核空间。当想要执行 IO 操作时，由于没有执行这些操作的权限，只能发起系统调用请求操作系统帮忙完成。</p>\n<p>因此，用户进程想要执行 IO 操作的话，必须通过<font color='red'>系统调用</font>来间接访问内核空间。</p>\n<p>我们在平常开发过程中接触最多的就是<font color='red'>磁盘 IO（读写文件）</font>和<font color='red'>网络 IO（网络请求和响应）</font>。</p>\n<p>从应用程序的视角来看，应用程序对操作系统的内核发起 IO 调用（系统调用），操作系统负责的内核执行具体的 IO 操作。也就是说，<strong>应用程序实际上只是发起了 IO 操作的调用而已，具体 IO 的执行是由操作系统的内核来完成的</strong>。</p>\n<p>当应用程序发起 I/O 调用后，会经历两个步骤：</p>\n<ol>\n<li>内核等待 I/O 设备准备好数据</li>\n<li>内核将数据从内核空间拷贝到用户空间</li>\n</ol>\n<h3 id=\"常见的-io-模型\"><a class=\"anchor\" href=\"#常见的-io-模型\">#</a> 常见的 IO 模型</h3>\n<p>UNIX 系统下，IO 模型一共有 5 种：</p>\n<ul>\n<li>同步阻塞 I/O</li>\n<li>同步非阻塞 I/O</li>\n<li>I/O 多路复用</li>\n<li>信号驱动 I/O</li>\n<li>异步 I/O</li>\n</ul>\n<h3 id=\"java-中-3-种常见-io-模型\"><a class=\"anchor\" href=\"#java-中-3-种常见-io-模型\">#</a> Java 中 3 种常见 IO 模型</h3>\n<h4 id=\"bioblocking\"><a class=\"anchor\" href=\"#bioblocking\">#</a> BIO（Blocking）</h4>\n<p>BIO 属于<strong>同步阻塞 IO 模型</strong>，应用程序发起 read 调用后，会一直阻塞，直到内核把数据拷贝到用户空间。这种阻塞模型<font color='red'>在处理多个并发连接时可能会导致性能瓶颈</font>，因为需要为每个连接创建一个线程，而线程的创建和切换都是有开销的。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/6a9e704af49b4380bb686f0c96d33b81%7Etplv-k3u1fbpfcp-watermark.png\" alt=\"图源：《深入拆解Tomcat &amp; Jetty》\" /></p>\n<h4 id=\"nionon-blockingnew\"><a class=\"anchor\" href=\"#nionon-blockingnew\">#</a> <mark>NIO（Non-blocking/New）</mark></h4>\n<h5 id=\"nio-简介\"><a class=\"anchor\" href=\"#nio-简介\">#</a> NIO 简介</h5>\n<p>为了解决 BIO 同步阻塞 IO 模型导致在高并发下的性能瓶颈问题，Java 1.4 引入了 NIO，对应  <code>java.nio</code>  包，提供了  <code>Channel</code>  ,  <code>Selector</code> ， <code>Buffer</code>  等抽象。它在标准 Java 代码中提供了<strong>非阻塞、面向缓冲、基于通道</strong>的 I/O，<font color='red'>在高负载、高并发情况下可以使用少量的线程来处理多个连接</font>，大大提高了 I/O 效率和并发。</p>\n<p>NIO 可以看作是 <strong>I/O 多路复用模型</strong>。也有很多人认为，Java 中的 NIO 属于同步非阻塞 IO 模型。</p>\n<hr />\n<p>先来看看<strong>同步非阻塞 IO 模型</strong>。应用程序会一直发起 read 调用，等待数据从内核空间拷贝到用户空间的这段时间里，线程依然是阻塞的，直到在内核把数据拷贝到用户空间。<font color='red'>通过 轮询 操作，避免了一直阻塞</font>。</p>\n<p>但是存在问题：<strong><font color='red'>应用程序不断进行 I/O 系统调用轮询数据是否已经准备好的过程是十分消耗 CPU 资源的</font></strong>。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/bb174e22dbe04bb79fe3fc126aed0c61%7Etplv-k3u1fbpfcp-watermark.png\" alt=\"图源：《深入拆解Tomcat &amp; Jetty》\" /></p>\n<hr />\n<p>这个时候，<strong>I/O 多路复用模型</strong> 就上场了。线程首先发起  <code>select</code>  调用，询问内核数据是否准备就绪，等内核把数据准备好了，用户线程再发起  <code>read</code>  调用。read 调用的过程（数据从内核空间 -&gt; 用户空间）还是阻塞的。</p>\n<blockquote>\n<p>目前支持 IO 多路复用的系统调用，有  <code>select</code> ， <code>epoll</code>  等等。select 系统调用，目前几乎在所有的操作系统上都有支持。</p>\n<ul>\n<li><strong>select 调用</strong>：内核提供的系统调用，它支持一次查询多个系统调用的可用状态。几乎所有的操作系统都支持。</li>\n<li><strong>epoll 调用</strong>：linux 2.6 内核，属于 select 调用的增强版本，优化了 IO 的执行效率。</li>\n</ul>\n</blockquote>\n<p>IO 多路复用模型，<strong><font color='red'>通过减少无效的系统调用，减少了对 CPU 资源的消耗</font></strong>。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/88ff862764024c3b8567367df11df6ab%7Etplv-k3u1fbpfcp-watermark.png\" alt=\"img\" /></p>\n<hr />\n<h5 id=\"nio-三大组件\"><a class=\"anchor\" href=\"#nio-三大组件\">#</a> NIO 三大组件</h5>\n<p>NIO 主要包括以下三个核心组件：</p>\n<ul>\n<li><strong>Buffer（缓冲区）</strong>：NIO 读写数据都是通过缓冲区进行操作的。读操作的时候将 Channel 中的数据填充到 Buffer 中，而写操作时将 Buffer 中的数据写入到 Channel 中。</li>\n<li><strong>Channel（通道）</strong>：Channel 是一个双向的、可读可写的数据传输通道，NIO 通过 Channel 来实现数据的输入输出。通道是一个抽象的概念，它可以代表文件、套接字或者其他数据源之间的连接。</li>\n<li><strong>Selector（选择器）</strong>：也被称为<font color='red'>多路复用器</font>，<font color='red'>允许一个线程处理多个 Channel</font>。所有的 Channel 都可以注册到 Selector 上，由 Selector 来分配线程来处理事件。</li>\n</ul>\n<p>三者的关系如下图所示（暂时不理解没关系，后文会详细介绍）：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/channel-buffer-selector.png\" alt=\"Buffer、Channel和Selector三者之间的关系\" /></p>\n<center>（Buffer、Channel和Selector三者之间的关系）</center>\n<h6 id=\"buffer缓冲区\"><a class=\"anchor\" href=\"#buffer缓冲区\">#</a> Buffer（缓冲区）</h6>\n<p>在传统的 BIO 中，数据的读写是面向流的， 分为字节流和字符流。</p>\n<p>在 Java 1.4 的 **<font color='red'> NIO 库中，所有数据都是用缓冲区处理的</font>**，这是新库和之前的 BIO 的一个重要区别，有点类似于 BIO 中的缓冲流。</p>\n<ul>\n<li>NIO 在读取数据时，它是直接读取缓冲区中的</li>\n<li>在写入数据时，是写入到缓冲区中</li>\n</ul>\n<p><code>Buffer</code>  的子类如下图所示，其中最常用的是  <code>ByteBuffer</code> ，它可以用来存储和操作字节数据。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/buffer-subclasses.png\" alt=\"Buffer 的子类\" /></p>\n<center>（Buffer的子类）</center>\n<p>可以将 Buffer <font color='red'>理解为数组</font>， <code>IntBuffer</code> 、 <code>FloatBuffer</code> 、 <code>CharBuffer</code>  等分别对应  <code>int[]</code> 、 <code>float[]</code> 、 <code>char[]</code>  等。</p>\n<hr />\n<p>为了更清晰地认识缓冲区，我们来简单看看  <code>Buffer</code>  类中定义的<font color='gree'>四个成员变量</font>：</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">abstract</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Buffer</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">private</span> <span class=\"token keyword\">int</span> mark <span class=\"token operator\">=</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">private</span> <span class=\"token keyword\">int</span> position <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token keyword\">private</span> <span class=\"token keyword\">int</span> limit<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token keyword\">private</span> <span class=\"token keyword\">int</span> capacity<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>这四个成员变量满足如下的关系：<font color='red'>0 &lt;= mark &lt;= position &lt;= limit &lt;= capacity</font>，具体含义如下：</p>\n<ol>\n<li><font color='cornflowerblue'>容量（ <code>capacity</code> ）</font>： <code>Buffer</code>  可以存储的<font color='red'>最大数据量</font>， <code>Buffer</code>  创建时设置且<font color='red'>不可改变</font>。</li>\n<li><font color='cornflowerblue'>界限（ <code>limit</code> ）</font>： <code>Buffer</code>  中可以<font color='red'>读 / 写数据的边界</font>。\n<ul>\n<li><font color='red'>写模式下，表示最多能写入的数据</font>，一般等于  <code>capacity</code> ；</li>\n<li><font color='red'>读模式下，表示 Buffer 中实际写入的数据大小</font>；</li>\n</ul>\n</li>\n<li><font color='cornflowerblue'>位置（ <code>position</code> ）</font>：<font color='red'>下一个可以被读写的数据的索引</font>。从写操作模式到读操作模式切换的时候（flip）， <code>position</code>  都会归零，这样就可以<font color='red'>从头开始读写</font>了。</li>\n<li><font color='cornflowerblue'>标记（ <code>mark</code> ）</font>： <code>Buffer</code>  <font color='red'>允许将位置直接定位到该标记处</font>，这是一个可选属性；</li>\n</ol>\n<p>另外，Buffer 有<font color='gree'>读模式和写模式</font>这两种模式，分别用于从 Buffer 中读取数据或者向 Buffer 中写入数据。</p>\n<ul>\n<li>Buffer 被创建之后<font color='red'>默认是写模式，调用  <code>flip()</code>  可以切换到读模式</font></li>\n<li><font color='red'>通过调用  <code>clear()</code>  或者  <code>compact()</code>  方法可以再次切换回写模式</font></li>\n</ul>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/JavaNIOBuffer.png\" alt=\"position 、limit 和 capacity 之前的关系\" /></p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/NIOBufferClassAttributes.png\" alt=\"position 、limit 和 capacity 之前的关系\" /></p>\n<hr />\n<p><code>Buffer</code>  对象不能通过  <code>new</code>  调用构造方法创建对象，<strong><font color='gree'>只能通过静态方法实例化  <code>Buffer</code> </font></strong>。</p>\n<p>以  <code>ByteBuffer</code>  为例进行介绍：</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">// 分配堆内存</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token class-name\">ByteBuffer</span> <span class=\"token function\">allocate</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> capacity<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> </pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token comment\">// 分配直接内存</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token class-name\">ByteBuffer</span> <span class=\"token function\">allocateDirect</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> capacity<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>Buffer <font color='gree'>最核心的两个方法</font>：</p>\n<ol>\n<li><code>get()</code>  : 读取缓冲区的数据</li>\n<li><code>put()</code>  ：向缓冲区写入数据</li>\n</ol>\n<p>除上述两个方法之外，其他的重要方法：</p>\n<ul>\n<li><code>flip()</code>  ：将缓冲区从写模式<font color='red'>切换到读模式</font>，将  <code>limit</code>  的值设置为当前  <code>position</code>  的值，将  <code>position</code>  的值设置为 0。</li>\n<li><code>clear()</code> : <font color='red'>清空缓冲区</font>，将缓冲区从读模式<font color='red'>切换到写模式</font>，并将  <code>position</code>  的值设置为 0，将  <code>limit</code>  的值设置为  <code>capacity</code>  的值。</li>\n<li>……</li>\n</ul>\n<hr />\n<p>Buffer 中<font color='gree'>数据变化的过程</font>：</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">java<span class=\"token punctuation\">.</span>nio<span class=\"token punctuation\">.</span></span><span class=\"token operator\">*</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">CharBufferDemo</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>        <span class=\"token comment\">// 分配一个容量为 8 的 CharBuffer</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>        <span class=\"token class-name\">CharBuffer</span> buffer <span class=\"token operator\">=</span> <span class=\"token class-name\">CharBuffer</span><span class=\"token punctuation\">.</span><span class=\"token function\">allocate</span><span class=\"token punctuation\">(</span><span class=\"token number\">8</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"初始状态：\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> </pre></td></tr><tr><td data-num=\"8\"></td><td><pre>        <span class=\"token function\">printState</span><span class=\"token punctuation\">(</span>buffer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> </pre></td></tr><tr><td data-num=\"9\"></td><td><pre></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>        <span class=\"token comment\">// 向 buffer 写入 3 个字符</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>        buffer<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span><span class=\"token char\">'a'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span><span class=\"token char\">'b'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span><span class=\"token char\">'c'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"写入3个字符后的状态：\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>        <span class=\"token function\">printState</span><span class=\"token punctuation\">(</span>buffer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>        <span class=\"token comment\">// 调用 flip () 方法，准备读取 buffer 中的数据，将 position 置 0,limit 的置 3</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>        buffer<span class=\"token punctuation\">.</span><span class=\"token function\">flip</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"调用flip()方法后的状态：\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>        <span class=\"token function\">printState</span><span class=\"token punctuation\">(</span>buffer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>        <span class=\"token comment\">// 读取字符</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>        <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>buffer<span class=\"token punctuation\">.</span><span class=\"token function\">hasRemaining</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span> </pre></td></tr><tr><td data-num=\"22\"></td><td><pre>            <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">print</span><span class=\"token punctuation\">(</span>buffer<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>        <span class=\"token comment\">// 调用 clear () 方法，清空缓冲区，将 position 的值置为 0，将 limit 的值置为 capacity 的值</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>        buffer<span class=\"token punctuation\">.</span><span class=\"token function\">clear</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"调用clear()方法后的状态：\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>        <span class=\"token function\">printState</span><span class=\"token punctuation\">(</span>buffer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre></pre></td></tr><tr><td data-num=\"32\"></td><td><pre>    <span class=\"token comment\">// 打印 buffer 的 capacity、limit、position、mark 的位置</span></pre></td></tr><tr><td data-num=\"33\"></td><td><pre>    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">printState</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">CharBuffer</span> buffer<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"34\"></td><td><pre>        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"capacity: \"</span> <span class=\"token operator\">+</span> buffer<span class=\"token punctuation\">.</span><span class=\"token function\">capacity</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"35\"></td><td><pre>        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">\", limit: \"</span> <span class=\"token operator\">+</span> buffer<span class=\"token punctuation\">.</span><span class=\"token function\">limit</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"36\"></td><td><pre>        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">\", position: \"</span> <span class=\"token operator\">+</span> buffer<span class=\"token punctuation\">.</span><span class=\"token function\">position</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"37\"></td><td><pre>        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">\", mark 开始读取的字符: \"</span> <span class=\"token operator\">+</span> buffer<span class=\"token punctuation\">.</span><span class=\"token function\">mark</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"38\"></td><td><pre>        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"39\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"40\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>输出：</p>\n<figure class=\"highlight sh\"><figcaption data-lang=\"sh\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>初始状态：</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>capacity: <span class=\"token number\">8</span>, limit: <span class=\"token number\">8</span>, position: <span class=\"token number\">0</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>写入3个字符后的状态：</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>capacity: <span class=\"token number\">8</span>, limit: <span class=\"token number\">8</span>, position: <span class=\"token number\">3</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>准备读取buffer中的数据！</pre></td></tr><tr><td data-num=\"8\"></td><td><pre></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>调用flip<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>方法后的状态：</pre></td></tr><tr><td data-num=\"10\"></td><td><pre>capacity: <span class=\"token number\">8</span>, limit: <span class=\"token number\">3</span>, position: <span class=\"token number\">0</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>读取到的数据：abc</pre></td></tr><tr><td data-num=\"13\"></td><td><pre></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>调用clear<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>方法后的状态：</pre></td></tr><tr><td data-num=\"15\"></td><td><pre>capacity: <span class=\"token number\">8</span>, limit: <span class=\"token number\">8</span>, position: <span class=\"token number\">0</span></pre></td></tr></table></figure><p>为了帮助理解，我绘制了一张图片展示  <code>capacity</code> 、 <code>limit</code>  和 <code>position</code>  每一阶段的变化。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/NIOBufferClassAttributesDataChanges.png\" alt=\"capacity、limit和position每一阶段的变化\" /></p>\n<h6 id=\"channel通道\"><a class=\"anchor\" href=\"#channel通道\">#</a> Channel（通道）</h6>\n<p>Channel 是一个通道，它建立了与数据源（如文件、网络套接字等）之间的连接。我们可以<font color='red'>用它来读取和写入数据</font>，就像打开了一条自来水管，让数据在 Channel 中自由流动。</p>\n<p>BIO 中的流是单向的，分为各种  <code>InputStream</code> （输入流）和  <code>OutputStream</code> （输出流），数据只是在一个方向上传输。通道与流的不同之处在于通道<font color='red'>是双向的</font>，它可以用于读、写或者同时用于读写。</p>\n<p>Channel 与前面介绍的 Buffer 打交道，读操作的时候将 Channel 中的数据填充到 Buffer 中，而写操作时将 Buffer 中的数据写入到 Channel 中。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/channel-buffer.png\" alt=\"Channel 和 Buffer之间的关系\" /></p>\n<center>（Channel 和 Buffer之间的关系）</center>\n<p>另外，因为 Channel 是<font color='red'>全双工</font>的，所以它可以比流更好地映射底层操作系统的 API。特别是在 UNIX 网络编程模型中，底层操作系统的通道都是全双工的，同时支持读写操作。</p>\n<hr />\n<p><code>Channel</code>  的<font color='gree'>子类</font>如下图所示。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/channel-subclasses.png\" alt=\"Channel 的子类\" /></p>\n<p>其中，最常用的是以下几种类型的通道：</p>\n<ul>\n<li><code>FileChannel</code> ：文件访问通道；</li>\n<li><code>SocketChannel</code> 、 <code>ServerSocketChannel</code> ：TCP 通信通道；</li>\n<li><code>DatagramChannel</code> ：UDP 通信通道；</li>\n</ul>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/channel-inheritance-relationship.png\" alt=\"Channel继承关系图\" /></p>\n<center>（Channel继承关系图）</center>\n<hr />\n<p>Channel <font color='gree'>最核心的两个方法</font>：</p>\n<ol>\n<li><code>read（）</code>  ：<font color='red'>读取数据并写入到 Buffer 中</font>。</li>\n<li><code>write（）</code>  ：<font color='red'>将 Buffer 中的数据写入到 Channel 中</font>。</li>\n</ol>\n<p>这里我们以  <code>FileChannel</code>  为例演示一下是读取文件数据的。</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token class-name\">RandomAccessFile</span> reader <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">RandomAccessFile</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"/Users/guide/Documents/test_read.in\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"r\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> </pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token class-name\">FileChannel</span> channel <span class=\"token operator\">=</span> reader<span class=\"token punctuation\">.</span><span class=\"token function\">getChannel</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token class-name\">ByteBuffer</span> buffer <span class=\"token operator\">=</span> <span class=\"token class-name\">ByteBuffer</span><span class=\"token punctuation\">.</span><span class=\"token function\">allocate</span><span class=\"token punctuation\">(</span><span class=\"token number\">1024</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>channel<span class=\"token punctuation\">.</span><span class=\"token function\">read</span><span class=\"token punctuation\">(</span>buffer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h6 id=\"selector选择器\"><a class=\"anchor\" href=\"#selector选择器\">#</a> Selector（选择器）</h6>\n<p>Selector 是 NIO 中的一个关键组件，是<strong>基于事件驱动的 I/O 多路复用模型</strong>，它<font color='red'>允许一个线程处理多个 Channel</font>。其主要<font color='gree'>运作原理</font>是：</p>\n<ul>\n<li>将 Channel 的事件<font color='red'>注册</font>在 Selector 上</li>\n<li>Selector 会<font color='red'>轮询</font>注册在它上的 Channel。当某个 Channel 的事件发生时，该 Channel 就处于就绪状态，会被 Selector 轮询出来，并将相关的 Channel <font color='red'>加入就绪集合中</font>。</li>\n<li>通过 <font color='red'>SelectionKey</font> 集合可以获取就绪 Channel 的集合（<font color='red'>一个 SelectionKey 对应一个 Channel</font>），然后对这些就绪的 Channel 进行<font color='red'>响应的 I/O 操作</font>。</li>\n</ul>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/selector-channel-selectionkey.png\" alt=\"Selector 选择器工作示意图\" /></p>\n<center>（Selector 选择器工作示意图）</center>\n<p>一个多路复用器 Selector 可以同时轮询多个 Channel，由于 JDK 使用了  <code>epoll()</code>  代替传统的  <code>select()</code>  实现，所以它并没有最大连接句柄  <code>1024/2048</code>  的限制。这也就意味着<strong>只需要一个线程负责 Selector 的轮询，就可以接入成千上万的客户端</strong>。</p>\n<hr />\n<p>Selector 可以<font color='gree'>监听四种事件类型</font>：</p>\n<ol>\n<li><code>SelectionKey.OP_ACCEPT</code> ：表示<font color='red'>通道接受连接</font>的事件，这通常用于  <code>ServerSocketChannel</code> 。</li>\n<li><code>SelectionKey.OP_CONNECT</code> ：表示<font color='red'>通道完成连接</font>的事件，这通常用于  <code>SocketChannel</code> 。</li>\n<li><code>SelectionKey.OP_READ</code> ：表示<font color='red'>通道准备好进行读取</font>的事件，即有数据可读。</li>\n<li><code>SelectionKey.OP_WRITE</code> ：表示<font color='red'>通道准备好进行写入</font>的事件，即可以写入数据。</li>\n</ol>\n<hr />\n<p><code>Selector</code>  是抽象类，可以<strong>通过调用此类的静态方法  <code>open()</code>  来创建 Selector 实例</strong>。Selector 可以同时监控多个  <code>SelectableChannel</code>  的  <code>IO</code>  状况，是非阻塞  <code>IO</code>  的核心。</p>\n<p>一个 Selector 实例<font color='gree'>有三种  <code>SelectionKey</code>  集合</font>：</p>\n<ol>\n<li><font color='red'>所有的</font>  <code>SelectionKey</code>  集合：代表了注册在该 Selector 上的  <code>Channel</code> ，这个集合可以通过  <code>keys()</code>  方法返回。</li>\n<li><font color='red'>被选择的</font>  <code>SelectionKey</code>  集合：代表了所有可通过  <code>select()</code>  方法获取的、需要进行  <code>IO</code>  处理的 Channel，这个集合可以通过  <code>selectedKeys()</code>  返回。</li>\n<li><font color='red'>被取消的</font>  <code>SelectionKey</code>  集合：代表了所有被取消注册关系的  <code>Channel</code> ，在下一次执行  <code>select()</code>  方法时，这些  <code>Channel</code>  对应的  <code>SelectionKey</code>  会被彻底删除，程序通常无须直接访问该集合，也没有暴露访问的方法。</li>\n</ol>\n<p>简单演示一下如何<font color='gree'>遍历被选择的  <code>SelectionKey</code>  集合</font>并进行处理：</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token class-name\">Set</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">SelectionKey</span><span class=\"token punctuation\">></span></span> selectedKeys <span class=\"token operator\">=</span> selector<span class=\"token punctuation\">.</span><span class=\"token function\">selectedKeys</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token class-name\">Iterator</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">SelectionKey</span><span class=\"token punctuation\">></span></span> keyIterator <span class=\"token operator\">=</span> selectedKeys<span class=\"token punctuation\">.</span><span class=\"token function\">iterator</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>keyIterator<span class=\"token punctuation\">.</span><span class=\"token function\">hasNext</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token class-name\">SelectionKey</span> key <span class=\"token operator\">=</span> keyIterator<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>key <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">.</span><span class=\"token function\">isAcceptable</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>            <span class=\"token comment\">// ServerSocketChannel 接收了一个新连接</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">.</span><span class=\"token function\">isConnectable</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>            <span class=\"token comment\">// 表示一个新连接建立</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">.</span><span class=\"token function\">isReadable</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>            <span class=\"token comment\">// Channel 有准备好的数据，可以读取</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">.</span><span class=\"token function\">isWritable</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>            <span class=\"token comment\">// Channel 有空闲的 Buffer，可以写入数据</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>    keyIterator<span class=\"token punctuation\">.</span><span class=\"token function\">remove</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><hr />\n<p>Selector 还提供了一系列<font color='gree'>和  <code>select()</code>  相关的方法</font>：</p>\n<ul>\n<li><strong> <code>int select()</code> </strong>：<font color='red'>阻塞线程</font>，监控所有注册的  <code>Channel</code>  中是否有<font color='red'>需要进行  <code>IO</code>  处理</font>的。如果有，该方法会将对应的  <code>SelectionKey</code>  加入到被选择的  <code>SelectionKey</code>  集合中，并<strong>返回这些  <code>Channel</code>  的数量</strong>。</li>\n<li><code>int select(long timeout)</code> ：可以设置超时时长的  <code>select()</code>  操作。</li>\n<li><code>int selectNow()</code> ：执行一个立即返回的  <code>select()</code>  操作，相对于无参数的  <code>select()</code>  方法而言，该方法<font color='red'>不会阻塞线程</font>。</li>\n<li><code>Selector wakeup()</code> ：使一个还未返回的  <code>select()</code>  方法立刻返回。</li>\n<li>……</li>\n</ul>\n<p>使用 Selector 实现网络读写的简单示例：</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">java<span class=\"token punctuation\">.</span>io<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">IOException</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">java<span class=\"token punctuation\">.</span>net<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">InetSocketAddress</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">java<span class=\"token punctuation\">.</span>nio<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">ByteBuffer</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">java<span class=\"token punctuation\">.</span>nio<span class=\"token punctuation\">.</span>channels<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">SelectionKey</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">java<span class=\"token punctuation\">.</span>nio<span class=\"token punctuation\">.</span>channels<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">Selector</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">java<span class=\"token punctuation\">.</span>nio<span class=\"token punctuation\">.</span>channels<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">ServerSocketChannel</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">java<span class=\"token punctuation\">.</span>nio<span class=\"token punctuation\">.</span>channels<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">SocketChannel</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">java<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">Iterator</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">java<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">Set</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">NioSelectorExample</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>  <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    <span class=\"token keyword\">try</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>      <span class=\"token comment\">// 实例化一个用于处理连接事件的 Channel ：ServerSocketChannel</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>      <span class=\"token class-name\">ServerSocketChannel</span> serverSocketChannel <span class=\"token operator\">=</span> <span class=\"token class-name\">ServerSocketChannel</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">open</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>      serverSocketChannel<span class=\"token punctuation\">.</span><span class=\"token function\">configureBlocking</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>      serverSocketChannel<span class=\"token punctuation\">.</span><span class=\"token function\">socket</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">bind</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">InetSocketAddress</span><span class=\"token punctuation\">(</span><span class=\"token number\">8080</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 设置 Channel 去监听 8080 端口</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>      <span class=\"token comment\">// 实例化一个 Selector 对象</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>      <span class=\"token class-name\">Selector</span> selector <span class=\"token operator\">=</span> <span class=\"token class-name\">Selector</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">open</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>      <span class=\"token comment\">// 将 ServerSocketChannel 注册到 Selector 并监听 OP_ACCEPT 事件（通道接受连接）</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>      serverSocketChannel<span class=\"token punctuation\">.</span><span class=\"token function\">register</span><span class=\"token punctuation\">(</span>selector<span class=\"token punctuation\">,</span> <span class=\"token class-name\">SelectionKey</span><span class=\"token punctuation\">.</span><span class=\"token constant\">OP_ACCEPT</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>      <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token comment\">// 轮询</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>        <span class=\"token keyword\">int</span> readyChannels <span class=\"token operator\">=</span> selector<span class=\"token punctuation\">.</span><span class=\"token function\">select</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 一直阻塞，直到 Selector 上存在需要进行 IO 处理的 Channel ，立即返回这些 Channel 的数量</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>readyChannels <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>          <span class=\"token keyword\">continue</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 此时 Selector 上没有需要进行 IO 处理的 Channel，继续轮询</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre></pre></td></tr><tr><td data-num=\"32\"></td><td><pre>        <span class=\"token comment\">// 此时 Selector 上有需要进行 IO 处理的 Channel</span></pre></td></tr><tr><td data-num=\"33\"></td><td><pre>        <span class=\"token class-name\">Set</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">SelectionKey</span><span class=\"token punctuation\">></span></span> selectedKeys <span class=\"token operator\">=</span> selector<span class=\"token punctuation\">.</span><span class=\"token function\">selectedKeys</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 获取 SelectionKey 集合，借此可获取就绪的 Channel 集合，从而得以处理它们的 IO 操作</span></pre></td></tr><tr><td data-num=\"34\"></td><td><pre>        <span class=\"token class-name\">Iterator</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">SelectionKey</span><span class=\"token punctuation\">></span></span> keyIterator <span class=\"token operator\">=</span> selectedKeys<span class=\"token punctuation\">.</span><span class=\"token function\">iterator</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 获取 SelectionKey 的迭代器</span></pre></td></tr><tr><td data-num=\"35\"></td><td><pre></pre></td></tr><tr><td data-num=\"36\"></td><td><pre>        <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>keyIterator<span class=\"token punctuation\">.</span><span class=\"token function\">hasNext</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token comment\">// 遍历 SelectionKey</span></pre></td></tr><tr><td data-num=\"37\"></td><td><pre>          <span class=\"token class-name\">SelectionKey</span> key <span class=\"token operator\">=</span> keyIterator<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"38\"></td><td><pre></pre></td></tr><tr><td data-num=\"39\"></td><td><pre>          <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">.</span><span class=\"token function\">isAcceptable</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"40\"></td><td><pre>            <span class=\"token comment\">// 处理连接事件：ServerSocketChannel</span></pre></td></tr><tr><td data-num=\"41\"></td><td><pre>            <span class=\"token class-name\">ServerSocketChannel</span> server <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">ServerSocketChannel</span><span class=\"token punctuation\">)</span> key<span class=\"token punctuation\">.</span><span class=\"token function\">channel</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 获取当前 SelectionKey 对应的 Channel</span></pre></td></tr><tr><td data-num=\"42\"></td><td><pre>            <span class=\"token comment\">// 完成连接，返回一个 SocketChannel 对象</span></pre></td></tr><tr><td data-num=\"43\"></td><td><pre>            <span class=\"token class-name\">SocketChannel</span> client <span class=\"token operator\">=</span> server<span class=\"token punctuation\">.</span><span class=\"token function\">accept</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> </pre></td></tr><tr><td data-num=\"44\"></td><td><pre>            client<span class=\"token punctuation\">.</span><span class=\"token function\">configureBlocking</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"45\"></td><td><pre></pre></td></tr><tr><td data-num=\"46\"></td><td><pre>            <span class=\"token comment\">// 将 SocketChannel 对象注册到 Selector 并监听 OP_READ 事件</span></pre></td></tr><tr><td data-num=\"47\"></td><td><pre>            client<span class=\"token punctuation\">.</span><span class=\"token function\">register</span><span class=\"token punctuation\">(</span>selector<span class=\"token punctuation\">,</span> <span class=\"token class-name\">SelectionKey</span><span class=\"token punctuation\">.</span><span class=\"token constant\">OP_READ</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"48\"></td><td><pre>          <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">.</span><span class=\"token function\">isReadable</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"49\"></td><td><pre>            <span class=\"token comment\">// 处理读事件：SocketChannel</span></pre></td></tr><tr><td data-num=\"50\"></td><td><pre>            <span class=\"token class-name\">SocketChannel</span> client <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">SocketChannel</span><span class=\"token punctuation\">)</span> key<span class=\"token punctuation\">.</span><span class=\"token function\">channel</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 获取当前 SelectionKey 对应的 Channel</span></pre></td></tr><tr><td data-num=\"51\"></td><td><pre>            <span class=\"token class-name\">ByteBuffer</span> buffer <span class=\"token operator\">=</span> <span class=\"token class-name\">ByteBuffer</span><span class=\"token punctuation\">.</span><span class=\"token function\">allocate</span><span class=\"token punctuation\">(</span><span class=\"token number\">1024</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 新建 Buffer 帮助读取数据</span></pre></td></tr><tr><td data-num=\"52\"></td><td><pre>            <span class=\"token keyword\">int</span> bytesRead <span class=\"token operator\">=</span> client<span class=\"token punctuation\">.</span><span class=\"token function\">read</span><span class=\"token punctuation\">(</span>buffer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 通过 Channel 读取 Buffer 中的数据</span></pre></td></tr><tr><td data-num=\"53\"></td><td><pre></pre></td></tr><tr><td data-num=\"54\"></td><td><pre>            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>bytesRead <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"55\"></td><td><pre>              buffer<span class=\"token punctuation\">.</span><span class=\"token function\">flip</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 将 Buffer 切换为读模式（position 置为 0，limit 置为当前 Buffer 中的数据大小）</span></pre></td></tr><tr><td data-num=\"56\"></td><td><pre>              <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"收到数据：\"</span> <span class=\"token operator\">+</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">(</span>buffer<span class=\"token punctuation\">.</span><span class=\"token function\">array</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> bytesRead<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"57\"></td><td><pre>              <span class=\"token comment\">// 将 SocketChannel 注册到 Selector 并监听 OP_WRITE 事件</span></pre></td></tr><tr><td data-num=\"58\"></td><td><pre>              client<span class=\"token punctuation\">.</span><span class=\"token function\">register</span><span class=\"token punctuation\">(</span>selector<span class=\"token punctuation\">,</span> <span class=\"token class-name\">SelectionKey</span><span class=\"token punctuation\">.</span><span class=\"token constant\">OP_WRITE</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"59\"></td><td><pre>            <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>bytesRead <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"60\"></td><td><pre>              <span class=\"token comment\">// 客户端断开连接</span></pre></td></tr><tr><td data-num=\"61\"></td><td><pre>              client<span class=\"token punctuation\">.</span><span class=\"token function\">close</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"62\"></td><td><pre>            <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"63\"></td><td><pre>          <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">.</span><span class=\"token function\">isWritable</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"64\"></td><td><pre>            <span class=\"token comment\">// 处理写事件：SocketChannel</span></pre></td></tr><tr><td data-num=\"65\"></td><td><pre>            <span class=\"token class-name\">SocketChannel</span> client <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">SocketChannel</span><span class=\"token punctuation\">)</span> key<span class=\"token punctuation\">.</span><span class=\"token function\">channel</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"66\"></td><td><pre>            <span class=\"token class-name\">ByteBuffer</span> buffer <span class=\"token operator\">=</span> <span class=\"token class-name\">ByteBuffer</span><span class=\"token punctuation\">.</span><span class=\"token function\">wrap</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Hello, Client!\"</span><span class=\"token punctuation\">.</span><span class=\"token function\">getBytes</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"67\"></td><td><pre>            client<span class=\"token punctuation\">.</span><span class=\"token function\">write</span><span class=\"token punctuation\">(</span>buffer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 通过 Channel 将数据写入 Buffer 中</span></pre></td></tr><tr><td data-num=\"68\"></td><td><pre></pre></td></tr><tr><td data-num=\"69\"></td><td><pre>            <span class=\"token comment\">// 将 SocketChannel 注册到 Selector 并监听 OP_READ 事件</span></pre></td></tr><tr><td data-num=\"70\"></td><td><pre>            client<span class=\"token punctuation\">.</span><span class=\"token function\">register</span><span class=\"token punctuation\">(</span>selector<span class=\"token punctuation\">,</span> <span class=\"token class-name\">SelectionKey</span><span class=\"token punctuation\">.</span><span class=\"token constant\">OP_READ</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"71\"></td><td><pre>          <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"72\"></td><td><pre></pre></td></tr><tr><td data-num=\"73\"></td><td><pre>          keyIterator<span class=\"token punctuation\">.</span><span class=\"token function\">remove</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 移除当前已处理完毕的 SelectionKey ，准备遍历下一个 SelectionKey </span></pre></td></tr><tr><td data-num=\"74\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"75\"></td><td><pre>        <span class=\"token comment\">// 当前 select () 处理完毕，进入下一次轮询</span></pre></td></tr><tr><td data-num=\"76\"></td><td><pre>      <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"77\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">IOException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"78\"></td><td><pre>      e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"79\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"80\"></td><td><pre>  <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"81\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>在示例中，我们创建了一个简单的服务器，监听 8080 端口，使用 Selector 处理连接、读取和写入事件。当接收到客户端的数据时，服务器将读取数据并将其打印到控制台，然后向客户端回复 &quot;Hello, Client!&quot;。</p>\n<h5 id=\"nio-零拷贝\"><a class=\"anchor\" href=\"#nio-零拷贝\">#</a> NIO 零拷贝</h5>\n<p>零拷贝是<font color='red'>提升 IO 操作性能</font>的一个常用手段，像 ActiveMQ、Kafka 、RocketMQ、QMQ、Netty 等顶级开源项目都用到了零拷贝。</p>\n<p>零拷贝是指<strong>计算机执行 IO 操作时，CPU 不需要将数据从一个存储区域复制到另一个存储区域，从而可以减少 CPU 拷贝、上下文切换的时间</strong>。也就是说，零拷贝主主要解决操作系统在处理 I/O 操作时<font color='red'>频繁复制数据的问题</font>。零拷贝的常见实现技术有：  <code>mmap+write</code> 、 <code>sendfile</code>  和  <code>sendfile + DMA gather copy</code>  。</p>\n<p>下图展示了各种零拷贝技术的对比图：</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>CPU 拷贝</th>\n<th>DMA 拷贝</th>\n<th>上下文切换</th>\n<th>系统调用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>传统方法 (read + write)</td>\n<td>2</td>\n<td>2</td>\n<td>4</td>\n<td>read+write</td>\n</tr>\n<tr>\n<td>mmap + write</td>\n<td>1</td>\n<td>2</td>\n<td>4</td>\n<td>mmap+write</td>\n</tr>\n<tr>\n<td>sendfile</td>\n<td>1</td>\n<td>2</td>\n<td>2</td>\n<td>sendfile</td>\n</tr>\n<tr>\n<td>sendfile + DMA gather copy</td>\n<td>0</td>\n<td>2</td>\n<td>2</td>\n<td>sendfile</td>\n</tr>\n</tbody>\n</table>\n<p>可以看出，无论是传统的 I/O 方式，还是引入了零拷贝之后，<font color='red'>2 次 DMA（Direct Memory Access）拷贝是都少不了的</font>。因为两次 DMA 都是依赖硬件完成的。零拷贝主要是减少了 CPU 拷贝及上下文的切换。</p>\n<p>Java 对零拷贝的支持：</p>\n<ul>\n<li>\n<p><code>MappedByteBuffer</code> ：是 NIO 基于 ** 内存映射（ <code>mmap</code> ）** 这种零拷⻉⽅式的提供的⼀种实现，底层实际是调用了 Linux 内核的  <code>mmap</code>  系统调用。它可以将一个文件或者文件的一部分映射到内存中，形成一个虚拟内存文件，这样就可以<font color='red'>直接操作内存中的数据</font>，而不需要通过系统调用来读写文件。</p>\n</li>\n<li>\n<p><code>FileChannel</code> ：其  <code>transferTo()/transferFrom()</code>  是 NIO 基于 ** 发送文件（ <code>sendfile</code> ）** 这种零拷贝方式的提供的一种实现，底层实际是调用了 Linux 内核的  <code>sendfile</code>  系统调用。它可以<font color='red'>直接将文件数据从磁盘发送到网络，而不需要经过用户空间的缓冲区</font>。</p>\n<blockquote>\n<p>关于 <code>FileChannel</code>  的用法可以看看这篇文章：<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vcm9ib3RoeS9wLzE0MjM1NTk4Lmh0bWw=\">Java NIO 文件通道 FileChannel 用法</span>。</p>\n</blockquote>\n</li>\n</ul>\n<p>代码示例：</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">private</span> <span class=\"token keyword\">void</span> <span class=\"token function\">loadFileIntoMemory</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">File</span> xmlFile<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">IOException</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>  <span class=\"token class-name\">FileInputStream</span> fis <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">FileInputStream</span><span class=\"token punctuation\">(</span>xmlFile<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>  <span class=\"token comment\">// 创建 FileChannel 对象</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>  <span class=\"token class-name\">FileChannel</span> fc <span class=\"token operator\">=</span> fis<span class=\"token punctuation\">.</span><span class=\"token function\">getChannel</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>  <span class=\"token comment\">// FileChannle.map () 将文件映射到直接内存并返回 MappedByteBuffer 对象</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>  <span class=\"token class-name\">MappedByteBuffer</span> mmb <span class=\"token operator\">=</span> fc<span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">FileChannel<span class=\"token punctuation\">.</span>MapMode</span><span class=\"token punctuation\">.</span><span class=\"token constant\">READ_ONLY</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> fc<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>  xmlFileBuffer <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token keyword\">byte</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span>fc<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>  mmb<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>xmlFileBuffer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>  fis<span class=\"token punctuation\">.</span><span class=\"token function\">close</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h5 id=\"小结\"><a class=\"anchor\" href=\"#小结\">#</a> 小结</h5>\n<p>这篇文章我们主要介绍了 NIO 的核心组件、零拷贝。</p>\n<p>如果我们需要使用 NIO 构建网络程序的话，<font color='red'>不建议直接使用原生 NIO</font>，编程复杂且功能性太弱，推荐使用一些成熟的<strong>基于 NIO 的网络编程框架比如 Netty</strong> 。Netty 在 NIO 的基础上进行了一些优化和扩展，比如支持多种协议、支持 SSL/TLS 等等。</p>\n<h4 id=\"aioasynchronous\"><a class=\"anchor\" href=\"#aioasynchronous\">#</a> AIO（Asynchronous）</h4>\n<p>Java 7 中引入了 NIO 的改进版 AIO（即 NIO 2），它是<strong>异步 IO 模型</strong>。基于事件和<font color='red'>回调机制</font>实现的，也就是<font color='red'>应用操作之后会直接返回</font>，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。</p>\n<p>目前来说 AIO 的<font color='red'>应用还不是很广泛</font>。Netty 之前也尝试使用过 AIO，不过又放弃了。这是因为，Netty 使用了 AIO 之后，在 Linux 系统上的性能并没有多少提升。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/3077e72a1af049559e81d18205b56fd7%7Etplv-k3u1fbpfcp-watermark.png\" alt=\"img\" /></p>\n<h4 id=\"小结-2\"><a class=\"anchor\" href=\"#小结-2\">#</a> 小结</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/bio-aio-nio.png\" alt=\"BIO、NIO 和 AIO 对比\" /></p>\n<center>（BIO、NIO 和 AIO 对比）</center>\n<h3 id=\"面试题nio-是如何实现同步非阻塞的主线程是只有一个吗\"><a class=\"anchor\" href=\"#面试题nio-是如何实现同步非阻塞的主线程是只有一个吗\">#</a> 【面试题】NIO 是如何实现同步非阻塞的？主线程是只有一个吗？</h3>\n<p>NIO 底层是用  <code>Selector</code>  、  <code>Channel</code>  和  <code>Buffer</code>  来实现的。主线程在循环调用  <code>select()</code>  方法进行阻塞等待，当有 acceptable 、 readable 或者 writable 事件发生的时候，循环就会往下走，将对应的事件交给对应的事件处理器进行处理。</p>\n<p>它可以多线程的，可以有多个 accept () 线程和多个 worker 线程。</p>\n<blockquote>\n<p>补充：</p>\n<p>在 NIO 中，使用了多路复用器 Selector 来实现同步非阻塞的 IO 操作。 Selector 可以监控多个 Channel 是否需要 IO 处理，当一个或多个 Channel 准备好读或写时，Selector 会通知程序进行读写操作，而不像 BIO 一样阻塞等待 IO 操作完成。</p>\n<p>在 NIO 中，主线程通常只有一个，但是可以使用 Selector 来管理多个 Channel，实现多个连接的非阻塞读写操作。当有多个 Channel 需要进行 IO 操作时，Selector 会轮询这些 Channel，检查它们的状态是否可读或可写。如果有可读或可写的 Channel，就将其加入到一个已选择键集合中，等待程序处理。这样，一个线程就可以同时处理多个 Channel，提高了系统的并发处理能力。</p>\n</blockquote>\n<h3 id=\"面试题bionioaio的区别\"><a class=\"anchor\" href=\"#面试题bionioaio的区别\">#</a> 【面试题】BIO/NIO/AIO 的区别？</h3>\n<p><strong>BIO（同步阻塞 IO）</strong>：在进行 IO 操作时，<font color='red'>必须等待 IO 操作完成</font>后才能进行下一步操作，这时线程会被<font color='red'>阻塞</font>。适用于连接数比较小且固定的架构，由于线程阻塞等待 IO 操作，所以<font color='red'>并发处理能力不强</font>。</p>\n<p><strong>NIO（同步非阻塞 IO）</strong>：支持多个连接同时进行读写操作，因此可以<font color='red'>用较少的线程来处理大量的连接</font>。NIO 通过  <code>Selector</code>  来监听多个  <code>Channel</code>  的状态，当 Channel 中有数据可读或可写时，Selector 会通知程序进行读写操作。适用于连接数多且连接时间较短的场景。</p>\n<p><strong>AIO（异步非阻塞 IO）</strong>：与 NIO 不同的是，<font color='red'>AIO 不需要用户线程等待 IO 操作完成</font>，而是由操作系统来完成 IO 操作，操作系统完成 IO 操作后会利用<font color='red'>回调机制</font>通知用户线程处理。适用于连接数较多且连接时间较长的场景，如高性能网络服务器等。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231025210135977.png\" alt=\"image-20231025210135977\" /></p>\n<h1 id=\"消息队列\"><a class=\"anchor\" href=\"#消息队列\">#</a> 消息队列</h1>\n<blockquote>\n<p>特指分布式消息队列</p>\n</blockquote>\n<h2 id=\"消息队列基础知识\"><a class=\"anchor\" href=\"#消息队列基础知识\">#</a> 消息队列基础知识</h2>\n<h3 id=\"消息队列的定义\"><a class=\"anchor\" href=\"#消息队列的定义\">#</a> 消息队列的定义</h3>\n<p>可以把消息队列看作是<font color='red'>一个存放消息的容器</font>，当我们需要使用消息的时候，直接从容器中取出消息供自己使用即可。由于<font color='red'>队列 Queue</font> 是一种先进先出的数据结构，所以消费消息时也<font color='red'>按照顺序来消费</font>。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/message-queue-small.png\" alt=\"img\" /></p>\n<p>消息队列是一种 <strong>Pub/Sub 模型（发布 / 订阅模型）</strong>，参与消息传递的双方称为<strong>生产者</strong>和<strong>消费者</strong>，生产者负责发送消息，消费者负责处理消息。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/message-queue-pub-sub-model-63a717b4.png\" alt=\"发布/订阅（Pub/Sub）模型\" /></p>\n<center>发布/订阅（Pub/Sub）模型</center>\n<p>我们知道操作系统中的进程通信的一种很重要的方式就是消息队列。我们这里提到的消息队列稍微有点区别，<font color='red'>更多指的是各个服务以及系统内部各个组件 / 模块之前的通信</font>，属于一种<strong>中间件</strong>。</p>\n<p>简单来说：<strong>中间件是一类服务于应用软件的软件，应用软件是为用户服务的，用户不会接触或者使用到中间件。</strong></p>\n<p>随着分布式和微服务系统的发展，消息队列在系统设计中有了更大的发挥空间，使用消息队列<font color='red'>可以降低系统耦合性、实现任务异步、有效地进行流量削峰</font>，是分布式和微服务系统中重要的组件之一。</p>\n<h3 id=\"消息队列的作用\"><a class=\"anchor\" href=\"#消息队列的作用\">#</a> 消息队列的作用</h3>\n<p>通常来说，使用消息队列能为我们的系统带来下面三点好处：</p>\n<ol>\n<li><strong>通过异步处理提高系统性能（减少响应所需时间）</strong></li>\n<li><strong>削峰 / 限流</strong></li>\n<li><strong>降低系统耦合性</strong></li>\n<li><strong>实现分布式事务</strong></li>\n</ol>\n<p>如果在面试的时候你被面试官问到这个问题的话，一般情况是你在你的简历上涉及到消息队列这方面的内容，这个时候推荐<font color='red'>结合自己的项目来回答</font>。</p>\n<h4 id=\"作用1通过异步处理提高系统性能减少响应所需时间\"><a class=\"anchor\" href=\"#作用1通过异步处理提高系统性能减少响应所需时间\">#</a> 作用 1：通过异步处理提高系统性能（减少响应所需时间）</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/Asynchronous-message-queue.png\" alt=\"通过异步处理提高系统性能\" /></p>\n<center>通过异步处理提高系统性能</center>\n<p><font color='red'>服务端将用户的请求数据存储到消息队列后，立即返回结果</font>。随后，系统再对消息进行消费。</p>\n<p>因为用户请求数据写入消息队列之后就立即返回给用户了，但是请求数据在后续的业务校验、写数据库等操作中可能失败。因此，<strong>使用消息队列进行异步处理之后，需要适当修改业务流程进行配合</strong>，比如用户在提交订单之后，订单数据写入消息队列，不能立即返回用户订单提交成功，需要在消息队列的订单消费者进程真正处理完该订单之后，甚至出库后，再通过电子邮件或短信通知用户订单成功，以免交易纠纷。这就类似我们平时手机订火车票和电影票。</p>\n<h4 id=\"作用2削峰限流\"><a class=\"anchor\" href=\"#作用2削峰限流\">#</a> 作用 2：削峰 / 限流</h4>\n<p><strong>先将短时间高并发产生的事务消息存储在消息队列中，然后后端服务再慢慢根据自己的能力去消费这些消息，这样就避免大量事务直接把后端服务冲垮。</strong></p>\n<p>举例：在电子商务一些秒杀、促销活动中，合理使用消息队列可以有效抵御促销活动刚开始大量订单涌入对系统的冲击。如下图所示：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231025224518547.png\" alt=\"削峰\" /></p>\n<center>削峰</center>\n<h4 id=\"作用3降低系统的耦合性\"><a class=\"anchor\" href=\"#作用3降低系统的耦合性\">#</a> 作用 3：降低系统的耦合性</h4>\n<p>使用消息队列还可以降低系统耦合性。我们知道如果模块之间不存在直接调用，那么新增模块或者修改模块就对其他模块影响较小，这样系统的可扩展性无疑更好一些。还是直接上图吧：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231025224821246.png\" alt=\"image-20231025224821246\" /></p>\n<p>生产者（客户端）发送消息到消息队列中去，接受者（服务端）处理消息，需要消费的系统直接去消息队列获取消息进行消费即可，而不需要和其他系统有耦合，这显然也提高了系统的扩展性。</p>\n<p>** 消息队列使用 Pub/Sub 模式（发布 / 订阅模式）工作，生产者发布消息，一个或多个消费者订阅消息。** 从上图可以看到<font color='red'>生产者和消费者之间没有直接耦合</font>，</p>\n<ul>\n<li>生产者将消息发送至分布式消息队列即结束对消息的处理</li>\n<li>消费者从分布式消息队列获取该消息后进行后续处理，并不需要知道该消息从何而来。</li>\n</ul>\n<p><font color='red'>对新增业务，只要对该类消息感兴趣，即可订阅该消息，对原有系统和业务没有任何影响，从而实现网站业务的可扩展性设计</font>。</p>\n<p>消费者对消息进行过滤、处理、包装后，构造成一个新的消息类型，将消息继续发送出去，等待其他消费者订阅该消息。因此基于事件（消息对象）驱动的业务架构可以是一系列流程。</p>\n<p>另外，<font color='red'>为了避免 “消息队列服务器” 宕机造成消息丢失，会将成功发送到消息队列的消息存储在 “生产者服务器” 上，等消息真正被 “消费者服务器” 处理后才删除消息</font>。在消息队列服务器宕机后，生产者服务器会选择分布式消息队列服务器集群中的其他服务器发布消息。</p>\n<p>备注：不要认为消息队列只能利用发布 - 订阅模式工作，只不过在解耦这个特定业务环境下是使用发布 - 订阅模式的。除了发布 - 订阅模式，还有<strong>点对点订阅模式</strong>（一个消息只有一个消费者），我们比较常用的是发布 - 订阅模式。</p>\n<h4 id=\"作用4实现分布式事务\"><a class=\"anchor\" href=\"#作用4实现分布式事务\">#</a> 作用 4：实现分布式事务</h4>\n<p>分布式事务的解决方案之一就是 MQ 事务。</p>\n<p>RocketMQ、Kafka、Pulsar、QMQ 都提供了事务相关的功能。<font color='red'>事务允许事件流应用将生产、处理、消费消息的整个过程定义为一个原子操作</font>。</p>\n<p>详细介绍可以查看 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9qYXZhZ3VpZGUuY24vZGlzdHJpYnV0ZWQtc3lzdGVtL2Rpc3RyaWJ1dGVkLXRyYW5zYWN0aW9uLmh0bWw=\">分布式事务详解 (付费)</span> 这篇文章。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/07b338324a7d8894b8aef4b659b76d92.png\" alt=\"分布式事务详解 - MQ事务\" /></p>\n<center>分布式事务详解 - MQ事务</center>\n<h3 id=\"消息队列存在的问题\"><a class=\"anchor\" href=\"#消息队列存在的问题\">#</a> 消息队列存在的问题</h3>\n<p><strong>系统可用性降低</strong>：在加入 MQ 之前，你不用考虑<font color='red'>消息丢失、 MQ 挂掉</font>等等的情况，但是引入 MQ 之后你就需要去考虑了！</p>\n<p><strong>系统复杂性提高</strong>：加入 MQ 之后，你需要<font color='red'>保证消息没有被重复消费、处理消息丢失的情况、保证消息传递的顺序性</font>等等问题！</p>\n<p><strong>一致性问题</strong>：消息队列可以实现异步，确实可以提高系统响应速度。但是，万一消息的真正消费者并没有正确消费消息怎么办？这样就会导致<font color='red'>数据不一致</font>的情况了！</p>\n<h3 id=\"jms-和-amqp\"><a class=\"anchor\" href=\"#jms-和-amqp\">#</a> JMS 和 AMQP</h3>\n<h4 id=\"jms-定义\"><a class=\"anchor\" href=\"#jms-定义\">#</a> JMS 定义</h4>\n<p><strong>JMS（JAVA Message Service）是 Java 的消息服务，其 API 是一个消息服务的标准 / 规范</strong>。JMS 的客户端之间可以通过 JMS 服务进行异步的消息传输。它允许应用程序组件基于 JavaEE 平台创建、发送、接收和读取消息。它使分布式通信耦合度更低，消息服务更加可靠以及异步性。</p>\n<p>JMS 定义了<font color='gree'>五种不同消息</font>的正文格式以及调用的消息类型，允许你发送并接收一些不同形式的数据：</p>\n<ul>\n<li><code>StreamMessage</code> ：Java 原始值的数据流</li>\n<li><code>MapMessage</code> ：一套名称 - 值对</li>\n<li><code>TextMessage</code> ：一个字符串对象</li>\n<li><code>ObjectMessage</code> ：一个序列化的 Java 对象</li>\n<li><code>BytesMessage</code> ：一个字节的数据流</li>\n</ul>\n<h4 id=\"jms-两种消息模型\"><a class=\"anchor\" href=\"#jms-两种消息模型\">#</a> JMS 两种消息模型</h4>\n<h5 id=\"点到点模型p2p\"><a class=\"anchor\" href=\"#点到点模型p2p\">#</a> 点到点模型（P2P）</h5>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/message-queue-queue-model-3aa809bf.png\" alt=\"队列模型\" /></p>\n<p>使用<strong>队列（Queue）<strong>作为消息通信载体，满足</strong>生产者与消费者模式</strong>，<strong><font color='red'>一条消息只能被一个消费者使用</font></strong>，未被消费的消息在队列中保留直到被消费或超时。比如：生产者发送 100 条消息的话，两个消费者来消费，一般情况下两个消费者会按照消息发送的顺序各自消费一半（也就是你一个我一个的消费）。</p>\n<h5 id=\"发布订阅模型pubsub\"><a class=\"anchor\" href=\"#发布订阅模型pubsub\">#</a> 发布 / 订阅模型（Pub/Sub）</h5>\n<p><img data-src=\"https://javaguide.cn/assets/message-queue-pub-sub-model-63a717b4.png\" alt=\"发布/订阅（Pub/Sub）模型\" /></p>\n<center>发布/订阅（Pub/Sub）模型</center>\n<p>使用<strong>主题（Topic）<strong>作为消息通信载体，类似于</strong>广播模式</strong>；发布者发布一条消息，<strong><font color='red'>该消息通过主题传递给所有的订阅者</font></strong>。</p>\n<h4 id=\"amqp-定义\"><a class=\"anchor\" href=\"#amqp-定义\">#</a> AMQP 定义</h4>\n<p>AMQP，即  <code>Advanced Message Queuing Protocol</code> ，一个提供统一消息服务的应用层标准<strong>高级消息队列协议</strong>（二进制应用层协议），是<font color='red'>应用层协议</font>的一个开放标准，为面向消息的中间件设计，兼容 JMS。<font color='red'>基于此协议的客户端与消息中间件可传递消息</font>，并不受客户端 / 中间件产品，不同的开发语言等条件的限制。</p>\n<p><strong>RabbitMQ 就是基于 AMQP 协议实现的。</strong></p>\n<h4 id=\"jms-vs-amqp\"><a class=\"anchor\" href=\"#jms-vs-amqp\">#</a> JMS vs AMQP</h4>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\"></th>\n<th style=\"text-align:left\">JMS</th>\n<th style=\"text-align:left\">AMQP</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">定义</td>\n<td style=\"text-align:left\"><strong>Java API</strong></td>\n<td style=\"text-align:left\">协议</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">跨语言</td>\n<td style=\"text-align:left\">否</td>\n<td style=\"text-align:left\"><strong>是</strong></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">跨平台</td>\n<td style=\"text-align:left\">否</td>\n<td style=\"text-align:left\"><strong>是</strong></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">支持消息类型</td>\n<td style=\"text-align:left\">提供两种消息模型：①P2P;②Pub/sub</td>\n<td style=\"text-align:left\">提供了五种消息模型：①direct exchange；②fanout exchange；③topic change；④headers exchange；⑤system exchange。本质来讲，后四种和 JMS 的 pub/sub 模型没有太大差别，仅是在路由机制上做了更详细的划分；</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">支持消息类型</td>\n<td style=\"text-align:left\"><strong>多种消息类型</strong></td>\n<td style=\"text-align:left\"><strong>byte []（二进制）</strong></td>\n</tr>\n</tbody>\n</table>\n<p><strong>总结：</strong></p>\n<ul>\n<li>AMQP 为消息定义了线路层的协议，而 JMS 所定义的是 API 规范。在 Java 体系中，多个 client 均可以通过 JMS 进行交互，不需要应用修改代码，但是其对跨平台的支持较差。而 <strong>AMQP 天然具有跨平台、跨语言特性</strong>。</li>\n<li><strong>JMS 支持  <code>TextMessage</code> 、 <code>MapMessage</code>  等复杂的消息类型</strong>；而 <strong>AMQP 仅支持  <code>byte[]</code>  消息类型</strong>（复杂的类型可序列化后发送）。</li>\n<li>由于 Exchange 提供的路由算法，<strong>AMQP 可以提供多样化的路由方式</strong>来传递消息到消息队列，<strong>而 JMS 仅支持 P2P 和 Pub/Sub 方式两种</strong>。</li>\n</ul>\n<h3 id=\"rpc-和消息队列的区别\"><a class=\"anchor\" href=\"#rpc-和消息队列的区别\">#</a> RPC 和消息队列的区别</h3>\n<p>RPC 和消息队列都是分布式微服务系统中重要的组件之一，下面我们来简单对比一下两者：</p>\n<ul>\n<li><strong>用途</strong>：\n<ul>\n<li>RPC：主要用来解决两个服务的远程通信问题，不需要了解底层网络的通信机制。通过 RPC 可以帮助我们<font color='red'>远程调用某个服务的方法</font>，这个过程就像调用本地方法一样简单。</li>\n<li>消息队列：主要用来<font color='red'>降低系统耦合性、实现任务异步、流量削峰</font>。</li>\n</ul>\n</li>\n<li><strong>通信方式</strong>：\n<ul>\n<li>RPC：<font color='red'>双向直接网络通讯</font></li>\n<li>消息队列：<font color='red'>单向引入中间载体</font>的网络通讯</li>\n</ul>\n</li>\n<li><strong>架构</strong>：\n<ul>\n<li>RPC：<font color='red'>不需要存储消息</font>，因为是双向直接网络通讯</li>\n<li>消息队列：需要把消息存储起来</li>\n</ul>\n</li>\n<li><strong>请求处理的时效性</strong>：\n<ul>\n<li>通过 RPC 发出的调用一般会<font color='red'>立即被处理</font></li>\n<li>存放在消息队列中的消息<font color='red'>并不一定会立即被处理</font></li>\n</ul>\n</li>\n</ul>\n<p><font color='red'>RPC 和消息队列本质上是网络通讯的两种不同的实现机制，两者的用途不同</font>，万不可将两者混为一谈。</p>\n<h3 id=\"消息队列选型\"><a class=\"anchor\" href=\"#消息队列选型\">#</a> <mark>消息队列选型</mark></h3>\n<h4 id=\"常见的消息队列\"><a class=\"anchor\" href=\"#常见的消息队列\">#</a> 常见的消息队列</h4>\n<h5 id=\"kafka\"><a class=\"anchor\" href=\"#kafka\">#</a> Kafka</h5>\n<blockquote>\n<p>Kafka 官网：<span class=\"exturl\" data-url=\"aHR0cDovL2thZmthLmFwYWNoZS5vcmcv\">http://kafka.apache.org/</span></p>\n<p>Kafka 更新记录（可以直观看到项目是否还在维护）：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9rYWZrYS5hcGFjaGUub3JnL2Rvd25sb2Fkcw==\">https://kafka.apache.org/downloads</span></p>\n</blockquote>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/kafka-logo.png\" alt=\"img\" /></p>\n<p>Kafka 是 LinkedIn 开源的一个<font color='red'>分布式流式处理平台</font>，已经成为 Apache 顶级项目，早期被用来用于<font color='red'>处理海量的日志</font>，后面才慢慢发展成了一款功能全面的<font color='red'>高性能消息队列</font>。</p>\n<p>流式处理平台具有三个关键功能：</p>\n<ol>\n<li><strong>消息队列</strong>：<font color='red'>发布和订阅消息流</font>。</li>\n<li><strong>持久方式存储消息流</strong>：Kafka 会<font color='red'>把消息持久化到磁盘</font>，有效地避免了消息丢失的风险。</li>\n<li><strong>流式处理平台</strong>：在消息发布的时候进行处理，Kafka 提供了一个完整的流式处理类库。</li>\n</ol>\n<p>Kafka 是一个分布式系统，由通过高性能<font color='red'> TCP 网络协议</font>进行通信的服务器和客户端组成，可以部署在在本地和云环境中的裸机硬件、虚拟机和容器上。</p>\n<p>在 Kafka 2.8 之前，Kafka 最被大家诟病的就是其重度依赖于 Zookeeper 做元数据管理和集群的高可用。<font color='red'>在 Kafka 2.8 之后，引入了基于 Raft 协议的 KRaft 模式，不再依赖 Zookeeper，大大简化了 Kafka 的架构</font>。</p>\n<p>提示一下：<font color='red'>如果要使用 KRaft 模式的话，建议选择较高版本的 Kafka</font>，因为这个功能还在持续完善优化中。Kafka 3.3.1 版本是第一个将 KRaft（Kafka Raft）共识协议标记为生产就绪的版本。</p>\n<h5 id=\"rocketmq\"><a class=\"anchor\" href=\"#rocketmq\">#</a> RocketMQ</h5>\n<blockquote>\n<p>RocketMQ 官网：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9yb2NrZXRtcS5hcGFjaGUub3JnLw==\">https://rocketmq.apache.org/</span> （文档很详细，推荐阅读）</p>\n<p>RocketMQ 更新记录（可以直观看到项目是否还在维护）：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2FwYWNoZS9yb2NrZXRtcS9yZWxlYXNlcw==\">https://github.com/apache/rocketmq/releases</span></p>\n</blockquote>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/rocketmq-logo.png\" alt=\"img\" /></p>\n<p>RocketMQ 是阿里开源的一款<font color='red'>云原生 “消息、事件、流” 实时数据处理平台</font>，借鉴了 Kafka，已经成为 Apache 顶级项目。</p>\n<p>RocketMQ 的核心特性（摘自 RocketMQ 官网）：</p>\n<ul>\n<li><strong>云原生</strong>：生与云，长与云，<font color='red'>无限弹性扩缩，K8s 友好</font></li>\n<li><strong>高吞吐</strong>：万亿级吞吐保证，同时满足微服务与大数据场景。</li>\n<li><strong>流处理</strong>：提供轻量、高扩展、高性能和丰富功能的流计算引擎。</li>\n<li><strong>金融级</strong>：金融级的稳定性，广泛用于交易核心链路。</li>\n<li><strong>架构极简</strong>：<font color='red'>零外部依赖</font>，Shared-nothing 架构。</li>\n<li><strong>生态友好</strong>：无缝对接微服务、实时计算、数据湖等周边生态。</li>\n</ul>\n<p>根据官网介绍：</p>\n<blockquote>\n<p>Apache RocketMQ 自诞生以来，因其架构简单、业务功能丰富、具备极强可扩展性等特点<font color='red'>被众多企业开发者以及云厂商广泛采用</font>。历经十余年的大规模场景打磨，RocketMQ 已经成为<font color='red'>业内共识的金融级可靠业务消息首选方案</font>，被广泛应用于互联网、大数据、移动互联网、物联网等领域的业务场景。</p>\n</blockquote>\n<h5 id=\"rabbitmq\"><a class=\"anchor\" href=\"#rabbitmq\">#</a> RabbitMQ</h5>\n<blockquote>\n<p>RabbitMQ 官网：<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cucmFiYml0bXEuY29tLw==\">https://www.rabbitmq.com/</span> 。</p>\n<p>RabbitMQ 更新记录（可以直观看到项目是否还在维护）：<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cucmFiYml0bXEuY29tL25ld3MuaHRtbA==\">https://www.rabbitmq.com/news.html</span></p>\n</blockquote>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/rabbitmq-logo.png\" alt=\"img\" /></p>\n<p>RabbitMQ 是采用 Erlang 语言实现 <font color='red'>AMQP (Advanced Message Queuing Protocol，高级消息队列协议）</font>的消息中间件，它最初起源于金融系统，用于在分布式系统中<font color='red'>存储转发消息</font>。</p>\n<p>RabbitMQ 发展到今天，被越来越多的人认可，这和它在易用性、扩展性、可靠性和高可用性等方面的卓著表现是分不开的。RabbitMQ 的具体特点可以概括为以下几点：</p>\n<ul>\n<li><strong>可靠性</strong>：RabbitMQ 使用一些机制来保证消息的可靠性，如<font color='red'>持久化、传输确认、发布确认</font>等。</li>\n<li><strong>灵活的路由</strong>：在消息进入队列之前，<font color='red'>通过交换器来路由消息</font>。对于典型的路由功能，RabbitMQ 己经提供了一些内置的交换器来实现。针对更复杂的路由功能，可以将多个交换器绑定在一起，也可以通过插件机制来实现自己的交换器。这个后面会在我们讲 RabbitMQ 核心概念的时候详细介绍到。</li>\n<li><strong>扩展性</strong>：多个 RabbitMQ 节点可以组成一个<font color='red'>集群</font>，也可以根据实际业务情况动态地扩展集群中节点。</li>\n<li><strong>高可用性</strong>：队列可以在集群中的机器上<font color='red'>设置镜像</font>，使得在部分节点出现问题的情况下队列仍然可用。</li>\n<li><strong>支持多种协议</strong>：RabbitMQ 除了原生支持 AMQP 协议，还支持 <font color='red'>STOMP、MQTT</font> 等多种消息中间件协议。</li>\n<li><strong>多语言客户端</strong>：RabbitMQ 几乎<font color='red'>支持所有常用语言</font>，比如 Java、Python、Ruby、PHP、C#、JavaScript 等。</li>\n<li><strong>易用的管理界面</strong>：RabbitMQ 提供了一个<font color='red'>易用的用户界面</font>，使得用户可以<font color='red'>监控和管理消息、集群中的节点</font>等。在安装 RabbitMQ 的时候会介绍到，安装好 RabbitMQ 就自带管理界面。</li>\n<li><strong>插件机制</strong>：RabbitMQ 提供了许多插件，以实现从多方面进行扩展，当然也可以编写自己的插件。感觉这个有点类似 Dubbo 的 SPI 机制。</li>\n</ul>\n<h5 id=\"activemq\"><a class=\"anchor\" href=\"#activemq\">#</a> ActiveMQ</h5>\n<p>目前已经被淘汰，不推荐使用，不建议学习。</p>\n<h4 id=\"对比\"><a class=\"anchor\" href=\"#对比\">#</a> 对比</h4>\n<blockquote>\n<p>参考《Java 工程师面试突击第 1 季 - 中华石杉老师》</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>对比方向</th>\n<th>概要</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>吞吐量</td>\n<td>万级的 ActiveMQ 和 RabbitMQ 的吞吐量（ActiveMQ 的性能最差）要比十万级甚至是百万级的 <font color='red'>RocketMQ 和 Kafka</font> 低一个数量级。</td>\n</tr>\n<tr>\n<td>可用性</td>\n<td><font color='red'>都可以实现高可用</font>。ActiveMQ 和 RabbitMQ 都是基于<font color='red'>主从架构</font>实现高可用性。RocketMQ 基于<font color='red'>分布式架构</font>。 Kafka 也是分布式的，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用</td>\n</tr>\n<tr>\n<td>时效性</td>\n<td><font color='red'>RabbitMQ</font> 基于 Erlang 开发，所以并发能力很强，性能极其好，延时很低，达到微秒级，其他几个都是 ms 级。</td>\n</tr>\n<tr>\n<td>功能支持</td>\n<td><font color='red'>Pulsar</font> 的功能更全面，支持多租户、多种消费模式和持久性模式等功能，是下一代云原生分布式消息流平台。</td>\n</tr>\n<tr>\n<td>消息丢失</td>\n<td>ActiveMQ 和 RabbitMQ 丢失的可能性非常低， <font color='red'>Kafka、RocketMQ 和 Pulsar</font> 理论上可以做到 0 丢失。</td>\n</tr>\n</tbody>\n</table>\n<p>总结：</p>\n<ul>\n<li>ActiveMQ 的社区算是比较成熟，但是较目前来说，ActiveMQ 的性能比较差，而且版本迭代很慢，不推荐使用，已经被淘汰了。</li>\n<li>RabbitMQ 在吞吐量方面虽然稍逊于 Kafka、RocketMQ 和 Pulsar，但是由于它基于 Erlang 开发，所以并发能力很强，性能极其好，延时很低，达到微秒级。但是也因为 RabbitMQ 基于 Erlang 开发，所以国内很少有公司有实力做 Erlang 源码级别的研究和定制。如果业务场景对并发量要求不是太高（十万级、百万级），那这几种消息队列中，RabbitMQ 或许是你的首选。</li>\n<li>RocketMQ 和 Pulsar 支持强一致性，对消息一致性要求比较高的场景可以使用。</li>\n<li>RocketMQ 阿里出品，Java 系开源项目，源代码我们可以直接阅读，然后可以定制自己公司的 MQ，并且 RocketMQ 有阿里巴巴的实际业务场景的实战考验。</li>\n<li>Kafka 仅仅提供较少的核心功能，但是提供超高的吞吐量，ms 级的延迟，极高的可用性以及可靠性，而且分布式可以任意扩展。同时 Kafka 最好是支撑较少的 topic 数量即可，保证其超高吞吐量。<font color='red'>Kafka 唯一的一点劣势是有可能消息重复消费</font>，那么对数据准确性会造成极其轻微的影响，在大数据领域中以及日志采集中，这点轻微影响可以忽略这个特性天然适合大数据实时计算以及日志收集。如果是<font color='red'>大数据领域的实时计算、日志采集等场景</font>，用 Kafka 是业内标准的，绝对没问题，社区活跃度很高，绝对不会黄，何况几乎是全世界这个领域的事实性规范。</li>\n</ul>\n<h2 id=\"kafka-2\"><a class=\"anchor\" href=\"#kafka-2\">#</a> Kafka</h2>\n<h3 id=\"基础\"><a class=\"anchor\" href=\"#基础\">#</a> 基础</h3>\n<h4 id=\"功能-应用场景\"><a class=\"anchor\" href=\"#功能-应用场景\">#</a> 功能、应用场景</h4>\n<p>Kafka 是一个<strong>分布式流式处理平台</strong>，流平台具有三个关键功能：</p>\n<ol>\n<li><strong><font color='red'>消息队列</font></strong>：<font color='red'>发布和订阅消息流</font>，这个功能类似于消息队列，这也是 Kafka 也被归类为消息队列的原因。</li>\n<li><strong><font color='red'>容错的持久方式存储记录消息流</font></strong>：Kafka 会<font color='red'>把消息持久化到磁盘</font>，有效避免了消息丢失的风险。</li>\n<li>**<font color='red'>流式处理平台</font>：** 在消息发布的时候进行处理，Kafka 提供了一个<font color='red'>完整的流式处理类库</font>。</li>\n</ol>\n<p>Kafka 主要有两大应用场景：</p>\n<ol>\n<li><strong><font color='red'>消息队列</font></strong>：建立实时流数据管道，以可靠地在系统或应用程序之间获取数据。</li>\n<li>**<font color='red'>数据处理</font>：** 构建实时的流数据处理程序来转换或处理数据流。</li>\n</ol>\n<h4 id=\"相比其他-mq-的优势\"><a class=\"anchor\" href=\"#相比其他-mq-的优势\">#</a> 相比其他 MQ 的优势</h4>\n<p>Kafka 相比其他消息队列主要的优势如下：</p>\n<ol>\n<li><strong><font color='red'>极致的性能</font></strong>：基于 Scala 和 Java 语言开发，设计中大量使用了<font color='red'>批量处理</font>和<font color='red'>异步</font>的思想，最高<font color='red'>每秒可以处理千万级别的消息</font>。</li>\n<li><strong><font color='red'>生态系统兼容性无可匹敌</font></strong>：Kafka 与周边生态系统的兼容性是最好的没有之一，尤其在大数据和流计算领域。</li>\n</ol>\n<h4 id=\"消息模型\"><a class=\"anchor\" href=\"#消息模型\">#</a> 消息模型</h4>\n<blockquote>\n<p>题外话：早期的  <code>JMS</code>  和  <code>AMQP</code>  属于消息服务领域权威组织所做的相关的标准，但是这些标准的进化跟不上消息队列的演进速度，<font color='red'>这些标准实际上已经属于废弃状态</font>。所以，可能存在的情况是：<font color='red'>不同的消息队列都有自己的一套消息模型</font>。</p>\n</blockquote>\n<h5 id=\"队列模型p2p\"><a class=\"anchor\" href=\"#队列模型p2p\">#</a> 队列模型（P2P）</h5>\n<blockquote>\n<p>早期的消息模型</p>\n</blockquote>\n<p><img data-src=\"https://oss.javaguide.cn/github/javaguide/high-performance/message-queue/%E9%98%9F%E5%88%97%E6%A8%A1%E5%9E%8B23.png\" alt=\"队列模型\" /></p>\n<center>队列模型</center>\n<p>使用<strong>队列（Queue）<strong>作为消息通信载体，满足生产者与消费者模式，</strong><font color='red'>一条消息只能被一个消费者使用，未被消费的消息在队列中保留直到被消费或超时</font></strong>。比如：我们生产者发送 100 条消息的话，两个消费者来消费，一般情况下两个消费者会按照消息发送的顺序各自消费一半（也就是你一个我一个的消费。）</p>\n<p>队列模型存在的问题：<font color='red'>无法将生产者产生的消息分发给多个消费者，并保证每个消费者都能接收到完整的消息内容</font>。这种情况，队列模型就不好解决了。很多比较杠精的人就说：我们可以为每个消费者创建一个单独的队列，让生产者发送多份。这是一种非常愚蠢的做法，浪费资源不说，还违背了使用消息队列的目的。</p>\n<h5 id=\"发布-订阅模型pub-sub\"><a class=\"anchor\" href=\"#发布-订阅模型pub-sub\">#</a> 发布 - 订阅模型（Pub-Sub）</h5>\n<blockquote>\n<p><strong><font color='red'>Kafka 采用的消息模型</font></strong>，为了解决队列模型存在的问题</p>\n</blockquote>\n<p><img data-src=\"https://oss.javaguide.cn/java-guide-blog/%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%9E%8B.png\" alt=\"发布订阅模型\" /></p>\n<center>发布订阅模型</center>\n<p>发布 - 订阅模型（Pub-Sub） 使用<strong>主题（Topic）<strong>作为消息通信载体，类似于</strong>广播模式</strong>。<strong>发布者发布一条消息，该消息通过主题传递给所有的订阅者，在一条消息广播之后才订阅的用户则是收不到该条消息的</strong>。</p>\n<p>在发布 - 订阅模型中，<font color='red'>如果只有一个订阅者，那它和队列模型就基本是一样的了</font>。所以说，发布 - 订阅模型在功能层面上是可以兼容队列模型的。</p>\n<blockquote>\n<p><strong>RocketMQ 的消息模型和 Kafka 基本是完全一样的。唯一的区别是 Kafka 中没有队列这个概念，与之对应的是 Partition（分区）。</strong></p>\n</blockquote>\n<h3 id=\"核心概念\"><a class=\"anchor\" href=\"#核心概念\">#</a> 核心概念</h3>\n<h4 id=\"producer-comsumer-broker-topic-partition\"><a class=\"anchor\" href=\"#producer-comsumer-broker-topic-partition\">#</a> Producer、Comsumer、Broker、Topic、Partition</h4>\n<p>Kafka 将生产者发布的消息发送到 **Topic（主题）** 中，需要这些消息的消费者可以订阅这些 Topic，如下图所示：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/message-queue20210507200944439.png\" alt=\"img\" /></p>\n<p>上面这张图也为我们引出了，Kafka 比较重要的几个概念：</p>\n<ol>\n<li>\n<p>Producer（生产者）: 产生消息的一方。</p>\n</li>\n<li>\n<p>Consumer（消费者）: 消费消息的一方。</p>\n</li>\n<li>\n<p><strong>Broker（代理）</strong>: 可以看作是<font color='red'>一个独立的 Kafka 实例</font>。多个 Kafka Broker 组成一个 Kafka <strong>Cluster（集群）</strong>。每个 Broker 中又包含：</p>\n<ul>\n<li>\n<p><strong>Topic（主题）</strong>: Producer 将消息发送到特定的主题，Consumer 通过订阅特定的 Topic (主题) 来消费消息。</p>\n</li>\n<li>\n<p><strong>Partition（分区）</strong>: <font color='red'>属于 Topic 的一部分</font>。一个 Topic 可以有多个 Partition ，并且 **<font color='red'>同一 Topic 下的 Partition 可以分布在不同的 Broker 上，表明一个 Topic 可以横跨多个 Broker</font>**。</p>\n</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"多副本机制replica\"><a class=\"anchor\" href=\"#多副本机制replica\">#</a> 多副本机制（Replica）</h4>\n<blockquote>\n<p>类似于 <strong>Redis 中的主从复制（Replica）</strong></p>\n</blockquote>\n<p>Kafka 为分区（Partition）引入了<strong>多副本（Replica）机制</strong>。Partition 中的多个副本之间会有一个叫做  <code>leader</code>  的家伙，其他副本称为  <code>follower</code> 。<font color='red'>发送的消息先被发送到 leader 副本，然后 follower 副本才能从 leader 副本中拉取消息进行同步</font>。</p>\n<blockquote>\n<p><strong><font color='red'>生产者和消费者只与 leader 副本交互</font></strong>。可以理解为<font color='red'>其他副本只是 leader 副本的拷贝，它们的存在只是为了保证消息存储的安全性</font>。<font color='red'>当 leader 副本发生故障时会从 follower 中选举出一个 leader，前提是该 follower 和 leader 同步程度一致</font>。</p>\n</blockquote>\n<p>Kafka 多副本（Replica）机制的好处如下：</p>\n<ol>\n<li><strong><font color='red'>负载均衡</font></strong>：Kafka 通过给特定 Topic 指定多个 Partition，而各个 Partition 可以分布在不同的 Broker 上，这样便能提供比较好的<font color='red'>并发能力</font>。</li>\n<li><strong><font color='red'>数据容灾能力</font></strong>：Partition 可以指定对应的 Replica 数，极大地提高了消息存储的安全性与容灾能力，不过也相应地增加了所需要的存储空间。</li>\n</ol>\n<h3 id=\"kafka-与-zookeeper-的关系\"><a class=\"anchor\" href=\"#kafka-与-zookeeper-的关系\">#</a> Kafka 与 Zookeeper 的关系</h3>\n<h4 id=\"zookeeper-在-kafka-中的作用\"><a class=\"anchor\" href=\"#zookeeper-在-kafka-中的作用\">#</a> Zookeeper 在 Kafka 中的作用</h4>\n<p>下图就是我的本地 Zookeeper，它成功和我本地的 Kafka 关联上（以下文件夹结构借助 idea 插件 Zookeeper tool 实现）。</p>\n<img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/zookeeper-kafka.jpg\" alt=\"img\" style=\"zoom:50%;\" />\n<p>ZooKeeper 主要为 Kafka 提供<strong>元数据的管理</strong>的功能。</p>\n<p>从图中我们可以看出，Zookeeper 主要为 Kafka 做了下面这些事情：</p>\n<ol>\n<li><strong><font color='red'>Broker 注册</font></strong>：在 Zookeeper 上会有一个专门用来<font color='red'>记录 Broker 服务器列表</font>的节点。每个 Broker 在启动时，都会到 Zookeeper 上进行注册，即到  <code>/brokers/ids</code>  下创建属于自己的节点。每个 Broker 就会将自己的 IP 地址和端口等信息记录到该节点中去</li>\n<li><strong><font color='red'>Topic 注册</font></strong>：在 Kafka 中，<font color='red'>同一个 Topic 的消息会被分成多个 Partition</font>，并将其分布在多个 Broker 上。<font color='red'>这些 Partition 信息及与 Broker 的对应关系也都是由 Zookeeper 在维护</font>。比如我创建了一个名字为 my-topic 的 Topic 并且它有两个 Partition ，对应到 zookeeper 中会创建这些文件夹： <code>/brokers/topics/my-topic/Partitions/0</code> 、 <code>/brokers/topics/my-topic/Partitions/1</code></li>\n<li><strong><font color='red'>负载均衡</font></strong>：上面也说过了 Kafka 通过给特定 Topic 指定多个 Partition，而各个 Partition 可以分布在不同的 Broker 上，这样便能提供比较好的并发能力。<font color='red'>对于同一个 Topic 的不同 Partition，Kafka 会尽力将这些 Partition 分布到不同的 Broker 服务器上</font>。\n<ul>\n<li>当 Provider 产生消息时，会尽量投递到不同 Broker 的 Partition 里面。</li>\n<li>当 Consumer 消费消息时，Zookeeper 会可以根据当前的 Partition 数量以及 Consumer 数量来实现动态负载均衡。</li>\n</ul>\n</li>\n<li>……</li>\n</ol>\n<h4 id=\"kafka-不再依赖于-zookeeper\"><a class=\"anchor\" href=\"#kafka-不再依赖于-zookeeper\">#</a> Kafka 不再依赖于 Zookeeper</h4>\n<p>在 Kafka 2.8 之前，Kafka 最被大家诟病的就是其重度依赖于 Zookeeper。<font color='red'>在 Kafka 2.8 之后，引入了基于 Raft 协议的 KRaft 模式，不再依赖 Zookeeper，大大简化了 Kafka 的架构，让你可以以一种轻量级的方式来使用 Kafka</font>。</p>\n<p>不过，要提示一下：如果要使用 KRaft 模式的话，建议选择较高版本的 Kafka，因为这个功能还在持续完善优化中。Kafka 3.3.1 版本是第一个将 KRaft（Kafka Raft）共识协议标记为生产就绪的版本。</p>\n<p>![](<span class=\"exturl\" data-url=\"aHR0cHM6Ly9vc3MuamF2YWd1aWRlLmNuL2dpdGh1Yi9qYXZhZ3VpZGUvaGlnaC1wZXJmb3JtYW5jZS9tZXNzYWdlLXF1ZXVlL2thZmthMy4zLjEta3JhZnQt\">https://oss.javaguide.cn/github/javaguide/high-performance/message-queue/kafka3.3.1-kraft-</span> production-ready.png)</p>\n<h3 id=\"消费顺序-消息丢失-重复消费\"><a class=\"anchor\" href=\"#消费顺序-消息丢失-重复消费\">#</a> 消费顺序、消息丢失、重复消费</h3>\n<h4 id=\"如何保证消息的消费顺序\"><a class=\"anchor\" href=\"#如何保证消息的消费顺序\">#</a> 如何保证消息的消费顺序？</h4>\n<p>我们在使用消息队列的过程中经常有业务场景需要严格保证消息的消费顺序，比如我们同时发了 2 个消息，这 2 个消息对应的操作分别对应的数据库操作是：</p>\n<ol>\n<li>更改用户会员等级。</li>\n<li>根据会员等级计算订单价格。</li>\n</ol>\n<p>假如这两条消息的消费顺序不一样造成的最终结果就会截然不同。</p>\n<p>我们知道<font color='red'> Kafka 中 Partition (分区) 是真正保存消息的地方</font>，我们发送的消息都被放在了这里。而 Partition (分区) 又存在于 Topic (主题) 概念中，并且我们可以给特定 Topic 指定多个 Partition。</p>\n<p><img data-src=\"https://oss.javaguide.cn/github/javaguide/high-performance/message-queue/KafkaTopicPartionsLayout.png\" alt=\"img\" /></p>\n<p>每次添加消息到 Partition (分区) 的时候都会采用 **<font color='red'>尾加法</font>**，如上图所示。 <font color='red'>Kafka 只能为我们保证 Partition（分区）中的消息有序，通过 **offset（偏移量）** 实现</font>。</p>\n<blockquote>\n<p>消息在被追加到 Partition (分区) 的时候都会分配一个特定的偏移量（offset）。</p>\n</blockquote>\n<p>所以，我们就有一种很简单的保证消息消费顺序的方法：1 个 Topic 只对应一个 Partition。这样当然可以解决问题，但是破坏了 Kafka 的设计初衷。</p>\n<p>Kafka 中发送 1 条消息的时候，可以指定 topic、partition、key、data（数据）4 个参数。如果你发送消息的时候指定了 Partition 的话，所有消息都会被发送到指定的 Partition。并且，<font color='red'>同一个 key 的消息可以保证只发送到同一个 partition</font>，这个我们可以采用表 / 对象的 id 来作为 key 。</p>\n<p>总结一下，对于如何保证 Kafka 中消息消费的顺序，有了下面两种方法：</p>\n<ol>\n<li>1 个 Topic 只对应一个 Partition。</li>\n<li>（推荐）<strong>发送消息的时候指定 key/Partition</strong>。</li>\n</ol>\n<p>当然不仅仅只有上面两种方法，上面两种方法是我觉得比较好理解的。</p>\n<h4 id=\"如何保证消息不丢失\"><a class=\"anchor\" href=\"#如何保证消息不丢失\">#</a> 如何保证消息不丢失？</h4>\n<h5 id=\"情况1producer-丢失消息\"><a class=\"anchor\" href=\"#情况1producer-丢失消息\">#</a> 情况 1：Producer 丢失消息</h5>\n<p>Producer 调用  <code>send</code>  方法发送消息之后，消息可能因为网络问题并没有发送过去。所以，我们不能默认在调用  <code>send</code>  方法发送消息之后消息发送成功了。</p>\n<p>为了确定消息是发送成功，我们要判断消息发送的结果。但是要注意的是<font color='red'> Kafka 中 Producer 使用  <code>send</code>  方法发送消息实际上是异步的操作，可以通过  <code>get()</code>  方法获取调用结果，但是这样也让它变为了同步操作</font>，示例代码如下：</p>\n<blockquote>\n<p>详细代码见这篇文章：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3M/X19iaXo9TXpnMk9UQTBOamswT0E9PSZhbXA7bWlkPTIyNDc0ODYyNjkmYW1wO2lkeD0yJmFtcDtzbj1lYzAwNDE3YWQ2NDFkZDhjM2QxNDVkNzRjYWZhMDljZSZhbXA7Y2hrc209Y2VhMjQ0ZjZmOWQ1Y2RlMGM4ZWIyMzNmY2M0Y2Y4MmUxMWFjZDA2NDQ2NzE5YTdhZjU1MjMwNjQ5ODYzYTNkZGQ5NWY3OGQxMTFkZSZhbXA7dG9rZW49MTYzMzk1NzI2MiZhbXA7bGFuZz16aF9DTiNyZA==\">Kafka 系列第三篇！10 分钟学会如何在 Spring Boot 程序中使用 Kafka 作为消息队列？</span></p>\n</blockquote>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token class-name\">SendResult</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">Object</span><span class=\"token punctuation\">></span></span> sendResult <span class=\"token operator\">=</span> kafkaTemplate<span class=\"token punctuation\">.</span><span class=\"token function\">send</span><span class=\"token punctuation\">(</span>topic<span class=\"token punctuation\">,</span> o<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>sendResult<span class=\"token punctuation\">.</span><span class=\"token function\">getRecordMetadata</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>  logger<span class=\"token punctuation\">.</span><span class=\"token function\">info</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"生产者成功发送消息到\"</span> <span class=\"token operator\">+</span> sendResult<span class=\"token punctuation\">.</span><span class=\"token function\">getProducerRecord</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">topic</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token string\">\"-> \"</span> <span class=\"token operator\">+</span> sendRe</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>              sult<span class=\"token punctuation\">.</span><span class=\"token function\">getProducerRecord</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">value</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>但是<font color='red'>一般不推荐这么做</font>！可以<strong>借助  <code>ListenableFuture</code>  为 Producer 的  <code>send</code>  方法添加回调函数</strong>的形式，示例代码如下：</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token class-name\">ListenableFuture</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">SendResult</span><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">Object</span><span class=\"token punctuation\">></span><span class=\"token punctuation\">></span></span> future <span class=\"token operator\">=</span> kafkaTemplate<span class=\"token punctuation\">.</span><span class=\"token function\">send</span><span class=\"token punctuation\">(</span>topic<span class=\"token punctuation\">,</span> o<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>        future<span class=\"token punctuation\">.</span><span class=\"token function\">addCallback</span><span class=\"token punctuation\">(</span>result <span class=\"token operator\">-></span> logger<span class=\"token punctuation\">.</span><span class=\"token function\">info</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"生产者成功发送消息到topic:&#123;&#125; partition:&#123;&#125;的消息\"</span><span class=\"token punctuation\">,</span> result<span class=\"token punctuation\">.</span><span class=\"token function\">getRecordMetadata</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">topic</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> result<span class=\"token punctuation\">.</span><span class=\"token function\">getRecordMetadata</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">partition</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>                ex <span class=\"token operator\">-></span> logger<span class=\"token punctuation\">.</span><span class=\"token function\">error</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"生产者发送消息失败，原因：&#123;&#125;\"</span><span class=\"token punctuation\">,</span> ex<span class=\"token punctuation\">.</span><span class=\"token function\">getMessage</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p><strong><font color='red'>如果消息发送失败的话，我们检查失败的原因之后重新发送即可</font></strong>！</p>\n<ul>\n<li>\n<p>这里推荐<font color='red'>为 Producer 的  <code>retries</code> （重试次数）设置一个比较合理的值，一般是 3 </font>，但是为了保证消息不丢失的话一般会设置比较大一点。设置完成之后，当出现网络问题之后能够自动重试消息发送，避免消息丢失。</p>\n</li>\n<li>\n<p>另外，<font color='red'>建议还要设置重试间隔</font>，因为间隔太小的话重试的效果就不明显了，网络波动一次你 3 次一下子就重试完了。</p>\n</li>\n</ul>\n<h5 id=\"情况2consumer-丢失消息\"><a class=\"anchor\" href=\"#情况2consumer-丢失消息\">#</a> 情况 2：Consumer 丢失消息</h5>\n<p>我们知道消息在被追加到 Partition (分区) 的时候都会分配一个特定的 offset（偏移量）。<font color='red'>offset 表示 Consumer 当前消费到的 Partition (分区) 的所在位置</font>。Kafka 通过偏移量（offset）可以保证消息在分区内的顺序性。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/kafka-offset.jpg\" alt=\"kafka offset\" /></p>\n<center>kafka offset</center>\n<p><font color='red'>当 Consumer 拉取到了 Partition 的某个消息之后，Consumer 会自动提交了  offset </font>。自动提交的话会有一个问题，试想一下，当 Consumer 刚拿到这个消息准备进行真正消费的时候，突然挂掉了，消息实际上并没有被消费，但是 offset 却被自动提交了。</p>\n<p>解决办法也比较粗暴，我们 ** 关闭自动提交 offset，每次在真正消费完消息之后再手动提交 offset **。 但是，细心的朋友一定会发现，<font color='red'>这样会带来消息被重新消费的问题</font>。比如你刚刚消费完消息之后，还没提交 offset，结果自己挂掉了，那么这个消息理论上就会被消费两次。</p>\n<h5 id=\"情况3kafka-丢失消息\"><a class=\"anchor\" href=\"#情况3kafka-丢失消息\">#</a> 情况 3：Kafka 丢失消息</h5>\n<p>我们知道<font color='red'> Kafka 为 Partition 引入了多副本（Replica）机制</font>。Partition 中的多个副本之间会有一个叫做 leader 的家伙，其他副本称为 follower。我们发送的消息会被发送到 leader 副本，然后 follower 副本才能从 leader 副本中拉取消息进行同步。Producer 和 Comsumer 只与 leader 副本交互。可以理解为其他 follower 副本只是 leader 副本的拷贝，它们的存在只是为了保证消息存储的安全性。</p>\n<p>试想一种情况：<font color='red'>假如 leader 副本所在的 broker 突然挂掉，但是 leader 的数据还有一些没有被 follower 副本的同步的话，就会造成<strong>消息丢失</strong></font>。</p>\n<ul>\n<li>\n<p><strong>设置  <code>acks = all</code> </strong>：<font color='red'>acks 是 Kafka Producer 很重要的一个参数，其默认值为 1，代表我们的消息被 leader 副本接收之后就算被成功发送</font>。<strong><font color='red'>配置  <code>acks = all</code>  表示只有所有 ISR 列表的副本全部收到消息时，Producer 才会接收到来自服务器的响应</font></strong>。这种模式是<font color='red'>最高级别、最安全</font>的，可以确保不止一个 Broker 接收到了消息，但副作用是<font color='red'>延迟会很高</font>。</p>\n<blockquote>\n<p>Partition 中的所有副本统称为 <strong> <code>AR</code> </strong>（Assigned Repllicas）。所有与 leader 副本保持一定程度同步的副本（包括 Leader 本身）组成 <strong> <code>ISR</code> </strong>（In-Sync Replicas），ISR 集合是 AR 集合中的一个子集。</p>\n</blockquote>\n</li>\n<li>\n<p><strong>设置  <code>replication.factor &gt;= 3</code> </strong>：为了保证 leader 副本能有 follower 副本能同步消息，可以 **<font color='red'>确保每个 Partition 至少有 3 个副本</font>**。虽然造成了数据冗余，但是带来了<font color='red'>数据的安全性</font>。</p>\n</li>\n<li>\n<p><strong>设置  <code>min.insync.replicas &gt; 1</code> </strong>：<strong><font color='red'>代表消息至少要被写入到 2 个副本才算是被成功发送</font></strong>。其默认值为 1 ，在实际生产中应尽量避免。</p>\n</li>\n<li>\n<p><strong>确保  <code>replication.factor &gt; min.insync.replicas</code> </strong>：<font color='red'>为了保证整个 Kafka 服务的高可用性</font>。设想一下假如两者相等的话，只要是有一个副本挂掉，整个 Partition 就无法正常工作了。这明显违反高可用性！<font color='red'>一般推荐设置成  <code>replication.factor = min.insync.replicas + 1</code> </font>。</p>\n</li>\n<li>\n<p><strong>设置  <code>unclean.leader.election.enable = false</code> </strong>：</p>\n<blockquote>\n<p>Kafka 从 0.11.0.0 版本开始， <code>unclean.leader.election.enable</code>  参数的默认值改为 false</p>\n</blockquote>\n<p>我们最开始也说了我们发送的消息会被发送到 leader 副本，然后 follower 副本才能从 leader 副本中拉取消息进行同步，多个 follower 副本之间的消息同步情况不一样。当我们配置了 unclean.leader.election.enable = false 的话，<strong><font color='red'>当 leader 副本发生故障时，就不会从同步程度达不到要求的 follower 副本中选择出 leader</font></strong>，降低了消息丢失的可能性。</p>\n</li>\n</ul>\n<h4 id=\"如何保证消息不被重复消费\"><a class=\"anchor\" href=\"#如何保证消息不被重复消费\">#</a> 如何保证消息不被重复消费？</h4>\n<p>kafka 出现消息重复消费的原因：</p>\n<ul>\n<li>\n<p><strong><font color='red'>根本原因：Consumer 已经消费了消息，但没有成功提交 offset</font></strong></p>\n</li>\n<li>\n<p>直接原因：Consumer 由于处理业务时间长或者网络链接等原因，<font color='red'>让 Kafka 认为服务假死，触发了 Partition  <code>rebalance</code> </font>。</p>\n</li>\n</ul>\n<p>解决方案：</p>\n<ul>\n<li><strong>Consumer 消费消息服务做幂等校验</strong>，比如 Redis 的 set、MySQL 的主键等天然的幂等功能，这种方法最有效。</li>\n<li><strong>将  <code>enable.auto.commit</code>  参数设置为 false，关闭 offset 的自动提交，开发者在代码中手动提交 offset</strong>。那么这里会有个问题：什么时候提交 offset 合适？\n<ul>\n<li>处理完消息再提交：依旧有消息重复消费的风险，和自动提交一样</li>\n<li><strong>拉取到消息即提交</strong>：会有消息丢失的风险。允许消息延时的场景，一般会采用这种方式。然后，通过定时任务在业务不繁忙（比如凌晨）的时候做数据兜底。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"重试机制\"><a class=\"anchor\" href=\"#重试机制\">#</a> 重试机制</h3>\n<blockquote>\n<p>在 Kafka 如何保证消息不丢失中提到了 Kafka 的重试机制。</p>\n<p>网上关于 Spring Kafka 的默认重试机制文章很多，但大多都是过时的，和实际运行结果完全不一样。以下是根据 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9tdm5yZXBvc2l0b3J5LmNvbS9hcnRpZmFjdC9vcmcuc3ByaW5nZnJhbWV3b3JrLmthZmthL3NwcmluZy1rYWZrYS8yLjkuMw==\">spring-kafka-2.9.3</span> 源码重新梳理一下。</p>\n</blockquote>\n<h4 id=\"消费失败后会先重试多次重试失败后会跳过\"><a class=\"anchor\" href=\"#消费失败后会先重试多次重试失败后会跳过\">#</a> 消费失败后会先重试，多次重试失败后会跳过</h4>\n<p>Producer 代码：</p>\n<pre><code class=\"language-Java\"> for (int i = 0; i &lt; 10; i++) &#123;\n   kafkaTemplate.send(KafkaConst.TEST_TOPIC, String.valueOf(i))\n &#125;\n</code></pre>\n<p>Comsumer 代码：</p>\n<pre><code class=\"language-Java\">   @KafkaListener(topics = &#123;KafkaConst.TEST_TOPIC&#125;,groupId = &quot;apple&quot;)\n   private void customer(String message) throws InterruptedException &#123;\n       log.info(&quot;kafka customer:&#123;&#125;&quot;,message);\n       Integer n = Integer.parseInt(message);\n       if (n%5==0)&#123; // 当n为0和5时抛出异常\n           throw new  RuntimeException();\n       &#125;\n   &#125;\n</code></pre>\n<p><strong>在默认配置下，当消费异常会进行重试，重试多次后会跳过当前消息，继续进行后续消息的消费，不会一直卡在当前消息</strong>。</p>\n<p>下面是一段消费的日志，可以看出当  <code>test-0@95</code>  重试多次后会被跳过。</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token number\">2023</span><span class=\"token operator\">-</span><span class=\"token number\">08</span><span class=\"token operator\">-</span><span class=\"token number\">10</span> <span class=\"token number\">12</span><span class=\"token operator\">:</span><span class=\"token number\">03</span><span class=\"token operator\">:</span><span class=\"token number\">32.918</span> <span class=\"token constant\">DEBUG</span> <span class=\"token number\">9700</span> <span class=\"token operator\">--</span><span class=\"token operator\">-</span> <span class=\"token punctuation\">[</span>ntainer#<span class=\"token number\">0</span><span class=\"token operator\">-</span><span class=\"token number\">0</span><span class=\"token operator\">-</span><span class=\"token class-name\">C</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token class-name\"><span class=\"token namespace\">o<span class=\"token punctuation\">.</span>s<span class=\"token punctuation\">.</span>kafka<span class=\"token punctuation\">.</span>listener<span class=\"token punctuation\">.</span></span>DefaultErrorHandler</span>   <span class=\"token operator\">:</span> <span class=\"token class-name\">Skipping</span> seek of<span class=\"token operator\">:</span> test<span class=\"token operator\">-</span><span class=\"token number\">0</span><span class=\"token annotation punctuation\">@95</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token number\">2023</span><span class=\"token operator\">-</span><span class=\"token number\">08</span><span class=\"token operator\">-</span><span class=\"token number\">10</span> <span class=\"token number\">12</span><span class=\"token operator\">:</span><span class=\"token number\">03</span><span class=\"token operator\">:</span><span class=\"token number\">32.918</span> <span class=\"token constant\">TRACE</span> <span class=\"token number\">9700</span> <span class=\"token operator\">--</span><span class=\"token operator\">-</span> <span class=\"token punctuation\">[</span>ntainer#<span class=\"token number\">0</span><span class=\"token operator\">-</span><span class=\"token number\">0</span><span class=\"token operator\">-</span><span class=\"token class-name\">C</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token class-name\"><span class=\"token namespace\">o<span class=\"token punctuation\">.</span>s<span class=\"token punctuation\">.</span>kafka<span class=\"token punctuation\">.</span>listener<span class=\"token punctuation\">.</span></span>DefaultErrorHandler</span>   <span class=\"token operator\">:</span> <span class=\"token class-name\">Seeking</span><span class=\"token operator\">:</span> test<span class=\"token operator\">-</span><span class=\"token number\">0</span> <span class=\"token keyword\">to</span><span class=\"token operator\">:</span> <span class=\"token number\">96</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token number\">2023</span><span class=\"token operator\">-</span><span class=\"token number\">08</span><span class=\"token operator\">-</span><span class=\"token number\">10</span> <span class=\"token number\">12</span><span class=\"token operator\">:</span><span class=\"token number\">03</span><span class=\"token operator\">:</span><span class=\"token number\">32.918</span>  <span class=\"token constant\">INFO</span> <span class=\"token number\">9700</span> <span class=\"token operator\">--</span><span class=\"token operator\">-</span> <span class=\"token punctuation\">[</span>ntainer#<span class=\"token number\">0</span><span class=\"token operator\">-</span><span class=\"token number\">0</span><span class=\"token operator\">-</span><span class=\"token class-name\">C</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token class-name\"><span class=\"token namespace\">o<span class=\"token punctuation\">.</span>a<span class=\"token punctuation\">.</span>k<span class=\"token punctuation\">.</span>clients<span class=\"token punctuation\">.</span>consumer<span class=\"token punctuation\">.</span></span>KafkaConsumer</span>     <span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token class-name\">Consumer</span> clientId<span class=\"token operator\">=</span>consumer<span class=\"token operator\">-</span>apple<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> groupId<span class=\"token operator\">=</span>apple<span class=\"token punctuation\">]</span> <span class=\"token class-name\">Seeking</span> <span class=\"token keyword\">to</span> <span class=\"token namespace\">offset</span> <span class=\"token number\">96</span> <span class=\"token keyword\">for</span> partition test<span class=\"token operator\">-</span><span class=\"token number\">0</span></pre></td></tr></table></figure><h4 id=\"默认重试-10-次时间间隔为-0\"><a class=\"anchor\" href=\"#默认重试-10-次时间间隔为-0\">#</a> 默认重试 10 次，时间间隔为 0</h4>\n<blockquote>\n<p>源码略了</p>\n</blockquote>\n<p>总结：<strong>Kafka Comsumer 在默认配置下会进行最多 10 次重试，每次重试的时间间隔为 0，即立即重试。如果在 10 次重试后仍然无法成功消费消息，则不再进行重试，该消息将被视为消费失败</strong>。</p>\n<h4 id=\"自定义重试次数-时间间隔\"><a class=\"anchor\" href=\"#自定义重试次数-时间间隔\">#</a> 自定义重试次数、时间间隔</h4>\n<p>从上面的代码可以知道，默认错误处理器的重试次数以及时间间隔是由  <code>FixedBackOff</code>  控制的， <code>FixedBackOff</code>  是  <code>DefaultErrorHandler</code>  初始化时默认的。</p>\n<p>所以自定义重试次数以及时间间隔，<strong>只需要在  <code>DefaultErrorHandler</code>  初始化的时候传入自定义的  <code>FixedBackOff</code>  即可</strong>。</p>\n<p>重新实现一个  <code>KafkaListenerContainerFactory</code>  ，调用  <code>setCommonErrorHandler</code>  设置新的自定义的错误处理器就可以实现。</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token annotation punctuation\">@Bean</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token class-name\">KafkaListenerContainerFactory</span> <span class=\"token function\">kafkaListenerContainerFactory</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">ConsumerFactory</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">></span></span> consumerFactory<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token class-name\">ConcurrentKafkaListenerContainerFactory</span> factory <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ConcurrentKafkaListenerContainerFactory</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token comment\">// 自定义重试时间间隔以及次数</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token class-name\">FixedBackOff</span> fixedBackOff <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">FixedBackOff</span><span class=\"token punctuation\">(</span><span class=\"token number\">1000</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    factory<span class=\"token punctuation\">.</span><span class=\"token function\">setCommonErrorHandler</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">DefaultErrorHandler</span><span class=\"token punctuation\">(</span>fixedBackOff<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    factory<span class=\"token punctuation\">.</span><span class=\"token function\">setConsumerFactory</span><span class=\"token punctuation\">(</span>consumerFactory<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token keyword\">return</span> factory<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h4 id=\"重试失败后如何告警\"><a class=\"anchor\" href=\"#重试失败后如何告警\">#</a> 重试失败后，如何告警？</h4>\n<p>重试失败后逻辑需要手动实现，以下是一个简单的例子。<strong>继承  <code>DefaultErrorHandler</code>  并重写  <code>handleRemaining</code>  函数，加上自定义的告警等操作</strong>。</p>\n<pre><code class=\"language-Java\">@Slf4j\npublic class DelErrorHandler extends DefaultErrorHandler &#123;\n\n    public DelErrorHandler(FixedBackOff backOff) &#123;\n        super(null,backOff);\n    &#125;\n\n    @Override\n    public void handleRemaining(Exception thrownException, List&lt;ConsumerRecord&lt;?, ?&gt;&gt; records, Consumer&lt;?, ?&gt; consumer, MessageListenerContainer container) &#123;\n        super.handleRemaining(thrownException, records, consumer, container);\n        log.info(&quot;重试多次失败&quot;);\n        // 自定义操作\n    &#125;\n&#125;\n</code></pre>\n<p><code>DefaultErrorHandler</code>  只是默认的一个错误处理器，Spring Kafka 还提供了  <code>CommonErrorHandler</code>  接口。手动实现  <code>CommonErrorHandler</code>  就可以实现更多的自定义操作，有很高的灵活性。例如根据不同的错误类型，实现不同的重试逻辑以及业务逻辑等。</p>\n<h4 id=\"重试最大次数失败后如何再次处理该消息\"><a class=\"anchor\" href=\"#重试最大次数失败后如何再次处理该消息\">#</a> 重试最大次数失败后，如何再次处理该消息？</h4>\n<p>当达到最大重试次数后，消息数据会被直接跳过，继续向后进行。当代码修复后，如何重新消费这些重试失败的消息数据呢？</p>\n<p><strong>死信队列（Dead Letter Queue，简称 DLQ）</strong> 是消息中间件中的一种特殊队列。它主要 **<font color='red'>用于处理无法被 Comsumer 正确处理的消息</font>**，通常是因为<font color='red'>消息格式错误、处理失败、消费超时</font>等情况导致的消息被 &quot;丢弃&quot; 或 &quot;死亡&quot; 的情况。</p>\n<p>当消息进入队列后，消费者会尝试处理它。如果处理失败，或者超过一定的重试次数仍无法被成功处理，消息可以发送到死信队列中，而不是被永久性地丢弃。<font color='red'>在死信队列中，可以进一步分析、处理这些无法正常消费的消息，以便定位问题、修复错误，并采取适当的措施</font>。</p>\n<h4 id=\"重试注解-retryabletopic\"><a class=\"anchor\" href=\"#重试注解-retryabletopic\">#</a> 重试注解  <code>@RetryableTopic</code></h4>\n<p>这是 Spring Kafka 中的一个注解，<strong><font color='red'>用于配置某个 Topic 支持消息重试</font></strong>，更推荐使用这个注解来完成重试。</p>\n<pre><code class=\"language-Java\">// 重试 5 次，重试间隔 100 毫秒,最大间隔 1 秒\n@RetryableTopic(\n        attempts = &quot;5&quot;,\n        backoff = @Backoff(delay = 100, maxDelay = 1000)\n)\n@KafkaListener(topics = &#123;KafkaConst.TEST_TOPIC&#125;, groupId = &quot;apple&quot;)\nprivate void customer(String message) &#123;\n    log.info(&quot;kafka customer:&#123;&#125;&quot;, message);\n    Integer n = Integer.parseInt(message);\n    if (n % 5 == 0) &#123;\n        throw new RuntimeException();\n    &#125;\n    System.out.println(n);\n&#125;\n</code></pre>\n<p>当达到最大重试次数后，如果仍然无法成功处理消息，消息会被发送到对应的死信队列中。<font color='red'>对于死信队列的处理，既可以用  <code>@DltHandler</code>  处理，也可以使用  <code>@KafkaListener</code>  重新消费</font>。</p>\n<h3 id=\"面试题kafka-消费组有什么特性\"><a class=\"anchor\" href=\"#面试题kafka-消费组有什么特性\">#</a> 【面试题】kafka 消费组有什么特性？</h3>\n<p>Kafka 消费组：是 Kafka 提供的<font color='red'>可扩展、具有容错性的 Comsumer 机制</font>。同一个消费组的多个 Comsumer 能分布到多个物理机器上<font color='red'>加速消费</font>，同时也可以实现<font color='red'>负载均衡</font>。</p>\n<p>当某个 Comsumer 宕机时，其他 Comsumer 可以继续消费该 Partition 的数据，从而保证了<font color='red'>数据的可靠性和持久性</font>。</p>\n<p>因此，Kafka 消费组有以下特性：</p>\n<ul>\n<li>同一个消费组内的<font color='red'>所有 Comsumer 共享一个公共 ID</font>。</li>\n<li>消费组内的<font color='red'>每个 Comsumer 都有自己的 offset (偏移量)</font>，用于记录已经消费过的消息位置。</li>\n<li>消费组内的<font color='red'>每个 Comsumer 可以处理 Partition 中的所有消息</font>。</li>\n</ul>\n<h3 id=\"面试题kafka-多-topic-为什么有性能问题\"><a class=\"anchor\" href=\"#面试题kafka-多-topic-为什么有性能问题\">#</a> 【面试题】kafka 多 topic 为什么有性能问题？</h3>\n<p>kafka 多 topic 可能会导致性能问题的<font color='gree'>原因</font>：</p>\n<ul>\n<li><strong>Partition 数量增加</strong>：每个 topic 都会被分成多个 Partition，当有大量的 topic 存在时， Partition 数量也会相应增加。这会导致 Kafka 需要处理更多的 Partition，增加了系统的负载和资源消耗。</li>\n<li><strong>网络开销增加</strong>：Kafka 的多 topic 会导致更多的网络通信开销。当一个 Producer 同时向多个 topic 发送消息时，需要建立多个网络连接，并且需要维护多个网络通信的状态。这增加了网络开销和延迟。</li>\n<li><strong>资源竞争</strong>：多个 topic 同时进行读写操作时，会引起资源的竞争。例如，多个 Comsumer 同时消费不同的 topic，会导致 Comsumer 之间的竞争和争夺资源的情况，从而影响系统的性能。</li>\n<li><strong>数据分布不均衡</strong>：当有大量的 topic 存在时，数据的分布可能会不均衡。某些 topic 可能会有更多的数据量，而某些 topic 可能会有较少的数据量。这会<font color='red'>导致某些 broker 负载过重</font>，而其他 broker 负载较轻，从而影响整个系统的性能。</li>\n</ul>\n<p>为了解决这些性能问题，可以采取以下<font color='gree'>措施</font>：</p>\n<ul>\n<li><strong>合并 topic</strong>：如果有多个 topic 的数据量较小，可以考虑将它们合并为一个 topic，减少分区数量和网络开销。</li>\n<li><strong>增加资源</strong>：<font color='red'>增加 Kafka 集群的 broker 数量和 C omsumer 数量</font>，以便更好地处理多 topic 的负载。</li>\n<li><strong>均衡数据分布</strong>：通过调整 Partition 分配策略，使得数据在各个 broker 上均衡分布，避免负载不均的情况。</li>\n<li><strong>使用分区策略</strong>：根据业务需求，合理地选择分区策略，避免数据集中在某个 Partition 或某个 broker 上。</li>\n<li><strong>优化网络通信</strong>：通过合理的网络配置和优化，减少网络开销和延迟，提高系统的性能。</li>\n</ul>\n<h2 id=\"rocketmq-2\"><a class=\"anchor\" href=\"#rocketmq-2\">#</a> RocketMQ</h2>\n<p>RocketMQ 是一款功能强大的<strong>分布式消息系统</strong>，广泛应用于多个领域，包括异步通信解耦、企业解决方案、金融支付、电信、电子商务、快递物流、广告营销、社交、即时通信、移动应用、手游、视频、物联网、车联网等。</p>\n<p>RocketMQ 源码地址：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2FwYWNoZS9yb2NrZXRtcQ==\">https://github.com/apache/rocketmq</span></p>\n<p>RocketMQ 官方网站：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9yb2NrZXRtcS5hcGFjaGUub3JnL3poLw==\">https://rocketmq.apache.org</span></p>\n<p>文章描述 RocketMQ 相关概念和知识，如无特别声明，均是  <code>Apache RocketMQ 4.x</code>  版本。</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRlZS5jb20vbmFnZW9mZmVyL3NwcmluZ2Jvb3QtbGFkZGVy\">🔥SpringBoot Ladder</span>：从零到一学习 SpringBoot 各种组件框架实战的项目，让 Demo 变得简单。咱们文章中的 RocketMQ 示例也在这个项目。</p>\n<h3 id=\"使用场景\"><a class=\"anchor\" href=\"#使用场景\">#</a> 使用场景</h3>\n<h4 id=\"异步解耦\"><a class=\"anchor\" href=\"#异步解耦\">#</a> <mark>异步解耦</mark></h4>\n<p>最常见的一个场景是用户注册后，需要发送注册邮件和短信通知，以告知用户注册成功。传统的做法有以下两种：</p>\n<h5 id=\"串行方式\"><a class=\"anchor\" href=\"#串行方式\">#</a> 串行方式</h5>\n<p>串行方式下的注册流程如下图所示。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/p429262.png\" alt=\"img\" /></p>\n<p>数据流动如下所述：</p>\n<ol>\n<li>您在注册页面填写账号和密码并提交注册信息，这些注册信息首先会被写入注册系统。</li>\n<li>注册信息写入注册系统成功后，再发送请求至邮件通知系统。邮件通知系统收到请求后向用户发送邮件通知。</li>\n<li>邮件通知系统接收注册系统请求后再向下游的短信通知系统发送请求。短信通知系统收到请求后向用户发送短信通知。</li>\n</ol>\n<p>以上三个任务全部完成后，才返回注册结果到客户端，用户才能使用账号登录。</p>\n<p>假设每个任务耗时分别为 50ms，则用户需要在注册页面等待总共 150ms 才能登录。</p>\n<h5 id=\"并行方式\"><a class=\"anchor\" href=\"#并行方式\">#</a> 并行方式</h5>\n<p>并行方式下的注册流程如下图所示。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/p429331.png\" alt=\"img\" /></p>\n<p>数据流动如下所述：</p>\n<ol>\n<li>用户在注册页面填写账号和密码并提交注册信息，这些注册信息首先会被写入注册系统。</li>\n<li>注册信息写入注册系统成功后，再<font color='red'>同时发送请求至邮件和短信通知系统</font>。邮件和短信通知系统收到请求后分别向用户发送邮件和短信通知。</li>\n</ol>\n<p>以上两个任务全部完成后，才返回注册结果到客户端，用户才能使用账号登录。</p>\n<p>假设每个任务耗时分别为 50ms，其中，邮件和短信通知并行完成，则用户需要在注册页面等待总共 100ms 才能登录。</p>\n<h5 id=\"异步解耦-2\"><a class=\"anchor\" href=\"#异步解耦-2\">#</a> 异步解耦</h5>\n<p>对于用户来说，注册功能实际只需要注册系统存储用户的账户信息后，该用户便可以登录，后续的注册短信和邮件不是即时需要关注的步骤。</p>\n<p>对于注册系统而言，发送注册成功的短信和邮件通知并不一定要绑定在一起同步完成，所以实际<font color='red'>当数据写入注册系统后，注册系统就可以把其他的操作放入对应的 RocketMQ 中然后马上返回用户结果，由 RocketMQ 异步地进行这些操作</font>。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/p429333.png\" alt=\"img\" /></p>\n<p>数据流动如下所述：</p>\n<ol>\n<li>用户在注册页面填写账号和密码并提交注册信息，这些注册信息首先会被写入注册系统。</li>\n<li><font color='red'>注册信息写入注册系统成功后，再发送消息至 RocketMQ。RocketMQ 会马上返回响应给注册系统，注册完成。用户可立即登录。</font></li>\n<li><font color='red'>下游的邮件和短信通知系统订阅 RocketMQ 的此类注册请求消息</font>，即可向用户发送邮件和短信通知，完成所有的注册流程。</li>\n</ol>\n<p>用户只需在注册页面等待注册数据写入注册系统和 RocketMQ 的时间，即等待 55ms 即可登录。</p>\n<h4 id=\"流量削峰\"><a class=\"anchor\" href=\"#流量削峰\">#</a> <mark>流量削峰</mark></h4>\n<p>流量削峰也是 RocketMQ 的常用场景，一般在<font color='red'>秒杀或团队抢购</font>活动中使用广泛。</p>\n<p>在秒杀或团队抢购活动中，由于<font color='red'>用户请求量较大</font>，导致流量暴增，秒杀的应用在处理如此大量的访问流量后，下游的通知系统无法承载海量的调用量，甚至会导致系统崩溃等问题而发生漏通知的情况。为解决这些问题，<font color='red'>可在应用和下游通知系统之间加入 RocketMQ</font>。</p>\n<p><img data-src=\"https://images-machen.oss-cn-beijing.aliyuncs.com/p429350.png\" alt=\"img\" /></p>\n<p>秒杀处理流程如下所述：</p>\n<ol>\n<li>用户发起海量秒杀请求到秒杀业务处理系统。</li>\n<li>秒杀处理系统按照秒杀处理逻辑<font color='red'>将满足秒杀条件的请求发送 RocketMQ</font>。</li>\n<li><font color='red'>下游的通知系统订阅 RocketMQ 的秒杀相关消息</font>，再将秒杀成功的消息发送到相应用户。</li>\n<li>用户收到秒杀成功的通知。</li>\n</ol>\n<h4 id=\"顺序消息\"><a class=\"anchor\" href=\"#顺序消息\">#</a> 顺序消息</h4>\n<blockquote>\n<p>详细请见 “消息类型 - 顺序消息” 小节</p>\n</blockquote>\n<p>顺序消息是 RocketMQ 提供的<strong>一种对消息发送、消费顺序有严格要求的消息</strong>。</p>\n<h4 id=\"分布式模缓存同步\"><a class=\"anchor\" href=\"#分布式模缓存同步\">#</a> 分布式模缓存同步</h4>\n<p>双十一大促时，各个分会场会有琳琅满目的商品，每件商品的价格都会实时变化。使用缓存技术也无法满足对商品价格的访问需求，缓存服务器网卡满载。访问较多次商品价格查询影响会场页面的打开速度。</p>\n<p>此时需要提供一种广播机制，一条消息本来只可以被集群的一台机器消费，如果使用 RocketMQ 的<strong>广播消费模式</strong>，那么<font color='red'>这条消息会被所有节点消费一次，相当于把价格信息同步到需要的每台机器上，取代缓存的作用</font>。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/TB1ki7KXgMPMeJjy1XdXXasrXXa-1530-1140.png\" alt=\"img\" /></p>\n<h4 id=\"分布式定时延时调度\"><a class=\"anchor\" href=\"#分布式定时延时调度\">#</a> 分布式定时 / 延时调度</h4>\n<blockquote>\n<p>详细请见 “消息类型 - 定时消息” 小节</p>\n</blockquote>\n<p>RocketMQ 提供<strong>精确度到秒级的分布式定时消息能力</strong>（5.0 架构后），可广泛应用于<font color='red'>订单超时中心处理、分布式延时调度系统</font>等场景。</p>\n<h3 id=\"消息类型\"><a class=\"anchor\" href=\"#消息类型\">#</a> 消息类型</h3>\n<h4 id=\"普通消息\"><a class=\"anchor\" href=\"#普通消息\">#</a> 普通消息</h4>\n<p>普通消息一般应用于微服务解耦、事件驱动、数据集成等场景，这些场景大多数要求数据传输通道具有可靠的传输能力，且<font color='red'>对消息的处理时机、处理顺序没有特别要求</font>。</p>\n<p>以在线的电商交易场景为例，上游订单系统将用户下单支付这一业务事件封装成独立的普通消息并发送至 RocketMQ 服务端，下游按需从服务端订阅消息，并按照本地消费逻辑处理下游任务。<font color='red'>每个消息之间都是相互独立的，且不需要产生关联</font>。</p>\n<p>另外还有日志系统，以离线的日志收集场景为例，通过埋点组件收集前端应用的相关操作日志，并转发到 RocketMQ 。</p>\n<p><font color='gree'>普通消息的生命周期</font>：</p>\n<p><img data-src=\"https://rocketmq.apache.org/zh/assets/images/lifecyclefornormal-e8a2a7e42a0722f681eb129b51e1bd66.png\" alt=\"img\" /></p>\n<ul>\n<li><font color='cornflowerblue'>初始化（Initialized）</font>：消息被 Producer 构建并完成初始化，<font color='red'>待发送到服务端</font>的状态。</li>\n<li><font color='cornflowerblue'>待消费（Ready）</font>：<font color='red'>消息被发送到服务端</font>，对 Consumer 可见，等待消费的状态。</li>\n<li><font color='cornflowerblue'>消费中（Inflight）</font>：<font color='red'>消息被 Consumer 获取</font>，并按照其本地的业务逻辑进行处理的过程。此时服务端会等待 Consumer 完成消费并提交消费结果，如果一定时间后没有收到 Consumer 的响应，RocketMQ 会对消息进行<font color='red'>重试</font>处理。</li>\n<li><font color='cornflowerblue'>消费提交（Acked）</font>：Consumer 完成消费处理，并向服务端提交消费结果，服务端标记当前消息已经被处理（包括消费成功和失败）。RocketMQ 默认支持保留所有消息，此时消息数据并不会立即被删除，<font color='red'>只是逻辑标记已消费</font>。消息在保存时间到期或存储空间不足被删除前，<font color='red'>Consumer 仍然可以回溯消息，重新消费</font>。</li>\n<li><font color='cornflowerblue'>消息删除（Deleted）</font>：RocketMQ 按照消息保存机制滚动清理最早的消息数据，<font color='red'>将消息从物理文件中删除</font>。</li>\n</ul>\n<h4 id=\"定时消息\"><a class=\"anchor\" href=\"#定时消息\">#</a> 定时消息</h4>\n<p>在分布式定时调度触发、任务超时处理等场景，需要实现精准、可靠的定时事件触发。使用 RocketMQ 的定时消息可以<font color='red'>简化定时调度任务的开发逻辑</font>，实现高性能、可扩展、高可靠的定时触发能力。</p>\n<p><strong><font color='red'>定时消息仅支持在 MessageType 为 Delay 的 Topic 内使用</font></strong>，即定时消息只能发送至类型为定时消息的 Topic 中，发送的消息的类型必须和 Topic 的类型一致。</p>\n<p>基于定时消息的超时任务处理具备如下优势：</p>\n<ul>\n<li><font color='red'>定时精度高、开发门槛低</font>：消息定时时间不存在阶梯间隔，可以轻松实现任意精度事件触发，无需业务去重。</li>\n<li><font color='red'>高性能、可扩展</font>：传统的定时实现方案较为复杂，需要进行数据库扫描，容易遇到性能瓶颈的问题，RocketMQ 可以基于定时消息特性完成事件驱动，实现百万级消息 TPS 能力。</li>\n</ul>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/p433720.png\" alt=\"img\" /></p>\n<p><font color='gree'>定时消息的生命周期</font>：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/lifecyclefordelay-2ce8278df69cd026dd11ffd27ab09a17.png\" alt=\"img\" /></p>\n<ul>\n<li><font color='cornflowerblue'>初始化（Initialized）</font>：消息被生产者构建并完成初始化，待发送到服务端的状态。</li>\n<li><strong><font color='cornflowerblue'>定时中（In timing）</font></strong>：消息被发送到服务端，和普通消息不同的是，<strong>服务端不会直接构建消息索引，而是会将定时消息单独存储在定时存储系统中，等待定时时刻到达</strong>。</li>\n<li><font color='cornflowerblue'>待消费（Ready）</font>：<strong>定时时刻到达后，服务端将定时消息重新写入普通存储引擎，对下游消费者可见</strong>，等待消费者消费的状态。</li>\n<li><font color='cornflowerblue'>消费中（Inflight）</font>：消息被消费者获取，并按照消费者本地的业务逻辑进行处理的过程。此时服务端会等待消费者完成消费并提交消费结果，如果一定时间后没有收到消费者的响应，RocketMQ 会对消息进行重试处理。</li>\n<li><font color='cornflowerblue'>消费提交（Acked）</font>：消费者完成消费处理，并向服务端提交消费结果，服务端标记当前消息已经被处理（包括消费成功和失败）。RocketMQ 默认支持保留所有消息，此时消息数据并不会立即被删除，只是逻辑标记已消费。消息在保存时间到期或存储空间不足被删除前，消费者仍然可以回溯消息重新消费。</li>\n<li><font color='cornflowerblue'>消息删除（Deleted）</font>：Apache RocketMQ 按照消息保存机制滚动清理最早的消息数据，将消息从物理文件中删除。</li>\n</ul>\n<p>定时消息的实现逻辑：先经过定时存储等待触发，<font color='red'>定时时间到达后才会被投递给 Consumer</font>。因此，如果将大量定时消息的定时时间设置为同一时刻，则到达该时刻后会有大量消息同时需要被处理，会造成系统压力过大，导致消息分发延迟，影响定时精度。</p>\n<h4 id=\"顺序消息-2\"><a class=\"anchor\" href=\"#顺序消息-2\">#</a> 顺序消息</h4>\n<p>顺序消息是 RocketMQ 提供的<strong>一种对消息发送、消费顺序有严格要求的消息</strong>。<strong><font color='red'>顺序消息仅支持在 MessageType 为 FIFO 的 Topic 内使用</font></strong>，对于一个指定的 Topic，消息严格按照<font color='red'>先进先出（FIFO）</font>的原则进行消息发布和消费，即先发布的消息先消费，后发布的消息后消费。</p>\n<p>顺序消息分为分区顺序消息和全局顺序消息。</p>\n<ul>\n<li><strong><font color='cornflowerblue'>分区顺序消息</font></strong>：对于指定的一个 Topic，所有消息<font color='red'>根据 Sharding Key 进行区块分区</font>，同一个 Partition 内的消息按照严格的先进先出（FIFO）原则进行发布和消费。<strong><font color='red'>同一 Partition 内的消息保证顺序，不同 Partition 之间的消息顺序不做要求</font></strong>。\n<ul>\n<li>适用场景：适用于性能要求高，以 Sharding Key 作为分区字段，在同一个区块中严格地按照先进先出（FIFO）原则进行消息发布和消费的场景。</li>\n<li>示例\n<ul>\n<li>用户注册需要<font color='red'>发送验证码</font>，以用户 ID 作为 Sharding Key，那么同一个用户发送的消息都会按照发布的先后顺序来消费。</li>\n<li>电商的<font color='red'>订单创建</font>，以订单 ID 作为 Sharding Key，那么同一个订单相关的创建订单消息、订单支付消息、订单退款消息、订单物流消息都会按照发布的先后顺序来消费。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong><font color='cornflowerblue'>全局顺序消息</font></strong>：<strong><font color='red'>对于指定的一个 Topic，所有消息按照严格的先入先出（FIFO）的顺序来发布和消费</font></strong>。\n<ul>\n<li>适用场景：适用于性能要求不高，所有的消息严格按照 FIFO 原则来发布和消费的场景。</li>\n<li>示例：在证券处理中，以人民币兑换美元为 Topic，在价格相同的情况下，先出价者优先处理，则可以按照 FIFO 的方式发布和消费全局顺序消息。</li>\n</ul>\n</li>\n</ul>\n<p><strong><font color='red'>全局顺序消息实际上是一种特殊的分区顺序消息，即 Topic 中只有一个分区</font></strong>，因此全局顺序和分区顺序的实现原理相同。因为分区顺序消息有多个分区，所以<font color='red'>分区顺序消息比全局顺序消息的并发度和性能更高</font>。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/p326576.png\" alt=\"img\" /></p>\n<p>和普通消息发送相比，<font color='red'>顺序消息发送必须要设置消息组</font>（推荐实现 MessageQueueSelector 的方式，见下文）。要保证消息的顺序性需要单一 Producer 串行发送。</p>\n<p>单线程使用 MessageListenerConcurrently 可以顺序消费，多线程环境下使用 MessageListenerOrderly 才能顺序消费。</p>\n<h4 id=\"事务消息\"><a class=\"anchor\" href=\"#事务消息\">#</a> 事务消息</h4>\n<h3 id=\"基础概念\"><a class=\"anchor\" href=\"#基础概念\">#</a> 基础概念</h3>\n<blockquote>\n<p>RocketMQ 消息模型：<strong>在一个  <code>Topic</code>  中配置多个  <code>Queue</code> ，并且每个  <code>Queue</code>  维护每个  <code>Consumer组</code>  的  <code>offset</code> （消费位置）</strong> 实现了 <strong>主题模式 / 发布订阅模式</strong>。</p>\n</blockquote>\n<h4 id=\"topic-主题\"><a class=\"anchor\" href=\"#topic-主题\">#</a> Topic 主题</h4>\n<p><strong>Topic 是消息传输和存储的顶层容器，用于标识同一类业务逻辑的消息</strong>。Topic 的作用主要如下：</p>\n<ul>\n<li><strong>定义数据的分类隔离</strong>：在 Apache RocketMQ 的方案设计中，<font color='red'>建议将不同业务类型的数据拆分到不同的 Topic 中管理，实现存储的隔离性和订阅隔离性</font>。</li>\n<li><strong>定义数据的身份和权限</strong>：Apache RocketMQ 的消息本身是匿名无身份的<font color='red'>，同一分类的消息使用相同的 Topic 来做身份识别和权限管理</font>。</li>\n</ul>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/archifortopic-ef512066703a22865613ea9216c4c300.png\" alt=\"img\" /></p>\n<h4 id=\"queue-队列\"><a class=\"anchor\" href=\"#queue-队列\">#</a> Queue 队列</h4>\n<blockquote>\n<p>类似于 **Kafka 中的 Partition（分区）** 这一概念？</p>\n</blockquote>\n<p><strong>Queue 是消息存储和传输的实际容器，也是消息的最小存储单元</strong>。<font color='red'>每个 Topic 都是由多个 Queue 组成的</font>，以此实现 Queue 数量的水平拆分和 Queue 内部的流式存储。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/archiforqueue-dd6788b33bf2fc96b4a1dab83a1b0d71.png\" alt=\"img\" /></p>\n<h4 id=\"message-消息\"><a class=\"anchor\" href=\"#message-消息\">#</a> Message 消息</h4>\n<p><strong>Message 是最小数据传输单元</strong>。Producer 将业务数据的负载和拓展属性包装成 Message 发送到 Apache RocketMQ 服务端，服务端按照相关语义将 Message 投递到消费端进行消费。</p>\n<h4 id=\"producer-生产者\"><a class=\"anchor\" href=\"#producer-生产者\">#</a> Producer 生产者</h4>\n<p>发布消息的角色。<strong>Producer 通过 MQ 的负载均衡模块选择相应的 Broker 集群队列进行消息投递，投递的过程支持快速失败和重试</strong>。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/archiforproducer-ebb8ff832f6e857cbebc2c17c2044a3b.png\" alt=\"img\" /></p>\n<h4 id=\"consumer-消费者\"><a class=\"anchor\" href=\"#consumer-消费者\">#</a> Consumer 消费者</h4>\n<p>消息消费的角色。</p>\n<ul>\n<li>支持以 ** 推（push）、拉（pull）** 两种模式对消息进行消费。</li>\n<li>同时也支持<strong>集群方式</strong>和<strong>广播方式</strong>的消费。</li>\n<li>提供<strong>实时消息订阅机制</strong>，可以满足大多数用户的需求。</li>\n</ul>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/archiforconsumer-24914573add839fdf2ba2cbc0fcab7c4.png\" alt=\"img\" /></p>\n<h4 id=\"broker-代理服务器\"><a class=\"anchor\" href=\"#broker-代理服务器\">#</a> <mark>Broker 代理服务器</mark></h4>\n<p><strong>Broker 负责消息的存储、投递和查询，并保证服务高可用</strong>。其实 Broker 就是 MQ 服务器，Producer 生产消息到 Broker，Consumer 从 Broker 拉取并消费消息。</p>\n<p><font color='gree'>Broker、Topic、Queue 的关系</font>：</p>\n<ul>\n<li>一个 Topic 中存在多个 Queue</li>\n<li>一个 Topic 分布在多个 Broker 上，而一个 Broker 可以配置多个 Topic，即 <font color='red'>Topic 和 Broker 之间是多对多的关系</font></li>\n</ul>\n<p>如果某个 Topic 消息量很大，应该给它多配置几个 Queue (提高并发能力)，并且<strong>尽量多分布在不同 Broker 上，以减轻某个 Broker 的压力</strong>。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/16ef38687488a5a4.jpg\" alt=\"img\" /></p>\n<p>Broker 集群遵从 <strong>Master-Slave 架构</strong> ：</p>\n<ul>\n<li>Broker 分为 Master 与 Slave</li>\n<li>一个 Master 可以对应多个 Slave，但是一个 Slave 只能对应一个 Master</li>\n<li>Master 与 Slave 的对应关系通过指定相同的 BrokerName，不同的 BrokerId 来定义，<font color='red'>BrokerId 为 0 表示 Master</font>，非 0 表示 Slave</li>\n<li>Master 也可以部署多个</li>\n</ul>\n<h4 id=\"nameserver-名字服务器\"><a class=\"anchor\" href=\"#nameserver-名字服务器\">#</a> <mark>NameServer 名字服务器</mark></h4>\n<blockquote>\n<p>为 Broker 和 Producer、Consumer 解耦，类似于 SpringCloud 中的 Eureka / Nacos</p>\n</blockquote>\n<p>NameServer 是一个简单的 <strong>Broker 路由注册中心</strong>，支持 Broker 的注册与发现，主要提供两个功能：</p>\n<ul>\n<li><strong>Broker 管理</strong>：\n<ul>\n<li><font color='red'>NameServer 接受并保存 Broker 所提交的注册信息，作为 Broker 路由表的基本数据</font></li>\n<li><font color='red'>提供心跳检测机制，检查 Broker 是否还存活</font></li>\n</ul>\n</li>\n<li><strong>路由信息管理</strong>：\n<ul>\n<li>每个 NameServer 保存了关于 Broker 集群的整个路由信息、用于客户端查询的 Queue 信息</li>\n<li><font color='red'>Producer 和 Consumer 通过 NameServer 中的 Broker 路由表就可以知道整个 Broker 集群的路由信息，从而和对应的 Broker 进行消息的投递和消费</font>（Producer 和 Consumer 定期会向 NameServer 查询相关的 Broker 信息）</li>\n</ul>\n</li>\n</ul>\n<p><font color='red'>NameServer 通常会有多个实例部署，各实例间相互不进行信息通讯</font>。<font color='red'>Broker 向每一台 NameServer 注册自己的路由信息</font>，所以每一个 NameServer 实例上面都保存一份完整的路由信息。当某个 NameServer 因某种原因下线了，客户端仍然可以向其它 NameServer 获取路由信息。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/16ef386c6d1e8bdb.jpg\" alt=\"img\" /></p>\n<center>Producer、Consumer、Broker、NameServer</center>\n<blockquote>\n<p>上图中的四个角色实际上都需要做集群。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/16ef386fa3be1e53.jpg\" alt=\"img\" /></p>\n<center>官方架构图</center>\n<ul>\n<li><strong> <code>Broker</code>  做了集群，并且还进行了主从部署</strong>：由于消息分布在各个  <code>Broker</code>  上，一旦某个  <code>Broker</code>  宕机，则该  <code>Broker</code>  上的消息读写都会受到影响。所以  <code>RocketMQ</code>  提供了  <code>master/slave</code>  的结构， <code>salve</code>  定时从  <code>master</code>  同步数据 (同步刷盘或者异步刷盘)，<strong>如果  <code>master</code>  宕机，则  <code>slave</code>  提供消费服务，但是不能写入消息</strong> (后面我还会提到哦)。</li>\n<li><strong>为了保证高可用  <code>HA</code> ， <code>NameServer</code>  也做了集群部署，但它是去中心化的</strong>：意味着  <code>NameServer</code>  没有 master 节点，在  <code>RocketMQ</code>  中是通过 <strong>单个 Broker 和所有 NameServer 保持长连接</strong> ，并且  <code>Broker</code>  会定期向所有  <code>Nameserver</code>  发送心跳，其中包含了自身的  <code>Topic</code>  配置信息，这个步骤就对应图中的  <code>Routing Info</code> 。</li>\n<li>在  <code>Producer</code>  需要向  <code>Broker</code>  发送消息的时候，<strong>需要先从  <code>NameServer</code>  获取关于  <code>Broker</code>  的路由信息</strong>，然后通过 <strong>轮询</strong> 的方式向每个 Queue 中生产数据，以达到<strong>负载均衡</strong>的效果。</li>\n<li><code>Comsumer</code>  通过  <code>NameServer</code>  获取所有  <code>Broker</code>  的路由信息后，向  <code>Broker</code>  发送  <code>Pull</code>  请求来获取消息数据。 <code>Consumer</code>  可以以两种模式启动 —— <strong>广播（Broadcast）和集群（Cluster）</strong>：\n<ul>\n<li>广播模式下，一条消息会发送给 <strong>同一个消费组中的所有消费者</strong></li>\n<li>集群模式下消息只会发送给一个消费者</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<h4 id=\"部署模型小结\"><a class=\"anchor\" href=\"#部署模型小结\">#</a> 部署模型小结</h4>\n<ul>\n<li>\n<p>每个 Broker 与 NameServer 集群中的所有节点建立长连接，定时将 Topic 信息注册到所有 NameServer。</p>\n</li>\n<li>\n<p>Producer 与 NameServer 集群中的其中一个节点建立长连接，定期从 NameServer 获取 Topic/Broker 路由信息。并向提供 Topic 服务的 Broker Master 建立长连接，且定时向 Broker Master 发送心跳。Producer 完全无状态。</p>\n</li>\n<li>\n<p>Consumer 与 NameServer 集群中的其中一个节点建立长连接，定期从 NameServer 获取 Topic/Broker 路由信息，并向提供 Topic 服务的 Broker Master、Broker Slave 建立长连接，且定时向 Broker Master、Broker Slave 发送心跳。</p>\n<blockquote>\n<p><font color='red'>Consumer 既可以从 Broker Master 订阅消息，也可以从 Broker Slave 订阅消息</font>。</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"工作原理\"><a class=\"anchor\" href=\"#工作原理\">#</a> 工作原理</h3>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/p68921.png\" alt=\"img\" /></p>\n<h4 id=\"1-启动-nameserver\"><a class=\"anchor\" href=\"#1-启动-nameserver\">#</a> 1、启动 NameServer</h4>\n<p>启动 NameServer。NameServer 启动后监听端口，等待 Broker、Producer、Consumer 连接，相当于一个<font color='red'>路由控制中心</font>。</p>\n<h4 id=\"2-启动-broker\"><a class=\"anchor\" href=\"#2-启动-broker\">#</a> 2、启动 Broker</h4>\n<p>启动 Broker。<font color='red'>与所有 NameServer 保持长连接，定时发送心跳包</font>（包含当前 Broker 信息以及存储的所有 Topic 信息）。注册成功后，NameServer 集群中就有 Topic 跟 Broker 的映射关系。</p>\n<h4 id=\"3-创建-topic\"><a class=\"anchor\" href=\"#3-创建-topic\">#</a> 3、创建 Topic</h4>\n<p><font color='red'>创建 Topic 时需要指定该 Topic 要存储在哪些 Broker 上</font>，也可以在发送消息时自动创建 Topic。</p>\n<h4 id=\"4-producer-发送消息\"><a class=\"anchor\" href=\"#4-producer-发送消息\">#</a> 4、Producer 发送消息</h4>\n<p>Producer 发送消息。启动时先跟 NameServer 集群中的其中一台建立长连接，并从 NameServer 中查询当前发送的 Topic 存在于哪些 Broker 上，轮询从对应 Broker 上的 Queue 列表中选择一个 Queue，然后与该 Queue 所在的 Broker 建立长连接，从而向 Broker 发消息。</p>\n<h4 id=\"5-consumer-接收消息\"><a class=\"anchor\" href=\"#5-consumer-接收消息\">#</a> 5、Consumer 接收消息</h4>\n<p>Consumer 接受消息。跟其中一台 NameServer 建立长连接，获取当前订阅 Topic 存在于哪些 Broker 上，然后直接跟 Broker 建立连接通道，然后开始消费消息。</p>\n<h3 id=\"如何正确发送消息\"><a class=\"anchor\" href=\"#如何正确发送消息\">#</a> 如何正确发送消息</h3>\n<h4 id=\"不建议单一进程创建大量-producer\"><a class=\"anchor\" href=\"#不建议单一进程创建大量-producer\">#</a> 不建议单一进程创建大量 Producer</h4>\n<p>Apache RocketMQ 的 Producer 和 Topic 是多对多的关系，支持同一个 Producer 向多个 Topic 发送消息。<font color='red'>对于 Producer 的创建和初始化，建议遵循够用即可、最大化复用原则</font>，如果有需要发送消息到多个 Topic 的场景，无需为每个 Topic 都创建一个 Producer。</p>\n<h4 id=\"不建议频繁创建和销毁-producer\"><a class=\"anchor\" href=\"#不建议频繁创建和销毁-producer\">#</a> 不建议频繁创建和销毁 Producer</h4>\n<p>Apache RocketMQ 的 <font color='red'>Producer 是可以重复利用的底层资源</font>，类似数据库的连接池。因此不需要在每次发送消息时动态创建 Producer，且在发送结束后销毁 Producer。这样频繁的创建销毁会在服务端产生大量短连接请求，严重影响系统性能。</p>\n<p>正确示例：</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token class-name\">Producer</span> p <span class=\"token operator\">=</span> <span class=\"token class-name\">ProducerBuilder</span><span class=\"token punctuation\">.</span><span class=\"token function\">build</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">&lt;</span>n<span class=\"token punctuation\">;</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token class-name\">Message</span> m<span class=\"token operator\">=</span> <span class=\"token class-name\">MessageBuilder</span><span class=\"token punctuation\">.</span><span class=\"token function\">build</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    p<span class=\"token punctuation\">.</span><span class=\"token function\">send</span><span class=\"token punctuation\">(</span>m<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre> <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>p<span class=\"token punctuation\">.</span><span class=\"token function\">shutdown</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h3 id=\"consumer-分类\"><a class=\"anchor\" href=\"#consumer-分类\">#</a> Consumer 分类</h3>\n<ul>\n<li>PushConsumer</li>\n<li>SimpleConsumer</li>\n<li>PullConsumer</li>\n</ul>\n<h3 id=\"producer-和-consumer-分组\"><a class=\"anchor\" href=\"#producer-和-consumer-分组\">#</a> Producer 和 Consumer 分组</h3>\n<h4 id=\"producer-分组\"><a class=\"anchor\" href=\"#producer-分组\">#</a> Producer 分组</h4>\n<p>RocketMQ 服务端 5.x 版本开始，<strong>Producer 是匿名的，无需管理 Producer 分组（ProducerGroup）</strong>。</p>\n<p>对于历史版本服务端 3.x 和 4.x 版本，已经使用的 ProducerGroup 可以废弃无需再设置，且不会对当前业务产生影响。</p>\n<h4 id=\"consumer-分组\"><a class=\"anchor\" href=\"#consumer-分组\">#</a> Consumer 分组</h4>\n<p><strong>Consumer 分组是多个消费行为一致的 Consumer 的负载均衡分组</strong>。Consumer  分组不是具体实体而是一个逻辑资源。通过 Consumer 分组实现消费性能的水平扩展以及高可用容灾。</p>\n<p>Consumer 分组中的订阅关系、投递顺序性、消费重试策略是一致的。</p>\n<ul>\n<li>订阅关系：Apache RocketMQ 以 Consumer 分组的粒度管理订阅关系，实现订阅关系的管理和追溯。</li>\n<li>投递顺序性：Apache RocketMQ 的服务端将消息投递给 Consumer 消费时，支持顺序投递和并发投递，投递方式在 Consumer 分组中统一配置。</li>\n<li>消费重试策略：Consumer 消费消息失败时的重试策略，包括重试次数、死信队列设置等。</li>\n</ul>\n<p>RocketMQ 服务端 5.x 版本：上述 Consumer 的消费行为从关联的 Consumer 分组中统一获取，因此同一分组内所有 Consumer 的消费行为必然是一致的，客户端无需关注。</p>\n<p>RocketMQ 服务端 3.x/4.x 历史版本：上述消费逻辑由消费者客户端接口定义，因此，您需要自己在消费者客户端设置时保证同一分组下的消费者的消费行为一致。[来自官方网站]</p>\n<h3 id=\"如何解决顺序消费-重复消费\"><a class=\"anchor\" href=\"#如何解决顺序消费-重复消费\">#</a> 如何解决顺序消费、重复消费？</h3>\n<p>其实  <code>RocketMQ</code>  的架构基本和  <code>Kafka</code>  类似，只不过：</p>\n<ul>\n<li>RocketMQ 的注册中心是  <code>NameServer</code> ，而 Kafka 的是  <code>Zookeeper</code></li>\n<li>RocketMQ 的 **Queue（队列）** 相当于是 Kafka 的 <strong>Partition（分区）</strong></li>\n</ul>\n<h4 id=\"顺序消费\"><a class=\"anchor\" href=\"#顺序消费\">#</a> 顺序消费</h4>\n<blockquote>\n<p>可以参考 “消息类型 - 顺序消息” 小节</p>\n</blockquote>\n<p><strong> <code>RocketMQ</code>  在 Topic 上是无序的、它只有在 Queue 层面才保证有序</strong>：</p>\n<ul>\n<li><font color='cornflowerblue'>普通顺序（分区顺序消息）</font>：对于一个 Topic，同一 Queue 内的消息保证顺序，不同 Queue 之间的消息顺序不做要求。</li>\n<li><font color='cornflowerblue'>严格顺序（全局顺序消息）</font>：对于指定的一个 Topic，所有消息按照严格的先入先出（FIFO）的顺序来发布和消费。</li>\n</ul>\n<p>严格顺序的代价巨大，而 MQ 一般能容忍短暂的乱序，所以<font color='red'>推荐使用普通顺序模式！</font></p>\n<hr />\n<p>在 Producer 生产消息的时候，会轮询同一 Topic 的不同 Queue 来发送消息。那么如果此时我有几个消息分别是同一个订单的创建、支付、发货，<font color='red'>在轮询的策略下这<strong>三个消息会被发送到不同的 Queue</strong>，那么此时就无法使用  <code>RocketMQ</code>  的队列有序特性来保证消息有序性了</font>。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/16ef3874585e096e.jpg\" alt=\"img\" /></p>\n<p>解决方法很简单，<strong>只需要将同一语义下的消息放入同一个队列</strong>（比如这里是同一个订单)，那我们就可以使用 <strong><font color='red'>Hash 取模法</font></strong> 来保证同一个订单在同一个队列中就行了。</p>\n<p>RocketMQ 实现了两种<font color='gree'> Queue 选择算法</font>：</p>\n<ul>\n<li>\n<p><font color='cornflowerblue'>轮询算法</font></p>\n<ul>\n<li><font color='red'>向消息指定的 Topic 所在 Queue 中依次发送消息</font>，保证消息均匀分布</li>\n<li>是 RocketMQ <font color='red'>默认</font>队列选择算法</li>\n</ul>\n</li>\n<li>\n<p><font color='cornflowerblue'>最小投递延迟算法</font></p>\n<ul>\n<li>\n<p>每次消息投递的时候统计消息投递的延迟，<font color='red'>优先选择消息延时小的 Queue</font>，导致消息分布不均匀，按照如下设置即可。</p>\n</li>\n<li>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>producer<span class=\"token punctuation\">.</span><span class=\"token function\">setSendLatencyFaultEnable</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li>\n<p><font color='cornflowerblue'>继承  <code>MessageQueueSelector</code>  实现自定义的选择算法</font></p>\n<ul>\n<li>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token class-name\">SendResult</span> sendResult <span class=\"token operator\">=</span> producer<span class=\"token punctuation\">.</span><span class=\"token function\">send</span><span class=\"token punctuation\">(</span>msg<span class=\"token punctuation\">,</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">MessageQueueSelector</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token annotation punctuation\">@Override</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token class-name\">MessageQueue</span> <span class=\"token function\">select</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">MessageQueue</span><span class=\"token punctuation\">></span></span> mqs<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Message</span> msg<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Object</span> arg<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>        <span class=\"token comment\">// 从 mqs 中选择一个队列，可以根据 msg 特点选择</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>        <span class=\"token keyword\">return</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Object</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ul>\n<h4 id=\"特殊情况\"><a class=\"anchor\" href=\"#特殊情况\">#</a> 特殊情况</h4>\n<h5 id=\"发送异常\"><a class=\"anchor\" href=\"#发送异常\">#</a> 发送异常</h5>\n<p>选择 Queue 后会与 Broker 建立连接，通过网络请求将消息发送到 Broker 上，如果 Broker 挂了或者网络波动发送消息超时，此时 RocketMQ 会进行重试。</p>\n<p>重新选择其他 Broker 中的 Queue 进行发送，默认重试两次，可以手动设置。</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>producer<span class=\"token punctuation\">.</span><span class=\"token function\">setRetryTimesWhenSendFailed</span><span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h5 id=\"消息过大\"><a class=\"anchor\" href=\"#消息过大\">#</a> 消息过大</h5>\n<p>消息超过 4k 时 RocketMQ 会将消息压缩后再发送到 Broker 上，减少网络资源的占用。</p>\n<h4 id=\"重复消费\"><a class=\"anchor\" href=\"#重复消费\">#</a> 重复消费</h4>\n<p>需求：有一个订单的处理积分的系统 FrancisQ，每当来一个消息的时候它就负责为创建这个订单的用户的积分加上相应的数值。可是有一次，消息队列发送给订单系统 FrancisQ 的订单信息，其要求是给 FrancisQ 的积分加上 500。但是积分系统在收到 FrancisQ 的订单信息处理完成之后返回给消息队列处理成功的信息的时候出现了网络波动 (当然还有很多种情况，比如 Broker 意外重启等等)，这条回应没有发送成功。那么，消息队列没收到积分系统的回应会不会尝试重发这个消息？问题就来了，我再发这个消息，万一它又给 FrancisQ 的账户加上 500 积分怎么办呢？</p>\n<hr />\n<p>解决方法：<strong>让 Consumer 实现幂等校验</strong>！即<font color='red'>对同一个消息的处理结果，执行多少次都不变</font>。</p>\n<blockquote>\n<p>幂等操作的特点：其执行任意多次所产生的影响，均与执行一次的影响相同。</p>\n</blockquote>\n<p>那么如何给业务实现幂等呢？这个还是需要结合具体的业务的。</p>\n<ul>\n<li>可以使用 **<font color='cornflowerblue'>写入  <code>Redis</code> </font>** 来保证，因为  <code>Redis</code>  的  <code>key</code>  和  <code>value</code>  就是天然支持幂等的。</li>\n<li>可以使用 **<font color='cornflowerblue'>数据库插入法</font>**，基于数据库的<font color='red'>唯一键</font>来保证重复数据不会被插入多条。</li>\n</ul>\n<p>需要根据特定场景使用特定的解决方案，你要知道你的消息消费是否是完全不可重复消费还是可以忍受重复消费的，然后再选择强校验和弱校验的方式。毕竟在 CS 领域还是很少有技术银弹的说法。</p>\n<hr />\n<p>而在互联网领域，幂等不仅仅适用于 **<font color='red'>消息队列的重复消费问题</font><strong>，也同样适用于在其他场景中来解决</strong><font color='red'>重复请求或者重复调用的问题</font>**：</p>\n<ul>\n<li>比如将 HTTP 服务设计成幂等的<font color='red'>解决前端或者 APP 重复提交表单数据的问题</font></li>\n<li>可以将一个微服务设计成幂等的，解决  <code>RPC</code>  框架<font color='red'>自动重试导致的重复调用问题</font>。</li>\n</ul>\n<h3 id=\"如何实现分布式事务\"><a class=\"anchor\" href=\"#如何实现分布式事务\">#</a> 如何实现分布式事务？</h3>\n<p>事务指的是要么都执行，要么都不执行。在分布式架构中，很多服务是部署在不同系统之间的，那么如何实现分布式事务呢？常见的分布式事务实现有：</p>\n<ul>\n<li><font color='cornflowerblue'>2PC（两阶段提交）</font>：优点是简单，缺点是同步阻塞、中心化问题、数据不一致、太过保守...</li>\n<li><font color='cornflowerblue'>TCC（Try Confirm/Cancel）</font>：也是 2PC 的一种。</li>\n<li><font color='cornflowerblue'>事务消息（half 半消息机制）</font>：RocketMQ 支持这种类型的消息。</li>\n</ul>\n<p>这三种实现都有特定的使用场景和各自的局限，并不完美。</p>\n<hr />\n<p>RocketMQ 中使用的是<strong>事务消息（half 半消息机制） + 事务反查机制</strong>来解决分布式事务问题的，可以对照着图进行理解。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/16ef38798d7a987f.png\" alt=\"img\" /></p>\n<p>在第 1 步发送的 half 消息，它的意思是<font color='red'>在事务提交之前，对于 Consumer 来说这个消息是不可见的</font>。</p>\n<blockquote>\n<p>那么，如何做到写入消息但是对 Consumer 不可见呢？RocketMQ 事务消息的做法是：</p>\n<ol>\n<li>如果消息是 half 消息，将备份原消息的 Topic 与消息消费队列</li>\n<li>然后<strong>改变 Topic 为 RMQ_SYS_TRANS_HALF_TOPIC</strong>，由于 Consumer 未订阅该 Topic，故无法消费 half 类型的消息。</li>\n<li>然后 <strong>RocketMQ 会开启一个定时任务，从该 Topic 中拉取消息进行消费</strong>，根据 Producer 组获取一个服务提供者，发送回查事务状态请求，根据事务状态来决定是提交或回滚消息。</li>\n</ol>\n</blockquote>\n<p>如果没有从第 5 步开始的<font color='red'>事务反查机制</font>，如果出现网路波动第 4 步没有发送成功，这样就会产生 MQ 不知道是不是需要给 Consumer 消费的问题。在  <code>RocketMQ</code>  中就是使用的上述的事务反查来解决的，而在  <code>Kafka</code>  中通常是直接抛出一个异常让用户来自行解决。</p>\n<p>你还需要注意的是， <code>MQ Server</code>  指向系统 B 的操作已经和系统 A 不相关了，也就是说在消息队列中的分布式事务是：<strong><font color='red'>本地事务和存储消息到消息队列才是同一个事务</font></strong>。这样也就产生了事务的<font color='red'>最终一致性</font>，因为整个过程是异步的，<strong><font color='red'>每个系统只要保证它自己那一部分的事务就行了</font></strong>。</p>\n<h3 id=\"如何解决消息堆积问题\"><a class=\"anchor\" href=\"#如何解决消息堆积问题\">#</a> 如何解决消息堆积问题？</h3>\n<p>在上面我们提到了消息队列的一个很重要的功能 ——<strong> 削峰</strong>。那么如果这个峰值太大了导致消息堆积在队列中怎么办呢？</p>\n<p>其实这个问题可以将它广义化，因为产生消息堆积的根源其实就只有两个：</p>\n<ul>\n<li>\n<p>Producer 生产太快：<strong>限流降级</strong>，或者<strong>增加 Consumer 实例</strong>以水平扩展消费能力（<font color='red'>同时还需要增加每个 Topic 的 Queue 数量</font>）。</p>\n<blockquote>\n<p>别忘了在  <code>RocketMQ</code>  中，<strong>一个 Queue 只会被一个 Consumer 消费</strong> ，如果你仅仅是增加 Consumer 实例就会出现我一开始给你画的架构图的那种情况：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/16ef387d939ab66d.jpg\" alt=\"img\" /></p>\n</blockquote>\n</li>\n<li>\n<p>Consumer 消费太慢：先检查 <strong>Consumer 是否出现了大量的消费错误</strong>，或者打印日志查看是否有哪一个线程卡死，导致了锁资源不释放等问题。</p>\n</li>\n</ul>\n<h3 id=\"回溯消费\"><a class=\"anchor\" href=\"#回溯消费\">#</a> 回溯消费</h3>\n<p>回溯消费是指  <code>Consumer</code>  已经消费成功的消息，由于业务上需求需要重新消费。在  <code>RocketMQ</code>  中， <code>Broker</code>  在向  <code>Consumer</code>  投递成功消息后，<font color='red'>消息仍然需要保留</font>。并且重新消费一般是按照时间维度，例如由于  <code>Consumer</code>  系统故障，恢复后需要重新消费 1 小时前的数据，那么  <code>Broker</code>  要提供一种机制，可以按照时间维度来回退消费进度。 <code>RocketMQ</code>  支持按照时间回溯消费，时间维度精确到毫秒。</p>\n<h3 id=\"如何保证高性能读写\"><a class=\"anchor\" href=\"#如何保证高性能读写\">#</a> 如何保证高性能读写？</h3>\n<blockquote>\n<p>可参考 “Java IO - IO 模型 - NIO” 小节，略了。</p>\n</blockquote>\n<ul>\n<li>传统 IO 方式：即  <code>read + write</code> ，整个过程会发生 4 次上下文切换和 4 次数据的拷贝，这在高并发场景下会严重影响读写性能，故引入了零拷贝技术。\n<ul>\n<li>用户调用 read () 方法，开始读取数据，此时发生一次上下文从用户态到内核态的切换，也就是图示的切换 1</li>\n<li>将磁盘数据通过 DMA 拷贝到内核缓存区</li>\n<li>将内核缓存区的数据拷贝到用户缓冲区，这样用户，也就是我们写的代码就能拿到文件的数据</li>\n<li>read () 方法返回，此时就会从内核态切换到用户态，也就是图示的切换 2</li>\n<li>当我们拿到数据之后，就可以调用 write () 方法，此时上下文会从用户态切换到内核态，即图示切换 3</li>\n<li>CPU 将用户缓冲区的数据拷贝到 Socket 缓冲区</li>\n<li>将 Socket 缓冲区数据拷贝至网卡</li>\n<li>write () 方法返回，上下文重新从内核态切换到用户态，即图示切换 4</li>\n</ul>\n</li>\n<li>零拷贝技术\n<ul>\n<li><code>mmap</code> ：</li>\n<li><code>sendfile</code> ：</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"刷盘机制\"><a class=\"anchor\" href=\"#刷盘机制\">#</a> 刷盘机制</h3>\n<h4 id=\"同步刷盘-异步刷盘\"><a class=\"anchor\" href=\"#同步刷盘-异步刷盘\">#</a> 同步刷盘、异步刷盘</h4>\n<blockquote>\n<p>在单个节点层面</p>\n</blockquote>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/16ef387fba311cda-20230814005009889.jpg\" alt=\"img\" /></p>\n<p><font color='cornflowerblue'>同步刷盘</font>：<strong><font color='red'>需要等待一个刷盘成功的  <code>ACK</code> </font></strong> ，对<font color='red'>消息可靠性</font>来说是一种不错的保障，但是<font color='red'>性能上会有较大影响</font>，一般适用于金融等特定业务场景。</p>\n<p><font color='cornflowerblue'>异步刷盘</font>：<strong><font color='red'>开启一个线程去异步地执行刷盘操作</font></strong>。消息刷盘采用后台异步线程提交的方式进行，<font color='red'>降低了读写延迟</font>，<font color='red'>提高了  <code>MQ</code>  的性能和吞吐量</font>，一般适用于如发验证码等<font color='red'>对于消息保证要求不太高</font>的业务场景。</p>\n<p>一般地，<strong>异步刷盘只有在  <code>Broker</code>  意外宕机的时候会丢失部分数据</strong>，你可以设置  <code>Broker</code>  的参数  <code>FlushDiskType</code>  来调整你的刷盘策略 (ASYNC_FLUSH 或者 SYNC_FLUSH)。</p>\n<h4 id=\"同步复制-异步复制\"><a class=\"anchor\" href=\"#同步复制-异步复制\">#</a> 同步复制、异步复制</h4>\n<blockquote>\n<p>在 Broker 主从模式下，master 返回消息给客户端时是否需要同步 slave</p>\n</blockquote>\n<p><font color='cornflowerblue'>同步复制</font>：也叫 “同步双写”，即<strong>只有消息同步双写到主从节点上时，才返回写入成功</strong>。</p>\n<p><font color='cornflowerblue'>异步复制</font>：<strong>消息写入主节点之后，直接返回写入成功</strong>。</p>\n<p>然而，很多事情是没有完美的方案的，就比如我们进行消息写入的节点越多就更能保证消息的可靠性，但是随之的性能也会下降，所以需要程序员根据特定业务场景去选择适应的主从复制方案。</p>\n<p><font color='red'>异步复制不会像异步刷盘那样影响消息的可靠性</font>，因为两者是不同的概念，对于消息可靠性是通过不同的刷盘策略保证的，而像异步同步复制策略<font color='red'>仅仅是影响到了可用性</font>。为什么呢？其主要原因是 <strong> <code>RocketMQ</code>  是不支持自动主从切换的，当 master 节点挂掉之后，Producer 就不能再给这个 master 节点生产消息了</strong>。</p>\n<p>比如这个时候采用异步复制的方式，在主节点还未发送完需要同步的消息的时候主节点挂掉了，这个时候从节点就少了一部分消息。但是此时生产者无法再给主节点生产消息了，<strong>消费者可以自动切换到从节点进行消费</strong> (仅仅是消费)，所以在主节点挂掉的时间只会产生主从结点短暂的消息不一致的情况，降低了可用性，而当主节点重启之后，从节点那部分未来得及复制的消息还会继续复制。</p>\n<p>在单主从架构中，如果一个主节点挂掉了，那么也就意味着整个系统不能再生产了。那么这个可用性的问题能否解决呢？<strong>一个主从不行那就多个主从的呗</strong>，别忘了在我们最初的架构图中，每个  <code>Topic</code>  是分布在不同  <code>Broker</code>  中的。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/16ef38687488a5asadasfg4.jpg\" alt=\"img\" /></p>\n<p>但是这种复制方式同样也会带来一个问题，那就是无法保证 <strong>严格顺序</strong> 。在上文中我们提到了如何保证的消息顺序性是通过将一个语义的消息发送在同一个队列中，使用  <code>Topic</code>  下的队列来保证顺序性的。如果此时我们主节点 A 负责的是订单 A 的一系列语义消息，然后它挂了，这样其他节点是无法代替主节点 A 的，如果我们任意节点都可以存入任何消息，那就没有顺序性可言了。</p>\n<p>而在  <code>RocketMQ</code>  中采用了  <code>Dledger</code>  解决这个问题。他要求在写入消息的时候，要求<strong>至少消息复制到半数以上的节点之后</strong>，才给客⼾端返回写⼊成功，并且它是⽀持通过选举来动态切换主节点的。这里我就不展开说明了，读者可以自己去了解。</p>\n<blockquote>\n<p>也不是说  <code>Dledger</code>  是个完美的方案，至少在  <code>Dledger</code>  选举过程中是无法提供服务的，而且他必须要使用三个节点或以上，如果多数节点同时挂掉他也是无法保证可用性的，而且要求消息复制半数以上节点的效率和直接异步复制还是有一定的差距的。</p>\n</blockquote>\n<h4 id=\"存储机制\"><a class=\"anchor\" href=\"#存储机制\">#</a> 存储机制</h4>\n<h3 id=\"动手发一条消息\"><a class=\"anchor\" href=\"#动手发一条消息\">#</a> 动手发一条消息</h3>\n<h4 id=\"1-启动-rocketmq\"><a class=\"anchor\" href=\"#1-启动-rocketmq\">#</a> 1、启动 RocketMQ</h4>\n<p><font color='gree'>安装 NameServer</font></p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">docker</span> run <span class=\"token parameter variable\">-d</span> <span class=\"token parameter variable\">-p</span> <span class=\"token number\">9876</span>:9876 <span class=\"token parameter variable\">--name</span> rmqnamesrv foxiswho/rocketmq:server-4.5.1</pre></td></tr></table></figure><p><font color='gree'>安装 Broker</font></p>\n<p>1）新建配置目录。</p>\n<p>如果是 Windows 需要替换为 Windows 的电脑路径，和 Linux 还是有点差异。</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">mkdir</span> <span class=\"token parameter variable\">-p</span> <span class=\"token variable\">$&#123;<span class=\"token environment constant\">HOME</span>&#125;</span>/docker/software/rocketmq/conf</pre></td></tr></table></figure><p>2）新建配置文件 broker.conf。</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>brokerClusterName <span class=\"token operator\">=</span> DefaultCluster</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>brokerName <span class=\"token operator\">=</span> broker-a</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>brokerId <span class=\"token operator\">=</span> <span class=\"token number\">0</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>deleteWhen <span class=\"token operator\">=</span> 04</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>fileReservedTime <span class=\"token operator\">=</span> <span class=\"token number\">48</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>brokerRole <span class=\"token operator\">=</span> ASYNC_MASTER</pre></td></tr><tr><td data-num=\"7\"></td><td><pre>flushDiskType <span class=\"token operator\">=</span> ASYNC_FLUSH</pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token comment\"># 此处为本地 ip, 如果部署服务器，需要填写服务器外网 ip</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>brokerIP1 <span class=\"token operator\">=</span> xx.xx.xx.xx</pre></td></tr></table></figure><p>3）创建容器。</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">docker</span> run <span class=\"token parameter variable\">-d</span> <span class=\"token punctuation\">\\</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token parameter variable\">-p</span> <span class=\"token number\">10911</span>:10911 <span class=\"token punctuation\">\\</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token parameter variable\">-p</span> <span class=\"token number\">10909</span>:10909 <span class=\"token punctuation\">\\</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token parameter variable\">--name</span> rmqbroker <span class=\"token punctuation\">\\</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token parameter variable\">--link</span> rmqnamesrv:namesrv <span class=\"token punctuation\">\\</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token parameter variable\">-v</span> <span class=\"token variable\">$&#123;<span class=\"token environment constant\">HOME</span>&#125;</span>/docker/software/rocketmq/conf/broker.conf:/etc/rocketmq/broker.conf <span class=\"token punctuation\">\\</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token parameter variable\">-e</span> <span class=\"token string\">\"NAMESRV_ADDR=namesrv:9876\"</span> <span class=\"token punctuation\">\\</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token parameter variable\">-e</span> <span class=\"token string\">\"JAVA_OPTS=-Duser.home=/opt\"</span> <span class=\"token punctuation\">\\</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token parameter variable\">-e</span> <span class=\"token string\">\"JAVA_OPT_EXT=-server -Xms512m -Xmx512m\"</span> <span class=\"token punctuation\">\\</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>foxiswho/rocketmq:broker-4.5.1</pre></td></tr></table></figure><p><font color='gree'>安装 RocketMQ 控制台</font></p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">docker</span> pull pangliang/rocketmq-console-ng</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">docker</span> run <span class=\"token parameter variable\">-d</span> <span class=\"token punctuation\">\\</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token parameter variable\">--link</span> rmqnamesrv:namesrv <span class=\"token punctuation\">\\</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token parameter variable\">-e</span> <span class=\"token string\">\"JAVA_OPTS=-Drocketmq.config.namesrvAddr=namesrv:9876 -Drocketmq.config.isVIPChannel=false\"</span> <span class=\"token punctuation\">\\</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token parameter variable\">--name</span> rmqconsole <span class=\"token punctuation\">\\</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token parameter variable\">-p</span> <span class=\"token number\">8088</span>:8080 <span class=\"token punctuation\">\\</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token parameter variable\">-t</span> pangliang/rocketmq-console-ng</pre></td></tr></table></figure><p>运行成功，稍等几秒启动时间，浏览器输入  <code>localhost:8088</code>  查看控制台。</p>\n<h4 id=\"2-发送普通消息\"><a class=\"anchor\" href=\"#2-发送普通消息\">#</a> 2、发送普通消息</h4>\n<p>下述完整 Demo 详情查看<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRlZS5jb20vbmFnZW9mZmVyL3NwcmluZ2Jvb3QtbGFkZGVyL3RyZWUvbWFpbi9tcS1yb2NrZXRtcS00eA==\"> springboot-ladder/mq-rocketmq-4x</span> 项目模块。</p>\n<h5 id=\"21-引入-rocketmq-依赖\"><a class=\"anchor\" href=\"#21-引入-rocketmq-依赖\">#</a> 2.1、引入 RocketMQ 依赖</h5>\n<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.apache.rocketmq&lt;/groupId&gt;\n    &lt;artifactId&gt;rocketmq-spring-boot-starter&lt;/artifactId&gt;\n    &lt;version&gt;2.2.3&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>\n<h5 id=\"22-启动自动装配\"><a class=\"anchor\" href=\"#22-启动自动装配\">#</a> 2.2、启动自动装配</h5>\n<p>因为咱们 Demo 中使用的是 SpringBoot3，RocketMQ 最新版本 2.2.3 没有适配 SpringBoot3，所以需要手动搞定自动装配。</p>\n<blockquote>\n<p>如果 SpringBoot2 版本，就不需要执行这一步。</p>\n</blockquote>\n<p>resources 目录下创建 META-INF/spring 目录，并创建 <code>org.springframework.boot.autoconfigure.AutoConfiguration.imports</code>  文件。</p>\n<figure class=\"highlight properties\"><figcaption data-lang=\".properties\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># RocketMQ 2.2.3 version does not adapt to SpringBoot3</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>org.apache.rocketmq.spring.autoconfigure.RocketMQAutoConfiguration</pre></td></tr></table></figure><p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230924172750462.png\" alt=\"img\" /></p>\n<h5 id=\"23-producer\"><a class=\"anchor\" href=\"#23-producer\">#</a> 2.3、Producer</h5>\n<p>配置文件中引入 RocketMQ 相关配置定义，比如连接 NameServer 地址等。</p>\n<figure class=\"highlight yaml\"><figcaption data-lang=\"YAML\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token key atrule\">server</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>  <span class=\"token key atrule\">port</span><span class=\"token punctuation\">:</span> <span class=\"token number\">6060</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token key atrule\">rocketmq</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>  <span class=\"token key atrule\">name-server</span><span class=\"token punctuation\">:</span> 127.0.0.1<span class=\"token punctuation\">:</span><span class=\"token number\">9876</span> <span class=\"token comment\"># NameServer 地址</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>  <span class=\"token key atrule\">producer</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token key atrule\">group</span><span class=\"token punctuation\">:</span> rocketmq<span class=\"token punctuation\">-</span>4x<span class=\"token punctuation\">-</span>service_common<span class=\"token punctuation\">-</span>message<span class=\"token punctuation\">-</span>execute_pg <span class=\"token comment\"># 全局发送者组定义</span></pre></td></tr></table></figure><p>定义消息生产者，通过  <code>RocketMQTemplate</code>  向 RocketMQ 发送普通常规消息。</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">cn<span class=\"token punctuation\">.</span>hutool<span class=\"token punctuation\">.</span>core<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">StrUtil</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">com<span class=\"token punctuation\">.</span>alibaba<span class=\"token punctuation\">.</span>fastjson<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">JSON</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">com<span class=\"token punctuation\">.</span>nageoffer<span class=\"token punctuation\">.</span>springbootladder<span class=\"token punctuation\">.</span>rocketmq4x<span class=\"token punctuation\">.</span>event<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">GeneralMessageEvent</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">lombok<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">RequiredArgsConstructor</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">lombok<span class=\"token punctuation\">.</span>extern<span class=\"token punctuation\">.</span>slf4j<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">Slf4j</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">org<span class=\"token punctuation\">.</span>apache<span class=\"token punctuation\">.</span>rocketmq<span class=\"token punctuation\">.</span>client<span class=\"token punctuation\">.</span>producer<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">SendResult</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">org<span class=\"token punctuation\">.</span>apache<span class=\"token punctuation\">.</span>rocketmq<span class=\"token punctuation\">.</span>common<span class=\"token punctuation\">.</span>message<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">MessageConst</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">org<span class=\"token punctuation\">.</span>apache<span class=\"token punctuation\">.</span>rocketmq<span class=\"token punctuation\">.</span>spring<span class=\"token punctuation\">.</span>core<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">RocketMQTemplate</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">org<span class=\"token punctuation\">.</span>springframework<span class=\"token punctuation\">.</span>messaging<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">Message</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">org<span class=\"token punctuation\">.</span>springframework<span class=\"token punctuation\">.</span>messaging<span class=\"token punctuation\">.</span>support<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">MessageBuilder</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">org<span class=\"token punctuation\">.</span>springframework<span class=\"token punctuation\">.</span>stereotype<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">Component</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token comment\">/**</pre></td></tr><tr><td data-num=\"14\"></td><td><pre> * 普通消息发送者</pre></td></tr><tr><td data-num=\"15\"></td><td><pre> *</pre></td></tr><tr><td data-num=\"16\"></td><td><pre> * @公众号：马丁玩编程，回复：加群，添加马哥微信（备注：ladder）获取更多项目资料</pre></td></tr><tr><td data-num=\"17\"></td><td><pre> */</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre><span class=\"token annotation punctuation\">@Slf4j</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre><span class=\"token annotation punctuation\">@Component</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre><span class=\"token annotation punctuation\">@RequiredArgsConstructor</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">GeneralMessageDemoProduce</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>    <span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">RocketMQTemplate</span> rocketMQTemplate<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>    <span class=\"token comment\">/**</pre></td></tr><tr><td data-num=\"26\"></td><td><pre>     * 发送普通消息</pre></td></tr><tr><td data-num=\"27\"></td><td><pre>     *</pre></td></tr><tr><td data-num=\"28\"></td><td><pre>     * @param topic            消息发送主题，用于标识同一类业务逻辑的消息</pre></td></tr><tr><td data-num=\"29\"></td><td><pre>     * @param tag              消息的过滤标签，消费者可通过 Tag 对消息进行过滤，仅接收指定标签的消息。</pre></td></tr><tr><td data-num=\"30\"></td><td><pre>     * @param keys             消息索引键，可根据关键字精确查找某条消息</pre></td></tr><tr><td data-num=\"31\"></td><td><pre>     * @param messageSendEvent 普通消息发送事件，自定义对象，最终都会序列化为字符串</pre></td></tr><tr><td data-num=\"32\"></td><td><pre>     * @return 消息发送 RocketMQ 返回结果</pre></td></tr><tr><td data-num=\"33\"></td><td><pre>     */</span></pre></td></tr><tr><td data-num=\"34\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token class-name\">SendResult</span> <span class=\"token function\">sendMessage</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> topic<span class=\"token punctuation\">,</span> <span class=\"token class-name\">String</span> tag<span class=\"token punctuation\">,</span> <span class=\"token class-name\">String</span> keys<span class=\"token punctuation\">,</span> <span class=\"token class-name\">GeneralMessageEvent</span> messageSendEvent<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"35\"></td><td><pre>        <span class=\"token class-name\">SendResult</span> sendResult<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"36\"></td><td><pre>        <span class=\"token keyword\">try</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"37\"></td><td><pre>            <span class=\"token class-name\">StringBuilder</span> destinationBuilder <span class=\"token operator\">=</span> <span class=\"token class-name\">StrUtil</span><span class=\"token punctuation\">.</span><span class=\"token function\">builder</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">append</span><span class=\"token punctuation\">(</span>topic<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"38\"></td><td><pre>            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">StrUtil</span><span class=\"token punctuation\">.</span><span class=\"token function\">isNotBlank</span><span class=\"token punctuation\">(</span>tag<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"39\"></td><td><pre>                destinationBuilder<span class=\"token punctuation\">.</span><span class=\"token function\">append</span><span class=\"token punctuation\">(</span><span class=\"token string\">\":\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">append</span><span class=\"token punctuation\">(</span>tag<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"40\"></td><td><pre>            <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"41\"></td><td><pre>            <span class=\"token class-name\">Message</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span><span class=\"token punctuation\">></span></span> message <span class=\"token operator\">=</span> <span class=\"token class-name\">MessageBuilder</span></pre></td></tr><tr><td data-num=\"42\"></td><td><pre>                    <span class=\"token punctuation\">.</span><span class=\"token function\">withPayload</span><span class=\"token punctuation\">(</span>messageSendEvent<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"43\"></td><td><pre>                    <span class=\"token punctuation\">.</span><span class=\"token function\">setHeader</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">MessageConst</span><span class=\"token punctuation\">.</span><span class=\"token constant\">PROPERTY_KEYS</span><span class=\"token punctuation\">,</span> keys<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"44\"></td><td><pre>                    <span class=\"token punctuation\">.</span><span class=\"token function\">setHeader</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">MessageConst</span><span class=\"token punctuation\">.</span><span class=\"token constant\">PROPERTY_TAGS</span><span class=\"token punctuation\">,</span> tag<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"45\"></td><td><pre>                    <span class=\"token punctuation\">.</span><span class=\"token function\">build</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"46\"></td><td><pre>            sendResult <span class=\"token operator\">=</span> rocketMQTemplate<span class=\"token punctuation\">.</span><span class=\"token function\">syncSend</span><span class=\"token punctuation\">(</span></pre></td></tr><tr><td data-num=\"47\"></td><td><pre>                    destinationBuilder<span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"48\"></td><td><pre>                    message<span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"49\"></td><td><pre>                    <span class=\"token number\">2000L</span></pre></td></tr><tr><td data-num=\"50\"></td><td><pre>            <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"51\"></td><td><pre>            log<span class=\"token punctuation\">.</span><span class=\"token function\">info</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"[普通消息] 消息发送结果：&#123;&#125;，消息ID：&#123;&#125;，消息Keys：&#123;&#125;\"</span><span class=\"token punctuation\">,</span> sendResult<span class=\"token punctuation\">.</span><span class=\"token function\">getSendStatus</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> sendResult<span class=\"token punctuation\">.</span><span class=\"token function\">getMsgId</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> keys<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"52\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Throwable</span> ex<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"53\"></td><td><pre>            log<span class=\"token punctuation\">.</span><span class=\"token function\">error</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"[普通消息] 消息发送失败，消息体：&#123;&#125;\"</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">JSON</span><span class=\"token punctuation\">.</span><span class=\"token function\">toJSONString</span><span class=\"token punctuation\">(</span>messageSendEvent<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> ex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"54\"></td><td><pre>            <span class=\"token keyword\">throw</span> ex<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"55\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"56\"></td><td><pre>        <span class=\"token keyword\">return</span> sendResult<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"57\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"58\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h5 id=\"24-consumer\"><a class=\"anchor\" href=\"#24-consumer\">#</a> 2.4、Consumer</h5>\n<p>定义消息消费者，从 RocketMQ Broker 拉取对应 Topic Tag 的消息列表。</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">com<span class=\"token punctuation\">.</span>alibaba<span class=\"token punctuation\">.</span>fastjson<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">JSON</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">com<span class=\"token punctuation\">.</span>nageoffer<span class=\"token punctuation\">.</span>springbootladder<span class=\"token punctuation\">.</span>rocketmq4x<span class=\"token punctuation\">.</span>event<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">GeneralMessageEvent</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">lombok<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">RequiredArgsConstructor</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">lombok<span class=\"token punctuation\">.</span>extern<span class=\"token punctuation\">.</span>slf4j<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">Slf4j</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">org<span class=\"token punctuation\">.</span>apache<span class=\"token punctuation\">.</span>rocketmq<span class=\"token punctuation\">.</span>spring<span class=\"token punctuation\">.</span>annotation<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">RocketMQMessageListener</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">org<span class=\"token punctuation\">.</span>apache<span class=\"token punctuation\">.</span>rocketmq<span class=\"token punctuation\">.</span>spring<span class=\"token punctuation\">.</span>core<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">RocketMQListener</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">org<span class=\"token punctuation\">.</span>springframework<span class=\"token punctuation\">.</span>stereotype<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">Component</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token comment\">/**</pre></td></tr><tr><td data-num=\"10\"></td><td><pre> * 普通消息消费者</pre></td></tr><tr><td data-num=\"11\"></td><td><pre> *</pre></td></tr><tr><td data-num=\"12\"></td><td><pre> * @公众号：马丁玩编程，回复：加群，添加马哥微信（备注：ladder）获取更多项目资料</pre></td></tr><tr><td data-num=\"13\"></td><td><pre> */</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre><span class=\"token annotation punctuation\">@Slf4j</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre><span class=\"token annotation punctuation\">@Component</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre><span class=\"token annotation punctuation\">@RequiredArgsConstructor</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre><span class=\"token annotation punctuation\">@RocketMQMessageListener</span><span class=\"token punctuation\">(</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>        topic <span class=\"token operator\">=</span> <span class=\"token string\">\"rocketmq-demo_common-message_topic\"</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>        selectorExpression <span class=\"token operator\">=</span> <span class=\"token string\">\"general\"</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>        consumerGroup <span class=\"token operator\">=</span> <span class=\"token string\">\"rocketmq-demo_general-message_cg\"</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">GeneralMessageDemoConsume</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">RocketMQListener</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">GeneralMessageEvent</span><span class=\"token punctuation\">></span></span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>    <span class=\"token annotation punctuation\">@Override</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">onMessage</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">GeneralMessageEvent</span> message<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>        log<span class=\"token punctuation\">.</span><span class=\"token function\">info</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"接到到RocketMQ消息，消息体：&#123;&#125;\"</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">JSON</span><span class=\"token punctuation\">.</span><span class=\"token function\">toJSONString</span><span class=\"token punctuation\">(</span>message<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h5 id=\"25-发送一条消息\"><a class=\"anchor\" href=\"#25-发送一条消息\">#</a> 2.5、发送一条消息</h5>\n<p>定义消息发送程序，这里为了避免类过多，直接写在 SpringBoot 的启动程序里。发送普通消息的方法返回值就是发送 RocketMQ Broker 返回的状态码，成功的话就是  <code>SEND_OK</code> 。</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">com<span class=\"token punctuation\">.</span>nageoffer<span class=\"token punctuation\">.</span>springbootladder<span class=\"token punctuation\">.</span>rocketmq4x<span class=\"token punctuation\">.</span>event<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">GeneralMessageEvent</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">com<span class=\"token punctuation\">.</span>nageoffer<span class=\"token punctuation\">.</span>springbootladder<span class=\"token punctuation\">.</span>rocketmq4x<span class=\"token punctuation\">.</span>produce<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">GeneralMessageDemoProduce</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">io<span class=\"token punctuation\">.</span>swagger<span class=\"token punctuation\">.</span>v3<span class=\"token punctuation\">.</span>oas<span class=\"token punctuation\">.</span>annotations<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">Operation</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">io<span class=\"token punctuation\">.</span>swagger<span class=\"token punctuation\">.</span>v3<span class=\"token punctuation\">.</span>oas<span class=\"token punctuation\">.</span>annotations<span class=\"token punctuation\">.</span>tags<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">Tag</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">lombok<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">RequiredArgsConstructor</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">org<span class=\"token punctuation\">.</span>apache<span class=\"token punctuation\">.</span>rocketmq<span class=\"token punctuation\">.</span>client<span class=\"token punctuation\">.</span>producer<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">SendResult</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">org<span class=\"token punctuation\">.</span>springframework<span class=\"token punctuation\">.</span>boot<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">SpringApplication</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">org<span class=\"token punctuation\">.</span>springframework<span class=\"token punctuation\">.</span>boot<span class=\"token punctuation\">.</span>autoconfigure<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">SpringBootApplication</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">org<span class=\"token punctuation\">.</span>springframework<span class=\"token punctuation\">.</span>web<span class=\"token punctuation\">.</span>bind<span class=\"token punctuation\">.</span>annotation<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">PostMapping</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">org<span class=\"token punctuation\">.</span>springframework<span class=\"token punctuation\">.</span>web<span class=\"token punctuation\">.</span>bind<span class=\"token punctuation\">.</span>annotation<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">RestController</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">java<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">UUID</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre></pre></td></tr><tr><td data-num=\"14\"></td><td><pre><span class=\"token annotation punctuation\">@RestController</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre><span class=\"token annotation punctuation\">@RequiredArgsConstructor</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre><span class=\"token annotation punctuation\">@SpringBootApplication</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre><span class=\"token annotation punctuation\">@Tag</span><span class=\"token punctuation\">(</span>name <span class=\"token operator\">=</span> <span class=\"token string\">\"RocketMQ发送示例\"</span><span class=\"token punctuation\">,</span> description <span class=\"token operator\">=</span> <span class=\"token string\">\"RocketMQ发送示例启动器\"</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">RocketMQDemoApplication</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>    <span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">GeneralMessageDemoProduce</span> generalMessageDemoProduce<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>    <span class=\"token annotation punctuation\">@PostMapping</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"/test/send/general-message\"</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>    <span class=\"token annotation punctuation\">@Operation</span><span class=\"token punctuation\">(</span>summary <span class=\"token operator\">=</span> <span class=\"token string\">\"发送RocketMQ普通消息\"</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token class-name\">String</span> <span class=\"token function\">sendGeneralMessage</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>        <span class=\"token class-name\">String</span> keys <span class=\"token operator\">=</span> <span class=\"token constant\">UUID</span><span class=\"token punctuation\">.</span><span class=\"token function\">randomUUID</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>        <span class=\"token class-name\">GeneralMessageEvent</span> generalMessageEvent <span class=\"token operator\">=</span> <span class=\"token class-name\">GeneralMessageEvent</span><span class=\"token punctuation\">.</span><span class=\"token function\">builder</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>                <span class=\"token punctuation\">.</span><span class=\"token function\">body</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"消息具体内容，可以是自定义对象，最终都会序列化为字符串。如果是取消订单，这里应该是订单ID或者相关联的信息\"</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>                <span class=\"token punctuation\">.</span><span class=\"token function\">keys</span><span class=\"token punctuation\">(</span>keys<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>                <span class=\"token punctuation\">.</span><span class=\"token function\">build</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>        <span class=\"token class-name\">SendResult</span> sendResult <span class=\"token operator\">=</span> generalMessageDemoProduce<span class=\"token punctuation\">.</span><span class=\"token function\">sendMessage</span><span class=\"token punctuation\">(</span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre>                <span class=\"token string\">\"rocketmq-demo_common-message_topic\"</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"32\"></td><td><pre>                <span class=\"token string\">\"general\"</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"33\"></td><td><pre>                keys<span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"34\"></td><td><pre>                generalMessageEvent</pre></td></tr><tr><td data-num=\"35\"></td><td><pre>        <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"36\"></td><td><pre>        <span class=\"token keyword\">return</span> sendResult<span class=\"token punctuation\">.</span><span class=\"token function\">getSendStatus</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">name</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"37\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"38\"></td><td><pre></pre></td></tr><tr><td data-num=\"39\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"40\"></td><td><pre>        <span class=\"token class-name\">SpringApplication</span><span class=\"token punctuation\">.</span><span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">RocketMQDemoApplication</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">,</span> args<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"41\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"42\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>项目中引入了 Swagger3，通过界面 UI 发送一条消息测试效果。访问  <code>http://127.0.0.1:6060/swagger-ui/index.html</code> ，调用定义的发送 RocketMQ 普通消息方法。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230924173811738.png\" alt=\"img\" /></p>\n<p>点击 Execute 执行方法调用。</p>\n<p><img data-src=\"https://images-machen.oss-cn-beijing.aliyuncs.com/image-20230924173837160.png\" alt=\"img\" /></p>\n<p>通过方法调用得知，返回数据为成功。</p>\n<p><img data-src=\"https://images-machen.oss-cn-beijing.aliyuncs.com/image-20230924173948187.png\" alt=\"img\" /></p>\n<p>也能看到 RocketMQ 对应的生产者和消费者对应日志。</p>\n<figure class=\"highlight text\"><figcaption data-lang=\"text\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>2023-09-24T17:38:57.457+08:00  INFO 48437 --- [nio-6060-exec-6] c.n.s.r.p.GeneralMessageDemoProduce      : [普通消息] 消息发送结果：SEND_OK，消息ID：7F000001BD35251A69D77A3BC5280002，消息Keys：7a60c853-08dc-46cd-a647-398d45b54966</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>2023-09-24T17:38:57.459+08:00  INFO 48437 --- [al-message_cg_3] c.n.s.r.c.GeneralMessageDemoConsume      : 接到RocketMQ消息，消息体：&#123;\"body\":\"消息具体内容，可以是自定义对象，最终都会序列化为字符串。如果是取消订单，这里应该是订单ID或者相关联的信息\",\"keys\":\"7a60c853-08dc-46cd-a647-398d45b54966\"&#125;</pre></td></tr></table></figure><h4 id=\"3-扩展框架-springcloud-stream\"><a class=\"anchor\" href=\"#3-扩展框架-springcloud-stream\">#</a> 3、扩展框架 SpringCloud Stream</h4>\n<p>Spring Cloud Stream 是一个<strong>用于构建基于消息的微服务应用</strong>框架。它基于 SpringBoot 来创建具有生产级别的单机 Spring 应用，并且使用  <code>Spring Integration</code>  与 Broker 进行连接。</p>\n<p>Spring Cloud Stream 提供了消息中间件配置的统一抽象，推出了 publish-subscribe、consumer groups、partition 这些统一的概念。</p>\n<p>Spring Cloud Stream 内部有两个概念：Binder 和 Binding。</p>\n<ul>\n<li><code>Binder</code> ：跟外部消息中间件集成的组件，用来创建 Binding，各消息中间件都有自己的 Binder 实现。</li>\n</ul>\n<p>比如  <code>Kafka</code>  的实现  <code>KafkaMessageChannelBinder</code> ， <code>RabbitMQ</code>  的实现  <code>RabbitMessageChannelBinder</code>  以及  <code>RocketMQ</code>  的实现  <code>RocketMQMessageChannelBinder</code> 。</p>\n<ul>\n<li><code>Binding</code> ：包括 Input Binding 和 Output Binding。</li>\n</ul>\n<p>Binding 在消息中间件与应用程序提供的 Provider 和 Consumer 之间提供了一个桥梁，实现了开发者只需使用应用程序的 Provider 或 Consumer 生产或消费数据即可，屏蔽了开发者与底层消息中间件的接触。</p>\n<p>下图是 Spring Cloud Stream 的架构设计。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/68747470733a2f2f646f63732e737072696e672e696f2f737072696e672d636c6f75642d73747265616d2f646f63732f63757272656e742f7265666572656e63652f68746d6c2f696d616765732f534353742d776974682d62696e6465722e706e67.png\" alt=\"img\" /></p>\n<p>SpringCloud Stream RocketMQ 不是咱们本次介绍的重点，所以只是抛砖引玉，大家需要了解详情参考：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2FsaWJhYmEvc3ByaW5nLWNsb3VkLWFsaWJhYmEvYmxvYi8yLjIueC9zcHJpbmctY2xvdWQtYWxpYmFiYS1leGFtcGxlcy9yb2NrZXRtcS1leGFtcGxlL3JlYWRtZS16aC5tZA==\">RocketMQ Example</span></p>\n<h3 id=\"部署架构\"><a class=\"anchor\" href=\"#部署架构\">#</a> 部署架构</h3>\n<h4 id=\"本地部署\"><a class=\"anchor\" href=\"#本地部署\">#</a> 本地部署</h4>\n<h5 id=\"单组节点单副本模式\"><a class=\"anchor\" href=\"#单组节点单副本模式\">#</a> 单组节点单副本模式</h5>\n<p>这种方式风险较大，因为 Broker 只有一个节点，一旦 Broker 重启或者宕机时，会导致整个服务不可用。不建议线上环境使用，可以用于本地测试。</p>\n<h5 id=\"多组节点集群单副本模式\"><a class=\"anchor\" href=\"#多组节点集群单副本模式\">#</a> 多组节点（集群）单副本模式</h5>\n<p>一个集群内全部部署 Master 角色，不部署 Slave 副本，例如 2 个 Master 或者 3 个 Master，这种模式的优缺点如下：</p>\n<ul>\n<li>优点：配置简单，单个 Master 宕机或重启维护对应用无影响，在磁盘配置为 RAID10 时，即使机器宕机不可恢复情况下，由于 RAID10 磁盘非常可靠，消息也不会丢（异步刷盘丢失少量消息，同步刷盘一条不丢），性能最高；</li>\n<li>缺点：单台机器宕机期间，这台机器上未被消费的消息在机器恢复之前不可订阅，消息实时性会受到影响。</li>\n</ul>\n<h4 id=\"生产部署\"><a class=\"anchor\" href=\"#生产部署\">#</a> 生产部署</h4>\n<h5 id=\"多节点集群多副本模式异步复制\"><a class=\"anchor\" href=\"#多节点集群多副本模式异步复制\">#</a> 多节点（集群）多副本模式：异步复制</h5>\n<p><font color='red'>每个 Master 配置一个 Slave</font>，有多组 Master-Slave，HA 采用<strong>异步复制</strong>方式，主备有短暂消息延迟（毫秒级），这种模式的优缺点如下：</p>\n<ul>\n<li>优点：即使磁盘损坏，消息丢失的非常少，且消息实时性不会受影响，同时 Master 宕机后，消费者仍然可以从 Slave 消费，而且此过程对应用透明，不需要人工干预，性能同多 Master 模式几乎一样；</li>\n<li>缺点：Master 宕机，磁盘损坏情况下会丢失少量消息。</li>\n</ul>\n<h5 id=\"多节点集群多副本模式同步双写\"><a class=\"anchor\" href=\"#多节点集群多副本模式同步双写\">#</a> 多节点（集群）多副本模式：同步双写</h5>\n<p><font color='red'>每个 Master 配置一个 Slave</font>，有多对 Master-Slave，HA 采用<strong>同步双写</strong>方式，即只有主备都写成功，才向应用返回成功，这种模式的优缺点如下：</p>\n<ul>\n<li>优点：数据与服务都无单点故障，Master 宕机情况下，消息无延迟，服务可用性与数据可用性都非常高；</li>\n<li>缺点：性能比异步复制模式略低（大约低 10% 左右），发送单个消息的 RT 会略高，且目前版本在主节点宕机后，备机不能自动切换为主机。</li>\n</ul>\n",
            "tags": [
                "Java",
                "JUC"
            ]
        },
        {
            "id": "http://example.com/java/java-se/java-excise/%E7%AC%AC18%E7%AB%A0%EF%BC%9A%E9%9A%8F%E5%A0%82%E5%A4%8D%E4%B9%A0%E4%B8%8E%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%A2%98%EF%BC%88JDK8-17%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%89/",
            "url": "http://example.com/java/java-se/java-excise/%E7%AC%AC18%E7%AB%A0%EF%BC%9A%E9%9A%8F%E5%A0%82%E5%A4%8D%E4%B9%A0%E4%B8%8E%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%A2%98%EF%BC%88JDK8-17%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%89/",
            "title": "宋红康_第18章：JDK8-17新特性",
            "date_published": "2023-11-12T03:06:50.211Z",
            "content_html": "<h1 id=\"第18章随堂复习与企业真题jdk8-17新特性\"><a class=\"anchor\" href=\"#第18章随堂复习与企业真题jdk8-17新特性\">#</a> 第 18 章：随堂复习与企业真题（JDK8-17 新特性）</h1>\n<hr />\n<h2 id=\"一-随堂复习\"><a class=\"anchor\" href=\"#一-随堂复习\">#</a> 一、随堂复习</h2>\n<h3 id=\"1-jdk新特性的概述\"><a class=\"anchor\" href=\"#1-jdk新特性的概述\">#</a> 1. JDK 新特性的概述</h3>\n<ul>\n<li>几个重要的版本\n<ul>\n<li>jdk 5.0 /jdk 8.0 ：里程碑式的版本</li>\n<li>jdk9.0 开始每 6 个月发布一个新的版本</li>\n<li>LTS : jdk8 、 jdk 11 、 jdk 17</li>\n</ul>\n</li>\n<li>如何学习新特性\n<ul>\n<li>\n<p>新的语法规则 （多关注）：自动装箱、自动拆箱、注解、enum、Lambda 表达式、方法引用、switch 表达式、try-catch 变化、record 等</p>\n</li>\n<li>\n<p>增加、过时、删除 API：StringBuilder、ArrayList、新的日期时间的 API、Optional 等</p>\n</li>\n<li>\n<p>底层的优化、JVM 参数的调整、GC 的变化、内存结构（永久代 ---&gt; 元空间）</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-jdk8lambda表达式\"><a class=\"anchor\" href=\"#2-jdk8lambda表达式\">#</a> 2. JDK8:<mark>lambda 表达式</mark></h3>\n<h4 id=\"21-什么情况下可以使用lambda表达式\"><a class=\"anchor\" href=\"#21-什么情况下可以使用lambda表达式\">#</a> 2.1 什么情况下可以使用 lambda 表达式</h4>\n<ul>\n<li><strong>在给函数式接口提供实例时</strong>，都可以考虑使用 lambda 表达式。</li>\n<li>基本语法的使用（重要）</li>\n</ul>\n<h4 id=\"22-函数式接口\"><a class=\"anchor\" href=\"#22-函数式接口\">#</a> 2.2 <strong>函数式接口</strong></h4>\n<ul>\n<li>\n<p>常见的函数式接口。Comparator \\ Runnable \\ java.util.function 下定义的丰富的函数式接口</p>\n<pre><code>消费型接口：Consumer&lt;T&gt;     void accept(T t)\n供给型接口：Supplier&lt;T&gt;     T get()\n函数型接口：Function&lt;T,R&gt;   R apply(T t)\n判断型接口：Predicate&lt;T&gt;    boolean test(T t)\n</code></pre>\n</li>\n</ul>\n<h4 id=\"23-方法引用-构造器引用-数组引用\"><a class=\"anchor\" href=\"#23-方法引用-构造器引用-数组引用\">#</a> 2.3 方法引用、构造器引用、数组引用</h4>\n<ul>\n<li>\n<p>方法引用、构造器引用、数组引用：看做是 lambda 表达式的进一步刻画、表达。</p>\n</li>\n<li>\n<p>（掌握）方法引用、构造器引用、数组引用的使用场景。</p>\n</li>\n</ul>\n<h3 id=\"3-jdk8stream-api的使用\"><a class=\"anchor\" href=\"#3-jdk8stream-api的使用\">#</a> 3. JDK8:<mark>Stream API</mark> 的使用</h3>\n<ul>\n<li>Stream 关注于内存中的多个数据的运算。</li>\n<li>使用步骤：\n<ul>\n<li>Stream 的<font color='red'>实例化</font></li>\n<li>一系列的<font color='red'>中间操作</font></li>\n<li><font color='red'>终止操作</font></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"4-jdk8之后的新特性语法层面\"><a class=\"anchor\" href=\"#4-jdk8之后的新特性语法层面\">#</a> 4. JDK8 之后的新特性：语法层面</h3>\n<ul>\n<li>jShell 工具</li>\n<li><font color='red'>try-catch 结构的变化，资源自动关闭</font>。try(...)</li>\n<li><font color='red'>局部变量的类型推断：var</font></li>\n<li>instanceof 的模式匹配</li>\n<li><font color='red'>switch 表达式</font>、<font color='red'>switch 的模式匹配</font></li>\n<li>文本块的使用：&quot;&quot;&quot;文本块&quot;&quot;&quot;</li>\n<li>新的引用数据类型：<font color='red'>record (记录)</font></li>\n<li>密封类： <code>sealed</code>  class</li>\n</ul>\n<h3 id=\"5-jdk8之后的新特性其它\"><a class=\"anchor\" href=\"#5-jdk8之后的新特性其它\">#</a> 5. JDK8 之后的新特性：其它</h3>\n<ul>\n<li><code>Optional类</code> 的使用</li>\n<li>其他：了解</li>\n</ul>\n<h2 id=\"二-企业真题\"><a class=\"anchor\" href=\"#二-企业真题\">#</a> 二、企业真题</h2>\n<h3 id=\"21-jdk8新特性\"><a class=\"anchor\" href=\"#21-jdk8新特性\">#</a> 2.1 JDK8 新特性</h3>\n<h4 id=\"1-谈谈java8新特性京旗下-时代宇信必-招信诺中外包金软件-阿巴\"><a class=\"anchor\" href=\"#1-谈谈java8新特性京旗下-时代宇信必-招信诺中外包金软件-阿巴\">#</a> 1. <mark>谈谈 java8 新特性</mark> (京 * 旗下、时代 * 宇，信必 *、招 * 信诺，中 * 外包，金 * 软件、阿 ** 巴)</h4>\n<pre><code>类似问题\n&gt; JDK1.8相较于JDK1.7有什么不一样？（惠*）\n&gt; JDK1.8的新特性有哪些？Stream API + Lambda表达式，还有吗？（久*国际物流）\n</code></pre>\n<ol>\n<li>\n<p><strong>Lambda 表达式</strong>：在给函数式接口提供实例时使用，可简化函数式编程的语法形式。</p>\n</li>\n<li>\n<p>方法引用：用于直接引用已有的方法、构造函数来提供更简洁的 Lambda 表达式。</p>\n</li>\n<li>\n<p><strong>Stream API</strong>：用于对集合进行处理和操作的 API，可以在集合中进行过滤、排序、映射等操作。</p>\n</li>\n<li>\n<p>时间日期 API（ <code>java.time包</code> ）：引入了全新的时间日期 API，解决了旧有的日期时间类库的许多问题，如线程安全、设计缺陷等。</p>\n</li>\n<li>\n<p><font color='red'>接口默认方法和私有方法</font>：允许在接口中定义默认的实现方法、私有方法，避免影响原有的继承关系。</p>\n</li>\n<li>\n<p>可重复注解：允许同一个注解在同一个元素上使用多次，并且不会产生冲突。</p>\n</li>\n<li>\n<p>新的类型注解：允许开发者对类型进行注释，提高代码可读性和可靠性。</p>\n</li>\n<li>\n<p>CompletableFuture 类：用于执行异步任务，可以轻松管理并发操作。</p>\n</li>\n<li>\n<p>内存结构：Java 8 引入了 <code>元空间（Metaspace）</code> ，代替了旧版的永久代（PermGen Space）。元空间是 JVM 中<font color='red'>存储类元数据（Class Metadata）</font>的区域，能够动态的调整大小，并且可以设置元空间最大值。这对于需要动态生成类的应用程序而言，更为灵活和安全。</p>\n</li>\n<li>\n<p><font color='red'>HashMap 底层结构</font>:Java 8 的 HashMap 实现中，链表长度超过一定阈值时，链表会转换成 <code>红黑树</code> 。在红黑树中查询、插入、删除的时间复杂度均为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(log n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span>，相较于链表更为高效。该变化使得 HashMap 对于冲突较多的场景效率更高。</p>\n</li>\n</ol>\n<p>此外，还有 ArrayList、ConcurrentHashMap、Collections 等相关数据结构也做出了一些优化和改进。</p>\n<h4 id=\"2-jdk18在数据结构上发生了哪些变化银数据\"><a class=\"anchor\" href=\"#2-jdk18在数据结构上发生了哪些变化银数据\">#</a> 2. JDK1.8 在数据结构上发生了哪些变化？（银 * 数据）</h4>\n<ul>\n<li>\n<p>内存结构：Java 8 引入了 <code>元空间（Metaspace）</code> ，代替了旧版的永久代（PermGen Space）。元空间是 JVM 中<font color='red'>存储类元数据（Class Metadata）</font>的区域，<font color='red'>能够动态的调整大小</font>，并且可以设置元空间最大值。这对于需要动态生成类的应用程序而言，更为灵活和安全。</p>\n<ul>\n<li>对于 HotSpot，方法区在 jdk7 中是：永久代（PermGen Space）</li>\n<li>对于 HotSpot，方法区在 jdk8 中是：元空间（Metaspace）</li>\n</ul>\n</li>\n<li>\n<p><font color='red'>HashMap 底层结构</font>:Java 8 的 HashMap 实现中，链表长度超过一定阈值时，链表会转换成 <code>红黑树</code> 。在红黑树中查询、插入、删除的时间复杂度均为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(log n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span>，相较于链表更为高效。该变化使得 HashMap 对于冲突较多的场景效率更高。</p>\n</li>\n</ul>\n<h4 id=\"3-jdk18用的是哪个垃圾回收器oo\"><a class=\"anchor\" href=\"#3-jdk18用的是哪个垃圾回收器oo\">#</a> 3. JDK1.8 用的是哪个垃圾回收器？（O**O）</h4>\n<p><code>Parallel GC</code>  --&gt; jdk9：默认使用 <code>G1GC</code>   --&gt; <strong> <code>ZGC</code> </strong> （低延迟）</p>\n<h3 id=\"22-lambda表达式\"><a class=\"anchor\" href=\"#22-lambda表达式\">#</a> 2.2 Lambda 表达式</h3>\n<h4 id=\"1-lambda表达式有了解吗说说如何使用的oo\"><a class=\"anchor\" href=\"#1-lambda表达式有了解吗说说如何使用的oo\">#</a> 1. <mark>Lambda 表达式有了解吗，说说如何使用的</mark>（O**O）</h4>\n<pre><code>类似问题：\n&gt; Lambda的理解（国*）\n</code></pre>\n<p><strong>在给函数式接口提供实例时</strong>，都可以考虑使用 lambda 表达式。</p>\n<p>Lambda 表达式是 Java 8 中引入的一种新特性，它本质上是<font color='red'>一个匿名函数</font>，用于表示将一个功能传递给某个方法。Lambda 表达式可以看作是函数式编程的核心思想，它是可传递的代码块，实现了代码的重复利用和简化。</p>\n<p>使用 Lambda 表达式的语法如下：</p>\n<p>(parameter1, parameter2, ...) -&gt; expression</p>\n<p>或者</p>\n<p statement1;=\"\" statement2;=\"\" css-module=\".\">(parameter1, parameter2, ...) -&gt;</p>\n<p>其中，</p>\n<ul>\n<li><code>参数列表</code>  parameter1, parameter2 指定了 Lambda 表达式中的参数。</li>\n<li>箭头符号 -&gt; 将参数列表和 Lambda 表达式的主体分开。</li>\n<li><code>表达式</code>  expression 或语句块组成了 Lambda 表达式的主体。</li>\n</ul>\n<p>Lambda 表达式可以被赋值给一个变量，也可以像参数一样传递到方法中去。在 Java 中，Lambda 通常会关联<strong>函数式接口（Functional Interface），即只包含一个抽象方法的接口</strong>。例如，Runnable 接口只有一个 run () 方法，可以将一个 Lambda 表达式作为 Runnable 对象进行调用：</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token class-name\">Runnable</span> r <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Hello, world!\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span>r<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>除此之外，Lambda 表达式还可以<strong>与集合框架中的 Stream API 结合使用</strong>来对数据流进行过滤、映射等处理操作，从而简化操作实现。例如：</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span></span> nums <span class=\"token operator\">=</span> <span class=\"token class-name\">Arrays</span><span class=\"token punctuation\">.</span><span class=\"token function\">asList</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">int</span> sum <span class=\"token operator\">=</span> nums<span class=\"token punctuation\">.</span><span class=\"token function\">stream</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">mapToInt</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Integer</span><span class=\"token operator\">::</span><span class=\"token function\">intValue</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">sum</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>sum<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 输出：15</span></pre></td></tr></table></figure><p>Lambda 表达式的使用，让 Java 语言有了更多的编程方式和更好的代码可读性，它是 Java 8 中最具有代表性的新特性之一。</p>\n<h4 id=\"2-什么是函数式接口有几种函数式接口阿巴\"><a class=\"anchor\" href=\"#2-什么是函数式接口有几种函数式接口阿巴\">#</a> 2. <mark>什么是函数式接口？有几种函数式接口</mark>（阿 ** 巴）</h4>\n<p>** 函数式接口（functional interface）** 是 Java 8 中引入的一种新类型接口，它<font color='red'>只包含一个抽象方法</font>，用于支持 Lambda 表达式和方法引用等函数式编程特性。当声明一个函数式接口时，可以使用  <code>@FunctionalInterface</code>  注解标记以便在编译时进行验证，确保该接口只有一个抽象方法。</p>\n<p>在 Java 8 中的 <code>java.util.function包</code> 下，已经为常见的函数式接口提供了内置支持，比如：</p>\n<table>\n<thead>\n<tr>\n<th>称谓</th>\n<th>函数式接口</th>\n<th>参数类型</th>\n<th>说明</th>\n<th>用途</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>消费</code> 型接口</td>\n<td><code>Consumer&lt;T&gt;  </code></td>\n<td>T</td>\n<td>有参数输入 T，没有输出</td>\n<td>对类型为 T 的对象应用操作，包含方法：   <code>void accept(T t)  </code></td>\n</tr>\n<tr>\n<td><code>供给</code> 型接口</td>\n<td><code>Supplier&lt;T&gt;  </code></td>\n<td>无</td>\n<td>无参数输入，返回一个 T 类型结果</td>\n<td>返回类型为 T 的对象，包含方法： <code>T get()  </code></td>\n</tr>\n<tr>\n<td><code>函数</code> 型接口</td>\n<td><code>Function&lt;T, R&gt;  </code></td>\n<td>T</td>\n<td>有一个 T 类型的输入参数，输出 R 类型的结果</td>\n<td>对类型为 T 的对象应用操作，并返回结果。结果是 R 类型的对象。包含方法： <code>R apply(T t)  </code></td>\n</tr>\n<tr>\n<td><code>判断</code> 型接口</td>\n<td><code>Predicate&lt;T&gt;  </code></td>\n<td>T</td>\n<td>输入 T，返回一个布尔值结果</td>\n<td>确定类型为 T 的对象是否满足某约束，并返回 boolean 值。包含方法： <code>boolean test(T t)  </code></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"23-stream-api\"><a class=\"anchor\" href=\"#23-stream-api\">#</a> 2.3 Stream API</h3>\n<h4 id=\"1-创建stream的方式阿巴\"><a class=\"anchor\" href=\"#1-创建stream的方式阿巴\">#</a> 1. 创建 Stream 的方式（阿 ** 巴）</h4>\n<p>Stream 操作分 3 个步骤：</p>\n<ul>\n<li>\n<p>创建 Stream 实例（3 种主要方式）</p>\n<ul>\n<li>\n<p><strong>通过集合 (Collection)</strong></p>\n<blockquote>\n<p>Java8 中的 Collection 接口被扩展，提供了两个获取流的方法：</p>\n<ul>\n<li>\n<p>default Stream<E>  <code>stream</code>  () : 返回一个<font color='red'>顺序流</font></p>\n</li>\n<li>\n<p>default Stream<E>  <code>parallelStream</code>  () : 返回一个<font color='red'>并行流</font></p>\n</li>\n</ul>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token annotation punctuation\">@Test</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">test01</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span></span> list <span class=\"token operator\">=</span> <span class=\"token class-name\">Arrays</span><span class=\"token punctuation\">.</span><span class=\"token function\">asList</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span><span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token comment\">//JDK1.8 中，Collection 系列集合增加了方法</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token class-name\">Stream</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span></span> stream <span class=\"token operator\">=</span> list<span class=\"token punctuation\">.</span><span class=\"token function\">stream</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure></blockquote>\n</li>\n<li>\n<p><strong>通过数组</strong></p>\n<blockquote>\n<p>Java8 中的  <code>Arrays.stream(T[] array)</code>  可以获取数组流，这里的 T 既可以是引用数据类型，也可以是基本数据类型：</p>\n<ul>\n<li>static <T> Stream<T> stream (T [] array): 返回一个流</li>\n<li>public static IntStream stream(int[] array)</li>\n<li>public static LongStream stream(long[] array)</li>\n<li>public static DoubleStream stream(double[] array)</li>\n</ul>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token annotation punctuation\">@Test</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">test02</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> arr <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span><span class=\"token string\">\"hello\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"world\"</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token class-name\">Stream</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">></span></span> stream <span class=\"token operator\">=</span> <span class=\"token class-name\">Arrays</span><span class=\"token punctuation\">.</span><span class=\"token function\">stream</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> </pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token annotation punctuation\">@Test</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">test03</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> arr <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span><span class=\"token number\">5</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token class-name\">IntStream</span> stream <span class=\"token operator\">=</span> <span class=\"token class-name\">Arrays</span><span class=\"token punctuation\">.</span><span class=\"token function\">stream</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure></blockquote>\n</li>\n<li>\n<p><strong>通过 Stream 类的静态方法 of ()</strong></p>\n<blockquote>\n<p>可以调用 <code>Stream.of(T... values)</code> , 通过显示值创建一个流。它可以接收<font color='red'>任意数量的参数</font>。</p>\n<ul>\n<li>public static<T> Stream<T> of (T... values) : 返回一个流</li>\n</ul>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token annotation punctuation\">@Test</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">test04</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token class-name\">Stream</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span></span> stream <span class=\"token operator\">=</span> <span class=\"token class-name\">Stream</span><span class=\"token punctuation\">.</span><span class=\"token function\">of</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span><span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    stream<span class=\"token punctuation\">.</span><span class=\"token function\">forEach</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token operator\">::</span><span class=\"token function\">println</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure></blockquote>\n</li>\n</ul>\n</li>\n<li>\n<p>一系列的中间操作</p>\n</li>\n<li>\n<p>终止操作</p>\n</li>\n</ul>\n<h4 id=\"2-你讲讲stream表达式是咋用的干啥的中国际上海网络\"><a class=\"anchor\" href=\"#2-你讲讲stream表达式是咋用的干啥的中国际上海网络\">#</a> 2. 你讲讲 stream 表达式是咋用的，干啥的？（中 * 国际，上海 ** 网络）</h4>\n<pre><code>&gt; Stream API 关注的是多个数据的计算（排序、查找、过滤、映射、遍历等），面向CPU的。\n  集合关注的数据的存储，面向内存的。\n&gt; Stream API 之于集合，类似于SQL之于数据表的查询。\n</code></pre>\n<p>在 Java 8 中，Stream 是<font color='red'>一种新的集合处理方式</font>，它是用来对集合或者数组进行一系列操作的。Stream API 简化了对集合数据的处理，使代码更易读、更短。</p>\n<p>stream 表达式通常由三个部分构成： <code>源</code> 、 <code>零个或多个中间操作</code> ，以及 <code>一个终止操作</code> 。其中，<font color='red'>中间操作可有可无，终止操作是不可缺少的</font>，只有<font color='red'>在调用终止操作时才开始执行 stream 表达式中的各种操作</font>，从而提高效率。</p>\n<p>Stream 的使用步骤：</p>\n<ul>\n<li>创建 Stream 实例（3 种主要方式）\n<ul>\n<li><strong>通过集合 (Collection)</strong></li>\n<li><strong>通过数组</strong></li>\n<li><strong>通过 Stream 类的静态方法 of ()</strong></li>\n</ul>\n</li>\n<li>一系列的中间操作</li>\n<li>终止操作</li>\n</ul>\n<p>stream 表达式提供了一种简洁、灵活的集合处理方式，使得<font color='red'>代码更加清晰、易读</font>，同时使用 stream <font color='red'>可以将数据处理部分代码进行函数式抽象</font>，避免重复代码。</p>\n<h4 id=\"3-集合用stream流怎么实现过滤润软件\"><a class=\"anchor\" href=\"#3-集合用stream流怎么实现过滤润软件\">#</a> 3. 集合用 Stream 流怎么实现过滤？（润 * 软件）</h4>\n<p>filter (Predicate predicate) 方法</p>\n<h4 id=\"4-用stream怎么选出list里想要的数据惠\"><a class=\"anchor\" href=\"#4-用stream怎么选出list里想要的数据惠\">#</a> 4. 用 Stream 怎么选出 List 里想要的数据？（惠 *）</h4>\n<p>使用 Stream 选出 List 中我们想要的数据通常可以通过过滤（ <code>filter</code> ）操作来实现，例如：</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">></span></span> list <span class=\"token operator\">=</span> <span class=\"token class-name\">Arrays</span><span class=\"token punctuation\">.</span><span class=\"token function\">asList</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"apple\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"banana\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"orange\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"grape\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"peach\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">></span></span> result <span class=\"token operator\">=</span> list<span class=\"token punctuation\">.</span><span class=\"token function\">stream</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>                          <span class=\"token punctuation\">.</span><span class=\"token function\">filter</span><span class=\"token punctuation\">(</span>str <span class=\"token operator\">-></span> str<span class=\"token punctuation\">.</span><span class=\"token function\">contains</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"a\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>                          <span class=\"token punctuation\">.</span><span class=\"token function\">collect</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Collectors</span><span class=\"token punctuation\">.</span><span class=\"token function\">toList</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>   <span class=\"token comment\">// 输出：[apple, banana, grape, peach]</span></pre></td></tr></table></figure><p>在这个例子中，我们首先通过 Arrays.asList () 方法初始化一个字符串列表，然后使用 stream () 方法将其转换为一个流对象。接着调用 filter () 方法，使用 Lambda 表达式实现一个简单的条件判断，该条件将保留包含字符 “a” 的字符串。最后使用 collect () 方法将过滤后的结果收集回 List 对象。</p>\n<p>在 filter () 中，我们可以根据实际需求自定义过滤条件。例如，可以使用正则表达式、时间戳等其他方式进行过滤操作，只留下符合条件的元素。无论具体的过滤条件是什么，Stream 应该是处理集合或数组数据集的良好选择，并且在许多常见的情况下可以提供比传统循环更加清晰和简洁的代码实现方式。</p>\n<h3 id=\"24-其它版本新特性\"><a class=\"anchor\" href=\"#24-其它版本新特性\">#</a> 2.4 其它版本新特性</h3>\n<h4 id=\"1-说说jdk15-jdk16-jdk17中的新特性都有什么银数据\"><a class=\"anchor\" href=\"#1-说说jdk15-jdk16-jdk17中的新特性都有什么银数据\">#</a> 1. 说说 JDK15、JDK16、JDK17 中的新特性都有什么？(银 * 数据)</h4>\n<p>Java SE 15</p>\n<ul>\n<li>\n<p><code>Sealed Classes（密封类）</code> ：通过<font color='red'>限制子类</font>，增强类的封装性和安全性。</p>\n</li>\n<li>\n<p>Hidden Classes（隐式类）：让开发人员在运行时动态创建类，并加强对于执行代码的保护。</p>\n</li>\n<li>\n<p><code>Text Blocks（文本块）</code> ：为多行字符串提供了一种更加可读性和可写性的表示方式，优化了文本处理操作。</p>\n</li>\n<li>\n<p><code>Record Classes（记录类）</code> ：声明用于存储数据并带有标识性的类。</p>\n</li>\n</ul>\n<p>Java SE 16</p>\n<ul>\n<li>\n<p><code>Records</code> ：进一步完善记录类（Record Classes），使得构造函数等细节更加灵活。</p>\n</li>\n<li>\n<p><code>instanceof的模式匹配</code> ：简化了 instanceof 操作符的使用，使得<font color='red'>当匹配成功时可以直接将类型转换</font>。</p>\n</li>\n<li>\n<p>Foreign Function &amp; Memory API：为 Java 应用程序提供了与外部应用程序交互的基础设施，方便实现本地方法。</p>\n</li>\n<li>\n<p>Vector API（预览）：为处理向量形式数据提供了一个类库，从而提高处理性能。</p>\n</li>\n</ul>\n<p>Java SE 17</p>\n<ul>\n<li>\n<p>Sealed Classes 和 Hidden Classes 的迭代升级。</p>\n</li>\n<li>\n<p><code>switch的模式匹配 (预览)</code> ：扩展了模式匹配功能，支持在 switch 语句中使用模式匹配，增强了代码的可读性和可维护性。</p>\n</li>\n<li>\n<p><code>接口中默认方法的隐式继承</code> ：使得接口的默认方法可以隐式继承自其他接口，而不需要进行实现。</p>\n</li>\n<li>\n<p>Enhanced Pseudo-Random Number Generators：升级并扩展了 Java 中的随机数生成器 API，支持更多的数据类型和方式。</p>\n</li>\n</ul>\n",
            "tags": [
                "Java",
                "Java基础",
                "Java基础-真题"
            ]
        },
        {
            "id": "http://example.com/java/java-se/java-excise/%E7%AC%AC17%E7%AB%A0%EF%BC%9A%E9%9A%8F%E5%A0%82%E5%A4%8D%E4%B9%A0%E4%B8%8E%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%A2%98%EF%BC%88%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%EF%BC%89/",
            "url": "http://example.com/java/java-se/java-excise/%E7%AC%AC17%E7%AB%A0%EF%BC%9A%E9%9A%8F%E5%A0%82%E5%A4%8D%E4%B9%A0%E4%B8%8E%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%A2%98%EF%BC%88%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%EF%BC%89/",
            "title": "宋红康_第17章：反射机制",
            "date_published": "2023-11-12T03:06:50.202Z",
            "content_html": "<h1 id=\"第17章随堂复习与企业真题反射机制\"><a class=\"anchor\" href=\"#第17章随堂复习与企业真题反射机制\">#</a> 第 17 章：随堂复习与企业真题（反射机制）</h1>\n<hr />\n<h2 id=\"一-随堂复习\"><a class=\"anchor\" href=\"#一-随堂复习\">#</a> 一、随堂复习</h2>\n<h3 id=\"1-反射的概述熟悉\"><a class=\"anchor\" href=\"#1-反射的概述熟悉\">#</a> 1. 反射的概述（熟悉）</h3>\n<ul>\n<li>Java 给我们提供了一套 API，使用这套 API 我们可以<font color='red'>在运行时动态的获取指定对象所属的类，创建运行时类的对象，调用指定的结构（属性、方法）等</font>。</li>\n<li>API：\n<ul>\n<li><code>java.lang.Class</code> ：代表一个类</li>\n<li>java.lang.reflect.Method：代表类的方法</li>\n<li>java.lang.reflect.Field：代表类的成员变量</li>\n<li>java.lang.reflect.Constructor：代表类的构造器</li>\n<li>… …</li>\n</ul>\n</li>\n<li>反射的优点和缺点\n<ul>\n<li><strong>优点：</strong>\n<ul>\n<li>\n<p>提高了 Java 程序的灵活性和扩展性， <code>降低了耦合性</code> ，提高 <code>自适应</code> 能力</p>\n</li>\n<li>\n<p>允许程序创建和控制任何类的对象，无需提前 <code>硬编码</code> 目标类</p>\n</li>\n</ul>\n</li>\n<li><strong>缺点：</strong>\n<ul>\n<li>反射的 <code>性能较低</code> 。\n<ul>\n<li>反射机制主要应用在对灵活性和扩展性要求很高的系统框架上</li>\n</ul>\n</li>\n<li>反射会 <code>模糊</code> 程序内部逻辑， <code>可读性较差</code> 。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>反射，平时开发中，我们使用并不多。主要是<font color='red'>在框架的底层使用</font>。</li>\n</ul>\n<h3 id=\"2-class反射的源头\"><a class=\"anchor\" href=\"#2-class反射的源头\">#</a> 2. Class: 反射的源头</h3>\n<img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230414145938600.png\" alt=\"image-20230414145938600\" style=\"zoom:67%;\" />\n<ul>\n<li>\n<p>Class 的理解 （掌握）</p>\n<pre><code>针对于编写好的.java源文件进行编译(使用javac.exe)，会生成一个或多个.class字节码文件。接着，我们使用\njava.exe命令对指定的.class文件进行解释运行。这个解释运行的过程中，我们需要将.class字节码文件加载(使用类的加载器)到内存中(存放在方法区)。加载到内存中的.class文件对应的结构即为Class的一个实例。\n</code></pre>\n</li>\n<li>\n<p><strong>获取 Class 的实例的几种方式</strong>（前三种）</p>\n<ul>\n<li><code>类.class</code></li>\n<li>对象.getClass ()</li>\n<li>（使用较多） <code>Class.forName(String className)</code></li>\n<li>(了解) 使用 ClassLoader 的方法 loadClass (String className)</li>\n</ul>\n</li>\n<li>\n<p>Class 可以指向哪些结构。</p>\n<pre><code>简言之，所有Java类型！\n（1）class：外部类，成员(成员内部类，静态内部类)，局部内部类，匿名内部类\n（2）interface：接口\n（3）[]：数组\n（4）enum：枚举\n（5）annotation：注解@interface\n（6）primitive type：基本数据类型\n（7）void\n</code></pre>\n</li>\n</ul>\n<h3 id=\"3-类的加载过程-类的加载器理解\"><a class=\"anchor\" href=\"#3-类的加载过程-类的加载器理解\">#</a> 3. 类的加载过程、类的加载器（理解）</h3>\n<img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20220417171411631.png\" alt=\"image-20220417171411631\" style=\"zoom: 50%;\" />\n<ul>\n<li>\n<p>类的加载过程</p>\n<pre><code>过程1：类的装载(loading)\n将类的class文件读入内存，并为之创建一个java.lang.Class对象。此过程由类加载器完成\n\n过程2：链接(linking)\n&gt; 验证(Verify):确保加载的类信息符合JVM规范，例如：以cafebabe开头，没有安全方面的问题。\n&gt; 准备(Prepare):正式为类变量（static）分配内存并设置类变量默认初始值的阶段，这些内存都将在方法区中进行分配。\n&gt; 解析(Resolve):虚拟机常量池内的符号引用（常量名）替换为直接引用（地址）的过程。\n\n过程3：初始化(initialization)\n执行类构造器&lt;clinit&gt;()方法的过程。\n类构造器&lt;clinit&gt;()方法是由编译期自动收集类中所有类变量的赋值动作和静态代码块中的语句合并产生的。\n</code></pre>\n</li>\n<li>\n<p>类的加载器</p>\n<pre><code>5.1 作用：负责类的加载，并对应于一个Class的实例。\n\n5.2 分类（分为两种）：\n&gt; BootstrapClassLoader:引导类加载器、启动类加载器\n     &gt; 使用C/C++语言编写的，不能通过Java代码获取其实例\n     &gt; 负责加载Java的核心库（JAVA_HOME/jre/lib/rt.jar或sun.boot.class.path路径下的内容）\n\n&gt; 继承于ClassLoader的类加载器\n    &gt; ExtensionClassLoader:扩展类加载器\n            &gt; 负责加载从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre/lib/ext子目录下加载类库\n    &gt; SystemClassLoader/ApplicationClassLoader:系统类加载器、应用程序类加载器\n            &gt; 我们自定义的类，默认使用的类的加载器。\n    &gt; 用户自定义类的加载器\n            &gt; 实现应用的隔离（同一个类在一个应用程序中可以加载多份）；数据的加密。\n</code></pre>\n</li>\n</ul>\n<h3 id=\"4-反射的应用1创建运行时类的对象重点\"><a class=\"anchor\" href=\"#4-反射的应用1创建运行时类的对象重点\">#</a> 4. 反射的应用 1：<mark>创建运行时类的对象</mark>（重点）</h3>\n<p><strong>方法 1：Class 实例的 newInstance () 方法</strong></p>\n<pre><code>Class clazz = Person.class;\n\n//创建Person类的实例\nPerson per = (Person) clazz.newInstance();\n\nSystem.out.println(per);\n</code></pre>\n<pre><code>要想创建对象成功，需要满足：\n条件1：要求运行时类中必须提供一个空参的构造器\n条件2：要求提供的空参的构造器的权限要足够。\n</code></pre>\n<p><strong>方法 2：Constructor 实例的 newInstance (Object ... objs) 方法</strong></p>\n<h3 id=\"5-反射的应用2获取运行时类所有的结构\"><a class=\"anchor\" href=\"#5-反射的应用2获取运行时类所有的结构\">#</a> 5. 反射的应用 2：获取运行时类所有的结构</h3>\n<pre><code>（了解）获取运行时类的内部结构1：所有属性、所有方法、所有构造器\n（熟悉）获取运行时类的内部结构2：父类、接口们、包、带泛型的父类、父类的泛型等\n</code></pre>\n<h3 id=\"6-反射的应用3调用指定的结构重点\"><a class=\"anchor\" href=\"#6-反射的应用3调用指定的结构重点\">#</a> 6. 反射的应用 3：<mark>调用指定的结构</mark>（重点）</h3>\n<ul>\n<li>属性</li>\n<li>方法</li>\n<li>构造器</li>\n</ul>\n<pre><code>3.1 调用指定的属性（步骤）\n步骤1.通过Class实例调用getDeclaredField(String fieldName)，获取运行时类指定名的属性\n步骤2. setAccessible(true)：确保此属性是可以访问的\n步骤3. 通过Filed类的实例调用get(Object obj) （获取的操作）\n                  或 set(Object obj,Object value) （设置的操作）进行操作。\n\n3.2 调用指定的方法（步骤）\n步骤1.通过Class的实例调用getDeclaredMethod(String methodName,Class ... args),获取指定的方法\n步骤2. setAccessible(true)：确保此方法是可访问的\n步骤3.通过Method实例调用invoke(Object obj,Object ... objs),即为对Method对应的方法的调用。\n     invoke()的返回值即为Method对应的方法的返回值\n     特别的：如果Method对应的方法的返回值类型为void，则invoke()返回值为null\n\n3.3 调用指定的构造器（步骤）\n步骤1.通过Class的实例调用getDeclaredConstructor(Class ... args)，获取指定参数类型的构造器\n步骤2.setAccessible(true)：确保此构造器是可以访问的\n步骤3.通过Constructor实例调用newInstance(Object ... objs),返回一个运行时类的实例。\n</code></pre>\n<h3 id=\"7-反射的应用4注解的使用了解\"><a class=\"anchor\" href=\"#7-反射的应用4注解的使用了解\">#</a> 7. 反射的应用 4：注解的使用（了解）</h3>\n<p>略</p>\n<h3 id=\"8-体会反射的动态性\"><a class=\"anchor\" href=\"#8-体会反射的动态性\">#</a> 8. 体会：反射的动态性</h3>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">ReflectTest</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token comment\">// 体会：静态性</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token class-name\">Person</span> <span class=\"token function\">getInstance</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>        <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token comment\">// 体会：反射的动态性</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token comment\">// 举例 1：</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">></span></span> <span class=\"token class-name\">T</span> <span class=\"token function\">getInstance</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> className<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">Exception</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>        <span class=\"token class-name\">Class</span> clazz <span class=\"token operator\">=</span> <span class=\"token class-name\">Class</span><span class=\"token punctuation\">.</span><span class=\"token function\">forName</span><span class=\"token punctuation\">(</span>className<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>        <span class=\"token class-name\">Constructor</span> con <span class=\"token operator\">=</span> clazz<span class=\"token punctuation\">.</span><span class=\"token function\">getDeclaredConstructor</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>        con<span class=\"token punctuation\">.</span><span class=\"token function\">setAccessible</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>        <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">)</span> con<span class=\"token punctuation\">.</span><span class=\"token function\">newInstance</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>    <span class=\"token annotation punctuation\">@Test</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">test1</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">Exception</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>        <span class=\"token class-name\">Person</span> p1 <span class=\"token operator\">=</span> <span class=\"token function\">getInstance</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>p1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>        <span class=\"token class-name\">String</span> className <span class=\"token operator\">=</span> <span class=\"token string\">\"com.atguigu04.other.dynamic.Person\"</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>        <span class=\"token class-name\">Person</span> per1 <span class=\"token operator\">=</span> <span class=\"token function\">getInstance</span><span class=\"token punctuation\">(</span>className<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>per1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>        <span class=\"token class-name\">String</span> className1 <span class=\"token operator\">=</span> <span class=\"token string\">\"java.util.Date\"</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre>        <span class=\"token class-name\">Date</span> date1 <span class=\"token operator\">=</span> <span class=\"token function\">getInstance</span><span class=\"token punctuation\">(</span>className1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"32\"></td><td><pre>        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>date1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"33\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"34\"></td><td><pre></pre></td></tr><tr><td data-num=\"35\"></td><td><pre>    <span class=\"token comment\">// 体会：反射的动态性</span></pre></td></tr><tr><td data-num=\"36\"></td><td><pre>    <span class=\"token comment\">// 举例 2：</span></pre></td></tr><tr><td data-num=\"37\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token class-name\">Object</span> <span class=\"token function\">invoke</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> className<span class=\"token punctuation\">,</span><span class=\"token class-name\">String</span> methodName<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">Exception</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"38\"></td><td><pre>        <span class=\"token comment\">//1. 创建全类名对应的运行时类的对象</span></pre></td></tr><tr><td data-num=\"39\"></td><td><pre>        <span class=\"token class-name\">Class</span> clazz <span class=\"token operator\">=</span> <span class=\"token class-name\">Class</span><span class=\"token punctuation\">.</span><span class=\"token function\">forName</span><span class=\"token punctuation\">(</span>className<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"40\"></td><td><pre></pre></td></tr><tr><td data-num=\"41\"></td><td><pre>        <span class=\"token class-name\">Constructor</span> con <span class=\"token operator\">=</span> clazz<span class=\"token punctuation\">.</span><span class=\"token function\">getDeclaredConstructor</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"42\"></td><td><pre>        con<span class=\"token punctuation\">.</span><span class=\"token function\">setAccessible</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"43\"></td><td><pre></pre></td></tr><tr><td data-num=\"44\"></td><td><pre>        <span class=\"token class-name\">Object</span> obj <span class=\"token operator\">=</span> con<span class=\"token punctuation\">.</span><span class=\"token function\">newInstance</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"45\"></td><td><pre></pre></td></tr><tr><td data-num=\"46\"></td><td><pre>        <span class=\"token comment\">//2. 获取运行时类中指定的方法，并调用</span></pre></td></tr><tr><td data-num=\"47\"></td><td><pre>        <span class=\"token class-name\">Method</span> method <span class=\"token operator\">=</span> clazz<span class=\"token punctuation\">.</span><span class=\"token function\">getDeclaredMethod</span><span class=\"token punctuation\">(</span>methodName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"48\"></td><td><pre>        method<span class=\"token punctuation\">.</span><span class=\"token function\">setAccessible</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"49\"></td><td><pre>        <span class=\"token keyword\">return</span> method<span class=\"token punctuation\">.</span><span class=\"token function\">invoke</span><span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"50\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"51\"></td><td><pre></pre></td></tr><tr><td data-num=\"52\"></td><td><pre>    <span class=\"token annotation punctuation\">@Test</span></pre></td></tr><tr><td data-num=\"53\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">test2</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">Exception</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"54\"></td><td><pre>        <span class=\"token class-name\">String</span> className <span class=\"token operator\">=</span> <span class=\"token string\">\"com.atguigu04.other.dynamic.Person\"</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"55\"></td><td><pre>        <span class=\"token class-name\">String</span> methodName <span class=\"token operator\">=</span> <span class=\"token string\">\"show\"</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"56\"></td><td><pre></pre></td></tr><tr><td data-num=\"57\"></td><td><pre>        <span class=\"token class-name\">Object</span> returnValue <span class=\"token operator\">=</span> <span class=\"token function\">invoke</span><span class=\"token punctuation\">(</span>className<span class=\"token punctuation\">,</span>methodName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"58\"></td><td><pre>        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>returnValue<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"59\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"60\"></td><td><pre></pre></td></tr><tr><td data-num=\"61\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h2 id=\"二-企业真题\"><a class=\"anchor\" href=\"#二-企业真题\">#</a> 二、企业真题</h2>\n<h3 id=\"21-反射概述\"><a class=\"anchor\" href=\"#21-反射概述\">#</a> 2.1 反射概述</h3>\n<h4 id=\"1-对反射了解吗反射有什么好处为什么需要反射微银行\"><a class=\"anchor\" href=\"#1-对反射了解吗反射有什么好处为什么需要反射微银行\">#</a> 1. 对反射了解吗？反射有什么好处？为什么需要反射？（微 * 银行）</h4>\n<pre><code>类似问题：\n&gt; Java反射的作用是什么？(三*重工、上海*和网络)\n&gt; Java反射机制的作用有什么？(上海明*物联网)\n&gt; 反射的具体用途？（阿***芝*信用项目组）\n</code></pre>\n<p><strong>Java 的反射机制</strong>：<font color='red'>在程序<u>运行时</u>，能够<u>动态加载并获取任意一个类的内部结构</u>，并能够直接<u>操作任意一个对象的属性和方法</u></font>。本质上，JVM 得到 class 对象之后，再通过 class 对象进行反编译，从而获取对象的各种信息。</p>\n<p><strong>好处</strong>：<font color='red'>可以在运行时动态地：<u>创建对象</u>、<u>调用指定结构</u>（属性、方法、构造器、父类、接口等）</font>，这样可以大大提高程序的灵活性和扩展性。</p>\n<p>Java 中使用反射机制是为了<strong>解决以下问题</strong>：</p>\n<ol>\n<li>\n<p>在程序<font color='red'>运行时动态获取类信息</font>，实现程序的灵活性和扩展性。</p>\n</li>\n<li>\n<p><font color='red'>编写通用代码</font>，无需针对每个具体的类编写特定的代码，提高了代码的重用率和通用性。</p>\n</li>\n<li>\n<p>实现一些特殊场景的需求，如<font color='red'>动态代理、自定义类加载器、工厂模式</font>等。</p>\n</li>\n</ol>\n<p>总之，反射机制允许程序在运行时动态地加载类和对类进行操作，从而增强了 Java 语言的灵活性和功能性，同时也带来一些设计和实现上的风险。</p>\n<h4 id=\"2-反射的使用场合和作用-及其优缺点软国际\"><a class=\"anchor\" href=\"#2-反射的使用场合和作用-及其优缺点软国际\">#</a> 2. 反射的使用场合和作用、及其优缺点（* 软国际）</h4>\n<pre><code>类似问题：\n&gt; 反射机制的优缺点(君*科技)\n&gt; Java反射你怎么用的？（吉*航空）\n</code></pre>\n<p>反射机制在 Java 中被广泛应用于以下<strong>使用场合</strong>：</p>\n<ol>\n<li><code>框架开发</code> ：在框架中，需要通过反射机制来加载和使用一些外部未知的类和对象，实现灵活性和扩展性。</li>\n<li><code>插件式开发</code> ：在 Java 应用程序中，可以使用反射机制动态地加载和调用其他模块的类和方法，从而实现插件化的设计。</li>\n<li><code>动态代理</code> ：通过反射机制，可以实现动态代理模式，为对象提供运行时的处理逻辑。</li>\n<li><code>单元测试</code> ：在 JUnit 等测试框架中，可以使用反射机制获取私有成员、构造器、方法，进行单元测试。</li>\n<li><code>JavaBean编程</code> ：在 JavaBean 编程中，可以使用反射机制获取 Bean 的属性和方法，实现通用的数据操作和转换。</li>\n</ol>\n<p>反射机制的<strong>作用</strong>：在运行时获取任意一个类的内部信息，并能够直接操作任意一个对象的内部属性和方法。</p>\n<ol>\n<li><code>动态加载类</code> ：通过反射机制，可以在运行时动态地加载其他模块或外部类，这对于框架开发、插件式编程等场合非常有用。</li>\n<li><code>调用构造器、属性和方法</code> ：通过反射机制，可以获取类的构造器、属性和方法，并且直接操作他们，比如修改私有属性、调用私有方法等。</li>\n<li>泛型编程：使用反射机制，可以在运行时获取泛型信息，从而实现指定类型的通用代码编写。</li>\n<li>动态代理：通过反射机制，可以在运行时动态生成代理对象，并在调用代理对象的方法时动态地执行相关逻辑。</li>\n<li>生成动态代码：通过反射机制，可以在运行时动态生成新的类和代码，从而增强应用程序的灵活性和可扩展性。</li>\n</ol>\n<p>反射机制的<strong>优点</strong>：</p>\n<ol>\n<li><code>动态性</code> ：通过反射机制，可以在运行时获取、操作任意一个类的内部信息，增强了 Java 语言的动态性和灵活性。</li>\n<li><code>通用性</code> ：通过反射机制，可以编写通用代码，并且不需要提前知道具体的类名和方法名，提高了代码的通用性和重用性。</li>\n<li><code>扩展性</code> ：通过反射机制，可以实现一些特殊场景的需求，如自定义类加载器、动态代理等，增强了程序的扩展性和功能性。</li>\n</ol>\n<p>反射机制的<strong>缺点</strong>：</p>\n<ol>\n<li><code>性能损失</code> ：使用反射机制会带来一定的性能损失，比直接调用代码要更慢。</li>\n<li><code>安全性风险</code> ：通过反射机制，可以打破访问修饰符（如 private、final 等），从而影响程序的安全性。</li>\n<li><code>代码可读性降低</code> ：使用反射机制，由于不确定操作的实体是什么，因此可能导致代码的可读性降低。</li>\n</ol>\n<h4 id=\"3-实现java反射的类有什么君科技\"><a class=\"anchor\" href=\"#3-实现java反射的类有什么君科技\">#</a> 3. 实现 Java 反射的类有什么？(君 * 科技)</h4>\n<pre><code>类似问题：\n&gt; Java反射 API 有几类？(北京*蓝)\n</code></pre>\n<p>Java 反射 API 主要包含以下几个核心的类和接口：</p>\n<p><code>java.lang.Class类</code> ：表示一个 Java 类，可以通过该类获取类名、类修饰符、构造器、方法、注解等信息，并实例化对象。</p>\n<p><code>java.lang.reflect包</code> 下：</p>\n<ul>\n<li>\n<p><code>Field类</code> ：表示一个类的属性或字段，可以通过该类获取属性的类型、修饰符、值并进行修改操作。</p>\n</li>\n<li>\n<p><code>Method类</code> ：表示一个类的方法，可以通过该类获取方法的返回值、参数、修饰符等信息，并且调用方法。</p>\n</li>\n<li>\n<p><code>Constructor类</code> ：表示一个类的构造器，可以通过该类获取构造器的修饰符、参数、并使用 newInstance 方法来创建对象。</p>\n</li>\n<li>\n<p><code>Modifier类</code> ：表示 Java 中的修饰符，可以通过该类判断某个成员是否具有某种修饰符，如 public、static、final 等等。</p>\n</li>\n</ul>\n<p>总之，这些类和接口提供了 Java 语言中反射机制的基础 API，开发者可以借助这些接口来操作和查询任意一个类的属性、方法和注解等信息。</p>\n<h4 id=\"4-反射是怎么实现的上海立网络\"><a class=\"anchor\" href=\"#4-反射是怎么实现的上海立网络\">#</a> 4. 反射是怎么实现的？（上海立 * 网络）</h4>\n<img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230414145938600.png\" alt=\"image-20230414145938600\" style=\"zoom:67%;\" />\n<p>Java 的反射机制是基于<strong> Java 虚拟机</strong>实现的。</p>\n<p>具体来说，Java 反射机制主要实现了以下几个步骤：</p>\n<ol start=\"0\">\n<li>\n<p>对于编写好的 <code>.java源文件</code> 使用<font color='red'>javac.exe 进行编译</font>，会生成一个或多个 <code>.class字节码文件</code> 。接着使用<font color='red'>java.exe 进行解释运行</font>，该过程中会使用<font color='red'>类的加载器</font>将.class 字节码文件加载到内存 (方法区) 中，对应的结构即为 <code>Class的一个实例</code> 。</p>\n<blockquote>\n<p>在 Java 程序<font color='red'>运行时，每个类都会被虚拟机加载，并转换成一个 Class 对象，这个 Class 对象保存了这个类的所有信息</font>，包括类名、继承关系、方法、变量等。因此，在运行时可以通过这个 Class 对象来访问和操作类的信息。</p>\n<p>Java 反射机制就是<font color='red'>利用这个 Class 对象</font>来实现的。通过反射，我们可以获得一个类的 Class 对象，并访问和操作这个类的所有信息，还可以根据需要动态地创建对象、调用方法和改变变量值等操作。</p>\n</blockquote>\n</li>\n<li>\n<p><strong>获取 Class 对象</strong>：使用 <code>Class.forName()</code>  方法或直接使用 <code>运行时类.class</code>  来获取一个类的 Class 对象。</p>\n</li>\n<li>\n<p><strong>获取运行时类的信息</strong>：通过 Class 对象可以获取类的名称、修饰符、父类、接口、构造函数、成员变量等信息。</p>\n</li>\n<li>\n<p><strong>创建对象</strong>：使用 <code>Class对象的newInstance()</code>  或 ** <code>Constructor对象的newInstance()</code> ** 方法来创建一个类的对象。</p>\n</li>\n<li>\n<p><strong>调用方法</strong>：使用 <code>Method对象的invoke()</code>  方法来调用一个对象的方法。</p>\n</li>\n<li>\n<p><strong>调用属性值</strong>：使用 <code>Field对象的get()/set()</code>  方法来读取 / 修改一个对象的属性值。</p>\n</li>\n</ol>\n<p>总之，Java 反射机制的实现依赖于 Java 虚拟机的能力，使得程序可以在运行时获得类的全部信息并进行操作。但在使用反射时需要注意性能、类型安全和访问权限等问题。</p>\n<h3 id=\"22-class的理解\"><a class=\"anchor\" href=\"#22-class的理解\">#</a> 2.2 Class 的理解</h3>\n<h4 id=\"1-class类的作用生成class对象的方法有哪些顺\"><a class=\"anchor\" href=\"#1-class类的作用生成class对象的方法有哪些顺\">#</a> 1. Class 类的作用？生成 Class 对象的方法有哪些？(顺 *)</h4>\n<p>Class 类表示一个 Java 类或接口，<strong>存放类的结构信息</strong>，是<strong> Java 反射机制的起源和入口</strong>，<strong>提供了获取类信息的相关方法</strong>。类信息包括：属性、方法、构造方法、父类、接口、注解、类名、包名等各种元数据信息。</p>\n<p>生成 Class 对象的方法主要有三种：</p>\n<ol>\n<li>\n<p><code>运行时类.class</code> ：如 String.class 就表示 String 类的 Class 对象，该方法是<font color='red'>最简单、最安全、最常见</font>的一种方式。</p>\n</li>\n<li>\n<p><code>运行时类实例.getClass()</code> ：例如 Object obj = new String (); Class&lt;?&gt; cls = obj.getClass (); 该方法适用于<font color='red'>已经获取到对象</font>的情况下，可以方便地获取该对象所属的类类型。</p>\n</li>\n<li>\n<p><code>Class.forName(className)</code> ：根据类的完整路径（全类名 = 包名 + 类名）来获取 Class 对象，例如 Class&lt;?&gt; cls = Class.forName (&quot;java.lang.String&quot;); 该方法适用于需要<font color='red'>动态加载类</font>的情况下，可以在<font color='red'>运行时加载并获取类的 Class 对象</font>。</p>\n</li>\n</ol>\n<p>总之，Java 中的 Class 类可以让我们在运行时动态地操作和访问类的变量、方法、构造器等各种元数据信息，是 Java 反射机制的基础。</p>\n<h4 id=\"2-classforname全路径-会调用哪些方法会调用构造方法吗加载的类会放在哪上银行外包\"><a class=\"anchor\" href=\"#2-classforname全路径-会调用哪些方法会调用构造方法吗加载的类会放在哪上银行外包\">#</a> 2. Class.forName (&quot;全路径&quot;) 会调用哪些方法？会调用构造方法吗？加载的类会放在哪？（上 * 银行外包）</h4>\n<img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20220417171411631.png\" alt=\"image-20220417171411631\" style=\"zoom: 50%;\" />\n<p>Class.forName (&quot;全路径&quot;) 是为了<font color='red'>将指定了全类名的类加载到内存中</font>。在类的加载过程中，会经历三个阶段：</p>\n<ul>\n<li>\n<p><code>装载（Loading）</code></p>\n</li>\n<li>\n<p><code>链接（Linking）</code></p>\n<ul>\n<li>验证（Verify）</li>\n<li>准备（Prepare）</li>\n<li>解析（Resolve）</li>\n</ul>\n</li>\n<li>\n<p><code>初始化（Initialization）</code> ：执行<strong>类构造器<clinit>() 方法</strong>。</p>\n<blockquote>\n<p><code>类构造器 &lt;clinit&gt;() 方法</code> 是一种特殊的类方法，用于编译器在编译时自动为每个 Java 类生成并插入的隐式构造代码块。主要有以下几个特点：</p>\n<ol>\n<li>\n<p>该方法<font color='red'>由编译器自动生成</font>；通常称之为 “类构造器” 或 “类初始化方法”，其名称中的 “&lt;” 和 “&gt;&quot; 符号表示该方法不是用户程序员定义的方法。</p>\n</li>\n<li>\n<p>该方法的访问修饰符是默认级别的（即 package-private），因为它<font color='red'>只能被 JVM 执行</font>，不能被程序显式调用。</p>\n</li>\n<li>\n<p><clinit>() 方法<font color='red'>是静态方法</font>，没有参数和返回值。</p>\n</li>\n<li>\n<p><font color='red'>在一个类第一次被使用时（加载类、创建实例等操作），JVM 会自动执行一次该类的 <clinit>() 方法</font>，并保证<font color='red'>线程安全</font>。</p>\n</li>\n<li>\n<p>该方法主要作用是 **<font color='red'>对类的 static 属性和 static 代码块进行初始化</font>**，确保类在第一次使用时被正确地初始化。</p>\n</li>\n<li>\n<p>当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要<font color='red'>先触发其父类的初始化</font>。</p>\n</li>\n</ol>\n<p>总之，Java 中的类构造器 <clinit>() 方法是编译器生成的一个特殊方法，主要用于对一个类的静态属性和静态代码块进行初始化，确保类在第一次使用时被正确地初始化。</p>\n<p>注：<strong><font color='red'>类构造器是构造类信息的，不是构造该类对象的构造器，因此不会调用构造方法</font></strong>。</p>\n</blockquote>\n</li>\n</ul>\n<p>加载的类放在 **<font color='red'>内存的方法区</font>**。</p>\n<h3 id=\"23-类的加载\"><a class=\"anchor\" href=\"#23-类的加载\">#</a> 2.3 类的加载</h3>\n<h4 id=\"1-类加载流程汇通-同顺-凡科技\"><a class=\"anchor\" href=\"#1-类加载流程汇通-同顺-凡科技\">#</a> 1. 类加载流程（汇 ** 通、同 * 顺、凡 * 科技）</h4>\n<img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20220417171411631.png\" alt=\"image-20220417171411631\" style=\"zoom: 50%;\" />\n<p>Java 类加载流程主要分为装载、链接和初始化三个阶段。</p>\n<ul>\n<li>\n<p><strong>装载（Loading）</strong>：<font color='red'>通过 <code>类加载器</code> 将 .class 字节码文件加载到 JVM 内存中</font>，在这个过程中会<font color='red'>生成一个对应的 Class 对象</font>，并<font color='red'>在 <code>方法区</code> 中存储类加载器、类变量以及常量池等信息</font>。</p>\n</li>\n<li>\n<p><strong>链接（Linking）</strong>：</p>\n<ul>\n<li>\n<p><font color='#B32015'>验证（Verify）</font>：确保类文件的字节流<font color='red'>符合 JVM 规范</font>，并能够安全地被执行。</p>\n</li>\n<li>\n<p><font color='#B32015'>准备（Prepare）</font>：<font color='red'>为类中的 <code>静态变量</code> 分配内存空间，并赋予默认初始值</font>（例如，int 类型变量默认值为 0）。</p>\n</li>\n<li>\n<p><font color='#B32015'>解析（Resolve）</font>：<font color='red'>将类文件中的<u>符号引用</u>替换成<u>直接引用</u></font>，例如将类中使用的其他类的符号引用映射为对应的直接引用。</p>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>初始化（Initialization）</strong>：JVM 在准备完毕后，会按照代码中的定义，对类进行初始化（即 **<font color='red'>执行 <code>类构造器（&lt;clinit&gt;() 方法）</code> </font><strong>的过程），主要是</strong><font color='red'>对 <code>静态属性</code> 进行赋值和 <code>静态代码块</code> 的执行</font>**。</p>\n</li>\n</ul>\n<p>需要注意的是：</p>\n<ol>\n<li>\n<p>如果父类还没有被初始化，则<font color='red'>父类先被初始化</font>；</p>\n</li>\n<li>\n<p>接口在初始化时<font color='red'>不会初始化其父接口</font>；</p>\n</li>\n<li>\n<p>当一个类被加载、链接和初始化后，就可以把它的实例对象创建出来了（通过 new 关键字）。</p>\n</li>\n</ol>\n<p>总之，Java 类的加载流程是一个复杂而紧密的过程，多个类加载器共同完成，它为 Java 虚拟机提供了动态连接能力，<font color='red'>使得程序运行时才装载这些类</font>，从而实现了更高效、安全和灵活的编程模式。</p>\n<h3 id=\"24-创建对象\"><a class=\"anchor\" href=\"#24-创建对象\">#</a> 2.4 创建对象</h3>\n<h4 id=\"1-说一下创建对象的几种方法华油集团-科软-凡科技\"><a class=\"anchor\" href=\"#1-说一下创建对象的几种方法华油集团-科软-凡科技\">#</a> 1. 说一下创建对象的几种方法？（华油 *** 集团、* 科软、凡 * 科技）</h4>\n<pre><code>类似问题：\n&gt; 除了使用new创建对象之外，还可以用什么方法创建对象？(*云网络)\n</code></pre>\n<p><img data-src=\"images/image-20221214145240412.png\" alt=\"image-20221214145240412\" /></p>\n<p>Java 中创建对象的方法有很多种，以下是其中的 5 种方式:</p>\n<ol>\n<li><code>new</code>  关键字<br />\n这是最常见的，也是最简单的创建对象的方式，通过这种方式我们还可以调用任意的构造器（无参的和有参的）。</li>\n</ol>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Main</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>        <span class=\"token class-name\">Person</span> person1 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>        <span class=\"token class-name\">Person</span> person2 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"fsx\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">18</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><ol start=\"2\">\n<li><code>Class实例.newInstance()</code> <br />\n 这是运用<font color='red'>反射</font>创建对象时最常用的方法，只能调用<font color='red'>无参构造器</font>，且<font color='red'>必须是 public 的</font>。</li>\n</ol>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token class-name\">Class</span> clazz <span class=\"token operator\">=</span> <span class=\"token class-name\">Class</span><span class=\"token punctuation\">.</span><span class=\"token function\">forName</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"com.example.Person\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token class-name\">Person</span> person <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Person</span><span class=\"token punctuation\">)</span> clazz<span class=\"token punctuation\">.</span><span class=\"token function\">newInstance</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><ol start=\"3\">\n<li><code>Constructor实例.newInstance()</code> <br />\n 这是运用<font color='red'>反射</font>创建对象时最常用的方法之一，可以调用<font color='red'>任何构造器</font>。</li>\n</ol>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token class-name\">Constructor</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Person</span><span class=\"token punctuation\">></span></span> constructor <span class=\"token operator\">=</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">.</span><span class=\"token function\">getConstructor</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token class-name\">Person</span> person <span class=\"token operator\">=</span> constructor<span class=\"token punctuation\">.</span><span class=\"token function\">newInstance</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"fsx\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">18</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><ol start=\"4\">\n<li><code>Clone()</code> <br />\n 这种方式不调用任何构造器，但是当前类需要实现 Cloneable 接口，并实现 clone ()，是通过调用 Object 类中的 clone () 方法来创建一个新的对象。</li>\n</ol>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Person</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Cloneable</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token class-name\">Object</span> <span class=\"token function\">clone</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">CloneNotSupportedException</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>        <span class=\"token keyword\">return</span> <span class=\"token keyword\">super</span><span class=\"token punctuation\">.</span><span class=\"token function\">clone</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><ol start=\"5\">\n<li><code>反序列化</code> <br />\n这种方式是通过将一个对象序列化成<font color='red'>二进制流</font>到一个文件或网络中，然后再从文件 / 网络中反序列化出来得到一个新的对象。借助<font color='red'>对象流（ObjectOutputStream、ObjectInputStream）</font>，以及<font color='red'>writeObject()、readObject()</font>方法。</li>\n</ol>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Main</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">Exception</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>        <span class=\"token class-name\">ObjectOutputStream</span> oos <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ObjectOutputStream</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">FileOutputStream</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"person.obj\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>        oos<span class=\"token punctuation\">.</span><span class=\"token function\">writeObject</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"fsx\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">18</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>        oos<span class=\"token punctuation\">.</span><span class=\"token function\">close</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>        <span class=\"token class-name\">ObjectInputStream</span> ois <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ObjectInputStream</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">FileInputStream</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"person.obj\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>        <span class=\"token class-name\">Person</span> person <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Person</span><span class=\"token punctuation\">)</span> ois<span class=\"token punctuation\">.</span><span class=\"token function\">readObject</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>        ois<span class=\"token punctuation\">.</span><span class=\"token function\">close</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h4 id=\"2-如何找到对象实际类的度\"><a class=\"anchor\" href=\"#2-如何找到对象实际类的度\">#</a> 2. 如何找到对象实际类的？（* 度）</h4>\n<p>可以使用 <code>getClass()</code>  方法来获取对象的实际类。</p>\n<p>例如，如果有一个名为 obj 的对象，可以使用以下代码获取它的实际类：</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token class-name\">Class</span> clazz <span class=\"token operator\">=</span> obj<span class=\"token punctuation\">.</span><span class=\"token function\">getClass</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h4 id=\"3-java反射创建对象效率高还是通过new创建对象的效率高为什么三重工\"><a class=\"anchor\" href=\"#3-java反射创建对象效率高还是通过new创建对象的效率高为什么三重工\">#</a> 3. Java 反射创建对象效率高还是通过 new 创建对象的效率高？为什么？(三 * 重工)</h4>\n<p>通过 <code>new</code>  创建对象的效率比较高。原因是，通过反射时，<font color='red'>先获取运行时类的 Class 对象</font>，<font color='red'>再获取构造函数</font>，<font color='red'>最后调用构造函数创建对象</font>，这个过程比较繁琐，所以效率较低。</p>\n<ol>\n<li>使用 new 关键字创建对象的示例代码：</li>\n</ol>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">MyClass</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">private</span> <span class=\"token keyword\">int</span> value<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    </pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token class-name\">MyClass</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> value<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>value <span class=\"token operator\">=</span> value<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    </pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token comment\">// other methods and fields</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token class-name\">MyClass</span> obj <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">MyClass</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><ol start=\"2\">\n<li>使用反射方式创建对象的示例代码：</li>\n</ol>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token class-name\">Class</span> clazz <span class=\"token operator\">=</span> <span class=\"token class-name\">MyClass</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token class-name\">Constructor</span> constructor <span class=\"token operator\">=</span> clazz<span class=\"token punctuation\">.</span><span class=\"token function\">getConstructor</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token class-name\">MyClass</span> obj <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">MyClass</span><span class=\"token punctuation\">)</span> constructor<span class=\"token punctuation\">.</span><span class=\"token function\">newInstance</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>在上面的示例代码中，首先<font color='red'>通过反射获取 MyClass 类的 Class 对象</font>，并<font color='red'>通过 Class 对象获取参数类型为 int 的构造函数</font>后，<font color='red'>再通过反射调用该构造函数创建对象</font>。</p>\n<h3 id=\"25-调用属性-方法\"><a class=\"anchor\" href=\"#25-调用属性-方法\">#</a> 2.5 调用属性、方法</h3>\n<h4 id=\"1-如何利用反射机制来访问一个类的方法神州软件\"><a class=\"anchor\" href=\"#1-如何利用反射机制来访问一个类的方法神州软件\">#</a> 1. 如何利用反射机制来访问一个类的方法？（神州 ** 软件）</h4>\n<pre><code>调用指定的方法（步骤）\n步骤1.通过Class的实例调用getDeclaredMethod(String methodName,Class ... args),获取指定的方法\n步骤2. setAccessible(true)：确保此方法是可访问的\n步骤3.通过Method实例调用invoke(Object obj,Object ... objs),即为对Method对应的方法的调用。\n     invoke()的返回值即为Method对应的方法的返回值\n     特别的：如果Method对应的方法的返回值类型为void，则invoke()返回值为null\n</code></pre>\n<p>利用反射机制来访问一个类的方法，可以通过以下步骤实现：</p>\n<ol>\n<li>\n<p><strong>获取运行时类的 Class 对象</strong>：使用 <code>Class.forName()</code>  或 <code>运行时类.class</code>  或 <code>运行时类的实例.getClass()</code>  方法。</p>\n</li>\n<li>\n<p><strong>获取目标方法的 Method 对象</strong>：通过 Class 的实例调用 <code>getDeclaredMethod(String methodName,Class ... args)</code>  方法。</p>\n</li>\n<li>\n<p><strong>确保方法可访问</strong>：如果目标方法是私有方法，还需要通过 <code>setAccessible(true)</code>  设置 Method 对象为可访问的。</p>\n</li>\n<li>\n<p><strong>调用目标方法</strong>：通过 Method 对象的 <code>invoke(Object obj,Object ... objs)</code>  方法。</p>\n</li>\n</ol>\n<p>下面提供一个示例代码：</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">// 定义一个测试类</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Test</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">sayHello</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Hello\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token comment\">// 调用 Test 类中的 sayHello 方法</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token class-name\">Class</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span><span class=\"token punctuation\">></span></span> clazz <span class=\"token operator\">=</span> <span class=\"token class-name\">Class</span><span class=\"token punctuation\">.</span><span class=\"token function\">forName</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Test\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token class-name\">Object</span> obj <span class=\"token operator\">=</span> clazz<span class=\"token punctuation\">.</span><span class=\"token function\">newInstance</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token class-name\">Method</span> method <span class=\"token operator\">=</span> clazz<span class=\"token punctuation\">.</span><span class=\"token function\">getDeclaredMethod</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"sayHello\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>method<span class=\"token punctuation\">.</span><span class=\"token function\">setAccessible</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>method<span class=\"token punctuation\">.</span><span class=\"token function\">invoke</span><span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>在上述示例代码中，首先通过 <code>Class.forName()</code>  方法获取 Test 类的 Class 对象，然后通过该对象获取 sayHello 方法的 Method 对象。由于 sayHello 方法是公共方法，因此无需设置 Method 对象为可访问的。最后通过 Method 对象的 <code>invoke()</code>  方法调用 sayHello 方法并输出结果。</p>\n<h4 id=\"2-如何利用反射机制来访问一个类的私有属性\"><a class=\"anchor\" href=\"#2-如何利用反射机制来访问一个类的私有属性\">#</a> 2. 如何利用反射机制来访问一个类的私有属性？</h4>\n<p>利用反射机制来访问一个类的私有属性，可以通过以下步骤实现：</p>\n<ol>\n<li>\n<p><strong>获取运行时类的 Class 对象</strong>：使用 <code>Class.forName()</code>  或 <code>object.getClass()</code>  方法。</p>\n</li>\n<li>\n<p><strong>获取指定属性的 Field 对象</strong>：通过 Class 对象的 <code>getDeclaredField(String fieldName)</code>  等方法。</p>\n</li>\n<li>\n<p><strong>设置 Field 对象为可访问的</strong>：使用 <code>setAccessible()</code>  方法设置为 true。</p>\n</li>\n<li>\n<p><strong>获取或者修改属性的值</strong>：使用 Field 对象的 <code>get(Object obj)</code>  和 <code>set(Object obj,Object value)</code>  方法。</p>\n</li>\n</ol>\n<p>下面是一个示例代码，用于演示如何使用反射机制访问一个类的私有属性。</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">java<span class=\"token punctuation\">.</span>lang<span class=\"token punctuation\">.</span>reflect<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">Field</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">MyClass</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> name<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token class-name\">MyClass</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> name<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> name<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token comment\">// other methods and fields</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">MainClass</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">NoSuchFieldException</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">IllegalAccessException</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>        <span class=\"token comment\">// 创建需要反射操作的对象</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>        <span class=\"token class-name\">MyClass</span> obj <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">MyClass</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"test\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>        <span class=\"token comment\">// 获取 MyClass 类中的 name 私有字段</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>        <span class=\"token class-name\">Field</span> field <span class=\"token operator\">=</span> obj<span class=\"token punctuation\">.</span><span class=\"token function\">getClass</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getDeclaredField</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"name\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>        <span class=\"token comment\">// 设置访问标志位，使得私有字段可访问</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>        field<span class=\"token punctuation\">.</span><span class=\"token function\">setAccessible</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>        <span class=\"token comment\">// 获取 name 字段的值</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>        <span class=\"token class-name\">String</span> nameValue <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">)</span> field<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>        <span class=\"token comment\">// 输出 name 字段的值</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>nameValue<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>        <span class=\"token comment\">// 修改 name 字段的值</span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre>        field<span class=\"token punctuation\">.</span><span class=\"token function\">set</span><span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">,</span> <span class=\"token string\">\"new_test\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"32\"></td><td><pre></pre></td></tr><tr><td data-num=\"33\"></td><td><pre>        <span class=\"token comment\">// 获取修改后的 name 字段值</span></pre></td></tr><tr><td data-num=\"34\"></td><td><pre>        nameValue <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">)</span> field<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"35\"></td><td><pre></pre></td></tr><tr><td data-num=\"36\"></td><td><pre>        <span class=\"token comment\">// 输出修改后的 name 字段值</span></pre></td></tr><tr><td data-num=\"37\"></td><td><pre>        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>nameValue<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"38\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"39\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>在上述示例代码中，我们首先创建一个名为 MyClass 的类，并定义了一个私有的属性 name。在 MainClass 中，我们首先通过 <code>getClass()</code>  方法获取对象所属类的 Class 对象，然后使用 <code>getDeclaredField()</code>  方法获取 name 属性，由于 name 是私有属性，所以需要设置 <code>setAccessible(true)</code>  使其可被访问。接着，我们调用 <code>get()</code>  方法获取 name 属性的值，并输出验证是否正确获取。最后，我们修改 name 属性的值，再次使用 <code>get()</code>  方法获取修改后的 name 属性值，输出验证是否修改成功。需要注意的是，访问私有属性需要抛出 NoSuchFieldException 和 IllegalAccessException 异常。</p>\n<h4 id=\"3-说一下java反射获取私有属性如何改变值阿麻信用项目组\"><a class=\"anchor\" href=\"#3-说一下java反射获取私有属性如何改变值阿麻信用项目组\">#</a> 3. 说一下 Java 反射获取私有属性，如何改变值？（阿 **** 麻信用项目组）</h4>\n<pre><code>调用指定的属性（步骤）\n步骤1.通过Class实例调用getDeclaredField(String fieldName)，获取运行时类指定名的属性\n步骤2. setAccessible(true)：确保此属性是可以访问的\n步骤3. 通过Filed类的实例调用get(Object obj) （获取的操作）\n                       或 set(Object obj,Object value) （设置的操作）进行操作。\n</code></pre>\n<pre><code>针对于核心源码的api，内部的私有的结构在jdk17中就不可以通过反射调用了。\n</code></pre>\n<p>使用 Java 反射机制可以获取私有属性，并通过反射修改其值。下面是一个示例代码，可以帮助理解反射如何获取私有属性并修改属性值。</p>\n<ul>\n<li>首先通过对象的 <code>getClass()</code>  方法获取对象所属类的 Class 对象</li>\n<li>然后使用 <code>getDeclaredField()</code>  方法获取 name 字段</li>\n<li>由于 name 是私有字段，所以需要设置 <code>setAccessible(true)</code>  来使其可被访问</li>\n<li>接着，我们调用 <code>set()</code>  方法对 name 字段进行赋值操作</li>\n<li>最后，我们再使用 <code>get()</code>  方法获取修改后的 name 字段值，输出验证是否修改成功</li>\n</ul>\n<p>需要注意的是，访问私有属性需要抛出 NoSuchFieldException 和 IllegalAccessException 异常。</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">class</span> <span class=\"token class-name\">MyClass</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> name <span class=\"token operator\">=</span> <span class=\"token string\">\"test\"</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token comment\">// getter and setter methods</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">MainClass</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">NoSuchFieldException</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">IllegalAccessException</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>        <span class=\"token comment\">// 创建需要反射操作的对象</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>        <span class=\"token class-name\">MyClass</span> obj <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">MyClass</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>        <span class=\"token comment\">// 获取 MyClass 类中的 name 私有字段</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>        <span class=\"token class-name\">Field</span> field <span class=\"token operator\">=</span> obj<span class=\"token punctuation\">.</span><span class=\"token function\">getClass</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getDeclaredField</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"name\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>        <span class=\"token comment\">// 设置访问标志位，使得私有字段可访问</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>        field<span class=\"token punctuation\">.</span><span class=\"token function\">setAccessible</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>        <span class=\"token comment\">// 修改 name 字段的值</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>        field<span class=\"token punctuation\">.</span><span class=\"token function\">set</span><span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">,</span> <span class=\"token string\">\"new_test\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>        <span class=\"token comment\">// 获取修改后的 name 字段值</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>        <span class=\"token class-name\">String</span> nameValue <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">)</span> field<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>        <span class=\"token comment\">// 输出修改后的 name 字段值</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>nameValue<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure>",
            "tags": [
                "Java",
                "Java基础",
                "Java基础-真题"
            ]
        },
        {
            "id": "http://example.com/java/java-se/java-excise/%E7%AC%AC16%E7%AB%A0%EF%BC%9A%E9%9A%8F%E5%A0%82%E5%A4%8D%E4%B9%A0%E4%B8%8E%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%A2%98%EF%BC%88%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%EF%BC%89/",
            "url": "http://example.com/java/java-se/java-excise/%E7%AC%AC16%E7%AB%A0%EF%BC%9A%E9%9A%8F%E5%A0%82%E5%A4%8D%E4%B9%A0%E4%B8%8E%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%A2%98%EF%BC%88%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%EF%BC%89/",
            "title": "宋红康_第16章：网络编程",
            "date_published": "2023-11-12T03:06:50.192Z",
            "content_html": "<h1 id=\"第16章随堂复习与企业真题网络编程\"><a class=\"anchor\" href=\"#第16章随堂复习与企业真题网络编程\">#</a> 第 16 章：随堂复习与企业真题（网络编程）</h1>\n<hr />\n<h2 id=\"一-随堂复习\"><a class=\"anchor\" href=\"#一-随堂复习\">#</a> 一、随堂复习</h2>\n<h3 id=\"1-网络编程概述\"><a class=\"anchor\" href=\"#1-网络编程概述\">#</a> 1. 网络编程概述</h3>\n<ul>\n<li>计算机网络：略</li>\n<li>网络编程的目的：直接或间接地通过网络协议与其它计算机实现数据交换，进行通讯。</li>\n<li>需要解决的三个问题：\n<ul>\n<li>问题 1：如何准确地<font color='red'>定位网络上一台或多台主机</font></li>\n<li>问题 2：如何<font color='red'>定位主机上的特定的应用</font></li>\n<li>问题 3：找到主机后，<font color='red'>如何可靠、高效地进行数据传输</font></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-要素1ip地址\"><a class=\"anchor\" href=\"#2-要素1ip地址\">#</a> 2. 要素 1：<strong>IP 地址</strong></h3>\n<ul>\n<li>使用具体的一个 ip 地址对应具体的一个互联网上的主机</li>\n<li>IP 分类：\n<ul>\n<li>角度一：IPv4、IPv6</li>\n<li>角度二：公网地址、私网地址（或局域网)</li>\n</ul>\n</li>\n<li>使用 InetAddress 类表示 IP 地址\n<ul>\n<li>实例化：<font color='gree'>getByName</font>(String host) 、<font color='gree'>getLocalHost</font>()</li>\n<li>常用方法：getHostName () 、getHostAddress ()</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"3-要素2端口号\"><a class=\"anchor\" href=\"#3-要素2端口号\">#</a> 3. 要素 2：<strong>端口号</strong></h3>\n<ul>\n<li>用于<font color='red'>区分同一台主机上的不同的进程</font></li>\n<li>不同的进程分配不同的端口号</li>\n<li>范围：0-65535</li>\n</ul>\n<h3 id=\"4-要素3网络通信协议\"><a class=\"anchor\" href=\"#4-要素3网络通信协议\">#</a> 4. 要素 3：<strong>网络通信协议</strong></h3>\n<ul>\n<li>这里有两套参考模型\n<ul>\n<li><code>OSI参考模型</code> ：模型过于理想化，未能在因特网上进行广泛推广</li>\n<li><code>TCP/IP参考模型(或TCP/IP协议)</code> ：事实上的国际标准。</li>\n</ul>\n</li>\n<li>在传输层中涉及到两个协议：TCP、UDP。二者的对比\n<ul>\n<li><code>TCP</code> ：可靠的连接（发送数据前，需要三次握手、四次挥手），进行大数据量的传输，效率低。</li>\n<li><code>UDP</code> ：不可靠的连接（发送前，不需要确认对方是否在）、使用数据报传输（限制在 64kb 以内）、效率高。</li>\n</ul>\n</li>\n<li>TCP 的三次握手、四次挥手（了解）</li>\n</ul>\n<h3 id=\"5-tcp网络编程\"><a class=\"anchor\" href=\"#5-tcp网络编程\">#</a> 5. TCP 网络编程</h3>\n<blockquote>\n<p>例题 1：客户端发送内容给服务端，服务端将内容打印到控制台上。</p>\n<p>例题 2：客户端发送文件给服务端，服务端将文件保存在本地。</p>\n<p>例题 3：从客户端发送文件给服务端，服务端保存到本地。并返回 “发送成功” 给客户端。并关闭相应的连接。</p>\n</blockquote>\n<h3 id=\"6-udp网络编程\"><a class=\"anchor\" href=\"#6-udp网络编程\">#</a> 6. UDP 网络编程</h3>\n<p>简单的理解 UDP 的数据传输。</p>\n<h3 id=\"7-url编程\"><a class=\"anchor\" href=\"#7-url编程\">#</a> 7. URL 编程</h3>\n<ul>\n<li>\n<p>Java 后台：将写好的 Java 程序部署在 Tomcat 服务器。启动 Tomcat 服务器。</p>\n</li>\n<li>\n<p>前台：使用浏览器进行访问。需要使用 url。（HTML+CSS+JavaScript）</p>\n</li>\n<li>\n<p>URL 的作用：<font color='red'>定位互联网上某一资源的地址</font>。</p>\n</li>\n<li>\n<p>URL 的格式：</p>\n</li>\n</ul>\n<pre><code>http://192.168.21.107:8080/examples/abcd.jpg?name=Tom   ---&gt; &quot;万事万物皆对象&quot;\n应用层协议 ip地址       端口号  资源地址   参数列表\n</code></pre>\n<ul>\n<li>使用 URL 实现数据的下载（了解）</li>\n</ul>\n<h2 id=\"二-企业真题\"><a class=\"anchor\" href=\"#二-企业真题\">#</a> 二、企业真题</h2>\n<h4 id=\"1-tcp协议和udp协议的区别华为\"><a class=\"anchor\" href=\"#1-tcp协议和udp协议的区别华为\">#</a> 1. TCP 协议和 UDP 协议的区别（华 ** 为）</h4>\n<p>TCP（传输控制协议）和 UDP（用户数据报协议）是互联网中用于数据传输的两个主要的传输层协议。它们的区别如下：</p>\n<ol>\n<li>\n<p><strong>连接方式</strong>：TCP 是基于连接的可靠协议，需要在通信前通过三次握手建立连接。而 UDP 不需要建立连接，可以直接发送数据包。</p>\n</li>\n<li>\n<p><strong>数据传输方式</strong>：TCP 是面向 <code>字节流</code> 的协议，将应用程序传来的数据拆分为小的数据段，并在确认收到所有数据后按照应用程序的要求进行重组。UDP 是面向 <code>数据报</code> 的协议，把数据打包成数据报，一次发送，一次接收。</p>\n</li>\n<li>\n<p><strong>可靠性</strong>：TCP 提供可靠性，利用 <code>序号、确认应答、重传等机制</code> 保证数据传输的可靠性。UDP 没有此类机制，传输数据时不保证可靠性。</p>\n</li>\n<li>\n<p><strong>效率</strong>：TCP 比 UDP 慢，因为 TCP 有较多的开销用于 <code>维护连接和保证可靠性</code> ；UDP 比 TCP 快，因为不需要进行连接状态的维护及重传机制等操作。</p>\n</li>\n<li>\n<p><strong>使用场景</strong>：TCP 适用于 <code>对数据可靠性要求较高</code> 的环境，例如文件传输、电子邮件和网页浏览。UDP 适用于 <code>实时性要求较高</code> 而且丢失一些数据也没有太大的影响的环境，例如在线游戏和视频流媒体。</p>\n</li>\n</ol>\n<h4 id=\"2-简单说说tcp协议的三次握手与四次挥手机制-科软\"><a class=\"anchor\" href=\"#2-简单说说tcp协议的三次握手与四次挥手机制-科软\">#</a> 2. 简单说说 TCP 协议的三次握手与四次挥手机制 （* 科软）</h4>\n<p>TCP 协议的三次握手和四次挥手是 TCP 连接建立和断开过程中的重要步骤，分别如下：</p>\n<ol>\n<li>\n<p><strong>三次握手</strong>：<br />\na. 客户端向服务器发送 SYN 包（SYN=1，ACK=0），表示 <code>请求建立连接</code> ；<br />\nb. 服务器收到客户端的 SYN 包后，回复一个 SYN 包（SYN=1，ACK=1），表示 <code>同意连接</code> ，并通过 ACK 字段确认客户端的请求；<br />\nc. 客户端收到来自服务器的 SYN-ACK 包后，再回复一个 ACK 包（SYN=0，ACK=1），表示 <code>连接建立成功</code> 。</p>\n</li>\n<li>\n<p><strong>四次挥手</strong>：<br />\na. 客户端向服务器发送 FIN 包（FIN=1，ACK=0），表示 <code>要关闭连接</code> ；<br />\nb. 服务器收到客户端的 FIN 包后，回复一个 ACK 包（ACK=1），表示 <code>已经接收到关闭请求</code> ；<br />\nc. 服务器回复一个 FIN 包（FIN=1，ACK=1），表示服务器 <code>已经准备好关闭连接</code> ；<br />\nd. 客户端收到服务器的 FIN 包后，再回复一个 ACK 包（ACK=1），表示 <code>已经接受到关闭请求</code> 。</p>\n</li>\n</ol>\n<p>这样，TCP 连接就成功地断开了。</p>\n",
            "tags": [
                "Java",
                "Java基础",
                "Java基础-真题"
            ]
        },
        {
            "id": "http://example.com/java/java-se/java-excise/%E7%AC%AC15%E7%AB%A0%EF%BC%9A%E9%9A%8F%E5%A0%82%E5%A4%8D%E4%B9%A0%E4%B8%8E%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%A2%98%EF%BC%88File%E7%B1%BB%E4%B8%8EIO%E6%B5%81%EF%BC%89/",
            "url": "http://example.com/java/java-se/java-excise/%E7%AC%AC15%E7%AB%A0%EF%BC%9A%E9%9A%8F%E5%A0%82%E5%A4%8D%E4%B9%A0%E4%B8%8E%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%A2%98%EF%BC%88File%E7%B1%BB%E4%B8%8EIO%E6%B5%81%EF%BC%89/",
            "title": "宋红康_第15章：File类与IO流",
            "date_published": "2023-11-12T03:06:50.184Z",
            "content_html": "<h1 id=\"第15章随堂复习与企业真题file类与io流\"><a class=\"anchor\" href=\"#第15章随堂复习与企业真题file类与io流\">#</a> 第 15 章：随堂复习与企业真题（File 类与 IO 流）</h1>\n<hr />\n<h2 id=\"一-随堂复习\"><a class=\"anchor\" href=\"#一-随堂复习\">#</a> 一、随堂复习</h2>\n<h3 id=\"1-file类的使用\"><a class=\"anchor\" href=\"#1-file类的使用\">#</a> 1. File 类的使用</h3>\n<ul>\n<li>File 类的一个实例对应着 <code>磁盘上的一个文件或文件目录</code> 。  ----&gt; “万事万物皆对象”</li>\n<li>（熟悉）File 的实例化、常用的方法</li>\n<li>File 类中 <code>只有新建、删除、获取路径等方法，不包含读写文件的方法，此时需要使用IO流</code></li>\n</ul>\n<h3 id=\"2-io流的概述\"><a class=\"anchor\" href=\"#2-io流的概述\">#</a> 2. IO 流的概述</h3>\n<ul>\n<li>IO 流的分类\n<ul>\n<li>流向：输入流、输出流</li>\n<li>处理数据单位：字节流、字符流</li>\n<li>流的角色： <code>节点流</code> 、 <code>处理流</code></li>\n</ul>\n</li>\n<li>IO 的 4 个抽象基类： <code>InputStream</code>  \\  <code>OutputStream</code>  \\  <code>Reader</code>  \\  <code>Writer</code></li>\n</ul>\n<img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230411183512545.png\" alt=\"image-20230411183512545\" style=\"zoom:50%;\" />\n<h3 id=\"3-节点流之文件流\"><a class=\"anchor\" href=\"#3-节点流之文件流\">#</a> 3. 节点流之：文件流</h3>\n<ul>\n<li><code>FileInputStream</code>  \\  <code>FileOutputStream</code>  \\  <code>FileReader</code>  \\  <code>FileWriter</code></li>\n<li>（掌握）读写数据的过程。\n<ul>\n<li>步骤 1：创建 File 类的对象，作为读取或写出数据的端点</li>\n<li>步骤 2：创建相关的流的对象</li>\n<li>步骤 3：读取、写出数据的过程</li>\n<li>步骤 4：关闭流资源</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"4-处理流之一缓冲流\"><a class=\"anchor\" href=\"#4-处理流之一缓冲流\">#</a> 4. 处理流之一：缓冲流</h3>\n<ul>\n<li><code>BufferedInputStream</code>  \\  <code>BufferedOutputStream</code>  \\  <code>BufferedReader</code>  \\  <code>BufferedWriter</code></li>\n<li>作用：实现更高效的读写数据的操作</li>\n</ul>\n<h3 id=\"5-处理流之二转换流\"><a class=\"anchor\" href=\"#5-处理流之二转换流\">#</a> 5. 处理流之二：转换流</h3>\n<ul>\n<li>层次 1：熟悉转换流的使用\n<ul>\n<li><code>InputStreamReader</code> 、 <code>OutputStreamWriter</code></li>\n</ul>\n</li>\n<li>层次 2：（掌握）字符的编码和解码的过程、常用的字符集\n<ul>\n<li>解决相关的问题：读写字符出现乱码！本质问题：使用的解码集与编码集不一致。</li>\n</ul>\n</li>\n</ul>\n<img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230411195403807.png\" style=\"zoom:80%;\" />\n<h3 id=\"6-处理流之三对象流\"><a class=\"anchor\" href=\"#6-处理流之三对象流\">#</a> 6. 处理流之三：对象流</h3>\n<ul>\n<li>层次 1：熟悉对象流的使用\n<ul>\n<li><code>ObjectInputStream</code> :<font color='red'>反序列化</font>时需要使用的 api</li>\n<li><code>ObjectOutputStream</code> :<font color='red'>序列化</font>时需要使用的 api</li>\n</ul>\n</li>\n<li>层次 2：对象的序列化机制\n<ul>\n<li>使用场景：不同的进程之间通信、客户端（或浏览器端）与服务器端传输数据</li>\n<li>自定义类要想实现序列化机制需要满足的要求及注意点。</li>\n</ul>\n</li>\n</ul>\n<img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230411144529975.png\" alt=\"image-20230411144529975\" style=\"zoom: 80%;\" />\n<h3 id=\"7-其它流的使用\"><a class=\"anchor\" href=\"#7-其它流的使用\">#</a> 7. 其它流的使用</h3>\n<ul>\n<li>了解：数据流：DataInputStream 、DataOutputStream</li>\n<li>了解：标准的输入流、标准的输出流： <code>System.in</code>  、 <code>System.out</code></li>\n<li>了解：打印流： <code>PrintStream</code> 、 <code>PrintWriter</code></li>\n</ul>\n<h2 id=\"二-企业真题\"><a class=\"anchor\" href=\"#二-企业真题\">#</a> 二、企业真题</h2>\n<h3 id=\"21-io流概述\"><a class=\"anchor\" href=\"#21-io流概述\">#</a> 2.1 IO 流概述</h3>\n<h4 id=\"1-谈谈java-io里面的常用类字节流字符流银数据\"><a class=\"anchor\" href=\"#1-谈谈java-io里面的常用类字节流字符流银数据\">#</a> 1. 谈谈 Java IO 里面的常用类，字节流，字符流 (银 * 数据)</h4>\n<img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230411183512545.png\" alt=\"image-20230411183512545\" style=\"zoom: 50%;\" />\n<p>按 <code>操作数据单位</code> 的不同分为：</p>\n<ul>\n<li>** 字节流（8bit）** 用于处理<font color='red'>二进制数据</font>，常用的类有 <code>InputStream</code>  和 <code>OutputStream</code> 。\n<ul>\n<li>常用的类有 <code>FileInputStream</code>  和 <code>FileOutputStream</code> ，它们分别用于从文件中读取和写入 <code>字节</code> 数据。</li>\n</ul>\n</li>\n<li>** 字符流（16bit）** 用于处理<font color='red'>文本数据</font>，常用的类有 <code>Reader</code>  和 <code>Writer</code> 。\n<ul>\n<li>常用的类有 <code>FileReader</code>  和 <code>FileWriter</code> ，它们分别用于从文件中读取和写入 <code>字符</code> 数据。</li>\n</ul>\n</li>\n</ul>\n<p>根据 <code>IO流的角色</code> 不同分为：<strong>节点流</strong>和<strong>处理流</strong>。</p>\n<ul>\n<li>\n<p><strong>节点流</strong>：直接从<font color='red'>数据源</font>或<font color='red'>目的地</font>读写数据</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20220412230745170.png\" alt=\"image-20220412230745170\" /></p>\n</li>\n<li>\n<p><strong>处理流</strong>：不直接连接到数据源或目的地，而是<font color='red'>“连接” 在已存在的流</font>（节点流或处理流）之上，通过对数据的处理为程序提供更为强大的读写功能。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20220412230751461.png\" alt=\"image-20220412230751461\" /></p>\n<ul>\n<li>\n<p><strong>缓冲流</strong>（ <code>BufferedInputStream</code> ,  <code>BufferedOutputStream</code> ,  <code>BufferedReader</code> ,  <code>BufferedWriter</code> ）</p>\n</li>\n<li>\n<p><strong>数据流</strong>（ <code>DataInputStream</code> ,  <code>DataOutputStream</code> ）等</p>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"2-java-中有几种类型的流jdk为每种类型的流提供一些抽象类以供继承请说出他们分别是哪些类上海厦联网-极科技\"><a class=\"anchor\" href=\"#2-java-中有几种类型的流jdk为每种类型的流提供一些抽象类以供继承请说出他们分别是哪些类上海厦联网-极科技\">#</a> 2. Java 中有几种类型的流？JDK 为每种类型的流提供一些抽象类以供继承，请说出他们分别是哪些类？（上海 * 厦 * 联网、极 * 科技）</h4>\n<p>在 Java 中，有四种类型的流：<strong>字节输入流</strong>、<strong>字节输出流</strong>、<strong>字符输入流</strong>和<strong>字符输出流</strong>。JDK 为每种类型的流都提供了抽象类以供继承。</p>\n<p>字节输入流的抽象类是 <code>InputStream</code> ，它定义了读取字节数据的方法。字节输出流的抽象类是 <code>OutputStream</code> ，它定义了写入字节数据的方法。</p>\n<p>字符输入流的抽象类是 <code>Reader</code> ，它定义了读取字符数据的方法。字符输出流的抽象类是 <code>Writer</code> ，它定义了写入字符数据的方法。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230410101610691.png\" alt=\"image-20230410101610691\" /></p>\n<h4 id=\"3-流一般需不需要关闭如果关闭的话用什么方法处理流是怎么关闭的银数据\"><a class=\"anchor\" href=\"#3-流一般需不需要关闭如果关闭的话用什么方法处理流是怎么关闭的银数据\">#</a> 3. 流一般需不需要关闭？如果关闭的话用什么方法？处理流是怎么关闭的？(银 * 数据)</h4>\n<p>是的，流在使用完毕后通常 <code>需要关闭</code> 。这样可以释放系统资源， <code>防止资源泄漏</code> 。可以使用 <code>close()</code>  方法来关闭流。</p>\n<p>在处理流时，只需要 <code>关闭最外层的流即可</code> 。当最外层的流被关闭时，它内部包装的所有流都会被自动关闭。</p>\n<p>例如，如果我们使用 <code>BufferedReader</code>  来包装 <code>FileReader</code> ，那么只需要调用 <code>BufferedReader</code>  的 <code>close()</code>  方法即可，它会自动关闭内部的 <code>FileReader</code> 。</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token class-name\">BufferedReader</span> br <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">BufferedReader</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">FileReader</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"file.txt\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token comment\">// ...</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>br<span class=\"token punctuation\">.</span><span class=\"token function\">close</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 关闭 BufferedReader，同时也会关闭内部的 FileReader</span></pre></td></tr></table></figure><p>在 Java 7 及以上版本中，还可以使用 <code>try-with-resources</code>  语句来自动关闭流。只需将流的声明放在 try 语句的括号中，当 try 语句块执行完毕后，流会被自动关闭。</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">try</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">BufferedReader</span> br <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">BufferedReader</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">FileReader</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"file.txt\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token comment\">// ...</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">&#125;</span> <span class=\"token comment\">// 当 try 语句块执行完毕后，br 会被自动关闭</span></pre></td></tr></table></figure><h4 id=\"4-outputstream里面的write是什么意思君科技\"><a class=\"anchor\" href=\"#4-outputstream里面的write是什么意思君科技\">#</a> 4. OutputStream 里面的 write () 是什么意思？(君 * 科技)</h4>\n<p><code>OutputStream</code>  类中的 <code>write()</code>  方法用于<font color='red'>将指定的<strong>字节</strong>数据写出到输出流</font>。它有三种重载形式：</p>\n<ul>\n<li><code>write(int b)</code> ：将指定的字节（ <code>b</code> ）写出到输出流。</li>\n<li><code>write(byte[] b)</code> ：将指定字节数组（ <code>b</code> ）中的所有字节写出到输出流。</li>\n<li><code>write(byte[] b, int off, int len)</code> ：将指定字节数组（ <code>b</code> ）中从偏移量（ <code>off</code> ）开始的 <code>len</code>  个字节写出到输出流。</li>\n</ul>\n<p>例如，下面的代码演示了如何使用 <code>FileOutputStream</code>  将字符串写入文件：</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token class-name\">String</span> str <span class=\"token operator\">=</span> <span class=\"token string\">\"Hello, world!\"</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">try</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">FileOutputStream</span> fos <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">FileOutputStream</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"file.txt\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    fos<span class=\"token punctuation\">.</span><span class=\"token function\">write</span><span class=\"token punctuation\">(</span>str<span class=\"token punctuation\">.</span><span class=\"token function\">getBytes</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h3 id=\"22-缓冲流\"><a class=\"anchor\" href=\"#22-缓冲流\">#</a> 2.2 缓冲流</h3>\n<h4 id=\"1-bufferedreader属于哪种流他主要是用来做什么的国电网\"><a class=\"anchor\" href=\"#1-bufferedreader属于哪种流他主要是用来做什么的国电网\">#</a> 1. BufferedReader 属于哪种流？他主要是用来做什么的？(国 * 电网)</h4>\n<p>属于 <code>字符输入流</code> ，它继承自 <code>Reader</code>  类。它的主要作用是<strong>为其他字符输入流（如 <code>FileReader</code> ）提供缓冲功能，以提高读取效率</strong>。</p>\n<p>当我们从 <code>BufferedReader</code>  中读取数据时，它会<font color='red'>一次性从底层输入流中读取多个字符并存储在 <code>内部缓冲区</code> 中</font>。这样，当我们<font color='red'>再次读取数据时，就可以直接从缓冲区中获取，而不需要再次访问底层输入流</font>。</p>\n<p>此外， <code>BufferedReader</code>  还提供了一些方便的方法，如 <code>readLine()</code> ，用于<font color='red'>读取一行文本，不包括换行符</font>。</p>\n<p>例如，下面的代码演示了如何使用 <code>BufferedReader</code>  来读取文件中的文本：</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">try</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">BufferedReader</span> br <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">BufferedReader</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">FileReader</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"file.txt\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token class-name\">String</span> line<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>line <span class=\"token operator\">=</span> br<span class=\"token punctuation\">.</span><span class=\"token function\">readLine</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>line<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h4 id=\"2-什么是缓冲区有什么作用北京中油\"><a class=\"anchor\" href=\"#2-什么是缓冲区有什么作用北京中油\">#</a> 2. 什么是缓冲区？有什么作用？(北京中油 **)</h4>\n<p>内部缓冲区是指<strong>缓冲流</strong>类（如 <code>BufferedInputStream</code> 、 <code>BufferedOutputStream</code>  和 <code>BufferedReader</code> 、 <code>BufferedWriter</code> ）内部<strong>用于临时存储数据的数组</strong>，类型为 <code>byte[]</code>  或 <code>char[]</code> ，大小默认是 <code>8192</code> ，当达到一定程度时，集中性的写出。它的作用是<strong>减少与磁盘的交互次数，从而提高读写效率</strong>。</p>\n<p>例如，在使用 <code>BufferedReader</code>  读取数据时，它会一次性从底层输入流中读取多个字符（char）并存储在内部缓冲区中。这样，当我们再次读取数据时，就可以直接从缓冲区中获取，而不需要再次访问底层输入流。这样可以减少对底层输入流的访问次数，从而提高读取效率。</p>\n<p>同理，在使用 <code>BufferedWriter</code>  写入数据时，它会先将数据写入内部缓冲区。当缓冲区满时，才会将数据一次性写入底层输出流。这样可以减少对底层输出流的访问次数，从而提高写入效率。</p>\n<h3 id=\"23-转换流\"><a class=\"anchor\" href=\"#23-转换流\">#</a> 2.3 转换流</h3>\n<h4 id=\"1-字节流和字符流是什么怎么转换北京蓝-海供应链管理\"><a class=\"anchor\" href=\"#1-字节流和字符流是什么怎么转换北京蓝-海供应链管理\">#</a> 1. 字节流和字符流是什么？怎么转换？(北京蓝 *、* 海 * 供应链管理）</h4>\n<p><strong>字节流</strong>用于处理 <code>二进制数据</code> ，常用的类有 <code>InputStream</code>  和 <code>OutputStream</code> 。</p>\n<p><strong>字符流</strong>用于处理 <code>文本数据</code> ，常用的类有 <code>Reader</code>  和 <code>Writer</code> 。</p>\n<p>在某些情况下，我们需要将字节流和字符流进行转换。例如，当我们从网络套接字（ <code>Socket</code> ）中读取文本数据时，需要将套接字的输入流（字节流）转换为字符流。</p>\n<p>可以使用处理流中的<strong>转换流</strong>来实现，常用的类有 <code>InputStreamReader</code>  和 <code>OutputStreamWriter</code> ，<font color='red'>用于实现字节流和字符流之间的转换</font>。这两个类分别继承自 <code>Reader</code>  和 <code>Writer</code> ，它们可以将字节流转换为字符流，或将字符流转换为字节流。</p>\n<p>例如，下面的代码演示了如何使用 <code>InputStreamReader</code>  将套接字的输入流（字节流）转换为字符流：</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token class-name\">Socket</span> socket <span class=\"token operator\">=</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">try</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">BufferedReader</span> br <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">BufferedReader</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">InputStreamReader</span><span class=\"token punctuation\">(</span>socket<span class=\"token punctuation\">.</span><span class=\"token function\">getInputStream</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token class-name\">String</span> line<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>line <span class=\"token operator\">=</span> br<span class=\"token punctuation\">.</span><span class=\"token function\">readLine</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>line<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230411195403807.png\" style=\"zoom:80%;\" />\n<h3 id=\"24-序列化\"><a class=\"anchor\" href=\"#24-序列化\">#</a> 2.4 序列化</h3>\n<h4 id=\"1-什么是java序列化如何实现君科技-上海厦物联网\"><a class=\"anchor\" href=\"#1-什么是java序列化如何实现君科技-上海厦物联网\">#</a> 1. 什么是 Java 序列化，如何实现 (君 * 科技、上海 * 厦物联网)</h4>\n<p>** <code>对象序列化机制</code>  ** 允许<font color='red'><strong>把<u>内存中的 Java 对象</u>转换成<u>平台无关的二进制流（字节序列）</u></strong>，以便将其存储在文件中或通过网络传输</font>。与之相反的过程称为反序列化，即从字节序列中恢复对象。当其它程序获取了这种二进制流，就可以恢复成原来的 Java 对象。</p>\n<p>要实现 Java 序列化，需要满足以下条件：</p>\n<ul>\n<li><strong>对象所属的类</strong>必须实现 <code>Serializable</code>  接口。这个接口是一个 <code>标记接口</code> ，没有任何方法，只是用来标识一个类是否支持序列化。</li>\n<li>对象中<strong>所有需要序列化的字段</strong>都必须是可序列化的。如果有不可序列化的字段，则需要将其声明为 <code>transient</code> ，以便在序列化时跳过该字段。</li>\n</ul>\n<p>可以使用 <code>ObjectOutputStream</code>  类来实现对象的序列化。它继承自 <code>OutputStream</code> ，提供了 <code>writeObject()</code>  方法用于将对象写入输出流。</p>\n<p>例如，下面的代码演示了如何使用 <code>ObjectOutputStream</code>  将一个对象序列化并写入文件：</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token class-name\">MyObject</span> obj <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">MyObject</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">try</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">ObjectOutputStream</span> oos <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ObjectOutputStream</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">FileOutputStream</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"file.ser\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    oos<span class=\"token punctuation\">.</span><span class=\"token function\">writeObject</span><span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>与之相反，可以使用 <code>ObjectInputStream</code>  类来实现对象的反序列化。它继承自 <code>InputStream</code> ，提供了 <code>readObject()</code>  方法用于从输入流中读取对象。</p>\n<p>例如，下面的代码演示了如何使用 <code>ObjectInputStream</code>  从文件中读取并反序列化一个对象：</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">try</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">ObjectInputStream</span> ois <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ObjectInputStream</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">FileInputStream</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"file.ser\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token class-name\">MyObject</span> obj <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">MyObject</span><span class=\"token punctuation\">)</span> ois<span class=\"token punctuation\">.</span><span class=\"token function\">readObject</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>序列化机制的实现步骤如下：</p>\n<ol>\n<li>\n<p>自定义<strong>类</strong>需要实现 <code>java.io.Serializable标识接口</code> ，否则在序列化时报错 <code>NotSerializableException</code></p>\n</li>\n<li>\n<p>自定义类需要显示声明一个静态常量： <code>static final long serialVersionUID</code> ，用来唯一标识当前类，值可以任意指定</p>\n<blockquote>\n<p>如果类没有显示定义 serialVersionUID，它的值是 Java 运行时环境根据类的内部细节 <code>自动生成</code> 的。若序列化后，类的实例变量做了修改， serialVersionUID  <code>可能发生变化</code> ，在反序列化时会因为序列版本号不匹配，导致反序列化时报错 <code>InvalidClassException</code> 。</p>\n<p>如果声明了 serialVersionUID ，即使在序列化完成之后修改了类，导致类重新编译，则原来的数据也能正常反序列化，只是新增的字段值是默认值而已。</p>\n<p>因此，建议显式声明 serialVersionUID 。</p>\n</blockquote>\n</li>\n<li>\n<p>自定义类的各个<strong>属性</strong>如果也要序列化的话</p>\n<ol>\n<li>对于基本数据类型，默认是可序列化的</li>\n<li>对于<strong>引用数据类型</strong>，要求实现 Serializable 接口，否则报错 <code>NotSerializableException</code></li>\n</ol>\n<blockquote>\n<ul>\n<li>\n<p>如果有一个属性不需要可序列化的，则该属性必须注明是<strong>瞬态</strong>的，使用  <code>transient</code>  关键字修饰</p>\n</li>\n<li>\n<p>静态（ <code>static</code> ）变量的值不会序列化，因为静态变量的值不属于某个对象</p>\n</li>\n</ul>\n</blockquote>\n</li>\n</ol>\n<img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230411144529975.png\" alt=\"image-20230411144529975\" style=\"zoom: 80%;\" />\n<h4 id=\"2-java有些类中为什么需要实现serializable接口阿校招\"><a class=\"anchor\" href=\"#2-java有些类中为什么需要实现serializable接口阿校招\">#</a> 2. Java 有些类中为什么需要实现 Serializable 接口？（阿 * 校招）</h4>\n<p><strong>便于此类的对象实现<u>序列化</u>操作</strong>。</p>\n<p>当一个类需要支持序列化时，它必须实现 <code>Serializable</code>  接口。序列化是指将对象转换为字节序列的过程，以便将其存储在文件中或通过网络传输。只有实现了 <code>Serializable</code>  接口的类才能被序列化。</p>\n<p><code>Serializable</code>  接口是一个标记接口，没有任何方法。它只是用来标识一个类是否支持序列化。当我们试图序列化一个未实现 <code>Serializable</code>  接口的对象时，会抛出 <code>NotSerializableException</code>  异常。</p>\n<p>许多 Java 类都实现了 <code>Serializable</code>  接口，以便支持序列化。例如，Java 集合框架中的许多类（如 <code>ArrayList</code> ,  <code>HashMap</code>  等）都实现了这个接口。</p>\n",
            "tags": [
                "Java",
                "Java基础",
                "Java基础-真题"
            ]
        },
        {
            "id": "http://example.com/java/java-se/java-excise/%E7%AC%AC14%E7%AB%A0%EF%BC%9A%E9%9A%8F%E5%A0%82%E5%A4%8D%E4%B9%A0%E4%B8%8E%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%A2%98%EF%BC%88%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%EF%BC%89/",
            "url": "http://example.com/java/java-se/java-excise/%E7%AC%AC14%E7%AB%A0%EF%BC%9A%E9%9A%8F%E5%A0%82%E5%A4%8D%E4%B9%A0%E4%B8%8E%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%A2%98%EF%BC%88%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%EF%BC%89/",
            "title": "宋红康_第14章：数据结构与集合源码",
            "date_published": "2023-11-12T03:06:50.174Z",
            "content_html": "<h1 id=\"第14章随堂复习与企业真题数据结构与集合源码\"><a class=\"anchor\" href=\"#第14章随堂复习与企业真题数据结构与集合源码\">#</a> 第 14 章：随堂复习与企业真题（数据结构与集合源码）</h1>\n<hr />\n<h2 id=\"一-随堂复习\"><a class=\"anchor\" href=\"#一-随堂复习\">#</a> 一、随堂复习</h2>\n<h3 id=\"1-数据结构\"><a class=\"anchor\" href=\"#1-数据结构\">#</a> 1. 数据结构</h3>\n<ul>\n<li>\n<p>数据结构的研究对象：</p>\n<ul>\n<li>① 数据间的 <code>逻辑关系</code> （集合关系、一对一、一对多、多对多）</li>\n<li>② 数据的 <code>存储结构</code> （或物理结构）\n<ul>\n<li>角度一：顺序结构、链式结构、索引结构、哈希结构</li>\n<li>角度二： <code>线性表</code> （一维数组、链表、栈、队列）、 <code>树</code> （二叉树、B + 树）、 <code>图</code> （多对多）、 <code>哈希表</code> （HashMap、HashSet)</li>\n</ul>\n</li>\n<li>③ 相关运算</li>\n</ul>\n</li>\n<li>\n<p>树（了解）</p>\n</li>\n<li>\n<p>相关数据结构的核心 <code>Node的设计</code> （单向链表、双向链表、二叉树、栈、队列）（理解）</p>\n</li>\n</ul>\n<h3 id=\"2-list接口下的实现类的源码剖析\"><a class=\"anchor\" href=\"#2-list接口下的实现类的源码剖析\">#</a> 2. List 接口下的实现类的源码剖析</h3>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">List 接口的实现类</th>\n<th style=\"text-align:center\"><em>ArrayList</em></th>\n<th style=\"text-align:center\"><s>Vector</s></th>\n<th style=\"text-align:center\">LinkedList</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">地位</td>\n<td style=\"text-align:center\">新版的动态数组</td>\n<td style=\"text-align:center\">旧版的动态数组</td>\n<td style=\"text-align:center\">链表</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">底层实现</td>\n<td style=\"text-align:center\">Object 数组，但可以扩容</td>\n<td style=\"text-align:center\">Object 数组</td>\n<td style=\"text-align:center\"><font color='red'>双向链表</font></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">默认的初始容量</td>\n<td style=\"text-align:center\">JDK6.0 及之前是 10；JDK8.0 之后是 <code>0</code> ，之后在添加第一个元素时，再创建长度为 10 的数组</td>\n<td style=\"text-align:center\"><code>10</code></td>\n<td style=\"text-align:center\">0</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">扩容机制</td>\n<td style=\"text-align:center\">默认扩容为原来的 <code>1.5倍</code></td>\n<td style=\"text-align:center\">默认扩容增加为原来的 <code>2倍</code></td>\n<td style=\"text-align:center\">不需要扩容</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">特点</td>\n<td style=\"text-align:center\">线程不安全、效率高</td>\n<td style=\"text-align:center\"><font color='red'>线程安全</font>、效率低</td>\n<td style=\"text-align:center\">线程不安全</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">使用场景</td>\n<td style=\"text-align:center\"><font color='red'>频繁追加、查找数据</font></td>\n<td style=\"text-align:center\">避免使用</td>\n<td style=\"text-align:center\"><font color='red'>频繁插入、删除数据</font></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">说明</td>\n<td style=\"text-align:center\">对于频繁访问列表中的某一个元素，只需要在列表末尾进行添加和删除元素操作的情况下</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">元素是通过指针相互连接的，在插入 / 删除元素时，只需要改动前后元素的指针即可</td>\n</tr>\n</tbody>\n</table>\n<p>【面试题】ArrayList、Vector、LinkedList 的三者的对比？</p>\n<ul>\n<li>\n<p>层次 1：</p>\n<ul>\n<li>Collection 接口的子接口 List: 存储有序的、可重复的数据 (&quot;动态&quot; 数组)\n<ul>\n<li>ArrayList: 主要实现类；线程不安全的、效率高；底层使用 Object [] 数组存储；添加数据、查找数据时，效率较高；在插入、删除数据时，效率较低</li>\n<li>LinkedList: 底层使用双向链表的方式进行存储；在对集合中的数据进行频繁的删除、插入操作时，建议使用此类在插入、删除数据时，效率较高；在添加数据、查找数据时，效率较低；</li>\n<li>Vector: 古老实现类；线程安全的、效率低；底层使用 Object [] 数组存储</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>层次 2：查看相关 api 的源码（见笔记，略）</p>\n</li>\n</ul>\n<h3 id=\"3-map接口下的实现类的源码剖析\"><a class=\"anchor\" href=\"#3-map接口下的实现类的源码剖析\">#</a> 3. Map 接口下的实现类的源码剖析</h3>\n<ul>\n<li><strong>（掌握）HashMap 的底层源码的剖析</strong></li>\n<li>（熟悉）LinkedHashMap 的底层源码的剖析</li>\n<li>（了解）HashSet、LinkedHashSet 的底层源码的剖析</li>\n</ul>\n<h2 id=\"二-企业真题\"><a class=\"anchor\" href=\"#二-企业真题\">#</a> 二、企业真题</h2>\n<h3 id=\"21-数据结构相关\"><a class=\"anchor\" href=\"#21-数据结构相关\">#</a> 2.1 数据结构相关</h3>\n<h4 id=\"1-链表和数组有什么区别腾\"><a class=\"anchor\" href=\"#1-链表和数组有什么区别腾\">#</a> 1. 链表和数组有什么区别？（腾 *）</h4>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\"></th>\n<th style=\"text-align:center\">数组</th>\n<th style=\"text-align:center\">链表</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">存储方式</td>\n<td style=\"text-align:center\">连续</td>\n<td style=\"text-align:center\">分散</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">内存分配方式</td>\n<td style=\"text-align:center\">静态分配</td>\n<td style=\"text-align:center\">动态分配</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">访问元素</td>\n<td style=\"text-align:center\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span></td>\n<td style=\"text-align:center\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">插入 / 删除元素</td>\n<td style=\"text-align:center\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></td>\n<td style=\"text-align:center\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span></td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"2-栈是如何运行的西信息技术\"><a class=\"anchor\" href=\"#2-栈是如何运行的西信息技术\">#</a> 2. 栈是如何运行的？(西 * 信息技术)</h4>\n<p>栈特点是 <code>先进后出（FILO）</code> ，数据只能在 <code>栈顶</code> 进行压入（push）和弹出（pop）操作。</p>\n<p>栈是种抽象数据结构 <code>ADT</code>  (abstract data type)，可以使用 <code>数组</code> 、 <code>链表</code> 实现栈结构。</p>\n<p>在 <code>计算机系统中</code> ，栈是一个具有以上属性的 <code>动态内存区域</code> ，程序可以将数据压入栈中，也可以将数据从栈中弹出，压栈操作时栈增大，弹出操作是栈减小</p>\n<h3 id=\"22-list集合源码相关\"><a class=\"anchor\" href=\"#22-list集合源码相关\">#</a> 2.2 List 集合源码相关</h3>\n<h4 id=\"1-arraylist的默认大小是多少以及扩容机制顺-凡科技\"><a class=\"anchor\" href=\"#1-arraylist的默认大小是多少以及扩容机制顺-凡科技\">#</a> 1. <mark>ArrayList 的默认大小是多少，以及扩容机制</mark>（顺 *、凡 * 科技）</h4>\n<pre><code>类似问题：\n&gt; 说说ArrayList的扩容机制吧(国*电网)\n&gt; 讲一下ArrayList的扩容机制（*实在）\n&gt; ArrayList的扩容机制，为什么是10，为什么是1.5倍（*软国际）\n</code></pre>\n<p>Java 中的 ArrayList 类实例化时如果不指定长度，底层数组初始化为 <code>&#123;&#125;</code> ，只有在 <code>首次添加元素时</code> 才会创建默认容量为 <code>10</code>  的数组。当元素数量超过 ArrayList 的容量时，ArrayList 会自动扩容到原来的 <code>1.5倍</code> 。ArrayList 的<mark>扩容机制</mark>如下：</p>\n<ol>\n<li>当添加新元素时，如果当前容量不足以容纳新元素，则会调用 <code>grow()</code>  方法进行扩容。</li>\n<li>grow () 方法会 <code>计算新容量newCapacity</code> ，其中 newCapacity = oldCapacity + (oldCapacity&gt;&gt; 1)，也就是<font color='red'>原有容量的 1.5 倍</font>。</li>\n<li>如果 newCapacity 仍然小于新添加元素后的数量，那么 newCapacity 就会被设置为<font color='red'>新添加元素后的数量</font>。</li>\n<li>然后，ArrayList 会调用 <code>copyOf(T[] original, int newLength)</code>  创建一个新的数组，并<font color='red'>将<u>原有元素</u>拷贝到新数组中</font>。</li>\n<li>最后，<font color='red'><u>新元素</u>会被添加到新数组的尾部</font>。</li>\n</ol>\n<p>需要注意的是，由于<font color='red'>扩容会涉及到数组的拷贝操作</font>，因此在实际开发中，尽量<font color='red'>避免频繁对 ArrayList 进行扩容</font>，以提高程序的性能。为了避免频繁扩容，<font color='red'>可以在创建 ArrayList 对象时，指定一个足够大的初始容量，以便能够容纳预期数量的元素</font>。</p>\n<h4 id=\"2-arraylist的底层是怎么实现的腾\"><a class=\"anchor\" href=\"#2-arraylist的底层是怎么实现的腾\">#</a> 2. ArrayList 的底层是怎么实现的？（腾 *）</h4>\n<pre><code>类似问题：\n集合类的ArrayList底层（安全不安全，扩容，初始大小，添加删除查询是怎么操作的，底层是什么组成的）\n（湖**利软件、汇*云通、猎*、苏州***动、上海*进天下、北京博*软件、*科软、大连*点科技、中*亿达、德*物流、天*伟业、猫*娱乐）\n</code></pre>\n<p>ArrayList 的底层实现是基于 <code>Object[]数组</code> 的。我们可以在集合中存储任意类型的数据，但是它是 <code>线程不安全</code> 的。由于它底层是基于数组实现的，所以它非常适合用于对元素进行查找， <code>查找效率非常高</code> 。</p>\n<p>当我们实例化一个 ArrayList 时，无参数构造函数默认将数组初始化为 <code>&#123;&#125;</code> ，只有在首次添加元素时为数组初始化长度为 <code>10</code> 。如果增加的元素个数超过了 10 个，那么 ArrayList 底层会新生成一个数组，长度为原数组的 <code>1.5倍</code> ，然后将原数组的内容 <code>复制</code> 到新数组当中，并且后续增加的内容都会 <code>追加</code> 到新数组。</p>\n<blockquote>\n<p>开发建议： <code>ArrayList(int capacity)&#123;&#125;</code>  创建指定长度的数组：开发中，如果能大体确认数组长度，推荐使用这种带参构造器，因为 <code>避免了扩容、复制数组带来的时空消耗</code> 。</p>\n</blockquote>\n<h4 id=\"3-在arraylist中remove后面几个元素该怎么做惠-中亿达\"><a class=\"anchor\" href=\"#3-在arraylist中remove后面几个元素该怎么做惠-中亿达\">#</a> 3. 在 ArrayList 中 remove 后面几个元素该怎么做？（惠 *、中 * 亿达）</h4>\n<p>前移。</p>\n<h4 id=\"4-arraylist17和18的区别拓思\"><a class=\"anchor\" href=\"#4-arraylist17和18的区别拓思\">#</a> 4. <mark>ArrayList1.7 和 1.8 的区别</mark>（拓 * 思）</h4>\n<p>JDK 1.8 和 1.7 中 ArrayList 最明显的区别就是<strong>底层数组的初始化方式</strong>。</p>\n<p>在 <code>JDK1.8</code>  中，如果不指定长度，使用 <code>无参构造方法</code>  ArrayList list = new ArrayList () 创建 List 集合时，底层的 Object [] elementData 初始化为 <code>&#123;&#125;（空的数组）</code> ，并没有直接创建长度为 10 的数组。而在第一次调用 <code>add()</code>  方法时，底层才创建了长度为 <code>10</code>  的数组，并将本次要添加的元素添加进去。这样做可<font color='red'>节省内存消耗</font>，因为在添加元素时，数组名将指针指向了新的数组，且老数组 {} 是一个空数组，这样有利于 System.gc ()，并不会一直占据内存。</p>\n<p>相比之下，在 <code>JDK1.7</code>  中，使用 <code>无参构造方法</code> 创建 List 集合时，底层直接创建了长度是 <code>10</code>  的 Object [] 数组 elementData。后续的添加和扩容操作与 JDK1.8 无异。</p>\n<h4 id=\"5-数组和-arraylist-的区别阿-科软\"><a class=\"anchor\" href=\"#5-数组和-arraylist-的区别阿-科软\">#</a> 5. <mark>数组和 ArrayList 的区别</mark>（阿 *、* 科软）</h4>\n<p>ArrayList 看做是对数组的常见操作的封装。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\"></th>\n<th style=\"text-align:center\">数组</th>\n<th style=\"text-align:center\">ArrayList</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">长度</td>\n<td style=\"text-align:center\">创建时确定，且长度固定</td>\n<td style=\"text-align:center\">长度是 <code>动态</code> 的</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">存储类型</td>\n<td style=\"text-align:center\">基本数据类型、引用数据类型</td>\n<td style=\"text-align:center\"><code>引用数据类型</code></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">操作</td>\n<td style=\"text-align:center\">基本的读写操作</td>\n<td style=\"text-align:center\">插入、删除、查找等 <code>高级操作</code></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">性能</td>\n<td style=\"text-align:center\"><code>随机访问</code> 性能更优</td>\n<td style=\"text-align:center\"><code>插入和删除</code> 性能更优</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">随机访问性能的说明</td>\n<td style=\"text-align:center\">可以直接通过 <code>索引</code> 来访问元素，<font color='red'>O(1)$</font></td>\n<td style=\"text-align:center\"><font color='red'>需要先检查索引是否越界，</font>这会增加一些开销</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">插入删除性能的说明</td>\n<td style=\"text-align:center\">需要 <code>创建一个新数组</code> ，然后将原数组中的元素复制到新数组中</td>\n<td style=\"text-align:center\">只需要 <code>移动元素</code> ，而不需要创建新的数组</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"6-什么是线程安全的list平金服\"><a class=\"anchor\" href=\"#6-什么是线程安全的list平金服\">#</a> 6. 什么是线程安全的 List？(平 * 金服)</h4>\n<p>线程安全的 List 是指可以在多线程环境下安全使用的 List。这意味着，当多个线程同时访问和修改同一个 List 时，它能够保证 <code>数据的一致性</code> 和正确性。</p>\n<p>Java 中提供了几种线程安全的 List 实现，包括 <code>Vector</code>  和 <code>CopyOnWriteArrayList</code> 。此外，我们还可以使用 <code>Collections.synchronizedList()</code>  方法来将任意一个 List 包装成线程安全的 List。</p>\n<p>需要注意的是，虽然线程安全的 List 可以在多线程环境下安全使用，但它们通常比非线程安全的 List（如 ArrayList） <code>性能低</code> 一些。因此，在选择使用哪种 List 时，应该根据实际情况进行权衡。</p>\n<h3 id=\"23-hashmap集合源码相关\"><a class=\"anchor\" href=\"#23-hashmap集合源码相关\">#</a> 2.3 HashMap 集合源码相关</h3>\n<h4 id=\"1-说说hahmap底层实现新股份-顺-猫娱乐\"><a class=\"anchor\" href=\"#1-说说hahmap底层实现新股份-顺-猫娱乐\">#</a> 1. <mark>说说 HahMap 底层实现</mark> (新 * 股份、顺 *、猫 * 娱乐)</h4>\n<pre><code>类似问题：\n&gt; HashMap的实现讲一下？（腾*，上海**网络）\n&gt; 说说HashMap的底层执行原理？（滴*，纬*软件，上海*想，*昂，*蝶**云，宇*科技，*东数科，猎*网）\n&gt; 详细说一下 HashMap 的 put 过程（*度）\n&gt; Java中的HashMap的工作原理是什么？（北京中**译咨询）\n&gt; 集合类的HashMap底层（安全不安全，扩容，初始大小，添加删除查询是怎么操作的，底层是什么组成的）（湖**利软件）\n&gt; HashMap 的存储过程（爱*信、杭州*智）\n&gt; Hashmap底层实现及构造（汇**通、猎*、苏州博*讯动、上海*进天下、北京博*软件、*科软、大连*点科技、中*亿达、德*物流、天*伟业、猫*娱乐）\n&gt; HashMap的实现原理（腾*、阿*）\n&gt; HaspMap底层讲一讲（*米）\n&gt; 说一下HashMap的实现，扩容机制？（*节）\n&gt; 讲一下 HashMap 中 put 方法过程？（阿*）\n</code></pre>\n<p><strong>HashMap 的底层实现原理</strong></p>\n<p>HashMap 是 Java 中一种常用的数据结构，它实现了 Map 接口，能够以 <code>键值对</code> 的形式存储数据。它的底层实现是基于 <code>哈希表</code> 的，具体来说，它是通过 <code>数组+单向链表+红黑树</code> 的形式来实现的。</p>\n<p><strong>HashMap 的 put (key,value) 过程</strong></p>\n<ol>\n<li>\n<p>计算 key 的哈希值，并将其映射到数组下标</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20220514190454633-1661448231965.png\" alt=\"image-20220514190454633\" /></p>\n<p>调用 <code>hashCode()</code>  和 <code>hash()</code>  计算 key 的哈希值 hash。</p>\n<p>并根据 <code>下式</code> 计算该键值对被分配到数组中的索引位置 index，</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>index <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>hash <span class=\"token operator\">&amp;</span> <span class=\"token punctuation\">(</span>capacity <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>其中 hash 是键的哈希值，capacity 是数组的长度，<font color='red'>&amp; 运算符是按位与运算</font>，运算结果的取值范围是 [0,capacity-1]，刚好对应数组的各个下标。</p>\n<p>下标位置称为 <code>桶（bucket）</code> 或 <code>槽（slot）</code> 。</p>\n<img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20220514190904009-1661448231966.png\" alt=\"image-20220514190904009\" style=\"zoom: 50%;\" />\n</li>\n<li>\n<p>检查该 bucket 是否为空</p>\n<p>如果空，就直接将键值对添加到该 bucket 上，然后返回 null。</p>\n<blockquote>\n<p>添加情况 1</p>\n</blockquote>\n<p>如果该 bucket 不为空，执行下一步。</p>\n</li>\n<li>\n<p>处理哈希冲突，采用链表或红黑树的方式将多个键值对存储在同一个槽中</p>\n<p>如果该槽中存在一个键值对 (k,v)， <code>其键k的hash与当前键key的hash相同</code> ，<strong>并且</strong>， <code>key.equals(k)返回ture</code> ，则将该键值对的值 v 替换为当前值 value，并返回旧值 v。</p>\n<blockquote>\n<p>修改 value</p>\n</blockquote>\n<p>若二者的 <code>hash不相同</code> ，<strong>或者</strong>， <code>key.equals(k)返回false</code> ，则将当前键值对先采用 <code>单向链式存储（尾插法）</code> 的方式添加到该 bucket 链表中，（当一个 bucket 中的链表长度超过一定 <code>阈值</code> （默认为 8）时，Java 会将该链表转化为 <code>红黑树</code> 。这是因为链表的查找时间复杂度是 O (n)，而<font color='red'>红黑树的查找时间复杂度是<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(log n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></font>，所以对于较长的链表，使用红黑树可以<font color='red'>提高查询效率</font>。）</p>\n<blockquote>\n<p>添加情况 2、3</p>\n</blockquote>\n</li>\n<li>\n<p>扩容</p>\n<p>当 HashMap 中的元素数量达到一定 <code>阈值</code> （即负载因子与容量的乘积）时会触发扩容操作，步骤如下：</p>\n<ul>\n<li>创建一个 <code>2倍长度的新数组</code></li>\n<li>将原数组中的元素 <code>重新计算哈希值</code> ，并 <code>重新分配</code> 到新数组中，会导致元素在新数组中的 <code>位置可能发生变化</code> 。</li>\n<li><code>释放原数组的空间</code> ，将新数组设置为当前数组。</li>\n</ul>\n<p>注意：</p>\n<p>HashMap 中 <code>负载因子默认是0.75</code> ，这意味着当 HashMap 中的元素数量达到数组长度的 75% 时，就会触发扩容操作。每次扩容时，它都会将数组的长度 <code>增加一倍</code> 。</p>\n<p>由于扩容操作需要重新计算所有元素的哈希值，并将它们添加到新数组中，这个过程需要大量的时间和内存。在创建 HashMap 时，如果我们能够预估元素数量，可以通过 <code>指定初始容量</code> 来 <code>避免不必要的扩容操作</code> ，从而提高性能。</p>\n</li>\n<li>\n<p>返回结果</p>\n<p>如果添加成功，返回 <code>null</code> 。</p>\n<p>如果修改成功，返回该键对应的 <code>旧值</code> 。</p>\n</li>\n</ol>\n<h4 id=\"2-hashmap初始值16临界值12是怎么算的软力\"><a class=\"anchor\" href=\"#2-hashmap初始值16临界值12是怎么算的软力\">#</a> 2. HashMap 初始值 16，临界值 12 是怎么算的（软 ** 力）</h4>\n<p>底层源码中定义的成员变量 “ <code>默认初始容量</code> ”：</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> <span class=\"token constant\">DEFAULT_INITIAL_CAPACITY</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span> <span class=\"token operator\">&lt;&lt;</span> <span class=\"token number\">4</span></pre></td></tr></table></figure><p>底层源码中定义的成员变量 “ <code>默认加载因子</code> ”：</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">float</span> <span class=\"token constant\">DEFAULT_LOAD_FACTOR</span> <span class=\"token operator\">=</span> <span class=\"token number\">0.75f</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>临界值 = 数组的长度 * 加载因子</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>newThr <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token constant\">DEFAULT_LOAD_FACTOR</span> <span class=\"token operator\">*</span> <span class=\"token constant\">DEFAULT_INITIAL_CAPACITY</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 16 * 0.75 = 12</span></pre></td></tr></table></figure><h4 id=\"3-hashmap长度为什么是2的幂次方国时代\"><a class=\"anchor\" href=\"#3-hashmap长度为什么是2的幂次方国时代\">#</a> 3. <mark>HashMap 长度为什么是 2 的幂次方？</mark>(国 * 时代)</h4>\n<p><strong>能保证哈希值能够均匀分布在数组中，从而减少哈希冲突</strong></p>\n<p>将 key 的哈希值 hash 映射到数组下标 i 的计算如下：</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>i <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;</span> hash</pre></td></tr></table></figure><p>其中 n 就是 HashMap 的长度，当 n 是 2 的幂次方时， <code>n-1的二进制是一个全为1的二进制数</code> 。这样，哈希值与数组长度减 1 的 <code>按位与运算</code> 结果的取值范围就在 <code>[0,table.length-1]</code>  上，对应数组的每个下标。这样可以减少哈希冲突，提高 HashMap 的性能。</p>\n<h4 id=\"4-hashmap怎么计算哈希值和索引扩容机制怎么解决hash冲突软国际-中软腾\"><a class=\"anchor\" href=\"#4-hashmap怎么计算哈希值和索引扩容机制怎么解决hash冲突软国际-中软腾\">#</a> 4. <mark>HashMap 怎么计算哈希值和索引？扩容机制？怎么解决 hash 冲突？</mark>（* 软国际、中软 * 腾）</h4>\n<pre><code>类似问题：\n&gt; HashMap key的哈希冲突了怎么做（新*股份）\n&gt; HashMap的默认大小是多少，以及扩容机制（顺*、凡*科技）\n&gt; 讲一下HashMap的扩容机制？（好实*）\n</code></pre>\n<p><strong>计算哈希值、索引</strong></p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20220514190454633-1661448231965.png\" alt=\"image-20220514190454633\" /></p>\n<p>在 HashMap 中，计算哈希值的方式是先调用键对象的 <code>hashCode()</code>  方法得到哈希值，然后再对哈希值进行一些额外的计算 <code>hash()</code> ，以增强哈希值的随机性，通过一些位运算（例如使用异或和移位等）来消除高位的影响，以此来得到最终的哈希值。</p>\n<p>计算哈希桶索引时，HashMap 会使用<u>哈希值</u>和<u>哈希桶长度减 1</u>的值进行 <code>按位与运算</code> ，得到一个<u>哈希桶索引</u>，计算公式如下：</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>i <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;</span> hash</pre></td></tr></table></figure><p><strong>扩容机制</strong></p>\n<p>当 HashMap 中的元素数量达到一定 <code>阈值</code> （即负载因子与容量的乘积）时会触发扩容操作，步骤如下：</p>\n<ul>\n<li>创建一个 <code>2倍长度的新数组</code></li>\n<li>将原数组中的元素 <code>重新计算哈希值</code> ，并 <code>重新分配</code> 到新数组中，会导致元素在新数组中的 <code>位置可能发生变化</code> 。</li>\n<li><code>释放原数组的空间</code> ，将新数组设置为当前数组。</li>\n</ul>\n<p>注意：</p>\n<p>HashMap 中 <code>负载因子默认是0.75</code> ，这意味着当 HashMap 中的元素数量达到数组长度的 75% 时，就会触发扩容操作。每次扩容时，它都会将数组的长度 <code>增加一倍</code> 。</p>\n<p>由于扩容操作需要重新计算所有元素的哈希值，并将它们添加到新数组中，这个过程需要大量的时间和内存。在创建 HashMap 时，如果我们能够预估元素数量，可以通过 <code>指定初始容量</code> 来 <code>避免不必要的扩容操作</code> ，从而提高性能。</p>\n<p><strong>处理哈希冲突</strong></p>\n<p>哈希冲突是指不同的键，其哈希值映射到同一个数组下标上。HashMap 使用 <code>链表</code> 或 <code>红黑树</code> 来存储哈希桶中的元素，以解决哈希冲突。</p>\n<ul>\n<li>\n<p>当添加一个键值对时，如果该键值对的哈希桶位置已经存在一个或多个键值对，那么 HashMap 就需要在这些键值对中查找具有相同键的键值对。</p>\n</li>\n<li>\n<p>在查找过程中，HashMap 会 <code>先比较键的哈希值</code> ，</p>\n<ul>\n<li>\n<p>如果不同，则说明这个键在哈希桶中不存在，可以将新的键值对添加到链表或红黑树中。</p>\n</li>\n<li>\n<p>如果哈希值相同，HashMap 会 <code>再比较键是否相等</code> ，</p>\n<ul>\n<li>\n<p>如果相等，则说明这个键在哈希桶中已经存在，需要用新的值替换旧的值。</p>\n</li>\n<li>\n<p>如果键不相等，则说明发生了哈希冲突，需要将新的键值对添加到链表或红黑树中。</p>\n<blockquote>\n<p>如果 <code>链表的长度超过8</code> ，且 <code>数组长度达到64</code>  时，则会将链表转化为红黑树。这是因为当链表长度较长时，查找键值对的时间复杂度可能会变为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>N</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(N)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span>，而红黑树的查找时间复杂度是<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(logN)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span>，因此<font color='red'>可以提高 HashMap 的查询性能</font>。</p>\n</blockquote>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"5-hashmap底层是数组链表有数组很快了为什么加链表润软件\"><a class=\"anchor\" href=\"#5-hashmap底层是数组链表有数组很快了为什么加链表润软件\">#</a> 5. HashMap 底层是数组 + 链表，有数组很快了，为什么加链表？（润 * 软件）</h4>\n<p>HashMap 底层使用链表是 <code>为了解决哈希冲突</code> 。</p>\n<p>当我们向 HashMap 中添加一个键值对时，它会先计算键的哈希值，然后根据哈希值确定这个键值对在数组中的位置。如果两个不同的键具有相同的哈希值，那么它们会被存储在同一个 bucket 中。这种情况被称为哈希冲突。</p>\n<p>为了解决哈希冲突，HashMap 会使用链表、红黑树来存储同一个 bucket 中的多个键值对。<font color='red'>每个 bucket 都可以看作是一个<u>链表的头节点</u>或<u>红黑树的根节点</u></font>。如果遇到哈希冲突，就将新的键值对<font color='red'>添加到链表或红黑树的<u>末尾</u></font>。</p>\n<p>但是，由于<font color='red'>链表和红黑树本身需要占用额外的空间</font>，因此在 HashMap 的设计中需要进行权衡。通常来说，<font color='red'>当哈希桶中的元素数量比较小时，使用链表就足够了</font>，而<font color='red'>当元素数量比较大时，使用红黑树可以更好地平衡时间和空间的开销</font>。为了提高 HashMap 的性能， <code>JDK8</code>  开始引入了一种基于 “ <code>链表和红黑树的自适应存储方式</code> ”，也就是说，</p>\n<ul>\n<li><strong><font color='red'>当链表中的元素数量超过 8 个，且数组长度达到 64 时，会将链表转换为红黑树</font></strong></li>\n<li><strong><font color='red'>当红黑树中的元素数量小于 6 个时，会将红黑树转换为链表</font></strong></li>\n</ul>\n<h4 id=\"6-hashmap为什么长度达到一定的长度要转化为红黑树度\"><a class=\"anchor\" href=\"#6-hashmap为什么长度达到一定的长度要转化为红黑树度\">#</a> 6. HashMap 为什么长度达到一定的长度要转化为红黑树（* 度）</h4>\n<pre><code>类似问题：\n&gt; HashMap为什么用红黑树（*软国际）\n</code></pre>\n<ul>\n<li>因为 <code>红黑树的增删改查操作的时间复杂度为O(logn)</code> ，比单向链表的 O (n) 效率高。</li>\n<li>可以 <code>避免出现极长的单链表</code> ，导致空间浪费，提高了空间利用率</li>\n</ul>\n<h4 id=\"7-hashmap什么时候扩充为红黑树什么时候又返回到链表汉\"><a class=\"anchor\" href=\"#7-hashmap什么时候扩充为红黑树什么时候又返回到链表汉\">#</a> 7. HashMap 什么时候扩充为红黑树，什么时候又返回到链表？（汉 *）</h4>\n<pre><code>类似问题：\n&gt; HashMap什么时候转换为红黑树（杭州*智公司）\n&gt; 当HashMap中相同hashcode值的数据超过多少时会转变成红黑树？（百*云创）\n&gt; 什么时候是数据+链表，什么时候是红黑树（*软国际）\n</code></pre>\n<p>链表 -&gt; 红黑树：当同一个 bucket 中的 <code>链表元素数量超过8</code> ，且 <code>数组长度达到64</code>  时，该 bucket 的链表需要转换为红黑树，这是为了<font color='red'>提高增删改查的性能</font>。</p>\n<p>红黑树 -&gt; 链表：当同一个 bucket 中的 <code>红黑树元素数量减少到6</code>  时，那么该 bucket 的红黑树转换回链表，这是为了<font color='red'>节省内存空间</font>。</p>\n<h4 id=\"8-在-jdk18中hashmap的数据结构与17相比有什么变化这些变化的好处在哪里海科\"><a class=\"anchor\" href=\"#8-在-jdk18中hashmap的数据结构与17相比有什么变化这些变化的好处在哪里海科\">#</a> 8. <mark>在 JDK1.8 中，HashMap 的数据结构与 1.7 相比有什么变化，这些变化的好处在哪里</mark>？（海 * 科）</h4>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">HashMap 的变化</th>\n<th style=\"text-align:center\">JDK7</th>\n<th style=\"text-align:center\">JDK8</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">table 数组类型</td>\n<td style=\"text-align:center\">Entry&lt;K,V&gt;[]</td>\n<td style=\"text-align:center\"><code>Node&lt;K,V&gt;</code> []</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">创建 HashMap 实例时</td>\n<td style=\"text-align:center\">默认初始化数组的容量是 16（饿汉式）</td>\n<td style=\"text-align:center\">没有初始化 table 数组（当首次添加映射元素时才将数组的容量初始化为 16）（ <code>懒汉式</code> ）</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">数据结构（七上八下）</td>\n<td style=\"text-align:center\">数组 + 单向链表（ <code>头插法</code> ）</td>\n<td style=\"text-align:center\">数组 + 单向链表（ <code>尾插法</code> ） +  <code>红黑树</code></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">单向链表←→红黑树</td>\n<td style=\"text-align:center\">×</td>\n<td style=\"text-align:center\">当某个索引位置 i 上的<font color='red'>链表的长度达到 8，且数组的长度超过 64</font>时，此索引位置上的元素要从单向链表改为红黑树，<font color='orange'>将增删改查的时间复杂度从<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span> 降到<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(log n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></font>。<br/>如果索引 i 位置是红黑树的结构，当不断删除元素的情况下，<font color='red'>当前索引 i 位置上的元素的个数低于 6 时</font>，要从红黑树改为单向链表，<font color='orange'>节省内存空间</font>。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">扩容条件</td>\n<td style=\"text-align:center\">size 达到 threshold，且 table [i]!=null</td>\n<td style=\"text-align:center\">size 达到 threshold，且 table [i]!=null；<br/>或者，<font color='red'>链表的长度达到 8，但数组的长度未超过 64</font></td>\n</tr>\n</tbody>\n</table>\n<p><strong>数据结构的变化</strong></p>\n<ul>\n<li>\n<p>JDK1.8 中的 HashMap 仍然使用数组和链表结构，但是 <code>当链表长度达到一定阈值时，会将链表转换成红黑树</code> ，好处：</p>\n<ul>\n<li><font color='red'>可以提高增删改查的性能</font>，因为红黑树在最坏情况也也能保证<font color='red'><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(logN)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span></font>的时间复杂度</li>\n<li>可以<font color='red'>避免出现极长的单链表</font>，导致空间浪费，提高了空间利用率</li>\n</ul>\n</li>\n<li>\n<p>此外，链表的插入方法从 jdk1.7 的头插法变成了 jdk1.8 的 <code>尾插法</code> ，好处：</p>\n<ul>\n<li><font color='red'>可以避免 JDK1.7 中，并发情况下，扩容，形成环状链表，造成死循环的问题</font>。</li>\n</ul>\n</li>\n</ul>\n<p><strong>其他变化</strong></p>\n<ul>\n<li>jdk1.7 中的 Entry 内部类，在 jdk1.8 中改名为 <code>Node</code></li>\n<li>HashMap 调用无参构造器进行实例化时，在 jdk1.7 中会将数组的容量初始化为 16（饿汉式），在 jdk1.8 中不会初始化数组（懒汉式：只在首次添加元素时，才将数组容量初始化为 16），好处是：\n<ul>\n<li><font color='red'>减少内存的浪费</font>：在实例化 HashMap 对象时，如果立即初始化底层数组的大小，可能会导致数组过大或过小，从而浪费内存</li>\n</ul>\n</li>\n<li>jdk1.7 的扩容条件是 <code>size达到threshold，且table[i]!=null</code> ，jdk1.8 在此基础上增加了一个可以触发扩容操作的条件：遇到哈希冲突时，如果 <code>链表的长度达到8，但数组的长度未超过64</code> ，也需要扩容。</li>\n</ul>\n<h4 id=\"9-hashmap的get方法的原理顺\"><a class=\"anchor\" href=\"#9-hashmap的get方法的原理顺\">#</a> 9. HashMap 的 get () 方法的原理？（顺 *）</h4>\n<ol>\n<li>计算键的哈希值。</li>\n<li>使用哈希值来确定键值对在 HashMap 内部数组中的索引位置。</li>\n<li>检查该索引位置是否为空。如果为空，则返回 null。</li>\n<li>如果该索引位置不为空，则检查该位置的第一个元素是否与给定键匹配。如果匹配，则返回与该键关联的值。</li>\n<li>如果第一个元素与给定键不匹配，则遍历该位置处的链表（或红黑树），直到找到与给定键匹配的元素或到达链表末尾。</li>\n<li>如果找到匹配项，则返回与该键关联的值；否则，返回 null。</li>\n</ol>\n<h4 id=\"10-hashmap的remove方法的原理\"><a class=\"anchor\" href=\"#10-hashmap的remove方法的原理\">#</a> 10. HashMap 的 remove () 方法的原理？</h4>\n<ol>\n<li>计算键的哈希值。</li>\n<li>使用哈希值来确定键值对在 HashMap 内部数组中的索引位置。</li>\n<li>检查该索引位置是否为空。如果为空，则返回 null。</li>\n<li>如果该索引位置不为空，则检查该位置的第一个元素是否与给定键匹配。如果匹配，则删除该元素并返回与该键关联的值。</li>\n<li>如果第一个元素与给定键不匹配，则遍历该位置处的链表（或红黑树），直到找到与给定键匹配的元素或到达链表末尾。</li>\n<li>如果找到匹配项，则删除该元素并返回与该键关联的值；否则，返回 null。</li>\n</ol>\n<h3 id=\"24-hashcode和equals\"><a class=\"anchor\" href=\"#24-hashcode和equals\">#</a> 2.4 hashCode 和 equals</h3>\n<h4 id=\"1-hashcode和equals的区别海供应链管理\"><a class=\"anchor\" href=\"#1-hashcode和equals的区别海供应链管理\">#</a> 1. <mark>hashCode () 和 equals () 的区别？</mark>（海 * 供应链管理）</h4>\n<p>hashCode () 和 equals () 都是 Java 中 Object 类中定义的方法，用于 <code>判断对象是否相等</code> 。它们通常被重写，并且一起使用，用于在集合类（如 HashMap）中确定对象的唯一性。</p>\n<ul>\n<li>hashCode()： <code>根据对象的属性计算对象的哈希码值</code> ，是一个整数。哈希码值通常用于快速确定对象在集合中的位置。例如，在 HashMap 中，hashCode () 方法用于确定键值对在内部数组中的索引位置。\n<ul>\n<li><font color='red'>如果两个对象的哈希码不相等，则它们肯定不相等</font></li>\n<li>反之，<font color='red'>如果两个对象的哈希码相等，则它们不一定相等，还需要调用 equals () 进一步判断</font></li>\n</ul>\n</li>\n<li>equals()：\n<ul>\n<li><font color='cornflowerblue'>默认情况下</font>，equals () 方法 <code>比较的是两个对象的引用值</code> ，即它们是否指向同一个内存地址。</li>\n<li>但<font color='cornflowerblue'>通常被重写</font>，用于 <code>比较两个对象（的属性）是否相等</code> 。</li>\n<li>在 HashMap 中，如果两个键具有相同的哈希码值，则会调用 equals () 方法来确定它们是否真正相等。</li>\n</ul>\n</li>\n<li>二者之间有一个重要的关系：如果两个对象使用 equals () 方法比较相等，则它们必须具有相同的哈希码值。这意味着，<font color='red'>如果重写了 equals () 方法，则也必须重写 hashCode () 方法</font>，以确保它们之间的 <code>一致性</code> 。</li>\n</ul>\n<h4 id=\"2-hashcode-与-equals-生成算法-方法怎么重写阿校招\"><a class=\"anchor\" href=\"#2-hashcode-与-equals-生成算法-方法怎么重写阿校招\">#</a> 2. <mark>hashCode () 与 equals () 生成算法、方法怎么重写？</mark>（阿 * 校招）</h4>\n<p><strong>省流版</strong></p>\n<p><code>equals()判断中使用的属性，通常也都会参与到hashCode()的计算中</code> 。</p>\n<p>重写时可以借助 <code>Objects.equals</code>  和 <code>Objects.hash()</code> 。</p>\n<p><strong>详细版</strong></p>\n<p>hashCode () 方法用于返回对象的哈希码，重写该方法时需要满足以下 <code>规则</code> ：</p>\n<ul>\n<li>如果两个对象使用 equals () 方法比较返回 true，那么它们的 hashCode () 方法返回的值必须相等；</li>\n<li>如果两个对象使用 equals () 方法比较返回 false，那么它们的 hashCode () 方法返回的值可以相等，也可以不相等；</li>\n<li>如果两个对象使用 equals () 方法比较返回 false，但是它们的 hashCode () 方法返回的值相等，那么它们被称为<font color='red'>哈希冲突</font>，可能会影响散列表等数据结构的性能。</li>\n</ul>\n<p>常见的 hashCode () 方法 <code>实现方式</code> 有：</p>\n<ul>\n<li>对象的属性值的异或和；</li>\n<li>乘法因子法；</li>\n<li>幂和积法等。</li>\n</ul>\n<p>具体实现可以根据业务需求和对象的属性值来选择。</p>\n<p>equals () 方法用于比较两个对象是否相等，重写该方法时需要满足以下 <code>规则</code> ：</p>\n<ul>\n<li>自反性：对于任意非空的引用值 x，x.equals (x) 必须返回 true；</li>\n<li>对称性：对于任意非空的引用值 x 和 y，如果 x.equals (y) 返回 true，那么 y.equals (x) 也必须返回 true；</li>\n<li>传递性：对于任意非空的引用值 x、y 和 z，如果 x.equals (y) 返回 true，并且 y.equals (z) 返回 true，那么 x.equals (z) 也必须返回 true；</li>\n<li>一致性：对于任意非空的引用值 x 和 y，在对象的属性值没有改变的情况下，多次调用 x.equals (y) 的结果必须一致；</li>\n<li>对于任意非空的引用值 x，x.equals (null) 必须返回 false。</li>\n</ul>\n<p>常见的 equals () 方法 <code>实现方式</code> 有：</p>\n<ul>\n<li>比较两个对象的引用值是否相等；</li>\n<li>比较两个对象的属性值是否相等；</li>\n<li>比较两个对象的类型是否相等等。</li>\n</ul>\n<p>具体实现可以根据业务需求和对象的属性值来选择。</p>\n<p>示例代码：</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Person</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> name<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">private</span> <span class=\"token keyword\">int</span> age<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> name<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> age<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> name<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>age <span class=\"token operator\">=</span> age<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token annotation punctuation\">@Override</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">hashCode</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>        <span class=\"token comment\">// 方式一：乘法因子法</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>        <span class=\"token comment\">// int result = 17;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>        <span class=\"token comment\">// result = 31 * result + name.hashCode();</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>        <span class=\"token comment\">// result = 31 * result + age;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>        <span class=\"token comment\">// return result;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>        </pre></td></tr><tr><td data-num=\"18\"></td><td><pre>        <span class=\"token comment\">// 方式二：借助 Objects.hash ()</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>        <span class=\"token keyword\">return</span> <span class=\"token class-name\">Objects</span><span class=\"token punctuation\">.</span><span class=\"token function\">hash</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">,</span> age<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>    <span class=\"token annotation punctuation\">@Override</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">equals</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Object</span> obj<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>        <span class=\"token comment\">// 判断传入的对象是否为当前对象的引用</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span> <span class=\"token operator\">==</span> obj<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>        <span class=\"token comment\">// 判断传入的对象是否属于当前类型</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>obj <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">||</span> <span class=\"token function\">getClass</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> obj<span class=\"token punctuation\">.</span><span class=\"token function\">getClass</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>        <span class=\"token comment\">// 如果传入的对象属于当前类型，则进行强制转换</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>        <span class=\"token class-name\">Person</span> person <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Person</span><span class=\"token punctuation\">)</span> obj<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>        <span class=\"token comment\">// 方式一：</span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre>        <span class=\"token comment\">// return age == person.age &amp;&amp; name.equals(person.name);</span></pre></td></tr><tr><td data-num=\"32\"></td><td><pre>        </pre></td></tr><tr><td data-num=\"33\"></td><td><pre>        <span class=\"token comment\">// 方式二：借助 Integer.compare ()、Objects.equals ()</span></pre></td></tr><tr><td data-num=\"34\"></td><td><pre>        <span class=\"token keyword\">return</span> <span class=\"token class-name\">Integer</span><span class=\"token punctuation\">.</span><span class=\"token function\">compare</span><span class=\"token punctuation\">(</span>age<span class=\"token punctuation\">,</span>person<span class=\"token punctuation\">.</span>age<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token class-name\">Objects</span><span class=\"token punctuation\">.</span><span class=\"token function\">equals</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">,</span>person<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"35\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"36\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h4 id=\"3-说一下equals和的区别equals相等hash值一定相等吗hash值相等equals一定相等吗南电网-上海智网络\"><a class=\"anchor\" href=\"#3-说一下equals和的区别equals相等hash值一定相等吗hash值相等equals一定相等吗南电网-上海智网络\">#</a> 3. 说一下 equals 和 == 的区别，equals 相等 hash 值一定相等吗？hash 值相等 equals 一定相等吗？（南 * 电网、上海 * 智网络）</h4>\n<p>首先， <code>==</code>  是一个运算符，而 <code>equals()</code>  是一个方法。</p>\n<p>其次，二者都可用于比较两个对象。 <code>==</code>  运算符用于比较两个对象的引用是否相等，即<strong>比较的是两个对象的内存地址</strong>，与 <code>equals()</code>  方法一样。</p>\n<p>但是 <code>equals()</code>  通常被重写，例如 String、Integer、Date 等类对 <code>equals()</code>  方法进行了重写，所以在这些类中， <code>equals()</code> <strong> 比较的是两个对象的内容</strong>。</p>\n<p>如果两个对象通过 equals () 方法比较相等，那么它们的 hash 值也应该相等。但是，如果两个对象的 hash 值相等，并不意味着它们通过 equals () 方法比较也一定相等，这是<font color='red'>因为不同的对象可能会产生相同的 hash 值</font>。</p>\n<h3 id=\"25-set集合源码相关\"><a class=\"anchor\" href=\"#25-set集合源码相关\">#</a> 2.5 Set 集合源码相关</h3>\n<h4 id=\"1-hashset存放数据的方式拓软件\"><a class=\"anchor\" href=\"#1-hashset存放数据的方式拓软件\">#</a> 1. <mark>HashSet 存放数据的方式？</mark>（拓 * 软件）</h4>\n<p>HashSet 实际上是基于 HashMap 实现的，内部有一个 HashMap 类型的成员变量，用于存储元素。当向 HashSet 中添加一个元素时，实际上是将该元素添加到 <code>HashMap的键</code> 中，而该键对应的 <code>值则是一个固定的Object对象</code> 。</p>\n<blockquote>\n<p>由于 HashMap 中的键不能重复，所以当你向 HashSet 中添加重复元素时，实际上是向 HashMap 中添加重复键，这样就能<font color='red'>保证 HashSet 中不会有重复元素</font>。此外，由于 HashMap 允许键为 null，所以<font color='red'>HashSet 也允许有 null 值</font>。</p>\n</blockquote>\n<h4 id=\"2-set是如何实现元素的唯一性湖利软件\"><a class=\"anchor\" href=\"#2-set是如何实现元素的唯一性湖利软件\">#</a> 2. Set 是如何实现元素的唯一性？（湖 ** 利软件）</h4>\n<p><strong>Set 的元素存储在 Map 的键中</strong></p>\n<p>因为 Set 实际上是基于 Map 实现的，Set 的元素实际上存储在 Map 的键中，而<font color='red'>Map 的键是唯一的，不能重复的，因此 Set 的元素是唯一的</font>。</p>\n<p><strong>Map 如何实现键的唯一性？</strong></p>\n<p>Map 接口的不同实现类使用不同的数据结构和算法来<font color='red'>保证键的唯一性</font>。</p>\n<ul>\n<li>\n<p>HashMap：依赖于 <code>键的哈希值</code> 和 <code>equals()</code> 。通过哈希值来快速定位 key 所在的位置，再通过比较函数判断 key 是否相等。因此，<font color='orange'>在使用 Map 时，我们需要保证键对象的 hashCode () 和 equals () 方法都正确实现，才能保证 Map 中的 key 唯一性</font>。</p>\n<blockquote>\n<p>例如，HashMap 是基于 <code>哈希表</code> 实现的。当你向 HashMap 中添加一个键值对时，它会根据键的哈希码值来确定该键值对在哈希表中的存储位置。如果该位置已经有一个键值对，那么 HashMap 会调用 <code>equals()</code>  方法来检查新添加的键与已有的键是否相等。如果 <code>equals()</code>  方法返回 <code>true</code> ，则新添加的键与已有的<u>键重复</u>，新添加的键值对将<u>替换</u>已有的键值对。如果 <code>equals()</code>  方法返回 <code>false</code> ，则新添加的键与已有的<u>键不重复</u>，新添加的键值对将被<u>添加</u>到哈希表中。</p>\n</blockquote>\n</li>\n<li>\n<p>TreeMap：依赖于 <code>键的自然排序</code> 或者 <code>指定的比较器</code></p>\n<blockquote>\n<p>对于 TreeMap，它是基于 <code>红黑树</code> 实现的。当你向 TreeMap 中添加一个键值对时，它<font color='red'>会根据键的自然顺序或者指定的比较器来确定该键值对在红黑树中的位置</font>。<font color='red'>如果你尝试向 TreeMap 中添加<u>重复键</u>，那么新添加的键值对将<u>不会被添加</u>到红黑树中</font>。</p>\n</blockquote>\n</li>\n</ul>\n<p>总之，Map 接口的不同实现类通过使用不同的数据结构和算法来保证键的唯一性。</p>\n<h4 id=\"3-用哪两种方式来实现集合的排序凡科技\"><a class=\"anchor\" href=\"#3-用哪两种方式来实现集合的排序凡科技\">#</a> 3. 用哪两种方式来实现集合的排序（凡 * 科技）</h4>\n<pre><code>类似问题：\n&gt; 集合怎么排序？（北京中**信科技）\n</code></pre>\n<p>在 Java 中，可以使用以下两种方式来实现集合的排序：</p>\n<ol>\n<li><font color='cornflowerblue'>自然排序</font>：<font color='red'>集合元素实现了 <code> Comparable 接口</code> ，通过重写 <code> compareTo() 方法</code> 来定义元素之间的排序关系</font>。Java 中的一些内置类型（如 Integer、String 等）已经实现了 Comparable 接口，可以直接使用自然排序。例如，可以使用 Collections.sort () 方法对实现了 Comparable 接口的 List 进行排序。</li>\n<li><font color='cornflowerblue'>定制排序</font>：使用一个比较器（Comparator）对象来定义元素之间的排序关系。<font color='red'>需要创建一个实现了 <code> Comparator 接口</code> 的比较器对象，并实现了 <code> compare() 方法</code> 来定义元素之间的排序关系</font>。通过<font color='red'>在集合类的构造器的排序方法参数中传入比较器对象</font>，可以实现自定义排序。例如，可以使用 Collections.sort () 方法对实现了 Comparator 接口的 List 进行排序。</li>\n</ol>\n",
            "tags": [
                "Java",
                "Java基础",
                "Java基础-真题"
            ]
        },
        {
            "id": "http://example.com/java/java-se/java-excise/%E7%AC%AC13%E7%AB%A0%EF%BC%9A%E9%9A%8F%E5%A0%82%E5%A4%8D%E4%B9%A0%E4%B8%8E%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%A2%98%EF%BC%88%E6%B3%9B%E5%9E%8B%EF%BC%89/",
            "url": "http://example.com/java/java-se/java-excise/%E7%AC%AC13%E7%AB%A0%EF%BC%9A%E9%9A%8F%E5%A0%82%E5%A4%8D%E4%B9%A0%E4%B8%8E%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%A2%98%EF%BC%88%E6%B3%9B%E5%9E%8B%EF%BC%89/",
            "title": "宋红康_第13章：泛型",
            "date_published": "2023-11-12T03:06:50.167Z",
            "content_html": "<h1 id=\"第13章随堂复习与企业真题泛型\"><a class=\"anchor\" href=\"#第13章随堂复习与企业真题泛型\">#</a> 第 13 章：随堂复习与企业真题（泛型）</h1>\n<hr />\n<h2 id=\"一-随堂复习\"><a class=\"anchor\" href=\"#一-随堂复习\">#</a> 一、随堂复习</h2>\n<h3 id=\"1-泛型的理解\"><a class=\"anchor\" href=\"#1-泛型的理解\">#</a> 1. 泛型的理解</h3>\n<ul>\n<li><E> ，泛型参数，使用引用数据类型来赋值。</li>\n</ul>\n<h3 id=\"2-泛型在集合-比较器中的使用重点\"><a class=\"anchor\" href=\"#2-泛型在集合-比较器中的使用重点\">#</a> 2. <mark>泛型在集合、比较器中的使用（重点）</mark></h3>\n<ul>\n<li>集合：ArrayList、HashMap、Iterator</li>\n<li>比较器：Comparable、Comparator</li>\n</ul>\n<h3 id=\"3-自定义泛型类泛型接口-泛型方法熟悉\"><a class=\"anchor\" href=\"#3-自定义泛型类泛型接口-泛型方法熟悉\">#</a> 3. 自定义泛型类 / 泛型接口、泛型方法（熟悉）</h3>\n<ul>\n<li>class Order<T></li>\n<li>public <E> 返回值类型 方法名 (形参列表){}</li>\n<li>具体的细节，见 IDEA 中的笔记。</li>\n</ul>\n<h3 id=\"4-泛型在继承上的体现\"><a class=\"anchor\" href=\"#4-泛型在继承上的体现\">#</a> 4. 泛型在继承上的体现</h3>\n<pre><code>1. 类SuperA是类A的父类，则G&lt;SuperA&gt; 与 G&lt;A&gt;的关系：G&lt;SuperA&gt; 和 G&lt;A&gt;是并列的两个类，没有任何子父类的关系。\n\n比如：ArrayList&lt;Object&gt; 、ArrayList&lt;String&gt;没有关系\n\n2. 类SuperA是类A的父类或接口，SuperA&lt;G&gt; 与 A&lt;G&gt;的关系：SuperA&lt;G&gt; 与A&lt;G&gt; 有继承或实现的关系。\n即A&lt;G&gt;的实例可以赋值给SuperA&lt;G&gt;类型的引用（或变量）\n\n比如：List&lt;String&gt; 与 ArrayList&lt;String&gt;\n</code></pre>\n<h3 id=\"5-通配符的使用\"><a class=\"anchor\" href=\"#5-通配符的使用\">#</a> 5. <mark>通配符的使用</mark></h3>\n<ul>\n<li>? 的使用 （重点）\n<ul>\n<li>以集合为例：可以读取数据、不能写入数据（例外：null）</li>\n</ul>\n</li>\n<li>? extends A\n<ul>\n<li>以集合为例：可以读取数据、不能写入数据（例外：null）</li>\n</ul>\n</li>\n<li>? super A\n<ul>\n<li>以集合为例：可以读取数据、可以写入 A 类型或 A 类型子类的数据（例外：null）</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"二-企业真题\"><a class=\"anchor\" href=\"#二-企业真题\">#</a> 二、企业真题</h2>\n<h4 id=\"1-java-的泛型是什么有什么好处和优点jdk-不同版本的泛型有什么区别软动力\"><a class=\"anchor\" href=\"#1-java-的泛型是什么有什么好处和优点jdk-不同版本的泛型有什么区别软动力\">#</a> 1. <mark>Java 的泛型是什么？有什么好处和优点？JDK 不同版本的泛型有什么区别？</mark>（软 * 动力）</h4>\n<p>答：</p>\n<p>泛型的核心思想：把集合中的内容限制为一个特定的数据类型（虽然暂时未知）</p>\n<p>泛型的概念：Java 的泛型是  <code>JDK 1.5</code>  的新特性，泛型的本质是参数化类型，即 <code>不确定的类型</code> ，也就是说所操作的数据类型被指定为一个参数。这种参数类型可以用在类、接口和方法的创建中，分别称为 <code>泛型类</code> 、 <code>泛型接口</code> 、 <code>泛型方法</code> 。</p>\n<p>泛型的优点：包括 <code>提高类型安全</code> 和 <code>消除强制类型转换</code> 。</p>\n<ul>\n<li>泛型的主要目标是提高 Java 程序的类型安全。通过知道使用泛型定义的变量的类型限制，编译器可以在一个高得多的程度上验证类型假设。没有泛型，这些假设就只存在于程序员的头脑中（或者如果幸运的话，还存在于代码注释中）</li>\n<li>泛型的一个附带好处是，消除源代码中的许多强制类型转换。这使得代码更加可读，并且减少了出错机会。</li>\n</ul>\n<p>JDK 不同版本之间泛型的区别：</p>\n<ul>\n<li>jdk7.0 新特性：</li>\n</ul>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token class-name\">ArrayList</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">></span></span> list <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayList</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 类型推断</span></pre></td></tr></table></figure><ul>\n<li>后续版本的新特性：</li>\n</ul>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token class-name\">Comparator</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Employee</span><span class=\"token punctuation\">></span></span> comparator <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Comparator</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span> <span class=\"token comment\">// 类型推断</span></pre></td></tr></table></figure><h4 id=\"2-说说你对泛型的了解软国际\"><a class=\"anchor\" href=\"#2-说说你对泛型的了解软国际\">#</a> 2. 说说你对泛型的了解（* 软国际）</h4>\n<p>泛型是  <code>JDK 1.5</code>  的新特性，它允许在定义类、接口和方法时使用类型参数。类型参数提供了一种方法来 <code>重用相同的代码，处理不同类型的对象</code> 。泛型的主要优点是 <code>提高类型安全</code> 和 <code>消除强制类型转换</code> 。</p>\n<p>例如，在没有泛型之前，如果您想编写一个可以接受任何类型对象的列表，您可能会定义一个 List 类，其中元素被存储为 Object 类型。当您从列表中检索元素时，您必须将其强制转换为正确的类型。这不仅容易出错，而且还会使代码难以阅读。</p>\n<p>使用泛型创建 <code>泛型类</code> ，您可以定义一个 List 类，其中元素的类型由类型参数指定。这样，当您从列表中检索元素时，就不需要进行强制类型转换。编译器会自动检查类型，并在必要时插入强制类型转换。</p>\n<p>泛型还可以用于创建 <code>泛型方法</code> 和 <code>泛型接口</code> 。它们提供了一种灵活的方法来重用代码，并且可以与不同类型的对象一起使用。</p>\n",
            "tags": [
                "Java",
                "Java基础",
                "Java基础-真题"
            ]
        },
        {
            "id": "http://example.com/java/java-se/java-excise/%E7%AC%AC12%E7%AB%A0%EF%BC%9A%E9%9A%8F%E5%A0%82%E5%A4%8D%E4%B9%A0%E4%B8%8E%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%A2%98%EF%BC%88%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%EF%BC%89/",
            "url": "http://example.com/java/java-se/java-excise/%E7%AC%AC12%E7%AB%A0%EF%BC%9A%E9%9A%8F%E5%A0%82%E5%A4%8D%E4%B9%A0%E4%B8%8E%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%A2%98%EF%BC%88%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%EF%BC%89/",
            "title": "宋红康_第12章：集合框架",
            "date_published": "2023-11-12T03:06:50.157Z",
            "content_html": "<h1 id=\"第12章随堂复习与企业真题集合框架\"><a class=\"anchor\" href=\"#第12章随堂复习与企业真题集合框架\">#</a> 第 12 章：随堂复习与企业真题（集合框架）</h1>\n<hr />\n<h2 id=\"一-随堂复习\"><a class=\"anchor\" href=\"#一-随堂复习\">#</a> 一、随堂复习</h2>\n<h3 id=\"1-数组存储数据方面的特点和弊端\"><a class=\"anchor\" href=\"#1-数组存储数据方面的特点和弊端\">#</a> 1. 数组存储数据方面的特点和弊端</h3>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\"></th>\n<th style=\"text-align:center\">数组</th>\n<th style=\"text-align:center\">集合</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">长度</td>\n<td style=\"text-align:center\">长度固定</td>\n<td style=\"text-align:center\">动态长度</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">可存储的元素类型</td>\n<td style=\"text-align:center\">基本数据类型、引用数据类型</td>\n<td style=\"text-align:center\">引用数据类型 / 映射</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">元素类型要求</td>\n<td style=\"text-align:center\">元素的类型必须相同</td>\n<td style=\"text-align:center\">元素的类型可以不同</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">是否连续存储</td>\n<td style=\"text-align:center\">连续存储</td>\n<td style=\"text-align:center\">非连续存储</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">元素特点</td>\n<td style=\"text-align:center\">有序、可重复</td>\n<td style=\"text-align:center\">List：有序、可重复；Set：无序、不可重复；Map：无序、不可重复；</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">查找速度</td>\n<td style=\"text-align:center\">快（通过索引值，复杂度为 O (1)）</td>\n<td style=\"text-align:center\">慢（复杂度为 O (n)）</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">增、删、插速度</td>\n<td style=\"text-align:center\">慢</td>\n<td style=\"text-align:center\">快</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">举例</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">List、Set、Map</td>\n</tr>\n</tbody>\n</table>\n<pre><code>   数组存储多个数据方面的特点：\n   &gt; 数组一旦初始化，其长度就是确定的。\n   &gt; 数组中的多个元素是依次紧密排列的，有序的，可重复的\n   &gt; (优点) 数组一旦初始化完成，其元素的类型就是确定的。不是此类型的元素，就不能添加到此数组中。\n      int[] arr = new int[10];\n      arr[0] = 1;\n      arr[1] = &quot;AA&quot;;//编译报错\n\n      Object[] arr1 = new Object[10];\n      arr1[0] = new String();\n      arr1[1] = new Date();\n   &gt; (优点)元素的类型既可以是基本数据类型，也可以是引用数据类型。\n\n   数组存储多个数据方面的弊端：\n   &gt; 数组一旦初始化，其长度就不可变了。\n   &gt; 数组中存储数据特点的单一性。对于无序的、不可重复的场景的多个数据就无能为力了。\n   &gt; 数组中可用的方法、属性都极少。具体的需求，都需要自己来组织相关的代码逻辑。\n   &gt; 针对于数组中元素的删除、插入操作，性能较差。\n</code></pre>\n<h3 id=\"2-集合框架概述\"><a class=\"anchor\" href=\"#2-集合框架概述\">#</a> 2. 集合框架概述</h3>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231112105809219.png\" alt=\"集合框架概述\" /></p>\n<pre><code>java.util.Collection:存储一个一个的数据\n    |-----子接口：List:存储有序的、可重复的数据 (&quot;动态&quot;数组)\n           |---- ArrayList(主要实现类)、LinkedList、Vector\n\n    |-----子接口：Set:存储无序的、不可重复的数据(高中学习的集合)\n           |---- HashSet(主要实现类)、LinkedHashSet、TreeSet\n\n\njava.util.Map:存储一对一对的数据(key-value键值对，(x1,y1)、(x2,y2) --&gt; y=f(x),类似于高中的函数)\n    |---- HashMap(主要实现类)、LinkedHashMap、TreeMap、Hashtable、Properties\n</code></pre>\n<pre><code>学习的程度把握：\n层次1：针对于具体特点的多个数据，知道选择相应的适合的接口的主要实现类，会实例化，会调用常用的方法。\n层次2：区分接口中不同的实现类的区别。\n*****************\n层次3：① 针对于常用的实现类，需要熟悉底层的源码 ② 熟悉常见的数据结构 （第14章讲）\n</code></pre>\n<h3 id=\"3-collection的常用方法\"><a class=\"anchor\" href=\"#3-collection的常用方法\">#</a> 3. Collection 的常用方法</h3>\n<h4 id=\"31-常用方法\"><a class=\"anchor\" href=\"#31-常用方法\">#</a> 3.1 常用方法</h4>\n<pre><code>add(Object obj)\naddAll(Collection coll)\nclear()\nisEmpty()\nsize()\ncontains(Object obj)\ncontainsAll(Collection coll)\nretainAll(Collection coll)\nremove(Object obj)\nremoveAll(Collection coll)\nhashCode()\nequals()\ntoArray()\n**************\niterator() ---&gt; 引出了迭代器接口\n</code></pre>\n<pre><code>向Collection中添加元素的要求：\n&gt; 要求元素所属的类一定要重写equals()!\n</code></pre>\n<pre><code>集合与数组的相互转换：\n集合 ---&gt; 数组：toArray()\n数组 ---&gt; 集合：调用Arrays的静态方法asList(Object ... objs)，返回一个List\n</code></pre>\n<h4 id=\"32-迭代器接口\"><a class=\"anchor\" href=\"#32-迭代器接口\">#</a> 3.2 迭代器接口</h4>\n<ul>\n<li>设计模式的一种</li>\n<li>迭代器不负责数据的存储；负责对集合类的遍历</li>\n</ul>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token number\">1.</span> 如何获取迭代器<span class=\"token punctuation\">(</span><span class=\"token class-name\">Iterator</span><span class=\"token punctuation\">)</span>对象？</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token class-name\">Iterator</span> iterator <span class=\"token operator\">=</span> coll<span class=\"token punctuation\">.</span><span class=\"token function\">iterator</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token number\">2.</span> 如何实现遍历<span class=\"token punctuation\">(</span>代码实现<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>iterator<span class=\"token punctuation\">.</span><span class=\"token function\">hasNext</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>iterator<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//next ():①指针下移 ② 将下移以后集合位置上的元素返回</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h3 id=\"4-collection的子接口list\"><a class=\"anchor\" href=\"#4-collection的子接口list\">#</a> 4. Collection 的子接口：List</h3>\n<img data-src=\"https://gitee.com/jayhee/picture-bed/raw/master/img/image-20220407203244029.png\" alt=\"image-20220407203244029\" style=\"zoom: 67%;\" />\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">List 接口的实现类</th>\n<th style=\"text-align:center\"><em>ArrayList</em></th>\n<th style=\"text-align:center\">LinkedList</th>\n<th style=\"text-align:center\"><s>Vector</s></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">地位</td>\n<td style=\"text-align:center\">主要实现类</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">古老实现类</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">底层实现</td>\n<td style=\"text-align:center\">Object 数组，但可以扩容</td>\n<td style=\"text-align:center\"><font color='red'>双向链表</font></td>\n<td style=\"text-align:center\">Object 数组</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">特点</td>\n<td style=\"text-align:center\">线程不安全、效率高</td>\n<td style=\"text-align:center\">线程不安全</td>\n<td style=\"text-align:center\"><font color='red'>线程安全</font>、效率低</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">使用场景</td>\n<td style=\"text-align:center\"><font color='red'>频繁追加、查找数据</font></td>\n<td style=\"text-align:center\"><font color='red'>频繁插入、删除数据</font></td>\n<td style=\"text-align:center\">避免使用</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">说明</td>\n<td style=\"text-align:center\">对于频繁访问列表中的某一个元素，只需要在列表末尾进行添加和删除元素操作的情况下</td>\n<td style=\"text-align:center\">元素是通过指针相互连接的，在插入 / 删除元素时，只需要改动前后元素的指针即可</td>\n<td style=\"text-align:center\"></td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>常用方法</li>\n</ul>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>小结：</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    增</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>        <span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Object</span> obj<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>        <span class=\"token function\">addAll</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Collection</span> coll<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    删</pre></td></tr><tr><td data-num=\"6\"></td><td><pre>        <span class=\"token function\">remove</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Object</span> obj<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>        <span class=\"token function\">remove</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> index<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    改</pre></td></tr><tr><td data-num=\"9\"></td><td><pre>        <span class=\"token function\">set</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> index<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Object</span> ele<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    查</pre></td></tr><tr><td data-num=\"11\"></td><td><pre>        <span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> index<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    插</pre></td></tr><tr><td data-num=\"13\"></td><td><pre>        <span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> index<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Object</span> ele<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>        <span class=\"token function\">addAll</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> index<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Collection</span> eles<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    长度</pre></td></tr><tr><td data-num=\"16\"></td><td><pre>        <span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>    遍历</pre></td></tr><tr><td data-num=\"18\"></td><td><pre>        <span class=\"token function\">iterator</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> ：使用迭代器进行遍历</pre></td></tr><tr><td data-num=\"19\"></td><td><pre>        增强<span class=\"token keyword\">for</span>循环</pre></td></tr><tr><td data-num=\"20\"></td><td><pre>        一般的<span class=\"token keyword\">for</span>循环</pre></td></tr></table></figure><pre><code>List及其实现类特点\njava.util.Collection:存储一个一个的数据\n    |-----子接口：List:存储有序的、可重复的数据 (&quot;动态&quot;数组)\n           |---- ArrayList:List的主要实现类；线程不安全的、效率高；底层使用Object[]数组存储\n                           在添加数据、查找数据时，效率较高；在插入、删除数据时，效率较低\n           |---- LinkedList:底层使用双向链表的方式进行存储；在对集合中的数据进行频繁的删除、插入操作时，建议\t\t\t\t\t\t\t使用此类在插入、删除数据时，效率较高；在添加数据、查找数据时，效率较低；\n           |---- Vector:List的古老实现类；线程安全的、效率低；底层使用Object[]数组存储\n\n[面试题] ArrayList、Vector的区别？  ArrayList、LinkedList的区别？\n</code></pre>\n<h3 id=\"5-collection的子接口set\"><a class=\"anchor\" href=\"#5-collection的子接口set\">#</a> 5. Collection 的子接口：Set</h3>\n<img data-src=\"https://gitee.com/jayhee/picture-bed/raw/master/img/image-20220407203244029.png\" alt=\"image-20220407203244029\" style=\"zoom: 67%;\" />\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">Set 接口的实现类</th>\n<th style=\"text-align:center\"><em>HashSet</em></th>\n<th style=\"text-align:center\">LinkedHashSet</th>\n<th style=\"text-align:center\">TreeSet</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">地位</td>\n<td style=\"text-align:center\">主要实现类</td>\n<td style=\"text-align:center\">HashSet 的子类</td>\n<td style=\"text-align:center\">了解即可</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">底层实现（存储在 key 中）</td>\n<td style=\"text-align:center\">HashMap</td>\n<td style=\"text-align:center\">LinkedHashMap</td>\n<td style=\"text-align:center\">TreeMap</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">数据结构</td>\n<td style=\"text-align:center\">数组 + 单向链表 + 红黑树</td>\n<td style=\"text-align:center\">数组 + 单向链表 + 红黑树 + <font color='red'>双向链表</font></td>\n<td style=\"text-align:center\">红黑树</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">对添加的元素的要求</td>\n<td style=\"text-align:center\">所在类要<font color='orange'>重写 <code>equals()</code>  和 <code>hashCode()</code> </font>，同时要求二者保持一致性</td>\n<td style=\"text-align:center\">与 HashSet 相同</td>\n<td style=\"text-align:center\"><font color='red'><strong>属于同一个类</strong></font>，且要求<font color='orange'>该类实现 <code>Comparable接口</code> 并重写 <code>compareTo(Object obj)</code> ，或者定义一个 <code>Comparator接口</code> 的实现类实例，并重写 <code>compare(Object o1,Object o2)</code> ，将实例作为参数传递给 TreeSet 的构造器</font></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">遍历顺序</td>\n<td style=\"text-align:center\">与添加顺序不同</td>\n<td style=\"text-align:center\">与添加顺序相同（得益于双向链表）</td>\n<td style=\"text-align:center\"><font color='red'>按照指定属性的大小顺序</font></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">判断两个元素相等的标准</td>\n<td style=\"text-align:center\"><font color='red'> <code>hashCode()</code>  返回的哈希值相等，且 <code>equals()</code>  返回 true</font></td>\n<td style=\"text-align:center\">与 HashSet 相同</td>\n<td style=\"text-align:center\">两个对象通过 <font color='red'> <code>compareTo(Object obj) 或compare(Object o1,Object o2)</code>  方法的返回值为 0</font></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">特点</td>\n<td style=\"text-align:center\"><font color='red'>线程不安全</font>，元素可以是 null</td>\n<td style=\"text-align:center\"><font color='red'> <code>插入性能略低</code> 于 HashSet，但在 <code>迭代访问</code>  Set 里的全部元素时有很好的性能</font></td>\n<td style=\"text-align:center\">可以实现<font color='red'>自然排序、定制排序</font></td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>Set 中的常用的方法都是 Collection 中声明的方法，<font color='red'>没有新增的方法</font></li>\n<li>常见的实现类的对比</li>\n</ul>\n<pre><code>java.util.Collection:存储一个一个的数据\n    |-----子接口：Set:存储无序的、不可重复的数据(高中学习的集合)\n           |---- HashSet：主要实现类；底层使用的是HashMap，即使用数组+单向链表+红黑树结构进行存储。（jdk8中）\n                |---- LinkedHashSet：是HashSet的子类；在现有的数组+单向链表+红黑树结构的基础上，又添加了\n                                     一组双向链表，用于记录添加元素的先后顺序。即：我们可以按照添加元素的顺\t\t\t\t\t\t\t\t\t序实现遍历。便于频繁的查询操作。\n           |---- TreeSet：底层使用红黑树存储。可以按照添加的元素的指定的属性的大小顺序进行遍历。\n</code></pre>\n<ul>\n<li>难点： Set 中无序性、不可重复性的理解（以 HashSet 及其子类为例说明）</li>\n</ul>\n<pre><code>&gt;无序性： != 随机性。\n         添加元素的顺序和遍历元素的顺序不一致,是不是就是无序性呢？ No!\n         到底什么是无序性？与添加的元素的位置有关，不像ArrayList一样是依次紧密排列的。\n         这里是根据添加的元素的哈希值，计算的其在数组中的存储位置。此位置不是依次排列的，表现为无序性。\n\n&gt;不可重复性：添加到Set中的元素是不能相同的。\n          比较的标准，需要判断hashCode()得到的哈希值以及equals()得到的boolean型的结果。\n          哈希值相同且equals()返回true，则认为元素是相同的。\n</code></pre>\n<pre><code>添加到HashSet/LinkedHashSet中元素的要求:\n&gt;要求元素所在的类要重写两个方法：equals() 和 hashCode()。\n&gt;同时，要求equals() 和 hashCode()要保持一致性！我们只需要在IDEA中自动生成两个方法的重写即可，即能保证两个方法的一致性。\n</code></pre>\n<ul>\n<li>了解 TreeSet 的使用</li>\n</ul>\n<h3 id=\"6-map接口\"><a class=\"anchor\" href=\"#6-map接口\">#</a> 6. Map 接口</h3>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230402211251010.png\" alt=\"image-20230402211251010\" /></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">Map 接口的实现类</th>\n<th style=\"text-align:center\"><em>HashMap</em></th>\n<th style=\"text-align:center\">LinkedHashMap</th>\n<th style=\"text-align:center\">TreeMap</th>\n<th style=\"text-align:center\"><s>Hashtable</s></th>\n<th style=\"text-align:center\">Properties</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">地位</td>\n<td style=\"text-align:center\">主要实现类</td>\n<td style=\"text-align:center\">HashMap 的子类</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">古老实现类</td>\n<td style=\"text-align:center\"><s>Hashtable</s> 的子类</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">底层实现</td>\n<td style=\"text-align:center\">哈希表</td>\n<td style=\"text-align:center\">哈希表 + <font color='red'>双向链表</font></td>\n<td style=\"text-align:center\">红黑树</td>\n<td style=\"text-align:center\">哈希表</td>\n<td style=\"text-align:center\">哈希表</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">数据结构</td>\n<td style=\"text-align:center\">一维数组 + 单向链表（+ 红黑树）</td>\n<td style=\"text-align:center\">一维数组 + 单向链表（+ 红黑树） + <font color='red'>双向链表</font></td>\n<td style=\"text-align:center\">红黑树</td>\n<td style=\"text-align:center\">一维数组 + 单向链表</td>\n<td style=\"text-align:center\">一维数组 + 单向链表</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">键、值是否允许为 null</td>\n<td style=\"text-align:center\">是</td>\n<td style=\"text-align:center\">是</td>\n<td style=\"text-align:center\"><font color='red'>键不能为 null</font>，值可以为 null</td>\n<td style=\"text-align:center\">键和值都不能为 null</td>\n<td style=\"text-align:center\">键和值都不能为 null</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">是否线程安全</td>\n<td style=\"text-align:center\">否</td>\n<td style=\"text-align:center\">否</td>\n<td style=\"text-align:center\">否</td>\n<td style=\"text-align:center\"><font color='red'>是，因此效率低</font></td>\n<td style=\"text-align:center\"><font color='red'>是，因此效率低</font></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">特点</td>\n<td style=\"text-align:center\">查找、插入、删除速度快，但不保证元素的顺序</td>\n<td style=\"text-align:center\">保证元素的<font color='red'>插入 / 访问顺序</font></td>\n<td style=\"text-align:center\"><font color='red'>可以按照<strong> key 中的指定属性</strong>的大小顺序进行遍历</font>：①自然排序；②定制排序</td>\n<td style=\"text-align:center\"><font color='red'>线程安全</font>，效率低</td>\n<td style=\"text-align:center\"><font color='red'>键和值都是 String 类型</font></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">性能</td>\n<td style=\"text-align:center\">①<font color='red'>查找、插入、删除速度快</font>；②迭代遍历速度慢（因为和容量有关，需要遍历底层数组，以及每个数组元素对应的链表 / 红黑树，数组的长度就是 HashMap 的容量）</td>\n<td style=\"text-align:center\">①<font color='red'>插入、删除速度慢</font>；②迭代遍历比 HashMap 快（因为只和实际数据有关，和容量无关）</td>\n<td style=\"text-align:center\">查找、插入、删除速度慢（<font color='red'>因为要维护红黑树的平衡、顺序</font>）</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">内存</td>\n<td style=\"text-align:center\">占用大，保存数组</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">占用小，保存节点</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">使用场景</td>\n<td style=\"text-align:center\">快速的查找和插入，不要求元素的顺序</td>\n<td style=\"text-align:center\">需要保持元素的插入顺序或者访问顺序</td>\n<td style=\"text-align:center\">适用于需要<font color='red'>有序</font>的键值对集合</td>\n<td style=\"text-align:center\">适用于需要线程安全的场景</td>\n<td style=\"text-align:center\">以键值对的方式存储<font color='red'>配置信息</font></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">补充说明</td>\n<td style=\"text-align:center\"><font color='red'>在 JDK8 引入红黑树</font></td>\n<td style=\"text-align:center\">双向链表: <font color='red'>记录元素的添加顺序</font></td>\n<td style=\"text-align:center\"><font color='red'>①自然排序</font>（key 所在类实现了 Comparable 接口）；<font color='red'>②定制排序</font>（在创建 TreeMap 时传入 Comparator 对象）；</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">要求 key</td>\n<td style=\"text-align:center\"><font color='red'>key 所在类要重写 <code>hashCode()</code>  和 <code>equals()</code> </font></td>\n<td style=\"text-align:center\">与 HashMap 相同</td>\n<td style=\"text-align:center\"><font color='red'>key 必须是同一个类的对象</font></td>\n<td style=\"text-align:center\">与 HashMap 相同</td>\n<td style=\"text-align:center\">key 是 String 类</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">要求 value</td>\n<td style=\"text-align:center\"><font color='red'>value 所在类要重写 <code>equals()</code> </font></td>\n<td style=\"text-align:center\">与 HashMap 相同</td>\n<td style=\"text-align:center\">无</td>\n<td style=\"text-align:center\">与 HashMap 相同</td>\n<td style=\"text-align:center\">value 是 String 类</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>常用的方法</li>\n</ul>\n<pre><code>增：\n    put(Object key,Object value)\n    putAll(Map m)\n删：\n    Object remove(Object key)\n改：\n    put(Object key,Object value)\n    putAll(Map m)\n查：\n    Object get(Object key)\n长度：\n    size()\n遍历：\n   遍历key集：Set keySet()\n   遍历value集：Collection values()\n   遍历entry集：Set entrySet()\n</code></pre>\n<ul>\n<li>常用的实现类</li>\n</ul>\n<pre><code>java.util.Map:存储一对一对的数据(key-value键值对，(x1,y1)、(x2,y2) --&gt; y=f(x),类似于高中的函数)\n    |---- HashMap:主要实现类;线程不安全的，效率高;可以添加null的key和value值;底层使用数组+单向链表+红黑树结构存储（jdk8）\n        |---- LinkedHashMap:是HashMap的子类；在HashMap使用的数据结构的基础上，增加了一对双向链表，用于记录添加的元素的先后顺序，进而我们在遍历元素时，就可以按照添加的顺序显示。开发中，对于频繁的遍历操作，建议使用此类。\n    |---- TreeMap:底层使用红黑树存储;可以按照添加的key-value中的key元素的指定的属性的大小顺序进行遍历。需要考虑使用①自然排序 ②定制排序。\n    |---- Hashtable:古老实现类;线程安全的，效率低;不可以添加null的key或value值;底层使用数组+单向链表结构存储（jdk8）\n        |---- Properties:其key和value都是String类型。常用来处理属性文件。\n\n\n[面试题] 区别HashMap和Hashtable、区别HashMap和LinkedHashMap、HashMap的底层实现（① new HashMap() ② put(key,value)）\n</code></pre>\n<pre><code>HashMap中元素的特点:\n&gt; HashMap中的所有的key彼此之间是不可重复的、无序的。所有的key就构成一个Set集合。---&gt;key所在的类要重写hashCode()和equals()\n&gt; HashMap中的所有的value彼此之间是可重复的、无序的。所有的value就构成一个Collection集合。---&gt;value所在的类要重写equals()\n&gt; HashMap中的一个key-value,就构成了一个entry。\n&gt; HashMap中的所有的entry彼此之间是不可重复的、无序的。所有的entry就构成了一个Set集合。\n</code></pre>\n<ul>\n<li>\n<p>（了解）TreeMap 的使用</p>\n</li>\n<li>\n<p>（重要）Properties 的使用</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">PropertiesTest</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token annotation punctuation\">@Test</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">IOException</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token comment\">// 注意：因为设计到流的操作，为了确保流能关闭，建议使用 try-catch-finally</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>        <span class=\"token comment\">// 方式 1：数据和代码耦合度高；如果修改的话，需要重写的编译代码、打包发布，繁琐</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>        <span class=\"token comment\">// 数据</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token comment\">//        String name = \"Tom\";</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token comment\">//        String password = \"abc123\";</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>        <span class=\"token comment\">// 代码：用于操作 name,password</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>        <span class=\"token comment\">//...</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>        <span class=\"token comment\">// 方式 2：将数据封装到具体的配置文件中，在程序中读取配置文件中的信息。实现了</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>        <span class=\"token comment\">// 数据和代码的解耦；由于我们没有修改代码，就省去了重新编译和打包的过程。</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>        <span class=\"token class-name\">File</span> file <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">File</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"info.properties\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 注意，要提前创建好</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre><span class=\"token comment\">//        System.out.println(file.getAbsolutePath());</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>        <span class=\"token class-name\">FileInputStream</span> fis <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">FileInputStream</span><span class=\"token punctuation\">(</span>file<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>        <span class=\"token class-name\">Properties</span> pros <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Properties</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>        pros<span class=\"token punctuation\">.</span><span class=\"token function\">load</span><span class=\"token punctuation\">(</span>fis<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 加载流中的文件中的数据</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>        <span class=\"token comment\">// 读取数据</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>        <span class=\"token class-name\">String</span> name <span class=\"token operator\">=</span> pros<span class=\"token punctuation\">.</span><span class=\"token function\">getProperty</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"name\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>        <span class=\"token class-name\">String</span> pwd <span class=\"token operator\">=</span> pros<span class=\"token punctuation\">.</span><span class=\"token function\">getProperty</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"password\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>name <span class=\"token operator\">+</span> <span class=\"token string\">\":\"</span> <span class=\"token operator\">+</span> pwd<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>        fis<span class=\"token punctuation\">.</span><span class=\"token function\">close</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre></pre></td></tr><tr><td data-num=\"30\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"7-collections工具类的使用\"><a class=\"anchor\" href=\"#7-collections工具类的使用\">#</a> 7. Collections 工具类的使用</h3>\n<pre><code>区分Collection 和 Collections\nCollection：集合框架中的用于存储一个一个元素的接口，又分为List和Set等子接口。\nCollections：用于操作集合框架的一个工具类。此时的集合框架包括：Set、List、Map\n</code></pre>\n<ul>\n<li>熟悉常用的 Collections 中的方法即可。</li>\n</ul>\n<h2 id=\"二-企业真题\"><a class=\"anchor\" href=\"#二-企业真题\">#</a> 二、企业真题</h2>\n<h3 id=\"21-集合概述\"><a class=\"anchor\" href=\"#21-集合概述\">#</a> 2.1 集合概述</h3>\n<h4 id=\"1-listsetmap是否继承自collection接口北京中译咨询-思贸易\"><a class=\"anchor\" href=\"#1-listsetmap是否继承自collection接口北京中译咨询-思贸易\">#</a> 1. List，Set，Map 是否继承自 collection 接口？（北京中 * 译咨询、思 * 贸易）</h4>\n<p>Map 不是。</p>\n<h4 id=\"2-说说listsetmap的区别民银行\"><a class=\"anchor\" href=\"#2-说说listsetmap的区别民银行\">#</a> 2. 说说 List,Set,Map 的区别 (民 * 银行)</h4>\n<pre><code>类似问题：\n&gt; Map与Set、List的区别（纬*）\n</code></pre>\n<p>List、Set 是存储<font color='red'>单列数据</font>集合，都继承与 Collection 接口。Map 是存储<font color='red'>键值对</font>这样的<font color='red'>双列数据</font>的集合，是个独立接口。</p>\n<p>List 中存储的数据是有序的，可以是重复的。</p>\n<p>Set 中存储的数据是无序的，且不允许重复。</p>\n<p>Map 中存储的数据是无序的，他的键是不允许重复的，值是可以重复的。</p>\n<h4 id=\"3-写出list-map-set接口的实现类并说出其特点华为\"><a class=\"anchor\" href=\"#3-写出list-map-set接口的实现类并说出其特点华为\">#</a> 3. <mark>写出 list、map、set 接口的实现类，并说出其特点</mark>（华 ** 为）</h4>\n<pre><code>类似问题：\n&gt; 集合有哪些， 各自有哪些特点， 各自的API有哪些？（湖**利软件）\n&gt; List Map Set三个接口在存储元素时个有什么特点（*软）\n</code></pre>\n<ul>\n<li>List 接口的实现类\n<ul>\n<li>ArrayList\n<ul>\n<li>动态数组，可扩容的 Object 数组</li>\n<li>支持随机访问元素，适用于频繁访问元素的场景</li>\n<li>插入和删除操作效率较低</li>\n</ul>\n</li>\n<li>LinkedList\n<ul>\n<li>双向链表</li>\n<li>随机访问元素效率较低</li>\n<li>支持快速的插入和删除操作，适用于频繁插入和删除元素的场景</li>\n</ul>\n</li>\n<li><s>Vector</s>\n<ul>\n<li>与 ArrayList 类似，底层也是可扩容的 Object 数组</li>\n<li>线程安全，支持同步访问，也因此效率低，不适用于高并发场景</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Set 接口的实现类\n<ul>\n<li>HashSet\n<ul>\n<li>哈希表</li>\n<li>不保证元素的顺序</li>\n</ul>\n</li>\n<li>LinkedHashSet\n<ul>\n<li>哈希表 + 双向链表</li>\n<li>保证元素有序</li>\n</ul>\n</li>\n<li>TreeSet\n<ul>\n<li>红黑树</li>\n<li>要求元素属于同一个类</li>\n<li>可以按照指定属性的大小顺序进行遍历</li>\n<li>可以实现自然排序 / 定制排序</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Map 接口的实现类\n<ul>\n<li>HashMap\n<ul>\n<li>哈希表</li>\n<li>快速的查找和插入，不保证元素的顺序</li>\n</ul>\n</li>\n<li>LinkedHashMap\n<ul>\n<li>哈希表 + 双向链表</li>\n<li>保证元素有序</li>\n</ul>\n</li>\n<li>TreeMap\n<ul>\n<li>红黑树</li>\n<li>要求 key 都属于同一个类</li>\n<li>可以按照<strong> key 中的指定属性</strong>的大小顺序进行遍历</li>\n<li>适用于需要<font color='red'>有序</font>的键值对集合</li>\n</ul>\n</li>\n<li>Hashtable\n<ul>\n<li>哈希表</li>\n<li>线程安全</li>\n</ul>\n</li>\n<li>Properties\n<ul>\n<li>哈希表</li>\n<li><font color='red'>键和值都是 String 类型</font></li>\n<li>适用于以键值对的方式存储<font color='red'>配置信息</font></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"4-常见集合类的区别和适用场景饿\"><a class=\"anchor\" href=\"#4-常见集合类的区别和适用场景饿\">#</a> 4. <mark>常见集合类的区别和适用场景</mark>（饿 **）</h4>\n<p>Java 中常见的集合类有 List、Set、Map。</p>\n<p>区别（元素特点）：</p>\n<ul>\n<li>List 中的元素是有序，可重复的；</li>\n<li>Set 中的元素是无序，不可重复的；</li>\n<li>Map 是由键值对组成的，键不可以重复，值可以重复。</li>\n</ul>\n<p>区别（实现类的底层数据结构）：</p>\n<ul>\n<li>\n<p>List 的实现类</p>\n<ul>\n<li>ArrayList 是一个动态数组</li>\n<li>LinkedList 是一个双向链表</li>\n<li>Vector 是一个线程安全的动态数组</li>\n</ul>\n</li>\n<li>\n<p>Set 的实现类</p>\n<ul>\n<li>HashSet 是基于哈希表实现的</li>\n<li>LinkedHashSet 是基于哈希表、双向链表实现的</li>\n<li>TreeSet 是基于红黑树实现的</li>\n</ul>\n</li>\n<li>\n<p>Map 的实现类</p>\n<ul>\n<li>HashMap 是基于哈希表实现的</li>\n<li>LinkedHashMap 是基于哈希表、双向链表实现的</li>\n<li>TreeMap 是基于红黑树实现的</li>\n</ul>\n</li>\n</ul>\n<p>适用场景：</p>\n<ul>\n<li>\n<p>List</p>\n<ul>\n<li>ArrayList：需要<font color='red'>频繁访问元素</font>时使用</li>\n<li>LinkedList：需要<font color='red'>频繁插入或删除元素</font>时使用</li>\n<li>Vector：需要<font color='red'>线程安全</font>时使用</li>\n</ul>\n</li>\n<li>\n<p>Set</p>\n<ul>\n<li>HashSet：需要<font color='red'>去重</font>时使用，不保证元素的顺序</li>\n<li>TreeSet：需要<font color='red'>排序</font>时使用</li>\n</ul>\n</li>\n<li>\n<p>Map</p>\n<ul>\n<li>HashMap：需要<font color='red'>快速的查找和插入</font>，不要求元素的顺序时使用</li>\n<li>LinkedHashMap：需要<font color='red'>保证键值对元素的顺序</font>时使用</li>\n<li>TreeMap：需要<font color='red'>排序</font>时使用</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"5-集合的父类是谁哪些安全的北京中信\"><a class=\"anchor\" href=\"#5-集合的父类是谁哪些安全的北京中信\">#</a> 5. <mark>集合的父类是谁？哪些安全的？</mark>（北京中 ** 信）</h4>\n<p>Collection、List、Set、Map 都是接口，不是类。</p>\n<p>（线程）不安全：ArrayList、HashSet、HashMap</p>\n<blockquote>\n<p>这些都是常用的，当需要线程安全时，调用 Collections 工具类中的同步方法对集合进行包装</p>\n</blockquote>\n<p>（线程） 安全：Vector、Hashtable</p>\n<blockquote>\n<p>反而不常用，因为效率低</p>\n</blockquote>\n<h4 id=\"6-集合说一下哪些是线程不安全的科软\"><a class=\"anchor\" href=\"#6-集合说一下哪些是线程不安全的科软\">#</a> 6. 集合说一下哪些是线程不安全的（* 科软）</h4>\n<p>除了 Vector 和 Hashtable。</p>\n<h4 id=\"7-遍历集合的方式有哪些恒电子\"><a class=\"anchor\" href=\"#7-遍历集合的方式有哪些恒电子\">#</a> 7. 遍历集合的方式有哪些？（恒 * 电子）</h4>\n<ul>\n<li>\n<p>迭代器 Iterator 用来遍历 Collection，不能用来遍历 Map！</p>\n<blockquote>\n<p><code>map.keySet().iterator()</code> 、 <code>map.values().iterator()</code> 、 <code>map.entrySet().iterator()</code>  本质上都是迭代器对 Set、Collection 进行遍历</p>\n</blockquote>\n</li>\n<li>\n<p>增强 for</p>\n<blockquote>\n<p>for (Object obj : 集合对象)</p>\n</blockquote>\n</li>\n<li>\n<p>一般的 for：可以用来遍历 List</p>\n</li>\n</ul>\n<h3 id=\"22-list接口\"><a class=\"anchor\" href=\"#22-list接口\">#</a> 2.2 List 接口</h3>\n<h4 id=\"1-list下面有哪些实现软力\"><a class=\"anchor\" href=\"#1-list下面有哪些实现软力\">#</a> 1. List 下面有哪些实现（软 ** 力）</h4>\n<p>ArrayList、LinkedList、Vector</p>\n<h4 id=\"2-arraylist与linkedlist区别oo-滴-汇天下-拓软件-博纳软件-上海进天下北京永生信息-联-在途游\"><a class=\"anchor\" href=\"#2-arraylist与linkedlist区别oo-滴-汇天下-拓软件-博纳软件-上海进天下北京永生信息-联-在途游\">#</a> 2. <mark>ArrayList 与 LinkedList 区别</mark>？(O**O、滴 *、汇 * 天下、拓 * 软件、博纳 ** 软件、上海 * 进天下，北京永生 ** 信息、* 联、在 * 途游)</h4>\n<pre><code>类似问题：\n&gt; ArrayList跟LinkedList的区别详细说出？（阿*校招、*东）\n</code></pre>\n<p>ArrayList 和 LinkedList 的区别如下：</p>\n<ul>\n<li>ArrayList 是基于<font color='red'>动态数组</font>实现的，而 LinkedList 是基于<font color='red'>双向链表</font>实现的。</li>\n<li><font color='red'>对于随机访问 get 和 set，ArrayList 更快</font>，因为 ArrayList 可以根据<strong>下标</strong>以 O (1) 时间复杂度对元素进行随机访问；而 LinkedList 需要<strong>移动指针遍历</strong>每个元素直到找到为止。</li>\n<li><font color='red'>对于新增和删除操作 add 和 remove，LinkedList 更快</font>，因为 ArrayList 在新增和删除元素时，可能需要<strong>扩容和复制数组</strong>；而 LinkedList 除了<strong>实例化对象</strong>需要时间外，只需要<strong>修改指针</strong>即可。</li>\n</ul>\n<p>补充上第 14 章中的源码（底层的数据结构）</p>\n<h4 id=\"3-arraylist与vector区别呢为什么要用arraylist取代vector呢湖利软件\"><a class=\"anchor\" href=\"#3-arraylist与vector区别呢为什么要用arraylist取代vector呢湖利软件\">#</a> 3. ==ArrayList 与 Vector 区别呢？== 为什么要用 ArrayList 取代 Vector 呢？(湖 ** 利软件)</h4>\n<p>ArrayList 和 Vector 的区别如下：</p>\n<ul>\n<li>ArrayList 不是同步的，而<font color='red'>Vector 是线程安全的</font>，也就是说是同步的。</li>\n<li><font color='red'>ArrayList 在性能方面更优</font>，因为 ArrayList 没有使用 synchronized 加锁，不加锁，所以处理速度会快一些。</li>\n<li>扩容：ArrayList 和 Vector 都会根据实际的需要动态的调整容量，只不过在<font color='red'>Vector 扩容每次会增加 1 倍，而 ArrayList 只会增加 50%</font>。</li>\n</ul>\n<p>因此，如果不需要线程安全的话，建议使用 ArrayList。</p>\n<h4 id=\"4-javautilarraylist常用的方法有哪些华为\"><a class=\"anchor\" href=\"#4-javautilarraylist常用的方法有哪些华为\">#</a> 4. Java.util.ArrayList 常用的方法有哪些？（华 ** 为）</h4>\n<ul>\n<li>Collection 接口中的方法</li>\n<li><font color='gree'>List 接口中的方法</font></li>\n<li><font color='purple'>ArrayList 类特有的方法</font></li>\n</ul>\n<p>例如：</p>\n<ul>\n<li>增\n<ul>\n<li>add (E obj)：在列表的<font color='red'>末尾</font>添加指定元素</li>\n<li>addAll(Collection other)</li>\n</ul>\n</li>\n<li>删\n<ul>\n<li>clear()</li>\n<li>remove (Object obj)：移除列表中<font color='red'>首次出现</font>的指定元素，如果存在，返回 true，否则返回 false</li>\n<li>removeAll(Collection coll)</li>\n<li>retainAll(Collection coll)</li>\n<li><font color='gree'><strong>remove</strong>(int index)</font></li>\n</ul>\n</li>\n<li>改\n<ul>\n<li><font color='gree'><strong>set</strong>(int index, Object ele)</font></li>\n</ul>\n</li>\n<li>查\n<ul>\n<li><font color='gree'><strong>get</strong>(int index)</font></li>\n<li><font color='gree'>subList(int fromIndex, int toIndex):</font></li>\n<li><font color='gree'>indexOf(Object obj)</font></li>\n<li><font color='gree'>lastIndexOf(Object obj)</font></li>\n</ul>\n</li>\n<li>插\n<ul>\n<li><font color='gree'><strong>add</strong>(int index, Object ele)</font></li>\n<li><font color='gree'>addAll(int index, Collection eles)</font></li>\n</ul>\n</li>\n<li>长度\n<ul>\n<li>size ()：返回列表中<font color='red'>实际存储的元素个数</font></li>\n</ul>\n</li>\n<li>遍历\n<ul>\n<li>iterator()</li>\n<li>增强 for 循环</li>\n<li>普通 for 循环</li>\n</ul>\n</li>\n<li>其他\n<ul>\n<li>isEmpty()</li>\n<li>contains(Object obj)</li>\n<li>containsAll(Collection coll)</li>\n<li>equals(Object obj)</li>\n<li>toArray()</li>\n<li>hashCode()</li>\n</ul>\n</li>\n<li>ArrayList 类特有\n<ul>\n<li><font color='purple'>ensureCapacity(int minCapacity)</font>：确保列表的容量至少等于指定的最小值</li>\n<li><font color='purple'>trimToSize()</font>：将列表的容量调整为列表的当前大小</li>\n<li><font color='purple'>clone()</font>：返回一个 ArrayList 对象的浅拷贝</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"5-arraylist-是有序还是无序为什么蜜信息\"><a class=\"anchor\" href=\"#5-arraylist-是有序还是无序为什么蜜信息\">#</a> 5. Arraylist 是有序还是无序？为什么？（蜜 * 信息）</h4>\n<p>有序；底层使用数组：Object []</p>\n<h3 id=\"23-set接口\"><a class=\"anchor\" href=\"#23-set接口\">#</a> 2.3 Set 接口</h3>\n<h4 id=\"1set集合有哪些实现类分别有什么特点拓软件\"><a class=\"anchor\" href=\"#1set集合有哪些实现类分别有什么特点拓软件\">#</a> 1.<mark>Set 集合有哪些实现类，分别有什么特点？</mark>（拓 * 软件）</h4>\n<pre><code>类似问题：\n&gt; Set的实现类有哪些？（博*科技）\n</code></pre>\n<ul>\n<li>\n<p>HashSet</p>\n<ul>\n<li>主要实现类</li>\n<li>基于哈希表</li>\n<li>存取速度快</li>\n<li>不保证元素的顺序</li>\n<li>允许 null</li>\n</ul>\n</li>\n<li>\n<p>LinkedHashSet</p>\n<ul>\n<li>\n<p>HashSet 的子类</p>\n</li>\n<li>\n<p>基于哈希表 + <font color='red'>双向链表</font></p>\n</li>\n<li>\n<p>记录了元素的添加顺序，便于频繁查询</p>\n</li>\n<li>\n<p><font color='red'> <code>插入性能略低</code> 于 HashSet，但 <code>迭代访问性能</code>  优于 HashSet</font></p>\n<blockquote>\n<p>LinkedHashSet 的插入性能低于 HashSet，是因为 LinkedHashSet 除了维护一个哈希表外，还要维护一个双向链表来记录元素的插入顺序 ²³。这样<font color='red'>在插入元素时，需要额外的操作来<strong>更新链表的指针</strong>，而 HashSet 不需要这样做</font>¹²。</p>\n<p>LinkedHashSet 的迭代性能优于 HashSet，是因为<font color='red'>LinkedHashSet 可以直接<strong>按照链表的顺序来遍历元素</strong>，而不需要对哈希表进行排序或者查找</font>²⁴。而<font color='red'>HashSet 在遍历时，需要<strong>根据哈希值来确定元素的位置</strong>，可能会遇到哈希冲突或者空桶的情况，导致性能下降</font>¹²。</p>\n</blockquote>\n</li>\n</ul>\n</li>\n<li>\n<p>TreeSet</p>\n<ul>\n<li>基于红黑树</li>\n<li>要求元素属于同一个类，不允许 null</li>\n<li>可以按照元素的指定属性的大小顺序进行排序（自然排序 / 定制排序）</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"2-list集合和set集合的区别亚科技-海翼科技华电系统达贷\"><a class=\"anchor\" href=\"#2-list集合和set集合的区别亚科技-海翼科技华电系统达贷\">#</a> 2. <mark>List 集合和 Set 集合的区别？</mark>（亚 * 科技、* 海 * 翼科技，* 华电 * 系统，达 * 贷）</h4>\n<p>List 集合和 Set 集合的区别有以下几点 ¹²：</p>\n<ul>\n<li><font color='red'>List 集合<strong>是有序的</strong></font>，可以按照元素的插入顺序（LinkedList）或者指定的索引（ArrayList）来访问元素，而<font color='red'>Set 集合是无序的</font>，不能通过索引来访问元素 ¹²。</li>\n<li><font color='red'>List 集合<strong>可以包含重复的元素</strong>，也可以包含多个 null 元素</font>，而<font color='red'>Set 集合不允许包含重复的元素，最多只能包含一个 null 元素</font>¹²。</li>\n<li><font color='red'>List 集合继承了 Collection 接口，并提供了一些<strong>额外的方法</strong></font>，如 get (int index), set (int index, E element), add (int index, E element), remove (int index) 等，而<font color='red'>Set 集合没有提供这些方法</font>¹²。</li>\n<li><font color='red'>List 集合的<strong>实现类</strong>有 ArrayList, LinkedList 和 Vector</font>，而<font color='red'>Set 集合的实现类有 HashSet, LinkedHashSet 和 TreeSet</font>¹²。</li>\n</ul>\n<h4 id=\"3-set里的元素是不能重复的那么用什么方法来区分重复与否呢-是用还是equals-它们有何区别鸿网络\"><a class=\"anchor\" href=\"#3-set里的元素是不能重复的那么用什么方法来区分重复与否呢-是用还是equals-它们有何区别鸿网络\">#</a> 3. <mark>Set 里的元素是不能重复的，那么用什么方法来区分重复与否呢？是用</mark>还是 equals ()? 它们有何区别？==（鸿 * 网络）</h4>\n<pre><code>类似问题：\n&gt; 1.HashSet如何检查重复(创*科技)\n&gt; 3.Set使用哪个区分不能重复的元素的？（北京创**荣信息）\n</code></pre>\n<p>Set 里的元素是不能重复的，它是通过调用元素的<font color='orange'> <code>equals()</code>  和 <code>hashCode()</code> </font>方法来判断两个元素是否相等的 ¹²。<font color='red'>如果两个元素的 equals () 方法返回 true，并且它们的 hashCode () 方法返回相同的值，那么它们就被认为是相等的</font>，Set 就不会存储重复的元素 ¹²。</p>\n<p><code>==</code>  和 <code>equals()</code>  都是用来比较两个对象是否相等的，但它们有以下区别 ³：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\"></th>\n<th style=\"text-align:center\">==</th>\n<th style=\"text-align:center\">equals()</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">比较的数据类型</td>\n<td style=\"text-align:center\">基本数据类型、引用数据类型</td>\n<td style=\"text-align:center\">引用数据类型</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">对于引用数据类型</td>\n<td style=\"text-align:center\">比较的是内存地址，是否指向同一个对象</td>\n<td style=\"text-align:center\">比较的是对象的内容</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">比较规则</td>\n<td style=\"text-align:center\">固定</td>\n<td style=\"text-align:center\">可以重写</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><font color='red'> <code>==</code>  是一个运算符，它可以用来比较<u>基本数据类型</u>和<u>引用数据类型</u></font>，而<font color='red'> <code>equals()</code>  是一个方法，它只能用来比较<u>引用数据类型</u></font>。</li>\n<li><font color='red'> <code>==</code>  比较的是两个对象的<u>内存地址</u>，即它们是否指向同一个对象</font>，而<font color='red'> <code>equals()</code>  比较的是两个<u>对象的内容</u>，即它们是否逻辑上相等</font>³。</li>\n<li><font color='red'> <code>==</code>  的<u>比较规则是固定的</u></font>，而<font color='red'> <code>equals()</code>  的<u>比较规则可以根据不同的类来重写</u></font>，例如 String 类就重写了 equals () 方法，使得它可以比较两个字符串的值是否相同 ³。</li>\n</ul>\n<h4 id=\"4-treeset两种排序方式在使用的时候怎么起作用拓软件\"><a class=\"anchor\" href=\"#4-treeset两种排序方式在使用的时候怎么起作用拓软件\">#</a> 4. TreeSet 两种排序方式在使用的时候怎么起作用？（拓 * 软件）</h4>\n<p>在<font color='red'>添加新的元素</font>时，需要<font color='red'>调用 <code>compareTo()</code>  或 <code> compare()</code> </font>。</p>\n<p><font color='red'>TreeSet 是一个基于<strong>红黑树</strong>实现的<strong>有序</strong>集合，它可以按照<strong>元素中的指定属性</strong>的<u>自然排序</u>或者<u>定制排序</u>来存储和遍历元素</font>¹²。它的两种排序方式在使用的时候有以下区别：</p>\n<ul>\n<li>自然排序：如果元素实现了 Comparable 接口，那么 TreeSet 会调用元素的 compareTo () 方法来比较元素的大小，并按照升序排列 ¹²³。例如，String 类就实现了 Comparable 接口，它的 compareTo () 方法是按照字典顺序比较字符串的 ¹²。</li>\n<li>指定排序：如果元素没有实现 Comparable 接口，或者想要使用不同的排序规则，那么可以在构造 TreeSet 时传入一个 Comparator 对象，它是一个比较器接口，可以自定义比较元素的方法 ¹²⁴。这种方式可以覆盖元素的自然顺序，也可以对没有自然顺序的元素进行排序 ¹²。例如，Student 类没有实现 Comparable 接口，但是可以通过传入一个 Comparator 对象来按照学号或者姓名等属性进行排序</li>\n</ul>\n<h4 id=\"5-treeset的数据结构米\"><a class=\"anchor\" href=\"#5-treeset的数据结构米\">#</a> 5. <mark>TreeSet 的数据结构</mark>（* 米）</h4>\n<p>TreeSet 是一个有序集合，它的内部实现是<font color='orange'>基于一个红黑树的 TreeMap</font>。<font color='red'>TreeMap 是一个键值对的映射，它的键是按照自然顺序或者指定的比较器顺序来排序的</font>。<font color='red'>TreeSet 只使用了 TreeMap 的键，而把值设置为一个固定的常量</font>。</p>\n<p>红黑树是一种<font color='orange'>自平衡的二叉搜索树</font>，它满足以下性质：</p>\n<p><img data-src=\"https://upload.wikimedia.org/wikipedia/commons/thumb/6/66/Red-black_tree_example.svg/450px-Red-black_tree_example.svg.png\" alt=\"img\" /></p>\n<ul>\n<li>每个节点要么是红色，要么是黑色</li>\n<li>根节点是黑色</li>\n<li>每个叶子节点（空节点）是黑色</li>\n<li>如果一个节点是红色，那么它的两个子节点都是黑色</li>\n<li>从任意一个节点到其每个叶子节点的所有路径都包含相同数目的黑色节点</li>\n</ul>\n<p>这些性质<font color='red'>保证了红黑树的高度近似于<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">log(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span>，从而使得插入、删除和查找操作的时间复杂度都是<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(log(n))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span><span class=\"mclose\">)</span></span></span></span></font>。</p>\n<p>TreeSet 使用红黑树的意义是<font color='red'>为了保证集合中的元素可以按照<strong>一定的顺序</strong>进行存储和遍历</font>，同时也为了<font color='red'>提高集合中的插入、删除和查找操作的效率</font>¹²³。</p>\n<p>TreeSet 使用红黑树的好处有以下几点 ¹²³：</p>\n<ul>\n<li>红黑树是一种 **<font color='red'>自平衡的二叉搜索树</font>**，它<font color='red'>可以保证在最坏情况下，插入、删除和查找操作的时间复杂度都是<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(log(n))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span><span class=\"mclose\">)</span></span></span></span>，而不会退化成链表或者倾斜树</font></li>\n<li>红黑树<font color='red'><strong>可以按照元素的自然顺序或者指定的比较器顺序来排序</strong></font>，这样可以<font color='red'>方便地对集合中的元素进行遍历、查找、范围查询等操作</font></li>\n<li>红黑树<font color='red'><strong>可以利用节点的颜色信息来维持树的平衡</strong>，这样可以减少旋转和重构的次数，提高操作的性能</font></li>\n</ul>\n<h3 id=\"24-map接口\"><a class=\"anchor\" href=\"#24-map接口\">#</a> 2.4 Map 接口</h3>\n<h4 id=\"1-说一下java的集合map有哪些实现类奥医药\"><a class=\"anchor\" href=\"#1-说一下java的集合map有哪些实现类奥医药\">#</a> 1. <mark>说一下 Java 的集合 Map 有哪些实现类？</mark>（奥 * 医药）</h4>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">Map 接口的实现类</th>\n<th style=\"text-align:center\"><em>HashMap</em></th>\n<th style=\"text-align:center\">LinkedHashMap</th>\n<th style=\"text-align:center\">TreeMap</th>\n<th style=\"text-align:center\"><s>Hashtable</s></th>\n<th style=\"text-align:center\">Properties</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">地位</td>\n<td style=\"text-align:center\">主要实现类</td>\n<td style=\"text-align:center\">HashMap 的子类</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">古老实现类</td>\n<td style=\"text-align:center\"><s>Hashtable</s> 的子类</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">底层实现</td>\n<td style=\"text-align:center\">哈希表</td>\n<td style=\"text-align:center\">哈希表 + <font color='red'>双向链表</font></td>\n<td style=\"text-align:center\">红黑树</td>\n<td style=\"text-align:center\">哈希表</td>\n<td style=\"text-align:center\">哈希表</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">数据结构</td>\n<td style=\"text-align:center\">一维数组 + 单向链表（+ 红黑树）</td>\n<td style=\"text-align:center\">一维数组 + 单向链表（+ 红黑树） + <font color='red'>双向链表</font></td>\n<td style=\"text-align:center\">红黑树</td>\n<td style=\"text-align:center\">一维数组 + 单向链表</td>\n<td style=\"text-align:center\">一维数组 + 单向链表</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">键、值是否允许为 null</td>\n<td style=\"text-align:center\">是</td>\n<td style=\"text-align:center\">是</td>\n<td style=\"text-align:center\"><font color='red'>键不能为 null</font>，值可以为 null</td>\n<td style=\"text-align:center\">键和值都不能为 null</td>\n<td style=\"text-align:center\">键和值都不能为 null</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">是否线程安全</td>\n<td style=\"text-align:center\">否</td>\n<td style=\"text-align:center\">否</td>\n<td style=\"text-align:center\">否</td>\n<td style=\"text-align:center\"><font color='red'>是，因此效率低</font></td>\n<td style=\"text-align:center\"><font color='red'>是，因此效率低</font></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">特点</td>\n<td style=\"text-align:center\">查找、插入、删除速度快，但不保证元素的顺序</td>\n<td style=\"text-align:center\">保证元素的<font color='red'>插入 / 访问顺序</font></td>\n<td style=\"text-align:center\"><font color='red'>可以按照<strong> key 中的指定属性</strong>的大小顺序进行遍历</font>：①自然排序；②定制排序</td>\n<td style=\"text-align:center\"><font color='red'>线程安全</font>，效率低</td>\n<td style=\"text-align:center\"><font color='red'>键和值都是 String 类型</font></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">性能</td>\n<td style=\"text-align:center\">①<font color='red'>查找、插入、删除速度快</font>；②迭代遍历速度慢（因为和容量有关，需要遍历底层数组，以及每个数组元素对应的链表 / 红黑树，数组的长度就是 HashMap 的容量）</td>\n<td style=\"text-align:center\">①<font color='red'>插入、删除速度慢</font>；②迭代遍历比 HashMap 快（因为只和实际数据有关，和容量无关）</td>\n<td style=\"text-align:center\">查找、插入、删除速度慢（<font color='red'>因为要维护红黑树的平衡、顺序</font>）</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">内存</td>\n<td style=\"text-align:center\">占用大，保存数组</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">占用小，保存节点</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">使用场景</td>\n<td style=\"text-align:center\">快速的查找和插入，不要求元素的顺序</td>\n<td style=\"text-align:center\">需要保持元素的插入顺序或者访问顺序</td>\n<td style=\"text-align:center\">适用于需要<font color='red'>有序</font>的键值对集合</td>\n<td style=\"text-align:center\">适用于需要线程安全的场景</td>\n<td style=\"text-align:center\">以键值对的方式存储<font color='red'>配置信息</font></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">补充说明</td>\n<td style=\"text-align:center\"><font color='red'>在 JDK8 引入红黑树</font></td>\n<td style=\"text-align:center\">双向链表: <font color='red'>记录元素的添加顺序</font></td>\n<td style=\"text-align:center\"><font color='red'>①自然排序</font>（key 所在类实现了 Comparable 接口）；<font color='red'>②定制排序</font>（在创建 TreeMap 时传入 Comparator 对象）；</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">要求 key</td>\n<td style=\"text-align:center\"><font color='red'>key 所在类要重写 <code>hashCode()</code>  和 <code>equals()</code> </font></td>\n<td style=\"text-align:center\">与 HashMap 相同</td>\n<td style=\"text-align:center\"><font color='red'>key 必须是同一个类的对象</font></td>\n<td style=\"text-align:center\">与 HashMap 相同</td>\n<td style=\"text-align:center\">key 是 String 类</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">要求 value</td>\n<td style=\"text-align:center\"><font color='red'>value 所在类要重写 <code>equals()</code> </font></td>\n<td style=\"text-align:center\">与 HashMap 相同</td>\n<td style=\"text-align:center\">无</td>\n<td style=\"text-align:center\">与 HashMap 相同</td>\n<td style=\"text-align:center\">value 是 String 类</td>\n</tr>\n</tbody>\n</table>\n<p>Java 的集合 Map 有以下几种常见的实现类：</p>\n<ul>\n<li>HashMap：基于哈希表的 Map 接口的实现，允许使用 null 键和 null 值，不保证映射的顺序，是线程不安全的，支持快速的插入、删除和查找操作</li>\n<li>TreeMap：基于红黑树的 Map 接口的实现，按照键的自然顺序或者指定的比较器顺序来排序，不允许使用 null 键，但可以使用 null 值，是线程不安全的，支持有序的插入、删除和查找操作</li>\n<li>LinkedHashMap：基于哈希表和双向链表的 Map 接口的实现，按照插入顺序或者访问顺序来排序，允许使用 null 键和 null 值，是线程不安全的，结合了 HashMap 的查询速度和 LinkedHashSet 的插入顺序</li>\n<li>Hashtable：基于哈希表的 Map 接口的旧版本实现，不允许使用 null 键和 null 值，保证映射的顺序，是线程安全的，但效率低于 HashMap 和 ConcurrentHashMap</li>\n<li>ConcurrentHashMap：基于哈希表和分段锁或者 CAS 技术的 Map 接口的实现，不允许使用 null 键和 null 值，不保证映射的顺序，是线程安全的，并发性能高于 Hashtable</li>\n</ul>\n<h4 id=\"2-final怎么用修饰map可以继续添加数据吗深蓝\"><a class=\"anchor\" href=\"#2-final怎么用修饰map可以继续添加数据吗深蓝\">#</a> 2. <mark>final 怎么用，修饰 Map 可以继续添加数据吗？</mark>（* 深蓝）</h4>\n<p>final 是一个关键字，可以用来修饰类、方法、变量等。final 的作用有以下几点：</p>\n<ul>\n<li>修饰类：表示该类不能被继承，如 String 类</li>\n<li>修饰方法：表示该方法不能被重写，如 Object 类的 getClass () 方法</li>\n<li>修饰变量：表示该变量是一个常量，只能被赋值一次，如 Math 类的 PI 常量</li>\n</ul>\n<p><font color='red'>final 修饰 Map 时，表示该 Map 的引用是一个常量，不能再指向其他的对象。但是，<strong>这并不影响 Map 中的键值对的添加、删除和修改</strong>。因为 final 只保证了引用的不变性，而不保证了引用指向的对象的不变性</font>。</p>\n<p><font color='red'>如果想要让 Map 中的键值对也不能被修改，可以使用 <code>Collections.unmodifiableMap()</code>  方法来返回一个不可修改的 Map 视图</font>。</p>\n<p>例如：</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">// 创建一个普通的 HashMap</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token class-name\">Map</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span></span> map <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">HashMap</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>map<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"a\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>map<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"b\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>map<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// &#123;a=1, b=2&#125;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token comment\">// 使用 final 修饰 map 的引用</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token keyword\">final</span> <span class=\"token class-name\">Map</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span></span> finalMap <span class=\"token operator\">=</span> map<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token comment\">//finalMap = new HashMap&lt;> (); // 编译错误，不能再赋值</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>finalMap<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"c\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 可以添加数据</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>finalMap<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// &#123;a=1, b=2, c=3&#125;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token comment\">// 使用 Collections.unmodifiableMap () 返回一个不可修改的 Map 视图</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre><span class=\"token class-name\">Map</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span></span> unmodifiableMap <span class=\"token operator\">=</span> <span class=\"token class-name\">Collections</span><span class=\"token punctuation\">.</span><span class=\"token function\">unmodifiableMap</span><span class=\"token punctuation\">(</span>map<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre><span class=\"token comment\">//unmodifiableMap.put (\"d\", 4); // 运行时异常，不能添加数据</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre><span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>unmodifiableMap<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// &#123;a=1, b=2, c=3&#125;</span></pre></td></tr></table></figure><h4 id=\"3-set和map的比较亚科技\"><a class=\"anchor\" href=\"#3-set和map的比较亚科技\">#</a> 3. <mark>Set 和 Map 的比较</mark>（亚 * 科技）</h4>\n<p>HashSet 底层就是 HashMap</p>\n<p>LinkedHashSet 底层就是 LinkedHashMap</p>\n<p>TreeSet 底层就是 TreeMap</p>\n<p>Set 和 Map 是 Java 中两种不同的集合接口，它们有以下几点区别：</p>\n<ul>\n<li>\n<p>元素特点</p>\n<ul>\n<li>Set 是一个<font color='red'>不包含重复元素</font>的集合，它只存储键，而不存储值</li>\n<li>Map 是一个键值对的映射，它存储键和值，且<font color='red'>键不能重复，但值可以重复</font></li>\n</ul>\n</li>\n<li>\n<p>无序性</p>\n<ul>\n<li>Set 是一个无序的集合，它不保证元素的存储顺序，除非使用有序的实现类如 TreeSet 或 LinkedHashSet</li>\n<li>Map 也是一个无序的映射，它不保证键或值的存储顺序，除非使用有序的实现类如 TreeMap 或 LinkedHashMa</li>\n</ul>\n</li>\n<li>\n<p>遍历方式</p>\n<ul>\n<li>Set<font color='red'>可以直接遍历</font>其元素，使用 iterator () 方法或 foreach 循环</li>\n<li>Map 不能直接遍历其元素，需要使用 keySet ()、values () 或 entrySet () 方法<font color='red'>先获取其键集、值集或键值对集</font>，然后再使用 iterator () 方法或 foreach 循环遍历</li>\n</ul>\n</li>\n<li>\n<p>null</p>\n<ul>\n<li>Set<font color='red'>最多只能存储一个 null 元素</font></li>\n<li>Map<font color='red'>最多只能有一个 null 键和任意个 null 值</font></li>\n</ul>\n</li>\n<li>\n<p>实现类的特点、用途</p>\n<ul>\n<li>\n<p>Set</p>\n<ul>\n<li>HashSet 是基于哈希表的 Set 实现类，它提供了快速的插入和查找操作，但不保证元素的顺序</li>\n<li>LinkedHashSet 是基于哈希表和双向链表的 Set 实现类，它按照元素的插入顺序来排序，同时也保持了 HashSet 的查询速度</li>\n<li>TreeSet 是基于红黑树的 Set 实现类，它按照<font color='red'>元素</font>的自然顺序或指定的比较器顺序来排序，但插入和查找操作较慢</li>\n</ul>\n</li>\n<li>\n<p>Map</p>\n<ul>\n<li>HashMap 是基于哈希表的 Map 实现类，它提供了快速的插入、删除和查找操作，但不保证键或值的顺序</li>\n<li>LinkedHashMap 是基于哈希表和双向链表的 Map 实现类，它按照键的插入顺序或访问顺序来排序，同时也保持了 HashMap 的查询速度</li>\n<li>TreeMap 是基于红黑树的 Map 实现类，它按照<font color='red'>键</font>的自然顺序或指定的比较器顺序来排序，但插入、删除和查找操作较慢</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"4-介绍一下hashmap是线程安全的吗米\"><a class=\"anchor\" href=\"#4-介绍一下hashmap是线程安全的吗米\">#</a> 4. <mark>介绍一下 HashMap，是线程安全的吗？</mark>（* 米）</h4>\n<pre><code>类似问题：\n&gt; HashMap为什么线程不安全？（微*银行）\n&gt; HashMap是线程安全的吗？为什么不安全？（*团、*东、顺*）\n</code></pre>\n<p>HashMap 是一种基于<font color='gree'><strong>哈希表</strong></font>的 Map 接口实现，它可以存储<font color='red'><strong>键值对 (key-value) 映射</strong></font>，具有以下特点:</p>\n<ul>\n<li>\n<p>HashMap 是<font color='gree'><strong>无序的</strong></font>，也就是说它不会记录插入的顺序，而是<font color='red'>根据键的哈希值来决定元素在数组中的位置</font></p>\n</li>\n<li>\n<p>HashMap 是<font color='gree'><strong>线程不安全</strong></font>的，也就是说如果多个线程同时对 HashMap 进行修改操作，可能会导致数据丢失、死循环或数据覆盖等问题。<font color='orange'>如果需要线程安全的 Map 实现，可以使用 Hashtable、 <code>Collections.synchronizedMap()</code>  或 ConcurrentHashMap</font></p>\n</li>\n<li>\n<p>HashMap<font color='red'>最多一个 null 键，任意个 null 值</font></p>\n</li>\n<li>\n<p>HashMap 有<font color='gree'>两个重要的参数</font>：</p>\n<ul>\n<li><font color='cornflowerblue'>初始容量大小</font>是创建时给数组分配的容量大小，默认值为 16，<font color='cornflowerblue'>加载因子</font>默认 0.75f，<font color='red'>用数组容量大小乘以加载因子得到一个值，一旦数组中存储的元素个数超过该值就会调用 <code>resize()</code>  将数组容量增加到原来的两倍</font>，专业术语叫做<font color='gree'>扩容</font>。<font color='red'>扩容的操作非常消耗性能，因为需要重新计算所有元素的哈希值并重新分配到新的数组中</font></li>\n</ul>\n</li>\n<li>\n<p>HashMap 的<font color='gree'>数据结构</font>是 **<font color='orange'>数组 + 链表 + 红黑树</font>**。</p>\n<ul>\n<li>数组是主要的数据结构，<font color='red'>每个数组元素又是一个链表或红黑树的头节点</font>。</li>\n<li>当通过键的哈希值计算出数组下标时，\n<ul>\n<li>如果该位置没有元素，则直接插入</li>\n<li>如果该位置有元素，则需要判断该元素与插入元素的<font color='red'>hashCode 是否相等</font>\n<ul>\n<li>如果相等则覆盖</li>\n<li>如果不等则<font color='red'>以链表或红黑树的形式插入到该位置</font>，<font color='red'>当链表的长度超过 8 时，会将链表转换为红黑树，以提高查找效率</font></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>HashMap 的<font color='gree'>主要操作</font>有 put () 和 get () 方法，它们的实现原理如下:</p>\n<ul>\n<li>\n<p><font color='cornflowerblue'>put()</font></p>\n<ul>\n<li>首先将键和值封装成一个 Node 对象</li>\n<li>然后调用键的 hashCode () 方法得到哈希值，并通过哈希函数转换成数组下标\n<ul>\n<li>\n<p>如果该下标位置没有元素，则直接插入</p>\n</li>\n<li>\n<p>如果该位置有元素，则遍历该位置的链表或红黑树，比较每个节点的键是否与插入元素的键相等</p>\n<ul>\n<li>如果相等则覆盖</li>\n<li>如果不等则插入到链表尾部或红黑树中</li>\n</ul>\n</li>\n<li>\n<p>最后判断是否需要扩容</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><font color='cornflowerblue'>get()</font></p>\n<ul>\n<li>首先调用键的 hashCode () 方法得到哈希值，并通过哈希函数转换成数组下标</li>\n<li>然后根据下标找到对应的链表或红黑树头节点，遍历该链表或红黑树，比较每个节点的键是否与查找元素的键相等\n<ul>\n<li>如果相等则返回该节点的值</li>\n<li>如果不等则继续查找，如果遍历完毕没有找到，则返回 null</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"5-hashmap和hashtable的区别银数据-阿巴芝麻信用-众银行-爱信-杭州智公司\"><a class=\"anchor\" href=\"#5-hashmap和hashtable的区别银数据-阿巴芝麻信用-众银行-爱信-杭州智公司\">#</a> 5. <mark>HashMap 和 Hashtable 的区别？</mark>(银 * 数据、阿 ** 巴芝麻信用、* 众银行、爱 * 信、杭州 * 智公司)</h4>\n<pre><code>类似问题：\n&gt; HashMap 和 HashTable 有什么区别，以及如何使用，以及他的一些方法？（阿*校招、*东、*度校招、顺*）\n</code></pre>\n<p>HashMap 和 Hashtable 都是实现了 Map 接口的类，它们都可以存储键值对 (key-value) 映射，但是它们之间也有一些区别:</p>\n<ul>\n<li>\n<p><font color='red'>HashMap 是线程不安全的</font>，也就是说如果多个线程同时对 HashMap 进行修改操作，可能会导致数据丢失、死循环或数据覆盖等问题。<font color='red'>Hashtable 是线程安全的</font>，它的方法都使用了 synchronized 关键字来保证同步，但是这也降低了效率</p>\n</li>\n<li>\n<p><font color='red'>HashMap 允许键和值都为 null，但是最多只能有一个键为 null 的元素</font>。<font color='red'>Hashtable 不允许键和值为 null</font>，否则会抛出 NullPointerException 异常</p>\n<blockquote>\n<ul>\n<li>\n<p>HashMap 是在 JDK1.2 中引入的，它是为了提供更高效和灵活的 Map 实现，而不考虑线程安全和兼容性。<font color='red'>HashMap 允许键值为 null，是因为它使用了特殊的处理逻辑来处理 null 键值，比如使用 0 作为 null 键的哈希值，使用 equals 方法而不是 == 来比较 null 值等</font>。这样做的好处是可以使得 HashMap 更通用和灵活，可以适应不同的场景和需求。</p>\n</li>\n<li>\n<p>Hashtable 是在 JDK1.0 中引入的，它是为了提供一个线程安全和兼容性较好的 Map 实现，而不考虑效率和灵活性。<font color='red'>Hashtable 不允许键值为 null，是因为它直接使用了键值的 hashCode () 方法和 == 运算符来计算哈希值和比较对象，如果键值为 null，就会抛出 NullPointerException 异常</font>。这样做的好处是可以使得 Hashtable 更简单和稳定，可以避免一些潜在的错误和异常 。</p>\n</li>\n</ul>\n</blockquote>\n</li>\n<li>\n<p><font color='red'>HashMap 的底层数组长度必须为 2 的幂次方，这样可以利用 &amp; 运算代替 % 运算提高效率，并且使得元素分布更均匀</font>。<font color='red'>Hashtable 的底层数组长度可以为任意值</font>，但是一般使用质数来减少哈希冲突</p>\n</li>\n<li>\n<p>HashMap 的哈希函数使用了键的 hashCode () 方法和高低位异或运算来计算哈希值，并且在链表长度超过 8 时会转换为红黑树来提高查找效率。Hashtable 的哈希函数只使用了键的 hashCode () 方法，并且一直使用链表来解决冲突</p>\n</li>\n</ul>\n<h4 id=\"6-hashtable是怎么实现的为什么线程安全迪创新\"><a class=\"anchor\" href=\"#6-hashtable是怎么实现的为什么线程安全迪创新\">#</a> 6. <mark>Hashtable 是怎么实现的，为什么线程安全？</mark>（迪 * 创新）</h4>\n<p>哈希表（数组 + 单向链表）；底层方法使用 synchronized 修饰。</p>\n<p>Hashtable 是一种基于哈希表的 Dictionary 的子类，它实现了 Map 接口，可以存储键值对 (key-value) 映射：</p>\n<ul>\n<li>Hashtable 的内部数据结构是<font color='orange'>一个 Entry 数组，每个 Entry 是一个单向链表的头节点，用来解决哈希冲突</font>。当插入或查找一个元素时，首先根据键的 hashCode () 方法和取模运算计算出数组下标，然后遍历对应位置的链表，比较每个节点的键是否与目标元素的键相等，如果相等则返回或覆盖，如果不等则插入或继续查找</li>\n<li>Hashtable 的<font color='orange'>所有方法都使用了 <code>synchronized</code>  关键字来修饰</font>，这意味着它是线程安全的，多个线程可以共享一个 Hashtable 对象。但是<font color='red'>这也导致了它的效率较低，因为每次操作都需要获取锁和释放锁</font></li>\n<li>Hashtable<font color='red'>不允许键和值为 null，否则会抛出 NullPointerException 异常</font>。这是因为它直接使用了键和值的 hashCode () 方法和 equals () 方法来计算哈希值和比较对象，如果键或值为 null，就会导致空指针异常</li>\n<li>Hashtable 有两个重要的参数：<font color='cornflowerblue'>初始容量大小</font>和<font color='cornflowerblue'>加载因子</font>。初始容量大小是创建时给数组分配的容量大小，默认值为 11，加载因子默认 0.75f，用数组容量大小乘以加载因子得到一个值，一旦数组中存储的元素个数超过该值就会调用 rehash 方法将数组容量增加到原来的两倍加一（通常为质数），专业术语叫做<font color='red'>扩容</font>。扩容的操作非常消耗性能，因为需要重新计算所有元素的哈希值并重新分配到新的数组中</li>\n</ul>\n<h4 id=\"7-hashmap和linkedhashmap的区别北京晨阳光\"><a class=\"anchor\" href=\"#7-hashmap和linkedhashmap的区别北京晨阳光\">#</a> 7. <mark>HashMap 和 LinkedHashMap 的区别</mark>（北京 * 晨阳光）</h4>\n<p>HashMap 和 LinkedHashMap 都是实现了 Map 接口的类，它们都可以存储键值对 (key-value) 映射，但是它们之间也有一些区别：</p>\n<ul>\n<li><font color='red'>HashMap 是基于哈希表的</font>，它根据键的 hashCode () 方法和取模运算计算出数组下标，然后在对应位置的链表中查找或插入元素。<font color='red'>HashMap 不保证元素的顺序，遍历时取得数据的顺序是完全随机的</font>。</li>\n<li><font color='red'>LinkedHashMap 是继承自 HashMap 的</font>，它<font color='red'>在 HashMap 的基础上增加了一个<strong>双向链表</strong></font>，用来维护元素的插入顺序或访问顺序。<font color='red'>LinkedHashMap 保证元素的顺序，遍历时取得数据的顺序是按照插入或访问的先后顺序</font>。</li>\n<li>HashMap 和 LinkedHashMap 在性能方面：\n<ul>\n<li><font color='gree'>插入、删除元素</font>：<font color='red'>由于 LinkedHashMap 需要额外维护一个双向链表，所以在 <code>插入和删除元素</code> 时会比 HashMap 慢一些</font>。</li>\n<li><font color='gree'>迭代遍历</font>：<font color='red'>LinkedHashMap 在 <code>遍历元素</code> 时会比 HashMap 快一些，因为 LinkedHashMap 的遍历速度只和实际数据有关，和容量无关</font>。而<font color='red'>HashMap 的遍历需要遍历底层数组，以及每个数组元素对应的链表 / 红黑树，数组的长度就是 HashMap 的容量，如果容量太大，那么遍历数组就会花费很多时间</font>。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"8-hashmap-和-treemap-的区别度太极-线途游-阿校招\"><a class=\"anchor\" href=\"#8-hashmap-和-treemap-的区别度太极-线途游-阿校招\">#</a> 8. <mark>HashMap 和 TreeMap 的区别</mark>（<em>度，太极</em> *、* 线途游、阿 * 校招）</h4>\n<p>HashMap 和 TreeMap 都是实现了 Map 接口的类，用来存储键值对，但是它们有以下几个方面的区别：</p>\n<ul>\n<li>数据结构：HashMap 是基于<font color='red'>哈希表</font>来实现的，而 TreeMap 是基于<font color='red'>红黑树</font>来实现的</li>\n<li>排序：HashMap<font color='red'>不保证映射的顺序</font>，而 TreeMap 根<font color='red'>据键的自然顺序或者指定的比较器来对键进行排序</font></li>\n<li>空值：HashMap 可以<font color='red'>允许一个 null 键和多个 null 值</font>，而 TreeMap<font color='red'>不允许 null 键，但是可以允许多个 null 值</font></li>\n<li>性能：\n<ul>\n<li>增、删、查：<font color='red'>HashMap 在添加、查找、删除等操作上速度会比较快，因为它只需要计算哈希值和数组下标，而 TreeMap 在这些操作上速度会比较慢，因为它需要维护红黑树的平衡和顺序</font></li>\n<li>内存：<font color=\"red\">HashMap 会占用更多的空间，因为它需要保存一个数组，而 TreeMap 会占用更少的空间，因为它只需要保存节点</font></li>\n<li>另外，HashMap 如果出现哈希冲突或者扩容的话，效率会降低</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"9-hashmap里面实际装的是什么惠\"><a class=\"anchor\" href=\"#9-hashmap里面实际装的是什么惠\">#</a> 9. <mark>HashMap 里面实际装的是什么？</mark>（惠 *）</h4>\n<p>JDK7：HashMap 内部声明了 Entry，实现了 Map 中的 Entry 接口。（key，value 作为 Entry 的两个属性出现）</p>\n<p>JDK8：HashMap 内部声明了 Node，实现了 Map 中的 Entry 接口。（key，value 作为 Node 的两个属性出现）</p>\n<p>HashMap 的内部结构包括以下几个部分：</p>\n<ul>\n<li>一个<font color='gree'>动态数组</font>，用来存放 Node 对象，每个 Node 对象包含一个 Entry 对象，Entry 对象中保存了键、值、哈希值等信息。</li>\n<li>一个<font color='gree'>哈希函数</font>，用来根据键的哈希值计算出数组的下标。</li>\n<li>一个<font color='gree'>负载因子</font>，用来控制数组的扩容时机，当数组中的元素个数超过数组长度乘以负载因子时，就会触发扩容操作。</li>\n<li>一个<font color='gree'>链表或者红黑树</font>，用来<font color='red'>解决哈希冲突，即当多个键的哈希值相同或者映射到同一个数组下标时，就会把这些键值对连接起来，形成一个链表或者红黑树</font>。<font color='red'>链表在元素个数达到 8 时会转换为红黑树，以提高查找效率</font></li>\n</ul>\n<h4 id=\"10-hashmap的key存储在哪里和value存储在一起吗那么value存储在哪里说具体点湖利软件-天伟业\"><a class=\"anchor\" href=\"#10-hashmap的key存储在哪里和value存储在一起吗那么value存储在哪里说具体点湖利软件-天伟业\">#</a> 10. <mark>HashMap 的 key 存储在哪里？和 value 存储在一起吗？那么 value 存储在哪里？说具体点？</mark>（湖 ** 利软件、天 * 伟业）</h4>\n<p>HashMap 的<font color='red'>key 和 value 都存储在 Node 对象中，其中 Node 是 HashMap 的内部类，实现了 Map.Entry 接口</font>。<font color='red'>Node 对象是一个链表节点或者红黑树节点，它有一个 next 属性指向下一个 Node 对象</font>。</p>\n<p><font color='orange'>HashMap 的底层结构是一个动态数组，数组的每个元素是一个 Node 对象，当多个 Node 对象的 key 的哈希值相同或者映射到同一个数组下标时，就会形成一个链表或者红黑树，通过 Node 对象的 next 属性连接起来</font>。</p>\n<p>所以，<font color='red'>可以说 HashMap 的 key 和 value<strong> 存储在动态数组中的 Node 对象中</strong>，Node 对象可以形成<strong>链表或者红黑树</strong>来解决<u>哈希冲突</u></font>。</p>\n<h4 id=\"11-自定义类型可以作为key么阿\"><a class=\"anchor\" href=\"#11-自定义类型可以作为key么阿\">#</a> 11. <mark>自定义类型可以作为 Key 么？</mark>（阿 *）</h4>\n<p>Java 中<font color='red'>自定义类型可以作为 HashMap 的 Key</font>，但是需要注意一些问题：</p>\n<ul>\n<li>自定义类型<font color='red'>必须重写 <code>hashCode()</code>  和 <code>equals()</code>  方法</font>，以保证相同属性的对象有相同的哈希值和相等性判断，否则会导致 HashMap 无法正确存取元素。</li>\n<li>自定义类型的 hashCode () 和 equals () 方法应该遵循以下原则：\n<ul>\n<li><font color='red'>如果两个对象相等，则两个对象的 hashCode () 必须相等</font>；</li>\n<li><font color='red'>如果两个对象不相等，则两个对象的 hashCode ()<strong> 尽量</strong>不要相等，以<strong>减少哈希冲突的可能性</strong></font>；</li>\n<li>equals () 方法应该满足<font color='red'>自反性、对称性、传递性、一致性</font>，即对于任意非空对象 x、y 和 z，有：\n<ul>\n<li>x.equals (x) 为 true；</li>\n<li>x.equals (y) 为 true 当且仅当 y.equals (x) 为 true；</li>\n<li>如果 x.equals (y) 为 true 且 y.equals (z) 为 true，则 x.equals (z) 也为 true；</li>\n<li>多次调用 x.equals (y) 的结果不会改变，除非 x 或 y 的属性发生变化。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><font color='orange'><strong>自定义类型的属性应该是不可变的</strong>，或者至少在作为 HashMap 的 Key 期间不要改变，否则会导致哈希值和相等性判断发生变化，从而导致 HashMap 无法正确存取元素</font>。</li>\n</ul>\n<h3 id=\"collections\"><a class=\"anchor\" href=\"#collections\">#</a> Collections</h3>\n<h4 id=\"1-集合类的工具类是谁用过工具类哪些方法顺\"><a class=\"anchor\" href=\"#1-集合类的工具类是谁用过工具类哪些方法顺\">#</a> 1. 集合类的工具类是谁？用过工具类哪些方法？（顺 *）</h4>\n<p>Collections 是一个集合工具类，它提供了一系列静态方法，用于对集合类（Collection、List、Set、Map 等）进行操作，例如排序、查找、复制、同步等。</p>\n<p>Collections 类的常用方法有：</p>\n<ul>\n<li><font color='gree'>sort</font>(List list)：按照自然顺序对 list 进行升序排序，list 中的元素必须实现 Comparable 接口</li>\n<li><font color='gree'>sort</font>(List list, Comparator c)：按照定制的顺序对 list 进行排序，c 是一个比较器，用来控制排序逻辑</li>\n<li><font color='gree'>reverse</font>(List list)：反转 list 中的元素顺序</li>\n<li><font color='gree'>shuffle</font>(List list)：随机打乱 list 中的元素顺序</li>\n<li><font color='gree'>swap</font>(List list, int i, int j)：交换 list 中 i 和 j 位置的元素</li>\n<li><font color='gree'>fill</font>(List list, Object obj)：用 obj 替换 list 中的所有元素</li>\n<li><font color='gree'><strong>copy</strong></font>(List <font color='red'>dest</font>, List <font color='red'>src</font>)：将 src 中的所有元素复制到 dest 中，<font color='red'>dest 必须至少和 src 一样长</font></li>\n<li><font color='gree'>max</font>(Collection coll)：根据自然顺序返回 coll 中的最大元素，coll 中的元素必须实现 Comparable 接口</li>\n<li><font color='gree'>max</font>(Collection coll, Comparator c)：根据定制的顺序返回 coll 中的最大元素，c 是一个比较器，用来控制比较逻辑</li>\n<li><font color='gree'>min</font>(Collection coll)：根据自然顺序返回 coll 中的最小元素，coll 中的元素必须实现 Comparable 接口</li>\n<li><font color='gree'>min</font>(Collection coll, Comparator c)：根据定制的顺序返回 coll 中的最小元素，c 是一个比较器，用来控制比较逻辑</li>\n<li><font color='gree'>frequency</font>(Collection c, Object o)：返回 o 在 c 中出现的次数</li>\n<li><font color='gree'>indexOfSubList</font>(List <font color='red'>source</font>, List <font color='red'>target</font>)：返回 target 在 source 中第一次出现的索引，如果不存在则返回 - 1</li>\n<li><font color='gree'>lastIndexOfSubList</font>(List source, List target)：返回 target 在 source 中最后一次出现的索引，如果不存在则返回 - 1</li>\n<li><font color='gree'>replaceAll</font>(List list, Object <font color='red'>oldVal</font>, Object <font color='red'>newVal</font>)：用 newVal 替换 list 中所有等于 oldVal 的元素</li>\n<li><font color='gree'>synchronizedCollection</font>(Collection c)：返回一个<font color='red'>线程安全的</font>Collection，它包装了 c</li>\n<li><font color='gree'>synchronizedList</font>(List list)：返回一个线程安全的 List，它包装了 list</li>\n<li><font color='gree'>synchronizedSet</font>(Set s)：返回一个线程安全的 Set，它包装了 s</li>\n<li><font color='gree'>synchronizedMap</font>(Map m)：返回一个线程安全的 Map，它包装了 m</li>\n</ul>\n<h4 id=\"2-collection-和-collections的区别平金服-软\"><a class=\"anchor\" href=\"#2-collection-和-collections的区别平金服-软\">#</a> 2. <mark>Collection 和 Collections 的区别？</mark>（平 * 金服、* 软）</h4>\n<p>Collection 是一个集合<font color='red'>接口</font>，定义了一些操作集合的方法，有<font color='red'>子接口 List 和 Set</font>。</p>\n<p>Collections 是一个集合<font color='red'>工具类</font>，提供了<font color='red'>一系列静态方法</font>去操作 Collection、List、Set、Map 等集合框架。</p>\n<h4 id=\"3-arraylist-如何实现排序阿\"><a class=\"anchor\" href=\"#3-arraylist-如何实现排序阿\">#</a> 3. <mark>ArrayList 如何实现排序？</mark>（阿 *）</h4>\n<p>ArrayList 是一个实现了 List 接口的动态数组，它可以存储任意类型的对象，也可以对其中的元素进行排序。有以下几种方法可以对 ArrayList 进行排序：</p>\n<ul>\n<li>使用<font color='gree'> <code>Collections.sort(List list)</code> </font>方法，它会按照元素的自然顺序（升序）对 list 进行排序，list 中的元素必须实现 Comparable 接口，或者是基本类型的包装类。</li>\n<li>使用<font color='gree'> <code>Collections.sort(List list, Comparator c)</code> </font>方法，它会按照定制的顺序（由 c 指定）对 list 进行排序，c 是一个比较器，用来控制排序逻辑。</li>\n<li>使用<font color='gree'> <code>List.sort(Comparator c)</code> </font>方法，它会按照定制的顺序（由 c 指定）对 list 进行排序，c 是一个比较器，用来控制排序逻辑。这个方法是在 Java 8 中引入的，默认调用 <code>Arrays.sort(Object[] a, Comparator c)</code>  方法。</li>\n<li>使用<font color='gree'> <code>Arrays.sort(Object[] a)</code> </font>方法，它会按照元素的自然顺序（升序）对数组 a 进行排序，a 中的元素必须实现 Comparable 接口，或者是基本类型的包装类。这个方法需要调用 toArray () 先将 ArrayList 转换为数组。</li>\n<li>使用<font color='gree'> <code>Arrays.sort(Object[] a, Comparator c)</code> </font>方法，它会按照定制的顺序（由 c 指定）对数组 a 进行排序，c 是一个比较器，用来控制排序逻辑。这个方法需要调用 toArray () 先将 ArrayList 转换为数组。</li>\n</ul>\n<p>下面给出一些示例代码：</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token annotation punctuation\">@Test</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">test1</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token comment\">// 创建一个 ArrayList 存储整数</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span></span> list <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayList</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    list<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    list<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    list<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token number\">7</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    list<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token comment\">// 方式一：使用 Collections.sort (List list) 方法按照自然顺序（升序）排序</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token class-name\">Collections</span><span class=\"token punctuation\">.</span><span class=\"token function\">sort</span><span class=\"token punctuation\">(</span>list<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>list<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 输出 [1, 3, 5, 7]</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    <span class=\"token comment\">// 方式二：使用 Collections.sort (List list, Comparator c) 方法按照定制的顺序（降序）排序</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    <span class=\"token class-name\">Collections</span><span class=\"token punctuation\">.</span><span class=\"token function\">sort</span><span class=\"token punctuation\">(</span>list<span class=\"token punctuation\">,</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Comparator</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>        <span class=\"token annotation punctuation\">@Override</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>        <span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">compare</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Integer</span> o1<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Integer</span> o2<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>            <span class=\"token keyword\">return</span> o2 <span class=\"token operator\">-</span> o1<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 降序</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>    <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>list<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 输出 [7, 5, 3, 1]</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>    <span class=\"token comment\">// 方式三：使用 List.sort (Comparator c) 方法按照定制的顺序（降序）排序</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>    list<span class=\"token punctuation\">.</span><span class=\"token function\">sort</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Comparator</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>        <span class=\"token annotation punctuation\">@Override</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>        <span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">compare</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Integer</span> o1<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Integer</span> o2<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>            <span class=\"token keyword\">return</span> o2 <span class=\"token operator\">-</span> o1<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 降序</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>    <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>list<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 输出 [7, 5, 3, 1]</span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre></pre></td></tr><tr><td data-num=\"32\"></td><td><pre>    <span class=\"token comment\">// 方式四：使用 Arrays.sort (Object [] a) 方法按照自然顺序（升序）排序</span></pre></td></tr><tr><td data-num=\"33\"></td><td><pre>    <span class=\"token class-name\">Integer</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> array1 <span class=\"token operator\">=</span> list<span class=\"token punctuation\">.</span><span class=\"token function\">toArray</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Integer</span><span class=\"token punctuation\">[</span>list<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 将 ArrayList 转换为数组</span></pre></td></tr><tr><td data-num=\"34\"></td><td><pre>    <span class=\"token class-name\">Arrays</span><span class=\"token punctuation\">.</span><span class=\"token function\">sort</span><span class=\"token punctuation\">(</span>array1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"35\"></td><td><pre>    <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Arrays</span><span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span>array1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 输出 [1, 3, 5, 7]</span></pre></td></tr><tr><td data-num=\"36\"></td><td><pre></pre></td></tr><tr><td data-num=\"37\"></td><td><pre>    <span class=\"token comment\">// 方式五：使用 Arrays.sort (Object [] a, Comparator c) 方法按照定制的顺序（降序）排序</span></pre></td></tr><tr><td data-num=\"38\"></td><td><pre>    <span class=\"token class-name\">Integer</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> array2 <span class=\"token operator\">=</span> list<span class=\"token punctuation\">.</span><span class=\"token function\">toArray</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Integer</span><span class=\"token punctuation\">[</span>list<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 将 ArrayList 转换为数组</span></pre></td></tr><tr><td data-num=\"39\"></td><td><pre>    <span class=\"token class-name\">Arrays</span><span class=\"token punctuation\">.</span><span class=\"token function\">sort</span><span class=\"token punctuation\">(</span>array2<span class=\"token punctuation\">,</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Comparator</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"40\"></td><td><pre>        <span class=\"token annotation punctuation\">@Override</span></pre></td></tr><tr><td data-num=\"41\"></td><td><pre>        <span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">compare</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Integer</span> o1<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Integer</span> o2<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"42\"></td><td><pre>            <span class=\"token keyword\">return</span> o2 <span class=\"token operator\">-</span> o1<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 降序</span></pre></td></tr><tr><td data-num=\"43\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"44\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"45\"></td><td><pre>    <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Arrays</span><span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span>array2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 输出 [7, 5, 3, 1]</span></pre></td></tr><tr><td data-num=\"46\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h4 id=\"4-hashmap是否线程安全怎样解决hashmap的线程不安全中卫星\"><a class=\"anchor\" href=\"#4-hashmap是否线程安全怎样解决hashmap的线程不安全中卫星\">#</a> 4. HashMap 是否线程安全，怎样解决 HashMap 的线程不安全（中 * 卫星）</h4>\n<pre><code>类似问题：\n&gt; 怎么实现HashMap线程安全？（*团、*东、顺*）\n</code></pre>\n<p>HashMap 不是线程安全的。如果您希望在多线程环境中使用线程安全的 HashMap，可以使用以下方法之一：</p>\n<ol>\n<li>使用<font color='gree'>Hashtable</font>，它通过对整个表上锁来实现线程安全，但效率较低。</li>\n<li>使用<font color='gree'> <code>Collections.synchronizedMap(Map m)</code> </font>包装 HashMap。这样可以返回一个由指定映射支持的同步（线程安全）映射。</li>\n<li>使用<font color='gree'>ConcurrentHashMap</font>，它是 Java 5 之后引入的一个线程安全的 HashMap。它将哈希表分为 16 个桶（默认值），常用操作（如 get、put、remove）只锁定当前需要用到的桶。</li>\n</ol>\n",
            "tags": [
                "Java",
                "Java基础",
                "Java基础-真题"
            ]
        },
        {
            "id": "http://example.com/java/java-se/java-excise/%E7%AC%AC11%E7%AB%A0%EF%BC%9A%E9%9A%8F%E5%A0%82%E5%A4%8D%E4%B9%A0%E4%B8%8E%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%A2%98%EF%BC%88%E5%B8%B8%E7%94%A8%E7%B1%BB%E4%B8%8E%E5%9F%BA%E7%A1%80API%EF%BC%89/",
            "url": "http://example.com/java/java-se/java-excise/%E7%AC%AC11%E7%AB%A0%EF%BC%9A%E9%9A%8F%E5%A0%82%E5%A4%8D%E4%B9%A0%E4%B8%8E%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%A2%98%EF%BC%88%E5%B8%B8%E7%94%A8%E7%B1%BB%E4%B8%8E%E5%9F%BA%E7%A1%80API%EF%BC%89/",
            "title": "宋红康_第11章：常用类与基础API",
            "date_published": "2023-11-12T03:06:50.149Z",
            "content_html": "<h1 id=\"第11章随堂复习与企业真题常用类与基础api\"><a class=\"anchor\" href=\"#第11章随堂复习与企业真题常用类与基础api\">#</a> 第 11 章：随堂复习与企业真题（常用类与基础 API）</h1>\n<hr />\n<h2 id=\"一-随堂复习\"><a class=\"anchor\" href=\"#一-随堂复习\">#</a> 一、随堂复习</h2>\n<h3 id=\"1-font-colorcornflowerbluestring类font\"><a class=\"anchor\" href=\"#1-font-colorcornflowerbluestring类font\">#</a> 1. <font color='cornflowerblue'><mark>String 类</mark></font></h3>\n<ul>\n<li>\n<p>String 的声明：<font color='red'>final 修饰</font>（不能继承）、<font color='red'>实现了 Comparable 接口</font>（可以比较大小）</p>\n</li>\n<li>\n<p>String 的<font color='orange'>不可变性</font></p>\n</li>\n<li>\n<p>String 的<font color='gree'>两种定义方式</font>：① <font color='red'>字面量的定义</font>方式  <code>String s = &quot;hello&quot;</code>  ② <font color='red'>new</font> 的方式： <code>String s = new String(&quot;hello&quot;);</code></p>\n<ul>\n<li>String 的内存解析：<font color='red'>字符串常量池</font>、<font color='red'>堆内存</font>的使用</li>\n<li><code>String s = new String(&quot;hello&quot;);</code>  在内存中创建的对象的个数：一个字符串常量对象，一个堆空间对象。</li>\n</ul>\n</li>\n<li>\n<p>String 的<font color='gree'>连接操作： <code>+</code> </font></p>\n<p><mark><strong><font color='orange'>结论</font>：</strong></mark></p>\n<ul>\n<li>\n<p>常量 + 常量：结果存储在<font color='red'><strong>常量池</strong></font>中，返回此字面量的地址。且常量池中不会存在相同内容的常量。</p>\n<blockquote>\n<p>这里的常量有两种情况：</p>\n<ul>\n<li>字面量</li>\n<li>final 修饰的常量</li>\n</ul>\n</blockquote>\n</li>\n<li>\n<p>常量 + <em>变量</em> 或 <em>变量</em> + <em>变量</em>：结果 new 在<font color='red'><strong>堆</strong></font>中，返回堆空间中此字符串对象的地址。</p>\n<blockquote>\n<p>如果变量声明为 final，那么就变成常量了！对应的情况就是 “常量 + 常量”</p>\n</blockquote>\n</li>\n<li>\n<p>拼接后调用 <code>intern()</code> ：返回<font color='red'><strong>常量池</strong></font>中字面量的地址。</p>\n</li>\n<li>\n<p><code>concat()</code>  拼接：哪怕是两个常量对象拼接，结果也是 new 在<font color='red'><strong>堆</strong></font>空间中。</p>\n</li>\n</ul>\n</li>\n<li>\n<p>熟悉 String 的<font color='gree'>构造器</font>、与其他结构之间的<font color='gree'>转换</font>、<font color='gree'>常用方法</font></p>\n<ul>\n<li>编码和解码\n<ul>\n<li><font color='red'>编码</font>：字符、字符串 --&gt; 字节、字节数组。对应着编码集</li>\n<li><font color='red'>解码</font>：字节、字节数组 --&gt; 字符、字符串。对应着解码集</li>\n<li>规则：解码集必须使用当初编码时使用的编码集。只要不一致，就可能出现乱码！</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>String 相关的<font color='gree'>算法问题</font>。</p>\n<ul>\n<li>trim</li>\n<li>字符串反转</li>\n<li>子串出现次数</li>\n<li>最大相同子串</li>\n<li>...</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-font-colorcornflowerbluestringbuffer类font-font-colorcornflowerbluestringbuilder类font\"><a class=\"anchor\" href=\"#2-font-colorcornflowerbluestringbuffer类font-font-colorcornflowerbluestringbuilder类font\">#</a> 2. <font color='cornflowerblue'>StringBuffer 类</font>、<font color='cornflowerblue'>StringBuilder 类</font></h3>\n<ul>\n<li>\n<p>[面试题] String、StringBuffer、StringBuilder 的区别</p>\n<ul>\n<li>\n<p><font color='cornflowerblue'><strong>String</strong></font></p>\n<ul>\n<li>\n<p><font color='red'>不可变</font>的字符序列</p>\n<blockquote>\n<p>private <strong>final</strong> char value[];</p>\n</blockquote>\n</li>\n<li>\n<p><font color='red'>效率最低</font></p>\n</li>\n<li>\n<p>底层使用<font color='red'>char[]</font>数组存储 (JDK8.0 中)，底层使用 byte [] 数组存储（JDK9 及之后）</p>\n</li>\n</ul>\n</li>\n<li>\n<p><strong><font color='cornflowerblue'>StringBuffer</font></strong></p>\n<ul>\n<li>\n<p><font color='red'>可变的</font>字符序列</p>\n<blockquote>\n<p>char[] value;</p>\n</blockquote>\n</li>\n<li>\n<p>JDK1.0 引入</p>\n</li>\n<li>\n<p><font color='red'>线程安全</font>（方法有 synchronized 修饰），因此<font color='red'>效率比 StringBuilder 低</font></p>\n</li>\n<li>\n<p>底层使用<font color='red'>char[]</font>数组存储 (JDK8.0 中)，底层使用 byte [] 数组存储（JDK9 及之后）</p>\n</li>\n</ul>\n</li>\n<li>\n<p><strong><font color='cornflowerblue'>StringBuilder</font></strong>：</p>\n<ul>\n<li>\n<p><font color='red'>可变的</font>字符序列</p>\n<blockquote>\n<p>char[] value;</p>\n</blockquote>\n</li>\n<li>\n<p>jdk1.5 引入</p>\n</li>\n<li>\n<p><font color='red'>线程不安全</font>的，<font color='red'>效率高</font></p>\n</li>\n<li>\n<p>底层使用<font color='red'>char[]</font>数组存储 (JDK8.0 中)，底层使用 byte [] 数组存储（JDK9 及之后）</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>知道什么场景下使用 StringBuffer、StringBuilder</p>\n<ul>\n<li>如果开发中，需要对字符串进行频繁的增、删、改操作，建议使用 StringBuffer、StringBuilder</li>\n<li>如果开发中，不涉及多线程，建议使用 StringBuilder，因为效率更高</li>\n<li>如果开发中，可以大体确定要操作的字符个数，建议使用带有 int capacity 参数的构造器，可以避免多次扩容，性能更优</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"3-jdk8之前的日期-时间api\"><a class=\"anchor\" href=\"#3-jdk8之前的日期-时间api\">#</a> 3. jdk8 之前的日期、时间 API</h3>\n<ul>\n<li>System.currentTimeMillis()</li>\n<li>两个 Date 的使用</li>\n<li>SimpleDateFormat 用于格式化、解析</li>\n<li>Calendar 日历类的使用</li>\n</ul>\n<h3 id=\"4-jdk8中新的日期-时间apijavatime包\"><a class=\"anchor\" href=\"#4-jdk8中新的日期-时间apijavatime包\">#</a> 4. jdk8 中新的日期、时间 API——<mark>java.time 包</mark></h3>\n<ul>\n<li>LocalDate、LocalTime、LocalDateTime --&gt; 类似于 Calendar</li>\n<li>Instant  --&gt; 类似于 Date</li>\n<li>DateTimeFormatter ---&gt; 类似于 SimpleDateFormat</li>\n</ul>\n<h3 id=\"5-比较器重点\"><a class=\"anchor\" href=\"#5-比较器重点\">#</a> 5. <mark>比较器 (重点)</mark></h3>\n<ul>\n<li>自然排序 Comparable 接口\n<ul>\n<li>compareTo(Object obj)</li>\n</ul>\n</li>\n<li>定制排序 Comparator 接口\n<ul>\n<li>compare(Object obj1,Object obj2)</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"6-其它api\"><a class=\"anchor\" href=\"#6-其它api\">#</a> 6. 其它 API</h3>\n<p>了解</p>\n<h2 id=\"二-企业真题\"><a class=\"anchor\" href=\"#二-企业真题\">#</a> 二、企业真题</h2>\n<h3 id=\"21-string\"><a class=\"anchor\" href=\"#21-string\">#</a> 2.1 String</h3>\n<h4 id=\"1-以下两种方式创建的string对象有什么不同团\"><a class=\"anchor\" href=\"#1-以下两种方式创建的string对象有什么不同团\">#</a> 1. 以下两种方式创建的 String 对象有什么不同？（* 团）</h4>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token class-name\">String</span> str <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"test\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token class-name\">String</span> str <span class=\"token operator\">=</span> <span class=\"token string\">\"test\"</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>new 方式创建的 String 对象存储在<font color='red'>堆空间</font>中，此外，如果 “test” 在<font color='red'>字符串常量池</font>中没有定义，还需要定义一个字符串常量对象。</p>\n<p>字面量创建的对象存储在<font color='red'>字符串常量池</font>中。</p>\n<h4 id=\"2-string-s-new-stringxyz创建了几个string-object-新陆\"><a class=\"anchor\" href=\"#2-string-s-new-stringxyz创建了几个string-object-新陆\">#</a> 2. String s = new String (&quot;xyz&quot;); 创建了几个 String Object? （新 * 陆）</h4>\n<p>两个</p>\n<h4 id=\"3-string-aabc-string-babc-问ab网邮箱\"><a class=\"anchor\" href=\"#3-string-aabc-string-babc-问ab网邮箱\">#</a> 3. String a=&quot;abc&quot; String b=&quot;a&quot;+&quot;bc&quot; 问 a==b?（网 * 邮箱）</h4>\n<p>是！都在字符串常量池中，且常量池中不会存在相同内容的常量。</p>\n<h4 id=\"4-string-中-怎样实现阿\"><a class=\"anchor\" href=\"#4-string-中-怎样实现阿\">#</a> <mark>4. String 中 “+” 怎样实现？（阿 *）</mark></h4>\n<p>常量 + 常量 ：首先，在字符串常量池中查找有无拼接结果的字符串常量，如果有则不用创建；否则，在字符串常量池中新建一个字符串常量。</p>\n<p>变量 + 常量 、变量 + 变量：<font color='orange'>创建一个 StringBuilder 的实例，通过 append () 添加字符串，最后调用 toString () 返回一个字符串。（toString () 内部 <strong>new</strong> 一个 String 的实例）</font></p>\n<blockquote>\n<p>Java 中，String 的 “+” 操作是用来连接两个或多个字符串的，例如 &quot;Hello&quot; + &quot;World&quot; 就会得到 &quot;HelloWorld&quot;。</p>\n<p><font color='orange'>如果 &quot;+&quot; 操作符左右有变量参与</font>，那么这个操作在编译时会被转换成 StringBuilder 的 append 方法，<font color='orange'>例如 &quot;Hello&quot; + &quot;World&quot; 会被转换成 <code>new StringBuilder().append(&quot;Hello&quot;).append(&quot;World&quot;).toString()</code> ，在 toString () 方法中会 new 一个 String 实例</font>！这样做的目的是为了提高字符串连接的效率，因为 String 是不可变的，每次 “+” 操作都会创建一个新的 String 对象，而 StringBuilder 是可变的，可以在原有的基础上追加字符串。</p>\n</blockquote>\n<h4 id=\"5-java中string是不是final的凡科技\"><a class=\"anchor\" href=\"#5-java中string是不是final的凡科技\">#</a> 5. Java 中 String 是不是 final 的？（凡 * 科技）</h4>\n<pre><code>类似问题：\n&gt; String被哪些类继承？（网*邮箱）\n&gt; 是否可以继承String类?（湖南*利软件）\n&gt; String 是否可以继承?（阿*）\n</code></pre>\n<p>是，因此不能被继承。</p>\n<h4 id=\"6-string为啥不可变在内存中的具体形态阿\"><a class=\"anchor\" href=\"#6-string为啥不可变在内存中的具体形态阿\">#</a> <mark>6. String 为啥不可变，在内存中的具体形态？（阿 *）</mark></h4>\n<p>因为其底层实现的 char 型数组 value 用了 final 修饰，这是一种<font color='red'>享元设计模式</font>。在开发中字符串的使用极其频繁，所以共用字符串信息，以便节省空间。</p>\n<blockquote>\n<p>Java 中的 String 为什么是不可变的，有以下几个原因：</p>\n<ul>\n<li><strong>安全性</strong>：<font color='gree'>String 类是被 final 修饰的，不能被继承或修改</font>。这样可以<font color='red'>保证 String 在传递过程中不会被篡改</font>，例如作为文件路径、网络地址、数据库连接等敏感信息。</li>\n<li><strong>效率性</strong>：String 类的<font color='gree'>底层实现 char 型数组是被 private final 修饰的，只能在构造函数中赋值一次，此后无法修改</font>。这样可以<font color='red'>避免每次修改都要创建一个新的 String 对象，节省了内存空间和时间开销</font>。同时，String 的不可变性也使得它<font color='red'>可以被缓存和共享</font>，例如字符串常量池、字符串字面量、字符串拼接等。</li>\n<li><strong>一致性</strong>：String 是被 private final 修饰的，它的值在创建后就不会改变。这样可以<font color='red'>保证 String 在多线程环境下不会出现数据不一致的问题，无需额外的同步机制</font>。</li>\n</ul>\n</blockquote>\n<p>String：提供 **<font color='red'>字符串常量池</font>**。</p>\n<blockquote>\n<p>在 jdk6 及之前，字符串常量池在<font color='red'>方法区</font></p>\n<p>之后，在<font color='red'>堆空间</font>中</p>\n</blockquote>\n<h4 id=\"7-string-可以在-switch中使用吗上海睿\"><a class=\"anchor\" href=\"#7-string-可以在-switch中使用吗上海睿\">#</a> <mark>7. String 可以在 switch 中使用吗？(上海 * 睿)</mark></h4>\n<p>从<font color='red'>JDK 7</font>开始，switch 支持字符串 String 类型了 ¹³。但是要注意以下几点：</p>\n<ul>\n<li>\n<p><font color='red'>switch 表达式中的字符串必须是一个<strong> String 对象</strong></font>，不能是 null³⁶。</p>\n</li>\n<li>\n<p><font color='red'>case 标签必须是<strong>字符串常量或字面量</strong></font>，不能是变量或表达式 ¹³。</p>\n<blockquote>\n<p>字符串常量、字面量的区别，主要是在于它们的存储位置和创建方式不同：</p>\n<ul>\n<li>字符串常量（String Constant）是指在程序中<font color='red'>直接用双引号括起来的字符串</font>，例如 &quot;Hello&quot;。这些字符串常量会被编译器放在一个特殊的内存区域，叫做<font color='red'>字符串常量池</font>（String Constant Pool），它是 Java 堆（Heap）的一部分。字符串常量池可以实现字符串的共享，避免重复创建相同的字符串对象⁹⁷。</li>\n<li>字符串字面量（String Literal）是指在程序中<font color='red'>用 new 关键字创建的字符串对象</font>，例如 new String (&quot;Hello&quot;)。这些字符串字面量会被分配在 Java<font color='red'>堆</font>中的普通区域，每次创建都会产生一个新的字符串对象⁹⁷。</li>\n</ul>\n<p>下面是一个示例代码，可以看出字符串常量和字面量的区别：</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token class-name\">String</span> s1 <span class=\"token operator\">=</span> <span class=\"token string\">\"Hello\"</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 字符串常量</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token class-name\">String</span> s2 <span class=\"token operator\">=</span> <span class=\"token string\">\"Hello\"</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 字符串常量</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token class-name\">String</span> s3 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Hello\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 字符串字面量</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token class-name\">String</span> s4 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Hello\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 字符串字面量</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>s1 <span class=\"token operator\">==</span> s2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//true，s1 和 s2 指向同一个字符串常量池中的对象</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>s3 <span class=\"token operator\">==</span> s4<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//false，s3 和 s4 指向不同的字符串字面量对象</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>s1 <span class=\"token operator\">==</span> s3<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//false，s1 和 s3 指向不同的内存区域</span></pre></td></tr></table></figure></blockquote>\n</li>\n<li>\n<p>switch 语句会根据字符串的 hash 值和 equals 方法来判断匹配的 case²⁶。</p>\n</li>\n</ul>\n<p>下面是一个使用 String 类型的 switch 语句的代码示例：</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token class-name\">String</span> fruit <span class=\"token operator\">=</span> <span class=\"token string\">\"apple\"</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//switch 表达式</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">switch</span> <span class=\"token punctuation\">(</span>fruit<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token comment\">//switch 语句</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">case</span> <span class=\"token string\">\"apple\"</span><span class=\"token operator\">:</span> <span class=\"token comment\">//case 标签</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"It is an apple.\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>        <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token keyword\">case</span> <span class=\"token string\">\"banana\"</span><span class=\"token operator\">:</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"It is a banana.\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>        <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token keyword\">case</span> <span class=\"token string\">\"orange\"</span><span class=\"token operator\">:</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"It is an orange.\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>        <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    <span class=\"token keyword\">default</span><span class=\"token operator\">:</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"It is not a fruit.\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h4 id=\"8-string中有哪些方法列举几个闪购\"><a class=\"anchor\" href=\"#8-string中有哪些方法列举几个闪购\">#</a> 8. String 中有哪些方法？列举几个（闪 * 购）</h4>\n<p>角度一：String 与其他结构间的转换</p>\n<ul>\n<li>基本数据类型 / 包装类 --&gt; String\n<ul>\n<li>public <font color='orange'>static</font> String <font color='gree'>valueOf</font>(基本数据类型 / 包装类 xxx)</li>\n</ul>\n</li>\n<li>String --&gt; char[] / byte[]\n<ul>\n<li>public char[] <font color='gree'>toCharArray()</font></li>\n<li>public byte[] <font color='gree'>getBytes()</font></li>\n</ul>\n</li>\n</ul>\n<p>角度二：常用方法...</p>\n<ul>\n<li>isEmpty()；<font color='red'>length()</font>；concat(String str)；</li>\n<li>equals(Object obj)；equalsIgnoreCase(String anotherString)；</li>\n<li><font color='red'>compareTo</font>(String anotherString)；compareToIgnoreCase(String other)；</li>\n<li>toLowerCase()；toUpperCase()；</li>\n<li><font color='red'>trim</font>()；<font color='red'>intern</font>()；</li>\n</ul>\n<p>角度三：查找</p>\n<ul>\n<li><font color='red'>contains</font>(String str)</li>\n<li>indexOf(String str)； indexOf(String str, int fromIndex)；</li>\n<li><font color='red'>lastIndexOf</font>(String str)；lastIndexOf(String str, int fromIndex)；</li>\n</ul>\n<p>角度四：字符串截取</p>\n<ul>\n<li>substring(int beginIndex)；</li>\n<li>substring(int beginIndex, int endIndex)；</li>\n</ul>\n<p>角度五：和 char/char [] 相关</p>\n<ul>\n<li><font color='red'>charAt</font>(int index)</li>\n<li><font color='red'>toCharArray</font>()</li>\n</ul>\n<p>角度六：开头、结尾</p>\n<ul>\n<li><font color='red'>startsWith</font>(String prefix)</li>\n<li>startsWith(String prefix, int offset)</li>\n<li><font color='red'>endsWith</font>(String postfix)</li>\n</ul>\n<p>角度七：替换</p>\n<ul>\n<li><font color='red'>replace</font>(char oldChar, char newChar)</li>\n<li><font color='red'>replaceAll</font>(String regex, String replacement)</li>\n<li><font color='red'>replaceFirst</font>(String regex, String replacement)</li>\n</ul>\n<h4 id=\"9-substring到底做了什么银数据\"><a class=\"anchor\" href=\"#9-substring到底做了什么银数据\">#</a> <mark>9. substring () 到底做了什么？(银 * 数据)</mark></h4>\n<p>substring () 方法的<font color='orange'>底层实现是 <code>new String(value, beginIndex, subLen)</code> ，即创建一个新的字符串对象， <code>value</code>  指向 s 的字符数组，起始索引为 <code>beginIndex</code> ，子串长度为 <code>subLen</code> </font>。</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token annotation punctuation\">@Test</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">test5</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token class-name\">String</span> s <span class=\"token operator\">=</span> <span class=\"token string\">\"abcdefg\"</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 创建一个字符串对象</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token class-name\">String</span> s1 <span class=\"token operator\">=</span> s<span class=\"token punctuation\">.</span><span class=\"token function\">substring</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>s1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// cde</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token comment\">// 底层实现相当于：</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token comment\">// String s1 = new String (s.value, 2, 3); 创建一个新的字符串对象，value 指向 s 的字符数组，起始索引为 2，子串长度为 3</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>这样做的好处是<font color='red'>可以实现字符串的快速共享，节省内存空间</font>，提高效率⁴。但是也有一些缺点，比如：</p>\n<ul>\n<li>如果原字符串很大，而截取的子串很小，那么会造成<font color='red'>内存浪费</font>，因为子串对象仍然持有原字符串的字符数组的引用⁴。</li>\n<li>如果对原字符串或者子串对象进行修改（比如使用 replace () 方法），那么会导致新的字符数组的创建，<font color='red'>增加了时间和空间的开销</font>⁴。</li>\n</ul>\n<h3 id=\"22-string-stringbuffer-stringbuilder\"><a class=\"anchor\" href=\"#22-string-stringbuffer-stringbuilder\">#</a> 2.2 String、StringBuffer、StringBuilder</h3>\n<h4 id=\"1-java中操作字符串有哪些类他们之间有什么区别-南电网\"><a class=\"anchor\" href=\"#1-java中操作字符串有哪些类他们之间有什么区别-南电网\">#</a> <mark>1. Java 中操作字符串有哪些类？他们之间有什么区别。（南 * 电网）</mark></h4>\n<pre><code>类似问题：\n&gt; String 和 StringBuffer区别？(亿*国际、天*隆、*团)\n&gt; StringBuilder和StrignBuffer的区别？（平*金服）\n&gt; StringBuilder和StringBuffer的区别以及实现？（*为）\n</code></pre>\n<pre><code>&gt; String:不可变的字符序列;底层使用char[] （jdk8及之前），底层使用byte[] （jdk9及之后）\n&gt; StringBuffer:可变的字符序列;JDK1.0声明，线程安全的，效率低;底层使用char[] （jdk8及之前），底层使用byte[] （jdk9及之后）\n&gt; StringBuilder:可变的字符序列;JDK5.0声明，线程不安全的,效率高;底层使用char[] （jdk8及之前），底层使用byte[] （jdk9及之后）\n</code></pre>\n<ul>\n<li>\n<p><font color='cornflowerblue'><strong>String</strong></font></p>\n<ul>\n<li>\n<p><font color='red'>不可变</font>的字符序列</p>\n<blockquote>\n<p>private <strong>final</strong> char value[];</p>\n</blockquote>\n</li>\n<li>\n<p><font color='red'>效率最低</font></p>\n</li>\n<li>\n<p>底层使用<font color='red'>char[]</font>数组存储 (JDK8.0 中)，底层使用 byte [] 数组存储（JDK9 及之后）</p>\n</li>\n</ul>\n</li>\n<li>\n<p><strong><font color='cornflowerblue'>StringBuffer</font></strong></p>\n<ul>\n<li>\n<p><font color='red'>可变的</font>字符序列</p>\n<blockquote>\n<p>char[] value;</p>\n</blockquote>\n</li>\n<li>\n<p>JDK1.0 引入</p>\n</li>\n<li>\n<p><font color='red'>线程安全</font>（方法有 synchronized 修饰），因此<font color='red'>效率比 StringBuilder 低</font></p>\n</li>\n<li>\n<p>底层使用<font color='red'>char[]</font>数组存储 (JDK8.0 中)，底层使用 byte [] 数组存储（JDK9 及之后）</p>\n</li>\n</ul>\n</li>\n<li>\n<p><strong><font color='cornflowerblue'>StringBuilder</font></strong>：</p>\n<ul>\n<li>\n<p><font color='red'>可变的</font>字符序列</p>\n<blockquote>\n<p>char[] value;</p>\n</blockquote>\n</li>\n<li>\n<p>jdk1.5 引入</p>\n</li>\n<li>\n<p><font color='red'>线程不安全</font>的，<font color='red'>效率高</font></p>\n</li>\n<li>\n<p>底层使用<font color='red'>char[]</font>数组存储 (JDK8.0 中)，底层使用 byte [] 数组存储（JDK9 及之后）</p>\n</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<h4 id=\"stringbuffer-stringbuilder的可变性分析\"><a class=\"anchor\" href=\"#stringbuffer-stringbuilder的可变性分析\">#</a> StringBuffer、StringBuilder 的可变性分析</h4>\n<ul>\n<li>\n<p>String</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token class-name\">String</span> s1 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// final char[] value = new char[0];</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token class-name\">String</span> s2 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"abc\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// final char[] value = new char[]&#123;'a','b','c'&#125;;</span></pre></td></tr></table></figure></li>\n<li>\n<p>StringBuilder</p>\n<ul>\n<li>内部属性\n<ul>\n<li>char [] value：存储字符序列</li>\n<li>int count：实际存储的字符个数</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token class-name\">StringBuilder</span> sBuilder1 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">StringBuilder</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// char[] value = new char[16];</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token class-name\">StringBuilder</span> sBuilder2 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">StringBuilder</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"abc\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// char[] value = new char[16 + \"abc\".length()];</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>sBuilder1<span class=\"token punctuation\">.</span><span class=\"token function\">append</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"ac\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// value[0]='a'; value[1]='c';</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>sBuilder1<span class=\"token punctuation\">.</span><span class=\"token function\">append</span><span class=\"token punctuation\">(</span><span class=\"token char\">'b'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// value[2]='b';</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token comment\">// 不断添加... 一旦 count 超过 value.length ()，就需要扩容（扩容为原来的 2 倍 + 2），</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token comment\">// 然后将原来的 value 数组复制到新的 value 数组中。</span></pre></td></tr></table></figure></li>\n</ul>\n<h4 id=\"开发启示\"><a class=\"anchor\" href=\"#开发启示\">#</a> 开发启示</h4>\n<ul>\n<li>如果开发中，需要对字符串进行频繁的增、删、改操作，建议使用 StringBuffer、StringBuilder</li>\n<li>如果开发中，不涉及多线程，建议使用 StringBuilder，因为效率更高</li>\n<li>如果开发中，可以大体确定要操作的字符个数，建议使用带有 int capacity 参数的构造器，可以避免多次扩容，性能更优</li>\n</ul>\n</blockquote>\n<h4 id=\"2-string的线程安全问题闪购\"><a class=\"anchor\" href=\"#2-string的线程安全问题闪购\">#</a> <mark>2. String 的线程安全问题（闪 * 购）</mark></h4>\n<blockquote>\n<p>String 类是 Java 中表示字符串的一个类，它有以下特点⁴：</p>\n<ul>\n<li>String 类被 final 修饰，是一个<font color='red'>不可变的类</font>，也就是说一旦创建了一个 String 对象，它的内容就不能被修改 ²³⁵。</li>\n<li>String 类重写了 equals () 和 hashCode () 方法，使得<font color='red'>两个内容相同的 String 对象可以被认为是相等的</font>，并且具有相同的哈希值⁵。</li>\n<li>String 类实现了 Serializable 接口，表示它可以被<font color='red'>序列化和反序列化</font>⁵。</li>\n<li>String 类实现了 Comparable 接口，表示它可以<font color='red'>按照字典顺序进行比较</font>⁵。</li>\n</ul>\n</blockquote>\n<p><font color='orange'>由于<font color='cornflowerblue'><strong>String</strong></font>是不可变的，所以它是线程安全的</font>。也就是说<font color='red'>多个线程可以同时访问同一个 String 对象而不会产生冲突</font>³。但是这也意味着<font color='red'>每次对 String 对象进行修改（比如拼接、替换、截取等操作）都会产生一个新的 String 对象，这会增加<strong>内存开销</strong>和<strong>垃圾回收</strong>的压力</font>³⁴。</p>\n<p>为了解决这个问题，Java 提供了两个类：<strong><font color='cornflowerblue'>StringBuffer</font><strong>和</strong><font color='cornflowerblue'>StringBuilder</font></strong>，它们都<font color='red'>继承自 AbstractStringBuilder 类</font>，可以实现<font color='red'><strong>字符串的可变性</strong></font>和<font color='red'><strong>动态扩容</strong></font>¹。它们的区别在于：</p>\n<ul>\n<li>StringBuffer 是线程安全的，它的方法都使用了 synchronized 关键字进行同步，保证了多线程环境下的数据一致性 ¹。</li>\n<li>StringBuilder 是非线程安全的，它的方法没有使用 synchronized 关键字进行同步，所以它的性能比 StringBuffer 更高，但是在多线程环境下可能会出现数据不一致的问题 ¹。</li>\n</ul>\n<p>因此，在 Java 中使用字符串时，需要根据具体的场景和需求来选择合适的类。一般来说：</p>\n<ul>\n<li>如果字符串内容不需要改变，或者只有少量的改变操作，可以使用 String 类⁴。</li>\n<li>如果字符串内容需要频繁地改变，并且在多线程环境下运行，可以使用 StringBuffer 类 ¹。</li>\n<li>如果字符串内容需要频繁地改变，并且在单线程环境下运行，或者对线程安全没有要求，可以使用 StringBuilder 类 ¹。</li>\n</ul>\n<h4 id=\"3-stringbuilder和stringbuffer的线程安全问题润软件\"><a class=\"anchor\" href=\"#3-stringbuilder和stringbuffer的线程安全问题润软件\">#</a> 3. StringBuilder 和 StringBuffer 的线程安全问题（润 * 软件）</h4>\n<p>见上一题。</p>\n<h3 id=\"23-comparator与comparable\"><a class=\"anchor\" href=\"#23-comparator与comparable\">#</a> 2.3 Comparator 与 Comparable</h3>\n<h4 id=\"1-简单说说-comparable-和-comparator-的区别和场景软力\"><a class=\"anchor\" href=\"#1-简单说说-comparable-和-comparator-的区别和场景软力\">#</a> <mark>1. 简单说说 Comparable 和 Comparator 的区别和场景？（软 ** 力）</mark></h4>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">自然排序：Comparable 接口</th>\n<th style=\"text-align:center\">定制排序：Comparator 接口</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">内部比较器</td>\n<td style=\"text-align:center\">外部比较器</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">单一的、唯一的</td>\n<td style=\"text-align:center\">灵活的、多样的</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">一劳永逸的</td>\n<td style=\"text-align:center\">临时的</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">重写 <code>compareTo(Object obj)</code>  抽象方法</td>\n<td style=\"text-align:center\">重写 <code>compare(Object obj1,Object obj2)</code>  抽象方法</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">对具体类的声明、内部进行修改</td>\n<td style=\"text-align:center\">将实现类的实例作为参数传递给 sort () 即可</td>\n</tr>\n</tbody>\n</table>\n<p>Comparable 和 Comparator 都是 Java 中用来实现对象比较和排序的接口，它们的区别和场景如下 ²³⁴⁵：</p>\n<ul>\n<li>Comparable 是一个<font color='red'>内部比较器</font>，它定义在要比较的类中，让类<font color='red'>实现 Comparable 接口并重写 compareTo 方法</font>，该方法返回一个整数，表示当前对象和另一个对象的大小关系。如果要让一个类的对象可以按照<font color='red'>自然顺序</font>进行排序，就需要实现 Comparable 接口。</li>\n<li>Comparator 是一个<font color='red'>外部比较器</font>，它定义在要比较的类之外，让一个单独的类<font color='red'>实现 Comparator 接口并重写 compare 方法</font>，该方法也返回一个整数，表示两个对象的大小关系。如果要让一个类的对象可以<font color='red'>按照不同的规则进行排序</font>，就需要使用 Comparator 接口。</li>\n<li>Comparable 和 Comparator 都可以用来对数组或集合中的元素进行排序，但是<font color='red'>Comparable 只能提供一种排序规则，而 Comparator 可以提供多种排序规则</font>。如果要对数组或集合中的元素进行排序，可以使用 Arrays.sort 或 Collections.sort 方法，并传入相应的比较器。</li>\n<li>Comparable 和 Comparator 都可以与 lambda 表达式结合使用，简化代码的编写。例如，可以使用 (a,b)-&gt;a.getName ().compareTo (b.getName ()) 来创建一个按照名称排序的 Comparator 对象。</li>\n</ul>\n<h4 id=\"2-comparable-接口和-comparator-接口实现比较阿\"><a class=\"anchor\" href=\"#2-comparable-接口和-comparator-接口实现比较阿\">#</a> 2. Comparable 接口和 Comparator 接口实现比较（阿 *）</h4>\n<p>Java 中 Comparable 接口和 Comparator 接口都可以用来实现对象的比较和排序，它们的用法如下⁴⁶⁷：</p>\n<ul>\n<li>Comparable 接口是一个内部比较器，它<font color='red'><strong>定义在要比较的类中</strong>，让类实现 Comparable 接口并重写 compareTo 方法</font>，该方法返回一个整数，表示当前对象和另一个对象的大小关系。例如，String 类就实现了 Comparable 接口，可以按照字典顺序进行比较。要使用 Comparable 接口对数组或集合中的元素进行排序，可以使用 Arrays.sort 或 Collections.sort 方法，并不需要传入比较器。</li>\n<li>Comparator 接口是一个外部比较器，它<font color='red'><strong>定义在要比较的类之外</strong>，让一个单独的类实现 Comparator 接口并重写 compare 方法</font>，该方法也返回一个整数，表示两个对象的大小关系。例如，可以创建一个按照年龄排序的 Comparator 对象，用来比较 Student 类的对象。要使用 Comparator 接口对数组或集合中的元素进行排序，可以使用 Arrays.sort 或 Collections.sort 方法，并<font color='red'>传入相应的比较器</font>。</li>\n<li>代码示例：</li>\n</ul>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">// 定义一个 Student 类</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">class</span> <span class=\"token class-name\">Student</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Comparable</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Student</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> name<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token keyword\">private</span> <span class=\"token keyword\">int</span> age<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token class-name\">Student</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> name<span class=\"token punctuation\">,</span><span class=\"token keyword\">int</span> age<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name<span class=\"token operator\">=</span>name<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>age<span class=\"token operator\">=</span>age<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token comment\">// 实现 Comparable 接口的 compareTo 方法，按照姓名排序</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">compareTo</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Student</span> o<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>        <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">.</span><span class=\"token function\">compareTo</span><span class=\"token punctuation\">(</span>o<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    <span class=\"token comment\">// 重写 toString 方法</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token class-name\">String</span> <span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>        <span class=\"token keyword\">return</span> <span class=\"token string\">\"Student[name=\"</span><span class=\"token operator\">+</span>name<span class=\"token operator\">+</span><span class=\"token string\">\",age=\"</span><span class=\"token operator\">+</span>age<span class=\"token operator\">+</span><span class=\"token string\">\"]\"</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre><span class=\"token comment\">// 定义一个按照年龄排序的 Comparator 对象</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre><span class=\"token keyword\">class</span> <span class=\"token class-name\">AgeComparator</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Comparator</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Student</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">compare</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Student</span> o1<span class=\"token punctuation\">,</span><span class=\"token class-name\">Student</span> o2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>        <span class=\"token keyword\">return</span> o1<span class=\"token punctuation\">.</span>age<span class=\"token operator\">-</span>o2<span class=\"token punctuation\">.</span>age<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre><span class=\"token comment\">// 测试代码</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Test</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>        <span class=\"token comment\">// 创建一个 Student 数组</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>        <span class=\"token class-name\">Student</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> students<span class=\"token operator\">=</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Student</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>            <span class=\"token keyword\">new</span> <span class=\"token class-name\">Student</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Alice\"</span><span class=\"token punctuation\">,</span><span class=\"token number\">20</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>            <span class=\"token keyword\">new</span> <span class=\"token class-name\">Student</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Bob\"</span><span class=\"token punctuation\">,</span><span class=\"token number\">18</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre>            <span class=\"token keyword\">new</span> <span class=\"token class-name\">Student</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Charlie\"</span><span class=\"token punctuation\">,</span><span class=\"token number\">22</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"32\"></td><td><pre>            <span class=\"token keyword\">new</span> <span class=\"token class-name\">Student</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"David\"</span><span class=\"token punctuation\">,</span><span class=\"token number\">19</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"33\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"34\"></td><td><pre>        <span class=\"token comment\">//------ 使用 Arrays.sort 方法对数组进行排序，不传入比较器，按照姓名排序 ------</span></pre></td></tr><tr><td data-num=\"35\"></td><td><pre>        <span class=\"token class-name\">Arrays</span><span class=\"token punctuation\">.</span><span class=\"token function\">sort</span><span class=\"token punctuation\">(</span>students<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"36\"></td><td><pre>        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Arrays</span><span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span>students<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"37\"></td><td><pre>        <span class=\"token comment\">// 输出：[Student [name=Alice,age=20], Student [name=Bob,age=18], Student [name=Charlie,age=22], Student [name=David,age=19]]</span></pre></td></tr><tr><td data-num=\"38\"></td><td><pre>        <span class=\"token comment\">//------ 创建一个 AgeComparator 对象 ------</span></pre></td></tr><tr><td data-num=\"39\"></td><td><pre>        <span class=\"token class-name\">AgeComparator</span> ac<span class=\"token operator\">=</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">AgeComparator</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"40\"></td><td><pre>        <span class=\"token comment\">// 使用 Arrays.sort 方法对数组进行排序，传入比较器，按照年龄排序</span></pre></td></tr><tr><td data-num=\"41\"></td><td><pre>        <span class=\"token class-name\">Arrays</span><span class=\"token punctuation\">.</span><span class=\"token function\">sort</span><span class=\"token punctuation\">(</span>students<span class=\"token punctuation\">,</span>ac<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"42\"></td><td><pre>        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Arrays</span><span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span>students<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"43\"></td><td><pre>        <span class=\"token comment\">// 输出：[Student [name=Bob,age=18], Student [name=David,age=19], Student [name=Alice,age=20], Student [name=Charlie,age=22]]</span></pre></td></tr><tr><td data-num=\"44\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"45\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure>",
            "tags": [
                "Java",
                "Java基础",
                "Java基础-真题"
            ]
        },
        {
            "id": "http://example.com/java/java-se/java-excise/%E7%AC%AC10%E7%AB%A0%EF%BC%9A%E9%9A%8F%E5%A0%82%E5%A4%8D%E4%B9%A0%E4%B8%8E%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%A2%98%EF%BC%88%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%89/",
            "url": "http://example.com/java/java-se/java-excise/%E7%AC%AC10%E7%AB%A0%EF%BC%9A%E9%9A%8F%E5%A0%82%E5%A4%8D%E4%B9%A0%E4%B8%8E%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%A2%98%EF%BC%88%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%89/",
            "title": "宋红康_第10章：多线程",
            "date_published": "2023-11-12T03:06:50.141Z",
            "content_html": "<h1 id=\"第10章随堂复习与企业真题多线程\"><a class=\"anchor\" href=\"#第10章随堂复习与企业真题多线程\">#</a> 第 10 章：随堂复习与企业真题（多线程）</h1>\n<hr />\n<h2 id=\"一-随堂复习\"><a class=\"anchor\" href=\"#一-随堂复习\">#</a> 一、随堂复习</h2>\n<h3 id=\"1-几个概念\"><a class=\"anchor\" href=\"#1-几个概念\">#</a> 1. 几个概念</h3>\n<pre><code>程序(program)：为完成特定任务，用某种语言编写的`一组指令的集合`。即指一段静态的代码。\n\n进程(process)：程序的一次执行过程，或是正在内存中运行的应用程序。程序是静态的，进程是动态的。\n              进程作为操作系统调度和分配资源的最小单位。\n\n线程(thread)：进程可进一步细化为线程，是程序内部的一条执行路径。\n             线程作为CPU调度和执行的最小单位\n</code></pre>\n<pre><code>线程调度策略\n分时调度：所有线程`轮流使用` CPU 的使用权，并且平均分配每个线程占用 CPU 的时间。\n\n抢占式调度：让`优先级高`的线程以`较大的概率`优先使用 CPU。如果线程的优先级相同，那么会随机选择一个(线程随机性)，Java使用的为抢占式调度。\n</code></pre>\n<pre><code>&gt; 单核CPU与多核CPU\n&gt; 并行与并发\n</code></pre>\n<h3 id=\"2-如何创建多线程重点\"><a class=\"anchor\" href=\"#2-如何创建多线程重点\">#</a> 2. <mark>如何创建多线程</mark>（重点）</h3>\n<ul>\n<li>方式 1：继承 Thread 类</li>\n<li>方式 2：实现 Runnable 接口</li>\n<li>方式 3：实现 Callable 接口 （jdk5.0 新增）</li>\n<li>方式 4：使用线程池（jdk5.0 新增）</li>\n</ul>\n<h3 id=\"3-thread类的常用方法-线程的生命周期\"><a class=\"anchor\" href=\"#3-thread类的常用方法-线程的生命周期\">#</a> 3. Thread 类的常用方法、线程的生命周期</h3>\n<pre><code>熟悉常用的构造器和方法：\n1. 线程中的构造器\n- public Thread() :分配一个新的线程对象。\n- public Thread(String name) :分配一个指定名字的新的线程对象。\n- public Thread(Runnable target) :指定创建线程的目标对象，它实现了Runnable接口中的run方法\n- public Thread(Runnable target,String name) :分配一个带有指定目标新的线程对象并指定名字。\n\n2.线程中的常用方法：\n&gt; start():①启动线程 ②调用线程的run()\n&gt; run():将线程要执行的操作，声明在run()中。\n&gt; currentThread():获取当前执行代码对应的线程\n&gt; getName(): 获取线程名\n&gt; setName(): 设置线程名\n&gt; sleep(long millis):静态方法，调用时，可以使得当前线程睡眠指定的毫秒数\n&gt; yield():静态方法，一旦执行此方法，就释放CPU的执行权\n&gt; join(): 在线程a中通过线程b调用join()，意味着线程a进入阻塞状态，直到线程b执行结束，线程a才结束阻塞状态，继续执行。\n&gt; isAlive():判断当前线程是否存活\n\n3. 线程的优先级：\ngetPriority():获取线程的优先级\nsetPriority():设置线程的优先级。范围[1,10]\n\n\nThread类内部声明的三个常量：\n- MAX_PRIORITY（10）：最高优先级\n- MIN _PRIORITY （1）：最低优先级\n- NORM_PRIORITY （5）：普通优先级，默认情况下main线程具有普通优先级。\n</code></pre>\n<p>线程的生命周期：</p>\n<p>jdk5.0 之前：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20221203142900528.png\" alt=\"image-20221203142900528\" /></p>\n<p>jdk5.0 及之后：Thread 类中定义了一个内部类 State</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">enum</span> <span class=\"token class-name\">State</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>        </pre></td></tr><tr><td data-num=\"3\"></td><td><pre>        <span class=\"token constant\">NEW</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    </pre></td></tr><tr><td data-num=\"5\"></td><td><pre>        <span class=\"token constant\">RUNNABLE</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>        <span class=\"token constant\">BLOCKED</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>        <span class=\"token constant\">WAITING</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>        <span class=\"token constant\">TIMED_WAITING</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre> </pre></td></tr><tr><td data-num=\"13\"></td><td><pre>        <span class=\"token constant\">TERMINATED</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20221203143046926.png\" alt=\"image-20221203143046926\" /></p>\n<h3 id=\"4-如何解决线程安全问题重点-难点\"><a class=\"anchor\" href=\"#4-如何解决线程安全问题重点-难点\">#</a> 4. <mark>如何解决线程安全问题</mark> (重点、难点)</h3>\n<ul>\n<li>\n<p>什么是线程的安全问题？多个线程操作共享数据，就有可能出现安全问题。</p>\n</li>\n<li>\n<p>如何解决线程的安全问题？有几种方式？</p>\n<ul>\n<li>\n<p><font color='gree'>同步机制</font>：① 同步代码块 ② 同步方法</p>\n<ul>\n<li>重点关注两个事：共享数据及操作共享数据的代码；<font color='red'>同步监视器（保证<strong>唯一性</strong>）</font></li>\n</ul>\n<pre><code>在实现Runnable接口的方式中，同步监视器可以考虑使用：this。\n在继承Thread类的方式中，同步监视器要慎用this，可以考虑使用：当前类.class。\n</code></pre>\n<pre><code>非静态的同步方法，默认同步监视器是this\n静态的同步方法，默认同步监视器是当前类本身。\n</code></pre>\n</li>\n<li>\n<p>jdk5.0 新增：<font color='gree'>Lock 接口及其实现类</font>。（保证多个线程共用同一个 Lock 的实例）</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"5-同步机制相关的问题\"><a class=\"anchor\" href=\"#5-同步机制相关的问题\">#</a> 5. 同步机制相关的问题</h3>\n<ul>\n<li>懒汉式的线程安全的写法</li>\n<li>同步机制会带来的问题：死锁\n<ul>\n<li>死锁产生的条件及规避方式</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"6-线程间的通信\"><a class=\"anchor\" href=\"#6-线程间的通信\">#</a> 6. 线程间的通信</h3>\n<ul>\n<li>\n<p>在同步机制下，考虑线程间的通信</p>\n</li>\n<li>\n<p><font color='red'>wait () 、notify () 、notifyAll () 都需要使用在<strong>同步代码块或同步方法</strong>中</font>。</p>\n</li>\n<li>\n<p>高频笔试题：wait () /sleep ()</p>\n</li>\n</ul>\n<h2 id=\"二-企业真题\"><a class=\"anchor\" href=\"#二-企业真题\">#</a> 二、企业真题</h2>\n<h3 id=\"21-线程概述\"><a class=\"anchor\" href=\"#21-线程概述\">#</a> 2.1 线程概述</h3>\n<h4 id=\"1-什么是线程云网络\"><a class=\"anchor\" href=\"#1-什么是线程云网络\">#</a> 1. 什么是线程 (* 云网络)</h4>\n<ul>\n<li>是进程内部的 <code>一条执行路径</code></li>\n<li>是<font color='orange'>CPU 调度和执行的最小单位</font></li>\n</ul>\n<h4 id=\"2-线程和进程有什么区别团-腾-云网络-神岳-言有物-直科技\"><a class=\"anchor\" href=\"#2-线程和进程有什么区别团-腾-云网络-神岳-言有物-直科技\">#</a> 2. 线程和进程有什么区别 (* 团、腾 *、* 云网络、神 ** 岳、言 * 有物、直 * 科技)</h4>\n<p>进程：对应<font color='red'>一个运行中的程序</font>。是<font color='orange'>操作系统<u>调度和分配资源</u>的最小单位</font></p>\n<p>线程：是运行中的<font color='red'>进程的一条或多条执行路径</font>。是<font color='orange'>CPU<u>调度和执行</u>的最小单位</font></p>\n<h4 id=\"3-多线程使用场景嘉医疗\"><a class=\"anchor\" href=\"#3-多线程使用场景嘉医疗\">#</a> 3. 多线程使用场景（嘉 * 医疗）</h4>\n<ul>\n<li>手机 app 应用的图片的下载</li>\n<li>迅雷的下载</li>\n<li>Tomcat 服务器上 web 应用，多个客户端发起请求，Tomcat 针对多个请求开辟多个线程处理</li>\n</ul>\n<h3 id=\"22-如何实现多线程\"><a class=\"anchor\" href=\"#22-如何实现多线程\">#</a> 2.2 如何实现多线程</h3>\n<h4 id=\"1-如何在java中出实现多线程阿校招-当置业-鸿网络-奥医药-科软-慧-上海驿软件-海科\"><a class=\"anchor\" href=\"#1-如何在java中出实现多线程阿校招-当置业-鸿网络-奥医药-科软-慧-上海驿软件-海科\">#</a> 1. 如何在 Java 中出实现多线程？(阿 * 校招、当 * 置业、鸿 * 网络、奥 * 医药、* 科软、慧 *、上海驿 * 软件、海 * 科)</h4>\n<pre><code>类似问题：\n&gt; 创建多线程用Runnable还是Thread(北京中*瑞飞)\n&gt; 多线程有几种实现方法，都是什么？（锐*（上海）企业管理咨询）\n</code></pre>\n<p>四种：</p>\n<ul>\n<li>继承 Thread 类</li>\n<li>实现 Runnable 接口</li>\n<li>实现 Callable 接口</li>\n<li>线程池</li>\n</ul>\n<h4 id=\"2-thread类中的start和run有什么区别北京中油-爱信-神泰岳-直科技软国际上海学网络\"><a class=\"anchor\" href=\"#2-thread类中的start和run有什么区别北京中油-爱信-神泰岳-直科技软国际上海学网络\">#</a> 2. Thread 类中的 start () 和 run () 有什么区别？(北京中油 **、爱 * 信、神 * 泰岳、直 * 科技，* 软国际，上海 * 学网络)</h4>\n<p>start()：① <font color='red'>开启线程（状态由 NEW 到 RUNNABLE）</font>② 调用线程的 run ()</p>\n<h4 id=\"3-启动一个线程是用run还是start度\"><a class=\"anchor\" href=\"#3-启动一个线程是用run还是start度\">#</a> 3. 启动一个线程是用 run () 还是 start ()?（* 度）</h4>\n<p>start()</p>\n<h4 id=\"4-java中runnable和callable有什么不同平金服-银数据-好在-亿征信-花儿网络\"><a class=\"anchor\" href=\"#4-java中runnable和callable有什么不同平金服-银数据-好在-亿征信-花儿网络\">#</a> 4. Java 中 Runnable 和 Callable 有什么不同？(平 * 金服、银 * 数据、好 * 在、亿 * 征信、花儿 ** 网络)</h4>\n<p>与 Runnable 接口相比， Callable 功能更强大些</p>\n<ul>\n<li>call () 可以<font color='red'>有返回值</font></li>\n<li>call()<font color='red'>可以抛出异常</font></li>\n<li><font color='red'>支持泛型参数</font></li>\n</ul>\n<p>缺点：<font color='red'>如果在主线程中需要获取分线程 call () 的返回值，则此时的主线程是阻塞状态的</font>。</p>\n<h4 id=\"5-什么是线程池为什么要使用它上海明物联网科技\"><a class=\"anchor\" href=\"#5-什么是线程池为什么要使用它上海明物联网科技\">#</a> 5. 什么是线程池，为什么要使用它？(上海明 * 物联网科技)</h4>\n<pre><code>此方式的好处：\n&gt; 提高了程序执行的效率。（因为线程已经提前创建好了）\n&gt; 提高了资源的复用率。（因为执行完的线程并未销毁，而是可以继续执行其他的任务）\n&gt; 可以设置相关的参数，对线程池中的线程的使用进行管理\n</code></pre>\n<p><font color='orange'>提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。</font></p>\n<p><strong>好处：</strong></p>\n<ul>\n<li>\n<p><font color='red'>提高响应速度</font>（因为线程已经提前创建好了）</p>\n</li>\n<li>\n<p><font color='red'>降低资源消耗</font>（因为执行完的线程并未销毁，可以继续执行其他任务）</p>\n</li>\n<li>\n<p><font color='red'><strong>便于线程管理</strong></font>，相关参数如下：</p>\n<ul>\n<li><code>corePoolSize</code> ：核心池的大小</li>\n<li><code>maximumPoolSize</code> ：最大线程数</li>\n<li><code>keepAliveTime</code> ：线程没有任务时最多保持多长时间后会终止</li>\n<li>…</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"23-常用方法-生命周期\"><a class=\"anchor\" href=\"#23-常用方法-生命周期\">#</a> 2.3 常用方法、生命周期</h3>\n<h4 id=\"1-sleep-和-yield区别神泰岳\"><a class=\"anchor\" href=\"#1-sleep-和-yield区别神泰岳\">#</a> 1. sleep () 和 yield () 区别？(神 * 泰岳)</h4>\n<p>sleep ()：一旦调用，就进入<font color='red'>TIMED_WAITING</font>状态</p>\n<p>yield ()：释放 cpu 的执行权，仍处在<font color='red'>RUNNABLE</font>的状态</p>\n<h4 id=\"2-线程创建的中的方法-属性情况招通-数互融\"><a class=\"anchor\" href=\"#2-线程创建的中的方法-属性情况招通-数互融\">#</a> 2. 线程创建的中的方法、属性情况？(招通 **、数 * 互融)</h4>\n<p>继承 Thread 类的方式：</p>\n<ul>\n<li>方法：\n<ul>\n<li>start ()：启动线程，执行 run () 方法。</li>\n<li>run ()：定义线程的执行逻辑。</li>\n<li>sleep ()：让当前线程睡眠一段时间，单位是毫秒。</li>\n<li>interrupt ()：中断线程的执行。</li>\n<li><font color='red'>join()</font>：等待该线程终止。</li>\n</ul>\n</li>\n<li>属性：\n<ul>\n<li>name：线程的名称。</li>\n<li><font color='red'>priority</font>：线程的优先级，取值范围为 1~10，默认值为 5。</li>\n<li>id：线程的唯一标识符，由 JVM 自动生成。</li>\n</ul>\n</li>\n</ul>\n<p>实现 Runnable 接口的方式：</p>\n<ul>\n<li>方法：\n<ul>\n<li>run ()：定义线程的执行逻辑。</li>\n</ul>\n</li>\n<li>属性：\n<ul>\n<li>无。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"3-线程的生命周期中国电子商务中心-科软-慧\"><a class=\"anchor\" href=\"#3-线程的生命周期中国电子商务中心-科软-慧\">#</a> 3. 线程的生命周期？(中国 ** 电子商务中心、* 科软、慧 *)</h4>\n<p>NEW、RUNNABLE、TERMINATED、<font color='red'>BLOCKED、WAITING、TIMED_WAITING</font></p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230316182537207.png\" alt=\"image-20230316182537207\" /></p>\n<h4 id=\"4-线程的基本状态以及状态之间的关系直科技\"><a class=\"anchor\" href=\"#4-线程的基本状态以及状态之间的关系直科技\">#</a> 4. 线程的基本状态以及状态之间的关系？(直 * 科技)</h4>\n<pre><code>类似问题：\n&gt; 线程有哪些状态？如何让线程进入阻塞？（华*中*，*兴）\n&gt; 线程有几个状态，就绪和阻塞有什么不同。（美*）\n&gt; Java的线程都有哪几种状态（字*跳动、*东、*手）\n</code></pre>\n<p>见上一题。</p>\n<h4 id=\"5-stop和suspend方法为何不推荐使用上海驿软件\"><a class=\"anchor\" href=\"#5-stop和suspend方法为何不推荐使用上海驿软件\">#</a> 5. stop () 和 suspend () 方法为何不推荐使用？（上海驿 * 软件）</h4>\n<p>stop ()：一旦执行，线程就结束了，导致<font color='red'>run () 有未执行完毕的代码</font>。stop()<font color='red'>会释放同步监视器，导致线程安全问题</font>。</p>\n<p>suspend ()：与 resume () 搭配使用，会导致<font color='red'>死锁</font>。</p>\n<h4 id=\"6-java-线程优先级是怎么定义的软动力\"><a class=\"anchor\" href=\"#6-java-线程优先级是怎么定义的软动力\">#</a> 6. Java 线程优先级是怎么定义的？（软 * 动力）</h4>\n<p>三个常量：MIN_PRIORITY（1）、NORM_PRIORITY（5）、MAX_PRIORITY（10）。</p>\n<p>范围：[1,10]。</p>\n<h3 id=\"24-线程安全与同步机制\"><a class=\"anchor\" href=\"#24-线程安全与同步机制\">#</a> 2.4 线程安全与同步机制</h3>\n<h4 id=\"1-你如何理解线程安全的线程安全问题是如何造成的软国际\"><a class=\"anchor\" href=\"#1-你如何理解线程安全的线程安全问题是如何造成的软国际\">#</a> 1. 你如何理解线程安全的？线程安全问题是如何造成的？（* 软国际）</h4>\n<pre><code>类似问题：\n&gt; 线程安全说一下？（奥*医药）\n&gt; 对线程安全的理解（*度校招）\n&gt; 什么是线程安全？(银*数据)\n</code></pre>\n<p>线程安全问题通常是由于<font color='red'><u>多个线程</u>同时对<u>共享的数据</u>进行读<strong>写</strong>操作而引起的</font>。</p>\n<h4 id=\"2-多线程共用一个数据变量需要注意什么史夫软件\"><a class=\"anchor\" href=\"#2-多线程共用一个数据变量需要注意什么史夫软件\">#</a> 2. 多线程共用一个数据变量需要注意什么？（史 * 夫软件）</h4>\n<p>线程安全问题</p>\n<h4 id=\"3-多线程保证线程安全一般有几种方式来科技-北京信天\"><a class=\"anchor\" href=\"#3-多线程保证线程安全一般有几种方式来科技-北京信天\">#</a> 3. 多线程保证线程安全一般有几种方式？（来 * 科技、北京 * 信天 *）</h4>\n<pre><code>类似问题：\n&gt; 如何解决其线程安全问题，并且说明为什么这样子去解决？（北京联合**）\n&gt; 请说出你所知道的线程同步的方法。（天*伟业）\n&gt; 哪些方法实现线程安全？（阿*）   \n&gt; 同步有几种实现方法，都是什么? （锐*企业管理咨询）\n&gt; 你在实际编码过程中如何避免线程安全问题？（*软国际）\n&gt; 如何让线程同步?（*手）\n&gt; 多线程下有什么同步措施（阿*校招）\n&gt; 同步有几种实现方法，都是什么？（海*科）\n</code></pre>\n<ul>\n<li>\n<p>同步机制</p>\n<ul>\n<li>同步代码块</li>\n<li>同步方法</li>\n</ul>\n</li>\n<li>\n<p>Lock 接口</p>\n</li>\n</ul>\n<h4 id=\"4-用什么关键字修饰同步方法上海驿软件\"><a class=\"anchor\" href=\"#4-用什么关键字修饰同步方法上海驿软件\">#</a> 4. 用什么关键字修饰同步方法？（上海驿 * 软件）</h4>\n<p>synchronized</p>\n<h4 id=\"5-synchronized加在静态方法和普通方法区别来科技\"><a class=\"anchor\" href=\"#5-synchronized加在静态方法和普通方法区别来科技\">#</a> 5. synchronized 加在静态方法和普通方法区别（来 * 科技）</h4>\n<p>synchronized 声明在方法上时，同步监视器默认为：</p>\n<ul>\n<li>静态的：当前类.class</li>\n<li>非静态的：this</li>\n</ul>\n<h4 id=\"6-java中synchronized和reentrantlock有什么不同三重工\"><a class=\"anchor\" href=\"#6-java中synchronized和reentrantlock有什么不同三重工\">#</a> 6. Java 中 synchronized 和 ReentrantLock 有什么不同 (三 * 重工)</h4>\n<pre><code>类似问题：\n&gt; 多线程安全机制中 synchronized和lock的区别（中*国际、*美、鸿*网络）\n&gt; 怎么实现线程安全，各个实现方法有什么区别？（美*、字*跳动）\n&gt; synchronized 和 lock 区别（阿*、*壳）\n</code></pre>\n<pre><code>synchronized不管是同步代码块还是同步方法，都需要在结束一对&#123;&#125;之后，释放对同步监视器的调用。\nLock是通过两个方法控制需要被同步的代码，更灵活一些。\nLock作为接口，提供了多种实现类，适合更多更复杂的场景，效率更高。\n</code></pre>\n<p><strong>synchronized 与 Lock 的对比</strong></p>\n<ol>\n<li><font color='red'>Lock 是显式锁</font>（手动开启和关闭锁，别忘记关闭锁），<font color='red'>synchronized 是隐式锁</font>，出了作用域、遇到异常等自动解锁</li>\n<li><font color='red'>Lock 只有代码块锁</font>，<font color='red'>synchronized 有代码块锁和方法锁</font></li>\n<li><font color='red'>使用 Lock 锁，JVM 将花费较少的时间来调度线程，性能更好</font>。并且具有<font color='red'>更好的扩展性（提供更多的子类）</font>，更体现面向对象。</li>\n<li>（了解）<font color='red'>Lock 锁可以对读不加锁，对写加锁</font>，synchronized 不可以</li>\n<li>（了解）<font color='red'>Lock 锁可以有多种获取锁的方式，可以从 sleep 的线程中抢到锁</font>，synchronized 不可以</li>\n</ol>\n<blockquote>\n<p>说明：开发建议中处理线程安全问题优先使用顺序为：</p>\n<p>・Lock ----&gt; 同步代码块 ----&gt; 同步方法</p>\n</blockquote>\n<h4 id=\"7-当一个线程进入一个对象的一个synchronized方法后其它线程是否可进入此对象的其它方法鸿网络\"><a class=\"anchor\" href=\"#7-当一个线程进入一个对象的一个synchronized方法后其它线程是否可进入此对象的其它方法鸿网络\">#</a> 7. 当一个线程进入一个对象的一个 synchronized 方法后，其它线程是否可进入此对象的其它方法？（鸿 * 网络）</h4>\n<p>需要看其他方法是否使用 synchronized 修饰，同步监视器的 this 是否是同一个。</p>\n<p>只有<font color='red'>当<strong>使用了 synchronized</strong>，且<strong>同步监视器是同一个</strong>的情况下，就不能访问了</font>。</p>\n<h4 id=\"8-线程同步与阻塞的关系同步一定阻塞吗阻塞一定同步吗阿校招-西安创佳\"><a class=\"anchor\" href=\"#8-线程同步与阻塞的关系同步一定阻塞吗阻塞一定同步吗阿校招-西安创佳\">#</a> 8. 线程同步与阻塞的关系？同步一定阻塞吗？阻塞一定同步吗？（阿 * 校招、西安 * 创佳 *）</h4>\n<p>同步一定阻塞；</p>\n<blockquote>\n<p>互斥是同步的保证，互斥了一定会阻塞</p>\n</blockquote>\n<p>阻塞不一定同步。</p>\n<blockquote>\n<p>Thread.sleep () 的调用也会阻塞，但不一定同步</p>\n</blockquote>\n<h3 id=\"25-死锁\"><a class=\"anchor\" href=\"#25-死锁\">#</a> 2.5 死锁</h3>\n<h4 id=\"1-什么是死锁产生死锁的原因及必要条件腾-阿\"><a class=\"anchor\" href=\"#1-什么是死锁产生死锁的原因及必要条件腾-阿\">#</a> 1. 什么是死锁，产生死锁的原因及必要条件（腾 *、阿 *）</h4>\n<p>什么是死锁：<font color='red'>不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源</font>，就形成了线程的死锁。</p>\n<p>死锁的原因：</p>\n<ul>\n<li>\n<p><font color='gree'>互斥</font>条件</p>\n<blockquote>\n<p>同步机制的目的就是为了实现互斥</p>\n</blockquote>\n</li>\n<li>\n<p><font color='gree'>占用且等待</font></p>\n</li>\n<li>\n<p><font color='gree'>不可抢占</font></p>\n</li>\n<li>\n<p><font color='gree'>循环等待</font></p>\n</li>\n</ul>\n<p>如何避免死锁：可以考虑<font color='red'>打破上面的诱发条件</font>。</p>\n<ul>\n<li>\n<p>针对 “互斥条件”：<font color='red'>互斥条件基本上<strong>无法被破坏</strong></font>。因为线程需要通过互斥解决安全问题。</p>\n</li>\n<li>\n<p>针对 “占用且等待”：<font color='red'>可以考虑<strong>一次性申请所有所需的资源</strong></font>，这样就不存在等待的问题。</p>\n</li>\n<li>\n<p>针对 “不可抢占”：占用部分资源的线程在进一步申请其他资源时，如果申请不到，就<font color='red'><strong>主动释放</strong>掉已经占用的资源</font>。</p>\n</li>\n<li>\n<p>针对 “循环等待”：可以<font color='red'>将资源改为<strong>线性顺序</strong>。申请资源时，先申请序号较小的，这样避免循环等待问题</font>。</p>\n</li>\n</ul>\n<h4 id=\"2-如何避免死锁阿-北京蓝-手\"><a class=\"anchor\" href=\"#2-如何避免死锁阿-北京蓝-手\">#</a> 2. 如何避免死锁？(阿 *、北京 * 蓝、* 手)</h4>\n<p>见上。</p>\n<h3 id=\"26-线程通信\"><a class=\"anchor\" href=\"#26-线程通信\">#</a> 2.6 线程通信</h3>\n<h4 id=\"1-java中notify和notifyall有什么区别汇天下\"><a class=\"anchor\" href=\"#1-java中notify和notifyall有什么区别汇天下\">#</a> 1. Java 中 notify () 和 notifyAll () 有什么区别 (汇 * 天下)</h4>\n<p>二者都是 Object 类中的方法，用于在多线程环境下进行线程间的通信。它们的区别在于：</p>\n<ul>\n<li>notify ()：会唤醒被 wait () 的线程中优先级最高的那<font color='gree'>一个</font>线程（如果被 wait () 的多个线程的优先级相同，则随机唤醒一个），使其从等待状态进入到可运行状态，<font color='red'>等待获取锁</font>并从<font color='red'>当初被 wait 的位置</font>继续执行；</li>\n<li>notifyAll ()：会唤醒<font color='gree'>所有</font>正在等待的线程，使它们从等待状态进入到可运行状态，<font color='red'>等待获取锁</font>并从<font color='red'>当初被 wait 的位置</font>继续执行；</li>\n</ul>\n<h4 id=\"2-为什么wait和notify方法要在同步代码块同步方法中调用北京智\"><a class=\"anchor\" href=\"#2-为什么wait和notify方法要在同步代码块同步方法中调用北京智\">#</a> 2. 为什么 wait () 和 notify () 方法要在同步代码块 / 同步方法中调用 (北京 * 智)</h4>\n<p>因为 wait ()、notify () 的<font color='red'>调用者必须是<strong>同步监视器</strong></font>。</p>\n<h4 id=\"3-多线程生产者消费者代码同步-wait-notify编程猫娱乐\"><a class=\"anchor\" href=\"#3-多线程生产者消费者代码同步-wait-notify编程猫娱乐\">#</a> 3. 多线程：生产者，消费者代码（同步、wait、notify 编程）（猫 * 娱乐）</h4>\n<pre><code>类似问题：\n&gt; 如何写代码来解决生产者消费者问题(上海明*物联网)\n&gt; 多线程中生产者和消费者如何保证同步（*为）\n&gt; 消费者生产者，写写伪代码（字*）\n</code></pre>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">/**</pre></td></tr><tr><td data-num=\"2\"></td><td><pre> * ClassName: ProducerConsumer</pre></td></tr><tr><td data-num=\"3\"></td><td><pre> * Package: threadcommunication</pre></td></tr><tr><td data-num=\"4\"></td><td><pre> * Description:</pre></td></tr><tr><td data-num=\"5\"></td><td><pre> * 案例：生产者 / 消费者问题</pre></td></tr><tr><td data-num=\"6\"></td><td><pre> * 生产者（Productor）将产品交给店员（Clerk），而消费者（Customer）从店员处取走产品，店员一次只能持有固定数量的产品（比如：20），</pre></td></tr><tr><td data-num=\"7\"></td><td><pre> * 如果生产者试图生产更多的产品，店员会叫生产者停一下，如果店中有空位放产品了再通知生产者继续生产；</pre></td></tr><tr><td data-num=\"8\"></td><td><pre> * 如果店中没有产品了，店员会告诉消费者等一下，如果店中有产品了再通知消费者来取走产品。</pre></td></tr><tr><td data-num=\"9\"></td><td><pre> * 分析：</pre></td></tr><tr><td data-num=\"10\"></td><td><pre> * 1. 是否是多线程问题？是，生产者线程，消费者线程；</pre></td></tr><tr><td data-num=\"11\"></td><td><pre> * 2. 是否有共享数据？是，店员（或产品）；</pre></td></tr><tr><td data-num=\"12\"></td><td><pre> * 3. 是否有线程安全问题？是，店员（或产品）；</pre></td></tr><tr><td data-num=\"13\"></td><td><pre> * 4. 如何解决线程安全问题？同步机制；</pre></td></tr><tr><td data-num=\"14\"></td><td><pre> * 5. 是否涉及线程的通信？是，体现在生产者和消费者之间；</pre></td></tr><tr><td data-num=\"15\"></td><td><pre> *</pre></td></tr><tr><td data-num=\"16\"></td><td><pre> * @Author 贺健翔</pre></td></tr><tr><td data-num=\"17\"></td><td><pre> * @Create 2023/3/16 15:06</pre></td></tr><tr><td data-num=\"18\"></td><td><pre> * @Version 1.0</pre></td></tr><tr><td data-num=\"19\"></td><td><pre> */</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre><span class=\"token keyword\">class</span> <span class=\"token class-name\">Clerk</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token comment\">// 店员</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>    <span class=\"token keyword\">private</span> <span class=\"token keyword\">int</span> productCount <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 产品数量</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>    <span class=\"token comment\">// 生产产品</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">synchronized</span> <span class=\"token keyword\">void</span> <span class=\"token function\">addProduct</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>productCount <span class=\"token operator\">>=</span> <span class=\"token number\">20</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>            <span class=\"token keyword\">try</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>                <span class=\"token function\">wait</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 生产者线程进入 WAITING 状态，同时会释放同步监视器！</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>            <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">InterruptedException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>                e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>            <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"32\"></td><td><pre>            productCount<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"33\"></td><td><pre>            <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Thread</span><span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token string\">\"生产了第\"</span> <span class=\"token operator\">+</span> productCount <span class=\"token operator\">+</span> <span class=\"token string\">\"个产品\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"34\"></td><td><pre>            <span class=\"token function\">notifyAll</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 唤醒被 wait () 的消费者线程</span></pre></td></tr><tr><td data-num=\"35\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"36\"></td><td><pre></pre></td></tr><tr><td data-num=\"37\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"38\"></td><td><pre></pre></td></tr><tr><td data-num=\"39\"></td><td><pre>    <span class=\"token comment\">// 消费产品</span></pre></td></tr><tr><td data-num=\"40\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">synchronized</span> <span class=\"token keyword\">void</span> <span class=\"token function\">minusProduct</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"41\"></td><td><pre>        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>productCount <span class=\"token operator\">&lt;=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"42\"></td><td><pre>            <span class=\"token keyword\">try</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"43\"></td><td><pre>                <span class=\"token function\">wait</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 消费者线程进入 WAITING 状态，同时会释放同步监视器！</span></pre></td></tr><tr><td data-num=\"44\"></td><td><pre>            <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">InterruptedException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"45\"></td><td><pre>                e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"46\"></td><td><pre>            <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"47\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"48\"></td><td><pre>            <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Thread</span><span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token string\">\"消费了第\"</span> <span class=\"token operator\">+</span> productCount <span class=\"token operator\">+</span> <span class=\"token string\">\"个产品\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"49\"></td><td><pre>            productCount<span class=\"token operator\">--</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"50\"></td><td><pre>            <span class=\"token function\">notifyAll</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 唤醒被 wait () 的生产者线程</span></pre></td></tr><tr><td data-num=\"51\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"52\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"53\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"54\"></td><td><pre></pre></td></tr><tr><td data-num=\"55\"></td><td><pre><span class=\"token keyword\">class</span> <span class=\"token class-name\">Producer</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Thread</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token comment\">// 生产者</span></pre></td></tr><tr><td data-num=\"56\"></td><td><pre>    <span class=\"token keyword\">private</span> <span class=\"token class-name\">Clerk</span> clerk<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"57\"></td><td><pre></pre></td></tr><tr><td data-num=\"58\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token class-name\">Producer</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Clerk</span> clerk<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"59\"></td><td><pre>        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>clerk <span class=\"token operator\">=</span> clerk<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"60\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"61\"></td><td><pre></pre></td></tr><tr><td data-num=\"62\"></td><td><pre>    <span class=\"token annotation punctuation\">@Override</span></pre></td></tr><tr><td data-num=\"63\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"64\"></td><td><pre>        <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"65\"></td><td><pre>            <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"生产者开始生产产品\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"66\"></td><td><pre>            <span class=\"token keyword\">try</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"67\"></td><td><pre>                <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">50</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"68\"></td><td><pre>            <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">InterruptedException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"69\"></td><td><pre>                e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"70\"></td><td><pre>            <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"71\"></td><td><pre>            <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>clerk<span class=\"token punctuation\">.</span><span class=\"token function\">addProduct</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"72\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"73\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"74\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"75\"></td><td><pre></pre></td></tr><tr><td data-num=\"76\"></td><td><pre><span class=\"token keyword\">class</span> <span class=\"token class-name\">Consumer</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Thread</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token comment\">// 消费者</span></pre></td></tr><tr><td data-num=\"77\"></td><td><pre>    <span class=\"token keyword\">private</span> <span class=\"token class-name\">Clerk</span> clerk<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"78\"></td><td><pre></pre></td></tr><tr><td data-num=\"79\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token class-name\">Consumer</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Clerk</span> clerk<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"80\"></td><td><pre>        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>clerk <span class=\"token operator\">=</span> clerk<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"81\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"82\"></td><td><pre></pre></td></tr><tr><td data-num=\"83\"></td><td><pre>    <span class=\"token annotation punctuation\">@Override</span></pre></td></tr><tr><td data-num=\"84\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"85\"></td><td><pre>        <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"86\"></td><td><pre>            <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"消费者开始消费产品\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"87\"></td><td><pre>            <span class=\"token keyword\">try</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"88\"></td><td><pre>                <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">100</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"89\"></td><td><pre>            <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">InterruptedException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"90\"></td><td><pre>                e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"91\"></td><td><pre>            <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"92\"></td><td><pre>            <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>clerk<span class=\"token punctuation\">.</span><span class=\"token function\">minusProduct</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"93\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"94\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"95\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"96\"></td><td><pre></pre></td></tr><tr><td data-num=\"97\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">ProducerConsumer</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"98\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"99\"></td><td><pre>        <span class=\"token class-name\">Clerk</span> clerk <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Clerk</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"100\"></td><td><pre>        <span class=\"token class-name\">Producer</span> producer <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Producer</span><span class=\"token punctuation\">(</span>clerk<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"101\"></td><td><pre>        <span class=\"token class-name\">Consumer</span> consumer <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Consumer</span><span class=\"token punctuation\">(</span>clerk<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"102\"></td><td><pre>        producer<span class=\"token punctuation\">.</span><span class=\"token function\">setName</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"生产者\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"103\"></td><td><pre>        consumer<span class=\"token punctuation\">.</span><span class=\"token function\">setName</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"消费者\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"104\"></td><td><pre>        producer<span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"105\"></td><td><pre>        consumer<span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"106\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"107\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h4 id=\"4-wait和sleep有什么区别调用这两个函数后线程状态分别作何改变字-东\"><a class=\"anchor\" href=\"#4-wait和sleep有什么区别调用这两个函数后线程状态分别作何改变字-东\">#</a> 4. wait () 和 sleep () 有什么区别？调用这两个函数后，线程状态分别作何改变？（字 *、* 东）</h4>\n<pre><code>类似问题：\n&gt; 线程中sleep()和wait()有什么区别？（外派*度）\n&gt; Java线程阻塞调用 wait 函数和 sleep 区别和联系（阿*）\n&gt; wait和sleep的区别，他们两个谁会释放锁（软*动力、*创）\n</code></pre>\n<p>相同点：一旦执行，都会使得当前线程结束执行状态，<font color='red'>进入阻塞状态（WAITING / TIMED_WAITING）</font>。</p>\n<p>不同点：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">不同点</th>\n<th style=\"text-align:center\">Thread.sleep()</th>\n<th style=\"text-align:center\">Object 类实例的 wait ()</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">所属的类</td>\n<td style=\"text-align:center\">Thread 类中的<font color='red'>静态</font>方法</td>\n<td style=\"text-align:center\"><font color='red'>Object 类</font>中的实例方法</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">适用范围</td>\n<td style=\"text-align:center\">任意</td>\n<td style=\"text-align:center\"><font color='red'>同步代码块或同步方法中</font></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">是否释放同步监视器</td>\n<td style=\"text-align:center\">否</td>\n<td style=\"text-align:center\"><font color='red'>是</font></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">结束方式</td>\n<td style=\"text-align:center\">指定时间一到就结束阻塞（TIMED_WAITING）</td>\n<td style=\"text-align:center\">可以指定时间（TIMED_WAITING），也可以无限等待（WAITING）直到 notify 或 notifyAll</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"27-单例模式线程安全\"><a class=\"anchor\" href=\"#27-单例模式线程安全\">#</a> 2.7 单例模式（线程安全）</h3>\n<h4 id=\"1-手写一个单例模式singleton还要安全的通快递-君科技\"><a class=\"anchor\" href=\"#1-手写一个单例模式singleton还要安全的通快递-君科技\">#</a> 1. 手写一个单例模式 (Singleton)，还要安全的（* 通快递、君 * 科技）</h4>\n<p>饿汉式：</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">// 饿汉式单例设计模式</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">class</span> <span class=\"token class-name\">Bank</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token comment\">// 1. 私有化类的构造器</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token keyword\">private</span> <span class=\"token class-name\">Bank</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token comment\">// 2. 内部创建类的实例对象</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token comment\">// 4. 要求此对象属性也必须声明为 static 的</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token class-name\">Bank</span> instance <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Bank</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token comment\">// 3. 通过 get 方法获取当前类的实例对象，必须声明为 static 的</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token class-name\">Bank</span> <span class=\"token function\">getInstance</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>        <span class=\"token keyword\">return</span> instance<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>安全的懒汉式：</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">class</span> <span class=\"token class-name\">Bank</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token comment\">// 1. 私有化类的构造器</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">private</span> <span class=\"token class-name\">Bank</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token comment\">// 2. 内部创建类的对象</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token comment\">// 4. 要求此对象也必须声明为静态的</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token class-name\">Bank</span> instance <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token comment\">// 3. 提供公共的静态方法，返回类的对象</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token comment\">// 欲解决线程安全问题，只需将此方法声明为同步的即可。因为是静态方法，所以同步监视器默认是当前类.class，是唯一的。</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">synchronized</span> <span class=\"token class-name\">Bank</span> <span class=\"token function\">getInstance</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>instance <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>            <span class=\"token keyword\">try</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>                <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">1000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>            <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">InterruptedException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>                e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>            <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>            <span class=\"token comment\">// 此处存在线程安全问题：当有多个线程进入到此处时，有可能会创建多个对象</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>            instance <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Bank</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>        <span class=\"token keyword\">return</span> instance<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h4 id=\"2-手写一个懒汉式的单例模式解决其线程安全问题并且说明为什么这样子去解决5\"><a class=\"anchor\" href=\"#2-手写一个懒汉式的单例模式解决其线程安全问题并且说明为什么这样子去解决5\">#</a> 2. 手写一个懒汉式的单例模式 &amp; 解决其线程安全问题，并且说明为什么这样子去解决（5*）</h4>\n<pre><code>类似问题：\n&gt; 手写一个懒汉式的单例模式（北京联合**）\n</code></pre>\n<p>同上。</p>\n",
            "tags": [
                "Java",
                "Java基础",
                "Java基础-真题"
            ]
        }
    ]
}