{
    "version": "https://jsonfeed.org/version/1",
    "title": "水文 & 摄影",
    "subtitle": "为了能更好地查看图片，你需要一点魔法",
    "icon": "http://example.com/images/favicon.ico",
    "description": "",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/photography/%E7%B4%AB%E7%AB%B9%E9%99%A2%E5%85%AC%E5%9B%AD/",
            "url": "http://example.com/photography/%E7%B4%AB%E7%AB%B9%E9%99%A2%E5%85%AC%E5%9B%AD/",
            "title": "紫竹院公园",
            "date_published": "2024-03-02T16:00:00.000Z",
            "content_html": "<p><img data-src=\"https://pic.imgdb.cn/item/65e5f89e9f345e8d036fa68a.jpg\" alt=\"\" /><br />\n<img data-src=\"https://pic.imgdb.cn/item/65e5f8cd9f345e8d03702954.jpg\" alt=\"\" /></p>\n<p><img data-src=\"https://pic.imgdb.cn/item/65e5f92d9f345e8d03712fc2.jpg\" alt=\"\" /></p>\n<p><img data-src=\"https://pic.imgdb.cn/item/65e5f92c9f345e8d03712e5d.jpg\" alt=\"\" /></p>\n<p><img data-src=\"https://pic.imgdb.cn/item/65e5f92d9f345e8d037130ad.jpg\" alt=\"\" /></p>\n<p><img data-src=\"https://pic.imgdb.cn/item/65e5fa539f345e8d0374341f.jpg\" alt=\"\" /></p>\n<p><img data-src=\"https://pic.imgdb.cn/item/65e5f9a29f345e8d0372631c.jpg\" alt=\"\" /></p>\n<p><img data-src=\"https://pic.imgdb.cn/item/65e5f92c9f345e8d03712cd9.jpg\" alt=\"\" height=\"700px\" /></p>\n<p><img data-src=\"https://pic.imgdb.cn/item/65e5f92c9f345e8d03712bd5.jpg\" alt=\"\" /></p>\n<p><img data-src=\"https://pic.imgdb.cn/item/65e5f9a39f345e8d037264f6.jpg\" alt=\"\" height=\"700px\" /></p>\n<p><img data-src=\"https://pic.imgdb.cn/item/65e5f9a19f345e8d03726251.jpg\" alt=\"\" /></p>\n<p><img data-src=\"https://pic.imgdb.cn/item/65e5f9a29f345e8d037263ad.jpg\" alt=\"\" /></p>\n<p><img data-src=\"https://pic.imgdb.cn/item/65e5f9a29f345e8d03726450.jpg\" alt=\"\" /></p>\n<p><img data-src=\"https://pic.imgdb.cn/item/65e5f9e69f345e8d03731510.jpg\" alt=\"\" /></p>\n<p><img data-src=\"https://pic.imgdb.cn/item/65e5f9e69f345e8d0373162f.jpg\" alt=\"\" /></p>\n<p><img data-src=\"https://pic.imgdb.cn/item/65e5f9e79f345e8d0373173e.jpg\" alt=\"\" /></p>\n<p><img data-src=\"https://pic.imgdb.cn/item/65e5f9e79f345e8d0373183a.jpg\" alt=\"\" height=\"700px\" /></p>\n<p><img data-src=\"https://pic.imgdb.cn/item/65e5fa549f345e8d0374355b.jpg\" alt=\"\" height=\"700px\" /></p>\n",
            "tags": [
                "摄影"
            ]
        },
        {
            "id": "http://example.com/distributed-microservices/ShardingSphere/",
            "url": "http://example.com/distributed-microservices/ShardingSphere/",
            "title": "ShardingSphere",
            "date_published": "2024-01-26T14:11:07.441Z",
            "content_html": "<p>Apache ShardingSphere 是一款分布式的数据库生态系统，<strong><font color='red'>可以将任意数据库转换为分布式数据库</font></strong>，并通过<font color='red'>数据分片、弹性伸缩、加密</font>等能力对原有数据库进行增强。</p>\n<p>ShardingSphere 源码地址：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2FwYWNoZS9zaGFyZGluZ3NwaGVyZQ==\">https://github.com/apache/shardingsphere</span></p>\n<p>ShardingSphere 官方网站：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9zaGFyZGluZ3NwaGVyZS5hcGFjaGUub3JnLw==\">https://shardingsphere.apache.org</span></p>\n<p>文章描述 ShardingSphere 相关概念和知识，如无特别声明，均是 Apache ShardingSphere  <code>5.3.2</code>  版本。</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRlZS5jb20vbmFnZW9mZmVyL3NwcmluZ2Jvb3QtbGFkZGVy\">🔥 SpringBoot Ladder</span>：从零到一学习 SpringBoot 各种组件框架实战的项目，让 Demo 变得简单。咱们文章中的 ShardingSphere 示例也在这个项目。</p>\n<h1 id=\"分库分表背景\"><a class=\"anchor\" href=\"#分库分表背景\">#</a> 分库分表背景</h1>\n<p><font color='gree'>传统的将数据集中存储至单一节点</font>的解决方案，在<font color='red'>性能、可用性和运维成本</font>这三方面已经难于满足海量数据的场景。</p>\n<p>从性能方面来说，由于关系型数据库大多采用 B+ 树类型的索引，在数据量超过阈值的情况下，索引深度的增加也将使得磁盘访问的 IO 次数增加，进而导致查询性能的下降；同时，高并发访问请求也使得集中式数据库成为系统的最大瓶颈。</p>\n<p>从可用性的方面来讲，服务化的无状态性，能够达到较小成本的随意扩容，这必然导致系统的最终压力都落在数据库之上。 而单一的数据节点，或者简单的主从架构，已经越来越难以承担。数据库的可用性，已成为整个系统的关键。</p>\n<p>从运维成本方面考虑，当一个数据库实例中的数据达到阈值以上，对于 DBA 的运维压力就会增大。 数据备份和恢复的时间成本都将随着数据量的大小而愈发不可控。一般来讲，单一数据库实例的数据的阈值在 1TB 之内，是比较合理的范围。</p>\n<p>在传统的关系型数据库无法满足互联网场景需要的情况下，<font color='gree'>将数据存储至原生支持分布式的 NoSQL 的尝试越来越多</font>。 <font color='red'>但 NoSQL 对 SQL 的不兼容性以及生态圈的不完善</font>，使得它们在与关系型数据库的博弈中始终无法完成致命一击，而关系型数据库的地位却依然不可撼动。</p>\n<p>**<font color='gree'>数据分片</font>** 指<font color='red'>按照某个维度，将存放在单一数据库中的数据分散地存放至多个数据库或表中</font>，以达到提升性能瓶颈以及可用性的效果。数据分片的有效手段是对关系型数据库进行<font color='red'>分库和分表</font>。分库和分表均可以有效的避免由数据量超过可承受阈值而产生的查询瓶颈。 除此之外，分库还能够用于有效的分散对数据库单点的访问量；分表虽然无法缓解数据库压力，但却能够提供尽量将分布式事务转化为本地事务的可能，一旦涉及到跨库的更新操作，分布式事务往往会使问题变得复杂。使用多主多从的分片方式，可以有效的避免数据单点，从而提升数据架构的可用性。</p>\n<p>通过分库和分表进行数据的拆分来使得各个表的数据量保持在阈值以下，以及对流量进行疏导应对高访问量，是应对高并发和海量数据系统的有效手段。数据分片的拆分方式又分为<font color='red'>垂直分片和水平分片</font>。</p>\n<h1 id=\"分库分表介绍\"><a class=\"anchor\" href=\"#分库分表介绍\">#</a> 分库分表介绍</h1>\n<h2 id=\"什么是分库分表\"><a class=\"anchor\" href=\"#什么是分库分表\">#</a> 什么是分库分表？</h2>\n<p>分库分表是一种数据库分片技术，用于解决大规模应用中单一数据库容量不足以支持高并发和大数据量的问题。<font color='red'>它将一个大型的数据库拆分成多个小型数据库，每个小型数据库称为一个分片。</font>每个分片存储部分数据，从而降低了单个数据库的负担。</p>\n<p><strong><font color='red'>简单来说，分库是将原本的单库拆分为多个库，分表是将原来的单表拆分为多个表。</font></strong></p>\n<p>很多情况下，分库分表并不是从系统设计开始就存在的，而是系统运行过程中，出现数据量庞大或者查询性能慢等问题延伸而来。</p>\n<p>如果你在业务功能开发时，已经预知业务数据库量，应提前进行分库或者分表，做好分片规范，避免系统运行时拆分。</p>\n<h3 id=\"分库\"><a class=\"anchor\" href=\"#分库\">#</a> 分库</h3>\n<p>1）<font color='cornflowerblue'>垂直分片</font></p>\n<p>比如：电商库 mall_db，业务拆分后就是 user_db、order_db、pay_db...</p>\n<p>按照业务拆分的方式称为垂直分片，又称为纵向拆分，它的核心理念是专库专用。在拆分之前，一个数据库由多个数据表构成，每个表对应着不同的业务。而拆分之后，则是 **<font color='red'>按照业务将表进行归类，分布到不同的数据库中</font>**，从而将压力分散至不同的数据库。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230926143106698.png\" alt=\"img\" /></p>\n<p>优点：</p>\n<ul>\n<li>可以针对不同业务场景优化数据库，提高性能。</li>\n<li>提高了数据库的并发能力。</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>需要处理<font color='red'>分布式事务的问题</font>。</li>\n<li>增加了系统的复杂度。</li>\n</ul>\n<p>2）<font color='cornflowerblue'>水平分片</font></p>\n<p>比如：用户库 user_db，分片库后就是 user_db_0、user_db_1、user_db_xx。</p>\n<p>水平分片又称为横向拆分。相对于垂直分片，它不再将数据根据业务逻辑分类，而是 **<font color='red'>通过某个字段（或某几个字段），根据某种规则将数据分散至多个库或表中，每个分片仅包含数据的一部分</font>**。 例如：根据主键分片，偶数主键的记录放入 0 库（或表），奇数主键的记录放入 1 库（或表），如下图所示。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230926143122066.png\" alt=\"img\" /></p>\n<p>优点：</p>\n<ul>\n<li>提高了单库的读写性能，降低了单库数据量。</li>\n<li>可以将库存储在不同的物理服务器上，提高了查询效率。</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>需要处理<font color='red'>跨库查询的问题</font>。</li>\n<li>对分库规则的设计需要谨慎，<font color='red'>避免热点数据集中在某个库中</font>。</li>\n</ul>\n<h3 id=\"分表\"><a class=\"anchor\" href=\"#分表\">#</a> 分表</h3>\n<p>1）<font color='cornflowerblue'>垂直分片</font></p>\n<p>比如：订单表 order_table，拆分后就是 order_table 以及 order_ext_table。</p>\n<p>同分库的概念，只不过将数据库维度降低为数据库表维度。</p>\n<p>优点：</p>\n<ul>\n<li>拆分后每个表的数据量变小，查询时涉及的磁盘 I/O 次数相对减少，提高了查询效率。</li>\n<li>每个小表的并发写入操作相对较少，减少了数据库锁的竞争，提高了并发能力。</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li><font color='red'>需要在应用层面处理<strong>跨表查询的逻辑</strong>，增加了开发的复杂性</font>。</li>\n<li>如果一个事务涉及多个小表，可能<font color='red'>需要在应用层面进行<strong>事务管理</strong>，增加了代码的复杂性</font>。</li>\n<li>需要额外的措施来<font color='red'>保证拆分后的小表之间的<strong>数据一致性</strong></font>。</li>\n</ul>\n<p>2）<font color='cornflowerblue'>水平分片</font></p>\n<p>比如：订单表 order_table，拆分后就是 order_table_0、 order_table_1、order_table_xxx。</p>\n<p>同分库的概念，只不过将数据库维度降低为数据库表维度。</p>\n<p>优点：</p>\n<ul>\n<li>可以根据数据量的增长动态地增加分表，从而扩展数据库的存储能力。</li>\n<li>每个小表的数据量减少，可以提高查询速度，尤其是在频繁查询的场景下。</li>\n<li>拆分后，每个小表的并发写入操作相对减少，降低了数据库锁的竞争，提高了并发性能。</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>对业务存在一定限制，<font color='red'>如果没有按照分片键查询，会造成读扩散问题</font>。</li>\n<li>对分表规则的设计需要谨慎，<font color='red'>避免热点数据集中在某个表中</font>。</li>\n</ul>\n<h2 id=\"分库分表场景\"><a class=\"anchor\" href=\"#分库分表场景\">#</a> 分库分表场景</h2>\n<h3 id=\"分表场景\"><a class=\"anchor\" href=\"#分表场景\">#</a> 分表场景</h3>\n<p><font color='red'>数据量过大</font>或者<font color='red'>数据库表对应的磁盘文件过大</font>。</p>\n<p>Q：多少数据量进行分表？</p>\n<p>A：单表 1000w 是否要分表？回答不够标准。假设一个表里 15 个字段，没有特别大的值（不包含 text 或其它超长度的列）数据量超过 5000 万了，依然很丝滑，因为走索引。</p>\n<p>真正需要考虑的是：业务的增长量以及历史数量。</p>\n<p>Q：物理文件过大，会有什么问题？</p>\n<p>A：会影响公司对数据库表的一个备份。数据库表文件过大，也间接证明表数据过大，增加或删除字段导致锁表的时间过长。</p>\n<h3 id=\"分库场景\"><a class=\"anchor\" href=\"#分库场景\">#</a> 分库场景</h3>\n<p><font color='red'>当数据库的连接数量不够客户端使用时</font>，可以考虑分库或读写分离。</p>\n<p>如果说当数据库的 QPS 越来越高以及数据量越来越大的时候，就需要考虑分库分表。</p>\n<p>Q：为什么说连接不够用？</p>\n<p>A：假设 MySQL Server 能支持 4000 个数据库连接。我们有 10 个服务，40 个节点，一个节点呢数据库连接池最多 10 个。这样就把一个 MySQL Server 的连接数压榨干净了。</p>\n<p>当 MySQL 连接不够用时，可能会报错 &quot;Too many connections&quot; 或者类似的错误。这是因为 MySQL 服务器同时可以处理的连接数量是有限制的，当连接数达到这个限制时，服务器就会拒绝新的连接请求，并返回这个错误消息。</p>\n<h3 id=\"分库分表场景-2\"><a class=\"anchor\" href=\"#分库分表场景-2\">#</a> 分库分表场景</h3>\n<ul>\n<li><font color='red'>高并发写入</font>场景：当应用面临高并发的写入请求时，单一数据库可能无法满足写入压力，此时可以将数据按照一定规则拆分到多个数据库中，每个数据库处理部分数据的写入请求，从而提高写入性能。</li>\n<li><font color='red'>数据量巨大</font>场景：随着数据量的不断增加，单一数据库的存储和查询性能可能逐渐下降。此时，可以将数据按照一定的规则拆分到多个表中，每个表存储部分数据，从而分散数据的存储压力，提高查询性能。</li>\n</ul>\n<h1 id=\"shardingsphere-介绍\"><a class=\"anchor\" href=\"#shardingsphere-介绍\">#</a> ShardingSphere 介绍</h1>\n<p>Apache ShardingSphere 是一款分布式的数据库生态系统，<strong><font color='red'>可以将任意数据库转换为分布式数据库</font></strong>，并通过<font color='red'>数据分片、弹性伸缩、加密</font>等能力对原有数据库进行增强。</p>\n<p>Apache ShardingSphere 设计哲学为 Database Plus，旨在构建异构数据库上层的标准和生态。它关注如何充分合理地利用数据库的计算和存储能力，而并非实现一个全新的数据库。它站在数据库的上层视角，关注它们之间的协作多于数据库自身。</p>\n<p>ShardingSphere 有两个产品在企业中广泛使用，分别是  <code>ShardingSphere-JDBC</code>  以及  <code>ShardingSphere-Proxy</code> 。</p>\n<h2 id=\"shardingsphere-jdbc\"><a class=\"anchor\" href=\"#shardingsphere-jdbc\">#</a> ShardingSphere-JDBC</h2>\n<p><code>ShardingSphere-JDBC</code>  定位为轻量级 Java 框架，在 Java 的 JDBC 层提供的额外服务。<font color='red'>它使用客户端直连数据库，以 Jar 包形式提供服务，无需额外部署和依赖，可理解为<strong>增强版的 JDBC 驱动</strong>，完全兼容 JDBC 和各种 ORM 框架</font>。</p>\n<ul>\n<li>适用于任何基于 JDBC 的 ORM 框架，如：JPA, Hibernate, Mybatis, Spring JDBC Template 或直接使用 JDBC；</li>\n<li>支持任何第三方的数据库连接池，如：DBCP, C3P0, BoneCP, HikariCP 等；</li>\n<li>支持任意实现 JDBC 规范的数据库，目前支持 MySQL，PostgreSQL，Oracle，SQLServer 以及任何可使用 JDBC 访问的数据库。</li>\n</ul>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230926142255390.png\" alt=\"img\" /></p>\n<h2 id=\"shardingsphere-proxy\"><a class=\"anchor\" href=\"#shardingsphere-proxy\">#</a> ShardingSphere-Proxy</h2>\n<p><code>ShardingSphere-Proxy</code>  定位为<font color='red'><strong>透明化的数据库代理端</strong>，通过实现数据库二进制协议，对异构语言提供支持</font>。目前提供 MySQL 和 PostgreSQL 协议，透明化数据库操作，对 DBA 更加友好。</p>\n<ul>\n<li>向应用程序完全透明，可直接当做 MySQL/PostgreSQL 使用；</li>\n<li>兼容 MariaDB 等基于 MySQL 协议的数据库，以及 openGauss 等基于 PostgreSQL 协议的数据库；</li>\n<li>适用于任何兼容 MySQL/PostgreSQL 协议的的客户端，如：MySQL Command Client, MySQL Workbench, Navicat 等。</li>\n</ul>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230926142321036.png\" alt=\"img\" /></p>\n<h2 id=\"混合部署\"><a class=\"anchor\" href=\"#混合部署\">#</a> 混合部署</h2>\n<p><code>ShardingSphere-JDBC</code>  采用无中心化架构，与应用程序共享资源，适用于 Java 开发的高性能的轻量级 OLTP 应用；  <code>ShardingSphere-Proxy</code>  提供静态入口以及异构语言的支持，独立于应用程序部署，适用于 OLAP 应用以及对分片数据库进行管理和运维的场景。</p>\n<p><code>Apache ShardingSphere</code>  是多接入端共同组成的生态圈。<font color='red'>通过混合使用  <code>ShardingSphere-JDBC</code>  和  <code>ShardingSphere-Proxy</code> ，并采用同一注册中心统一配置分片策略，能够灵活的搭建适用于各种场景的应用系统，使得架构师更加自由地调整适合于当前业务的最佳系统架构</font>。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230926142358927.png\" alt=\"img\" /></p>\n<h2 id=\"产品功能\"><a class=\"anchor\" href=\"#产品功能\">#</a> 产品功能</h2>\n<p>这里给大家列一些经常使用且入门门槛较低的功能，更多的功能大家可以去 ShardingSphere 官网发掘。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">特性</th>\n<th style=\"text-align:left\">定义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><strong>数据分片</strong></td>\n<td style=\"text-align:left\">数据分片，是应对海量数据存储与计算的有效手段。ShardingSphere 基于底层数据库提供分布式数据库解决方案，可以水平扩展计算和存储。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>读写分离</strong></td>\n<td style=\"text-align:left\">读写分离，是应对高压力业务访问的手段。基于对 SQL 语义理解及对底层数据库拓扑感知能力，ShardingSphere 提供灵活的<font color='red'>读写流量拆分</font>和<font color='red'>读流量负载均衡</font>。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>数据加密</strong></td>\n<td style=\"text-align:left\">数据加密，是保证数据安全的基本手段。ShardingSphere 提供完整、透明、安全、低成本的数据加密解决方案。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>影子库</strong></td>\n<td style=\"text-align:left\">在全链路压测场景下，ShardingSphere <font color='red'>支持不同工作负载下的数据隔离，避免测试数据污染生产环境</font>。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">......</td>\n<td style=\"text-align:left\">......</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"设计哲学\"><a class=\"anchor\" href=\"#设计哲学\">#</a> 设计哲学</h2>\n<p>ShardingSphere 采用 Database Plus 设计哲学，该理念<font color='red'>致力于构建数据库上层的标准和生态</font>，在生态中补充数据库所缺失的能力。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/design_cn.png\" alt=\"img\" /></p>\n<h1 id=\"数据分片核心概念\"><a class=\"anchor\" href=\"#数据分片核心概念\">#</a> 数据分片核心概念</h1>\n<h2 id=\"表\"><a class=\"anchor\" href=\"#表\">#</a> 表</h2>\n<p>表是透明化数据分片的关键概念。 Apache ShardingSphere 通过<font color='red'>提供多样化的表类型，适配不同场景下的数据分片需求</font>。</p>\n<h3 id=\"逻辑表\"><a class=\"anchor\" href=\"#逻辑表\">#</a> 逻辑表</h3>\n<p><strong><font color='red'>相同结构的水平拆分数据库（表）的逻辑名称</font></strong>，是 SQL 中表的逻辑标识。 例：订单数据根据主键尾数拆分为 10 张表，分别是  <code>t_order_0</code>  到  <code>t_order_9</code> ，他们的逻辑表名为  <code>t_order</code> 。</p>\n<h3 id=\"真实表\"><a class=\"anchor\" href=\"#真实表\">#</a> 真实表</h3>\n<p><strong><font color='red'>在水平拆分的数据库中真实存在的物理表</font></strong>。即上个示例中的  <code>t_order_0</code>  到  <code>t_order_9</code> 。</p>\n<h3 id=\"绑定表\"><a class=\"anchor\" href=\"#绑定表\">#</a> 绑定表</h3>\n<p><strong><font color='red'>分片规则一致的一组分片表</font></strong>。使用绑定表进行多表关联查询时，必须使用<font color='red'>分片键</font>进行关联，否则会出现笛卡尔积关联或跨库关联，从而影响查询效率。</p>\n<p>例如： <code>t_order</code>  表和  <code>t_order_item</code>  表，均按照  <code>order_id</code>  分片，并且使用  <code>order_id</code>  进行关联，则此两张表互为绑定表关系。绑定表之间的多表关联查询不会出现笛卡尔积关联，关联查询效率将大大提升。举例说明，如果 SQL 为：</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">SELECT</span> i<span class=\"token punctuation\">.</span><span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> t_order o <span class=\"token keyword\">JOIN</span> t_order_item i <span class=\"token keyword\">ON</span> o<span class=\"token punctuation\">.</span>order_id<span class=\"token operator\">=</span>i<span class=\"token punctuation\">.</span>order_id <span class=\"token keyword\">WHERE</span> o<span class=\"token punctuation\">.</span>order_id <span class=\"token operator\">in</span> <span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">,</span> <span class=\"token number\">11</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>在不配置绑定表关系时，假设分片键 order_id 将数值 10 路由至第 0 片，将数值 11 路由至第 1 片，那么路由后的 SQL 应该为 4 条，它们呈现为笛卡尔积：</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">SELECT</span> i<span class=\"token punctuation\">.</span><span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> t_order_0 o <span class=\"token keyword\">JOIN</span> t_order_item_0 i <span class=\"token keyword\">ON</span> o<span class=\"token punctuation\">.</span>order_id<span class=\"token operator\">=</span>i<span class=\"token punctuation\">.</span>order_id <span class=\"token keyword\">WHERE</span> o<span class=\"token punctuation\">.</span>order_id <span class=\"token operator\">in</span> <span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">,</span> <span class=\"token number\">11</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">SELECT</span> i<span class=\"token punctuation\">.</span><span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> t_order_0 o <span class=\"token keyword\">JOIN</span> t_order_item_1 i <span class=\"token keyword\">ON</span> o<span class=\"token punctuation\">.</span>order_id<span class=\"token operator\">=</span>i<span class=\"token punctuation\">.</span>order_id <span class=\"token keyword\">WHERE</span> o<span class=\"token punctuation\">.</span>order_id <span class=\"token operator\">in</span> <span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">,</span> <span class=\"token number\">11</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">SELECT</span> i<span class=\"token punctuation\">.</span><span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> t_order_1 o <span class=\"token keyword\">JOIN</span> t_order_item_0 i <span class=\"token keyword\">ON</span> o<span class=\"token punctuation\">.</span>order_id<span class=\"token operator\">=</span>i<span class=\"token punctuation\">.</span>order_id <span class=\"token keyword\">WHERE</span> o<span class=\"token punctuation\">.</span>order_id <span class=\"token operator\">in</span> <span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">,</span> <span class=\"token number\">11</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token keyword\">SELECT</span> i<span class=\"token punctuation\">.</span><span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> t_order_1 o <span class=\"token keyword\">JOIN</span> t_order_item_1 i <span class=\"token keyword\">ON</span> o<span class=\"token punctuation\">.</span>order_id<span class=\"token operator\">=</span>i<span class=\"token punctuation\">.</span>order_id <span class=\"token keyword\">WHERE</span> o<span class=\"token punctuation\">.</span>order_id <span class=\"token operator\">in</span> <span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">,</span> <span class=\"token number\">11</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>在配置绑定表关系，并且使用  <code>order_id</code>  进行关联后，路由的 SQL 应该为 2 条：</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">SELECT</span> i<span class=\"token punctuation\">.</span><span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> t_order_0 o <span class=\"token keyword\">JOIN</span> t_order_item_0 i <span class=\"token keyword\">ON</span> o<span class=\"token punctuation\">.</span>order_id<span class=\"token operator\">=</span>i<span class=\"token punctuation\">.</span>order_id <span class=\"token keyword\">WHERE</span> o<span class=\"token punctuation\">.</span>order_id <span class=\"token operator\">in</span> <span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">,</span> <span class=\"token number\">11</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">SELECT</span> i<span class=\"token punctuation\">.</span><span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> t_order_1 o <span class=\"token keyword\">JOIN</span> t_order_item_1 i <span class=\"token keyword\">ON</span> o<span class=\"token punctuation\">.</span>order_id<span class=\"token operator\">=</span>i<span class=\"token punctuation\">.</span>order_id <span class=\"token keyword\">WHERE</span> o<span class=\"token punctuation\">.</span>order_id <span class=\"token operator\">in</span> <span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">,</span> <span class=\"token number\">11</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h3 id=\"广播表\"><a class=\"anchor\" href=\"#广播表\">#</a> 广播表</h3>\n<p><strong><font color='red'>所有的数据源中都存在的表，表结构及其数据在每个数据库中均完全一致</font></strong>。<font color='red'>适用于数据量不大且需要与海量数据的表进行关联查询的场景，例如：字典表。</font></p>\n<h3 id=\"单表\"><a class=\"anchor\" href=\"#单表\">#</a> 单表</h3>\n<p><strong><font color='red'>所有的分片数据源中仅唯一存在的表</font></strong>。<font color='red'>适用于数据量不大且无需分片的表</font>。</p>\n<p>注意：<font color='red'>符合以下条件的单表会被自动加载</font>：</p>\n<ul>\n<li>数据加密、数据脱敏等规则中显示配置的单表</li>\n<li>用户通过 ShardingSphere 执行 DDL 语句创建的单表</li>\n</ul>\n<p>其余不符合上述条件的单表，ShardingSphere 不会自动加载，用户可根据需要配置单表规则进行管理。</p>\n<h2 id=\"数据节点\"><a class=\"anchor\" href=\"#数据节点\">#</a> 数据节点</h2>\n<p><strong><font color='red'>是数据分片的最小单元，由数据源名称和真实表组成</font></strong>。例：ds_0.t_order_0。逻辑表与真实表的映射关系，可分为均匀分布和自定义分布两种形式。</p>\n<h3 id=\"均匀分布\"><a class=\"anchor\" href=\"#均匀分布\">#</a> 均匀分布</h3>\n<p>指<font color='red'>数据表在每个数据源内呈现均匀分布的态势</font>，例如：</p>\n<figure class=\"highlight txt\"><figcaption data-lang=\"txt\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>db0</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>  ├── t_order0</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>  └── t_order1</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>db1</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>  ├── t_order0</pre></td></tr><tr><td data-num=\"6\"></td><td><pre>  └── t_order1</pre></td></tr></table></figure><p>数据节点的配置如下：</p>\n<figure class=\"highlight txt\"><figcaption data-lang=\"txt\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>db0.t_order0, db0.t_order1, db1.t_order0, db1.t_order1</pre></td></tr></table></figure><h3 id=\"自定义分布\"><a class=\"anchor\" href=\"#自定义分布\">#</a> 自定义分布</h3>\n<p>指<font color='red'>数据表呈现有特定规则的分布</font>， 例如：</p>\n<figure class=\"highlight txt\"><figcaption data-lang=\"txt\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>db0</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>  ├── t_order0</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>  └── t_order1</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>db1</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>  ├── t_order2</pre></td></tr><tr><td data-num=\"6\"></td><td><pre>  ├── t_order3</pre></td></tr><tr><td data-num=\"7\"></td><td><pre>  └── t_order4</pre></td></tr></table></figure><p>数据节点的配置如下：</p>\n<figure class=\"highlight txt\"><figcaption data-lang=\"txt\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>db0.t_order0, db0.t_order1, db1.t_order2, db1.t_order3, db1.t_order4</pre></td></tr></table></figure><h2 id=\"分片\"><a class=\"anchor\" href=\"#分片\">#</a> 分片</h2>\n<h3 id=\"分片键\"><a class=\"anchor\" href=\"#分片键\">#</a> 分片键</h3>\n<p><strong><font color='red'>用于将数据库（表）<u>水平拆分</u>的数据库字段</font></strong>。例：将订单表中的订单主键的尾数取模分片，则订单主键为分片字段。 SQL 中如果无分片字段，将执行全路由，性能较差。 除了对单分片字段的支持，Apache ShardingSphere 也支持根据多个字段进行分片。</p>\n<h3 id=\"分片算法\"><a class=\"anchor\" href=\"#分片算法\">#</a> 分片算法</h3>\n<p>用于将数据分片的算法，支持  <code>=</code> 、 <code>&gt;=</code> 、 <code>&lt;=</code> 、 <code>&gt;</code> 、 <code>&lt;</code> 、 <code>BETWEEN</code>  和  <code>IN</code>  进行分片。分片算法可由开发者自行实现，也可使用 Apache ShardingSphere <font color='red'>内置的分片算法语法糖</font>，灵活度非常高。</p>\n<h3 id=\"自动化分片算法\"><a class=\"anchor\" href=\"#自动化分片算法\">#</a> 自动化分片算法</h3>\n<p>分片算法语法糖，用于便捷的托管所有数据节点，<font color='red'>使用者无需关注真实表的物理分布</font>。包括<font color='red'>取模、哈希、范围、时间</font>等常用分片算法的实现。</p>\n<h3 id=\"自定义分片算法\"><a class=\"anchor\" href=\"#自定义分片算法\">#</a> 自定义分片算法</h3>\n<p>提供接口让应用开发者自行实现与业务实现紧密相关的分片算法，并允许使用者自行管理真实表的物理分布。自定义分片算法又分为：</p>\n<ul>\n<li><font color='red'>标准分片算法</font>：用于处理使用单一键作为分片键的  <code>=</code> 、 <code>IN</code> 、 <code>BETWEEN AND</code> 、 <code>&gt;</code> 、 <code>&lt;</code> 、 <code>&gt;=</code> 、 <code>&lt;=</code>  进行分片的场景。</li>\n<li><font color='red'>复合分片算法</font>：用于处理使用多键作为分片键进行分片的场景，包含多个分片键的逻辑较复杂，需要应用开发者自行处理其中的复杂度。</li>\n<li><font color='red'>Hint 分片算法</font>：用于处理使用  <code>Hint</code>  行分片的场景。</li>\n</ul>\n<h3 id=\"分片策略\"><a class=\"anchor\" href=\"#分片策略\">#</a> 分片策略</h3>\n<p>包含分片键和分片算法，由于分片算法的独立性，将其独立抽离。真正可用于分片操作的是<font color='red'>分片键 + 分片算法</font>，也就是分片策略。</p>\n<h3 id=\"强制分片路由\"><a class=\"anchor\" href=\"#强制分片路由\">#</a> 强制分片路由</h3>\n<p>对于<font color='red'>分片字段并非由 SQL 而是其他外置条件决定的场景</font>，可使用  <code>SQL Hint</code>  注入分片值。 例：按照员工登录主键分库，而数据库中并无此字段。 SQL Hint 支持通过 Java API 和 SQL 注释两种方式使用。 详情请参见强制分片路由。</p>\n<h2 id=\"行表达式\"><a class=\"anchor\" href=\"#行表达式\">#</a> 行表达式</h2>\n<p>行表达式是 **<font color='red'>为了解决配置的简化与一体化这两个主要问题</font>**。在繁琐的数据分片规则配置中，随着数据节点的增多，大量的重复配置使得配置本身不易被维护。通过行表达式可以有效地<font color='red'>简化数据节点的配置工作量</font>。</p>\n<p>对于常见的分片算法，使用 Java 代码实现并不有助于配置的统一管理。 <font color='red'>通过<u>行表达式</u>书写分片算法，可以有效地将规则配置一同存放，更加易于浏览与存储</font>。</p>\n<p><font color='red'>行表达式作为字符串由两部分组成，分别是以字符串开头的对应 SPI 实现的 Type Name 部分和表达式部分</font>。 以  <code>&lt;GROOVY&gt;t_order_$&#123;1..3&#125;</code>  为例，字符串 <code>&lt;GROOVY&gt;</code>  部分的子字符串  <code>GROOVY</code>  为此行表达式使用的对应 SPI 实现的 Type Name，其被  <code>&lt;&gt;</code>  符号包裹来识别。而字符串  <code>t_order_$&#123;1..3&#125;</code>  为此行表达式的表达式部分。当行表达式不指定 Type Name 时，例如  <code>t_order_$&#123;1..3&#125;</code> ，<font color='red'>行表示式默认将使用  <code>InlineExpressionParser</code>  SPI 的  <code>GROOVY</code>  实现来解析表达式</font>。</p>\n<p>以下部分介绍  <code>GROOVY</code>  实现的语法规则。</p>\n<p>行表达式的使用非常直观，只需要在配置中使用  <code>$&#123; expression &#125;</code>  或  <code>$-&gt;&#123; expression &#125;</code>  标识行表达式即可。 <font color='red'>目前支持数据节点和分片算法这两个部分的配置</font>。行表达式的内容使用的是 <font color='red'>Groovy 的语法</font>，Groovy 能够支持的所有操作，行表达式均能够支持。 例如：</p>\n<p><code>$&#123;begin..end&#125;</code>  表示范围区间  <code>$&#123;[unit1, unit2, unit_x]&#125;</code>  表示枚举值。</p>\n<p>行表达式中如果出现连续多个  <code>$&#123; expression &#125;</code>  或  <code>$-&gt;&#123; expression &#125;</code>  表达式，整个表达式最终的结果将会根据每个子表达式的结果进行<font color='red'>笛卡尔组合</font>。</p>\n<p>例如，以下行表达式：</p>\n<figure class=\"highlight txt\"><figcaption data-lang=\"txt\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>$&#123;['online', 'offline']&#125;_table$&#123;1..3&#125;</pre></td></tr></table></figure><p>最终会解析为：</p>\n<figure class=\"highlight txt\"><figcaption data-lang=\"txt\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>online_table1, online_table2, online_table3, offline_table1, offline_table2, offline_table3</pre></td></tr></table></figure><h2 id=\"分布式主键\"><a class=\"anchor\" href=\"#分布式主键\">#</a> 分布式主键</h2>\n<p>传统数据库软件开发中，主键自动生成技术是基本需求。而各个数据库对于该需求也提供了相应的支持，比如 MySQL 的自增键，Oracle 的自增序列等。 <font color='red'>数据分片后，不同数据节点生成全局唯一主键是非常棘手的问题。同一个逻辑表内的不同实际表之间的自增键由于无法互相感知而产生重复主键。</font>虽然可通过约束自增主键初始值和步长的方式避免碰撞，但需引入额外的运维规则，使解决方案缺乏完整性和可扩展性。</p>\n<p>目前有许多第三方解决方案可以完美解决这个问题，如 UUID 等依靠特定算法自生成不重复键，或者通过引入主键生成服务等。为了方便用户使用、满足不同用户不同使用场景的需求， <font color='red'>Apache ShardingSphere 不仅提供了<strong>内置的分布式主键生成器</strong>，例如  <code>UUID</code> 、 <code>SNOWFLAKE</code> ，还抽离出<strong>分布式主键生成器的接口</strong>，方便用户自行实现自定义的自增主键生成器</font>。</p>\n<h1 id=\"动手实现数据分表\"><a class=\"anchor\" href=\"#动手实现数据分表\">#</a> 动手实现数据分表</h1>\n<p>下文代码示例地址：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRlZS5jb20vbmFnZW9mZmVyL3NwcmluZ2Jvb3QtbGFkZGVyL3RyZWUvbWFpbi9zaGFyZGluZ3NwaGVyZS01eC9zaGFyZGluZ3NwaGVyZS01eC1zaGFyZGluZw==\">SpringBoot-Ladder ShardingSphere 5.x 分库分表示例程序 </span>。</p>\n<h2 id=\"准备数据库表\"><a class=\"anchor\" href=\"#准备数据库表\">#</a> 准备数据库 &amp; 表</h2>\n<p>MySQL 创建数据库  <code>user_0</code> ，创建后，执行以下数据库表 <code>t_user_0</code> 、 <code>t_user_1</code>  的创建语句。</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">TABLE</span> <span class=\"token identifier\"><span class=\"token punctuation\">`</span>t_user_0<span class=\"token punctuation\">`</span></span> <span class=\"token punctuation\">(</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>  <span class=\"token identifier\"><span class=\"token punctuation\">`</span>id<span class=\"token punctuation\">`</span></span> <span class=\"token keyword\">bigint</span><span class=\"token punctuation\">(</span><span class=\"token number\">20</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">unsigned</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span> <span class=\"token keyword\">AUTO_INCREMENT</span> <span class=\"token keyword\">COMMENT</span> <span class=\"token string\">'ID'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>  <span class=\"token identifier\"><span class=\"token punctuation\">`</span>username<span class=\"token punctuation\">`</span></span> <span class=\"token keyword\">varchar</span><span class=\"token punctuation\">(</span><span class=\"token number\">256</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">COLLATE</span> utf8mb4_unicode_ci <span class=\"token keyword\">DEFAULT</span> <span class=\"token boolean\">NULL</span> <span class=\"token keyword\">COMMENT</span> <span class=\"token string\">'用户名'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>  <span class=\"token identifier\"><span class=\"token punctuation\">`</span>password<span class=\"token punctuation\">`</span></span> <span class=\"token keyword\">varchar</span><span class=\"token punctuation\">(</span><span class=\"token number\">512</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">COLLATE</span> utf8mb4_unicode_ci <span class=\"token keyword\">DEFAULT</span> <span class=\"token boolean\">NULL</span> <span class=\"token keyword\">COMMENT</span> <span class=\"token string\">'密码'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>  <span class=\"token identifier\"><span class=\"token punctuation\">`</span>real_name<span class=\"token punctuation\">`</span></span> <span class=\"token keyword\">varchar</span><span class=\"token punctuation\">(</span><span class=\"token number\">256</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">COLLATE</span> utf8mb4_unicode_ci <span class=\"token keyword\">DEFAULT</span> <span class=\"token boolean\">NULL</span> <span class=\"token keyword\">COMMENT</span> <span class=\"token string\">'真实姓名'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>  <span class=\"token identifier\"><span class=\"token punctuation\">`</span>region<span class=\"token punctuation\">`</span></span> <span class=\"token keyword\">varchar</span><span class=\"token punctuation\">(</span><span class=\"token number\">64</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">COLLATE</span> utf8mb4_unicode_ci <span class=\"token keyword\">DEFAULT</span> <span class=\"token string\">'0'</span> <span class=\"token keyword\">COMMENT</span> <span class=\"token string\">'国家/地区'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>  <span class=\"token identifier\"><span class=\"token punctuation\">`</span>id_type<span class=\"token punctuation\">`</span></span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">DEFAULT</span> <span class=\"token boolean\">NULL</span> <span class=\"token keyword\">COMMENT</span> <span class=\"token string\">'证件类型'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>  <span class=\"token identifier\"><span class=\"token punctuation\">`</span>id_card<span class=\"token punctuation\">`</span></span> <span class=\"token keyword\">varchar</span><span class=\"token punctuation\">(</span><span class=\"token number\">256</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">COLLATE</span> utf8mb4_unicode_ci <span class=\"token keyword\">DEFAULT</span> <span class=\"token boolean\">NULL</span> <span class=\"token keyword\">COMMENT</span> <span class=\"token string\">'证件号'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>  <span class=\"token identifier\"><span class=\"token punctuation\">`</span>phone<span class=\"token punctuation\">`</span></span> <span class=\"token keyword\">varchar</span><span class=\"token punctuation\">(</span><span class=\"token number\">128</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">COLLATE</span> utf8mb4_unicode_ci <span class=\"token keyword\">DEFAULT</span> <span class=\"token boolean\">NULL</span> <span class=\"token keyword\">COMMENT</span> <span class=\"token string\">'手机号'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>  <span class=\"token identifier\"><span class=\"token punctuation\">`</span>telephone<span class=\"token punctuation\">`</span></span> <span class=\"token keyword\">varchar</span><span class=\"token punctuation\">(</span><span class=\"token number\">128</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">COLLATE</span> utf8mb4_unicode_ci <span class=\"token keyword\">DEFAULT</span> <span class=\"token boolean\">NULL</span> <span class=\"token keyword\">COMMENT</span> <span class=\"token string\">'固定电话'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>  <span class=\"token identifier\"><span class=\"token punctuation\">`</span>mail<span class=\"token punctuation\">`</span></span> <span class=\"token keyword\">varchar</span><span class=\"token punctuation\">(</span><span class=\"token number\">256</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">COLLATE</span> utf8mb4_unicode_ci <span class=\"token keyword\">DEFAULT</span> <span class=\"token boolean\">NULL</span> <span class=\"token keyword\">COMMENT</span> <span class=\"token string\">'邮箱'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>  <span class=\"token identifier\"><span class=\"token punctuation\">`</span>user_type<span class=\"token punctuation\">`</span></span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">DEFAULT</span> <span class=\"token boolean\">NULL</span> <span class=\"token keyword\">COMMENT</span> <span class=\"token string\">'旅客类型'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>  <span class=\"token identifier\"><span class=\"token punctuation\">`</span>verify_status<span class=\"token punctuation\">`</span></span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">DEFAULT</span> <span class=\"token boolean\">NULL</span> <span class=\"token keyword\">COMMENT</span> <span class=\"token string\">'审核状态'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>  <span class=\"token identifier\"><span class=\"token punctuation\">`</span>post_code<span class=\"token punctuation\">`</span></span> <span class=\"token keyword\">varchar</span><span class=\"token punctuation\">(</span><span class=\"token number\">64</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">COLLATE</span> utf8mb4_unicode_ci <span class=\"token keyword\">DEFAULT</span> <span class=\"token boolean\">NULL</span> <span class=\"token keyword\">COMMENT</span> <span class=\"token string\">'邮编'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>  <span class=\"token identifier\"><span class=\"token punctuation\">`</span>address<span class=\"token punctuation\">`</span></span> <span class=\"token keyword\">varchar</span><span class=\"token punctuation\">(</span><span class=\"token number\">1024</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">COLLATE</span> utf8mb4_unicode_ci <span class=\"token keyword\">DEFAULT</span> <span class=\"token boolean\">NULL</span> <span class=\"token keyword\">COMMENT</span> <span class=\"token string\">'地址'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>  <span class=\"token identifier\"><span class=\"token punctuation\">`</span>deletion_time<span class=\"token punctuation\">`</span></span> <span class=\"token keyword\">bigint</span><span class=\"token punctuation\">(</span><span class=\"token number\">20</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">DEFAULT</span> <span class=\"token string\">'0'</span> <span class=\"token keyword\">COMMENT</span> <span class=\"token string\">'注销时间戳'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>  <span class=\"token identifier\"><span class=\"token punctuation\">`</span>create_time<span class=\"token punctuation\">`</span></span> <span class=\"token keyword\">datetime</span> <span class=\"token keyword\">DEFAULT</span> <span class=\"token boolean\">NULL</span> <span class=\"token keyword\">COMMENT</span> <span class=\"token string\">'创建时间'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>  <span class=\"token identifier\"><span class=\"token punctuation\">`</span>update_time<span class=\"token punctuation\">`</span></span> <span class=\"token keyword\">datetime</span> <span class=\"token keyword\">DEFAULT</span> <span class=\"token boolean\">NULL</span> <span class=\"token keyword\">COMMENT</span> <span class=\"token string\">'修改时间'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>  <span class=\"token identifier\"><span class=\"token punctuation\">`</span>del_flag<span class=\"token punctuation\">`</span></span> <span class=\"token keyword\">tinyint</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">DEFAULT</span> <span class=\"token boolean\">NULL</span> <span class=\"token keyword\">COMMENT</span> <span class=\"token string\">'删除标识'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>  <span class=\"token keyword\">PRIMARY</span> <span class=\"token keyword\">KEY</span> <span class=\"token punctuation\">(</span><span class=\"token identifier\"><span class=\"token punctuation\">`</span>id<span class=\"token punctuation\">`</span></span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre><span class=\"token punctuation\">)</span> <span class=\"token keyword\">ENGINE</span><span class=\"token operator\">=</span><span class=\"token keyword\">InnoDB</span> <span class=\"token keyword\">AUTO_INCREMENT</span><span class=\"token operator\">=</span><span class=\"token number\">1695720264773</span> <span class=\"token keyword\">DEFAULT</span> <span class=\"token keyword\">CHARSET</span><span class=\"token operator\">=</span>utf8mb4 <span class=\"token keyword\">COLLATE</span><span class=\"token operator\">=</span>utf8mb4_unicode_ci <span class=\"token keyword\">COMMENT</span><span class=\"token operator\">=</span><span class=\"token string\">'用户表'</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre></pre></td></tr><tr><td data-num=\"23\"></td><td><pre><span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">TABLE</span> <span class=\"token identifier\"><span class=\"token punctuation\">`</span>t_user_1<span class=\"token punctuation\">`</span></span> <span class=\"token punctuation\">(</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>  <span class=\"token identifier\"><span class=\"token punctuation\">`</span>id<span class=\"token punctuation\">`</span></span> <span class=\"token keyword\">bigint</span><span class=\"token punctuation\">(</span><span class=\"token number\">20</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">unsigned</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span> <span class=\"token keyword\">AUTO_INCREMENT</span> <span class=\"token keyword\">COMMENT</span> <span class=\"token string\">'ID'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>  <span class=\"token identifier\"><span class=\"token punctuation\">`</span>username<span class=\"token punctuation\">`</span></span> <span class=\"token keyword\">varchar</span><span class=\"token punctuation\">(</span><span class=\"token number\">256</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">COLLATE</span> utf8mb4_unicode_ci <span class=\"token keyword\">DEFAULT</span> <span class=\"token boolean\">NULL</span> <span class=\"token keyword\">COMMENT</span> <span class=\"token string\">'用户名'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>  <span class=\"token identifier\"><span class=\"token punctuation\">`</span>password<span class=\"token punctuation\">`</span></span> <span class=\"token keyword\">varchar</span><span class=\"token punctuation\">(</span><span class=\"token number\">512</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">COLLATE</span> utf8mb4_unicode_ci <span class=\"token keyword\">DEFAULT</span> <span class=\"token boolean\">NULL</span> <span class=\"token keyword\">COMMENT</span> <span class=\"token string\">'密码'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>  <span class=\"token identifier\"><span class=\"token punctuation\">`</span>real_name<span class=\"token punctuation\">`</span></span> <span class=\"token keyword\">varchar</span><span class=\"token punctuation\">(</span><span class=\"token number\">256</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">COLLATE</span> utf8mb4_unicode_ci <span class=\"token keyword\">DEFAULT</span> <span class=\"token boolean\">NULL</span> <span class=\"token keyword\">COMMENT</span> <span class=\"token string\">'真实姓名'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>  <span class=\"token identifier\"><span class=\"token punctuation\">`</span>region<span class=\"token punctuation\">`</span></span> <span class=\"token keyword\">varchar</span><span class=\"token punctuation\">(</span><span class=\"token number\">64</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">COLLATE</span> utf8mb4_unicode_ci <span class=\"token keyword\">DEFAULT</span> <span class=\"token string\">'0'</span> <span class=\"token keyword\">COMMENT</span> <span class=\"token string\">'国家/地区'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>  <span class=\"token identifier\"><span class=\"token punctuation\">`</span>id_type<span class=\"token punctuation\">`</span></span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">DEFAULT</span> <span class=\"token boolean\">NULL</span> <span class=\"token keyword\">COMMENT</span> <span class=\"token string\">'证件类型'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>  <span class=\"token identifier\"><span class=\"token punctuation\">`</span>id_card<span class=\"token punctuation\">`</span></span> <span class=\"token keyword\">varchar</span><span class=\"token punctuation\">(</span><span class=\"token number\">256</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">COLLATE</span> utf8mb4_unicode_ci <span class=\"token keyword\">DEFAULT</span> <span class=\"token boolean\">NULL</span> <span class=\"token keyword\">COMMENT</span> <span class=\"token string\">'证件号'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre>  <span class=\"token identifier\"><span class=\"token punctuation\">`</span>phone<span class=\"token punctuation\">`</span></span> <span class=\"token keyword\">varchar</span><span class=\"token punctuation\">(</span><span class=\"token number\">128</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">COLLATE</span> utf8mb4_unicode_ci <span class=\"token keyword\">DEFAULT</span> <span class=\"token boolean\">NULL</span> <span class=\"token keyword\">COMMENT</span> <span class=\"token string\">'手机号'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"32\"></td><td><pre>  <span class=\"token identifier\"><span class=\"token punctuation\">`</span>telephone<span class=\"token punctuation\">`</span></span> <span class=\"token keyword\">varchar</span><span class=\"token punctuation\">(</span><span class=\"token number\">128</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">COLLATE</span> utf8mb4_unicode_ci <span class=\"token keyword\">DEFAULT</span> <span class=\"token boolean\">NULL</span> <span class=\"token keyword\">COMMENT</span> <span class=\"token string\">'固定电话'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"33\"></td><td><pre>  <span class=\"token identifier\"><span class=\"token punctuation\">`</span>mail<span class=\"token punctuation\">`</span></span> <span class=\"token keyword\">varchar</span><span class=\"token punctuation\">(</span><span class=\"token number\">256</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">COLLATE</span> utf8mb4_unicode_ci <span class=\"token keyword\">DEFAULT</span> <span class=\"token boolean\">NULL</span> <span class=\"token keyword\">COMMENT</span> <span class=\"token string\">'邮箱'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"34\"></td><td><pre>  <span class=\"token identifier\"><span class=\"token punctuation\">`</span>user_type<span class=\"token punctuation\">`</span></span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">DEFAULT</span> <span class=\"token boolean\">NULL</span> <span class=\"token keyword\">COMMENT</span> <span class=\"token string\">'旅客类型'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"35\"></td><td><pre>  <span class=\"token identifier\"><span class=\"token punctuation\">`</span>verify_status<span class=\"token punctuation\">`</span></span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">DEFAULT</span> <span class=\"token boolean\">NULL</span> <span class=\"token keyword\">COMMENT</span> <span class=\"token string\">'审核状态'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"36\"></td><td><pre>  <span class=\"token identifier\"><span class=\"token punctuation\">`</span>post_code<span class=\"token punctuation\">`</span></span> <span class=\"token keyword\">varchar</span><span class=\"token punctuation\">(</span><span class=\"token number\">64</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">COLLATE</span> utf8mb4_unicode_ci <span class=\"token keyword\">DEFAULT</span> <span class=\"token boolean\">NULL</span> <span class=\"token keyword\">COMMENT</span> <span class=\"token string\">'邮编'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"37\"></td><td><pre>  <span class=\"token identifier\"><span class=\"token punctuation\">`</span>address<span class=\"token punctuation\">`</span></span> <span class=\"token keyword\">varchar</span><span class=\"token punctuation\">(</span><span class=\"token number\">1024</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">COLLATE</span> utf8mb4_unicode_ci <span class=\"token keyword\">DEFAULT</span> <span class=\"token boolean\">NULL</span> <span class=\"token keyword\">COMMENT</span> <span class=\"token string\">'地址'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"38\"></td><td><pre>  <span class=\"token identifier\"><span class=\"token punctuation\">`</span>deletion_time<span class=\"token punctuation\">`</span></span> <span class=\"token keyword\">bigint</span><span class=\"token punctuation\">(</span><span class=\"token number\">20</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">DEFAULT</span> <span class=\"token string\">'0'</span> <span class=\"token keyword\">COMMENT</span> <span class=\"token string\">'注销时间戳'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"39\"></td><td><pre>  <span class=\"token identifier\"><span class=\"token punctuation\">`</span>create_time<span class=\"token punctuation\">`</span></span> <span class=\"token keyword\">datetime</span> <span class=\"token keyword\">DEFAULT</span> <span class=\"token boolean\">NULL</span> <span class=\"token keyword\">COMMENT</span> <span class=\"token string\">'创建时间'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"40\"></td><td><pre>  <span class=\"token identifier\"><span class=\"token punctuation\">`</span>update_time<span class=\"token punctuation\">`</span></span> <span class=\"token keyword\">datetime</span> <span class=\"token keyword\">DEFAULT</span> <span class=\"token boolean\">NULL</span> <span class=\"token keyword\">COMMENT</span> <span class=\"token string\">'修改时间'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"41\"></td><td><pre>  <span class=\"token identifier\"><span class=\"token punctuation\">`</span>del_flag<span class=\"token punctuation\">`</span></span> <span class=\"token keyword\">tinyint</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">DEFAULT</span> <span class=\"token boolean\">NULL</span> <span class=\"token keyword\">COMMENT</span> <span class=\"token string\">'删除标识'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"42\"></td><td><pre>  <span class=\"token keyword\">PRIMARY</span> <span class=\"token keyword\">KEY</span> <span class=\"token punctuation\">(</span><span class=\"token identifier\"><span class=\"token punctuation\">`</span>id<span class=\"token punctuation\">`</span></span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"43\"></td><td><pre><span class=\"token punctuation\">)</span> <span class=\"token keyword\">ENGINE</span><span class=\"token operator\">=</span><span class=\"token keyword\">InnoDB</span> <span class=\"token keyword\">AUTO_INCREMENT</span><span class=\"token operator\">=</span><span class=\"token number\">1695720264420</span> <span class=\"token keyword\">DEFAULT</span> <span class=\"token keyword\">CHARSET</span><span class=\"token operator\">=</span>utf8mb4 <span class=\"token keyword\">COLLATE</span><span class=\"token operator\">=</span>utf8mb4_unicode_ci <span class=\"token keyword\">COMMENT</span><span class=\"token operator\">=</span><span class=\"token string\">'用户表'</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h2 id=\"开发用户持久层代码\"><a class=\"anchor\" href=\"#开发用户持久层代码\">#</a> 开发用户持久层代码</h2>\n<p>引入 MyBatisPlus 以及和 MySQL 相关依赖，开发普通的用户持久层代码逻辑。</p>\n<figure class=\"highlight xml\"><figcaption data-lang=\"XML\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>dependencies</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>dependency</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>groupId</span><span class=\"token punctuation\">></span></span>com.baomidou<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>groupId</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>artifactId</span><span class=\"token punctuation\">></span></span>mybatis-plus-boot-starter<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>artifactId</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>version</span><span class=\"token punctuation\">></span></span>$&#123;mybatis-plus.version&#125;<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>version</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>dependency</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>dependency</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>groupId</span><span class=\"token punctuation\">></span></span>com.mysql<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>groupId</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>artifactId</span><span class=\"token punctuation\">></span></span>mysql-connector-j<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>artifactId</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>scope</span><span class=\"token punctuation\">></span></span>runtime<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>scope</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>dependency</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>dependency</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>groupId</span><span class=\"token punctuation\">></span></span>org.springframework.boot<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>groupId</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>artifactId</span><span class=\"token punctuation\">></span></span>spring-boot-starter-jdbc<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>artifactId</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>dependency</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>dependencies</span><span class=\"token punctuation\">></span></span></pre></td></tr></table></figure><p>创建用户持久层实体。</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">com<span class=\"token punctuation\">.</span>baomidou<span class=\"token punctuation\">.</span>mybatisplus<span class=\"token punctuation\">.</span>annotation<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">FieldFill</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">com<span class=\"token punctuation\">.</span>baomidou<span class=\"token punctuation\">.</span>mybatisplus<span class=\"token punctuation\">.</span>annotation<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">TableField</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">com<span class=\"token punctuation\">.</span>baomidou<span class=\"token punctuation\">.</span>mybatisplus<span class=\"token punctuation\">.</span>annotation<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">TableName</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">lombok<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">AllArgsConstructor</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">lombok<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">Builder</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">lombok<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">Data</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">lombok<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">NoArgsConstructor</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">java<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">Date</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token comment\">/**</pre></td></tr><tr><td data-num=\"12\"></td><td><pre> * 用户信息实体</pre></td></tr><tr><td data-num=\"13\"></td><td><pre> *</pre></td></tr><tr><td data-num=\"14\"></td><td><pre> * @公众号：马丁玩编程，回复：加群，添加马哥微信（备注：ladder）获取更多项目资料</pre></td></tr><tr><td data-num=\"15\"></td><td><pre> */</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre><span class=\"token annotation punctuation\">@Data</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre><span class=\"token annotation punctuation\">@NoArgsConstructor</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre><span class=\"token annotation punctuation\">@AllArgsConstructor</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre><span class=\"token annotation punctuation\">@Builder</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre><span class=\"token annotation punctuation\">@TableName</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"t_user\"</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">UserDO</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>    <span class=\"token comment\">/**</pre></td></tr><tr><td data-num=\"24\"></td><td><pre>     * id</pre></td></tr><tr><td data-num=\"25\"></td><td><pre>     */</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>    <span class=\"token keyword\">private</span> <span class=\"token class-name\">Long</span> id<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>    <span class=\"token comment\">/**</pre></td></tr><tr><td data-num=\"29\"></td><td><pre>     * 用户名</pre></td></tr><tr><td data-num=\"30\"></td><td><pre>     */</span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre>    <span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> username<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"32\"></td><td><pre></pre></td></tr><tr><td data-num=\"33\"></td><td><pre>    <span class=\"token comment\">/**</pre></td></tr><tr><td data-num=\"34\"></td><td><pre>     * 密码</pre></td></tr><tr><td data-num=\"35\"></td><td><pre>     */</span></pre></td></tr><tr><td data-num=\"36\"></td><td><pre>    <span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> password<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"37\"></td><td><pre></pre></td></tr><tr><td data-num=\"38\"></td><td><pre>    <span class=\"token comment\">/**</pre></td></tr><tr><td data-num=\"39\"></td><td><pre>     * 真实姓名</pre></td></tr><tr><td data-num=\"40\"></td><td><pre>     */</span></pre></td></tr><tr><td data-num=\"41\"></td><td><pre>    <span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> realName<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"42\"></td><td><pre></pre></td></tr><tr><td data-num=\"43\"></td><td><pre>    <span class=\"token comment\">/**</pre></td></tr><tr><td data-num=\"44\"></td><td><pre>     * 国家 / 地区</pre></td></tr><tr><td data-num=\"45\"></td><td><pre>     */</span></pre></td></tr><tr><td data-num=\"46\"></td><td><pre>    <span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> region<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"47\"></td><td><pre></pre></td></tr><tr><td data-num=\"48\"></td><td><pre>    <span class=\"token comment\">/**</pre></td></tr><tr><td data-num=\"49\"></td><td><pre>     * 证件类型</pre></td></tr><tr><td data-num=\"50\"></td><td><pre>     */</span></pre></td></tr><tr><td data-num=\"51\"></td><td><pre>    <span class=\"token keyword\">private</span> <span class=\"token class-name\">Integer</span> idType<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"52\"></td><td><pre></pre></td></tr><tr><td data-num=\"53\"></td><td><pre>    <span class=\"token comment\">/**</pre></td></tr><tr><td data-num=\"54\"></td><td><pre>     * 证件号</pre></td></tr><tr><td data-num=\"55\"></td><td><pre>     */</span></pre></td></tr><tr><td data-num=\"56\"></td><td><pre>    <span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> idCard<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"57\"></td><td><pre></pre></td></tr><tr><td data-num=\"58\"></td><td><pre>    <span class=\"token comment\">/**</pre></td></tr><tr><td data-num=\"59\"></td><td><pre>     * 手机号</pre></td></tr><tr><td data-num=\"60\"></td><td><pre>     */</span></pre></td></tr><tr><td data-num=\"61\"></td><td><pre>    <span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> phone<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"62\"></td><td><pre></pre></td></tr><tr><td data-num=\"63\"></td><td><pre>    <span class=\"token comment\">/**</pre></td></tr><tr><td data-num=\"64\"></td><td><pre>     * 固定电话</pre></td></tr><tr><td data-num=\"65\"></td><td><pre>     */</span></pre></td></tr><tr><td data-num=\"66\"></td><td><pre>    <span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> telephone<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"67\"></td><td><pre></pre></td></tr><tr><td data-num=\"68\"></td><td><pre>    <span class=\"token comment\">/**</pre></td></tr><tr><td data-num=\"69\"></td><td><pre>     * 邮箱</pre></td></tr><tr><td data-num=\"70\"></td><td><pre>     */</span></pre></td></tr><tr><td data-num=\"71\"></td><td><pre>    <span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> mail<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"72\"></td><td><pre></pre></td></tr><tr><td data-num=\"73\"></td><td><pre>    <span class=\"token comment\">/**</pre></td></tr><tr><td data-num=\"74\"></td><td><pre>     * 旅客类型</pre></td></tr><tr><td data-num=\"75\"></td><td><pre>     */</span></pre></td></tr><tr><td data-num=\"76\"></td><td><pre>    <span class=\"token keyword\">private</span> <span class=\"token class-name\">Integer</span> userType<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"77\"></td><td><pre></pre></td></tr><tr><td data-num=\"78\"></td><td><pre>    <span class=\"token comment\">/**</pre></td></tr><tr><td data-num=\"79\"></td><td><pre>     * 审核状态</pre></td></tr><tr><td data-num=\"80\"></td><td><pre>     */</span></pre></td></tr><tr><td data-num=\"81\"></td><td><pre>    <span class=\"token keyword\">private</span> <span class=\"token class-name\">Integer</span> verifyStatus<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"82\"></td><td><pre></pre></td></tr><tr><td data-num=\"83\"></td><td><pre>    <span class=\"token comment\">/**</pre></td></tr><tr><td data-num=\"84\"></td><td><pre>     * 邮编</pre></td></tr><tr><td data-num=\"85\"></td><td><pre>     */</span></pre></td></tr><tr><td data-num=\"86\"></td><td><pre>    <span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> postCode<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"87\"></td><td><pre></pre></td></tr><tr><td data-num=\"88\"></td><td><pre>    <span class=\"token comment\">/**</pre></td></tr><tr><td data-num=\"89\"></td><td><pre>     * 地址</pre></td></tr><tr><td data-num=\"90\"></td><td><pre>     */</span></pre></td></tr><tr><td data-num=\"91\"></td><td><pre>    <span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> address<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"92\"></td><td><pre></pre></td></tr><tr><td data-num=\"93\"></td><td><pre>    <span class=\"token comment\">/**</pre></td></tr><tr><td data-num=\"94\"></td><td><pre>     * 注销时间戳</pre></td></tr><tr><td data-num=\"95\"></td><td><pre>     */</span></pre></td></tr><tr><td data-num=\"96\"></td><td><pre>    <span class=\"token keyword\">private</span> <span class=\"token class-name\">Long</span> deletionTime<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"97\"></td><td><pre></pre></td></tr><tr><td data-num=\"98\"></td><td><pre>    <span class=\"token comment\">/**</pre></td></tr><tr><td data-num=\"99\"></td><td><pre>     * 创建时间</pre></td></tr><tr><td data-num=\"100\"></td><td><pre>     */</span></pre></td></tr><tr><td data-num=\"101\"></td><td><pre>    <span class=\"token annotation punctuation\">@TableField</span><span class=\"token punctuation\">(</span>fill <span class=\"token operator\">=</span> <span class=\"token class-name\">FieldFill</span><span class=\"token punctuation\">.</span><span class=\"token constant\">INSERT</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"102\"></td><td><pre>    <span class=\"token keyword\">private</span> <span class=\"token class-name\">Date</span> createTime<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"103\"></td><td><pre></pre></td></tr><tr><td data-num=\"104\"></td><td><pre>    <span class=\"token comment\">/**</pre></td></tr><tr><td data-num=\"105\"></td><td><pre>     * 修改时间</pre></td></tr><tr><td data-num=\"106\"></td><td><pre>     */</span></pre></td></tr><tr><td data-num=\"107\"></td><td><pre>    <span class=\"token annotation punctuation\">@TableField</span><span class=\"token punctuation\">(</span>fill <span class=\"token operator\">=</span> <span class=\"token class-name\">FieldFill</span><span class=\"token punctuation\">.</span><span class=\"token constant\">INSERT_UPDATE</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"108\"></td><td><pre>    <span class=\"token keyword\">private</span> <span class=\"token class-name\">Date</span> updateTime<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"109\"></td><td><pre></pre></td></tr><tr><td data-num=\"110\"></td><td><pre>    <span class=\"token comment\">/**</pre></td></tr><tr><td data-num=\"111\"></td><td><pre>     * 删除标志</pre></td></tr><tr><td data-num=\"112\"></td><td><pre>     */</span></pre></td></tr><tr><td data-num=\"113\"></td><td><pre>    <span class=\"token annotation punctuation\">@TableField</span><span class=\"token punctuation\">(</span>fill <span class=\"token operator\">=</span> <span class=\"token class-name\">FieldFill</span><span class=\"token punctuation\">.</span><span class=\"token constant\">INSERT</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"114\"></td><td><pre>    <span class=\"token keyword\">private</span> <span class=\"token class-name\">Integer</span> delFlag<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"115\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>创建用户实体对应的 MyBatis Mapper 持久层接口。</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">com<span class=\"token punctuation\">.</span>baomidou<span class=\"token punctuation\">.</span>mybatisplus<span class=\"token punctuation\">.</span>core<span class=\"token punctuation\">.</span>mapper<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">BaseMapper</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">com<span class=\"token punctuation\">.</span>nageoffer<span class=\"token punctuation\">.</span>springbootladder<span class=\"token punctuation\">.</span>shardingspherecore<span class=\"token punctuation\">.</span>dao<span class=\"token punctuation\">.</span>entity<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">UserDO</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token comment\">/**</pre></td></tr><tr><td data-num=\"5\"></td><td><pre> * 用户信息持久层</pre></td></tr><tr><td data-num=\"6\"></td><td><pre> *</pre></td></tr><tr><td data-num=\"7\"></td><td><pre> * @公众号：马丁玩编程，回复：加群，添加马哥微信（备注：ladder）获取更多项目资料</pre></td></tr><tr><td data-num=\"8\"></td><td><pre> */</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">interface</span> <span class=\"token class-name\">UserMapper</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">BaseMapper</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">UserDO</span><span class=\"token punctuation\">></span></span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>创建用户接口，为了避免重复代码，这里直接继承 MyBatisPlus 的 IService 通用接口，实现增删改查。</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">com<span class=\"token punctuation\">.</span>baomidou<span class=\"token punctuation\">.</span>mybatisplus<span class=\"token punctuation\">.</span>extension<span class=\"token punctuation\">.</span>service<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">IService</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">com<span class=\"token punctuation\">.</span>nageoffer<span class=\"token punctuation\">.</span>springbootladder<span class=\"token punctuation\">.</span>shardingspherecore<span class=\"token punctuation\">.</span>dao<span class=\"token punctuation\">.</span>entity<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">UserDO</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token comment\">/**</pre></td></tr><tr><td data-num=\"5\"></td><td><pre> * 用户信息接口层</pre></td></tr><tr><td data-num=\"6\"></td><td><pre> *</pre></td></tr><tr><td data-num=\"7\"></td><td><pre> * @公众号：马丁玩编程，回复：加群，添加马哥微信（备注：ladder）获取更多项目资料</pre></td></tr><tr><td data-num=\"8\"></td><td><pre> */</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">interface</span> <span class=\"token class-name\">UserService</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">IService</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">UserDO</span><span class=\"token punctuation\">></span></span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">com<span class=\"token punctuation\">.</span>baomidou<span class=\"token punctuation\">.</span>mybatisplus<span class=\"token punctuation\">.</span>extension<span class=\"token punctuation\">.</span>service<span class=\"token punctuation\">.</span>impl<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">ServiceImpl</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">com<span class=\"token punctuation\">.</span>nageoffer<span class=\"token punctuation\">.</span>springbootladder<span class=\"token punctuation\">.</span>shardingspherecore<span class=\"token punctuation\">.</span>dao<span class=\"token punctuation\">.</span>entity<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">UserDO</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">com<span class=\"token punctuation\">.</span>nageoffer<span class=\"token punctuation\">.</span>springbootladder<span class=\"token punctuation\">.</span>shardingspherecore<span class=\"token punctuation\">.</span>dao<span class=\"token punctuation\">.</span>mapper<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">UserMapper</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">org<span class=\"token punctuation\">.</span>springframework<span class=\"token punctuation\">.</span>stereotype<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">Component</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre></pre></td></tr><tr><td data-num=\"17\"></td><td><pre><span class=\"token comment\">/**</pre></td></tr><tr><td data-num=\"18\"></td><td><pre> * 用户信息接口实现层</pre></td></tr><tr><td data-num=\"19\"></td><td><pre> *</pre></td></tr><tr><td data-num=\"20\"></td><td><pre> * @公众号：马丁玩编程，回复：加群，添加马哥微信（备注：ladder）获取更多项目资料</pre></td></tr><tr><td data-num=\"21\"></td><td><pre> */</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre><span class=\"token annotation punctuation\">@Component</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">UserServiceImpl</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">ServiceImpl</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">UserMapper</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">UserDO</span><span class=\"token punctuation\">></span></span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">UserService</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h2 id=\"引入-shardingsphere-jdbc\"><a class=\"anchor\" href=\"#引入-shardingsphere-jdbc\">#</a> 引入 ShardingSphere-JDBC</h2>\n<p>引入 ShardingSphere-JDBC 的 Maven Jar 包，这里使用 5.3.2。</p>\n<figure class=\"highlight xml\"><figcaption data-lang=\"XML\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>dependency</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>groupId</span><span class=\"token punctuation\">></span></span>org.apache.shardingsphere<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>groupId</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>artifactId</span><span class=\"token punctuation\">></span></span>shardingsphere-jdbc-core<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>artifactId</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>version</span><span class=\"token punctuation\">></span></span>5.3.2<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>version</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>dependency</span><span class=\"token punctuation\">></span></span></pre></td></tr></table></figure><p>SpringBoot 和 ShardingSphere 配置文件的关联方式详情见下图。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230926175048282.png\" alt=\"img\" /></p>\n<p>5.x.x 版本后，ShardingSphere-JDBC 的配置文件配置方式有了大的变化，从之前和 Spring 耦合变更为完全解耦，大家需要明确。</p>\n<figure class=\"highlight yaml\"><figcaption data-lang=\"YAML\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token key atrule\">server</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>  <span class=\"token key atrule\">port</span><span class=\"token punctuation\">:</span> <span class=\"token number\">6060</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token key atrule\">spring</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>  <span class=\"token key atrule\">datasource</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token comment\"># 指定 ShardingSphere 自定义驱动类</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token key atrule\">driver-class-name</span><span class=\"token punctuation\">:</span> org.apache.shardingsphere.driver.ShardingSphereDriver</pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token comment\"># 指定 ShardingSphere 自定义配置文件路径地址</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token key atrule\">url</span><span class=\"token punctuation\">:</span> jdbc<span class=\"token punctuation\">:</span>shardingsphere<span class=\"token punctuation\">:</span>classpath<span class=\"token punctuation\">:</span>shardingsphere<span class=\"token punctuation\">-</span>config.yaml</pre></td></tr></table></figure><p>创建 ShardingSphere 自定义分片配置文件  <code>shardingsphere-config.yaml</code> 。</p>\n<figure class=\"highlight yaml\"><figcaption data-lang=\"YAML\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># 数据源集合</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token key atrule\">dataSources</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>  <span class=\"token comment\"># 逻辑数据源名称</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>  <span class=\"token key atrule\">ds_0</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token comment\"># 数据源类型</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token key atrule\">dataSourceClassName</span><span class=\"token punctuation\">:</span> com.zaxxer.hikari.HikariDataSource</pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token comment\"># 数据库驱动</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token key atrule\">driverClassName</span><span class=\"token punctuation\">:</span> com.mysql.cj.jdbc.Driver</pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token comment\"># 数据库连接</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token key atrule\">jdbcUrl</span><span class=\"token punctuation\">:</span> jdbc<span class=\"token punctuation\">:</span>mysql<span class=\"token punctuation\">:</span>//127.0.0.1<span class=\"token punctuation\">:</span>3306/user_0<span class=\"token punctuation\">?</span>useUnicode=true<span class=\"token important\">&amp;characterEncoding=UTF-8&amp;rewriteBatchedStatements=true&amp;allowMultiQueries=true&amp;serverTimezone=Asia/Shanghai</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token comment\"># 用户名，如果本地数据库与这个不一致，需要修改</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    <span class=\"token key atrule\">username</span><span class=\"token punctuation\">:</span> root</pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    <span class=\"token comment\"># 密码，如果本地数据库与这个不一致，需要修改</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    <span class=\"token key atrule\">password</span><span class=\"token punctuation\">:</span> root</pre></td></tr><tr><td data-num=\"15\"></td><td><pre></pre></td></tr><tr><td data-num=\"16\"></td><td><pre><span class=\"token comment\"># ShardingSphere 规则配置，包含：数据分片、数据加密、读写分离等</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre><span class=\"token key atrule\">rules</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>  <span class=\"token punctuation\">-</span> <span class=\"token tag\">!SHARDING</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>    <span class=\"token comment\"># 需要数据分片的表集合</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>    <span class=\"token key atrule\">tables</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>      <span class=\"token comment\"># 逻辑表名</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>      <span class=\"token key atrule\">t_user</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>        <span class=\"token comment\"># 真实存在数据库的物理表集合</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>        <span class=\"token key atrule\">actualDataNodes</span><span class=\"token punctuation\">:</span> ds_0.t_user_$<span class=\"token punctuation\">&#123;</span>0..1<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>        <span class=\"token comment\"># 分表策略</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>        <span class=\"token key atrule\">tableStrategy</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>          <span class=\"token comment\"># 单分片键分表</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>          <span class=\"token key atrule\">standard</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>            <span class=\"token comment\"># 自定义分片字段</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>            <span class=\"token key atrule\">shardingColumn</span><span class=\"token punctuation\">:</span> id</pre></td></tr><tr><td data-num=\"31\"></td><td><pre>            <span class=\"token comment\"># 自定义分片算法名称，对应 &#123;rules [0].shardingAlgorithms.user_table_hash_mod&#125;</span></pre></td></tr><tr><td data-num=\"32\"></td><td><pre>            <span class=\"token key atrule\">shardingAlgorithmName</span><span class=\"token punctuation\">:</span> user_table_hash_mod</pre></td></tr><tr><td data-num=\"33\"></td><td><pre>    <span class=\"token comment\"># 数据分片算法定义集合</span></pre></td></tr><tr><td data-num=\"34\"></td><td><pre>    <span class=\"token key atrule\">shardingAlgorithms</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"35\"></td><td><pre>      <span class=\"token comment\"># 自定义分片算法名称</span></pre></td></tr><tr><td data-num=\"36\"></td><td><pre>      <span class=\"token key atrule\">user_table_hash_mod</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"37\"></td><td><pre>        <span class=\"token comment\"># 分片方式，HASH_MODE，按照 HASH 的方式对分片键进行操作，获取真实的物理表索引</span></pre></td></tr><tr><td data-num=\"38\"></td><td><pre>        <span class=\"token key atrule\">type</span><span class=\"token punctuation\">:</span> HASH_MOD</pre></td></tr><tr><td data-num=\"39\"></td><td><pre>        <span class=\"token key atrule\">props</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"40\"></td><td><pre>          <span class=\"token comment\"># 物理表分片数量</span></pre></td></tr><tr><td data-num=\"41\"></td><td><pre>          <span class=\"token key atrule\">sharding-count</span><span class=\"token punctuation\">:</span> <span class=\"token number\">2</span></pre></td></tr><tr><td data-num=\"42\"></td><td><pre><span class=\"token key atrule\">props</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"43\"></td><td><pre>  <span class=\"token comment\"># 是否打印逻辑 SQL 和真实 SQL，开发测试环境建议开放，生产环境建议关闭</span></pre></td></tr><tr><td data-num=\"44\"></td><td><pre>  <span class=\"token key atrule\">sql-show</span><span class=\"token punctuation\">:</span> <span class=\"token boolean important\">true</span></pre></td></tr></table></figure><h2 id=\"测试分表效果\"><a class=\"anchor\" href=\"#测试分表效果\">#</a> 测试分表效果</h2>\n<p>项目中引入了 Swagger3，通过界面 UI 发送一条消息测试效果。访问  <code>http://127.0.0.1:6060/swagger-ui/index.html</code> ，调用定义的新增数据和查询数据方法。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230926223335777.png\" alt=\"img\" /></p>\n<p>点击 Execute 执行方法调用。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230926223434188.png\" alt=\"img\" /></p>\n<p>通过新增用户方法调用得知，返回数据为成功。并在返回信息中，添加了用户 ID，可以根据该 ID 去查询数据库记录。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230926223516210.png\" alt=\"img\" /></p>\n<p>通过数据库日志得知，该数据被新增到  <code>t_user_1</code>  表中。</p>\n<figure class=\"highlight txt\"><figcaption data-lang=\"txt\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>2023-09-26T22:34:46.413+08:00  INFO 78131 --- [nio-6060-exec-1] ShardingSphere-SQL                       : Actual SQL: ds_0 ::: INSERT INTO t_user_1  ( id,</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>username,</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>password,</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>id_type,</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>id_card,</pre></td></tr><tr><td data-num=\"6\"></td><td><pre>phone,</pre></td></tr><tr><td data-num=\"7\"></td><td><pre>address,</pre></td></tr><tr><td data-num=\"8\"></td><td><pre>create_time,</pre></td></tr><tr><td data-num=\"9\"></td><td><pre>update_time,</pre></td></tr><tr><td data-num=\"10\"></td><td><pre>del_flag )  VALUES  (?, ?, ?, ?, ?, ?, ?, ?, ?, ?) ::: [1695738886407, 公众号@马丁玩编程, mqEc1mududm63JuxHmpm6jSUHy8xRRsL, 0, 110101202309305156, 15601166692, 杭州市阿里巴巴园区, 2023-09-26 22:34:46.407, 2023-09-26 22:34:46.407, 0]</pre></td></tr></table></figure><p>拿到刚才的方法返回 ID，根据 ID 查询这条数据的信息。</p>\n<p><img data-src=\"https://images-machen.oss-cn-beijing.aliyuncs.com/image-20230926223811260.png\" alt=\"img\" /></p>\n",
            "tags": [
                "分布式微服务"
            ]
        },
        {
            "id": "http://example.com/mq/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/",
            "url": "http://example.com/mq/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/",
            "title": "消息队列",
            "date_published": "2024-01-25T18:59:25.893Z",
            "content_html": "<h1 id=\"消息队列\"><a class=\"anchor\" href=\"#消息队列\">#</a> 消息队列</h1>\n<blockquote>\n<p>特指分布式消息队列</p>\n</blockquote>\n<h2 id=\"消息队列基础知识\"><a class=\"anchor\" href=\"#消息队列基础知识\">#</a> 消息队列基础知识</h2>\n<h3 id=\"消息队列的定义\"><a class=\"anchor\" href=\"#消息队列的定义\">#</a> 消息队列的定义</h3>\n<p>可以把消息队列看作是<font color='red'>一个存放消息的容器</font>，当我们需要使用消息的时候，直接从容器中取出消息供自己使用即可。由于<font color='red'>队列 Queue</font> 是一种先进先出的数据结构，所以消费消息时也<font color='red'>按照顺序来消费</font>。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/message-queue-small.png\" alt=\"img\" /></p>\n<p>消息队列是一种 <strong>Pub/Sub 模型（发布 / 订阅模型）</strong>，参与消息传递的双方称为<strong>生产者</strong>和<strong>消费者</strong>，生产者负责发送消息，消费者负责处理消息。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/message-queue-pub-sub-model-63a717b4.png\" alt=\"发布/订阅（Pub/Sub）模型\" /></p>\n<center>发布/订阅（Pub/Sub）模型</center>\n<p>我们知道操作系统中的进程通信的一种很重要的方式就是消息队列。我们这里提到的消息队列稍微有点区别，<font color='red'>更多指的是各个服务以及系统内部各个组件 / 模块之前的通信</font>，属于一种<strong>中间件</strong>。</p>\n<p>简单来说：<strong>中间件是一类服务于应用软件的软件，应用软件是为用户服务的，用户不会接触或者使用到中间件。</strong></p>\n<p>随着分布式和微服务系统的发展，消息队列在系统设计中有了更大的发挥空间，使用消息队列<font color='red'>可以降低系统耦合性、实现任务异步、有效地进行流量削峰</font>，是分布式和微服务系统中重要的组件之一。</p>\n<h3 id=\"消息队列的作用\"><a class=\"anchor\" href=\"#消息队列的作用\">#</a> 消息队列的作用</h3>\n<p>通常来说，使用消息队列能为我们的系统带来下面三点好处：</p>\n<ol>\n<li><strong>通过异步处理提高系统性能（减少响应所需时间）</strong></li>\n<li><strong>削峰 / 限流</strong></li>\n<li><strong>降低系统耦合性</strong></li>\n<li><strong>实现分布式事务</strong></li>\n</ol>\n<p>如果在面试的时候你被面试官问到这个问题的话，一般情况是你在你的简历上涉及到消息队列这方面的内容，这个时候推荐<font color='red'>结合自己的项目来回答</font>。</p>\n<h4 id=\"作用1通过异步处理提高系统性能减少响应所需时间\"><a class=\"anchor\" href=\"#作用1通过异步处理提高系统性能减少响应所需时间\">#</a> 作用 1：通过异步处理提高系统性能（减少响应所需时间）</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/Asynchronous-message-queue.png\" alt=\"通过异步处理提高系统性能\" /></p>\n<center>通过异步处理提高系统性能</center>\n<p><font color='red'>服务端将用户的请求数据存储到消息队列后，立即返回结果</font>。随后，系统再对消息进行消费。</p>\n<p>因为用户请求数据写入消息队列之后就立即返回给用户了，但是请求数据在后续的业务校验、写数据库等操作中可能失败。因此，<strong>使用消息队列进行异步处理之后，需要适当修改业务流程进行配合</strong>，比如用户在提交订单之后，订单数据写入消息队列，不能立即返回用户订单提交成功，需要在消息队列的订单消费者进程真正处理完该订单之后，甚至出库后，再通过电子邮件或短信通知用户订单成功，以免交易纠纷。这就类似我们平时手机订火车票和电影票。</p>\n<h4 id=\"作用2削峰限流\"><a class=\"anchor\" href=\"#作用2削峰限流\">#</a> 作用 2：削峰 / 限流</h4>\n<p><strong>先将短时间高并发产生的事务消息存储在消息队列中，然后后端服务再慢慢根据自己的能力去消费这些消息，这样就避免大量事务直接把后端服务冲垮。</strong></p>\n<p>举例：在电子商务一些秒杀、促销活动中，合理使用消息队列可以有效抵御促销活动刚开始大量订单涌入对系统的冲击。如下图所示：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231025224518547.png\" alt=\"削峰\" /></p>\n<center>削峰</center>\n<h4 id=\"作用3降低系统的耦合性\"><a class=\"anchor\" href=\"#作用3降低系统的耦合性\">#</a> 作用 3：降低系统的耦合性</h4>\n<p>使用消息队列还可以降低系统耦合性。我们知道如果模块之间不存在直接调用，那么新增模块或者修改模块就对其他模块影响较小，这样系统的可扩展性无疑更好一些。还是直接上图吧：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231025224821246.png\" alt=\"image-20231025224821246\" /></p>\n<p>生产者（客户端）发送消息到消息队列中去，接受者（服务端）处理消息，需要消费的系统直接去消息队列获取消息进行消费即可，而不需要和其他系统有耦合，这显然也提高了系统的扩展性。</p>\n<p>** 消息队列使用 Pub/Sub 模式（发布 / 订阅模式）工作，生产者发布消息，一个或多个消费者订阅消息。** 从上图可以看到<font color='red'>生产者和消费者之间没有直接耦合</font>，</p>\n<ul>\n<li>生产者将消息发送至分布式消息队列即结束对消息的处理</li>\n<li>消费者从分布式消息队列获取该消息后进行后续处理，并不需要知道该消息从何而来。</li>\n</ul>\n<p><font color='red'>对新增业务，只要对该类消息感兴趣，即可订阅该消息，对原有系统和业务没有任何影响，从而实现网站业务的可扩展性设计</font>。</p>\n<p>消费者对消息进行过滤、处理、包装后，构造成一个新的消息类型，将消息继续发送出去，等待其他消费者订阅该消息。因此基于事件（消息对象）驱动的业务架构可以是一系列流程。</p>\n<p>另外，<font color='red'>为了避免 “消息队列服务器” 宕机造成消息丢失，会将成功发送到消息队列的消息存储在 “生产者服务器” 上，等消息真正被 “消费者服务器” 处理后才删除消息</font>。在消息队列服务器宕机后，生产者服务器会选择分布式消息队列服务器集群中的其他服务器发布消息。</p>\n<p>备注：不要认为消息队列只能利用发布 - 订阅模式工作，只不过在解耦这个特定业务环境下是使用发布 - 订阅模式的。除了发布 - 订阅模式，还有<strong>点对点订阅模式</strong>（一个消息只有一个消费者），我们比较常用的是发布 - 订阅模式。</p>\n<h4 id=\"作用4实现分布式事务\"><a class=\"anchor\" href=\"#作用4实现分布式事务\">#</a> 作用 4：实现分布式事务</h4>\n<p>分布式事务的解决方案之一就是 MQ 事务。</p>\n<p>RocketMQ、Kafka、Pulsar、QMQ 都提供了事务相关的功能。<font color='red'>事务允许事件流应用将生产、处理、消费消息的整个过程定义为一个原子操作</font>。</p>\n<p>详细介绍可以查看 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9qYXZhZ3VpZGUuY24vZGlzdHJpYnV0ZWQtc3lzdGVtL2Rpc3RyaWJ1dGVkLXRyYW5zYWN0aW9uLmh0bWw=\">分布式事务详解 (付费)</span> 这篇文章。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/07b338324a7d8894b8aef4b659b76d92.png\" alt=\"分布式事务详解 - MQ事务\" /></p>\n<center>分布式事务详解 - MQ事务</center>\n<h3 id=\"消息队列存在的问题\"><a class=\"anchor\" href=\"#消息队列存在的问题\">#</a> 消息队列存在的问题</h3>\n<p><strong>系统可用性降低</strong>：在加入 MQ 之前，你不用考虑<font color='red'>消息丢失、 MQ 挂掉</font>等等的情况，但是引入 MQ 之后你就需要去考虑了！</p>\n<p><strong>系统复杂性提高</strong>：加入 MQ 之后，你需要<font color='red'>保证消息没有被重复消费、处理消息丢失的情况、保证消息传递的顺序性</font>等等问题！</p>\n<p><strong>一致性问题</strong>：消息队列可以实现异步，确实可以提高系统响应速度。但是，万一消息的真正消费者并没有正确消费消息怎么办？这样就会导致<font color='red'>数据不一致</font>的情况了！</p>\n<h3 id=\"jms-和-amqp\"><a class=\"anchor\" href=\"#jms-和-amqp\">#</a> JMS 和 AMQP</h3>\n<h4 id=\"jms-定义\"><a class=\"anchor\" href=\"#jms-定义\">#</a> JMS 定义</h4>\n<p><strong>JMS（JAVA Message Service）是 Java 的消息服务，其 API 是一个消息服务的标准 / 规范</strong>。JMS 的客户端之间可以通过 JMS 服务进行异步的消息传输。它允许应用程序组件基于 JavaEE 平台创建、发送、接收和读取消息。它使分布式通信耦合度更低，消息服务更加可靠以及异步性。</p>\n<p>JMS 定义了<font color='gree'>五种不同消息</font>的正文格式以及调用的消息类型，允许你发送并接收一些不同形式的数据：</p>\n<ul>\n<li><code>StreamMessage</code> ：Java 原始值的数据流</li>\n<li><code>MapMessage</code> ：一套名称 - 值对</li>\n<li><code>TextMessage</code> ：一个字符串对象</li>\n<li><code>ObjectMessage</code> ：一个序列化的 Java 对象</li>\n<li><code>BytesMessage</code> ：一个字节的数据流</li>\n</ul>\n<h4 id=\"jms-两种消息模型\"><a class=\"anchor\" href=\"#jms-两种消息模型\">#</a> JMS 两种消息模型</h4>\n<h5 id=\"点到点模型p2p\"><a class=\"anchor\" href=\"#点到点模型p2p\">#</a> 点到点模型（P2P）</h5>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/message-queue-queue-model-3aa809bf.png\" alt=\"队列模型\" /></p>\n<p>使用<strong>队列（Queue）<strong>作为消息通信载体，满足</strong>生产者与消费者模式</strong>，<strong><font color='red'>一条消息只能被一个消费者使用</font></strong>，未被消费的消息在队列中保留直到被消费或超时。比如：生产者发送 100 条消息的话，两个消费者来消费，一般情况下两个消费者会按照消息发送的顺序各自消费一半（也就是你一个我一个的消费）。</p>\n<h5 id=\"发布订阅模型pubsub\"><a class=\"anchor\" href=\"#发布订阅模型pubsub\">#</a> 发布 / 订阅模型（Pub/Sub）</h5>\n<p><img data-src=\"https://javaguide.cn/assets/message-queue-pub-sub-model-63a717b4.png\" alt=\"发布/订阅（Pub/Sub）模型\" /></p>\n<center>发布/订阅（Pub/Sub）模型</center>\n<p>使用<strong>主题（Topic）<strong>作为消息通信载体，类似于</strong>广播模式</strong>；发布者发布一条消息，<strong><font color='red'>该消息通过主题传递给所有的订阅者</font></strong>。</p>\n<h4 id=\"amqp-定义\"><a class=\"anchor\" href=\"#amqp-定义\">#</a> AMQP 定义</h4>\n<p>AMQP，即  <code>Advanced Message Queuing Protocol</code> ，一个提供统一消息服务的应用层标准<strong>高级消息队列协议</strong>（二进制应用层协议），是<font color='red'>应用层协议</font>的一个开放标准，为面向消息的中间件设计，兼容 JMS。<font color='red'>基于此协议的客户端与消息中间件可传递消息</font>，并不受客户端 / 中间件产品，不同的开发语言等条件的限制。</p>\n<p><strong>RabbitMQ 就是基于 AMQP 协议实现的。</strong></p>\n<h4 id=\"jms-vs-amqp\"><a class=\"anchor\" href=\"#jms-vs-amqp\">#</a> JMS vs AMQP</h4>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\"></th>\n<th style=\"text-align:left\">JMS</th>\n<th style=\"text-align:left\">AMQP</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">定义</td>\n<td style=\"text-align:left\"><strong>Java API</strong></td>\n<td style=\"text-align:left\">协议</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">跨语言</td>\n<td style=\"text-align:left\">否</td>\n<td style=\"text-align:left\"><strong>是</strong></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">跨平台</td>\n<td style=\"text-align:left\">否</td>\n<td style=\"text-align:left\"><strong>是</strong></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">支持消息类型</td>\n<td style=\"text-align:left\">提供两种消息模型：①P2P;②Pub/sub</td>\n<td style=\"text-align:left\">提供了五种消息模型：①direct exchange；②fanout exchange；③topic change；④headers exchange；⑤system exchange。本质来讲，后四种和 JMS 的 pub/sub 模型没有太大差别，仅是在路由机制上做了更详细的划分；</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">支持消息类型</td>\n<td style=\"text-align:left\"><strong>多种消息类型</strong></td>\n<td style=\"text-align:left\"><strong>byte []（二进制）</strong></td>\n</tr>\n</tbody>\n</table>\n<p><strong>总结：</strong></p>\n<ul>\n<li>AMQP 为消息定义了线路层的协议，而 JMS 所定义的是 API 规范。在 Java 体系中，多个 client 均可以通过 JMS 进行交互，不需要应用修改代码，但是其对跨平台的支持较差。而 <strong>AMQP 天然具有跨平台、跨语言特性</strong>。</li>\n<li><strong>JMS 支持  <code>TextMessage</code> 、 <code>MapMessage</code>  等复杂的消息类型</strong>；而 <strong>AMQP 仅支持  <code>byte[]</code>  消息类型</strong>（复杂的类型可序列化后发送）。</li>\n<li>由于 Exchange 提供的路由算法，<strong>AMQP 可以提供多样化的路由方式</strong>来传递消息到消息队列，<strong>而 JMS 仅支持 P2P 和 Pub/Sub 方式两种</strong>。</li>\n</ul>\n<h3 id=\"rpc-和消息队列的区别\"><a class=\"anchor\" href=\"#rpc-和消息队列的区别\">#</a> RPC 和消息队列的区别</h3>\n<p>RPC 和消息队列都是分布式微服务系统中重要的组件之一，下面我们来简单对比一下两者：</p>\n<ul>\n<li><strong>用途</strong>：\n<ul>\n<li>RPC：主要用来解决两个服务的远程通信问题，不需要了解底层网络的通信机制。通过 RPC 可以帮助我们<font color='red'>远程调用某个服务的方法</font>，这个过程就像调用本地方法一样简单。</li>\n<li>消息队列：主要用来<font color='red'>降低系统耦合性、实现任务异步、流量削峰</font>。</li>\n</ul>\n</li>\n<li><strong>通信方式</strong>：\n<ul>\n<li>RPC：<font color='red'>双向直接网络通讯</font></li>\n<li>消息队列：<font color='red'>单向引入中间载体</font>的网络通讯</li>\n</ul>\n</li>\n<li><strong>架构</strong>：\n<ul>\n<li>RPC：<font color='red'>不需要存储消息</font>，因为是双向直接网络通讯</li>\n<li>消息队列：需要把消息存储起来</li>\n</ul>\n</li>\n<li><strong>请求处理的时效性</strong>：\n<ul>\n<li>通过 RPC 发出的调用一般会<font color='red'>立即被处理</font></li>\n<li>存放在消息队列中的消息<font color='red'>并不一定会立即被处理</font></li>\n</ul>\n</li>\n</ul>\n<p><font color='red'>RPC 和消息队列本质上是网络通讯的两种不同的实现机制，两者的用途不同</font>，万不可将两者混为一谈。</p>\n<h3 id=\"消息队列选型\"><a class=\"anchor\" href=\"#消息队列选型\">#</a> <mark>消息队列选型</mark></h3>\n<h4 id=\"常见的消息队列\"><a class=\"anchor\" href=\"#常见的消息队列\">#</a> 常见的消息队列</h4>\n<h5 id=\"kafka\"><a class=\"anchor\" href=\"#kafka\">#</a> Kafka</h5>\n<blockquote>\n<p>Kafka 官网：<span class=\"exturl\" data-url=\"aHR0cDovL2thZmthLmFwYWNoZS5vcmcv\">http://kafka.apache.org/</span></p>\n<p>Kafka 更新记录（可以直观看到项目是否还在维护）：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9rYWZrYS5hcGFjaGUub3JnL2Rvd25sb2Fkcw==\">https://kafka.apache.org/downloads</span></p>\n</blockquote>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/kafka-logo.png\" alt=\"img\" /></p>\n<p>Kafka 是 LinkedIn 开源的一个<font color='red'>分布式流式处理平台</font>，已经成为 Apache 顶级项目，早期被用来用于<font color='red'>处理海量的日志</font>，后面才慢慢发展成了一款功能全面的<font color='red'>高性能消息队列</font>。</p>\n<p>流式处理平台具有三个关键功能：</p>\n<ol>\n<li><strong>消息队列</strong>：<font color='red'>发布和订阅消息流</font>。</li>\n<li><strong>持久方式存储消息流</strong>：Kafka 会<font color='red'>把消息持久化到磁盘</font>，有效地避免了消息丢失的风险。</li>\n<li><strong>流式处理平台</strong>：在消息发布的时候进行处理，Kafka 提供了一个完整的流式处理类库。</li>\n</ol>\n<p>Kafka 是一个分布式系统，由通过高性能<font color='red'> TCP 网络协议</font>进行通信的服务器和客户端组成，可以部署在在本地和云环境中的裸机硬件、虚拟机和容器上。</p>\n<p>在 Kafka 2.8 之前，Kafka 最被大家诟病的就是其重度依赖于 Zookeeper 做元数据管理和集群的高可用。<font color='red'>在 Kafka 2.8 之后，引入了基于 Raft 协议的 KRaft 模式，不再依赖 Zookeeper，大大简化了 Kafka 的架构</font>。</p>\n<p>提示一下：<font color='red'>如果要使用 KRaft 模式的话，建议选择较高版本的 Kafka</font>，因为这个功能还在持续完善优化中。Kafka 3.3.1 版本是第一个将 KRaft（Kafka Raft）共识协议标记为生产就绪的版本。</p>\n<h5 id=\"rocketmq\"><a class=\"anchor\" href=\"#rocketmq\">#</a> RocketMQ</h5>\n<blockquote>\n<p>RocketMQ 官网：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9yb2NrZXRtcS5hcGFjaGUub3JnLw==\">https://rocketmq.apache.org/</span> （文档很详细，推荐阅读）</p>\n<p>RocketMQ 更新记录（可以直观看到项目是否还在维护）：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2FwYWNoZS9yb2NrZXRtcS9yZWxlYXNlcw==\">https://github.com/apache/rocketmq/releases</span></p>\n</blockquote>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/rocketmq-logo.png\" alt=\"img\" /></p>\n<p>RocketMQ 是阿里开源的一款<font color='red'>云原生 “消息、事件、流” 实时数据处理平台</font>，借鉴了 Kafka，已经成为 Apache 顶级项目。</p>\n<p>RocketMQ 的核心特性（摘自 RocketMQ 官网）：</p>\n<ul>\n<li><strong>云原生</strong>：生与云，长与云，<font color='red'>无限弹性扩缩，K8s 友好</font></li>\n<li><strong>高吞吐</strong>：万亿级吞吐保证，同时满足微服务与大数据场景。</li>\n<li><strong>流处理</strong>：提供轻量、高扩展、高性能和丰富功能的流计算引擎。</li>\n<li><strong>金融级</strong>：金融级的稳定性，广泛用于交易核心链路。</li>\n<li><strong>架构极简</strong>：<font color='red'>零外部依赖</font>，Shared-nothing 架构。</li>\n<li><strong>生态友好</strong>：无缝对接微服务、实时计算、数据湖等周边生态。</li>\n</ul>\n<p>根据官网介绍：</p>\n<blockquote>\n<p>Apache RocketMQ 自诞生以来，因其架构简单、业务功能丰富、具备极强可扩展性等特点<font color='red'>被众多企业开发者以及云厂商广泛采用</font>。历经十余年的大规模场景打磨，RocketMQ 已经成为<font color='red'>业内共识的金融级可靠业务消息首选方案</font>，被广泛应用于互联网、大数据、移动互联网、物联网等领域的业务场景。</p>\n</blockquote>\n<h5 id=\"rabbitmq\"><a class=\"anchor\" href=\"#rabbitmq\">#</a> RabbitMQ</h5>\n<blockquote>\n<p>RabbitMQ 官网：<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cucmFiYml0bXEuY29tLw==\">https://www.rabbitmq.com/</span> 。</p>\n<p>RabbitMQ 更新记录（可以直观看到项目是否还在维护）：<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cucmFiYml0bXEuY29tL25ld3MuaHRtbA==\">https://www.rabbitmq.com/news.html</span></p>\n</blockquote>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/rabbitmq-logo.png\" alt=\"img\" /></p>\n<p>RabbitMQ 是采用 Erlang 语言实现 <font color='red'>AMQP (Advanced Message Queuing Protocol，高级消息队列协议）</font>的消息中间件，它最初起源于金融系统，用于在分布式系统中<font color='red'>存储转发消息</font>。</p>\n<p>RabbitMQ 发展到今天，被越来越多的人认可，这和它在易用性、扩展性、可靠性和高可用性等方面的卓著表现是分不开的。RabbitMQ 的具体特点可以概括为以下几点：</p>\n<ul>\n<li><strong>可靠性</strong>：RabbitMQ 使用一些机制来保证消息的可靠性，如<font color='red'>持久化、传输确认、发布确认</font>等。</li>\n<li><strong>灵活的路由</strong>：在消息进入队列之前，<font color='red'>通过交换器来路由消息</font>。对于典型的路由功能，RabbitMQ 己经提供了一些内置的交换器来实现。针对更复杂的路由功能，可以将多个交换器绑定在一起，也可以通过插件机制来实现自己的交换器。这个后面会在我们讲 RabbitMQ 核心概念的时候详细介绍到。</li>\n<li><strong>扩展性</strong>：多个 RabbitMQ 节点可以组成一个<font color='red'>集群</font>，也可以根据实际业务情况动态地扩展集群中节点。</li>\n<li><strong>高可用性</strong>：队列可以在集群中的机器上<font color='red'>设置镜像</font>，使得在部分节点出现问题的情况下队列仍然可用。</li>\n<li><strong>支持多种协议</strong>：RabbitMQ 除了原生支持 AMQP 协议，还支持 <font color='red'>STOMP、MQTT</font> 等多种消息中间件协议。</li>\n<li><strong>多语言客户端</strong>：RabbitMQ 几乎<font color='red'>支持所有常用语言</font>，比如 Java、Python、Ruby、PHP、C#、JavaScript 等。</li>\n<li><strong>易用的管理界面</strong>：RabbitMQ 提供了一个<font color='red'>易用的用户界面</font>，使得用户可以<font color='red'>监控和管理消息、集群中的节点</font>等。在安装 RabbitMQ 的时候会介绍到，安装好 RabbitMQ 就自带管理界面。</li>\n<li><strong>插件机制</strong>：RabbitMQ 提供了许多插件，以实现从多方面进行扩展，当然也可以编写自己的插件。感觉这个有点类似 Dubbo 的 SPI 机制。</li>\n</ul>\n<h5 id=\"activemq\"><a class=\"anchor\" href=\"#activemq\">#</a> ActiveMQ</h5>\n<p>目前已经被淘汰，不推荐使用，不建议学习。</p>\n<h4 id=\"对比\"><a class=\"anchor\" href=\"#对比\">#</a> 对比</h4>\n<blockquote>\n<p>参考《Java 工程师面试突击第 1 季 - 中华石杉老师》</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>对比方向</th>\n<th>概要</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>吞吐量</td>\n<td>万级的 ActiveMQ 和 RabbitMQ 的吞吐量（ActiveMQ 的性能最差）要比十万级甚至是百万级的 <font color='red'>RocketMQ 和 Kafka</font> 低一个数量级。</td>\n</tr>\n<tr>\n<td>可用性</td>\n<td><font color='red'>都可以实现高可用</font>。ActiveMQ 和 RabbitMQ 都是基于<font color='red'>主从架构</font>实现高可用性。RocketMQ 基于<font color='red'>分布式架构</font>。 Kafka 也是分布式的，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用</td>\n</tr>\n<tr>\n<td>时效性</td>\n<td><font color='red'>RabbitMQ</font> 基于 Erlang 开发，所以并发能力很强，性能极其好，延时很低，达到微秒级，其他几个都是 ms 级。</td>\n</tr>\n<tr>\n<td>功能支持</td>\n<td><font color='red'>Pulsar</font> 的功能更全面，支持多租户、多种消费模式和持久性模式等功能，是下一代云原生分布式消息流平台。</td>\n</tr>\n<tr>\n<td>消息丢失</td>\n<td>ActiveMQ 和 RabbitMQ 丢失的可能性非常低， <font color='red'>Kafka、RocketMQ 和 Pulsar</font> 理论上可以做到 0 丢失。</td>\n</tr>\n</tbody>\n</table>\n<p>总结：</p>\n<ul>\n<li>ActiveMQ 的社区算是比较成熟，但是较目前来说，ActiveMQ 的性能比较差，而且版本迭代很慢，不推荐使用，已经被淘汰了。</li>\n<li>RabbitMQ 在吞吐量方面虽然稍逊于 Kafka、RocketMQ 和 Pulsar，但是由于它基于 Erlang 开发，所以并发能力很强，性能极其好，延时很低，达到微秒级。但是也因为 RabbitMQ 基于 Erlang 开发，所以国内很少有公司有实力做 Erlang 源码级别的研究和定制。如果业务场景对并发量要求不是太高（十万级、百万级），那这几种消息队列中，RabbitMQ 或许是你的首选。</li>\n<li>RocketMQ 和 Pulsar 支持强一致性，对消息一致性要求比较高的场景可以使用。</li>\n<li>RocketMQ 阿里出品，Java 系开源项目，源代码我们可以直接阅读，然后可以定制自己公司的 MQ，并且 RocketMQ 有阿里巴巴的实际业务场景的实战考验。</li>\n<li>Kafka 仅仅提供较少的核心功能，但是提供超高的吞吐量，ms 级的延迟，极高的可用性以及可靠性，而且分布式可以任意扩展。同时 Kafka 最好是支撑较少的 topic 数量即可，保证其超高吞吐量。<font color='red'>Kafka 唯一的一点劣势是有可能消息重复消费</font>，那么对数据准确性会造成极其轻微的影响，在大数据领域中以及日志采集中，这点轻微影响可以忽略这个特性天然适合大数据实时计算以及日志收集。如果是<font color='red'>大数据领域的实时计算、日志采集等场景</font>，用 Kafka 是业内标准的，绝对没问题，社区活跃度很高，绝对不会黄，何况几乎是全世界这个领域的事实性规范。</li>\n</ul>\n<h2 id=\"kafka-2\"><a class=\"anchor\" href=\"#kafka-2\">#</a> Kafka</h2>\n<h3 id=\"基础\"><a class=\"anchor\" href=\"#基础\">#</a> 基础</h3>\n<h4 id=\"功能-应用场景\"><a class=\"anchor\" href=\"#功能-应用场景\">#</a> 功能、应用场景</h4>\n<p>Kafka 是一个<strong>分布式流式处理平台</strong>，流平台具有三个关键功能：</p>\n<ol>\n<li><strong><font color='red'>消息队列</font></strong>：<font color='red'>发布和订阅消息流</font>，这个功能类似于消息队列，这也是 Kafka 也被归类为消息队列的原因。</li>\n<li><strong><font color='red'>容错的持久方式存储记录消息流</font></strong>：Kafka 会<font color='red'>把消息持久化到磁盘</font>，有效避免了消息丢失的风险。</li>\n<li>**<font color='red'>流式处理平台</font>：** 在消息发布的时候进行处理，Kafka 提供了一个<font color='red'>完整的流式处理类库</font>。</li>\n</ol>\n<p>Kafka 主要有两大应用场景：</p>\n<ol>\n<li><strong><font color='red'>消息队列</font></strong>：建立实时流数据管道，以可靠地在系统或应用程序之间获取数据。</li>\n<li>**<font color='red'>数据处理</font>：** 构建实时的流数据处理程序来转换或处理数据流。</li>\n</ol>\n<h4 id=\"相比其他-mq-的优势\"><a class=\"anchor\" href=\"#相比其他-mq-的优势\">#</a> 相比其他 MQ 的优势</h4>\n<p>Kafka 相比其他消息队列主要的优势如下：</p>\n<ol>\n<li><strong><font color='red'>极致的性能</font></strong>：基于 Scala 和 Java 语言开发，设计中大量使用了<font color='red'>批量处理</font>和<font color='red'>异步</font>的思想，最高<font color='red'>每秒可以处理千万级别的消息</font>。</li>\n<li><strong><font color='red'>生态系统兼容性无可匹敌</font></strong>：Kafka 与周边生态系统的兼容性是最好的没有之一，尤其在大数据和流计算领域。</li>\n</ol>\n<h4 id=\"消息模型\"><a class=\"anchor\" href=\"#消息模型\">#</a> 消息模型</h4>\n<blockquote>\n<p>题外话：早期的  <code>JMS</code>  和  <code>AMQP</code>  属于消息服务领域权威组织所做的相关的标准，但是这些标准的进化跟不上消息队列的演进速度，<font color='red'>这些标准实际上已经属于废弃状态</font>。所以，可能存在的情况是：<font color='red'>不同的消息队列都有自己的一套消息模型</font>。</p>\n</blockquote>\n<h5 id=\"队列模型p2p\"><a class=\"anchor\" href=\"#队列模型p2p\">#</a> 队列模型（P2P）</h5>\n<blockquote>\n<p>早期的消息模型</p>\n</blockquote>\n<p><img data-src=\"https://oss.javaguide.cn/github/javaguide/high-performance/message-queue/%E9%98%9F%E5%88%97%E6%A8%A1%E5%9E%8B23.png\" alt=\"队列模型\" /></p>\n<center>队列模型</center>\n<p>使用<strong>队列（Queue）<strong>作为消息通信载体，满足生产者与消费者模式，</strong><font color='red'>一条消息只能被一个消费者使用，未被消费的消息在队列中保留直到被消费或超时</font></strong>。比如：我们生产者发送 100 条消息的话，两个消费者来消费，一般情况下两个消费者会按照消息发送的顺序各自消费一半（也就是你一个我一个的消费。）</p>\n<p>队列模型存在的问题：<font color='red'>无法将生产者产生的消息分发给多个消费者，并保证每个消费者都能接收到完整的消息内容</font>。这种情况，队列模型就不好解决了。很多比较杠精的人就说：我们可以为每个消费者创建一个单独的队列，让生产者发送多份。这是一种非常愚蠢的做法，浪费资源不说，还违背了使用消息队列的目的。</p>\n<h5 id=\"发布-订阅模型pub-sub\"><a class=\"anchor\" href=\"#发布-订阅模型pub-sub\">#</a> 发布 - 订阅模型（Pub-Sub）</h5>\n<blockquote>\n<p><strong><font color='red'>Kafka 采用的消息模型</font></strong>，为了解决队列模型存在的问题</p>\n</blockquote>\n<p><img data-src=\"https://oss.javaguide.cn/java-guide-blog/%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%9E%8B.png\" alt=\"发布订阅模型\" /></p>\n<center>发布订阅模型</center>\n<p>发布 - 订阅模型（Pub-Sub） 使用<strong>主题（Topic）<strong>作为消息通信载体，类似于</strong>广播模式</strong>。<strong>发布者发布一条消息，该消息通过主题传递给所有的订阅者，在一条消息广播之后才订阅的用户则是收不到该条消息的</strong>。</p>\n<p>在发布 - 订阅模型中，<font color='red'>如果只有一个订阅者，那它和队列模型就基本是一样的了</font>。所以说，发布 - 订阅模型在功能层面上是可以兼容队列模型的。</p>\n<blockquote>\n<p><strong>RocketMQ 的消息模型和 Kafka 基本是完全一样的。唯一的区别是 Kafka 中没有队列这个概念，与之对应的是 Partition（分区）。</strong></p>\n</blockquote>\n<h3 id=\"核心概念\"><a class=\"anchor\" href=\"#核心概念\">#</a> 核心概念</h3>\n<h4 id=\"producer-comsumer-broker-topic-partition\"><a class=\"anchor\" href=\"#producer-comsumer-broker-topic-partition\">#</a> Producer、Comsumer、Broker、Topic、Partition</h4>\n<p>Kafka 将生产者发布的消息发送到 **Topic（主题）** 中，需要这些消息的消费者可以订阅这些 Topic，如下图所示：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/message-queue20210507200944439.png\" alt=\"img\" /></p>\n<p>上面这张图也为我们引出了，Kafka 比较重要的几个概念：</p>\n<ol>\n<li>\n<p>Producer（生产者）: 产生消息的一方。</p>\n</li>\n<li>\n<p>Consumer（消费者）: 消费消息的一方。</p>\n</li>\n<li>\n<p><strong>Broker（代理）</strong>: 可以看作是<font color='red'>一个独立的 Kafka 实例</font>。多个 Kafka Broker 组成一个 Kafka <strong>Cluster（集群）</strong>。每个 Broker 中又包含：</p>\n<ul>\n<li>\n<p><strong>Topic（主题）</strong>: Producer 将消息发送到特定的主题，Consumer 通过订阅特定的 Topic (主题) 来消费消息。</p>\n</li>\n<li>\n<p><strong>Partition（分区）</strong>: <font color='red'>属于 Topic 的一部分</font>。一个 Topic 可以有多个 Partition ，并且 **<font color='red'>同一 Topic 下的 Partition 可以分布在不同的 Broker 上，表明一个 Topic 可以横跨多个 Broker</font>**。</p>\n</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"多副本机制replica\"><a class=\"anchor\" href=\"#多副本机制replica\">#</a> 多副本机制（Replica）</h4>\n<blockquote>\n<p>类似于 <strong>Redis 中的主从复制（Replica）</strong></p>\n</blockquote>\n<p>Kafka 为分区（Partition）引入了<strong>多副本（Replica）机制</strong>。Partition 中的多个副本之间会有一个叫做  <code>leader</code>  的家伙，其他副本称为  <code>follower</code> 。<font color='red'>发送的消息先被发送到 leader 副本，然后 follower 副本才能从 leader 副本中拉取消息进行同步</font>。</p>\n<blockquote>\n<p><strong><font color='red'>生产者和消费者只与 leader 副本交互</font></strong>。可以理解为<font color='red'>其他副本只是 leader 副本的拷贝，它们的存在只是为了保证消息存储的安全性</font>。<font color='red'>当 leader 副本发生故障时会从 follower 中选举出一个 leader，前提是该 follower 和 leader 同步程度一致</font>。</p>\n</blockquote>\n<p>Kafka 多副本（Replica）机制的好处如下：</p>\n<ol>\n<li><strong><font color='red'>负载均衡</font></strong>：Kafka 通过给特定 Topic 指定多个 Partition，而各个 Partition 可以分布在不同的 Broker 上，这样便能提供比较好的<font color='red'>并发能力</font>。</li>\n<li><strong><font color='red'>数据容灾能力</font></strong>：Partition 可以指定对应的 Replica 数，极大地提高了消息存储的安全性与容灾能力，不过也相应地增加了所需要的存储空间。</li>\n</ol>\n<h3 id=\"kafka-与-zookeeper-的关系\"><a class=\"anchor\" href=\"#kafka-与-zookeeper-的关系\">#</a> Kafka 与 Zookeeper 的关系</h3>\n<h4 id=\"zookeeper-在-kafka-中的作用\"><a class=\"anchor\" href=\"#zookeeper-在-kafka-中的作用\">#</a> Zookeeper 在 Kafka 中的作用</h4>\n<p>下图就是我的本地 Zookeeper，它成功和我本地的 Kafka 关联上（以下文件夹结构借助 idea 插件 Zookeeper tool 实现）。</p>\n<img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/zookeeper-kafka.jpg\" alt=\"img\" style=\"zoom:50%;\" />\n<p>ZooKeeper 主要为 Kafka 提供<strong>元数据的管理</strong>的功能。</p>\n<p>从图中我们可以看出，Zookeeper 主要为 Kafka 做了下面这些事情：</p>\n<ol>\n<li><strong><font color='red'>Broker 注册</font></strong>：在 Zookeeper 上会有一个专门用来<font color='red'>记录 Broker 服务器列表</font>的节点。每个 Broker 在启动时，都会到 Zookeeper 上进行注册，即到  <code>/brokers/ids</code>  下创建属于自己的节点。每个 Broker 就会将自己的 IP 地址和端口等信息记录到该节点中去</li>\n<li><strong><font color='red'>Topic 注册</font></strong>：在 Kafka 中，<font color='red'>同一个 Topic 的消息会被分成多个 Partition</font>，并将其分布在多个 Broker 上。<font color='red'>这些 Partition 信息及与 Broker 的对应关系也都是由 Zookeeper 在维护</font>。比如我创建了一个名字为 my-topic 的 Topic 并且它有两个 Partition ，对应到 zookeeper 中会创建这些文件夹： <code>/brokers/topics/my-topic/Partitions/0</code> 、 <code>/brokers/topics/my-topic/Partitions/1</code></li>\n<li><strong><font color='red'>负载均衡</font></strong>：上面也说过了 Kafka 通过给特定 Topic 指定多个 Partition，而各个 Partition 可以分布在不同的 Broker 上，这样便能提供比较好的并发能力。<font color='red'>对于同一个 Topic 的不同 Partition，Kafka 会尽力将这些 Partition 分布到不同的 Broker 服务器上</font>。\n<ul>\n<li>当 Provider 产生消息时，会尽量投递到不同 Broker 的 Partition 里面。</li>\n<li>当 Consumer 消费消息时，Zookeeper 会可以根据当前的 Partition 数量以及 Consumer 数量来实现动态负载均衡。</li>\n</ul>\n</li>\n<li>……</li>\n</ol>\n<h4 id=\"kafka-不再依赖于-zookeeper\"><a class=\"anchor\" href=\"#kafka-不再依赖于-zookeeper\">#</a> Kafka 不再依赖于 Zookeeper</h4>\n<p>在 Kafka 2.8 之前，Kafka 最被大家诟病的就是其重度依赖于 Zookeeper。<font color='red'>在 Kafka 2.8 之后，引入了基于 Raft 协议的 KRaft 模式，不再依赖 Zookeeper，大大简化了 Kafka 的架构，让你可以以一种轻量级的方式来使用 Kafka</font>。</p>\n<p>不过，要提示一下：如果要使用 KRaft 模式的话，建议选择较高版本的 Kafka，因为这个功能还在持续完善优化中。Kafka 3.3.1 版本是第一个将 KRaft（Kafka Raft）共识协议标记为生产就绪的版本。</p>\n<p>![](<span class=\"exturl\" data-url=\"aHR0cHM6Ly9vc3MuamF2YWd1aWRlLmNuL2dpdGh1Yi9qYXZhZ3VpZGUvaGlnaC1wZXJmb3JtYW5jZS9tZXNzYWdlLXF1ZXVlL2thZmthMy4zLjEta3JhZnQt\">https://oss.javaguide.cn/github/javaguide/high-performance/message-queue/kafka3.3.1-kraft-</span> production-ready.png)</p>\n<h3 id=\"消费顺序-消息丢失-重复消费\"><a class=\"anchor\" href=\"#消费顺序-消息丢失-重复消费\">#</a> 消费顺序、消息丢失、重复消费</h3>\n<h4 id=\"如何保证消息的消费顺序\"><a class=\"anchor\" href=\"#如何保证消息的消费顺序\">#</a> 如何保证消息的消费顺序？</h4>\n<p>我们在使用消息队列的过程中经常有业务场景需要严格保证消息的消费顺序，比如我们同时发了 2 个消息，这 2 个消息对应的操作分别对应的数据库操作是：</p>\n<ol>\n<li>更改用户会员等级。</li>\n<li>根据会员等级计算订单价格。</li>\n</ol>\n<p>假如这两条消息的消费顺序不一样造成的最终结果就会截然不同。</p>\n<p>我们知道<font color='red'> Kafka 中 Partition (分区) 是真正保存消息的地方</font>，我们发送的消息都被放在了这里。而 Partition (分区) 又存在于 Topic (主题) 概念中，并且我们可以给特定 Topic 指定多个 Partition。</p>\n<p><img data-src=\"https://oss.javaguide.cn/github/javaguide/high-performance/message-queue/KafkaTopicPartionsLayout.png\" alt=\"img\" /></p>\n<p>每次添加消息到 Partition (分区) 的时候都会采用 **<font color='red'>尾加法</font>**，如上图所示。 <font color='red'>Kafka 只能为我们保证 Partition（分区）中的消息有序，通过 **offset（偏移量）** 实现</font>。</p>\n<blockquote>\n<p>消息在被追加到 Partition (分区) 的时候都会分配一个特定的偏移量（offset）。</p>\n</blockquote>\n<p>所以，我们就有一种很简单的保证消息消费顺序的方法：1 个 Topic 只对应一个 Partition。这样当然可以解决问题，但是破坏了 Kafka 的设计初衷。</p>\n<p>Kafka 中发送 1 条消息的时候，可以指定 topic、partition、key、data（数据）4 个参数。如果你发送消息的时候指定了 Partition 的话，所有消息都会被发送到指定的 Partition。并且，<font color='red'>同一个 key 的消息可以保证只发送到同一个 partition</font>，这个我们可以采用表 / 对象的 id 来作为 key 。</p>\n<p>总结一下，对于如何保证 Kafka 中消息消费的顺序，有了下面两种方法：</p>\n<ol>\n<li>1 个 Topic 只对应一个 Partition。</li>\n<li>（推荐）<strong>发送消息的时候指定 key/Partition</strong>。</li>\n</ol>\n<p>当然不仅仅只有上面两种方法，上面两种方法是我觉得比较好理解的。</p>\n<h4 id=\"如何保证消息不丢失\"><a class=\"anchor\" href=\"#如何保证消息不丢失\">#</a> 如何保证消息不丢失？</h4>\n<h5 id=\"情况1producer-丢失消息\"><a class=\"anchor\" href=\"#情况1producer-丢失消息\">#</a> 情况 1：Producer 丢失消息</h5>\n<p>Producer 调用  <code>send</code>  方法发送消息之后，消息可能因为网络问题并没有发送过去。所以，我们不能默认在调用  <code>send</code>  方法发送消息之后消息发送成功了。</p>\n<p>为了确定消息是发送成功，我们要判断消息发送的结果。但是要注意的是<font color='red'> Kafka 中 Producer 使用  <code>send</code>  方法发送消息实际上是异步的操作，可以通过  <code>get()</code>  方法获取调用结果，但是这样也让它变为了同步操作</font>，示例代码如下：</p>\n<blockquote>\n<p>详细代码见这篇文章：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3M/X19iaXo9TXpnMk9UQTBOamswT0E9PSZhbXA7bWlkPTIyNDc0ODYyNjkmYW1wO2lkeD0yJmFtcDtzbj1lYzAwNDE3YWQ2NDFkZDhjM2QxNDVkNzRjYWZhMDljZSZhbXA7Y2hrc209Y2VhMjQ0ZjZmOWQ1Y2RlMGM4ZWIyMzNmY2M0Y2Y4MmUxMWFjZDA2NDQ2NzE5YTdhZjU1MjMwNjQ5ODYzYTNkZGQ5NWY3OGQxMTFkZSZhbXA7dG9rZW49MTYzMzk1NzI2MiZhbXA7bGFuZz16aF9DTiNyZA==\">Kafka 系列第三篇！10 分钟学会如何在 Spring Boot 程序中使用 Kafka 作为消息队列？</span></p>\n</blockquote>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token class-name\">SendResult</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">Object</span><span class=\"token punctuation\">></span></span> sendResult <span class=\"token operator\">=</span> kafkaTemplate<span class=\"token punctuation\">.</span><span class=\"token function\">send</span><span class=\"token punctuation\">(</span>topic<span class=\"token punctuation\">,</span> o<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>sendResult<span class=\"token punctuation\">.</span><span class=\"token function\">getRecordMetadata</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>  logger<span class=\"token punctuation\">.</span><span class=\"token function\">info</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"生产者成功发送消息到\"</span> <span class=\"token operator\">+</span> sendResult<span class=\"token punctuation\">.</span><span class=\"token function\">getProducerRecord</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">topic</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token string\">\"-> \"</span> <span class=\"token operator\">+</span> sendRe</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>              sult<span class=\"token punctuation\">.</span><span class=\"token function\">getProducerRecord</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">value</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>但是<font color='red'>一般不推荐这么做</font>！可以<strong>借助  <code>ListenableFuture</code>  为 Producer 的  <code>send</code>  方法添加回调函数</strong>的形式，示例代码如下：</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token class-name\">ListenableFuture</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">SendResult</span><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">Object</span><span class=\"token punctuation\">></span><span class=\"token punctuation\">></span></span> future <span class=\"token operator\">=</span> kafkaTemplate<span class=\"token punctuation\">.</span><span class=\"token function\">send</span><span class=\"token punctuation\">(</span>topic<span class=\"token punctuation\">,</span> o<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>        future<span class=\"token punctuation\">.</span><span class=\"token function\">addCallback</span><span class=\"token punctuation\">(</span>result <span class=\"token operator\">-></span> logger<span class=\"token punctuation\">.</span><span class=\"token function\">info</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"生产者成功发送消息到topic:&#123;&#125; partition:&#123;&#125;的消息\"</span><span class=\"token punctuation\">,</span> result<span class=\"token punctuation\">.</span><span class=\"token function\">getRecordMetadata</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">topic</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> result<span class=\"token punctuation\">.</span><span class=\"token function\">getRecordMetadata</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">partition</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>                ex <span class=\"token operator\">-></span> logger<span class=\"token punctuation\">.</span><span class=\"token function\">error</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"生产者发送消息失败，原因：&#123;&#125;\"</span><span class=\"token punctuation\">,</span> ex<span class=\"token punctuation\">.</span><span class=\"token function\">getMessage</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p><strong><font color='red'>如果消息发送失败的话，我们检查失败的原因之后重新发送即可</font></strong>！</p>\n<ul>\n<li>\n<p>这里推荐<font color='red'>为 Producer 的  <code>retries</code> （重试次数）设置一个比较合理的值，一般是 3 </font>，但是为了保证消息不丢失的话一般会设置比较大一点。设置完成之后，当出现网络问题之后能够自动重试消息发送，避免消息丢失。</p>\n</li>\n<li>\n<p>另外，<font color='red'>建议还要设置重试间隔</font>，因为间隔太小的话重试的效果就不明显了，网络波动一次你 3 次一下子就重试完了。</p>\n</li>\n</ul>\n<h5 id=\"情况2consumer-丢失消息\"><a class=\"anchor\" href=\"#情况2consumer-丢失消息\">#</a> 情况 2：Consumer 丢失消息</h5>\n<p>我们知道消息在被追加到 Partition (分区) 的时候都会分配一个特定的 offset（偏移量）。<font color='red'>offset 表示 Consumer 当前消费到的 Partition (分区) 的所在位置</font>。Kafka 通过偏移量（offset）可以保证消息在分区内的顺序性。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/kafka-offset.jpg\" alt=\"kafka offset\" /></p>\n<center>kafka offset</center>\n<p><font color='red'>当 Consumer 拉取到了 Partition 的某个消息之后，Consumer 会自动提交了  offset </font>。自动提交的话会有一个问题，试想一下，当 Consumer 刚拿到这个消息准备进行真正消费的时候，突然挂掉了，消息实际上并没有被消费，但是 offset 却被自动提交了。</p>\n<p>解决办法也比较粗暴，我们 ** 关闭自动提交 offset，每次在真正消费完消息之后再手动提交 offset **。 但是，细心的朋友一定会发现，<font color='red'>这样会带来消息被重新消费的问题</font>。比如你刚刚消费完消息之后，还没提交 offset，结果自己挂掉了，那么这个消息理论上就会被消费两次。</p>\n<h5 id=\"情况3kafka-丢失消息\"><a class=\"anchor\" href=\"#情况3kafka-丢失消息\">#</a> 情况 3：Kafka 丢失消息</h5>\n<p>我们知道<font color='red'> Kafka 为 Partition 引入了多副本（Replica）机制</font>。Partition 中的多个副本之间会有一个叫做 leader 的家伙，其他副本称为 follower。我们发送的消息会被发送到 leader 副本，然后 follower 副本才能从 leader 副本中拉取消息进行同步。Producer 和 Comsumer 只与 leader 副本交互。可以理解为其他 follower 副本只是 leader 副本的拷贝，它们的存在只是为了保证消息存储的安全性。</p>\n<p>试想一种情况：<font color='red'>假如 leader 副本所在的 broker 突然挂掉，但是 leader 的数据还有一些没有被 follower 副本的同步的话，就会造成<strong>消息丢失</strong></font>。</p>\n<ul>\n<li>\n<p><strong>设置  <code>acks = all</code> </strong>：<font color='red'>acks 是 Kafka Producer 很重要的一个参数，其默认值为 1，代表我们的消息被 leader 副本接收之后就算被成功发送</font>。<strong><font color='red'>配置  <code>acks = all</code>  表示只有所有 ISR 列表的副本全部收到消息时，Producer 才会接收到来自服务器的响应</font></strong>。这种模式是<font color='red'>最高级别、最安全</font>的，可以确保不止一个 Broker 接收到了消息，但副作用是<font color='red'>延迟会很高</font>。</p>\n<blockquote>\n<p>Partition 中的所有副本统称为 <strong> <code>AR</code> </strong>（Assigned Repllicas）。所有与 leader 副本保持一定程度同步的副本（包括 Leader 本身）组成 <strong> <code>ISR</code> </strong>（In-Sync Replicas），ISR 集合是 AR 集合中的一个子集。</p>\n</blockquote>\n</li>\n<li>\n<p><strong>设置  <code>replication.factor &gt;= 3</code> </strong>：为了保证 leader 副本能有 follower 副本能同步消息，可以 **<font color='red'>确保每个 Partition 至少有 3 个副本</font>**。虽然造成了数据冗余，但是带来了<font color='red'>数据的安全性</font>。</p>\n</li>\n<li>\n<p><strong>设置  <code>min.insync.replicas &gt; 1</code> </strong>：<strong><font color='red'>代表消息至少要被写入到 2 个副本才算是被成功发送</font></strong>。其默认值为 1 ，在实际生产中应尽量避免。</p>\n</li>\n<li>\n<p><strong>确保  <code>replication.factor &gt; min.insync.replicas</code> </strong>：<font color='red'>为了保证整个 Kafka 服务的高可用性</font>。设想一下假如两者相等的话，只要是有一个副本挂掉，整个 Partition 就无法正常工作了。这明显违反高可用性！<font color='red'>一般推荐设置成  <code>replication.factor = min.insync.replicas + 1</code> </font>。</p>\n</li>\n<li>\n<p><strong>设置  <code>unclean.leader.election.enable = false</code> </strong>：</p>\n<blockquote>\n<p>Kafka 从 0.11.0.0 版本开始， <code>unclean.leader.election.enable</code>  参数的默认值改为 false</p>\n</blockquote>\n<p>我们最开始也说了我们发送的消息会被发送到 leader 副本，然后 follower 副本才能从 leader 副本中拉取消息进行同步，多个 follower 副本之间的消息同步情况不一样。当我们配置了 unclean.leader.election.enable = false 的话，<strong><font color='red'>当 leader 副本发生故障时，就不会从同步程度达不到要求的 follower 副本中选择出 leader</font></strong>，降低了消息丢失的可能性。</p>\n</li>\n</ul>\n<h4 id=\"如何保证消息不被重复消费\"><a class=\"anchor\" href=\"#如何保证消息不被重复消费\">#</a> 如何保证消息不被重复消费？</h4>\n<p>kafka 出现消息重复消费的原因：</p>\n<ul>\n<li>\n<p><strong><font color='red'>根本原因：Consumer 已经消费了消息，但没有成功提交 offset</font></strong></p>\n</li>\n<li>\n<p>直接原因：Consumer 由于处理业务时间长或者网络链接等原因，<font color='red'>让 Kafka 认为服务假死，触发了 Partition  <code>rebalance</code> </font>。</p>\n</li>\n</ul>\n<p>解决方案：</p>\n<ul>\n<li><strong>Consumer 消费消息服务做幂等校验</strong>，比如 Redis 的 set、MySQL 的主键等天然的幂等功能，这种方法最有效。</li>\n<li><strong>将  <code>enable.auto.commit</code>  参数设置为 false，关闭 offset 的自动提交，开发者在代码中手动提交 offset</strong>。那么这里会有个问题：什么时候提交 offset 合适？\n<ul>\n<li>处理完消息再提交：依旧有消息重复消费的风险，和自动提交一样</li>\n<li><strong>拉取到消息即提交</strong>：会有消息丢失的风险。允许消息延时的场景，一般会采用这种方式。然后，通过定时任务在业务不繁忙（比如凌晨）的时候做数据兜底。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"重试机制\"><a class=\"anchor\" href=\"#重试机制\">#</a> 重试机制</h3>\n<blockquote>\n<p>在 Kafka 如何保证消息不丢失中提到了 Kafka 的重试机制。</p>\n<p>网上关于 Spring Kafka 的默认重试机制文章很多，但大多都是过时的，和实际运行结果完全不一样。以下是根据 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9tdm5yZXBvc2l0b3J5LmNvbS9hcnRpZmFjdC9vcmcuc3ByaW5nZnJhbWV3b3JrLmthZmthL3NwcmluZy1rYWZrYS8yLjkuMw==\">spring-kafka-2.9.3</span> 源码重新梳理一下。</p>\n</blockquote>\n<h4 id=\"消费失败后会先重试多次重试失败后会跳过\"><a class=\"anchor\" href=\"#消费失败后会先重试多次重试失败后会跳过\">#</a> 消费失败后会先重试，多次重试失败后会跳过</h4>\n<p>Producer 代码：</p>\n<pre><code class=\"language-Java\"> for (int i = 0; i &lt; 10; i++) &#123;\n   kafkaTemplate.send(KafkaConst.TEST_TOPIC, String.valueOf(i))\n &#125;\n</code></pre>\n<p>Comsumer 代码：</p>\n<pre><code class=\"language-Java\">   @KafkaListener(topics = &#123;KafkaConst.TEST_TOPIC&#125;,groupId = &quot;apple&quot;)\n   private void customer(String message) throws InterruptedException &#123;\n       log.info(&quot;kafka customer:&#123;&#125;&quot;,message);\n       Integer n = Integer.parseInt(message);\n       if (n%5==0)&#123; // 当n为0和5时抛出异常\n           throw new  RuntimeException();\n       &#125;\n   &#125;\n</code></pre>\n<p><strong>在默认配置下，当消费异常会进行重试，重试多次后会跳过当前消息，继续进行后续消息的消费，不会一直卡在当前消息</strong>。</p>\n<p>下面是一段消费的日志，可以看出当  <code>test-0@95</code>  重试多次后会被跳过。</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token number\">2023</span><span class=\"token operator\">-</span><span class=\"token number\">08</span><span class=\"token operator\">-</span><span class=\"token number\">10</span> <span class=\"token number\">12</span><span class=\"token operator\">:</span><span class=\"token number\">03</span><span class=\"token operator\">:</span><span class=\"token number\">32.918</span> <span class=\"token constant\">DEBUG</span> <span class=\"token number\">9700</span> <span class=\"token operator\">--</span><span class=\"token operator\">-</span> <span class=\"token punctuation\">[</span>ntainer#<span class=\"token number\">0</span><span class=\"token operator\">-</span><span class=\"token number\">0</span><span class=\"token operator\">-</span><span class=\"token class-name\">C</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token class-name\"><span class=\"token namespace\">o<span class=\"token punctuation\">.</span>s<span class=\"token punctuation\">.</span>kafka<span class=\"token punctuation\">.</span>listener<span class=\"token punctuation\">.</span></span>DefaultErrorHandler</span>   <span class=\"token operator\">:</span> <span class=\"token class-name\">Skipping</span> seek of<span class=\"token operator\">:</span> test<span class=\"token operator\">-</span><span class=\"token number\">0</span><span class=\"token annotation punctuation\">@95</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token number\">2023</span><span class=\"token operator\">-</span><span class=\"token number\">08</span><span class=\"token operator\">-</span><span class=\"token number\">10</span> <span class=\"token number\">12</span><span class=\"token operator\">:</span><span class=\"token number\">03</span><span class=\"token operator\">:</span><span class=\"token number\">32.918</span> <span class=\"token constant\">TRACE</span> <span class=\"token number\">9700</span> <span class=\"token operator\">--</span><span class=\"token operator\">-</span> <span class=\"token punctuation\">[</span>ntainer#<span class=\"token number\">0</span><span class=\"token operator\">-</span><span class=\"token number\">0</span><span class=\"token operator\">-</span><span class=\"token class-name\">C</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token class-name\"><span class=\"token namespace\">o<span class=\"token punctuation\">.</span>s<span class=\"token punctuation\">.</span>kafka<span class=\"token punctuation\">.</span>listener<span class=\"token punctuation\">.</span></span>DefaultErrorHandler</span>   <span class=\"token operator\">:</span> <span class=\"token class-name\">Seeking</span><span class=\"token operator\">:</span> test<span class=\"token operator\">-</span><span class=\"token number\">0</span> <span class=\"token keyword\">to</span><span class=\"token operator\">:</span> <span class=\"token number\">96</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token number\">2023</span><span class=\"token operator\">-</span><span class=\"token number\">08</span><span class=\"token operator\">-</span><span class=\"token number\">10</span> <span class=\"token number\">12</span><span class=\"token operator\">:</span><span class=\"token number\">03</span><span class=\"token operator\">:</span><span class=\"token number\">32.918</span>  <span class=\"token constant\">INFO</span> <span class=\"token number\">9700</span> <span class=\"token operator\">--</span><span class=\"token operator\">-</span> <span class=\"token punctuation\">[</span>ntainer#<span class=\"token number\">0</span><span class=\"token operator\">-</span><span class=\"token number\">0</span><span class=\"token operator\">-</span><span class=\"token class-name\">C</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token class-name\"><span class=\"token namespace\">o<span class=\"token punctuation\">.</span>a<span class=\"token punctuation\">.</span>k<span class=\"token punctuation\">.</span>clients<span class=\"token punctuation\">.</span>consumer<span class=\"token punctuation\">.</span></span>KafkaConsumer</span>     <span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token class-name\">Consumer</span> clientId<span class=\"token operator\">=</span>consumer<span class=\"token operator\">-</span>apple<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> groupId<span class=\"token operator\">=</span>apple<span class=\"token punctuation\">]</span> <span class=\"token class-name\">Seeking</span> <span class=\"token keyword\">to</span> <span class=\"token namespace\">offset</span> <span class=\"token number\">96</span> <span class=\"token keyword\">for</span> partition test<span class=\"token operator\">-</span><span class=\"token number\">0</span></pre></td></tr></table></figure><h4 id=\"默认重试-10-次时间间隔为-0\"><a class=\"anchor\" href=\"#默认重试-10-次时间间隔为-0\">#</a> 默认重试 10 次，时间间隔为 0</h4>\n<blockquote>\n<p>源码略了</p>\n</blockquote>\n<p>总结：<strong>Kafka Comsumer 在默认配置下会进行最多 10 次重试，每次重试的时间间隔为 0，即立即重试。如果在 10 次重试后仍然无法成功消费消息，则不再进行重试，该消息将被视为消费失败</strong>。</p>\n<h4 id=\"自定义重试次数-时间间隔\"><a class=\"anchor\" href=\"#自定义重试次数-时间间隔\">#</a> 自定义重试次数、时间间隔</h4>\n<p>从上面的代码可以知道，默认错误处理器的重试次数以及时间间隔是由  <code>FixedBackOff</code>  控制的， <code>FixedBackOff</code>  是  <code>DefaultErrorHandler</code>  初始化时默认的。</p>\n<p>所以自定义重试次数以及时间间隔，<strong>只需要在  <code>DefaultErrorHandler</code>  初始化的时候传入自定义的  <code>FixedBackOff</code>  即可</strong>。</p>\n<p>重新实现一个  <code>KafkaListenerContainerFactory</code>  ，调用  <code>setCommonErrorHandler</code>  设置新的自定义的错误处理器就可以实现。</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token annotation punctuation\">@Bean</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token class-name\">KafkaListenerContainerFactory</span> <span class=\"token function\">kafkaListenerContainerFactory</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">ConsumerFactory</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">></span></span> consumerFactory<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token class-name\">ConcurrentKafkaListenerContainerFactory</span> factory <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ConcurrentKafkaListenerContainerFactory</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token comment\">// 自定义重试时间间隔以及次数</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token class-name\">FixedBackOff</span> fixedBackOff <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">FixedBackOff</span><span class=\"token punctuation\">(</span><span class=\"token number\">1000</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    factory<span class=\"token punctuation\">.</span><span class=\"token function\">setCommonErrorHandler</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">DefaultErrorHandler</span><span class=\"token punctuation\">(</span>fixedBackOff<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    factory<span class=\"token punctuation\">.</span><span class=\"token function\">setConsumerFactory</span><span class=\"token punctuation\">(</span>consumerFactory<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token keyword\">return</span> factory<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h4 id=\"重试失败后如何告警\"><a class=\"anchor\" href=\"#重试失败后如何告警\">#</a> 重试失败后，如何告警？</h4>\n<p>重试失败后逻辑需要手动实现，以下是一个简单的例子。<strong>继承  <code>DefaultErrorHandler</code>  并重写  <code>handleRemaining</code>  函数，加上自定义的告警等操作</strong>。</p>\n<pre><code class=\"language-Java\">@Slf4j\npublic class DelErrorHandler extends DefaultErrorHandler &#123;\n\n    public DelErrorHandler(FixedBackOff backOff) &#123;\n        super(null,backOff);\n    &#125;\n\n    @Override\n    public void handleRemaining(Exception thrownException, List&lt;ConsumerRecord&lt;?, ?&gt;&gt; records, Consumer&lt;?, ?&gt; consumer, MessageListenerContainer container) &#123;\n        super.handleRemaining(thrownException, records, consumer, container);\n        log.info(&quot;重试多次失败&quot;);\n        // 自定义操作\n    &#125;\n&#125;\n</code></pre>\n<p><code>DefaultErrorHandler</code>  只是默认的一个错误处理器，Spring Kafka 还提供了  <code>CommonErrorHandler</code>  接口。手动实现  <code>CommonErrorHandler</code>  就可以实现更多的自定义操作，有很高的灵活性。例如根据不同的错误类型，实现不同的重试逻辑以及业务逻辑等。</p>\n<h4 id=\"重试最大次数失败后如何再次处理该消息\"><a class=\"anchor\" href=\"#重试最大次数失败后如何再次处理该消息\">#</a> 重试最大次数失败后，如何再次处理该消息？</h4>\n<p>当达到最大重试次数后，消息数据会被直接跳过，继续向后进行。当代码修复后，如何重新消费这些重试失败的消息数据呢？</p>\n<p><strong>死信队列（Dead Letter Queue，简称 DLQ）</strong> 是消息中间件中的一种特殊队列。它主要 **<font color='red'>用于处理无法被 Comsumer 正确处理的消息</font>**，通常是因为<font color='red'>消息格式错误、处理失败、消费超时</font>等情况导致的消息被 &quot;丢弃&quot; 或 &quot;死亡&quot; 的情况。</p>\n<p>当消息进入队列后，消费者会尝试处理它。如果处理失败，或者超过一定的重试次数仍无法被成功处理，消息可以发送到死信队列中，而不是被永久性地丢弃。<font color='red'>在死信队列中，可以进一步分析、处理这些无法正常消费的消息，以便定位问题、修复错误，并采取适当的措施</font>。</p>\n<h4 id=\"重试注解-retryabletopic\"><a class=\"anchor\" href=\"#重试注解-retryabletopic\">#</a> 重试注解  <code>@RetryableTopic</code></h4>\n<p>这是 Spring Kafka 中的一个注解，<strong><font color='red'>用于配置某个 Topic 支持消息重试</font></strong>，更推荐使用这个注解来完成重试。</p>\n<pre><code class=\"language-Java\">// 重试 5 次，重试间隔 100 毫秒,最大间隔 1 秒\n@RetryableTopic(\n        attempts = &quot;5&quot;,\n        backoff = @Backoff(delay = 100, maxDelay = 1000)\n)\n@KafkaListener(topics = &#123;KafkaConst.TEST_TOPIC&#125;, groupId = &quot;apple&quot;)\nprivate void customer(String message) &#123;\n    log.info(&quot;kafka customer:&#123;&#125;&quot;, message);\n    Integer n = Integer.parseInt(message);\n    if (n % 5 == 0) &#123;\n        throw new RuntimeException();\n    &#125;\n    System.out.println(n);\n&#125;\n</code></pre>\n<p>当达到最大重试次数后，如果仍然无法成功处理消息，消息会被发送到对应的死信队列中。<font color='red'>对于死信队列的处理，既可以用  <code>@DltHandler</code>  处理，也可以使用  <code>@KafkaListener</code>  重新消费</font>。</p>\n<h3 id=\"面试题kafka-消费组有什么特性\"><a class=\"anchor\" href=\"#面试题kafka-消费组有什么特性\">#</a> 【面试题】kafka 消费组有什么特性？</h3>\n<p>Kafka 消费组：是 Kafka 提供的<font color='red'>可扩展、具有容错性的 Comsumer 机制</font>。同一个消费组的多个 Comsumer 能分布到多个物理机器上<font color='red'>加速消费</font>，同时也可以实现<font color='red'>负载均衡</font>。</p>\n<p>当某个 Comsumer 宕机时，其他 Comsumer 可以继续消费该 Partition 的数据，从而保证了<font color='red'>数据的可靠性和持久性</font>。</p>\n<p>因此，Kafka 消费组有以下特性：</p>\n<ul>\n<li>同一个消费组内的<font color='red'>所有 Comsumer 共享一个公共 ID</font>。</li>\n<li>消费组内的<font color='red'>每个 Comsumer 都有自己的 offset (偏移量)</font>，用于记录已经消费过的消息位置。</li>\n<li>消费组内的<font color='red'>每个 Comsumer 可以处理 Partition 中的所有消息</font>。</li>\n</ul>\n<h3 id=\"面试题kafka-多-topic-为什么有性能问题\"><a class=\"anchor\" href=\"#面试题kafka-多-topic-为什么有性能问题\">#</a> 【面试题】kafka 多 topic 为什么有性能问题？</h3>\n<p>kafka 多 topic 可能会导致性能问题的<font color='gree'>原因</font>：</p>\n<ul>\n<li><strong>Partition 数量增加</strong>：每个 topic 都会被分成多个 Partition，当有大量的 topic 存在时， Partition 数量也会相应增加。这会导致 Kafka 需要处理更多的 Partition，增加了系统的负载和资源消耗。</li>\n<li><strong>网络开销增加</strong>：Kafka 的多 topic 会导致更多的网络通信开销。当一个 Producer 同时向多个 topic 发送消息时，需要建立多个网络连接，并且需要维护多个网络通信的状态。这增加了网络开销和延迟。</li>\n<li><strong>资源竞争</strong>：多个 topic 同时进行读写操作时，会引起资源的竞争。例如，多个 Comsumer 同时消费不同的 topic，会导致 Comsumer 之间的竞争和争夺资源的情况，从而影响系统的性能。</li>\n<li><strong>数据分布不均衡</strong>：当有大量的 topic 存在时，数据的分布可能会不均衡。某些 topic 可能会有更多的数据量，而某些 topic 可能会有较少的数据量。这会<font color='red'>导致某些 broker 负载过重</font>，而其他 broker 负载较轻，从而影响整个系统的性能。</li>\n</ul>\n<p>为了解决这些性能问题，可以采取以下<font color='gree'>措施</font>：</p>\n<ul>\n<li><strong>合并 topic</strong>：如果有多个 topic 的数据量较小，可以考虑将它们合并为一个 topic，减少分区数量和网络开销。</li>\n<li><strong>增加资源</strong>：<font color='red'>增加 Kafka 集群的 broker 数量和 C omsumer 数量</font>，以便更好地处理多 topic 的负载。</li>\n<li><strong>均衡数据分布</strong>：通过调整 Partition 分配策略，使得数据在各个 broker 上均衡分布，避免负载不均的情况。</li>\n<li><strong>使用分区策略</strong>：根据业务需求，合理地选择分区策略，避免数据集中在某个 Partition 或某个 broker 上。</li>\n<li><strong>优化网络通信</strong>：通过合理的网络配置和优化，减少网络开销和延迟，提高系统的性能。</li>\n</ul>\n<h2 id=\"rocketmq-2\"><a class=\"anchor\" href=\"#rocketmq-2\">#</a> RocketMQ</h2>\n<p>RocketMQ 是一款功能强大的<strong>分布式消息系统</strong>，广泛应用于多个领域，包括异步通信解耦、企业解决方案、金融支付、电信、电子商务、快递物流、广告营销、社交、即时通信、移动应用、手游、视频、物联网、车联网等。</p>\n<p>RocketMQ 源码地址：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2FwYWNoZS9yb2NrZXRtcQ==\">https://github.com/apache/rocketmq</span></p>\n<p>RocketMQ 官方网站：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9yb2NrZXRtcS5hcGFjaGUub3JnL3poLw==\">https://rocketmq.apache.org</span></p>\n<p>文章描述 RocketMQ 相关概念和知识，如无特别声明，均是  <code>Apache RocketMQ 4.x</code>  版本。</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRlZS5jb20vbmFnZW9mZmVyL3NwcmluZ2Jvb3QtbGFkZGVy\">🔥SpringBoot Ladder</span>：从零到一学习 SpringBoot 各种组件框架实战的项目，让 Demo 变得简单。咱们文章中的 RocketMQ 示例也在这个项目。</p>\n<h3 id=\"使用场景\"><a class=\"anchor\" href=\"#使用场景\">#</a> 使用场景</h3>\n<h4 id=\"异步解耦\"><a class=\"anchor\" href=\"#异步解耦\">#</a> <mark>异步解耦</mark></h4>\n<p>最常见的一个场景是用户注册后，需要发送注册邮件和短信通知，以告知用户注册成功。传统的做法有以下两种：</p>\n<h5 id=\"串行方式\"><a class=\"anchor\" href=\"#串行方式\">#</a> 串行方式</h5>\n<p>串行方式下的注册流程如下图所示。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/p429262.png\" alt=\"img\" /></p>\n<p>数据流动如下所述：</p>\n<ol>\n<li>您在注册页面填写账号和密码并提交注册信息，这些注册信息首先会被写入注册系统。</li>\n<li>注册信息写入注册系统成功后，再发送请求至邮件通知系统。邮件通知系统收到请求后向用户发送邮件通知。</li>\n<li>邮件通知系统接收注册系统请求后再向下游的短信通知系统发送请求。短信通知系统收到请求后向用户发送短信通知。</li>\n</ol>\n<p>以上三个任务全部完成后，才返回注册结果到客户端，用户才能使用账号登录。</p>\n<p>假设每个任务耗时分别为 50ms，则用户需要在注册页面等待总共 150ms 才能登录。</p>\n<h5 id=\"并行方式\"><a class=\"anchor\" href=\"#并行方式\">#</a> 并行方式</h5>\n<p>并行方式下的注册流程如下图所示。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/p429331.png\" alt=\"img\" /></p>\n<p>数据流动如下所述：</p>\n<ol>\n<li>用户在注册页面填写账号和密码并提交注册信息，这些注册信息首先会被写入注册系统。</li>\n<li>注册信息写入注册系统成功后，再<font color='red'>同时发送请求至邮件和短信通知系统</font>。邮件和短信通知系统收到请求后分别向用户发送邮件和短信通知。</li>\n</ol>\n<p>以上两个任务全部完成后，才返回注册结果到客户端，用户才能使用账号登录。</p>\n<p>假设每个任务耗时分别为 50ms，其中，邮件和短信通知并行完成，则用户需要在注册页面等待总共 100ms 才能登录。</p>\n<h5 id=\"异步解耦-2\"><a class=\"anchor\" href=\"#异步解耦-2\">#</a> 异步解耦</h5>\n<p>对于用户来说，注册功能实际只需要注册系统存储用户的账户信息后，该用户便可以登录，后续的注册短信和邮件不是即时需要关注的步骤。</p>\n<p>对于注册系统而言，发送注册成功的短信和邮件通知并不一定要绑定在一起同步完成，所以实际<font color='red'>当数据写入注册系统后，注册系统就可以把其他的操作放入对应的 RocketMQ 中然后马上返回用户结果，由 RocketMQ 异步地进行这些操作</font>。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/p429333.png\" alt=\"img\" /></p>\n<p>数据流动如下所述：</p>\n<ol>\n<li>用户在注册页面填写账号和密码并提交注册信息，这些注册信息首先会被写入注册系统。</li>\n<li><font color='red'>注册信息写入注册系统成功后，再发送消息至 RocketMQ。RocketMQ 会马上返回响应给注册系统，注册完成。用户可立即登录。</font></li>\n<li><font color='red'>下游的邮件和短信通知系统订阅 RocketMQ 的此类注册请求消息</font>，即可向用户发送邮件和短信通知，完成所有的注册流程。</li>\n</ol>\n<p>用户只需在注册页面等待注册数据写入注册系统和 RocketMQ 的时间，即等待 55ms 即可登录。</p>\n<h4 id=\"流量削峰\"><a class=\"anchor\" href=\"#流量削峰\">#</a> <mark>流量削峰</mark></h4>\n<p>流量削峰也是 RocketMQ 的常用场景，一般在<font color='red'>秒杀或团队抢购</font>活动中使用广泛。</p>\n<p>在秒杀或团队抢购活动中，由于<font color='red'>用户请求量较大</font>，导致流量暴增，秒杀的应用在处理如此大量的访问流量后，下游的通知系统无法承载海量的调用量，甚至会导致系统崩溃等问题而发生漏通知的情况。为解决这些问题，<font color='red'>可在应用和下游通知系统之间加入 RocketMQ</font>。</p>\n<p><img data-src=\"https://images-machen.oss-cn-beijing.aliyuncs.com/p429350.png\" alt=\"img\" /></p>\n<p>秒杀处理流程如下所述：</p>\n<ol>\n<li>用户发起海量秒杀请求到秒杀业务处理系统。</li>\n<li>秒杀处理系统按照秒杀处理逻辑<font color='red'>将满足秒杀条件的请求发送 RocketMQ</font>。</li>\n<li><font color='red'>下游的通知系统订阅 RocketMQ 的秒杀相关消息</font>，再将秒杀成功的消息发送到相应用户。</li>\n<li>用户收到秒杀成功的通知。</li>\n</ol>\n<h4 id=\"顺序消息\"><a class=\"anchor\" href=\"#顺序消息\">#</a> 顺序消息</h4>\n<blockquote>\n<p>详细请见 “消息类型 - 顺序消息” 小节</p>\n</blockquote>\n<p>顺序消息是 RocketMQ 提供的<strong>一种对消息发送、消费顺序有严格要求的消息</strong>。</p>\n<h4 id=\"分布式模缓存同步\"><a class=\"anchor\" href=\"#分布式模缓存同步\">#</a> 分布式模缓存同步</h4>\n<p>双十一大促时，各个分会场会有琳琅满目的商品，每件商品的价格都会实时变化。使用缓存技术也无法满足对商品价格的访问需求，缓存服务器网卡满载。访问较多次商品价格查询影响会场页面的打开速度。</p>\n<p>此时需要提供一种广播机制，一条消息本来只可以被集群的一台机器消费，如果使用 RocketMQ 的<strong>广播消费模式</strong>，那么<font color='red'>这条消息会被所有节点消费一次，相当于把价格信息同步到需要的每台机器上，取代缓存的作用</font>。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/TB1ki7KXgMPMeJjy1XdXXasrXXa-1530-1140.png\" alt=\"img\" /></p>\n<h4 id=\"分布式定时延时调度\"><a class=\"anchor\" href=\"#分布式定时延时调度\">#</a> 分布式定时 / 延时调度</h4>\n<blockquote>\n<p>详细请见 “消息类型 - 定时消息” 小节</p>\n</blockquote>\n<p>RocketMQ 提供<strong>精确度到秒级的分布式定时消息能力</strong>（5.0 架构后），可广泛应用于<font color='red'>订单超时中心处理、分布式延时调度系统</font>等场景。</p>\n<h3 id=\"消息类型\"><a class=\"anchor\" href=\"#消息类型\">#</a> 消息类型</h3>\n<h4 id=\"普通消息\"><a class=\"anchor\" href=\"#普通消息\">#</a> 普通消息</h4>\n<p>普通消息一般应用于微服务解耦、事件驱动、数据集成等场景，这些场景大多数要求数据传输通道具有可靠的传输能力，且<font color='red'>对消息的处理时机、处理顺序没有特别要求</font>。</p>\n<p>以在线的电商交易场景为例，上游订单系统将用户下单支付这一业务事件封装成独立的普通消息并发送至 RocketMQ 服务端，下游按需从服务端订阅消息，并按照本地消费逻辑处理下游任务。<font color='red'>每个消息之间都是相互独立的，且不需要产生关联</font>。</p>\n<p>另外还有日志系统，以离线的日志收集场景为例，通过埋点组件收集前端应用的相关操作日志，并转发到 RocketMQ 。</p>\n<p><font color='gree'>普通消息的生命周期</font>：</p>\n<p><img data-src=\"https://rocketmq.apache.org/zh/assets/images/lifecyclefornormal-e8a2a7e42a0722f681eb129b51e1bd66.png\" alt=\"img\" /></p>\n<ul>\n<li><font color='cornflowerblue'>初始化（Initialized）</font>：消息被 Producer 构建并完成初始化，<font color='red'>待发送到服务端</font>的状态。</li>\n<li><font color='cornflowerblue'>待消费（Ready）</font>：<font color='red'>消息被发送到服务端</font>，对 Consumer 可见，等待消费的状态。</li>\n<li><font color='cornflowerblue'>消费中（Inflight）</font>：<font color='red'>消息被 Consumer 获取</font>，并按照其本地的业务逻辑进行处理的过程。此时服务端会等待 Consumer 完成消费并提交消费结果，如果一定时间后没有收到 Consumer 的响应，RocketMQ 会对消息进行<font color='red'>重试</font>处理。</li>\n<li><font color='cornflowerblue'>消费提交（Acked）</font>：Consumer 完成消费处理，并向服务端提交消费结果，服务端标记当前消息已经被处理（包括消费成功和失败）。RocketMQ 默认支持保留所有消息，此时消息数据并不会立即被删除，<font color='red'>只是逻辑标记已消费</font>。消息在保存时间到期或存储空间不足被删除前，<font color='red'>Consumer 仍然可以回溯消息，重新消费</font>。</li>\n<li><font color='cornflowerblue'>消息删除（Deleted）</font>：RocketMQ 按照消息保存机制滚动清理最早的消息数据，<font color='red'>将消息从物理文件中删除</font>。</li>\n</ul>\n<h4 id=\"定时消息\"><a class=\"anchor\" href=\"#定时消息\">#</a> 定时消息</h4>\n<p>在分布式定时调度触发、任务超时处理等场景，需要实现精准、可靠的定时事件触发。使用 RocketMQ 的定时消息可以<font color='red'>简化定时调度任务的开发逻辑</font>，实现高性能、可扩展、高可靠的定时触发能力。</p>\n<p><strong><font color='red'>定时消息仅支持在 MessageType 为 Delay 的 Topic 内使用</font></strong>，即定时消息只能发送至类型为定时消息的 Topic 中，发送的消息的类型必须和 Topic 的类型一致。</p>\n<p>基于定时消息的超时任务处理具备如下优势：</p>\n<ul>\n<li><font color='red'>定时精度高、开发门槛低</font>：消息定时时间不存在阶梯间隔，可以轻松实现任意精度事件触发，无需业务去重。</li>\n<li><font color='red'>高性能、可扩展</font>：传统的定时实现方案较为复杂，需要进行数据库扫描，容易遇到性能瓶颈的问题，RocketMQ 可以基于定时消息特性完成事件驱动，实现百万级消息 TPS 能力。</li>\n</ul>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/p433720.png\" alt=\"img\" /></p>\n<p><font color='gree'>定时消息的生命周期</font>：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/lifecyclefordelay-2ce8278df69cd026dd11ffd27ab09a17.png\" alt=\"img\" /></p>\n<ul>\n<li><font color='cornflowerblue'>初始化（Initialized）</font>：消息被生产者构建并完成初始化，待发送到服务端的状态。</li>\n<li><strong><font color='cornflowerblue'>定时中（In timing）</font></strong>：消息被发送到服务端，和普通消息不同的是，<strong>服务端不会直接构建消息索引，而是会将定时消息单独存储在定时存储系统中，等待定时时刻到达</strong>。</li>\n<li><font color='cornflowerblue'>待消费（Ready）</font>：<strong>定时时刻到达后，服务端将定时消息重新写入普通存储引擎，对下游消费者可见</strong>，等待消费者消费的状态。</li>\n<li><font color='cornflowerblue'>消费中（Inflight）</font>：消息被消费者获取，并按照消费者本地的业务逻辑进行处理的过程。此时服务端会等待消费者完成消费并提交消费结果，如果一定时间后没有收到消费者的响应，RocketMQ 会对消息进行重试处理。</li>\n<li><font color='cornflowerblue'>消费提交（Acked）</font>：消费者完成消费处理，并向服务端提交消费结果，服务端标记当前消息已经被处理（包括消费成功和失败）。RocketMQ 默认支持保留所有消息，此时消息数据并不会立即被删除，只是逻辑标记已消费。消息在保存时间到期或存储空间不足被删除前，消费者仍然可以回溯消息重新消费。</li>\n<li><font color='cornflowerblue'>消息删除（Deleted）</font>：Apache RocketMQ 按照消息保存机制滚动清理最早的消息数据，将消息从物理文件中删除。</li>\n</ul>\n<p>定时消息的实现逻辑：先经过定时存储等待触发，<font color='red'>定时时间到达后才会被投递给 Consumer</font>。因此，如果将大量定时消息的定时时间设置为同一时刻，则到达该时刻后会有大量消息同时需要被处理，会造成系统压力过大，导致消息分发延迟，影响定时精度。</p>\n<h4 id=\"顺序消息-2\"><a class=\"anchor\" href=\"#顺序消息-2\">#</a> 顺序消息</h4>\n<p>顺序消息是 RocketMQ 提供的<strong>一种对消息发送、消费顺序有严格要求的消息</strong>。<strong><font color='red'>顺序消息仅支持在 MessageType 为 FIFO 的 Topic 内使用</font></strong>，对于一个指定的 Topic，消息严格按照<font color='red'>先进先出（FIFO）</font>的原则进行消息发布和消费，即先发布的消息先消费，后发布的消息后消费。</p>\n<p>顺序消息分为分区顺序消息和全局顺序消息。</p>\n<ul>\n<li><strong><font color='cornflowerblue'>分区顺序消息</font></strong>：对于指定的一个 Topic，所有消息<font color='red'>根据 Sharding Key 进行区块分区</font>，同一个 Partition 内的消息按照严格的先进先出（FIFO）原则进行发布和消费。<strong><font color='red'>同一 Partition 内的消息保证顺序，不同 Partition 之间的消息顺序不做要求</font></strong>。\n<ul>\n<li>适用场景：适用于性能要求高，以 Sharding Key 作为分区字段，在同一个区块中严格地按照先进先出（FIFO）原则进行消息发布和消费的场景。</li>\n<li>示例\n<ul>\n<li>用户注册需要<font color='red'>发送验证码</font>，以用户 ID 作为 Sharding Key，那么同一个用户发送的消息都会按照发布的先后顺序来消费。</li>\n<li>电商的<font color='red'>订单创建</font>，以订单 ID 作为 Sharding Key，那么同一个订单相关的创建订单消息、订单支付消息、订单退款消息、订单物流消息都会按照发布的先后顺序来消费。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong><font color='cornflowerblue'>全局顺序消息</font></strong>：<strong><font color='red'>对于指定的一个 Topic，所有消息按照严格的先入先出（FIFO）的顺序来发布和消费</font></strong>。\n<ul>\n<li>适用场景：适用于性能要求不高，所有的消息严格按照 FIFO 原则来发布和消费的场景。</li>\n<li>示例：在证券处理中，以人民币兑换美元为 Topic，在价格相同的情况下，先出价者优先处理，则可以按照 FIFO 的方式发布和消费全局顺序消息。</li>\n</ul>\n</li>\n</ul>\n<p><strong><font color='red'>全局顺序消息实际上是一种特殊的分区顺序消息，即 Topic 中只有一个分区</font></strong>，因此全局顺序和分区顺序的实现原理相同。因为分区顺序消息有多个分区，所以<font color='red'>分区顺序消息比全局顺序消息的并发度和性能更高</font>。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/p326576.png\" alt=\"img\" /></p>\n<p>和普通消息发送相比，<font color='red'>顺序消息发送必须要设置消息组</font>（推荐实现 MessageQueueSelector 的方式，见下文）。要保证消息的顺序性需要单一 Producer 串行发送。</p>\n<p>单线程使用 MessageListenerConcurrently 可以顺序消费，多线程环境下使用 MessageListenerOrderly 才能顺序消费。</p>\n<h4 id=\"事务消息\"><a class=\"anchor\" href=\"#事务消息\">#</a> 事务消息</h4>\n<h3 id=\"基础概念\"><a class=\"anchor\" href=\"#基础概念\">#</a> 基础概念</h3>\n<blockquote>\n<p>RocketMQ 消息模型：<strong>在一个  <code>Topic</code>  中配置多个  <code>Queue</code> ，并且每个  <code>Queue</code>  维护每个  <code>Consumer组</code>  的  <code>offset</code> （消费位置）</strong> 实现了 <strong>主题模式 / 发布订阅模式</strong>。</p>\n</blockquote>\n<h4 id=\"topic-主题\"><a class=\"anchor\" href=\"#topic-主题\">#</a> Topic 主题</h4>\n<p><strong>Topic 是消息传输和存储的顶层容器，用于标识同一类业务逻辑的消息</strong>。Topic 的作用主要如下：</p>\n<ul>\n<li><strong>定义数据的分类隔离</strong>：在 Apache RocketMQ 的方案设计中，<font color='red'>建议将不同业务类型的数据拆分到不同的 Topic 中管理，实现存储的隔离性和订阅隔离性</font>。</li>\n<li><strong>定义数据的身份和权限</strong>：Apache RocketMQ 的消息本身是匿名无身份的<font color='red'>，同一分类的消息使用相同的 Topic 来做身份识别和权限管理</font>。</li>\n</ul>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/archifortopic-ef512066703a22865613ea9216c4c300.png\" alt=\"img\" /></p>\n<h4 id=\"queue-队列\"><a class=\"anchor\" href=\"#queue-队列\">#</a> Queue 队列</h4>\n<blockquote>\n<p>类似于 **Kafka 中的 Partition（分区）** 这一概念？</p>\n</blockquote>\n<p><strong>Queue 是消息存储和传输的实际容器，也是消息的最小存储单元</strong>。<font color='red'>每个 Topic 都是由多个 Queue 组成的</font>，以此实现 Queue 数量的水平拆分和 Queue 内部的流式存储。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/archiforqueue-dd6788b33bf2fc96b4a1dab83a1b0d71.png\" alt=\"img\" /></p>\n<h4 id=\"message-消息\"><a class=\"anchor\" href=\"#message-消息\">#</a> Message 消息</h4>\n<p><strong>Message 是最小数据传输单元</strong>。Producer 将业务数据的负载和拓展属性包装成 Message 发送到 Apache RocketMQ 服务端，服务端按照相关语义将 Message 投递到消费端进行消费。</p>\n<h4 id=\"producer-生产者\"><a class=\"anchor\" href=\"#producer-生产者\">#</a> Producer 生产者</h4>\n<p>发布消息的角色。<strong>Producer 通过 MQ 的负载均衡模块选择相应的 Broker 集群队列进行消息投递，投递的过程支持快速失败和重试</strong>。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/archiforproducer-ebb8ff832f6e857cbebc2c17c2044a3b.png\" alt=\"img\" /></p>\n<h4 id=\"consumer-消费者\"><a class=\"anchor\" href=\"#consumer-消费者\">#</a> Consumer 消费者</h4>\n<p>消息消费的角色。</p>\n<ul>\n<li>支持以 ** 推（push）、拉（pull）** 两种模式对消息进行消费。</li>\n<li>同时也支持<strong>集群方式</strong>和<strong>广播方式</strong>的消费。</li>\n<li>提供<strong>实时消息订阅机制</strong>，可以满足大多数用户的需求。</li>\n</ul>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/archiforconsumer-24914573add839fdf2ba2cbc0fcab7c4.png\" alt=\"img\" /></p>\n<h4 id=\"broker-代理服务器\"><a class=\"anchor\" href=\"#broker-代理服务器\">#</a> <mark>Broker 代理服务器</mark></h4>\n<p><strong>Broker 负责消息的存储、投递和查询，并保证服务高可用</strong>。其实 Broker 就是 MQ 服务器，Producer 生产消息到 Broker，Consumer 从 Broker 拉取并消费消息。</p>\n<p><font color='gree'>Broker、Topic、Queue 的关系</font>：</p>\n<ul>\n<li>一个 Topic 中存在多个 Queue</li>\n<li>一个 Topic 分布在多个 Broker 上，而一个 Broker 可以配置多个 Topic，即 <font color='red'>Topic 和 Broker 之间是多对多的关系</font></li>\n</ul>\n<p>如果某个 Topic 消息量很大，应该给它多配置几个 Queue (提高并发能力)，并且<strong>尽量多分布在不同 Broker 上，以减轻某个 Broker 的压力</strong>。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/16ef38687488a5a4.jpg\" alt=\"img\" /></p>\n<p>Broker 集群遵从 <strong>Master-Slave 架构</strong> ：</p>\n<ul>\n<li>Broker 分为 Master 与 Slave</li>\n<li>一个 Master 可以对应多个 Slave，但是一个 Slave 只能对应一个 Master</li>\n<li>Master 与 Slave 的对应关系通过指定相同的 BrokerName，不同的 BrokerId 来定义，<font color='red'>BrokerId 为 0 表示 Master</font>，非 0 表示 Slave</li>\n<li>Master 也可以部署多个</li>\n</ul>\n<h4 id=\"nameserver-名字服务器\"><a class=\"anchor\" href=\"#nameserver-名字服务器\">#</a> <mark>NameServer 名字服务器</mark></h4>\n<blockquote>\n<p>为 Broker 和 Producer、Consumer 解耦，类似于 SpringCloud 中的 Eureka / Nacos</p>\n</blockquote>\n<p>NameServer 是一个简单的 <strong>Broker 路由注册中心</strong>，支持 Broker 的注册与发现，主要提供两个功能：</p>\n<ul>\n<li><strong>Broker 管理</strong>：\n<ul>\n<li><font color='red'>NameServer 接受并保存 Broker 所提交的注册信息，作为 Broker 路由表的基本数据</font></li>\n<li><font color='red'>提供心跳检测机制，检查 Broker 是否还存活</font></li>\n</ul>\n</li>\n<li><strong>路由信息管理</strong>：\n<ul>\n<li>每个 NameServer 保存了关于 Broker 集群的整个路由信息、用于客户端查询的 Queue 信息</li>\n<li><font color='red'>Producer 和 Consumer 通过 NameServer 中的 Broker 路由表就可以知道整个 Broker 集群的路由信息，从而和对应的 Broker 进行消息的投递和消费</font>（Producer 和 Consumer 定期会向 NameServer 查询相关的 Broker 信息）</li>\n</ul>\n</li>\n</ul>\n<p><font color='red'>NameServer 通常会有多个实例部署，各实例间相互不进行信息通讯</font>。<font color='red'>Broker 向每一台 NameServer 注册自己的路由信息</font>，所以每一个 NameServer 实例上面都保存一份完整的路由信息。当某个 NameServer 因某种原因下线了，客户端仍然可以向其它 NameServer 获取路由信息。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/16ef386c6d1e8bdb.jpg\" alt=\"img\" /></p>\n<center>Producer、Consumer、Broker、NameServer</center>\n<blockquote>\n<p>上图中的四个角色实际上都需要做集群。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/16ef386fa3be1e53.jpg\" alt=\"img\" /></p>\n<center>官方架构图</center>\n<ul>\n<li><strong> <code>Broker</code>  做了集群，并且还进行了主从部署</strong>：由于消息分布在各个  <code>Broker</code>  上，一旦某个  <code>Broker</code>  宕机，则该  <code>Broker</code>  上的消息读写都会受到影响。所以  <code>RocketMQ</code>  提供了  <code>master/slave</code>  的结构， <code>salve</code>  定时从  <code>master</code>  同步数据 (同步刷盘或者异步刷盘)，<strong>如果  <code>master</code>  宕机，则  <code>slave</code>  提供消费服务，但是不能写入消息</strong> (后面我还会提到哦)。</li>\n<li><strong>为了保证高可用  <code>HA</code> ， <code>NameServer</code>  也做了集群部署，但它是去中心化的</strong>：意味着  <code>NameServer</code>  没有 master 节点，在  <code>RocketMQ</code>  中是通过 <strong>单个 Broker 和所有 NameServer 保持长连接</strong> ，并且  <code>Broker</code>  会定期向所有  <code>Nameserver</code>  发送心跳，其中包含了自身的  <code>Topic</code>  配置信息，这个步骤就对应图中的  <code>Routing Info</code> 。</li>\n<li>在  <code>Producer</code>  需要向  <code>Broker</code>  发送消息的时候，<strong>需要先从  <code>NameServer</code>  获取关于  <code>Broker</code>  的路由信息</strong>，然后通过 <strong>轮询</strong> 的方式向每个 Queue 中生产数据，以达到<strong>负载均衡</strong>的效果。</li>\n<li><code>Comsumer</code>  通过  <code>NameServer</code>  获取所有  <code>Broker</code>  的路由信息后，向  <code>Broker</code>  发送  <code>Pull</code>  请求来获取消息数据。 <code>Consumer</code>  可以以两种模式启动 —— <strong>广播（Broadcast）和集群（Cluster）</strong>：\n<ul>\n<li>广播模式下，一条消息会发送给 <strong>同一个消费组中的所有消费者</strong></li>\n<li>集群模式下消息只会发送给一个消费者</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<h4 id=\"部署模型小结\"><a class=\"anchor\" href=\"#部署模型小结\">#</a> 部署模型小结</h4>\n<ul>\n<li>\n<p>每个 Broker 与 NameServer 集群中的所有节点建立长连接，定时将 Topic 信息注册到所有 NameServer。</p>\n</li>\n<li>\n<p>Producer 与 NameServer 集群中的其中一个节点建立长连接，定期从 NameServer 获取 Topic/Broker 路由信息。并向提供 Topic 服务的 Broker Master 建立长连接，且定时向 Broker Master 发送心跳。Producer 完全无状态。</p>\n</li>\n<li>\n<p>Consumer 与 NameServer 集群中的其中一个节点建立长连接，定期从 NameServer 获取 Topic/Broker 路由信息，并向提供 Topic 服务的 Broker Master、Broker Slave 建立长连接，且定时向 Broker Master、Broker Slave 发送心跳。</p>\n<blockquote>\n<p><font color='red'>Consumer 既可以从 Broker Master 订阅消息，也可以从 Broker Slave 订阅消息</font>。</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"工作原理\"><a class=\"anchor\" href=\"#工作原理\">#</a> 工作原理</h3>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/p68921.png\" alt=\"img\" /></p>\n<h4 id=\"1-启动-nameserver\"><a class=\"anchor\" href=\"#1-启动-nameserver\">#</a> 1、启动 NameServer</h4>\n<p>启动 NameServer。NameServer 启动后监听端口，等待 Broker、Producer、Consumer 连接，相当于一个<font color='red'>路由控制中心</font>。</p>\n<h4 id=\"2-启动-broker\"><a class=\"anchor\" href=\"#2-启动-broker\">#</a> 2、启动 Broker</h4>\n<p>启动 Broker。<font color='red'>与所有 NameServer 保持长连接，定时发送心跳包</font>（包含当前 Broker 信息以及存储的所有 Topic 信息）。注册成功后，NameServer 集群中就有 Topic 跟 Broker 的映射关系。</p>\n<h4 id=\"3-创建-topic\"><a class=\"anchor\" href=\"#3-创建-topic\">#</a> 3、创建 Topic</h4>\n<p><font color='red'>创建 Topic 时需要指定该 Topic 要存储在哪些 Broker 上</font>，也可以在发送消息时自动创建 Topic。</p>\n<h4 id=\"4-producer-发送消息\"><a class=\"anchor\" href=\"#4-producer-发送消息\">#</a> 4、Producer 发送消息</h4>\n<p>Producer 发送消息。启动时先跟 NameServer 集群中的其中一台建立长连接，并从 NameServer 中查询当前发送的 Topic 存在于哪些 Broker 上，轮询从对应 Broker 上的 Queue 列表中选择一个 Queue，然后与该 Queue 所在的 Broker 建立长连接，从而向 Broker 发消息。</p>\n<h4 id=\"5-consumer-接收消息\"><a class=\"anchor\" href=\"#5-consumer-接收消息\">#</a> 5、Consumer 接收消息</h4>\n<p>Consumer 接受消息。跟其中一台 NameServer 建立长连接，获取当前订阅 Topic 存在于哪些 Broker 上，然后直接跟 Broker 建立连接通道，然后开始消费消息。</p>\n<h3 id=\"如何正确发送消息\"><a class=\"anchor\" href=\"#如何正确发送消息\">#</a> 如何正确发送消息</h3>\n<h4 id=\"不建议单一进程创建大量-producer\"><a class=\"anchor\" href=\"#不建议单一进程创建大量-producer\">#</a> 不建议单一进程创建大量 Producer</h4>\n<p>Apache RocketMQ 的 Producer 和 Topic 是多对多的关系，支持同一个 Producer 向多个 Topic 发送消息。<font color='red'>对于 Producer 的创建和初始化，建议遵循够用即可、最大化复用原则</font>，如果有需要发送消息到多个 Topic 的场景，无需为每个 Topic 都创建一个 Producer。</p>\n<h4 id=\"不建议频繁创建和销毁-producer\"><a class=\"anchor\" href=\"#不建议频繁创建和销毁-producer\">#</a> 不建议频繁创建和销毁 Producer</h4>\n<p>Apache RocketMQ 的 <font color='red'>Producer 是可以重复利用的底层资源</font>，类似数据库的连接池。因此不需要在每次发送消息时动态创建 Producer，且在发送结束后销毁 Producer。这样频繁的创建销毁会在服务端产生大量短连接请求，严重影响系统性能。</p>\n<p>正确示例：</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token class-name\">Producer</span> p <span class=\"token operator\">=</span> <span class=\"token class-name\">ProducerBuilder</span><span class=\"token punctuation\">.</span><span class=\"token function\">build</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">&lt;</span>n<span class=\"token punctuation\">;</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token class-name\">Message</span> m<span class=\"token operator\">=</span> <span class=\"token class-name\">MessageBuilder</span><span class=\"token punctuation\">.</span><span class=\"token function\">build</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    p<span class=\"token punctuation\">.</span><span class=\"token function\">send</span><span class=\"token punctuation\">(</span>m<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre> <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>p<span class=\"token punctuation\">.</span><span class=\"token function\">shutdown</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h3 id=\"consumer-分类\"><a class=\"anchor\" href=\"#consumer-分类\">#</a> Consumer 分类</h3>\n<ul>\n<li>PushConsumer</li>\n<li>SimpleConsumer</li>\n<li>PullConsumer</li>\n</ul>\n<h3 id=\"producer-和-consumer-分组\"><a class=\"anchor\" href=\"#producer-和-consumer-分组\">#</a> Producer 和 Consumer 分组</h3>\n<h4 id=\"producer-分组\"><a class=\"anchor\" href=\"#producer-分组\">#</a> Producer 分组</h4>\n<p>RocketMQ 服务端 5.x 版本开始，<strong>Producer 是匿名的，无需管理 Producer 分组（ProducerGroup）</strong>。</p>\n<p>对于历史版本服务端 3.x 和 4.x 版本，已经使用的 ProducerGroup 可以废弃无需再设置，且不会对当前业务产生影响。</p>\n<h4 id=\"consumer-分组\"><a class=\"anchor\" href=\"#consumer-分组\">#</a> Consumer 分组</h4>\n<p><strong>Consumer 分组是多个消费行为一致的 Consumer 的负载均衡分组</strong>。Consumer  分组不是具体实体而是一个逻辑资源。通过 Consumer 分组实现消费性能的水平扩展以及高可用容灾。</p>\n<p>Consumer 分组中的订阅关系、投递顺序性、消费重试策略是一致的。</p>\n<ul>\n<li>订阅关系：Apache RocketMQ 以 Consumer 分组的粒度管理订阅关系，实现订阅关系的管理和追溯。</li>\n<li>投递顺序性：Apache RocketMQ 的服务端将消息投递给 Consumer 消费时，支持顺序投递和并发投递，投递方式在 Consumer 分组中统一配置。</li>\n<li>消费重试策略：Consumer 消费消息失败时的重试策略，包括重试次数、死信队列设置等。</li>\n</ul>\n<p>RocketMQ 服务端 5.x 版本：上述 Consumer 的消费行为从关联的 Consumer 分组中统一获取，因此同一分组内所有 Consumer 的消费行为必然是一致的，客户端无需关注。</p>\n<p>RocketMQ 服务端 3.x/4.x 历史版本：上述消费逻辑由消费者客户端接口定义，因此，您需要自己在消费者客户端设置时保证同一分组下的消费者的消费行为一致。[来自官方网站]</p>\n<h3 id=\"如何解决顺序消费-重复消费\"><a class=\"anchor\" href=\"#如何解决顺序消费-重复消费\">#</a> 如何解决顺序消费、重复消费？</h3>\n<p>其实  <code>RocketMQ</code>  的架构基本和  <code>Kafka</code>  类似，只不过：</p>\n<ul>\n<li>RocketMQ 的注册中心是  <code>NameServer</code> ，而 Kafka 的是  <code>Zookeeper</code></li>\n<li>RocketMQ 的 **Queue（队列）** 相当于是 Kafka 的 <strong>Partition（分区）</strong></li>\n</ul>\n<h4 id=\"顺序消费\"><a class=\"anchor\" href=\"#顺序消费\">#</a> 顺序消费</h4>\n<blockquote>\n<p>可以参考 “消息类型 - 顺序消息” 小节</p>\n</blockquote>\n<p><strong> <code>RocketMQ</code>  在 Topic 上是无序的、它只有在 Queue 层面才保证有序</strong>：</p>\n<ul>\n<li><font color='cornflowerblue'>普通顺序（分区顺序消息）</font>：对于一个 Topic，同一 Queue 内的消息保证顺序，不同 Queue 之间的消息顺序不做要求。</li>\n<li><font color='cornflowerblue'>严格顺序（全局顺序消息）</font>：对于指定的一个 Topic，所有消息按照严格的先入先出（FIFO）的顺序来发布和消费。</li>\n</ul>\n<p>严格顺序的代价巨大，而 MQ 一般能容忍短暂的乱序，所以<font color='red'>推荐使用普通顺序模式！</font></p>\n<hr />\n<p>在 Producer 生产消息的时候，会轮询同一 Topic 的不同 Queue 来发送消息。那么如果此时我有几个消息分别是同一个订单的创建、支付、发货，<font color='red'>在轮询的策略下这<strong>三个消息会被发送到不同的 Queue</strong>，那么此时就无法使用  <code>RocketMQ</code>  的队列有序特性来保证消息有序性了</font>。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/16ef3874585e096e.jpg\" alt=\"img\" /></p>\n<p>解决方法很简单，<strong>只需要将同一语义下的消息放入同一个队列</strong>（比如这里是同一个订单)，那我们就可以使用 <strong><font color='red'>Hash 取模法</font></strong> 来保证同一个订单在同一个队列中就行了。</p>\n<p>RocketMQ 实现了两种<font color='gree'> Queue 选择算法</font>：</p>\n<ul>\n<li>\n<p><font color='cornflowerblue'>轮询算法</font></p>\n<ul>\n<li><font color='red'>向消息指定的 Topic 所在 Queue 中依次发送消息</font>，保证消息均匀分布</li>\n<li>是 RocketMQ <font color='red'>默认</font>队列选择算法</li>\n</ul>\n</li>\n<li>\n<p><font color='cornflowerblue'>最小投递延迟算法</font></p>\n<ul>\n<li>\n<p>每次消息投递的时候统计消息投递的延迟，<font color='red'>优先选择消息延时小的 Queue</font>，导致消息分布不均匀，按照如下设置即可。</p>\n</li>\n<li>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>producer<span class=\"token punctuation\">.</span><span class=\"token function\">setSendLatencyFaultEnable</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li>\n<p><font color='cornflowerblue'>继承  <code>MessageQueueSelector</code>  实现自定义的选择算法</font></p>\n<ul>\n<li>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token class-name\">SendResult</span> sendResult <span class=\"token operator\">=</span> producer<span class=\"token punctuation\">.</span><span class=\"token function\">send</span><span class=\"token punctuation\">(</span>msg<span class=\"token punctuation\">,</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">MessageQueueSelector</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token annotation punctuation\">@Override</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token class-name\">MessageQueue</span> <span class=\"token function\">select</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">MessageQueue</span><span class=\"token punctuation\">></span></span> mqs<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Message</span> msg<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Object</span> arg<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>        <span class=\"token comment\">// 从 mqs 中选择一个队列，可以根据 msg 特点选择</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>        <span class=\"token keyword\">return</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Object</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ul>\n<h4 id=\"特殊情况\"><a class=\"anchor\" href=\"#特殊情况\">#</a> 特殊情况</h4>\n<h5 id=\"发送异常\"><a class=\"anchor\" href=\"#发送异常\">#</a> 发送异常</h5>\n<p>选择 Queue 后会与 Broker 建立连接，通过网络请求将消息发送到 Broker 上，如果 Broker 挂了或者网络波动发送消息超时，此时 RocketMQ 会进行重试。</p>\n<p>重新选择其他 Broker 中的 Queue 进行发送，默认重试两次，可以手动设置。</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>producer<span class=\"token punctuation\">.</span><span class=\"token function\">setRetryTimesWhenSendFailed</span><span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h5 id=\"消息过大\"><a class=\"anchor\" href=\"#消息过大\">#</a> 消息过大</h5>\n<p>消息超过 4k 时 RocketMQ 会将消息压缩后再发送到 Broker 上，减少网络资源的占用。</p>\n<h4 id=\"重复消费\"><a class=\"anchor\" href=\"#重复消费\">#</a> 重复消费</h4>\n<p>需求：有一个订单的处理积分的系统 FrancisQ，每当来一个消息的时候它就负责为创建这个订单的用户的积分加上相应的数值。可是有一次，消息队列发送给订单系统 FrancisQ 的订单信息，其要求是给 FrancisQ 的积分加上 500。但是积分系统在收到 FrancisQ 的订单信息处理完成之后返回给消息队列处理成功的信息的时候出现了网络波动 (当然还有很多种情况，比如 Broker 意外重启等等)，这条回应没有发送成功。那么，消息队列没收到积分系统的回应会不会尝试重发这个消息？问题就来了，我再发这个消息，万一它又给 FrancisQ 的账户加上 500 积分怎么办呢？</p>\n<hr />\n<p>解决方法：<strong>让 Consumer 实现幂等校验</strong>！即<font color='red'>对同一个消息的处理结果，执行多少次都不变</font>。</p>\n<blockquote>\n<p>幂等操作的特点：其执行任意多次所产生的影响，均与执行一次的影响相同。</p>\n</blockquote>\n<p>那么如何给业务实现幂等呢？这个还是需要结合具体的业务的。</p>\n<ul>\n<li>可以使用 **<font color='cornflowerblue'>写入  <code>Redis</code> </font>** 来保证，因为  <code>Redis</code>  的  <code>key</code>  和  <code>value</code>  就是天然支持幂等的。</li>\n<li>可以使用 **<font color='cornflowerblue'>数据库插入法</font>**，基于数据库的<font color='red'>唯一键</font>来保证重复数据不会被插入多条。</li>\n</ul>\n<p>需要根据特定场景使用特定的解决方案，你要知道你的消息消费是否是完全不可重复消费还是可以忍受重复消费的，然后再选择强校验和弱校验的方式。毕竟在 CS 领域还是很少有技术银弹的说法。</p>\n<hr />\n<p>而在互联网领域，幂等不仅仅适用于 **<font color='red'>消息队列的重复消费问题</font><strong>，也同样适用于在其他场景中来解决</strong><font color='red'>重复请求或者重复调用的问题</font>**：</p>\n<ul>\n<li>比如将 HTTP 服务设计成幂等的<font color='red'>解决前端或者 APP 重复提交表单数据的问题</font></li>\n<li>可以将一个微服务设计成幂等的，解决  <code>RPC</code>  框架<font color='red'>自动重试导致的重复调用问题</font>。</li>\n</ul>\n<h3 id=\"如何实现分布式事务\"><a class=\"anchor\" href=\"#如何实现分布式事务\">#</a> 如何实现分布式事务？</h3>\n<p>事务指的是要么都执行，要么都不执行。在分布式架构中，很多服务是部署在不同系统之间的，那么如何实现分布式事务呢？常见的分布式事务实现有：</p>\n<ul>\n<li><font color='cornflowerblue'>2PC（两阶段提交）</font>：优点是简单，缺点是同步阻塞、中心化问题、数据不一致、太过保守...</li>\n<li><font color='cornflowerblue'>TCC（Try Confirm/Cancel）</font>：也是 2PC 的一种。</li>\n<li><font color='cornflowerblue'>事务消息（half 半消息机制）</font>：RocketMQ 支持这种类型的消息。</li>\n</ul>\n<p>这三种实现都有特定的使用场景和各自的局限，并不完美。</p>\n<hr />\n<p>RocketMQ 中使用的是<strong>事务消息（half 半消息机制） + 事务反查机制</strong>来解决分布式事务问题的，可以对照着图进行理解。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/16ef38798d7a987f.png\" alt=\"img\" /></p>\n<p>在第 1 步发送的 half 消息，它的意思是<font color='red'>在事务提交之前，对于 Consumer 来说这个消息是不可见的</font>。</p>\n<blockquote>\n<p>那么，如何做到写入消息但是对 Consumer 不可见呢？RocketMQ 事务消息的做法是：</p>\n<ol>\n<li>如果消息是 half 消息，将备份原消息的 Topic 与消息消费队列</li>\n<li>然后<strong>改变 Topic 为 RMQ_SYS_TRANS_HALF_TOPIC</strong>，由于 Consumer 未订阅该 Topic，故无法消费 half 类型的消息。</li>\n<li>然后 <strong>RocketMQ 会开启一个定时任务，从该 Topic 中拉取消息进行消费</strong>，根据 Producer 组获取一个服务提供者，发送回查事务状态请求，根据事务状态来决定是提交或回滚消息。</li>\n</ol>\n</blockquote>\n<p>如果没有从第 5 步开始的<font color='red'>事务反查机制</font>，如果出现网路波动第 4 步没有发送成功，这样就会产生 MQ 不知道是不是需要给 Consumer 消费的问题。在  <code>RocketMQ</code>  中就是使用的上述的事务反查来解决的，而在  <code>Kafka</code>  中通常是直接抛出一个异常让用户来自行解决。</p>\n<p>你还需要注意的是， <code>MQ Server</code>  指向系统 B 的操作已经和系统 A 不相关了，也就是说在消息队列中的分布式事务是：<strong><font color='red'>本地事务和存储消息到消息队列才是同一个事务</font></strong>。这样也就产生了事务的<font color='red'>最终一致性</font>，因为整个过程是异步的，<strong><font color='red'>每个系统只要保证它自己那一部分的事务就行了</font></strong>。</p>\n<h3 id=\"如何解决消息堆积问题\"><a class=\"anchor\" href=\"#如何解决消息堆积问题\">#</a> 如何解决消息堆积问题？</h3>\n<p>在上面我们提到了消息队列的一个很重要的功能 ——<strong> 削峰</strong>。那么如果这个峰值太大了导致消息堆积在队列中怎么办呢？</p>\n<p>其实这个问题可以将它广义化，因为产生消息堆积的根源其实就只有两个：</p>\n<ul>\n<li>\n<p>Producer 生产太快：<strong>限流降级</strong>，或者<strong>增加 Consumer 实例</strong>以水平扩展消费能力（<font color='red'>同时还需要增加每个 Topic 的 Queue 数量</font>）。</p>\n<blockquote>\n<p>别忘了在  <code>RocketMQ</code>  中，<strong>一个 Queue 只会被一个 Consumer 消费</strong> ，如果你仅仅是增加 Consumer 实例就会出现我一开始给你画的架构图的那种情况：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/16ef387d939ab66d.jpg\" alt=\"img\" /></p>\n</blockquote>\n</li>\n<li>\n<p>Consumer 消费太慢：先检查 <strong>Consumer 是否出现了大量的消费错误</strong>，或者打印日志查看是否有哪一个线程卡死，导致了锁资源不释放等问题。</p>\n</li>\n</ul>\n<h3 id=\"回溯消费\"><a class=\"anchor\" href=\"#回溯消费\">#</a> 回溯消费</h3>\n<p>回溯消费是指  <code>Consumer</code>  已经消费成功的消息，由于业务上需求需要重新消费。在  <code>RocketMQ</code>  中， <code>Broker</code>  在向  <code>Consumer</code>  投递成功消息后，<font color='red'>消息仍然需要保留</font>。并且重新消费一般是按照时间维度，例如由于  <code>Consumer</code>  系统故障，恢复后需要重新消费 1 小时前的数据，那么  <code>Broker</code>  要提供一种机制，可以按照时间维度来回退消费进度。 <code>RocketMQ</code>  支持按照时间回溯消费，时间维度精确到毫秒。</p>\n<h3 id=\"如何保证高性能读写\"><a class=\"anchor\" href=\"#如何保证高性能读写\">#</a> 如何保证高性能读写？</h3>\n<blockquote>\n<p>可参考 “Java IO - IO 模型 - NIO” 小节，略了。</p>\n</blockquote>\n<ul>\n<li>传统 IO 方式：即  <code>read + write</code> ，整个过程会发生 4 次上下文切换和 4 次数据的拷贝，这在高并发场景下会严重影响读写性能，故引入了零拷贝技术。\n<ul>\n<li>用户调用 read () 方法，开始读取数据，此时发生一次上下文从用户态到内核态的切换，也就是图示的切换 1</li>\n<li>将磁盘数据通过 DMA 拷贝到内核缓存区</li>\n<li>将内核缓存区的数据拷贝到用户缓冲区，这样用户，也就是我们写的代码就能拿到文件的数据</li>\n<li>read () 方法返回，此时就会从内核态切换到用户态，也就是图示的切换 2</li>\n<li>当我们拿到数据之后，就可以调用 write () 方法，此时上下文会从用户态切换到内核态，即图示切换 3</li>\n<li>CPU 将用户缓冲区的数据拷贝到 Socket 缓冲区</li>\n<li>将 Socket 缓冲区数据拷贝至网卡</li>\n<li>write () 方法返回，上下文重新从内核态切换到用户态，即图示切换 4</li>\n</ul>\n</li>\n<li>零拷贝技术\n<ul>\n<li><code>mmap</code> ：</li>\n<li><code>sendfile</code> ：</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"刷盘机制\"><a class=\"anchor\" href=\"#刷盘机制\">#</a> 刷盘机制</h3>\n<h4 id=\"同步刷盘-异步刷盘\"><a class=\"anchor\" href=\"#同步刷盘-异步刷盘\">#</a> 同步刷盘、异步刷盘</h4>\n<blockquote>\n<p>在单个节点层面</p>\n</blockquote>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/16ef387fba311cda-20230814005009889.jpg\" alt=\"img\" /></p>\n<p><font color='cornflowerblue'>同步刷盘</font>：<strong><font color='red'>需要等待一个刷盘成功的  <code>ACK</code> </font></strong> ，对<font color='red'>消息可靠性</font>来说是一种不错的保障，但是<font color='red'>性能上会有较大影响</font>，一般适用于金融等特定业务场景。</p>\n<p><font color='cornflowerblue'>异步刷盘</font>：<strong><font color='red'>开启一个线程去异步地执行刷盘操作</font></strong>。消息刷盘采用后台异步线程提交的方式进行，<font color='red'>降低了读写延迟</font>，<font color='red'>提高了  <code>MQ</code>  的性能和吞吐量</font>，一般适用于如发验证码等<font color='red'>对于消息保证要求不太高</font>的业务场景。</p>\n<p>一般地，<strong>异步刷盘只有在  <code>Broker</code>  意外宕机的时候会丢失部分数据</strong>，你可以设置  <code>Broker</code>  的参数  <code>FlushDiskType</code>  来调整你的刷盘策略 (ASYNC_FLUSH 或者 SYNC_FLUSH)。</p>\n<h4 id=\"同步复制-异步复制\"><a class=\"anchor\" href=\"#同步复制-异步复制\">#</a> 同步复制、异步复制</h4>\n<blockquote>\n<p>在 Broker 主从模式下，master 返回消息给客户端时是否需要同步 slave</p>\n</blockquote>\n<p><font color='cornflowerblue'>同步复制</font>：也叫 “同步双写”，即<strong>只有消息同步双写到主从节点上时，才返回写入成功</strong>。</p>\n<p><font color='cornflowerblue'>异步复制</font>：<strong>消息写入主节点之后，直接返回写入成功</strong>。</p>\n<p>然而，很多事情是没有完美的方案的，就比如我们进行消息写入的节点越多就更能保证消息的可靠性，但是随之的性能也会下降，所以需要程序员根据特定业务场景去选择适应的主从复制方案。</p>\n<p><font color='red'>异步复制不会像异步刷盘那样影响消息的可靠性</font>，因为两者是不同的概念，对于消息可靠性是通过不同的刷盘策略保证的，而像异步同步复制策略<font color='red'>仅仅是影响到了可用性</font>。为什么呢？其主要原因是 <strong> <code>RocketMQ</code>  是不支持自动主从切换的，当 master 节点挂掉之后，Producer 就不能再给这个 master 节点生产消息了</strong>。</p>\n<p>比如这个时候采用异步复制的方式，在主节点还未发送完需要同步的消息的时候主节点挂掉了，这个时候从节点就少了一部分消息。但是此时生产者无法再给主节点生产消息了，<strong>消费者可以自动切换到从节点进行消费</strong> (仅仅是消费)，所以在主节点挂掉的时间只会产生主从结点短暂的消息不一致的情况，降低了可用性，而当主节点重启之后，从节点那部分未来得及复制的消息还会继续复制。</p>\n<p>在单主从架构中，如果一个主节点挂掉了，那么也就意味着整个系统不能再生产了。那么这个可用性的问题能否解决呢？<strong>一个主从不行那就多个主从的呗</strong>，别忘了在我们最初的架构图中，每个  <code>Topic</code>  是分布在不同  <code>Broker</code>  中的。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/16ef38687488a5asadasfg4.jpg\" alt=\"img\" /></p>\n<p>但是这种复制方式同样也会带来一个问题，那就是无法保证 <strong>严格顺序</strong> 。在上文中我们提到了如何保证的消息顺序性是通过将一个语义的消息发送在同一个队列中，使用  <code>Topic</code>  下的队列来保证顺序性的。如果此时我们主节点 A 负责的是订单 A 的一系列语义消息，然后它挂了，这样其他节点是无法代替主节点 A 的，如果我们任意节点都可以存入任何消息，那就没有顺序性可言了。</p>\n<p>而在  <code>RocketMQ</code>  中采用了  <code>Dledger</code>  解决这个问题。他要求在写入消息的时候，要求<strong>至少消息复制到半数以上的节点之后</strong>，才给客⼾端返回写⼊成功，并且它是⽀持通过选举来动态切换主节点的。这里我就不展开说明了，读者可以自己去了解。</p>\n<blockquote>\n<p>也不是说  <code>Dledger</code>  是个完美的方案，至少在  <code>Dledger</code>  选举过程中是无法提供服务的，而且他必须要使用三个节点或以上，如果多数节点同时挂掉他也是无法保证可用性的，而且要求消息复制半数以上节点的效率和直接异步复制还是有一定的差距的。</p>\n</blockquote>\n<h4 id=\"存储机制\"><a class=\"anchor\" href=\"#存储机制\">#</a> 存储机制</h4>\n<h3 id=\"动手发一条消息\"><a class=\"anchor\" href=\"#动手发一条消息\">#</a> 动手发一条消息</h3>\n<h4 id=\"1-启动-rocketmq\"><a class=\"anchor\" href=\"#1-启动-rocketmq\">#</a> 1、启动 RocketMQ</h4>\n<p><font color='gree'>安装 NameServer</font></p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">docker</span> run <span class=\"token parameter variable\">-d</span> <span class=\"token parameter variable\">-p</span> <span class=\"token number\">9876</span>:9876 <span class=\"token parameter variable\">--name</span> rmqnamesrv foxiswho/rocketmq:server-4.5.1</pre></td></tr></table></figure><p><font color='gree'>安装 Broker</font></p>\n<p>1）新建配置目录。</p>\n<p>如果是 Windows 需要替换为 Windows 的电脑路径，和 Linux 还是有点差异。</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">mkdir</span> <span class=\"token parameter variable\">-p</span> <span class=\"token variable\">$&#123;<span class=\"token environment constant\">HOME</span>&#125;</span>/docker/software/rocketmq/conf</pre></td></tr></table></figure><p>2）新建配置文件 broker.conf。</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>brokerClusterName <span class=\"token operator\">=</span> DefaultCluster</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>brokerName <span class=\"token operator\">=</span> broker-a</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>brokerId <span class=\"token operator\">=</span> <span class=\"token number\">0</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>deleteWhen <span class=\"token operator\">=</span> 04</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>fileReservedTime <span class=\"token operator\">=</span> <span class=\"token number\">48</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>brokerRole <span class=\"token operator\">=</span> ASYNC_MASTER</pre></td></tr><tr><td data-num=\"7\"></td><td><pre>flushDiskType <span class=\"token operator\">=</span> ASYNC_FLUSH</pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token comment\"># 此处为本地 ip, 如果部署服务器，需要填写服务器外网 ip</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>brokerIP1 <span class=\"token operator\">=</span> xx.xx.xx.xx</pre></td></tr></table></figure><p>3）创建容器。</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">docker</span> run <span class=\"token parameter variable\">-d</span> <span class=\"token punctuation\">\\</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token parameter variable\">-p</span> <span class=\"token number\">10911</span>:10911 <span class=\"token punctuation\">\\</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token parameter variable\">-p</span> <span class=\"token number\">10909</span>:10909 <span class=\"token punctuation\">\\</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token parameter variable\">--name</span> rmqbroker <span class=\"token punctuation\">\\</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token parameter variable\">--link</span> rmqnamesrv:namesrv <span class=\"token punctuation\">\\</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token parameter variable\">-v</span> <span class=\"token variable\">$&#123;<span class=\"token environment constant\">HOME</span>&#125;</span>/docker/software/rocketmq/conf/broker.conf:/etc/rocketmq/broker.conf <span class=\"token punctuation\">\\</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token parameter variable\">-e</span> <span class=\"token string\">\"NAMESRV_ADDR=namesrv:9876\"</span> <span class=\"token punctuation\">\\</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token parameter variable\">-e</span> <span class=\"token string\">\"JAVA_OPTS=-Duser.home=/opt\"</span> <span class=\"token punctuation\">\\</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token parameter variable\">-e</span> <span class=\"token string\">\"JAVA_OPT_EXT=-server -Xms512m -Xmx512m\"</span> <span class=\"token punctuation\">\\</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>foxiswho/rocketmq:broker-4.5.1</pre></td></tr></table></figure><p><font color='gree'>安装 RocketMQ 控制台</font></p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">docker</span> pull pangliang/rocketmq-console-ng</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">docker</span> run <span class=\"token parameter variable\">-d</span> <span class=\"token punctuation\">\\</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token parameter variable\">--link</span> rmqnamesrv:namesrv <span class=\"token punctuation\">\\</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token parameter variable\">-e</span> <span class=\"token string\">\"JAVA_OPTS=-Drocketmq.config.namesrvAddr=namesrv:9876 -Drocketmq.config.isVIPChannel=false\"</span> <span class=\"token punctuation\">\\</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token parameter variable\">--name</span> rmqconsole <span class=\"token punctuation\">\\</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token parameter variable\">-p</span> <span class=\"token number\">8088</span>:8080 <span class=\"token punctuation\">\\</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token parameter variable\">-t</span> pangliang/rocketmq-console-ng</pre></td></tr></table></figure><p>运行成功，稍等几秒启动时间，浏览器输入  <code>localhost:8088</code>  查看控制台。</p>\n<h4 id=\"2-发送普通消息\"><a class=\"anchor\" href=\"#2-发送普通消息\">#</a> 2、发送普通消息</h4>\n<p>下述完整 Demo 详情查看<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRlZS5jb20vbmFnZW9mZmVyL3NwcmluZ2Jvb3QtbGFkZGVyL3RyZWUvbWFpbi9tcS1yb2NrZXRtcS00eA==\"> springboot-ladder/mq-rocketmq-4x</span> 项目模块。</p>\n<h5 id=\"21-引入-rocketmq-依赖\"><a class=\"anchor\" href=\"#21-引入-rocketmq-依赖\">#</a> 2.1、引入 RocketMQ 依赖</h5>\n<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.apache.rocketmq&lt;/groupId&gt;\n    &lt;artifactId&gt;rocketmq-spring-boot-starter&lt;/artifactId&gt;\n    &lt;version&gt;2.2.3&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>\n<h5 id=\"22-启动自动装配\"><a class=\"anchor\" href=\"#22-启动自动装配\">#</a> 2.2、启动自动装配</h5>\n<p>因为咱们 Demo 中使用的是 SpringBoot3，RocketMQ 最新版本 2.2.3 没有适配 SpringBoot3，所以需要手动搞定自动装配。</p>\n<blockquote>\n<p>如果 SpringBoot2 版本，就不需要执行这一步。</p>\n</blockquote>\n<p>resources 目录下创建 META-INF/spring 目录，并创建 <code>org.springframework.boot.autoconfigure.AutoConfiguration.imports</code>  文件。</p>\n<figure class=\"highlight properties\"><figcaption data-lang=\".properties\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># RocketMQ 2.2.3 version does not adapt to SpringBoot3</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>org.apache.rocketmq.spring.autoconfigure.RocketMQAutoConfiguration</pre></td></tr></table></figure><p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230924172750462.png\" alt=\"img\" /></p>\n<h5 id=\"23-producer\"><a class=\"anchor\" href=\"#23-producer\">#</a> 2.3、Producer</h5>\n<p>配置文件中引入 RocketMQ 相关配置定义，比如连接 NameServer 地址等。</p>\n<figure class=\"highlight yaml\"><figcaption data-lang=\"YAML\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token key atrule\">server</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>  <span class=\"token key atrule\">port</span><span class=\"token punctuation\">:</span> <span class=\"token number\">6060</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token key atrule\">rocketmq</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>  <span class=\"token key atrule\">name-server</span><span class=\"token punctuation\">:</span> 127.0.0.1<span class=\"token punctuation\">:</span><span class=\"token number\">9876</span> <span class=\"token comment\"># NameServer 地址</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>  <span class=\"token key atrule\">producer</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token key atrule\">group</span><span class=\"token punctuation\">:</span> rocketmq<span class=\"token punctuation\">-</span>4x<span class=\"token punctuation\">-</span>service_common<span class=\"token punctuation\">-</span>message<span class=\"token punctuation\">-</span>execute_pg <span class=\"token comment\"># 全局发送者组定义</span></pre></td></tr></table></figure><p>定义消息生产者，通过  <code>RocketMQTemplate</code>  向 RocketMQ 发送普通常规消息。</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">cn<span class=\"token punctuation\">.</span>hutool<span class=\"token punctuation\">.</span>core<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">StrUtil</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">com<span class=\"token punctuation\">.</span>alibaba<span class=\"token punctuation\">.</span>fastjson<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">JSON</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">com<span class=\"token punctuation\">.</span>nageoffer<span class=\"token punctuation\">.</span>springbootladder<span class=\"token punctuation\">.</span>rocketmq4x<span class=\"token punctuation\">.</span>event<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">GeneralMessageEvent</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">lombok<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">RequiredArgsConstructor</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">lombok<span class=\"token punctuation\">.</span>extern<span class=\"token punctuation\">.</span>slf4j<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">Slf4j</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">org<span class=\"token punctuation\">.</span>apache<span class=\"token punctuation\">.</span>rocketmq<span class=\"token punctuation\">.</span>client<span class=\"token punctuation\">.</span>producer<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">SendResult</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">org<span class=\"token punctuation\">.</span>apache<span class=\"token punctuation\">.</span>rocketmq<span class=\"token punctuation\">.</span>common<span class=\"token punctuation\">.</span>message<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">MessageConst</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">org<span class=\"token punctuation\">.</span>apache<span class=\"token punctuation\">.</span>rocketmq<span class=\"token punctuation\">.</span>spring<span class=\"token punctuation\">.</span>core<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">RocketMQTemplate</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">org<span class=\"token punctuation\">.</span>springframework<span class=\"token punctuation\">.</span>messaging<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">Message</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">org<span class=\"token punctuation\">.</span>springframework<span class=\"token punctuation\">.</span>messaging<span class=\"token punctuation\">.</span>support<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">MessageBuilder</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">org<span class=\"token punctuation\">.</span>springframework<span class=\"token punctuation\">.</span>stereotype<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">Component</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token comment\">/**</pre></td></tr><tr><td data-num=\"14\"></td><td><pre> * 普通消息发送者</pre></td></tr><tr><td data-num=\"15\"></td><td><pre> *</pre></td></tr><tr><td data-num=\"16\"></td><td><pre> * @公众号：马丁玩编程，回复：加群，添加马哥微信（备注：ladder）获取更多项目资料</pre></td></tr><tr><td data-num=\"17\"></td><td><pre> */</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre><span class=\"token annotation punctuation\">@Slf4j</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre><span class=\"token annotation punctuation\">@Component</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre><span class=\"token annotation punctuation\">@RequiredArgsConstructor</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">GeneralMessageDemoProduce</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>    <span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">RocketMQTemplate</span> rocketMQTemplate<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>    <span class=\"token comment\">/**</pre></td></tr><tr><td data-num=\"26\"></td><td><pre>     * 发送普通消息</pre></td></tr><tr><td data-num=\"27\"></td><td><pre>     *</pre></td></tr><tr><td data-num=\"28\"></td><td><pre>     * @param topic            消息发送主题，用于标识同一类业务逻辑的消息</pre></td></tr><tr><td data-num=\"29\"></td><td><pre>     * @param tag              消息的过滤标签，消费者可通过 Tag 对消息进行过滤，仅接收指定标签的消息。</pre></td></tr><tr><td data-num=\"30\"></td><td><pre>     * @param keys             消息索引键，可根据关键字精确查找某条消息</pre></td></tr><tr><td data-num=\"31\"></td><td><pre>     * @param messageSendEvent 普通消息发送事件，自定义对象，最终都会序列化为字符串</pre></td></tr><tr><td data-num=\"32\"></td><td><pre>     * @return 消息发送 RocketMQ 返回结果</pre></td></tr><tr><td data-num=\"33\"></td><td><pre>     */</span></pre></td></tr><tr><td data-num=\"34\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token class-name\">SendResult</span> <span class=\"token function\">sendMessage</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> topic<span class=\"token punctuation\">,</span> <span class=\"token class-name\">String</span> tag<span class=\"token punctuation\">,</span> <span class=\"token class-name\">String</span> keys<span class=\"token punctuation\">,</span> <span class=\"token class-name\">GeneralMessageEvent</span> messageSendEvent<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"35\"></td><td><pre>        <span class=\"token class-name\">SendResult</span> sendResult<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"36\"></td><td><pre>        <span class=\"token keyword\">try</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"37\"></td><td><pre>            <span class=\"token class-name\">StringBuilder</span> destinationBuilder <span class=\"token operator\">=</span> <span class=\"token class-name\">StrUtil</span><span class=\"token punctuation\">.</span><span class=\"token function\">builder</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">append</span><span class=\"token punctuation\">(</span>topic<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"38\"></td><td><pre>            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">StrUtil</span><span class=\"token punctuation\">.</span><span class=\"token function\">isNotBlank</span><span class=\"token punctuation\">(</span>tag<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"39\"></td><td><pre>                destinationBuilder<span class=\"token punctuation\">.</span><span class=\"token function\">append</span><span class=\"token punctuation\">(</span><span class=\"token string\">\":\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">append</span><span class=\"token punctuation\">(</span>tag<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"40\"></td><td><pre>            <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"41\"></td><td><pre>            <span class=\"token class-name\">Message</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span><span class=\"token punctuation\">></span></span> message <span class=\"token operator\">=</span> <span class=\"token class-name\">MessageBuilder</span></pre></td></tr><tr><td data-num=\"42\"></td><td><pre>                    <span class=\"token punctuation\">.</span><span class=\"token function\">withPayload</span><span class=\"token punctuation\">(</span>messageSendEvent<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"43\"></td><td><pre>                    <span class=\"token punctuation\">.</span><span class=\"token function\">setHeader</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">MessageConst</span><span class=\"token punctuation\">.</span><span class=\"token constant\">PROPERTY_KEYS</span><span class=\"token punctuation\">,</span> keys<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"44\"></td><td><pre>                    <span class=\"token punctuation\">.</span><span class=\"token function\">setHeader</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">MessageConst</span><span class=\"token punctuation\">.</span><span class=\"token constant\">PROPERTY_TAGS</span><span class=\"token punctuation\">,</span> tag<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"45\"></td><td><pre>                    <span class=\"token punctuation\">.</span><span class=\"token function\">build</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"46\"></td><td><pre>            sendResult <span class=\"token operator\">=</span> rocketMQTemplate<span class=\"token punctuation\">.</span><span class=\"token function\">syncSend</span><span class=\"token punctuation\">(</span></pre></td></tr><tr><td data-num=\"47\"></td><td><pre>                    destinationBuilder<span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"48\"></td><td><pre>                    message<span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"49\"></td><td><pre>                    <span class=\"token number\">2000L</span></pre></td></tr><tr><td data-num=\"50\"></td><td><pre>            <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"51\"></td><td><pre>            log<span class=\"token punctuation\">.</span><span class=\"token function\">info</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"[普通消息] 消息发送结果：&#123;&#125;，消息ID：&#123;&#125;，消息Keys：&#123;&#125;\"</span><span class=\"token punctuation\">,</span> sendResult<span class=\"token punctuation\">.</span><span class=\"token function\">getSendStatus</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> sendResult<span class=\"token punctuation\">.</span><span class=\"token function\">getMsgId</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> keys<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"52\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Throwable</span> ex<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"53\"></td><td><pre>            log<span class=\"token punctuation\">.</span><span class=\"token function\">error</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"[普通消息] 消息发送失败，消息体：&#123;&#125;\"</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">JSON</span><span class=\"token punctuation\">.</span><span class=\"token function\">toJSONString</span><span class=\"token punctuation\">(</span>messageSendEvent<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> ex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"54\"></td><td><pre>            <span class=\"token keyword\">throw</span> ex<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"55\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"56\"></td><td><pre>        <span class=\"token keyword\">return</span> sendResult<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"57\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"58\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h5 id=\"24-consumer\"><a class=\"anchor\" href=\"#24-consumer\">#</a> 2.4、Consumer</h5>\n<p>定义消息消费者，从 RocketMQ Broker 拉取对应 Topic Tag 的消息列表。</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">com<span class=\"token punctuation\">.</span>alibaba<span class=\"token punctuation\">.</span>fastjson<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">JSON</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">com<span class=\"token punctuation\">.</span>nageoffer<span class=\"token punctuation\">.</span>springbootladder<span class=\"token punctuation\">.</span>rocketmq4x<span class=\"token punctuation\">.</span>event<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">GeneralMessageEvent</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">lombok<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">RequiredArgsConstructor</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">lombok<span class=\"token punctuation\">.</span>extern<span class=\"token punctuation\">.</span>slf4j<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">Slf4j</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">org<span class=\"token punctuation\">.</span>apache<span class=\"token punctuation\">.</span>rocketmq<span class=\"token punctuation\">.</span>spring<span class=\"token punctuation\">.</span>annotation<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">RocketMQMessageListener</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">org<span class=\"token punctuation\">.</span>apache<span class=\"token punctuation\">.</span>rocketmq<span class=\"token punctuation\">.</span>spring<span class=\"token punctuation\">.</span>core<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">RocketMQListener</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">org<span class=\"token punctuation\">.</span>springframework<span class=\"token punctuation\">.</span>stereotype<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">Component</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token comment\">/**</pre></td></tr><tr><td data-num=\"10\"></td><td><pre> * 普通消息消费者</pre></td></tr><tr><td data-num=\"11\"></td><td><pre> *</pre></td></tr><tr><td data-num=\"12\"></td><td><pre> * @公众号：马丁玩编程，回复：加群，添加马哥微信（备注：ladder）获取更多项目资料</pre></td></tr><tr><td data-num=\"13\"></td><td><pre> */</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre><span class=\"token annotation punctuation\">@Slf4j</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre><span class=\"token annotation punctuation\">@Component</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre><span class=\"token annotation punctuation\">@RequiredArgsConstructor</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre><span class=\"token annotation punctuation\">@RocketMQMessageListener</span><span class=\"token punctuation\">(</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>        topic <span class=\"token operator\">=</span> <span class=\"token string\">\"rocketmq-demo_common-message_topic\"</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>        selectorExpression <span class=\"token operator\">=</span> <span class=\"token string\">\"general\"</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>        consumerGroup <span class=\"token operator\">=</span> <span class=\"token string\">\"rocketmq-demo_general-message_cg\"</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">GeneralMessageDemoConsume</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">RocketMQListener</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">GeneralMessageEvent</span><span class=\"token punctuation\">></span></span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>    <span class=\"token annotation punctuation\">@Override</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">onMessage</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">GeneralMessageEvent</span> message<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>        log<span class=\"token punctuation\">.</span><span class=\"token function\">info</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"接到到RocketMQ消息，消息体：&#123;&#125;\"</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">JSON</span><span class=\"token punctuation\">.</span><span class=\"token function\">toJSONString</span><span class=\"token punctuation\">(</span>message<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h5 id=\"25-发送一条消息\"><a class=\"anchor\" href=\"#25-发送一条消息\">#</a> 2.5、发送一条消息</h5>\n<p>定义消息发送程序，这里为了避免类过多，直接写在 SpringBoot 的启动程序里。发送普通消息的方法返回值就是发送 RocketMQ Broker 返回的状态码，成功的话就是  <code>SEND_OK</code> 。</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">com<span class=\"token punctuation\">.</span>nageoffer<span class=\"token punctuation\">.</span>springbootladder<span class=\"token punctuation\">.</span>rocketmq4x<span class=\"token punctuation\">.</span>event<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">GeneralMessageEvent</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">com<span class=\"token punctuation\">.</span>nageoffer<span class=\"token punctuation\">.</span>springbootladder<span class=\"token punctuation\">.</span>rocketmq4x<span class=\"token punctuation\">.</span>produce<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">GeneralMessageDemoProduce</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">io<span class=\"token punctuation\">.</span>swagger<span class=\"token punctuation\">.</span>v3<span class=\"token punctuation\">.</span>oas<span class=\"token punctuation\">.</span>annotations<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">Operation</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">io<span class=\"token punctuation\">.</span>swagger<span class=\"token punctuation\">.</span>v3<span class=\"token punctuation\">.</span>oas<span class=\"token punctuation\">.</span>annotations<span class=\"token punctuation\">.</span>tags<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">Tag</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">lombok<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">RequiredArgsConstructor</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">org<span class=\"token punctuation\">.</span>apache<span class=\"token punctuation\">.</span>rocketmq<span class=\"token punctuation\">.</span>client<span class=\"token punctuation\">.</span>producer<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">SendResult</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">org<span class=\"token punctuation\">.</span>springframework<span class=\"token punctuation\">.</span>boot<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">SpringApplication</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">org<span class=\"token punctuation\">.</span>springframework<span class=\"token punctuation\">.</span>boot<span class=\"token punctuation\">.</span>autoconfigure<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">SpringBootApplication</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">org<span class=\"token punctuation\">.</span>springframework<span class=\"token punctuation\">.</span>web<span class=\"token punctuation\">.</span>bind<span class=\"token punctuation\">.</span>annotation<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">PostMapping</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">org<span class=\"token punctuation\">.</span>springframework<span class=\"token punctuation\">.</span>web<span class=\"token punctuation\">.</span>bind<span class=\"token punctuation\">.</span>annotation<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">RestController</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">java<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">UUID</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre></pre></td></tr><tr><td data-num=\"14\"></td><td><pre><span class=\"token annotation punctuation\">@RestController</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre><span class=\"token annotation punctuation\">@RequiredArgsConstructor</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre><span class=\"token annotation punctuation\">@SpringBootApplication</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre><span class=\"token annotation punctuation\">@Tag</span><span class=\"token punctuation\">(</span>name <span class=\"token operator\">=</span> <span class=\"token string\">\"RocketMQ发送示例\"</span><span class=\"token punctuation\">,</span> description <span class=\"token operator\">=</span> <span class=\"token string\">\"RocketMQ发送示例启动器\"</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">RocketMQDemoApplication</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>    <span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">GeneralMessageDemoProduce</span> generalMessageDemoProduce<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>    <span class=\"token annotation punctuation\">@PostMapping</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"/test/send/general-message\"</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>    <span class=\"token annotation punctuation\">@Operation</span><span class=\"token punctuation\">(</span>summary <span class=\"token operator\">=</span> <span class=\"token string\">\"发送RocketMQ普通消息\"</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token class-name\">String</span> <span class=\"token function\">sendGeneralMessage</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>        <span class=\"token class-name\">String</span> keys <span class=\"token operator\">=</span> <span class=\"token constant\">UUID</span><span class=\"token punctuation\">.</span><span class=\"token function\">randomUUID</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>        <span class=\"token class-name\">GeneralMessageEvent</span> generalMessageEvent <span class=\"token operator\">=</span> <span class=\"token class-name\">GeneralMessageEvent</span><span class=\"token punctuation\">.</span><span class=\"token function\">builder</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>                <span class=\"token punctuation\">.</span><span class=\"token function\">body</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"消息具体内容，可以是自定义对象，最终都会序列化为字符串。如果是取消订单，这里应该是订单ID或者相关联的信息\"</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>                <span class=\"token punctuation\">.</span><span class=\"token function\">keys</span><span class=\"token punctuation\">(</span>keys<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>                <span class=\"token punctuation\">.</span><span class=\"token function\">build</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>        <span class=\"token class-name\">SendResult</span> sendResult <span class=\"token operator\">=</span> generalMessageDemoProduce<span class=\"token punctuation\">.</span><span class=\"token function\">sendMessage</span><span class=\"token punctuation\">(</span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre>                <span class=\"token string\">\"rocketmq-demo_common-message_topic\"</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"32\"></td><td><pre>                <span class=\"token string\">\"general\"</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"33\"></td><td><pre>                keys<span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"34\"></td><td><pre>                generalMessageEvent</pre></td></tr><tr><td data-num=\"35\"></td><td><pre>        <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"36\"></td><td><pre>        <span class=\"token keyword\">return</span> sendResult<span class=\"token punctuation\">.</span><span class=\"token function\">getSendStatus</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">name</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"37\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"38\"></td><td><pre></pre></td></tr><tr><td data-num=\"39\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"40\"></td><td><pre>        <span class=\"token class-name\">SpringApplication</span><span class=\"token punctuation\">.</span><span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">RocketMQDemoApplication</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">,</span> args<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"41\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"42\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>项目中引入了 Swagger3，通过界面 UI 发送一条消息测试效果。访问  <code>http://127.0.0.1:6060/swagger-ui/index.html</code> ，调用定义的发送 RocketMQ 普通消息方法。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230924173811738.png\" alt=\"img\" /></p>\n<p>点击 Execute 执行方法调用。</p>\n<p><img data-src=\"https://images-machen.oss-cn-beijing.aliyuncs.com/image-20230924173837160.png\" alt=\"img\" /></p>\n<p>通过方法调用得知，返回数据为成功。</p>\n<p><img data-src=\"https://images-machen.oss-cn-beijing.aliyuncs.com/image-20230924173948187.png\" alt=\"img\" /></p>\n<p>也能看到 RocketMQ 对应的生产者和消费者对应日志。</p>\n<figure class=\"highlight text\"><figcaption data-lang=\"text\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>2023-09-24T17:38:57.457+08:00  INFO 48437 --- [nio-6060-exec-6] c.n.s.r.p.GeneralMessageDemoProduce      : [普通消息] 消息发送结果：SEND_OK，消息ID：7F000001BD35251A69D77A3BC5280002，消息Keys：7a60c853-08dc-46cd-a647-398d45b54966</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>2023-09-24T17:38:57.459+08:00  INFO 48437 --- [al-message_cg_3] c.n.s.r.c.GeneralMessageDemoConsume      : 接到RocketMQ消息，消息体：&#123;\"body\":\"消息具体内容，可以是自定义对象，最终都会序列化为字符串。如果是取消订单，这里应该是订单ID或者相关联的信息\",\"keys\":\"7a60c853-08dc-46cd-a647-398d45b54966\"&#125;</pre></td></tr></table></figure><h4 id=\"3-扩展框架-springcloud-stream\"><a class=\"anchor\" href=\"#3-扩展框架-springcloud-stream\">#</a> 3、扩展框架 SpringCloud Stream</h4>\n<p>Spring Cloud Stream 是一个<strong>用于构建基于消息的微服务应用</strong>框架。它基于 SpringBoot 来创建具有生产级别的单机 Spring 应用，并且使用  <code>Spring Integration</code>  与 Broker 进行连接。</p>\n<p>Spring Cloud Stream 提供了消息中间件配置的统一抽象，推出了 publish-subscribe、consumer groups、partition 这些统一的概念。</p>\n<p>Spring Cloud Stream 内部有两个概念：Binder 和 Binding。</p>\n<ul>\n<li><code>Binder</code> ：跟外部消息中间件集成的组件，用来创建 Binding，各消息中间件都有自己的 Binder 实现。</li>\n</ul>\n<p>比如  <code>Kafka</code>  的实现  <code>KafkaMessageChannelBinder</code> ， <code>RabbitMQ</code>  的实现  <code>RabbitMessageChannelBinder</code>  以及  <code>RocketMQ</code>  的实现  <code>RocketMQMessageChannelBinder</code> 。</p>\n<ul>\n<li><code>Binding</code> ：包括 Input Binding 和 Output Binding。</li>\n</ul>\n<p>Binding 在消息中间件与应用程序提供的 Provider 和 Consumer 之间提供了一个桥梁，实现了开发者只需使用应用程序的 Provider 或 Consumer 生产或消费数据即可，屏蔽了开发者与底层消息中间件的接触。</p>\n<p>下图是 Spring Cloud Stream 的架构设计。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/68747470733a2f2f646f63732e737072696e672e696f2f737072696e672d636c6f75642d73747265616d2f646f63732f63757272656e742f7265666572656e63652f68746d6c2f696d616765732f534353742d776974682d62696e6465722e706e67.png\" alt=\"img\" /></p>\n<p>SpringCloud Stream RocketMQ 不是咱们本次介绍的重点，所以只是抛砖引玉，大家需要了解详情参考：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2FsaWJhYmEvc3ByaW5nLWNsb3VkLWFsaWJhYmEvYmxvYi8yLjIueC9zcHJpbmctY2xvdWQtYWxpYmFiYS1leGFtcGxlcy9yb2NrZXRtcS1leGFtcGxlL3JlYWRtZS16aC5tZA==\">RocketMQ Example</span></p>\n<h3 id=\"部署架构\"><a class=\"anchor\" href=\"#部署架构\">#</a> 部署架构</h3>\n<h4 id=\"本地部署\"><a class=\"anchor\" href=\"#本地部署\">#</a> 本地部署</h4>\n<h5 id=\"单组节点单副本模式\"><a class=\"anchor\" href=\"#单组节点单副本模式\">#</a> 单组节点单副本模式</h5>\n<p>这种方式风险较大，因为 Broker 只有一个节点，一旦 Broker 重启或者宕机时，会导致整个服务不可用。不建议线上环境使用，可以用于本地测试。</p>\n<h5 id=\"多组节点集群单副本模式\"><a class=\"anchor\" href=\"#多组节点集群单副本模式\">#</a> 多组节点（集群）单副本模式</h5>\n<p>一个集群内全部部署 Master 角色，不部署 Slave 副本，例如 2 个 Master 或者 3 个 Master，这种模式的优缺点如下：</p>\n<ul>\n<li>优点：配置简单，单个 Master 宕机或重启维护对应用无影响，在磁盘配置为 RAID10 时，即使机器宕机不可恢复情况下，由于 RAID10 磁盘非常可靠，消息也不会丢（异步刷盘丢失少量消息，同步刷盘一条不丢），性能最高；</li>\n<li>缺点：单台机器宕机期间，这台机器上未被消费的消息在机器恢复之前不可订阅，消息实时性会受到影响。</li>\n</ul>\n<h4 id=\"生产部署\"><a class=\"anchor\" href=\"#生产部署\">#</a> 生产部署</h4>\n<h5 id=\"多节点集群多副本模式异步复制\"><a class=\"anchor\" href=\"#多节点集群多副本模式异步复制\">#</a> 多节点（集群）多副本模式：异步复制</h5>\n<p><font color='red'>每个 Master 配置一个 Slave</font>，有多组 Master-Slave，HA 采用<strong>异步复制</strong>方式，主备有短暂消息延迟（毫秒级），这种模式的优缺点如下：</p>\n<ul>\n<li>优点：即使磁盘损坏，消息丢失的非常少，且消息实时性不会受影响，同时 Master 宕机后，消费者仍然可以从 Slave 消费，而且此过程对应用透明，不需要人工干预，性能同多 Master 模式几乎一样；</li>\n<li>缺点：Master 宕机，磁盘损坏情况下会丢失少量消息。</li>\n</ul>\n<h5 id=\"多节点集群多副本模式同步双写\"><a class=\"anchor\" href=\"#多节点集群多副本模式同步双写\">#</a> 多节点（集群）多副本模式：同步双写</h5>\n<p><font color='red'>每个 Master 配置一个 Slave</font>，有多对 Master-Slave，HA 采用<strong>同步双写</strong>方式，即只有主备都写成功，才向应用返回成功，这种模式的优缺点如下：</p>\n<ul>\n<li>优点：数据与服务都无单点故障，Master 宕机情况下，消息无延迟，服务可用性与数据可用性都非常高；</li>\n<li>缺点：性能比异步复制模式略低（大约低 10% 左右），发送单个消息的 RT 会略高，且目前版本在主节点宕机后，备机不能自动切换为主机。</li>\n</ul>\n",
            "tags": [
                "消息队列"
            ]
        },
        {
            "id": "http://example.com/docker/docker-javaguide/",
            "url": "http://example.com/docker/docker-javaguide/",
            "title": "docker-javaguide",
            "date_published": "2024-01-19T03:24:09.063Z",
            "content_html": "<h1 id=\"docker-核心概念\"><a class=\"anchor\" href=\"#docker-核心概念\">#</a> Docker 核心概念</h1>\n<h2 id=\"容器\"><a class=\"anchor\" href=\"#容器\">#</a> 容器</h2>\n<p><strong>Docker 是世界领先的软件容器平台</strong>，所以想要搞懂 Docker 的概念我们必须先从容器开始说起。</p>\n<h3 id=\"容器是什么\"><a class=\"anchor\" href=\"#容器是什么\">#</a> 容器是什么</h3>\n<p>一句话概括容器：<strong><font color='red'>容器就是将软件打包成标准化单元，以用于开发、交付和部署。</font></strong></p>\n<ul>\n<li><strong>容器镜像是轻量的、可执行的独立软件包</strong>，包含软件运行所需的所有内容：代码、运行时环境、系统工具、系统库和设置。</li>\n<li><strong>容器化软件适用于基于 Linux 和 Windows 的应用，在任何环境中都能够始终如一地运行。</strong></li>\n<li><strong>容器赋予了软件独立性</strong>，使其免受外在环境差异（例如，开发和预演环境的差异）的影响，从而有助于减少团队间在相同基础设施上运行不同软件时的冲突。</li>\n</ul>\n<p>如果需要通俗地描述容器的话，我觉得容器就是一个存放东西的地方，就像书包可以装各种文具、衣柜可以放各种衣服、鞋架可以放各种鞋子一样。我们现在所说的容器存放的东西可能更偏向于应用比如网站、程序甚至是系统环境。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/container.png\" alt=\"认识容器\" /></p>\n<center>认识容器</center>\n<h3 id=\"图解物理机-虚拟机-容器\"><a class=\"anchor\" href=\"#图解物理机-虚拟机-容器\">#</a> 图解：物理机、虚拟机、容器</h3>\n<p><strong>物理机：</strong></p>\n<p><img data-src=\"https://oss.javaguide.cn/github/javaguide/tools/docker/%E7%89%A9%E7%90%86%E6%9C%BA%E5%9B%BE%E8%A7%A3.jpeg\" alt=\"物理机\" /></p>\n<p><strong>虚拟机：</strong></p>\n<p><img data-src=\"https://oss.javaguide.cn/github/javaguide/tools/docker/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%9B%BE%E8%A7%A3.jpeg\" alt=\"虚拟机\" /></p>\n<p><strong>容器：</strong></p>\n<p><img data-src=\"https://oss.javaguide.cn/javaguide/image-20211110104003678.png\" alt=\"img\" /></p>\n<p>通过上面这三张抽象图，我们可以大概通过类比概括出：<strong><font color='red'>容器虚拟化的是操作系统而不是硬件，容器之间是共享同一套操作系统资源的</font>。虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统。<font color='red'>因此容器的隔离级别会稍低一些</font>。</strong></p>\n<h2 id=\"docker-思想\"><a class=\"anchor\" href=\"#docker-思想\">#</a> Docker 思想</h2>\n<h3 id=\"docker-是什么\"><a class=\"anchor\" href=\"#docker-是什么\">#</a> Docker 是什么</h3>\n<p>通过四点向你说明 Docker 到底是个什么东西。</p>\n<ul>\n<li><strong>Docker 是世界领先的<font color='red'>软件容器平台</font>，基于<font color='red'> Go 语言</font> 进行开发实现。</strong></li>\n<li><strong>Docker 可以<font color='red'>对进程进行封装隔离</font>，属于操作系统层面的虚拟化技术</strong>。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。</li>\n<li><strong><font color='red'>Docker 能够自动执行重复性任务，例如搭建和配置开发环境</font>，从而解放了开发人员。</strong></li>\n<li><strong>用户可以方便地<font color='red'>创建和使用容器</font>，把自己的应用放入容器。容器还可以进行<font color='red'>版本管理、复制、分享、修改</font>，就像管理普通的代码一样。</strong></li>\n</ul>\n<h3 id=\"docker-思想-2\"><a class=\"anchor\" href=\"#docker-思想-2\">#</a> Docker 思想</h3>\n<ul>\n<li><strong>集装箱</strong></li>\n<li><strong>标准化</strong>\n<ul>\n<li>运输方式</li>\n<li>存储方式</li>\n<li>API 接口</li>\n</ul>\n</li>\n<li><strong>隔离</strong></li>\n</ul>\n<h3 id=\"docker-容器的特点\"><a class=\"anchor\" href=\"#docker-容器的特点\">#</a> Docker 容器的特点</h3>\n<p><strong><font color='red'>轻量</font></strong> : 在一台机器上运行的多个 Docker 容器可以<font color='red'>共享这台机器的操作系统内核</font>；它们能够迅速启动，只需<font color='red'>占用很少的计算和内存资源</font>。镜像是通过文件系统层进行构造的，并共享一些公共文件。这样就能尽量降低磁盘用量，并能更快地下载镜像。</p>\n<p><strong><font color='red'>标准</font></strong> : Docker 容器<font color='red'>基于开放式标准</font>，能够在所有主流 Linux 版本、Microsoft Windows 以及包括 VM、裸机服务器和云在内的任何基础设施上运行。</p>\n<p><strong><font color='red'>安全</font></strong> : Docker 赋予应用的隔离性不仅限于彼此隔离，还独立于底层的基础设施。Docker <font color='red'>默认提供最强的隔离</font>，因此应用出现问题，也只是单个容器的问题，而不会波及到整台机器。</p>\n<h3 id=\"为什么使用-docker\"><a class=\"anchor\" href=\"#为什么使用-docker\">#</a> 为什么使用 Docker</h3>\n<p><font color='red'>借助 Docker，开发者可以将他们的应用以及依赖包<strong>打包</strong>到一个<strong>轻量级、可移植</strong>的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化</font>。</p>\n<p>容器是完全使用<font color='red'>沙箱机制，相互之间不会有任何接口</font>（类似 iPhone 的 app），更重要的是容器性能<font color='red'>开销极低</font>。</p>\n<p>传统的开发流程中，我们的项目通常需要使用 MySQL、Redis、FastDFS 等等环境，这些环境都是需要我们手动去进行下载并配置的，安装配置流程极其复杂，而且不同系统下的操作也不一样。</p>\n<p>Docker 的出现完美地解决了这一问题，我们<font color='red'>可以在容器中安装 MySQL、Redis 等软件环境，使得应用和环境架构分开</font>，它的优势在于：</p>\n<ul>\n<li><strong><font color='red'>一致的运行环境</font>：Docker 的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性，从而不会再出现 “这段代码在我机器上没问题啊” 这类问题；</strong></li>\n<li><strong><font color='red'>快速启动</font>：可以做到秒级、甚至毫秒级的启动时间，大大的节约了开发、测试、部署的时间；</strong></li>\n<li><strong><font color='red'>隔离性</font>：避免公用的服务器，资源会容易受到其他用户的影响；</strong></li>\n<li><strong><font color='red'>弹性伸缩，快速扩展</font>：善于处理集中爆发的服务器使用压力；</strong></li>\n<li><strong><font color='red'>迁移方便</font>：可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况；</strong></li>\n<li><strong><font color='red'>持续交付和部署</font>：使用 Docker 可以通过定制应用镜像来实现持续集成、持续交付、部署；</strong></li>\n</ul>\n<h2 id=\"容器-vs-虚拟机\"><a class=\"anchor\" href=\"#容器-vs-虚拟机\">#</a> 容器 vs 虚拟机</h2>\n<blockquote>\n<p>容器是一种虚拟化技术，常与虚拟机作比较。而 <font color='red'>Docker 只是容器的一种实现</font>，是一个容器化的解决方案和平台。不要把二者混为一谈。</p>\n</blockquote>\n<p><strong>每当说起容器，我们不得不将其与虚拟机做一个比较。就我而言，对于两者无所谓谁会取代谁，而是<font color='red'>两者可以和谐共存</font>。</strong></p>\n<p>简单来说：<strong>容器和虚拟机具有相似的资源隔离和分配优势，但功能有所不同，因为<font color='red'>容器虚拟化的是操作系统，而不是硬件，因此容器更容易移植，效率也更高</font>。</strong></p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20240121175824099.png\" alt=\"image-20240121175824099\" /></p>\n<center>虚拟化（Hypervisor）技术</center>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20240121180015087.png\" alt=\"image-20240121180015087\" /></p>\n<center>虚拟机（VM）示意图</center>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20240121180238543.png\" alt=\"image-20240121180238543\" /></p>\n<center>容器示意图</center>\n<h3 id=\"对比图\"><a class=\"anchor\" href=\"#对比图\">#</a> 对比图</h3>\n<p>传统虚拟机技术（VM）是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；而<font color='red'>容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核</font>，而且也没有进行硬件虚拟。<font color='red'>因此容器要比传统虚拟机更为轻便</font>。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/2e2b95eebf60b6d03f6c1476f4d7c697.png\" alt=\"img\" /></p>\n<h3 id=\"二者总结\"><a class=\"anchor\" href=\"#二者总结\">#</a> 二者总结</h3>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/4ef8691d67eb1eb53217099d0a691eb5.png\" alt=\"img\" /></p>\n<ul>\n<li><strong><font color='red'>容器是一个应用层抽象，用于将代码和依赖资源打包在一起。多个容器可以在同一台机器上运行，共享操作系统内核，但各自作为独立的进程在用户空间中运行</font></strong>。与虚拟机相比， <strong>容器占用的空间较少</strong>（容器镜像大小通常只有几十兆），<strong>瞬间就能完成启动</strong>。</li>\n<li><strong><font color='red'>虚拟机 (VM) 是一个物理硬件层抽象，用于将一台服务器变成多台服务器</font>。</strong> 管理程序允许多个 VM 在一台机器上运行。每个 VM 都包含一整套操作系统、一个或多个应用、必要的二进制文件和库资源，因此 <strong>占用大量空间</strong> 。而且 VM <strong>启动也十分缓慢</strong> 。</li>\n</ul>\n<p>通过 Docker 官网，我们知道了这么多 Docker 的优势，但是大家也没有必要完全否定虚拟机技术，因为两者有不同的使用场景。<strong><font color='red'>虚拟机更擅长于彻底隔离整个运行环境</font></strong>。例如，云服务提供商通常采用虚拟机技术隔离不同的用户。而 <strong><font color='red'>Docker 通常用于隔离不同的应用</font></strong> ，例如前端，后端以及数据库。</p>\n<h3 id=\"二者可共存\"><a class=\"anchor\" href=\"#二者可共存\">#</a> 二者可共存</h3>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/056c87751b9dd7b56f4264240fe96d00.png\" alt=\"img\" /></p>\n<center>Docker与虚拟机的共存关系</center>\n<h2 id=\"docker-基本概念\"><a class=\"anchor\" href=\"#docker-基本概念\">#</a> Docker 基本概念</h2>\n<p>Docker 中有非常重要的三个基本概念，理解了这三个概念，就理解了 Docker 的整个生命周期。</p>\n<ul>\n<li>\n<p><strong><font color='cornflowerblue'>镜像（Image）</font></strong>：<font color='red'>Image 是一个只读的模板</font>，可以用来创建多个 Container 。相当于是一个 root 文件系统，是<font color='red'>用于创建 Container 的模板</font>。</p>\n</li>\n<li>\n<p><strong><font color='cornflowerblue'>容器（Container）</font></strong>：<font color='red'>Container 是 Image 的一个运行实例</font>，它提供了一个独立的可移植的环境，可以在这个环境中运行应用程序。Image 和 Container 的关系，就像是面向对象程序设计中的类和实例一样，<strong><font color='red'>Image 是静态的定义（类），Container 是 Image 运行时的实体（实例）</font></strong>。Container 是独立运行的一个或一组应用，<font color='red'>是 Image 运行时的实体</font>，可以被创建、启动、停止、删除、暂停等。</p>\n</li>\n<li>\n<p><strong><font color='cornflowerblue'>仓库（Repository）</font></strong>：用来<font color='red'>存放 Image </font>的仓库，类似于代码控制中心。</p>\n<blockquote>\n<p><strong><font color='cornflowerblue'>注册表（Registry）</font></strong>：<font color='red'>包含多个 Repository，每个 Repository 可以包含多个 Tag，每个 Tag 对应一个 Image </font>。</p>\n</blockquote>\n</li>\n</ul>\n<p>理解了这三个概念，就理解了<font color='red'> Docker 的整个生命周期</font>。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/docker-overview.png\" alt=\"An Introductory Guide To Docker for Beginners\" /></p>\n<center>Docker 基本概念</center>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20240121181052546.png\" alt=\"image-20240121181052546\" /></p>\n<center>Docker 架构</center>\n<h3 id=\"镜像image一个特殊的文件系统\"><a class=\"anchor\" href=\"#镜像image一个特殊的文件系统\">#</a> 镜像（Image）：一个特殊的文件系统</h3>\n<p><strong>操作系统分为内核和用户空间</strong>。对于 Linux 而言，内核启动后，会挂载 root 文件系统为其提供用户空间支持。而 Image 就相当于是一个 root 文件系统。</p>\n<p><strong>Image 是一个特殊的文件系统，除了<font color='red'>提供容器运行时所需的程序、库、资源、配置等文件</font>外，还<font color='red'>包含了一些为运行时准备的配置参数（如匿名卷、环境变量、用户等）</font>。</strong><font color='red'>Image 不包含任何动态数据，其内容在构建之后也不会被改变</font>。</p>\n<p>Docker 设计时，就充分利用 <strong>Union FS</strong> 的技术，将其设计为<strong>分层存储的架构</strong>。Image 实际是由多层文件系统联合组成。</p>\n<p>**<font color='red'>Image 是逐层构建的，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。</font>** 比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随 Image 。因此在构建 Image 的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。</p>\n<p>分层存储的特征还使得<font color='red'> Image 的复用、定制</font>变的更为容易。甚至可以用之前构建好的 Image 作为基础层，然后进一步添加新的层，以定制自己所需的内容，构建新的 Image 。</p>\n<h3 id=\"容器containerimage-运行时的实体\"><a class=\"anchor\" href=\"#容器containerimage-运行时的实体\">#</a> 容器（Container）：Image 运行时的实体</h3>\n<p>镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的 类 和 实例 一样，<strong><font color='red'>Image 是静态的定义，Container 是 Image 运行时的实体</font>。Container 可以被创建、启动、停止、删除、暂停等</strong>。</p>\n<p><strong>Container 的实质是进程，但与直接在宿主执行的进程不同，<font color='red'>Container 进程运行于属于自己的独立的命名空间</font>。前面讲过 Image 使用的是分层存储，<font color='red'>Container 也是分层存储</font>。</strong></p>\n<p><strong><font color='red'>Container 存储层的生存周期和 Container 一样</font>，Container 消亡时，Container 存储层也随之消亡。因此，任何保存于 Container 存储层的信息都会随 Container 删除而丢失。</strong></p>\n<p>按照 Docker 最佳实践的要求，<strong><font color='red'>Container 不应该向其存储层内写入任何数据</font></strong> ，容器存储层要保持无状态化。<strong>所有的文件写入操作，都应该使用数据卷（Volume）、或者绑定宿主目录</strong>，在这些位置的读写会跳过容器存储层，直接对宿主 (或网络存储) 发生读写，其性能和稳定性更高。<font color='red'>数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡</font>。因此，<strong>使用数据卷后，容器可以随意删除、重新 run ，数据却不会丢失。</strong></p>\n<h3 id=\"仓库repository集中存放-image-文件的地方\"><a class=\"anchor\" href=\"#仓库repository集中存放-image-文件的地方\">#</a> 仓库（Repository）：集中存放 Image 文件的地方</h3>\n<h4 id=\"概念\"><a class=\"anchor\" href=\"#概念\">#</a> 概念</h4>\n<p>Image 构建完成后，可以很容易的在当前宿主上运行，但是，<strong>如果需要在其它服务器上使用这个 Image，我们就需要<font color='red'>一个集中的存储、分发 Image 的服务</font>，Docker Registry 就是这样的服务。</strong></p>\n<p><strong><font color='red'>一个 Registry 中可以包含多个 Repository，每个 Repository 可以包含多个 Tag，每个 Tag 对应一个 Image</font></strong>。所以说：镜像仓库是 Docker 用来集中存放镜像文件的地方，类似于我们之前常用的代码仓库。</p>\n<p>通常，<strong>一个 Repository 会包含同一个软件不同版本的 Image</strong>，而 <strong>tag 就常用于对应该软件的各个版本</strong> 。我们可以通过 <code>&lt;仓库名&gt;:&lt;标签&gt;</code>  的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 latest 作为默认标签。</p>\n<hr />\n<p>这里补充一下 <code> Docker Registry 公开服务</code> 和 <code>私有 Docker Registry </code> 的概念：</p>\n<h4 id=\"registry-公开服务\"><a class=\"anchor\" href=\"#registry-公开服务\">#</a> Registry 公开服务</h4>\n<p>Docker Registry 公开服务是开放给用户使用、允许用户管理 Image 的 Registry 服务。一般这类公开服务<font color='red'>允许用户免费上传、下载公开的 Image</font>，并可能提供收费服务供用户管理私有 Image 。<font color='red'>最常使用的 Registry 公开服务是官方的 <strong>Docker Hub</strong> ，这也是默认的 Registry</font>，并拥有大量的高质量的官方镜像，网址为：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9odWIuZG9ja2VyLmNvbS8=\">https://hub.docker.com/</span> 。官方是这样介绍 Docker Hub 的：</p>\n<blockquote>\n<p>Docker Hub 是 Docker 官方提供的一项服务，用于与您的团队查找和共享容器镜像。</p>\n</blockquote>\n<p>比如我们想要搜索自己想要的镜像：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20240120142613581.png\" alt=\"利用Docker Hub 搜索镜像\" /></p>\n<center>利用Docker Hub 搜索镜像</center>\n<p>在 Docker Hub 的搜索结果中，有几项关键的信息有助于我们选择合适的镜像：</p>\n<ul>\n<li><strong>OFFICIAL Image</strong>：代表镜像为 Docker 官方提供和维护，相对来说稳定性和安全性较高。</li>\n<li><strong>Stars</strong>：和点赞差不多的意思，类似 GitHub 的 Star。</li>\n<li><strong>Downloads</strong>：代表镜像被拉取的次数，基本上能够表示镜像被使用的频度。</li>\n</ul>\n<p>当然，除了直接通过 Docker Hub 网站搜索镜像这种方式外，我们<font color='red'>还可以通过  <code>docker search</code>  这个命令搜索 Docker Hub 中的镜像</font>，搜索的结果是一致的。</p>\n<figure class=\"highlight sh\"><figcaption data-lang=\"sh\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>➜  ~ <span class=\"token function\">docker</span> search mysql</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>NAME                              DESCRIPTION                                     STARS               OFFICIAL            AUTOMATED</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>mysql                             MySQL is a widely used, open-source relation…   <span class=\"token number\">8763</span>                <span class=\"token punctuation\">[</span>OK<span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>mariadb                           MariaDB is a community-developed fork of MyS…   <span class=\"token number\">3073</span>                <span class=\"token punctuation\">[</span>OK<span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>mysql/mysql-server                Optimized MySQL Server Docker images. Create…   <span class=\"token number\">650</span>                                     <span class=\"token punctuation\">[</span>OK<span class=\"token punctuation\">]</span></pre></td></tr></table></figure><p>在国内访问 <strong>Docker Hub</strong> 可能会比较慢，<font color='red'>国内也有一些云服务商</font>提供类似于 Docker Hub 的公开服务。比如 <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cudGVueGNsb3VkLmNvbS8=\">时速云镜像库</span>、<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuMTYzeXVuLmNvbS9wcm9kdWN0L3JlcG8=\">网易云镜像服务</span>、<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuZGFvY2xvdWQuaW8v\">DaoCloud 镜像市场</span>、<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWxpeXVuLmNvbS9wcm9kdWN0L2NvbnRhaW5lcnNlcnZpY2U/dXRtX2NvbnRlbnQ9c2VfMTI5MjgzNg==\">阿里云镜像库</span>等。</p>\n<h4 id=\"私有-registry\"><a class=\"anchor\" href=\"#私有-registry\">#</a> 私有 Registry</h4>\n<p>除了使用公开服务外，用户还可以 **<font color='red'>在本地搭建私有 Docker Registry</font>** 。Docker 官方提供了 Docker Registry 镜像，可以直接使用做为私有 Registry 服务。开源的 Docker Registry 镜像只提供了 Docker Registry API 的服务端实现，足以支持 docker 命令，不影响使用。但不包含图形界面，以及镜像维护、用户管理、访问控制等高级功能。</p>\n<h3 id=\"dockerfile\"><a class=\"anchor\" href=\"#dockerfile\">#</a> Dockerfile</h3>\n<p>容器化的过程包括三个步骤：</p>\n<ol>\n<li><strong>编写 Dockerfile</strong></li>\n<li>使用 Dockerfile <strong>构建 Image</strong></li>\n<li>使用 Image <strong>创建和运行 Container</strong></li>\n</ol>\n<p>其中，<strong><font color='red'>Dockerfile 是一个包含指令的文本文件</font></strong>，用于告诉 Docker 如何构建应用程序的 Image，包括应用程序的命令、依赖、配置环境和运行环境等内容。<font color='red'>一般在项目根目录下创建一个名为  <code>Dockerfile</code>  的文件</font>，第一个字母 D 大写，其他都小写。</p>\n<p>有了 Image 之后，就可以使用该 Image 来创建 Container，并<font color='red'>在 Container 中运行应用程序</font>。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20240121194842382.png\" alt=\"image-20240121194842382\" /></p>\n<h3 id=\"docker-compose\"><a class=\"anchor\" href=\"#docker-compose\">#</a> Docker Compose</h3>\n<p><font color='red'>docker compose 可以定义和运行多个 docker 容器和应用程序，解决服务之间关联关系的问题</font>。通过一个单独的  <code>docker-compose.yml</code>  配置文件，将一组互相关联的容器组合在一起，形成一个项目，然后<font color='red'>使用一条命令  <code>docker compose up</code>  就可以启动、停止或重建这些服务，方便管理</font>。这对于提高开发效率和减少沟通成本非常有用，建议初学者学习使用。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20240121194754264.png\" alt=\"image-20240121194754264\" /></p>\n<h2 id=\"docker-常见命令\"><a class=\"anchor\" href=\"#docker-常见命令\">#</a> Docker 常见命令</h2>\n<h3 id=\"基本命令\"><a class=\"anchor\" href=\"#基本命令\">#</a> 基本命令</h3>\n<figure class=\"highlight sh\"><figcaption data-lang=\"sh\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">docker</span> version <span class=\"token comment\"># 查看 docker 版本</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">docker</span> images <span class=\"token comment\"># 查看所有已下载镜像，等价于：docker image ls 命令</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token function\">docker</span> container <span class=\"token function\">ls</span> <span class=\"token comment\"># 查看所有容器</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token function\">docker</span> <span class=\"token function\">ps</span> <span class=\"token comment\">#查看正在运行的容器</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token function\">docker</span> image prune <span class=\"token comment\"># 清理临时的、没有被使用的镜像文件。-a, --all: 删除所有没有用的镜像，而不仅仅是临时文件；</span></pre></td></tr></table></figure><h3 id=\"拉取镜像\"><a class=\"anchor\" href=\"#拉取镜像\">#</a> 拉取镜像</h3>\n<figure class=\"highlight sh\"><figcaption data-lang=\"sh\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">docker</span> search mysql <span class=\"token comment\"># 查看 mysql 相关镜像</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">docker</span> pull mysql:5.7 <span class=\"token comment\"># 拉取 mysql 镜像</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token function\">docker</span> image <span class=\"token function\">ls</span> <span class=\"token comment\"># 查看所有已下载镜像</span></pre></td></tr></table></figure><h3 id=\"删除镜像\"><a class=\"anchor\" href=\"#删除镜像\">#</a> 删除镜像</h3>\n<p>比如我们要删除我们下载的 mysql 镜像。</p>\n<p>通过  <code>docker rmi [image]</code>  （等价于 <code>docker image rm [image]</code> ）删除镜像之前<font color='red'>首先要确保这个镜像没有被容器引用</font>（可以通过 tag 名称或者 image ID 删除）。</p>\n<p>举个例子，通过我们前面讲的 <code>docker ps</code>  命令即可查看。</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>➜  ~ <span class=\"token function\">docker</span> <span class=\"token function\">ps</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                               NAMES</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>c4cd691d9f80        mysql:5.7           <span class=\"token string\">\"docker-entrypoint.s…\"</span>   <span class=\"token number\">7</span> weeks ago         Up <span class=\"token number\">12</span> days          <span class=\"token number\">0.0</span>.0.0:3306-<span class=\"token operator\">></span><span class=\"token number\">3306</span>/tcp, <span class=\"token number\">33060</span>/tcp   mysql</pre></td></tr></table></figure><p>可以看到 mysql 正在被 id 为 c4cd691d9f80 的容器引用，我们需要首先通过  <code>docker stop c4cd691d9f80</code>  或者  <code>docker stop mysql</code>  暂停这个容器。</p>\n<p>然后查看 mysql 镜像的 id</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>➜  ~ <span class=\"token function\">docker</span> images</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>REPOSITORY              TAG                 IMAGE ID            CREATED             SIZE</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>mysql                   <span class=\"token number\">5.7</span>                 f6509bac4980        <span class=\"token number\">3</span> months ago        373MB</pre></td></tr></table></figure><p><font color='red'>通过 IMAGE ID 或者 REPOSITORY 名字即可删除</font></p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">docker</span> rmi f6509bac4980 <span class=\"token comment\">#  或者 docker rmi mysql</span></pre></td></tr></table></figure><h2 id=\"docker-两句口号\"><a class=\"anchor\" href=\"#docker-两句口号\">#</a> Docker 两句口号</h2>\n<ul>\n<li><strong><font color='red'>“Build, Ship and Run（搭建、发送、运行）”</font></strong></li>\n<li><strong><font color='red'>“Build once，Run anywhere（搭建一次，到处能用）”</font></strong></li>\n</ul>\n<p>如果你搜索 Docker 官网，会发现如下的字样：<strong>“Docker - Build, Ship, and Run Any App, Anywhere”</strong>。那么 Build, Ship, and Run 到底是在干什么呢？</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/docker-build-ship-run.jpg\" alt=\"img\" /></p>\n<ul>\n<li><strong><font color='red'>Build（构建镜像）</font></strong>：镜像就像是集装箱，包括文件以及运行环境等等资源。</li>\n<li><strong><font color='red'>Ship（运输镜像）</font></strong>：主机和仓库间运输，这里的仓库就像是超级码头一样。</li>\n<li><strong><font color='red'>Run（运行镜像）</font></strong>：运行的镜像就是一个容器，容器就是运行程序的地方。</li>\n</ul>\n<p><strong><font color='red'>Docker 运行过程也就是去仓库把镜像拉到本地，然后用一条命令把镜像运行起来变成容器</font>。所以，我们也常常将 Docker 称为码头工人或码头装卸工，这和 Docker 的中文翻译搬运工人如出一辙。</strong></p>\n<h2 id=\"docker-底层原理\"><a class=\"anchor\" href=\"#docker-底层原理\">#</a> Docker 底层原理</h2>\n<h3 id=\"虚拟化技术\"><a class=\"anchor\" href=\"#虚拟化技术\">#</a> 虚拟化技术</h3>\n<p>首先，Docker <strong>容器虚拟化技术</strong>为基础的软件，那么什么是虚拟化技术呢？</p>\n<p>简单点来说，虚拟化技术可以这样定义：</p>\n<blockquote>\n<p>虚拟化技术是一种资源管理技术，是将计算机的各种<span class=\"exturl\" data-url=\"aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU4JUE4JTg4JUU3JUFFJTk3JUU2JUE5JTlGJUU3JUE3JTkxJUU1JUFEJUI4\">实体资源</span>（<span class=\"exturl\" data-url=\"aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvQ1BV\">CPU</span>、<span class=\"exturl\" data-url=\"aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JTg2JTg1JUU1JUFEJTk4\">内存</span>、<span class=\"exturl\" data-url=\"aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU3JUEzJTgxJUU3JTlCJTk4JUU3JUE5JUJBJUU5JTk3JUI0\">磁盘空间</span>、<span class=\"exturl\" data-url=\"aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU3JUI2JUIyJUU4JUI3JUFGJUU5JTgxJUE5JUU5JTg1JThEJUU1JTk5JUE4\">网络适配器</span>等），予以抽象、转换后呈现出来并可供分割、组合为一个或多个电脑配置环境。由此，打破实体结构间的不可切割的障碍，使用户可以比原本的配置更好的方式来应用这些电脑硬件资源。这些资源的新虚拟部分是不受现有资源的架设方式，地域或物理配置所限制。一般所指的虚拟化资源包括计算能力和数据存储。</p>\n</blockquote>\n<h3 id=\"docker-基于-lxc-虚拟容器技术\"><a class=\"anchor\" href=\"#docker-基于-lxc-虚拟容器技术\">#</a> Docker 基于 LXC 虚拟容器技术</h3>\n<p>Docker 技术是基于 <strong>LXC（Linux container- Linux 容器）虚拟容器技术</strong>的。</p>\n<blockquote>\n<p>LXC，其名称来自 Linux 软件容器（Linux Containers）的缩写，一种操作系统层虚拟化（Operating system–level virtualization）技术，为 Linux 内核容器功能的一个用户空间接口。它将应用软件系统打包成一个软件容器（Container），内含应用软件本身的代码，以及所需要的操作系统核心和库。通过统一的名字空间和共用 API 来分配不同软件容器的可用硬件资源，创造出应用程序的独立沙箱运行环境，使得 Linux 用户可以容易的创建和管理系统或应用容器。</p>\n</blockquote>\n<p><strong>LXC 技术主要是借助 Linux 内核中提供的 CGroup 功能和 namespace 来实现的，通过 LXC 可以为软件提供一个独立的操作系统运行环境</strong>。</p>\n<p>cgroup 和 namespace 介绍：</p>\n<ul>\n<li>\n<p><strong><font color='red'>namespace 是 Linux 内核用来隔离内核资源的方式。</font></strong> 通过 namespace 可以让一些进程只能看到与自己相关的一部分资源，而另外一些进程也只能看到与它们自己相关的资源，这两拨进程根本就感觉不到对方的存在。具体的实现方式是把一个或多个进程的相关资源指定在同一个 namespace 中。Linux namespaces 是对全局系统资源的一种封装隔离，使得处于不同 namespace 的进程拥有独立的全局系统资源，改变一个 namespace 中的系统资源只会影响当前 namespace 里的进程，对其他 namespace 中的进程没有影响。</p>\n</li>\n<li>\n<p><strong><font color='red'>CGroup 是 Control Groups 的缩写，是 Linux 内核提供的一种可以限制、记录、隔离进程组 (process groups) 所使用的物力资源 (如 cpu memory i/o 等等) 的机制</font>。</strong></p>\n</li>\n</ul>\n<p>cgroup 和 namespace 两者对比：</p>\n<p><font color='red'>两者都是将进程进行分组</font>，但是两者的作用还是有本质区别。<font color='red'>namespace 是为了隔离进程组之间的资源，而 cgroup 是为了对一组进程进行统一的资源监控和限制</font>。</p>\n<h2 id=\"总结\"><a class=\"anchor\" href=\"#总结\">#</a> 总结</h2>\n<p>本文主要把 Docker 中的一些常见概念做了详细的阐述，但是并不涉及 Docker 的安装、镜像的使用、容器的操作等内容。这部分东西，希望读者自己可以通过阅读书籍与官方文档的形式掌握。如果觉得官方文档阅读起来很费力的话，这里推荐以下内容：</p>\n<ul>\n<li><strong>《Docker 技术入门与实战第二版》[<span class=\"exturl\" data-url=\"aHR0cHM6Ly95ZWFzeS5naXRib29rLmlvL2RvY2tlcl9wcmFjdGljZS8=\">前言 - Docker — 从入门到实践 (gitbook.io)</span>]</strong></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC81MzI2MDA5OA==\">10 分钟看懂 Docker 和 K8S</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuaW5mb3EuY24vYXJ0aWNsZS90ZTcwRmxTeXhobHRMMUNyN2d6TQ==\">从零开始入门 K8s：详解 K8s 容器基本概念</span></li>\n</ul>\n<h1 id=\"docker-实战\"><a class=\"anchor\" href=\"#docker-实战\">#</a> Docker 实战</h1>\n<h2 id=\"安装\"><a class=\"anchor\" href=\"#安装\">#</a> 安装</h2>\n<h3 id=\"windows\"><a class=\"anchor\" href=\"#windows\">#</a> Windows</h3>\n<h3 id=\"mac\"><a class=\"anchor\" href=\"#mac\">#</a> Mac</h3>\n<p>直接使用 Homebrew 安装即可</p>\n<figure class=\"highlight sh\"><figcaption data-lang=\"sh\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>brew <span class=\"token function\">install</span> <span class=\"token parameter variable\">--cask</span> <span class=\"token function\">docker</span></pre></td></tr></table></figure><h3 id=\"linux\"><a class=\"anchor\" href=\"#linux\">#</a> Linux</h3>\n<p>下面来看看 Linux 中如何安装 Docker，这里以 <strong>CentOS7</strong> 为例。</p>\n<p>在测试或开发环境中，Docker 官方为了简化安装流程，提供了一套便捷的安装脚本，执行这个脚本后就会自动地将一切准备工作做好，并且把 Docker 的稳定版本安装在系统中。</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">curl</span> <span class=\"token parameter variable\">-fsSL</span> get.docker.com <span class=\"token parameter variable\">-o</span> get-docker.sh</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">sh</span> get-docker.sh <span class=\"token parameter variable\">--mirror</span> Aliyun</pre></td></tr></table></figure><p>安装完成后直接启动服务：</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>systemctl start <span class=\"token function\">docker</span></pre></td></tr></table></figure><p>推荐设置开机自启，执行指令：</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>systemctl <span class=\"token builtin class-name\">enable</span> <span class=\"token function\">docker</span></pre></td></tr></table></figure><h2 id=\"几个概念\"><a class=\"anchor\" href=\"#几个概念\">#</a> 几个概念</h2>\n<h3 id=\"镜像image\"><a class=\"anchor\" href=\"#镜像image\">#</a> 镜像（Image）</h3>\n<p><font color='red'>Image 是一个只读的模板，可以用来创建多个 Container </font>。</p>\n<h3 id=\"容器container\"><a class=\"anchor\" href=\"#容器container\">#</a> 容器（Container）</h3>\n<p><font color='red'>Container 是根据 Image 创建的运行实例</font>，Docker 利用 Container 独立运行一个或一组应用。它可以被启动、开始、停止、删除，每个 Container 都是相互隔离的、保证安全的平台。 可以把 Container 看作是一个简易的 Linux 环境和运行在其中的应用程序。Container 的定义和 Image 几乎一模一样，也是一堆层的统一视角，<font color='red'>唯一区别在于 Container 的最上面那一层是可读可写的</font>。</p>\n<h3 id=\"仓库repository\"><a class=\"anchor\" href=\"#仓库repository\">#</a> 仓库（Repository）</h3>\n<p><font color='red'>仓库（Repository）是集中存放 Image 文件的场所</font>。仓库（Repository）和仓库注册服务器（Registry）是有区别的，<strong><font color='red'>Registry 上往往存放着多个 Repository，每个 Repository 中又包含了多个 Image，每个 Image 有不同的 Tag</font></strong>。Repository 分为公开 Repository 和私有 Repository 两种形式，<font color='red'>最大的公开 Repository 是 DockerHub</font>，存放了数量庞大的镜像供用户下载，<font color='red'>国内的公开仓库有阿里云、网易云</font>等</p>\n<h3 id=\"总结-2\"><a class=\"anchor\" href=\"#总结-2\">#</a> 总结</h3>\n<p>通俗点说，一个 Image 就代表一个软件；而基于某个 Image 运行就是生成一个程序实例，这个程序实例就是 Container ；而 Repository 是用来存储 Docker 中所有 Image 的。</p>\n<p>其中 Repository 又分为远程 Repository 和本地 Repository。</p>\n<p>和 Maven 类似，倘若每次都从远程下载依赖，则会大大降低效率。为此，Maven 的策略是第一次访问依赖时，将其下载到本地仓库，第二次、第三次使用时直接用本地仓库的依赖即可，Docker 的远程 Repository 和本地 Repository 的作用也是类似的。</p>\n<h2 id=\"初体验\"><a class=\"anchor\" href=\"#初体验\">#</a> 初体验</h2>\n<p>下面我们来对 Docker 进行一个初步的使用，这里以下载一个 MySQL 的镜像为例 <code>(在CentOS7下进行)</code> 。</p>\n<p>和 GitHub 一样，Docker 也提供了一个 DockerHub 用于查询各种镜像的地址和安装教程，为此，我们先访问 DockerHub：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9odWIuZG9ja2VyLmNvbS8=\">https://hub.docker.com/</span></p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/dockerhub-com.png\" alt=\"DockerHub\" /></p>\n<center>DockerHub</center>\n<p>在左上角的搜索框中输入 <code>MySQL</code>  并回车：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/dockerhub-mysql.png\" alt=\"DockerHub 搜索 MySQL\" /></p>\n<center>DockerHub 搜索 MySQL</center>\n<p>可以看到相关 MySQL 的镜像非常多，若右上角有 <code>OFFICIAL IMAGE</code>  标识，则说明是官方镜像，所以我们点击第一个 MySQL 镜像：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/dockerhub-mysql-official-image.png\" alt=\"MySQL 官方镜像\" /></p>\n<center>MySQL 官方镜像</center>\n<p>右边提供了下载 MySQL 镜像的指令为 <code>docker pull MySQL</code> ，但该指令始终会下载 MySQL 镜像的最新版本。</p>\n<p>若是想下载指定版本的镜像，则点击下面的 <code>View Available Tags</code> ：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/dockerhub-mysql-view-available-tags.png\" alt=\"查看其他版本的 MySQL\" /></p>\n<center>查看其他版本的 MySQL</center>\n<p>这里就可以看到各种版本的镜像，右边有下载的指令，所以若是想下载 5.7.32 版本的 MySQL 镜像，则执行：</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">docker</span> pull MySQL:5.7.32</pre></td></tr></table></figure><hr />\n<p>然而下载镜像的过程是非常慢的，所以我们需要配置一下镜像源加速下载，访问 <code>阿里云</code> 官网，点击<font color='red'>控制台</font>：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/docker-aliyun-mirror-admin.png\" alt=\"阿里云镜像加速\" /></p>\n<center>阿里云镜像加速</center>\n<p>然后点击左上角的菜单，在弹窗的窗口中，将鼠标悬停在<font color='red'>产品与服务</font>上，并在右侧搜索<font color='red'>容器镜像服务</font>，最后点击容器镜像服务：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/docker-aliyun-mirror-admin-accelerator.png\" alt=\"阿里云镜像加速\" /></p>\n<center>阿里云镜像加速</center>\n<p>点击左侧的镜像加速器，并依次执行右侧的配置指令即可。</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">sudo</span> <span class=\"token function\">mkdir</span> <span class=\"token parameter variable\">-p</span> /etc/docker</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">sudo</span> <span class=\"token function\">tee</span> /etc/docker/daemon.json <span class=\"token operator\">&lt;&lt;-</span><span class=\"token string\">'EOF'</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>&#123;</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>  \"registry-mirrors\": [\"https://679xpnpz.mirror.aliyuncs.com\"]</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>&#125;</pre></td></tr><tr><td data-num=\"6\"></td><td><pre>EOF</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token function\">sudo</span> systemctl daemon-reload</pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token function\">sudo</span> systemctl restart <span class=\"token function\">docker</span></pre></td></tr></table></figure><h2 id=\"image-指令\"><a class=\"anchor\" href=\"#image-指令\">#</a> Image 指令</h2>\n<p>若想 **<font color='red'>查看 Docker 中当前拥有哪些镜像</font>**，则可以使用  <code>docker images</code>  命令。</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token punctuation\">[</span>root@izrcf5u3j3q8xaz ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># docker images</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>REPOSITORY    TAG       IMAGE ID       CREATED         SIZE</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>MySQL         <span class=\"token number\">5.7</span>.32    f07dfa83b528   <span class=\"token number\">11</span> days ago     448MB</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>tomcat        latest    feba8d001e3f   <span class=\"token number\">2</span> weeks ago     649MB</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>nginx         latest    ae2feff98a0c   <span class=\"token number\">2</span> weeks ago     133MB</pre></td></tr><tr><td data-num=\"6\"></td><td><pre>hello-world   latest    bf756fb1ae65   <span class=\"token number\">12</span> months ago   <span class=\"token number\">13</span>.3kB</pre></td></tr></table></figure><p>其中 <code>REPOSITORY</code> <font color='red'>为镜像名</font>， <code>TAG</code>  为版本标志， <code>IMAGE ID</code>  为镜像 id (唯一的)， <code>CREATED</code>  为创建时间，注意这个时间并不是我们将镜像下载到 Docker 中的时间，而是<font color='red'>镜像创建者创建的时间</font>， <code>SIZE</code>  为镜像大小。</p>\n<hr />\n<p>该指令能够 **<font color='red'>根据镜像名查询指定镜像</font>**：</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">docker</span> image MySQL</pre></td></tr></table></figure><p>若如此做，则会查询出 Docker 中的所有 MySQL 镜像：</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token punctuation\">[</span>root@izrcf5u3j3q8xaz ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># docker images MySQL</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>REPOSITORY   TAG       IMAGE ID       CREATED         SIZE</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>MySQL        <span class=\"token number\">5.6</span>       0ebb5600241d   <span class=\"token number\">11</span> days ago     302MB</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>MySQL        <span class=\"token number\">5.7</span>.32    f07dfa83b528   <span class=\"token number\">11</span> days ago     448MB</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>MySQL        <span class=\"token number\">5.5</span>       d404d78aa797   <span class=\"token number\">20</span> months ago   205MB</pre></td></tr></table></figure><p>该指令还能够携带 <code>-q</code>  参数： <code>docker images -q</code>  ，  <code>-q</code> <font color='red'>表示仅显示镜像的 id</font>：</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token punctuation\">[</span>root@izrcf5u3j3q8xaz ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># docker images -q</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>0ebb5600241d</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>f07dfa83b528</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>feba8d001e3f</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>d404d78aa797</pre></td></tr></table></figure><hr />\n<p>若是要 **<font color='red'>下载指定版本的镜像</font>**，则使用：</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">docker</span> pull MySQL:5.7</pre></td></tr></table></figure><p><code>docker pull</code>  是固定的，后面写上需要下载的镜像名及版本标志；若是不写版本标志，而是直接执行 <code>docker pull MySQL</code> ，则会下载镜像的最新版本。</p>\n<p>一般在下载镜像前我们需要 **<font color='red'>搜索一下镜像有哪些版本</font>** 才能对指定版本进行下载，使用指令：</p>\n<figure class=\"highlight sh\"><figcaption data-lang=\"sh\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">docker</span> search MySQL</pre></td></tr></table></figure><p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/docker-search-mysql-terminal.png\" alt=\"img\" /></p>\n<p>不过该指令只能查看 MySQL 相关的镜像信息，而不能知道有哪些版本，若想知道版本，则只能这样查询：</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">docker</span> search MySQL:5.5</pre></td></tr></table></figure><p>若是查询的版本不存在，则结果为空：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/docker-search-mysql-404-terminal.png\" alt=\"img\" /></p>\n<hr />\n<p>**<font color='red'>删除镜像</font>** 使用指令：</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">docker</span> image <span class=\"token function\">rm</span> MySQL:5.5</pre></td></tr></table></figure><p>若是不指定版本，则默认删除的也是最新版本。</p>\n<p>还可以通过<font color='red'>指定镜像 id 进行删除</font>：</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">docker</span> image <span class=\"token function\">rm</span> bf756fb1ae65</pre></td></tr></table></figure><p>然而此时报错了：</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token punctuation\">[</span>root@izrcf5u3j3q8xaz ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># docker image rm bf756fb1ae65</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>Error response from daemon: conflict: unable to delete bf756fb1ae65 <span class=\"token punctuation\">(</span>must be forced<span class=\"token punctuation\">)</span> - image is being used by stopped container d5b6c177c151</pre></td></tr></table></figure><p>这是因为要删除的 <code>hello-world</code>  镜像正在运行中，所以无法删除镜像，此时需要<font color='red'>强制执行删除</font>：</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">docker</span> image <span class=\"token function\">rm</span> <span class=\"token parameter variable\">-f</span> bf756fb1ae65</pre></td></tr></table></figure><p><font color='red'>该指令会将镜像和通过该镜像执行的容器全部删除，谨慎使用</font>。</p>\n<hr />\n<p>Docker 还提供了 **<font color='red'>删除镜像的简化版本</font>**： <code>docker rmi 镜像名:版本标志</code>  。</p>\n<p>此时我们即可借助 <code>rmi</code>  和 <code>-q</code>  进行一些联合操作，比如现在想删除所有的 MySQL 镜像，那么你需要查询出 MySQL 镜像的 id，并根据这些 id 一个一个地执行 <code>docker rmi</code>  进行删除，但是现在，我们可以这样：</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">docker</span> rmi <span class=\"token parameter variable\">-f</span> <span class=\"token variable\"><span class=\"token variable\">$(</span><span class=\"token function\">docker</span> images MySQL <span class=\"token parameter variable\">-q</span><span class=\"token variable\">)</span></span></pre></td></tr></table></figure><p>首先通过 <code>docker images MySQL -q</code>  查询出 MySQL 的所有镜像 id， <code>-q</code>  表示仅查询 id，并将这些 id 作为参数传递给 <code>docker rmi -f</code>  指令，这样所有的 MySQL 镜像就都被删除了。</p>\n<h2 id=\"container-指令\"><a class=\"anchor\" href=\"#container-指令\">#</a> Container 指令</h2>\n<p>掌握了镜像的相关指令之后，我们需要了解一下容器的指令，容器是基于镜像的。</p>\n<p>若需要 **<font color='red'>通过 Image 运行一个 Container</font>**，则使用：</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">docker</span> run tomcat:8.0-jre8</pre></td></tr></table></figure><p>当然了，运行的前提是你拥有这个镜像，所以<font color='red'>先下载镜像</font>：</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">docker</span> pull tomcat:8.0-jre8</pre></td></tr></table></figure><hr />\n<p>下载完成后就可以运行了，运行后 **<font color='red'>查看一下当前运行的 Container</font>**： <code>docker ps</code>  。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/docker-ps-terminal.png\" alt=\"img\" /></p>\n<p>其中 <code>CONTAINER_ID</code>  为容器的 id， <code>IMAGE</code>  为镜像名， <code>COMMAND</code> <font color='red'>为容器内执行的命令</font>， <code>CREATED</code>  为容器的创建时间， <code>STATUS</code>  为容器的状态， <code>PORTS</code> <font color='red'>为容器内服务监听的端口</font>， <code>NAMES</code> <font color='red'>为容器的名称</font>。</p>\n<p>该指令有几个参数，比如 <code>-a</code> ：</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">docker</span> <span class=\"token function\">ps</span> <span class=\"token parameter variable\">-a</span></pre></td></tr></table></figure><p>该参数会<font color='red'>将运行和非运行的容器全部列举出来</font>。</p>\n<p><code>-q</code>  参数将<font color='red'>查询结果只显示容器 id</font>： <code>docker ps -q</code>  。</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token punctuation\">[</span>root@izrcf5u3j3q8xaz ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># docker ps -q</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>f3aac8ee94a3</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>074bf575249b</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>1d557472a708</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>4421848ba294</pre></td></tr></table></figure><p>若是组合使用，则查询运行和非运行的所有容器 id： <code>docker ps -qa</code>  。</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token punctuation\">[</span>root@izrcf5u3j3q8xaz ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># docker ps -aq</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>f3aac8ee94a3</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>7f7b0e80c841</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>074bf575249b</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>a1e830bddc4c</pre></td></tr><tr><td data-num=\"6\"></td><td><pre>1d557472a708</pre></td></tr><tr><td data-num=\"7\"></td><td><pre>4421848ba294</pre></td></tr><tr><td data-num=\"8\"></td><td><pre>b0440c0a219a</pre></td></tr><tr><td data-num=\"9\"></td><td><pre>c2f5d78c5d1a</pre></td></tr><tr><td data-num=\"10\"></td><td><pre>5831d1bab2a6</pre></td></tr><tr><td data-num=\"11\"></td><td><pre>d5b6c177c151</pre></td></tr></table></figure><hr />\n<p>通过该方式运行的 tomcat 是不能直接被外部访问的，因为容器具有隔离性，若是想直接通过 8080 端口访问容器内部的 tomcat，则需要 **<font color='red'>对宿主机端口与 Container 内的端口进行映射</font>**：</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">docker</span> run <span class=\"token parameter variable\">-p</span> <span class=\"token number\">8080</span>:8080 tomcat:8.0-jre8</pre></td></tr></table></figure><p>解释一下这两个端口的作用 ( <code>8080:8080</code> )，<font color='red'>第一个为宿主机端口，第二个为容器内的端口</font>，外部访问 8080 端口就会通过映射访问容器内的 8080 端口。</p>\n<p>此时外部就可以访问 Tomcat 了：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/docker-run-tomact-8080.png\" alt=\"img\" /></p>\n<p>若是这样进行映射：</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">docker</span> run <span class=\"token parameter variable\">-p</span> <span class=\"token number\">8088</span>:8080 tomcat:8.0-jre8</pre></td></tr></table></figure><p>则外部需访问 8088 端口才能访问 tomcat，需要注意的是，每次运行的容器都是相互独立的，所以<font color='red'>同时运行多个 tomcat 容器并不会产生端口的冲突</font>。</p>\n<hr />\n<p><font color='red'>通过 <code>-d</code> ，容器还能够以后台的方式运行</font>，这样就不会占用终端：</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">docker</span> run <span class=\"token parameter variable\">-d</span> <span class=\"token parameter variable\">-p</span> <span class=\"token number\">8080</span>:8080 tomcat:8.0-jre8</pre></td></tr></table></figure><p>启动容器时默认会给容器一个名称，但<font color='red'>容器名称其实是可以通过 <code>--name</code>  设置的</font>，使用指令：</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">docker</span> run <span class=\"token parameter variable\">-d</span> <span class=\"token parameter variable\">-p</span> <span class=\"token number\">8080</span>:8080 <span class=\"token parameter variable\">--name</span> tomcat01 tomcat:8.0-jre8</pre></td></tr></table></figure><p>此时的容器名称即为 tomcat01，<font color='red'>容器名称必须是唯一的</font>。</p>\n<hr />\n<p>接下来是 **<font color='red'>容器的运行、重启、暂停、杀死</font>** 指令，因为非常简单，就不过多介绍了。</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">docker</span> start c2f5d78c5d1a</pre></td></tr></table></figure><p>通过该指令能够将已经停止运行的容器运行起来，可以通过容器的 id 启动，也可以通过容器的名称启动。</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">docker</span> restart c2f5d78c5d1a</pre></td></tr></table></figure><p>该指令能够重启指定的容器。</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">docker</span> stop c2f5d78c5d1a</pre></td></tr></table></figure><p>该指令能够停止指定的容器。</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">docker</span> <span class=\"token function\">kill</span> c2f5d78c5d1a</pre></td></tr></table></figure><p>该指令能够直接杀死指定的容器。</p>\n<p>以上指令<font color='red'>都能够通过容器的 id 和容器名称两种方式配合使用</font>。</p>\n<hr />\n<p>当容器被停止之后，容器虽然不再运行了，但仍然是存在的，若是想 **<font color='red'>删除容器</font>**，则使用指令：</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">docker</span> <span class=\"token function\">rm</span> d5b6c177c151</pre></td></tr></table></figure><p>需要注意的是<font color='red'>容器的 id 无需全部写出来，只需唯一标识即可</font>。</p>\n<p>若是想 **<font color='red'>删除正在运行的容器</font>**，则需要添加 <code>-f</code>  参数强制删除：</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">docker</span> <span class=\"token function\">rm</span> <span class=\"token parameter variable\">-f</span> d5b6c177c151</pre></td></tr></table></figure><p>若是想 **<font color='red'>删除所有容器</font>**，则可以使用组合指令：</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">docker</span> <span class=\"token function\">rm</span> <span class=\"token parameter variable\">-f</span> <span class=\"token variable\"><span class=\"token variable\">$(</span><span class=\"token function\">docker</span> <span class=\"token function\">ps</span> <span class=\"token parameter variable\">-qa</span><span class=\"token variable\">)</span></span></pre></td></tr></table></figure><p>先通过 <code>docker ps -qa</code>  查询出所有容器的 id，然后通过 <code>docker rm -f</code>  进行删除。</p>\n<hr />\n<p>当容器以后台的方式运行时，我们无法知晓容器的运行状态，若此时需要 **<font color='red'>查看容器的运行日志</font>**，则使用指令：</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">docker</span> logs 289cc00dc5ed</pre></td></tr></table></figure><p>这样的方式显示的日志并不是实时的，若是想<font color='red'>实时显示</font>，需要使用 <code>-f</code>  参数：</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">docker</span> logs <span class=\"token parameter variable\">-f</span> 289cc00dc5ed</pre></td></tr></table></figure><p>通过 <code>-t</code>  参数还能够<font color='red'>显示日志的时间戳</font>，通常与 <code>-f</code>  参数联合使用：</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">docker</span> logs <span class=\"token parameter variable\">-ft</span> 289cc00dc5ed</pre></td></tr></table></figure><hr />\n<p><strong><font color='red'>查看容器内运行了哪些进程</font></strong>，可以使用指令：</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">docker</span> <span class=\"token function\">top</span> 289cc00dc5ed</pre></td></tr></table></figure><p>若是 **<font color='red'>想与容器进行交互</font>**，则使用指令：</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">docker</span> <span class=\"token builtin class-name\">exec</span> <span class=\"token parameter variable\">-it</span> 289cc00dc5ed <span class=\"token function\">bash</span></pre></td></tr></table></figure><p><font color='red'>此时终端将会进入容器内部，执行的指令都将在容器中生效</font>，在容器内只能执行一些比较简单的指令，如：ls、cd 等，若是想退出容器终端，重新回到 CentOS 中，则执行 <code>exit</code>  即可。</p>\n<p>现在我们已经能够进入容器终端执行相关操作了，那么该如何向 tomcat 容器中部署一个项目呢？</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">docker</span> <span class=\"token function\">cp</span> ./test.html 289cc00dc5ed:/usr/local/tomcat/webapps</pre></td></tr></table></figure><p>通过 <code>docker cp</code>  指令能够将文件从 CentOS 复制到容器中， <code>./test.html</code>  为 CentOS 中的资源路径， <code>289cc00dc5ed</code>  为容器 id， <code>/usr/local/tomcat/webapps</code>  为容器的资源路径，此时 <code>test.html</code>  文件将会被复制到该路径下。</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token punctuation\">[</span>root@izrcf5u3j3q8xaz ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># docker exec -it 289cc00dc5ed bash</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>root@289cc00dc5ed:/usr/local/tomcat<span class=\"token comment\"># cd webapps</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>root@289cc00dc5ed:/usr/local/tomcat/webapps<span class=\"token comment\"># ls</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>test.html</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>root@289cc00dc5ed:/usr/local/tomcat/webapps<span class=\"token comment\">#</span></pre></td></tr></table></figure><p>若是想将容器内的文件复制到 CentOS 中，则反过来写即可：</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">docker</span> <span class=\"token function\">cp</span> 289cc00dc5ed:/usr/local/tomcat/webapps/test.html ./</pre></td></tr></table></figure><p>所以现在若是想要部署项目，则先将项目上传到 CentOS，然后将项目从 CentOS 复制到容器内，此时启动容器即可。</p>\n<hr />\n<p>虽然使用 Docker 启动软件环境非常简单，但同时也面临着一个问题，我们无法 **<font color='red'>查看容器内部具体的细节，比如监听的端口、绑定的 ip 地址等等</font>**，好在这些 Docker 都帮我们想到了，只需使用指令：</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">docker</span> inspect 923c969b0d91</pre></td></tr></table></figure><p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/docker-inspect-terminal.png\" alt=\"img\" /></p>\n<hr />\n<p>最后再介绍几个容器和镜像相关的指令：</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">docker</span> commit <span class=\"token parameter variable\">-m</span> <span class=\"token string\">\"描述信息\"</span> <span class=\"token parameter variable\">-a</span> <span class=\"token string\">\"镜像作者\"</span> tomcat01 my_tomcat:1.0</pre></td></tr></table></figure><blockquote>\n<p>tomcat01 为 Container 名称，my_tomcat 为打包后的 Image 名称，1.0 是对应的 tag。</p>\n</blockquote>\n<p>该指令能够 **<font color='red'>将 Container 打包成一个 Image</font>**，此时查询镜像：</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token punctuation\">[</span>root@centos-7 _data<span class=\"token punctuation\">]</span><span class=\"token comment\"># docker images</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>my_tomcat           <span class=\"token number\">1.0</span>                 79ab047fade5        <span class=\"token number\">2</span> seconds ago       463MB</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>tomcat              <span class=\"token number\">8</span>                   a041be4a5ba5        <span class=\"token number\">2</span> weeks ago         533MB</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>MySQL               latest              db2b37ec6181        <span class=\"token number\">2</span> months ag</pre></td></tr></table></figure><p>若是想 **<font color='red'>将 Image 备份出来</font>** 出来，则可以使用指令：</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">docker</span> save my_tomcat:1.0 <span class=\"token parameter variable\">-o</span> my-tomcat-1.0.tar</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">[</span>root@centos-7 ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># docker save my_tomcat:1.0 -o my-tomcat-1.0.tar</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">[</span>root@centos-7 ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># ls</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>anaconda-ks.cfg  initial-setup-ks.cfg  公共  视频  文档  音乐</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>get-docker.sh    my-tomcat-1.0.tar     模板  图片  下载  桌面</pre></td></tr></table></figure><p><strong><font color='red'>将 .tar 格式的 Image 加载到 Docker 中</font></strong>，执行指令：</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">docker</span> load <span class=\"token parameter variable\">-i</span> my-tomcat-1.0.tar</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>root@centos-7 ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># docker load -i my-tomcat-1.0.tar</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>b28ef0b6fef8: Loading layer <span class=\"token punctuation\">[</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">></span><span class=\"token punctuation\">]</span>  <span class=\"token number\">105</span>.5MB/105.5MB</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>0b703c74a09c: Loading layer <span class=\"token punctuation\">[</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">></span><span class=\"token punctuation\">]</span>  <span class=\"token number\">23</span>.99MB/23.99MB</pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>Loaded image: my_tomcat:1.0</pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">[</span>root@centos-7 ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># docker images</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</pre></td></tr><tr><td data-num=\"9\"></td><td><pre>my_tomcat           <span class=\"token number\">1.0</span>                 79ab047fade5        <span class=\"token number\">7</span> minutes ag</pre></td></tr></table></figure><h2 id=\"数据卷volume\"><a class=\"anchor\" href=\"#数据卷volume\">#</a> 数据卷（volume）</h2>\n<p>学习了容器的相关指令之后，我们来了解一下<font color='red'> Docker 中的数据卷，它能够实现<strong>宿主机与容器之间的文件共享</strong>，它的好处在于我们<strong>对宿主机的文件进行修改将直接影响容器</strong>，而无需再将宿主机的文件再复制到容器中</font>。</p>\n<p>现在若是想将宿主机中 <code>/opt/apps</code>  目录与容器中 <code>webapps</code>  目录 **<font color='red'>做一个数据卷</font>**，则应该通过 <code>-v</code>  参数这样编写指令：</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">docker</span> run <span class=\"token parameter variable\">-d</span> <span class=\"token parameter variable\">-p</span> <span class=\"token number\">8080</span>:8080 <span class=\"token parameter variable\">--name</span> tomcat01 <span class=\"token parameter variable\">-v</span> /opt/apps:/usr/local/tomcat/webapps tomcat:8.0-jre8</pre></td></tr></table></figure><p>然而此时访问 tomcat 会发现无法访问：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/docker-data-volume-webapp-8080.png\" alt=\"img\" /></p>\n<p>这就说明我们的数据卷设置成功了，Docker 会将容器内的 <code>webapps</code>  目录与 <code>/opt/apps</code>  目录进行同步，而此时 <code>/opt/apps</code>  目录是空的，导致 <code>webapps</code>  目录也会变成空目录，所以就访问不到了。</p>\n<p>此时我们只需向 <code>/opt/apps</code>  目录下添加文件，就会使得 <code>webapps</code>  目录也会拥有相同的文件，达到文件共享，测试一下：</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token punctuation\">[</span>root@centos-7 opt<span class=\"token punctuation\">]</span><span class=\"token comment\"># cd apps/</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">[</span>root@centos-7 apps<span class=\"token punctuation\">]</span><span class=\"token comment\"># vim test.html</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">[</span>root@centos-7 apps<span class=\"token punctuation\">]</span><span class=\"token comment\"># ls</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>test.html</pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">[</span>root@centos-7 apps<span class=\"token punctuation\">]</span><span class=\"token comment\"># cat test.html</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token operator\">&lt;</span>h<span class=\"token operator\"><span class=\"token file-descriptor important\">1</span>></span>This is a <span class=\"token builtin class-name\">test</span> html<span class=\"token operator\">!</span><span class=\"token operator\">&lt;</span>/h<span class=\"token operator\"><span class=\"token file-descriptor important\">1</span>></span></pre></td></tr></table></figure><p>在 <code>/opt/apps</code>  目录下创建了一个  <code>test.html</code>  文件，那么容器内的 <code>webapps</code>  目录是否会有该文件呢？进入容器的终端：</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token punctuation\">[</span>root@centos-7 apps<span class=\"token punctuation\">]</span><span class=\"token comment\"># docker exec -it tomcat01 bash</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>root@115155c08687:/usr/local/tomcat<span class=\"token comment\"># cd webapps/</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>root@115155c08687:/usr/local/tomcat/webapps<span class=\"token comment\"># ls</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>test.html</pre></td></tr></table></figure><p>容器内确实已经有了该文件，那接下来我们编写一个简单的 Web 应用：</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">HelloServlet</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">HttpServlet</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token annotation punctuation\">@Override</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token keyword\">protected</span> <span class=\"token keyword\">void</span> <span class=\"token function\">doGet</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">HttpServletRequest</span> req<span class=\"token punctuation\">,</span> <span class=\"token class-name\">HttpServletResponse</span> resp<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">ServletException</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">IOException</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>        resp<span class=\"token punctuation\">.</span><span class=\"token function\">getWriter</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Hello World!\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token annotation punctuation\">@Override</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token keyword\">protected</span> <span class=\"token keyword\">void</span> <span class=\"token function\">doPost</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">HttpServletRequest</span> req<span class=\"token punctuation\">,</span> <span class=\"token class-name\">HttpServletResponse</span> resp<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">ServletException</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">IOException</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>        <span class=\"token function\">doGet</span><span class=\"token punctuation\">(</span>req<span class=\"token punctuation\">,</span>resp<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>这是一个非常简单的 Servlet，我们将其打包上传到 <code>/opt/apps</code>  中，那么容器内肯定就会同步到该文件，此时进行访问：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/docker-data-volume-webapp-8080-hello-world.png\" alt=\"img\" /></p>\n<hr />\n<p>这种方式设置的数据卷称为<font color='red'>自定义数据卷</font>，因为数据卷的目录是由我们自己设置的，Docker 还为我们提供了 **<font color='red'>另外一种设置数据卷的方式</font>**：</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">docker</span> run <span class=\"token parameter variable\">-d</span> <span class=\"token parameter variable\">-p</span> <span class=\"token number\">8080</span>:8080 <span class=\"token parameter variable\">--name</span> tomcat01 <span class=\"token parameter variable\">-v</span> aa:/usr/local/tomcat/webapps tomcat:8.0-jre8</pre></td></tr></table></figure><p>此时的 <code>aa</code>  并不是数据卷的目录，而是<font color='red'>数据卷的别名</font>，Docker 会为我们自动创建一个名为 <code>aa</code>  的数据卷，并且会将容器内 <code>webapps</code>  目录下的所有内容复制到数据卷中，<font color='red'>该数据卷的位置在</font> <code>/var/lib/docker/volumes</code>  目录下：</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token punctuation\">[</span>root@centos-7 volumes<span class=\"token punctuation\">]</span><span class=\"token comment\"># pwd</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>/var/lib/docker/volumes</pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">[</span>root@centos-7 volumes<span class=\"token punctuation\">]</span><span class=\"token comment\"># cd aa/</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token punctuation\">[</span>root@centos-7 aa<span class=\"token punctuation\">]</span><span class=\"token comment\"># ls</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>_data</pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token punctuation\">[</span>root@centos-7 aa<span class=\"token punctuation\">]</span><span class=\"token comment\"># cd _data/</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">[</span>root@centos-7 _data<span class=\"token punctuation\">]</span><span class=\"token comment\"># ls</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>docs  examples  host-manager  manager  ROOT</pre></td></tr></table></figure><p>此时我们只需修改该目录的内容就能能够影响到容器。</p>\n",
            "tags": [
                "docker"
            ]
        },
        {
            "id": "http://example.com/project/12306/12306%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/",
            "url": "http://example.com/project/12306/12306%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/",
            "title": "12306项目学习笔记",
            "date_published": "2024-01-18T12:27:39.117Z",
            "content_html": "<h1 id=\"项目介绍\"><a class=\"anchor\" href=\"#项目介绍\">#</a> 项目介绍</h1>\n<h2 id=\"项目简介\"><a class=\"anchor\" href=\"#项目简介\">#</a> 项目简介</h2>\n<p>提供了两种版本：</p>\n<ul>\n<li><strong>SpringBoot 聚合服务版本</strong>：适合测试和部署，可以直接启动  <code>aggregation-service</code>  聚合服务和网关服务。</li>\n<li><strong>SpringCloud 微服务版本</strong>：适合学习微服务设计，可以分别启动支付、订单、用户、购票和网关服务。</li>\n</ul>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/12306-base-biz-20230801.png\" alt=\"img\" /></p>\n<center>12306基础业务</center>\n<p>在系统设计中，采用最新 JDK17 + SpringBoot3&amp;SpringCloud <strong>微服务架构</strong>，构建高并发、大数据量下仍然能提供高效可靠的 12306 购票服务。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/1676637853202-c2af9e93-fe03-4c01-9fed-20ca07263476.png\" alt=\"img\" /></p>\n<center>常见的微服务架构</center>\n<p>下方的<strong>架构图</strong>全面描述了项目的服务集合、组件库列表和基础设置层等要素，有助于用户快速了解 12306 平台的顶层设计和业务细节，从零到一进行构建。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230802104007774.png\" alt=\"img\" /></p>\n<center>12306项目架构图</center>\n<p>项目中的文档包括三部分，<strong>快速开始</strong>、<strong>核心技术文档</strong>以及<strong>从零到一开发</strong>。可根据自己的兴趣选择深入了解核心技术或从零到一复刻系统。</p>\n<p><img data-src=\"https://images-machen.oss-cn-beijing.aliyuncs.com/12306%E6%96%87%E7%AB%A0%E7%BB%93%E6%9E%84-20230917.png\" alt=\"img\" /></p>\n<center>12306文章结构</center>\n<h2 id=\"技术架构选型\"><a class=\"anchor\" href=\"#技术架构选型\">#</a> 技术架构选型</h2>\n<h2 id=\"接口文档\"><a class=\"anchor\" href=\"#接口文档\">#</a> 接口文档</h2>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9hcGlmb3guY29tL2FwaWRvYy9zaGFyZWQtODZkOWQzYmUtOGExNS00NTNmLTg1YTYtNDQyMDE4MGE5MTVlL2FwaS04NTYyNzc3OA==\">用户登录 - 12306 (apifox.com)</span></p>\n<h2 id=\"学习路线\"><a class=\"anchor\" href=\"#学习路线\">#</a> 学习路线</h2>\n<p>12306 铁路购票系统的学习主要分为三块：</p>\n<ul>\n<li><strong>组件库开发</strong></li>\n<li><strong>业务梳理</strong></li>\n<li><strong>业务系统开发</strong></li>\n</ul>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20240119014418408.png\" alt=\"image-20240119014418408\" /></p>\n<h3 id=\"组件库开发\"><a class=\"anchor\" href=\"#组件库开发\">#</a> 组件库开发</h3>\n<p>组件库的产出源于<font color='red'>对公共功能的封装</font>，避免了在不同项目之间相互复制代码的情况。当然，如果这种复制代码的方式出现问题，那么需要同时对所有项目进行改造，从成本和优雅设计的角度来看并不可取。</p>\n<p>为了统一各个项目可能使用的公共内容，我们在这里规划了常用且通用的功能点，供大家使用，以提高编码效率。如果有一些好的想法，在通用的前提下，可以联系我们将其加入到各自语义的起始包中。</p>\n<p>组件库的开发宗旨是汇总资源，更高效地提供业务敏捷开发的能力，后续的迭代也将遵循这一原则。目前，这只是一个起点，是整体规划的一部分，还有许多可以提升的空间。</p>\n<p>目前<font color='red'>已有组件如下</font>，可能新增加的组件更新不及时，实际以代码库  <code>/frameworks</code>  目录下为准。</p>\n<p><img data-src=\"https://user-images.githubusercontent.com/77398366/229265310-7fa8b406-b621-4334-91d6-911c0b95dce3.png\" alt=\"img\" /></p>\n<h3 id=\"业务梳理\"><a class=\"anchor\" href=\"#业务梳理\">#</a> 业务梳理</h3>\n<p>在 12306 铁路购票系统中，包括会员、购票、订单、支付以及网关服务。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/12306_biz_20230720-1.png\" alt=\"img\" /></p>\n<h3 id=\"系统开发\"><a class=\"anchor\" href=\"#系统开发\">#</a> 系统开发</h3>\n<p>当你对 12306 系统的业务有了初步认识，就可以考虑对这个系统进行从零到一的开发。</p>\n<p>在正式开发框架之前，你需要把一些<strong>前置技术</strong>都有一定的掌握。不然极有可能是稀里糊涂的写，虽然写完了，但是吸收情况达不到最终的理想效果。</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>技术</th>\n<th>名称</th>\n<th>版本</th>\n<th>官网</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>Spring Boot</td>\n<td>基础框架</td>\n<td>3.0.7</td>\n<td><span class=\"exturl\" data-url=\"aHR0cHM6Ly9zcHJpbmcuaW8vcHJvamVjdHMvc3ByaW5nLWJvb3Q=\">https://spring.io/projects/spring-boot(opens new window)</span></td>\n</tr>\n<tr>\n<td>2</td>\n<td>MyBatis-Plus</td>\n<td>持久层框架</td>\n<td>3.5.3.1</td>\n<td><span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYW9taWRvdS5jb20v\">https://baomidou.com(opens new window)</span></td>\n</tr>\n<tr>\n<td>3</td>\n<td>HikariCP</td>\n<td>数据库连接池</td>\n<td>5.0.1</td>\n<td><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2JyZXR0d29vbGRyaWRnZS9IaWthcmlDUA==\">https://github.com/brettwooldridge/HikariCP(opens new window)</span></td>\n</tr>\n<tr>\n<td>4</td>\n<td>Redis</td>\n<td>分布式缓存数据库</td>\n<td>Latest</td>\n<td><span class=\"exturl\" data-url=\"aHR0cHM6Ly9yZWRpcy5pby8=\">https://redis.io(opens new window)</span></td>\n</tr>\n<tr>\n<td>5</td>\n<td>RocketMQ</td>\n<td>消息队列</td>\n<td>2.2.3</td>\n<td><span class=\"exturl\" data-url=\"aHR0cHM6Ly9yb2NrZXRtcS5hcGFjaGUub3JnLw==\">https://rocketmq.apache.org(opens new window)</span></td>\n</tr>\n<tr>\n<td>6</td>\n<td>ShardingSphere</td>\n<td>数据库生态系统</td>\n<td>5.3.2</td>\n<td><span class=\"exturl\" data-url=\"aHR0cHM6Ly9zaGFyZGluZ3NwaGVyZS5hcGFjaGUub3JnLw==\">https://shardingsphere.apache.org(opens new window)</span></td>\n</tr>\n<tr>\n<td>7</td>\n<td>SpringCloud Alibaba</td>\n<td>分布式框架</td>\n<td>2022.0.0.0-RC2</td>\n<td><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2FsaWJhYmEvc3ByaW5nLWNsb3VkLWFsaWJhYmE=\">https://github.com/alibaba/spring-cloud-alibaba(opens new window)</span></td>\n</tr>\n<tr>\n<td>8</td>\n<td>SpringCloud Gateway</td>\n<td>网关框架</td>\n<td>2022.0.3</td>\n<td><span class=\"exturl\" data-url=\"aHR0cHM6Ly9zcHJpbmcuaW8vcHJvamVjdHMvc3ByaW5nLWNsb3VkLWdhdGV3YXk=\">https://spring.io/projects/spring-cloud-gateway(opens new window)</span></td>\n</tr>\n<tr>\n<td>9</td>\n<td>FastJson2</td>\n<td>JSON 序列化工具</td>\n<td>2.0.36</td>\n<td><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2FsaWJhYmEvZmFzdGpzb24y\">https://github.com/alibaba/fastjson2(opens new window)</span></td>\n</tr>\n<tr>\n<td>10</td>\n<td>Canal</td>\n<td>BinLog 订阅组件</td>\n<td>1.1.6</td>\n<td><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2FsaWJhYmEvY2FuYWw=\">https://github.com/alibaba/canal(opens new window)</span></td>\n</tr>\n<tr>\n<td>11</td>\n<td>HuTool</td>\n<td>小而全的工具集项目</td>\n<td>5.8.2</td>\n<td><span class=\"exturl\" data-url=\"aHR0cHM6Ly9odXRvb2wuY24v\">https://hutool.cn(opens new window)</span></td>\n</tr>\n<tr>\n<td>12</td>\n<td>Swagger3</td>\n<td>项目 API 文档框架</td>\n<td>3.x</td>\n<td><span class=\"exturl\" data-url=\"aHR0cDovL3N3YWdnZXIuaW8v\">http://swagger.io(opens new window)</span></td>\n</tr>\n<tr>\n<td>13</td>\n<td>Knife4j</td>\n<td>Swagger 增强框架</td>\n<td>3.x</td>\n<td><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb2MueGlhb21pbmZvLmNvbS8=\">https://doc.xiaominfo.com(opens new window)</span></td>\n</tr>\n<tr>\n<td>14</td>\n<td>Maven</td>\n<td>项目构建管理</td>\n<td>3.9.1</td>\n<td><span class=\"exturl\" data-url=\"aHR0cDovL21hdmVuLmFwYWNoZS5vcmcv\">http://maven.apache.org(opens new window)</span></td>\n</tr>\n<tr>\n<td>15</td>\n<td>Redisson</td>\n<td>Redis Java 客户端</td>\n<td>3.21.3</td>\n<td><span class=\"exturl\" data-url=\"aHR0cHM6Ly9yZWRpc3Nvbi5vcmcv\">https://redisson.org(opens new window)</span></td>\n</tr>\n<tr>\n<td>16</td>\n<td>Sentinel</td>\n<td>流控防护框架</td>\n<td>1.8.6</td>\n<td><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2FsaWJhYmEvU2VudGluZWw=\">https://github.com/alibaba/Sentinel(opens new window)</span></td>\n</tr>\n<tr>\n<td>17</td>\n<td>Hippo4j</td>\n<td>动态线程池框架</td>\n<td>1.5.0</td>\n<td><span class=\"exturl\" data-url=\"aHR0cHM6Ly9oaXBwbzRqLmNuLw==\">https://hippo4j.cn(opens new window)</span></td>\n</tr>\n<tr>\n<td>18</td>\n<td>XXL-Job</td>\n<td>分布式定时任务框架</td>\n<td>2.4.0</td>\n<td><span class=\"exturl\" data-url=\"aHR0cDovL3d3dy54dXh1ZWxpLmNvbS94eGwtam9i\">http://www.xuxueli.com/xxl-job(opens new window)</span></td>\n</tr>\n<tr>\n<td>19</td>\n<td>SkyWalking</td>\n<td>分布式链路追踪框架</td>\n<td>9.5.0</td>\n<td><span class=\"exturl\" data-url=\"aHR0cHM6Ly9za3l3YWxraW5nLmFwYWNoZS5vcmcv\">https://skywalking.apache.org(opens new window)</span></td>\n</tr>\n<tr>\n<td>20</td>\n<td>JetCache</td>\n<td>Java 缓存框架</td>\n<td>2.7.3</td>\n<td><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2FsaWJhYmEvamV0Y2FjaGU=\">https://github.com/alibaba/jetcache(opens new window)</span></td>\n</tr>\n<tr>\n<td>21</td>\n<td>TTL</td>\n<td>增强版 ThreadLocal</td>\n<td>2.14.3</td>\n<td><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2FsaWJhYmEvdHJhbnNtaXR0YWJsZS10aHJlYWQtbG9jYWw=\">https://github.com/alibaba/transmittable-thread-local(opens new window)</span></td>\n</tr>\n</tbody>\n</table>\n<p>另外，我们在手摸手从零到一开发章节中，会有非常详细的系列教程，帮助大家梳理以及开发。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230917193923363.png\" alt=\"img\" /></p>\n<h1 id=\"快速开始\"><a class=\"anchor\" href=\"#快速开始\">#</a> 快速开始</h1>\n<h2 id=\"克隆项目\"><a class=\"anchor\" href=\"#克隆项目\">#</a> 克隆项目</h2>\n<h3 id=\"拉取项目\"><a class=\"anchor\" href=\"#拉取项目\">#</a> 拉取项目</h3>\n<p>打开 Gitee 项目地址：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRlZS5jb20vbmFnZW9mZmVyLzEyMzA2\">https://gitee.com/nageoffer/12306</span> 复制对应的 SSH 或 HTTP 克隆地址。</p>\n<p>12306 现在的代码还在不断更新迭代，每次打开项目都可以选择  <code>Pull</code>  下最新代码。</p>\n<p>打开 IntelliJ  IDEA，菜单栏顶部找到  <code>Git -&gt; Clone</code>  选项，等待克隆及 Maven 初始化即可。</p>\n<p>拉下来后，可在项目根目录执行  <code>mvn clean install</code>  测试是否具备运行环境。</p>\n<p><strong>⚠️</strong> <strong>重要提示。</strong></p>\n<p><font color='red'>建议大家在打开项目时，都执行下  <code>Update Project</code>  流程</font>，因为代码目前还在快速迭代中，避免错过新功能。</p>\n<h3 id=\"服务模块列表\"><a class=\"anchor\" href=\"#服务模块列表\">#</a> 服务模块列表</h3>\n<h4 id=\"springboot-单体版本\"><a class=\"anchor\" href=\"#springboot-单体版本\">#</a> SpringBoot 单体版本</h4>\n<p>如果你想<font color='red'>以小成本启动前后端系统</font>，后端项目仅启动  <code>aggregation-service</code>  和  <code>gateway-service</code>  服务即可。</p>\n<blockquote>\n<p>Q： <code>aggregation-service</code>  服务是做什么的？</p>\n<p>A：为了减少大家本地启动内存压力以及服务器部署压力，将订单、支付、用户以及购票系统进行了聚合，启动网关和  <code>aggregation-service</code>  服务即可享受 12306 购票系统全部功能。</p>\n</blockquote>\n<h4 id=\"springcloud-分布式版本\"><a class=\"anchor\" href=\"#springcloud-分布式版本\">#</a> SpringCloud 分布式版本</h4>\n<p>如果你是想跑<font color='red'>微服务全流程</font>，需依次启动  <code>pay-service</code> 、 <code>order-service</code> 、 <code>ticket-service</code> 、 <code>user-service</code>  以及  <code>gateway-service</code>  等服务。</p>\n<figure class=\"highlight plain\"><figcaption data-lang=\"plain\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>.</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>├── aggregation-service  || -- # 聚合服务</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>├── gateway-service  || -- # 网关服务</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>├── order-service  || -- # 订单服务</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>├── pay-service  || -- # 支付服务</pre></td></tr><tr><td data-num=\"6\"></td><td><pre>├── ticket-service  || -- # 购票服务</pre></td></tr><tr><td data-num=\"7\"></td><td><pre>└── user-service  || -- # 用户服务</pre></td></tr></table></figure><h3 id=\"项目工程的目录结构\"><a class=\"anchor\" href=\"#项目工程的目录结构\">#</a> 项目工程的目录结构</h3>\n<blockquote>\n<p>-&gt;<a href=\"#%E5%B7%A5%E7%A8%8B%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1\"> 工程目录结构设计</a></p>\n</blockquote>\n<h3 id=\"设置-jdk-版本\"><a class=\"anchor\" href=\"#设置-jdk-版本\">#</a> 设置 JDK 版本</h3>\n<p>12306 系统框架底层依赖 SpringBoot3，而这个版本对 JDK 的要求最低是 17。所以，我们需要 **<font color='red'>将项目的 JDK 修改为 17 版本</font>**，避免项目编译或运行报错。</p>\n<h2 id=\"数据库初始化\"><a class=\"anchor\" href=\"#数据库初始化\">#</a> 数据库初始化</h2>\n<blockquote>\n<p>下文中 Linux 路径中出现的符号  <code>~</code>  表示根路径  <code>$&#123;HOME&#125;</code></p>\n</blockquote>\n<h3 id=\"安装-mysql-5736\"><a class=\"anchor\" href=\"#安装-mysql-5736\">#</a> 安装 MySQL 5.7.36</h3>\n<p>Windows、Linux 以及 Mac M1 以下电脑通过以下 Docker 命令下载 MySQL 镜像，并启动 MySQL 容器：</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">docker</span> run <span class=\"token parameter variable\">--name</span> mysql <span class=\"token punctuation\">\\</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token parameter variable\">-p</span> <span class=\"token number\">3306</span>:3306 <span class=\"token punctuation\">\\</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token parameter variable\">-e</span> <span class=\"token assign-left variable\">MYSQL_ROOT_HOST</span><span class=\"token operator\">=</span><span class=\"token string\">'%'</span> <span class=\"token punctuation\">\\</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token parameter variable\">-e</span> <span class=\"token assign-left variable\">MYSQL_ROOT_PASSWORD</span><span class=\"token operator\">=</span>root <span class=\"token punctuation\">\\</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token parameter variable\">-d</span> mysql:5.7.36</pre></td></tr></table></figure><ul>\n<li><code>--name mysql</code> ：指定容器的名称为 mysql。</li>\n<li><code>-p 3306:3306</code> ：将容器的 3306 端口挂载到宿主机的 3306 端口上。</li>\n<li><code>-e MYSQL_ROOT_HOST='%'</code> ：允许 root 用户在任何主机访问。</li>\n<li><code>-e MYSQL_ROOT_PASSWORD=root</code> ：指定 MySQL 的 root 用户的密码为 root。</li>\n<li><code>-d</code> ：以后台的方式运行，后面是  <code>Image:Tag</code> 。</li>\n</ul>\n<p>将 MySQL 容器内的配置文件复制到 Linux 中：</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># 在 Linux 中新建本地目录～/docker/software/mysql/conf。-p 表示没有该目录则自动创建。</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">mkdir</span> <span class=\"token parameter variable\">-p</span> ~/docker/software/mysql/conf</pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token comment\"># 将 MySQL 容器内的配置文件复制到 Linux 本地目录中</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token function\">docker</span> <span class=\"token function\">cp</span> mysql:/etc/mysql/mysql.conf.d/mysqld.cnf ~/docker/software/mysql/conf</pre></td></tr></table></figure><p>在 Linux 中打开  <code>~/docker/software/mysql/conf</code>  mysqld.cnf 文件，增加以下内容：</p>\n<blockquote>\n<p>为了后续 Canal 对接，这里直接开启 BinLog 相关配置</p>\n</blockquote>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># 在 Linux 中打开配置文件</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">vim</span> ~/docker/software/mysql/conf/mysqld.cnf</pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token comment\"># 向配置文件中添加如下内容，注意是在在 [mysqld] 目录中</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>log-bin<span class=\"token operator\">=</span>mysql-bin  <span class=\"token comment\"># 开启 binlog</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>binlog-format<span class=\"token operator\">=</span>ROW  <span class=\"token comment\"># 选择 ROW 模式</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>server-id<span class=\"token operator\">=</span><span class=\"token number\">1</span> <span class=\"token comment\"># 配置 MySQL replaction 需要定义，不要和 canal 的 slaveId 重复</span></pre></td></tr></table></figure><p>删除原 MySQL 容器，通过新配置创建新的容器：</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># 删除运行中的 MySQL 容器</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">docker</span> <span class=\"token function\">rm</span> <span class=\"token parameter variable\">-f</span> mysql</pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token comment\"># 运行 Docker 容器命令</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token function\">docker</span> run <span class=\"token parameter variable\">--name</span> mysql <span class=\"token punctuation\">\\</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token parameter variable\">-p</span> <span class=\"token number\">3306</span>:3306 <span class=\"token punctuation\">\\</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token parameter variable\">-v</span> /etc/localtime:/etc/localtime <span class=\"token punctuation\">\\</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token parameter variable\">-v</span> ~/docker/software/mysql/conf:/etc/mysql/mysql.conf.d <span class=\"token punctuation\">\\</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token parameter variable\">-v</span> ~/docker/software/mysql/log:/var/log/mysql <span class=\"token punctuation\">\\</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token parameter variable\">-v</span> ~/docker/software/mysql/data:/var/lib/mysql <span class=\"token punctuation\">\\</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token parameter variable\">-e</span> <span class=\"token assign-left variable\">MYSQL_ROOT_PASSWORD</span><span class=\"token operator\">=</span>root <span class=\"token punctuation\">\\</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token parameter variable\">-d</span> mysql:5.7.36</pre></td></tr></table></figure><ul>\n<li><code>/etc/localtime</code> ：时间同步</li>\n<li><code>/docker/software/mysql/conf</code> ：同步 MySQL 配置文件，上面配置的内容就会覆盖容器中的配置文件</li>\n<li><code>/docker/software/mysql/log</code> ：同步 MySQL 日志目录</li>\n<li><code>/docker/software/mysql/data</code> ：同步 MySQL 的一些文件内容（对数据进行备份）</li>\n<li><code>MYSQL_ROOT_PASSWORD=root</code> ：默认 root 的密码是 root</li>\n</ul>\n<p>进入到 MySQL 的命令行模式来给 root 账号授权所有 ip 能够访问。</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># 使用 MySQL 容器中的命令行</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">docker</span> <span class=\"token builtin class-name\">exec</span> <span class=\"token parameter variable\">-it</span> mysql /bin/bash</pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token comment\"># 使用 MySQL 命令打开客户端：</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>mysql <span class=\"token parameter variable\">-uroot</span> <span class=\"token parameter variable\">-proot</span> --default-character-set<span class=\"token operator\">=</span>utf8</pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token comment\"># 接着创建一个账户，该账号所有 IP 都能够访问</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>grant all privileges on *.* to <span class=\"token string\">'root'</span> @<span class=\"token string\">'%'</span> identified by <span class=\"token string\">'root'</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token comment\"># 刷新生效</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>FLUSH PRIVILEGES<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>查看 binlog 日志是否已经开启。</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># 查看 binlog 日志是否开启</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>show variables like <span class=\"token string\">'log_%'</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token comment\"># 查看主结点当前状态</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>show master status<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>如果 log_bin 为 ON，即为开启状态。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/1670219063740-9658993e-ac4f-42dc-9634-d716a07dc08c.png\" alt=\"img\" /></p>\n<p>为了避免以后每次启动 Linux 服务器都需要手动运行 MySQL 等容器，可以将其修改为 **<font color='red'>开机时自动运行</font>**：</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">sudo</span> <span class=\"token function\">docker</span> update mysql <span class=\"token parameter variable\">--restart</span><span class=\"token operator\">=</span>always</pre></td></tr></table></figure><p>重启 Linux 后，通过  <code>sudo docker ps</code>  命令验证 MySQL 已经自动运行。</p>\n<h3 id=\"通过-navicat-idea-建立数据库连接\"><a class=\"anchor\" href=\"#通过-navicat-idea-建立数据库连接\">#</a> 通过 Navicat / IDEA 建立数据库连接</h3>\n<p>自定义连接名，IP 填写 Linux 的 IP 地址，端口号默认为 3306，用户名和密码默认为 root。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20240124161737463.png\" alt=\"image-20240124161737463\" /></p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20240124162008565.png\" alt=\"image-20240124162008565\" /></p>\n<h3 id=\"建库建表-初始化数据\"><a class=\"anchor\" href=\"#建库建表-初始化数据\">#</a> 建库建表 &amp; 初始化数据</h3>\n<p>两种启动模式分别对应不同的数据库表模式：</p>\n<ul>\n<li>SpringBoot 模式：仅分表，不分库。数据库名称是统一的  <code>12306</code> 。</li>\n<li><strong><font color='red'>SpringCloud 模式：分库又分表</font></strong>。数据库名称是  <code>12306_业务_分库数</code> 。</li>\n</ul>\n<p>两种模式的分表模式一致。所以说，启动 SpringBoot 模式时，导入 12306 数据库。<font color='red'>启动 SpringCloud 时，需要创建与 12306 相关的数据库及表结构</font>。</p>\n<p>这里启动 SpringCloud 模式，执行数据库建表语句和初始化数据 SQL 文件，文件夹地址： <code>/resources/&#123;data or db&#125;/12306-springcloud-xx.sql</code> ，如果后续遇到代码中关于数据库相关的报错，重新执行下对应库的 SQL 文件。</p>\n<p>MySQL 数据库中创建多个 12306 业务相关 DB，以下<strong>建库 SQL 可以在 IDEA 插件 “数据库” 中通过新建 “查询控制台” 执行</strong>：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20240124162134366.png\" alt=\"image-20240124162134366\" /></p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20240124162215075.png\" alt=\"image-20240124162215075\" /></p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">DATABASE</span> <span class=\"token comment\">/*!32312 IF NOT EXISTS*/</span> <span class=\"token identifier\"><span class=\"token punctuation\">`</span>12306_ticket<span class=\"token punctuation\">`</span></span> <span class=\"token comment\">/*!40100 DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci */</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">DATABASE</span> <span class=\"token comment\">/*!32312 IF NOT EXISTS*/</span> <span class=\"token identifier\"><span class=\"token punctuation\">`</span>12306_order_0<span class=\"token punctuation\">`</span></span> <span class=\"token comment\">/*!40100 DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci */</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">DATABASE</span> <span class=\"token comment\">/*!32312 IF NOT EXISTS*/</span> <span class=\"token identifier\"><span class=\"token punctuation\">`</span>12306_order_1<span class=\"token punctuation\">`</span></span> <span class=\"token comment\">/*!40100 DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci */</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">DATABASE</span> <span class=\"token comment\">/*!32312 IF NOT EXISTS*/</span> <span class=\"token identifier\"><span class=\"token punctuation\">`</span>12306_pay_0<span class=\"token punctuation\">`</span></span> <span class=\"token comment\">/*!40100 DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci */</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">DATABASE</span> <span class=\"token comment\">/*!32312 IF NOT EXISTS*/</span> <span class=\"token identifier\"><span class=\"token punctuation\">`</span>12306_pay_1<span class=\"token punctuation\">`</span></span> <span class=\"token comment\">/*!40100 DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci */</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">DATABASE</span> <span class=\"token comment\">/*!32312 IF NOT EXISTS*/</span> <span class=\"token identifier\"><span class=\"token punctuation\">`</span>12306_user_0<span class=\"token punctuation\">`</span></span> <span class=\"token comment\">/*!40100 DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci */</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">DATABASE</span> <span class=\"token comment\">/*!32312 IF NOT EXISTS*/</span> <span class=\"token identifier\"><span class=\"token punctuation\">`</span>12306_user_1<span class=\"token punctuation\">`</span></span> <span class=\"token comment\">/*!40100 DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci */</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>1）进入  <code>12306_ticket</code>  数据库 **<font color='red'>依次导入</font>** 项目中下述建表 SQL 语句。</p>\n<blockquote>\n<p>最好在 Navicat 中执行以下 SQL 文件，因为在 IDEA 中可能会遇到最大堆空间不足的问题。</p>\n</blockquote>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>resources/db/12306-springcloud-ticket.sql</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>resources/data/12306-springcloud-ticket.sql</pre></td></tr></table></figure><p>2）进入  <code>12306_user_0</code>  数据库 **<font color='red'>依次导入</font>** 项目中下述建表 SQL 语句，该 SQL 文件包含了  <code>12306_user_0</code>  和  <code>12306_user_1</code>  两个数据库的数据。</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>resources/db/12306-springcloud-user.sql</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>resources/data/12306-springcloud-user.sql</pre></td></tr></table></figure><p>3）进入  <code>12306_pay_0</code>  数据库导入项目中下述建表 SQL 语句，该 SQL 文件包含了  <code>12306_pay_0</code>  和  <code>12306_pay_1</code>  两个数据库的数据。</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>resources/db/12306-springcloud-pay.sql</pre></td></tr></table></figure><p>4）进入  <code>12306_order_0</code>  数据库导入项目中下述建表 SQL 语句，该 SQL 文件包含了  <code>12306_order_0</code>  和  <code>12306_order_1</code>  两个数据库的数据。</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>resources/db/12306-springcloud-order.sql</pre></td></tr></table></figure><h3 id=\"修改-mysql-相关的项目配置\"><a class=\"anchor\" href=\"#修改-mysql-相关的项目配置\">#</a> 修改 MySQL 相关的项目配置</h3>\n<p><strong><font color='red'>在 Linux 服务器中创建好 MySQL 后，由于项目中默认的配置信息是连接到本地的 MySQL 上，因此默认的 IP 全是 127.0.0.1，需要修改成自己的 Linux 服务器 IP，即 192.168.0.2</font></strong>。需要修改项目的数据库配置信息，缺点是在之后 update project 时可能冲突：</p>\n<blockquote>\n<p>主要是确认三个配置参数 <code>jdbcUrl</code> 、 <code>username</code> 、 <code>password</code> ，主要是 <strong>IP 地址、端口号、数据库名称、用户名、密码</strong>，如果不一致请记得修改。</p>\n<p>特别地，如果 <strong><font color='red'>MySQL/Redis/Nacos/RocketMQ</font></strong> 是安装在 Linux 中，那么需要将  <code>127.0.0.1</code>  修改为 Linux 的 IP 地址，例如我的是  <code>192.168.0.2</code>  ，后续会说明。</p>\n</blockquote>\n<p>以 SpringBoot 单体服务举例，修改  <code>aggregation-service</code>  目录中的  <code>shardingsphere-config-dev.yaml</code>  即可：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/1691894880930-7aee6932-b5a5-458f-84bb-dacf70fe4b78.png\" alt=\"image.png\" /></p>\n<p>以 SpringCloud 微服务举例：</p>\n<ul>\n<li>\n<p><code>aggregation-service</code> ：由于我采用的 SpringCloud 微服务模式不涉及该 service，因此不用修改相关配置文件。</p>\n</li>\n<li>\n<p><code>gateway-service</code> ：该 service 不涉及 MySQL 配置，不用修改。</p>\n</li>\n<li>\n<p><code>order-service</code> 、 <code>pay-service</code> 、 <code>user-service</code> ：修改各自目录下的  <code>shardingsphere-config.yaml</code>  文件，<font color='red'>主要是 jdbcUrl 参数，将其中的 127.0.0.1 修改成 Linux 服务器 IP，即 192.168.0.2</font>：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20240124235121774.png\" alt=\"image-20240124235121774\" /></p>\n</li>\n<li>\n<p><code>ticket-service</code> ：修改目录下的  <code>application.yaml</code>  文件，<font color='red'>将 spring.datasource.url 中的 127.0.0.1 修改为 192.168.0.2</font>：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20240124235317255.png\" alt=\"image-20240124235317255\" /></p>\n</li>\n</ul>\n<h2 id=\"安装后端环境中间件\"><a class=\"anchor\" href=\"#安装后端环境中间件\">#</a> 安装后端环境（中间件）</h2>\n<h3 id=\"云环境安装\"><a class=\"anchor\" href=\"#云环境安装\">#</a> 云环境安装</h3>\n<h3 id=\"linux-服务器安装\"><a class=\"anchor\" href=\"#linux-服务器安装\">#</a> Linux 服务器安装</h3>\n<blockquote>\n<p>啊啊啊啊啊啊啊 Linux 虚拟机的空间不够，发出尖锐的爆鸣声！！！</p>\n</blockquote>\n<h4 id=\"redis-latest\"><a class=\"anchor\" href=\"#redis-latest\">#</a> Redis Latest</h4>\n<p>通过简易版方式安装，主打的就是有问题铲了重装。</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">docker</span> run <span class=\"token parameter variable\">-p</span> <span class=\"token number\">6379</span>:6379 <span class=\"token parameter variable\">--name</span> redis  <span class=\"token parameter variable\">-d</span> redis redis-server <span class=\"token parameter variable\">--requirepass</span> <span class=\"token string\">\"123456\"</span></pre></td></tr></table></figure><p>同样地，也将 Redis 修改为 **<font color='red'>开机时自动运行</font>**：</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">sudo</span> <span class=\"token function\">docker</span> update redis <span class=\"token parameter variable\">--restart</span><span class=\"token operator\">=</span>always</pre></td></tr></table></figure><h4 id=\"rocketmq-451\"><a class=\"anchor\" href=\"#rocketmq-451\">#</a> RocketMQ 4.5.1</h4>\n<h5 id=\"安装-nameserver\"><a class=\"anchor\" href=\"#安装-nameserver\">#</a> 安装 NameServer</h5>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">docker</span> run <span class=\"token parameter variable\">-d</span> <span class=\"token parameter variable\">-p</span> <span class=\"token number\">9876</span>:9876 <span class=\"token parameter variable\">--name</span> rmqnamesrv foxiswho/rocketmq:server-4.5.1</pre></td></tr></table></figure><h5 id=\"安装-brocker\"><a class=\"anchor\" href=\"#安装-brocker\">#</a> 安装 Brocker</h5>\n<p>1）新建配置目录</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">mkdir</span> <span class=\"token parameter variable\">-p</span> ~/docker/software/rocketmq/conf</pre></td></tr></table></figure><p>2）新建配置文件 broker.conf</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>brokerClusterName <span class=\"token operator\">=</span> DefaultCluster</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>brokerName <span class=\"token operator\">=</span> broker-a</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>brokerId <span class=\"token operator\">=</span> <span class=\"token number\">0</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>deleteWhen <span class=\"token operator\">=</span> 04</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>fileReservedTime <span class=\"token operator\">=</span> <span class=\"token number\">48</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>brokerRole <span class=\"token operator\">=</span> ASYNC_MASTER</pre></td></tr><tr><td data-num=\"7\"></td><td><pre>flushDiskType <span class=\"token operator\">=</span> ASYNC_FLUSH</pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token comment\"># 此处为本地 ip, 如果部署服务器，需要填写服务器外网 ip, 例如 192.168.0.2</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>brokerIP1 <span class=\"token operator\">=</span> xx.xx.xx.xx</pre></td></tr></table></figure><p>3）创建容器</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">docker</span> run <span class=\"token parameter variable\">-d</span> <span class=\"token punctuation\">\\</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token parameter variable\">-p</span> <span class=\"token number\">10911</span>:10911 <span class=\"token punctuation\">\\</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token parameter variable\">-p</span> <span class=\"token number\">10909</span>:10909 <span class=\"token punctuation\">\\</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token parameter variable\">--name</span> rmqbroker <span class=\"token punctuation\">\\</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token parameter variable\">--link</span> rmqnamesrv:namesrv <span class=\"token punctuation\">\\</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token parameter variable\">-v</span> ~/docker/software/rocketmq/conf/broker.conf:/etc/rocketmq/broker.conf <span class=\"token punctuation\">\\</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token parameter variable\">-e</span> <span class=\"token string\">\"NAMESRV_ADDR=namesrv:9876\"</span> <span class=\"token punctuation\">\\</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token parameter variable\">-e</span> <span class=\"token string\">\"JAVA_OPTS=-Duser.home=/opt\"</span> <span class=\"token punctuation\">\\</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token parameter variable\">-e</span> <span class=\"token string\">\"JAVA_OPT_EXT=-server -Xms512m -Xmx512m\"</span> <span class=\"token punctuation\">\\</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>foxiswho/rocketmq:broker-4.5.1</pre></td></tr></table></figure><h5 id=\"安装-rocketmq-控制台\"><a class=\"anchor\" href=\"#安装-rocketmq-控制台\">#</a> 安装 rocketmq 控制台</h5>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">docker</span> pull apacherocketmq/rocketmq-dashboard</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">docker</span> run <span class=\"token parameter variable\">-d</span> <span class=\"token punctuation\">\\</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token parameter variable\">--link</span> rmqnamesrv:namesrv <span class=\"token punctuation\">\\</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token parameter variable\">-e</span> <span class=\"token string\">\"JAVA_OPTS=-Drocketmq.config.namesrvAddr=namesrv:9876 -Drocketmq.config.isVIPChannel=false\"</span> <span class=\"token punctuation\">\\</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token parameter variable\">--name</span> rmqconsole <span class=\"token punctuation\">\\</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token parameter variable\">-p</span> <span class=\"token number\">8088</span>:8080 <span class=\"token punctuation\">\\</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token parameter variable\">-t</span> apacherocketmq/rocketmq-dashboard</pre></td></tr></table></figure><p>运行成功，稍等几秒启动时间，浏览器输入  <code>localhost:8088</code>  查看。</p>\n<p>同样地，也将 NameServer、Brocker、rocketmq 控制台 修改为 **<font color='red'>开机时自动运行</font>**：</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">sudo</span> <span class=\"token function\">docker</span> update rmqnamesrv <span class=\"token parameter variable\">--restart</span><span class=\"token operator\">=</span>always</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">sudo</span> <span class=\"token function\">docker</span> update rmqbroker <span class=\"token parameter variable\">--restart</span><span class=\"token operator\">=</span>always</pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token function\">sudo</span> <span class=\"token function\">docker</span> update rmqconsole <span class=\"token parameter variable\">--restart</span><span class=\"token operator\">=</span>always</pre></td></tr></table></figure><h4 id=\"nacos-212\"><a class=\"anchor\" href=\"#nacos-212\">#</a> Nacos 2.1.2</h4>\n<p>通过简易版方式安装，主打的就是有问题铲了重装。</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">docker</span> run <span class=\"token punctuation\">\\</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token parameter variable\">-d</span> <span class=\"token parameter variable\">-p</span> <span class=\"token number\">8848</span>:8848 <span class=\"token punctuation\">\\</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token parameter variable\">-p</span> <span class=\"token number\">9848</span>:9848 <span class=\"token punctuation\">\\</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token parameter variable\">--name</span> nacos2 <span class=\"token punctuation\">\\</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token parameter variable\">-e</span> <span class=\"token assign-left variable\">MODE</span><span class=\"token operator\">=</span>standalone <span class=\"token punctuation\">\\</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token parameter variable\">-e</span> <span class=\"token assign-left variable\">TIME_ZONE</span><span class=\"token operator\">=</span><span class=\"token string\">'Asia/Shanghai'</span> <span class=\"token punctuation\">\\</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>nacos/nacos-server:v2.1.2</pre></td></tr></table></figure><p>运行成功，稍等几秒启动时间，浏览器输入  <code>http://localhost:8848/nacos/index.html</code>  查看控制台，用户名和密码均为 nacos。</p>\n<p>同样地，也将 Nacos2 修改为 **<font color='red'>开机时自动运行</font>**：</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">sudo</span> <span class=\"token function\">docker</span> update nacos2 <span class=\"token parameter variable\">--restart</span><span class=\"token operator\">=</span>always</pre></td></tr></table></figure><h4 id=\"修改中间件相关的项目配置\"><a class=\"anchor\" href=\"#修改中间件相关的项目配置\">#</a> 修改中间件相关的项目配置</h4>\n<p>如果 <strong><font color='red'>Redis/Nacos/RocketMQ</font></strong> 是安装在 Linux 中，那么需要修改项目中的配置信息。<strong><font color='red'>通过添加 VM options（JVM 参数）修改各 service 的配置信息，好处是不需要修改项目代码，不会冲突</font></strong>。</p>\n<ul>\n<li>\n<p>VM options 添加方法：</p>\n<ul>\n<li>规则 1：-D 开头 + 参数名 = 参数值</li>\n<li>规则 2：= 两侧没有空格</li>\n<li>规则 3：不同参数之间空格分隔</li>\n</ul>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>// 如下所示我们增加两个参数 Env 和 Name</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token parameter variable\">-DEnv</span><span class=\"token operator\">=</span>prod <span class=\"token parameter variable\">-DName</span><span class=\"token operator\">=</span>zhangsan</pre></td></tr></table></figure><p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/42bafc4558f74e6b83e543042cecca90.png\" alt=\"在这里插入图片描述\" /></p>\n</li>\n<li>\n<p>VM options 获取方法：</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">// System.getProperty (\"参数名\")</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span><span class=\"token function\">getProperty</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Env\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span><span class=\"token function\">getProperty</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Name\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure></li>\n</ul>\n<p><strong><font color='red'>由此得知，VM options 可以任意设置，即使是无用的参数也没有关系！</font></strong></p>\n<p>首先，参考以下 VM options 示例模板，根据实际情况给出各个 service 的具体 VM 参数：</p>\n<pre><code class=\"language-Shell\">-Dspring.data.redis.password=Sm9sVXBOYJjI030b5tz0trjpzvZzRhtZmEbv0uOImcD1wEDOPfeaqNU4PxHob/Wp\n-Dspring.data.redis.port=19389\n-Dunique-name=-自定义名称，可以切换为自己的名称\n-Dframework.cache.redis.prefix=自定义名称，可以切换为自己的名称:\n-Dspring.data.redis.host=Redis域名\n-Drocketmq.name-server=RocketMQ域名\n-Dspring.cloud.nacos.discovery.server-addr=Nacos域名\n</code></pre>\n<ul>\n<li>\n<p><code>aggregation-service</code> ：SpringCloud 微服务模式并不使用该 service，因此不用修改。</p>\n</li>\n<li>\n<p><code>gateway-service</code> ：</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>-Dunique-name<span class=\"token operator\">=</span>-fantedong</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>-Dspring.cloud.nacos.discovery.server-addr<span class=\"token operator\">=</span><span class=\"token number\">192.168</span>.0.2:8848</pre></td></tr></table></figure></li>\n<li>\n<p><code>order-service</code> 、 <code>pay-service</code> 、 <code>ticket-service</code> ：对我而言，Redis 在安装时设定的 password 正好是项目中配置的原始密码 123456，port 也正好是 6379，因此这两个参数不需要修改。设置自定义名称 unique-name 为 fantedong 。然后因为 Redis 是在自己的 Linux 服务器中的，所以不需要设置 framework.cache.redis.prefix 。<strong><font color='red'>由于 Redis/RocketMQ/Nacos 都是安装在 Linux 服务器中，因此需要修改填写服务器的 IP 地址，即 192.168.0.2 </font></strong>。</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>-Dunique-name<span class=\"token operator\">=</span>-fantedong</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token parameter variable\">-Dspring.data.redis.host</span><span class=\"token operator\">=</span><span class=\"token number\">192.168</span>.0.2</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>-Drocketmq.name-server<span class=\"token operator\">=</span><span class=\"token number\">192.168</span>.0.2:9876</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>-Dspring.cloud.nacos.discovery.server-addr<span class=\"token operator\">=</span><span class=\"token number\">192.168</span>.0.2:8848</pre></td></tr></table></figure></li>\n<li>\n<p><code>user-service</code> ：没有用到 RocketMQ 。</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>-Dunique-name<span class=\"token operator\">=</span>-fantedong</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token parameter variable\">-Dspring.data.redis.host</span><span class=\"token operator\">=</span><span class=\"token number\">192.168</span>.0.2</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>-Dspring.cloud.nacos.discovery.server-addr<span class=\"token operator\">=</span><span class=\"token number\">192.168</span>.0.2:8848</pre></td></tr></table></figure></li>\n</ul>\n<p>然后，因为 VM options 可以任意设置，图个方便省事，这里为  <code>gateway-service</code> 、 <code>order-service</code> 、 <code>pay-service</code> 、 <code>ticket-service</code> 、 <code>user-service</code>  均添加以下 VM options：</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>-Dunique-name<span class=\"token operator\">=</span>-fantedong</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token parameter variable\">-Dspring.data.redis.host</span><span class=\"token operator\">=</span><span class=\"token number\">192.168</span>.0.2</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>-Drocketmq.name-server<span class=\"token operator\">=</span><span class=\"token number\">192.168</span>.0.2:9876</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>-Dspring.cloud.nacos.discovery.server-addr<span class=\"token operator\">=</span><span class=\"token number\">192.168</span>.0.2:8848</pre></td></tr></table></figure><h2 id=\"启动后端\"><a class=\"anchor\" href=\"#启动后端\">#</a> 启动后端</h2>\n<h3 id=\"将-gateway-service-配置为分布式方式启动\"><a class=\"anchor\" href=\"#将-gateway-service-配置为分布式方式启动\">#</a> 将 gateway-service 配置为分布式方式启动</h3>\n<p><code>gateway-service</code>  配置中默认是 SpringBoot 单体模式，如果是以分布式方式启动，需要修改  <code>application.yaml</code>  配置文件中的属性。</p>\n<p>SpringBoot 单体模式：</p>\n<figure class=\"highlight yaml\"><figcaption data-lang=\"YAML\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token key atrule\">server</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>  <span class=\"token key atrule\">port</span><span class=\"token punctuation\">:</span> <span class=\"token number\">9000</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token key atrule\">spring</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>  <span class=\"token key atrule\">application</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> index12306<span class=\"token punctuation\">-</span>gateway$<span class=\"token punctuation\">&#123;</span>unique<span class=\"token punctuation\">-</span>name<span class=\"token punctuation\">:</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">-</span>service</pre></td></tr><tr><td data-num=\"6\"></td><td><pre>  <span class=\"token key atrule\">profiles</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token key atrule\">active</span><span class=\"token punctuation\">:</span> aggregation</pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token comment\"># active: dev</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>  <span class=\"token key atrule\">cloud</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token key atrule\">nacos</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>      <span class=\"token key atrule\">discovery</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>        <span class=\"token key atrule\">server-addr</span><span class=\"token punctuation\">:</span> 127.0.0.1<span class=\"token punctuation\">:</span><span class=\"token number\">8848</span></pre></td></tr></table></figure><p>SpringCloud 分布式模式：</p>\n<figure class=\"highlight yaml\"><figcaption data-lang=\"YAML\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token key atrule\">server</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>  <span class=\"token key atrule\">port</span><span class=\"token punctuation\">:</span> <span class=\"token number\">9000</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token key atrule\">spring</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>  <span class=\"token key atrule\">application</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> index12306<span class=\"token punctuation\">-</span>gateway$<span class=\"token punctuation\">&#123;</span>unique<span class=\"token punctuation\">-</span>name<span class=\"token punctuation\">:</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">-</span>service</pre></td></tr><tr><td data-num=\"6\"></td><td><pre>  <span class=\"token key atrule\">profiles</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token comment\"># active: aggregation</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token key atrule\">active</span><span class=\"token punctuation\">:</span> dev</pre></td></tr><tr><td data-num=\"9\"></td><td><pre>  <span class=\"token key atrule\">cloud</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token key atrule\">nacos</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>      <span class=\"token key atrule\">discovery</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>        <span class=\"token key atrule\">server-addr</span><span class=\"token punctuation\">:</span> 127.0.0.1<span class=\"token punctuation\">:</span><span class=\"token number\">8848</span></pre></td></tr></table></figure><p>可以看到，我们将  <code>spring.profiles.active</code>  从 aggregation 修改为了 dev。</p>\n<p>aggregation 代表着聚合模式也就是 SpringBoot 单体模式，dev 是分布式模式，分别对应两个配置文件。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/1691039852586-c1cadfec-3770-4eb0-89b1-7625d640c559.png\" alt=\"img\" /></p>\n<p>通过 Spring 机制，加载不同的配置文件，起到网关调用不同模式服务的作用。</p>\n<p>星球小伙伴修改网关配置后，问题得到解决。</p>\n<p>实际上，<strong><font color='red'>还是建议通过添加 VM options 的方式更改此配置</font></strong>，只需在<a href=\"#%E4%BF%AE%E6%94%B9%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%9B%B8%E5%85%B3%E7%9A%84%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE\">修改中间件相关的项目配置</a>中最后确定的 VM options 基础上添加一行  <code>-Dspring.profiles.active=dev</code>  即可：</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>-Dunique-name<span class=\"token operator\">=</span>-fantedong</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token parameter variable\">-Dspring.data.redis.host</span><span class=\"token operator\">=</span><span class=\"token number\">192.168</span>.0.2</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>-Drocketmq.name-server<span class=\"token operator\">=</span><span class=\"token number\">192.168</span>.0.2:9876</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>-Dspring.cloud.nacos.discovery.server-addr<span class=\"token operator\">=</span><span class=\"token number\">192.168</span>.0.2:8848</pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token parameter variable\">-Dspring.profiles.active</span><span class=\"token operator\">=</span>dev</pre></td></tr></table></figure><p>仅修改 GatewayServiceApplication 的运行配置即可。</p>\n<h3 id=\"启动后端服务\"><a class=\"anchor\" href=\"#启动后端服务\">#</a> 启动后端服务</h3>\n<p>如果你想<font color='red'>以小成本启动前后端系统（SpringBoot）</font>，后端项目仅启动  <code>aggregation-service</code>  和  <code>gateway-service</code>  服务即可。</p>\n<blockquote>\n<p>Q： <code>aggregation-service</code>  服务是做什么的？</p>\n<p>A：为了减少大家本地启动内存压力以及服务器部署压力，将订单、支付、用户以及购票系统进行了聚合，启动网关和  <code>aggregation-service</code>  服务即可享受 12306 购票系统全部功能。</p>\n</blockquote>\n<p>如果你是想跑<font color='red'>微服务全流程（SpringCloud）</font>，需依次启动  <code>pay-service</code> 、 <code>order-service</code> 、 <code>ticket-service</code> 、 <code>user-service</code>  以及  <code>gateway-service</code>  等服务。</p>\n<figure class=\"highlight plain\"><figcaption data-lang=\"plain\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>.</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>├── aggregation-service  || -- # 聚合服务</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>├── gateway-service  || -- # 网关服务</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>├── order-service  || -- # 订单服务</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>├── pay-service  || -- # 支付服务</pre></td></tr><tr><td data-num=\"6\"></td><td><pre>├── ticket-service  || -- # 购票服务</pre></td></tr><tr><td data-num=\"7\"></td><td><pre>└── user-service  || -- # 用户服务</pre></td></tr></table></figure><h2 id=\"安装前端环境nodejs\"><a class=\"anchor\" href=\"#安装前端环境nodejs\">#</a> 安装前端环境（Nodejs）</h2>\n<blockquote>\n<p>参考：<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cueXVxdWUuY29tL21hZ2VzdGFjay8xMjMwNi9vZ3BieXAzb290ZzlhMnNr\">快速启动之前端项目 (yuque.com)</span>，密码 gv4g</p>\n<p>因为我本地已经安装，且版本在 16.20.0 以上，故略过该内容。</p>\n</blockquote>\n<h2 id=\"启动前端\"><a class=\"anchor\" href=\"#启动前端\">#</a> 启动前端</h2>\n<p>Windows 用户通过 cmd 工具进入  <code>12306/console-vue</code>  目录执行，依次执行下述命令：</p>\n<p>1）安装 yarn</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">npm</span> <span class=\"token function\">install</span> <span class=\"token parameter variable\">-g</span> <span class=\"token function\">yarn</span></pre></td></tr></table></figure><p>2）下载依赖</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">yarn</span> <span class=\"token function\">install</span></pre></td></tr></table></figure><p>3）前端调用本地</p>\n<p>检查 vue.config.js 配置文件中 target 是否为： <code>http://127.0.0.1:9000</code> ，如果不是需要修改。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/1690859640845-75424af8-057c-4833-a03b-ffd32fc4bf00.png\" alt=\"img\" /></p>\n<p>4）启动项目</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">yarn</span> serve</pre></td></tr></table></figure><p>启动成功后，会出现以下信息，访问任意一个都可以登录 12306 Web 控制台。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/1690105184349-91b68fe7-7978-4fa4-85fe-4dfbdb9e25c0.png\" alt=\"img\" /></p>\n<p>首页查询车次信息是不涉及登录的，但是如果想体验购票，需要用户登录操作。</p>\n<p>默认用户名和密码：admin/admin123456</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/1690615839081-d8103138-9e4d-4424-8976-2c36490835d3.png\" alt=\"img\" /></p>\n<h2 id=\"问题调试\"><a class=\"anchor\" href=\"#问题调试\">#</a> 问题调试</h2>\n<h3 id=\"pay-service-目录下的-payserviceapplicationjava-启动类无法识别\"><a class=\"anchor\" href=\"#pay-service-目录下的-payserviceapplicationjava-启动类无法识别\">#</a> pay-service 目录下的 PayServiceApplication.java 启动类无法识别</h3>\n<p>解决方法是右键该目录下的 java 文件夹，标记为  <code>sources root</code>  目录，然后右键 pay-service 目录，选择  <code>maven-重新加载项目</code> ，解决。</p>\n<h3 id=\"windows-系统启动支付服务时报错-command-line-is-too-long-shorten-the-command-line-and-rerun\"><a class=\"anchor\" href=\"#windows-系统启动支付服务时报错-command-line-is-too-long-shorten-the-command-line-and-rerun\">#</a> Windows 系统启动支付服务时报错 Command line is too long Shorten the command line and rerun</h3>\n<p>该问题仅 Windows 系统电脑会出现。</p>\n<p>问题现状：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/1691204207160-af495b10-eb96-4ea4-976f-f2bbc4575324.png\" alt=\"img\" /></p>\n<p>解决方法：</p>\n<p>1）打开服务控制器</p>\n<p>2）选择支付服务 PayServiceApplication，点击 Modify options，点击 shorten command line</p>\n<p>3）选择 JAR manifest</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20240125031400152.png\" alt=\"image-20240125031400152\" /></p>\n<h3 id=\"linux-服务器的磁盘空间不足无法通过-docker-运行-mysql\"><a class=\"anchor\" href=\"#linux-服务器的磁盘空间不足无法通过-docker-运行-mysql\">#</a> Linux 服务器的磁盘空间不足，无法通过 docker 运行 MySQL</h3>\n<p>目前想法：转到 Windows 本地运行 MySQL 。</p>\n<h1 id=\"用户体系建设概要\"><a class=\"anchor\" href=\"#用户体系建设概要\">#</a> 用户体系建设概要</h1>\n<h2 id=\"业务分析\"><a class=\"anchor\" href=\"#业务分析\">#</a> 业务分析</h2>\n<p>12306 铁路购票系统中，存在两类用户，分别是：<strong>会员</strong>（即当前账户登录用户）以及<strong>乘车人</strong>。</p>\n<h3 id=\"会员用户\"><a class=\"anchor\" href=\"#会员用户\">#</a> 会员用户</h3>\n<p>会员支持在系统中自行<font color='red'>注册</font>，需要注册者提供用户名、密码、证件类型、证件号、真实姓名、手机号、邮箱以及旅客类型。</p>\n<p>其中，用户名和证件号码全局唯一，不允许注册者重复使用。</p>\n<p>会员<font color='red'>登录</font>系统时，支持用户名 / 邮箱 / 手机号码三种登录方式，搭配密码完成系统用户登录行为。</p>\n<h3 id=\"乘车人\"><a class=\"anchor\" href=\"#乘车人\">#</a> 乘车人</h3>\n<p>一个注册会员可以添加多个乘车人。<font color='red'>添加乘车人</font>时需要填写真实姓名、身份证、手机号等，新增乘车人需要通过实名认证审核，审核通过方可成功。</p>\n<p>会员选择交通工具（火车、高铁等）进行买票时，可以选择多个乘车人进行<font color='red'>购票</font>。</p>\n<p>会员可以通过已支付订单查看所有订单信息，乘车人也可通过订单标签页中本人车票<font color='red'>查看自己或其他会员购买为自己购买的订单信息</font>。</p>\n<h2 id=\"业务难点\"><a class=\"anchor\" href=\"#业务难点\">#</a> 业务难点</h2>\n<p>由于篇幅所限，本文无法详尽解答以下业务难点，但这些问题都会在后续的手摸手教学系列中逐一阐述，并给出较优解决方案。</p>\n<h3 id=\"如何确定信息真实\"><a class=\"anchor\" href=\"#如何确定信息真实\">#</a> 如何确定信息真实</h3>\n<p>当用户在 12306 网站注册新账号或者为自己的账号添加新的乘车人时，系统需要确保用户提交的各项信息是真实准确的，而不是虚假的。</p>\n<p>这其中就涉及到一个很重要的概念 —— 用户信息的认证。对用户提交的信息进行认证，就是要验证信息的真实性，确认这确实是本人自愿提交的真实信息，不是其他人冒充的。</p>\n<p>那么如何进行有效的用户信息认证呢？这个问题可以简化为一个核心点：<strong><font color='red'>你需要向系统证明你就是你本人，你提供的信息都是真的。</font></strong></p>\n<p>举个简单的例子，在注册时，你提交了自己的身份证号码。但是系统怎么确认你提交的身份证号码真的属于你自己，而是通过非法途径获取然后冒充他人的呢？这就需要进行用户认证。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/1689686443768-96ffcb9d-8062-45f5-b37f-abc2f7ecd418.png\" alt=\"img\" /></p>\n<p>许多云服务提供商开放了<font color='red'>收费的身份验证接口</font>，这些接口底层主要调用公安部门的身份核验系统，并<font color='red'>在云服务端增加缓存层</font>。</p>\n<p>12306 中的信息准确性校验主要包括：</p>\n<ul>\n<li>注册会员时，校验用户名、证件号、手机号是否匹配，确保账号信息真实有效。</li>\n<li>添加乘车人时，校验乘车人姓名、身份证号是否真实匹配，并校验手机号可用性。</li>\n</ul>\n<p>如果 12306 的用户验证依赖收费的云服务或公安接口，为了优化成本和性能，其底层系统很可能采用缓存机制来减少对外部服务的直接调用。</p>\n<h3 id=\"数十亿级数据量\"><a class=\"anchor\" href=\"#数十亿级数据量\">#</a> 数十亿级数据量</h3>\n<p>根据 2022 年的全国人口统计数据，现有 14 亿多总人口，每年新生人口约 956 万。为便于后续业务数据规模的判断，本文先基于这一人口总量和增长数据进行估算。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/1689686443741-a20b8648-5921-4888-8179-30a21c17f93e.png\" alt=\"img\" /></p>\n<p>根据系统设计的假设，12306 的注册用户规模约为 10 亿，每年新增用户约 500 万。</p>\n<p>考虑到会员可添加多名乘车人，且一家多人可能分别拥有账号，估算乘车人数据量大约为注册用户的 2-3 倍，粗略估算约 30 亿左右。</p>\n<p>鉴于会员和乘车人数据规模都已超过 10 亿级别，远超出单机 MySQL 数据库的处理能力，所以需使用分库分表或分布式数据库来支撑<font color='red'>海量用户 / 乘车人数据</font>。</p>\n<p><font color='red'>考虑到<u>分布式数据库</u>普及率较低，<u>分库分表</u>技术仍是大多数公司的选择</font>，所以后续文章关于大数据量的解决方案会以分库分表技术来说明，查看<a href=\"#%E5%AF%B9%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E8%BF%9B%E8%A1%8C%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8\">对用户数据进行分库分表</a>。</p>\n<p>如果使用分库分表技术，面试中这些问题都是无法避免会被问到：</p>\n<ul>\n<li>选择分库还是分表，还是选择分库分表？基于什么考虑？</li>\n<li>选择哪个字段作为分片键？选择单个分片键还是复合分片键？</li>\n<li>如何在老业务上平滑上线分库分表？出现问题如何快速回滚？</li>\n<li>拆分后出现单表数据量过大，如何继续扩容？扩单表还是整体扩？</li>\n</ul>\n<h3 id=\"会员多种登录类型\"><a class=\"anchor\" href=\"#会员多种登录类型\">#</a> 会员多种登录类型</h3>\n<p>根据前文对 12306 系统设计的讨论分析，我们已经得知会员表预计会采用分库分表技术来应对大规模的访问压力和海量用户数据。</p>\n<p>但是在具体的登录环节，由于系统支持会员使用用户名、手机号以及邮箱等多种方式进行登录，这就存在一个比较棘手的问题：</p>\n<p><font color='red'>由于登录时无法确定用户的分片键，使得系统无法直接锁定用户的数据位于哪个数据库或者哪张表中。为了找到用户的数据，只能对全部的数据库和表进行扫描查询，这就造成了所谓的 “读请求扩散” 问题。</font></p>\n<p>也就是说，原本读请求可以直接定位到某个数据库某张表，现在却要多处查询，无疑大大增加了系统的查询负载。</p>\n<p><font color='red'>一旦出现了读请求扩散问题，势必会导致用户的登录请求响应时间变长，严重的话还可能造成登录超时。</font></p>\n<h3 id=\"会员注册缓存穿透\"><a class=\"anchor\" href=\"#会员注册缓存穿透\">#</a> 会员注册缓存穿透</h3>\n<p>在高并发的会员注册场景下，可能会出现 **<font color='red'>缓存穿透问题</font>**。</p>\n<blockquote>\n<p>缓存穿透说简单点就是 <strong>大量请求的 key 既不存在于缓存中，也不存在于数据库中，进行了两次无用的查询，最终返回空数据</strong>。这就导致这些请求直接到了数据库上，根本没有经过缓存这一层，<font color='red'>对数据库造成了巨大的压力</font>，可能直接就被这么多请求弄宕机了。</p>\n<img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/redis-cache-penetration.png\" alt=\"缓存穿透\" style=\"zoom: 67%;\" />\n</blockquote>\n<p>主要原因可能是：</p>\n<ul>\n<li>用户注册时，需要验证用户名是否已存在，这通常需要查询数据库。</li>\n<li>如果缓存中没有该用户名，就会去数据库查询，如果数据库中也没有，就可以判断该用户名可用。</li>\n<li>在高并发的情况下，可能有大量的新用户同时注册，输入的用户名极有可能都不存在于数据库中。这将导致大量的缓存不存在，都去查询数据库，造成数据库压力剧增。</li>\n<li><font color='red'>且这些查询数据库的 Key 都不会被缓存，因为数据库中没有，不会写入缓存</font>。那么这些 Key 对应的 Null 值也不会被缓存，造成每次请求都查不到缓存，直接查询数据库。</li>\n<li>这样就形成了缓存穿透情况。</li>\n</ul>\n<p>而且极端情况下，注册的流程可能是恶意请求访问。注册请求缓存穿透流程图如下：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/1689686443736-10dd98ef-e609-4bcf-90a6-0e73789ca084.png\" alt=\"img\" /></p>\n<p>所以，在用户注册场景下，需要注意防止缓存穿透，常见的处理方式有下述这些：</p>\n<ol>\n<li>\n<p><font color='cornflowerblue'><strong>缓存不存在的 Key</strong></font>，value 设为 Null，并设置短暂过期时间（如 60 秒）。</p>\n<blockquote>\n<p>弊端：</p>\n<ul>\n<li>假设用户 A 注册 username 为 magestack，查询 DB 不存在，返回请求成功，并放入 Redis 缓存。<font color='red'>但是用户 A 并没有使用该值作为 username</font>。（如何理解？）</li>\n<li>如果有另一个用户 B 注册 username 为 magestack，将返回失败。也就是说每尝试一次不存在的用户名，该值 60 秒内都不可被注册。</li>\n</ul>\n<p>结论：<font color='red'>对用户使用体验不友好</font>。此外，如果有大量并发请求查询不存在的用户名，可能会导致<font color='red'>数据库短时间内被打挂</font>。</p>\n</blockquote>\n</li>\n<li>\n<p><font color='cornflowerblue'>在缓存之前，使用<strong>布隆过滤器</strong></font>，<font color='red'>其工作特点是 —— 当它判断某个元素存在，小概率会误判；当它判断某个元素不存在，那么这个元素一定不在</font>。因此可以将所有已注册的用户名存入布隆过滤器，<font color='red'>判断时先判断该用户名是否在布隆过滤器中，不在的一定不存在</font>，避免直接查询数据库。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/redis-cache-penetration-bloom-filter.png\" alt=\"加入布隆过滤器之后的缓存处理流程图\" /></p>\n<center>加入布隆过滤器之后的缓存处理流程图</center>\n<blockquote>\n<p>弊端：</p>\n<ul>\n<li>这种解决方案算是网上八股说的比较多的一个版本。但是依然不能解决实际场景问题。</li>\n<li><font color='red'>如果用户注销了账号，该用户名就可以再次被使用。然而，<strong>布隆过滤器由于无法删除元素</strong>，因此无法处理这种情况。</font></li>\n</ul>\n<p>结论：布隆过滤器不能删除元素的限制，导致该方案无法正式使用生产。</p>\n<p>解决方法：<a href=\"#%E6%A2%B3%E7%90%86%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E5%85%B3%E7%B3%BB\">新增一张表 t_user_reuse ，存储已被注销的可用用户名</a></p>\n</blockquote>\n</li>\n<li>\n<p><font color='cornflowerblue'>使用确定的数据结构（如 <strong>Redis 的 Set 集合</strong>）来存储已注册用户名</font>，判断时检查是否在集合内。</p>\n<blockquote>\n<p>弊端：</p>\n<ul>\n<li>\n<p>永久存储十几亿的用户信息到 Redis 缓存中显然不太现实，因为这会<font color='red'>占用大量的内存资源</font>。</p>\n</li>\n<li>\n<p>即使是临时存储，如果在缓存中查询不到数据，<font color='red'>仍然无法避免查询数据库的场景</font>。</p>\n</li>\n<li>\n<p>此外，<font color='red'>对于这么多的用户信息，是否应该将其存储在一个 Key 中呢？显然是不可行的</font>。即使进行分片，也会增加系统的复杂度。</p>\n<blockquote>\n<p>我们常说的 Redis 数据结构，其实都是针对 value 的数据类型而言的，因为 Redis 本身仅仅是一个存储 key-value 键值对数据的内存数据库，因此 key 一般为 String 。所以这里才说 “将那么多用户信息存储在一个 key 中是不可行的”，相当于一个 key 对应的 value 中存储了所有用户信息。</p>\n</blockquote>\n</li>\n</ul>\n<p>结论：由于该方案<font color='red'>占用内存较多且复杂度较高</font>，因此不适合实际应用。</p>\n</blockquote>\n</li>\n<li>\n<p>针对高并发注册场景，可以先查询缓存，<font color='cornflowerblue'>如果缓存不命中，则使用<strong>分布式锁</strong>来保证只有一个线程访问数据库</font>，避免重复查询。</p>\n<blockquote>\n<p>弊端：</p>\n<ul>\n<li>相对于上述解决方案，该方案在一定程度上可以解决会员注册缓存穿透的问题。</li>\n<li>但是，如果在用户注册高峰期，只有一个线程访问数据库，这<font color='red'>可能会导致大量用户的注册请求缓慢或超时</font>。</li>\n</ul>\n<p>结论：<font color='red'>这对用户的使用体验来说并不友好</font>，因此我们不建议使用该方案。</p>\n</blockquote>\n</li>\n</ol>\n<p>从真实业务场景来看，上面这些解决方案都存在弊端，不能适用于真实场景。</p>\n<h3 id=\"敏感信息泄露\"><a class=\"anchor\" href=\"#敏感信息泄露\">#</a> 敏感信息泄露</h3>\n<p>在 12306 系统中，存在较多的敏感信息，比如会员或者乘车人的姓名、手机号、邮箱、证件号码以及住址。</p>\n<p>在数据库中将手机号或身份证号等敏感个人信息存明文会带来以下安全问题：</p>\n<ul>\n<li><font color='red'>明文存储可能会直接泄露用户隐私</font>，一旦数据库被攻击或数据泄露，个人敏感信息就会被完全暴露。</li>\n<li><font color='red'>明文存储提高了内部人员滥用数据的风险</font>，恶意查询和使用个人敏感信息的成本很低。</li>\n</ul>\n<p>为此，如何选择<strong>将用户信息加密存储</strong>，以及<strong>如何平滑过度转换现有业务中的明文数据为密文</strong>，就是个需要考虑的问题。</p>\n<h2 id=\"小结\"><a class=\"anchor\" href=\"#小结\">#</a> 小结</h2>\n<p>本文通过对 12306 铁路购票系统的业务进行分析，提出了几个关键的业务难点：</p>\n<ol>\n<li>如何确定用户注册信息的真实性，可能需要调用第三方实名认证服务。</li>\n<li>面对亿级用户量，需要使用分库分表技术来支撑海量数据。</li>\n<li>支持多种登录方式会造成读请求扩散，需要解决用户定位问题。</li>\n<li>高并发场景下缓存穿透问题需要有效解决，避免数据库压力过大。</li>\n<li>明文存储用户敏感信息会造成安全隐患，需要对关键数据加密。</li>\n</ol>\n<p>这些问题在大型业务系统中普遍存在，需要系统性地考虑技术选型和方案设计，才能构建一个高性能、安全的系统。</p>\n<h1 id=\"中间件学习\"><a class=\"anchor\" href=\"#中间件学习\">#</a> 中间件学习</h1>\n<ul>\n<li>RocketMQ（消息队列）：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9uYWdlb2ZmZXIuY29tL3JvY2tldG1xL3JlYWRtZS8=\">从零到一学习 RocketMQ | 拿个 offer - 开源 &amp; 项目实战 (nageoffer.com)</span></li>\n<li>ShardingSphere-JDBC（分库分表）：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9uYWdlb2ZmZXIuY29tL3NoYXJkaW5nc3BoZXJlLWpkYmMvcmVhZG1lLw==\">从零到一学习 Sharding-JDBC | 拿个 offer - 开源 &amp; 项目实战 (nageoffer.com)</span></li>\n<li>ShardingSphere-Proxy</li>\n<li>Canal</li>\n<li>Redisson</li>\n<li>Sentinel</li>\n<li>Hippo4j</li>\n</ul>\n<h1 id=\"核心技术文档\"><a class=\"anchor\" href=\"#核心技术文档\">#</a> 核心技术文档</h1>\n<h2 id=\"雪花算法生成分布式-id\"><a class=\"anchor\" href=\"#雪花算法生成分布式-id\">#</a> 雪花算法生成分布式 ID</h2>\n<p>分布式系统中，有一些需要使用全局唯一 ID 的场景，这种时候为了防止 ID 冲突可以使用 36 位的 UUID，但是<font color='red'> UUID 有一些缺点：相对比较长，且一般无序</font>。</p>\n<p>有些时候我们希望能使用一种简单些的 ID，并且希望 ID 能够按照时间有序生成。</p>\n<h3 id=\"雪花算法snowflake\"><a class=\"anchor\" href=\"#雪花算法snowflake\">#</a> 雪花算法（Snowflake）</h3>\n<p>Snowflake 是 Twitter 开源的分布式 ID 生成算法，生成后是<font color='red'>一个 64 bit 的 long 型的数值，组成部分引入了时间戳，基本保持了自增</font>。</p>\n<p>优点：</p>\n<ol>\n<li>高性能高可用：生成时不依赖于数据库，完全在内存中生成。</li>\n<li>高吞吐：每秒钟能生成数百万的自增 ID。</li>\n<li>ID 自增：存入数据库中，索引效率高。</li>\n</ol>\n<p>缺点：</p>\n<p>依赖于系统时间的一致性，如果系统时间被回调，或者改变，可能会造成 ID 冲突或者重复。</p>\n<h4 id=\"组成\"><a class=\"anchor\" href=\"#组成\">#</a> 组成</h4>\n<h4 id=\"适用场景\"><a class=\"anchor\" href=\"#适用场景\">#</a> 适用场景</h4>\n<h3 id=\"雪花算法生成-id-重复问题\"><a class=\"anchor\" href=\"#雪花算法生成-id-重复问题\">#</a> 雪花算法生成 ID 重复问题</h3>\n<h4 id=\"标识位如何定义\"><a class=\"anchor\" href=\"#标识位如何定义\">#</a> 标识位如何定义</h4>\n<h4 id=\"分配标识位\"><a class=\"anchor\" href=\"#分配标识位\">#</a> 分配标识位</h4>\n<h3 id=\"开源分布式-id-框架\"><a class=\"anchor\" href=\"#开源分布式-id-框架\">#</a> 开源分布式 ID 框架</h3>\n<h3 id=\"小结-2\"><a class=\"anchor\" href=\"#小结-2\">#</a> 小结</h3>\n<h2 id=\"只会控制层捕获异常可以尝试全局拦截\"><a class=\"anchor\" href=\"#只会控制层捕获异常可以尝试全局拦截\">#</a> 只会控制层捕获异常？可以尝试全局拦截</h2>\n<h3 id=\"异常是什么\"><a class=\"anchor\" href=\"#异常是什么\">#</a> 异常是什么</h3>\n<p>异常机制是指当程序出现错误后，程序如何处理。具体来说，异常机制提供了程序退出的安全通道。<font color='red'>当出现错误后，程序执行的流程发生改变，程序的控制权转移到异常处理器</font>。</p>\n<p>在 Java 中，所有的异常都有一个<font color='red'>共同的祖先  <code>Throwable</code> （可抛出）</font>。Throwable 指定代码中可用异常传播机制通过 Java 应用程序传输的任何问题的共性。<font color='red'>Throwable 有两个重要的子类： <code>Error</code> （错误）和  <code>Exception</code> （异常）</font>，二者都是 Java 异常处理的重要子类，各自都包含大量子类，区别是：<strong><font color='red'>Exception 能被程序本身可以处理，Error 是无法处理</font></strong>。</p>\n<ul>\n<li>Error（错误）：JVM 无法解决的<strong>严重问题</strong>，大多数<font color='red'>与代码编写者执行的操作无关</font>，而是 JVM 出现的问题。例如 StackOverflowError（栈内存溢出）和 OutOfMemoryError（堆内存溢出，简称 OOM）。</li>\n<li>Exception（异常）：其它因编程错误或偶然的外在因素导致的<strong>一般性问题</strong>，是<font color='red'>程序本身可以通过代码处理的异常</font>。例如空指针访问、试图读取不存在的文件、网络连接中断、数组角标越界等。Exception 类有一个重要的子类  <code>RuntimeException</code> ，表示<font color='red'>运行时异常</font>。</li>\n</ul>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/1562771528807.png\" alt=\"1562771528807\" /></p>\n<h3 id=\"异常分类\"><a class=\"anchor\" href=\"#异常分类\">#</a> 异常分类</h3>\n<blockquote>\n<p><code>framework.starter.convention.exception</code></p>\n</blockquote>\n<p>通过上面所述，Error 属于程序无法处理的错误，我们的目标<font color='red'>更多是针对 Exception 做些文章，具体来说是<strong>根据业务异常情况，通过继承其子类 RuntimeException 来自定义（运行时）异常类型</strong>，自定义的异常只能通过 throw 抛出，而后由 try...catch (... finally ...) 处理，或者通过 throws 甩锅给调用者处理</font>。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20240307184954366.png\" alt=\"image-20240307184954366\" /></p>\n<h4 id=\"抽象异常\"><a class=\"anchor\" href=\"#抽象异常\">#</a> 抽象异常</h4>\n<blockquote>\n<p><code>AbstractException</code></p>\n</blockquote>\n<p>上图中的三类异常共同继承  <code>RuntimeException</code> ，那么肯定具备很多相似的地方，因此统一抽象一层 AbstractException。</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">package</span> <span class=\"token namespace\">org<span class=\"token punctuation\">.</span>opengoofy<span class=\"token punctuation\">.</span>index12306<span class=\"token punctuation\">.</span>framework<span class=\"token punctuation\">.</span>starter<span class=\"token punctuation\">.</span>convention<span class=\"token punctuation\">.</span>exception</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">lombok<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">Getter</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">org<span class=\"token punctuation\">.</span>opengoofy<span class=\"token punctuation\">.</span>index12306<span class=\"token punctuation\">.</span>framework<span class=\"token punctuation\">.</span>starter<span class=\"token punctuation\">.</span>convention<span class=\"token punctuation\">.</span>errorcode<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">IErrorCode</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">org<span class=\"token punctuation\">.</span>springframework<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">StringUtils</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">java<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">Optional</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token comment\">/**</pre></td></tr><tr><td data-num=\"10\"></td><td><pre> * 抽象项目中三类异常体系（客户端异常、服务端异常以及远程服务调用异常），作为三者的基类</pre></td></tr><tr><td data-num=\"11\"></td><td><pre> *</pre></td></tr><tr><td data-num=\"12\"></td><td><pre> * @公众号：马丁玩编程，回复：加群，添加马哥微信（备注：12306）获取项目资料</pre></td></tr><tr><td data-num=\"13\"></td><td><pre> * @see ClientException</pre></td></tr><tr><td data-num=\"14\"></td><td><pre> * @see ServiceException</pre></td></tr><tr><td data-num=\"15\"></td><td><pre> * @see RemoteException</pre></td></tr><tr><td data-num=\"16\"></td><td><pre> */</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre><span class=\"token annotation punctuation\">@Getter</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">abstract</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">AbstractException</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">RuntimeException</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token comment\">// 继承运行时异常类</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">String</span> errorCode<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">String</span> errorMessage<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token class-name\">AbstractException</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> message<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Throwable</span> throwable<span class=\"token punctuation\">,</span> <span class=\"token class-name\">IErrorCode</span> errorCode<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token comment\">// Throwable 为异常的根类</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>        <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>message<span class=\"token punctuation\">,</span> throwable<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>errorCode <span class=\"token operator\">=</span> errorCode<span class=\"token punctuation\">.</span><span class=\"token function\">code</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>errorMessage <span class=\"token operator\">=</span> <span class=\"token class-name\">Optional</span><span class=\"token punctuation\">.</span><span class=\"token function\">ofNullable</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">StringUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">hasLength</span><span class=\"token punctuation\">(</span>message<span class=\"token punctuation\">)</span> <span class=\"token operator\">?</span> message <span class=\"token operator\">:</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">orElse</span><span class=\"token punctuation\">(</span>errorCode<span class=\"token punctuation\">.</span><span class=\"token function\">message</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h4 id=\"客户端异常\"><a class=\"anchor\" href=\"#客户端异常\">#</a> 客户端异常</h4>\n<p>客户端相关异常，比如：<font color='red'>参数校验失败异常、幂等异常</font>......</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">package</span> <span class=\"token namespace\">org<span class=\"token punctuation\">.</span>opengoofy<span class=\"token punctuation\">.</span>index12306<span class=\"token punctuation\">.</span>framework<span class=\"token punctuation\">.</span>starter<span class=\"token punctuation\">.</span>convention<span class=\"token punctuation\">.</span>exception</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">org<span class=\"token punctuation\">.</span>opengoofy<span class=\"token punctuation\">.</span>index12306<span class=\"token punctuation\">.</span>framework<span class=\"token punctuation\">.</span>starter<span class=\"token punctuation\">.</span>convention<span class=\"token punctuation\">.</span>errorcode<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">BaseErrorCode</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">org<span class=\"token punctuation\">.</span>opengoofy<span class=\"token punctuation\">.</span>index12306<span class=\"token punctuation\">.</span>framework<span class=\"token punctuation\">.</span>starter<span class=\"token punctuation\">.</span>convention<span class=\"token punctuation\">.</span>errorcode<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">IErrorCode</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token comment\">/**</pre></td></tr><tr><td data-num=\"7\"></td><td><pre> * 客户端异常</pre></td></tr><tr><td data-num=\"8\"></td><td><pre> *</pre></td></tr><tr><td data-num=\"9\"></td><td><pre> * @公众号：马丁玩编程，回复：加群，添加马哥微信（备注：12306）获取项目资料</pre></td></tr><tr><td data-num=\"10\"></td><td><pre> */</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">ClientException</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">AbstractException</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token class-name\">ClientException</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">IErrorCode</span> errorCode<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>        <span class=\"token keyword\">this</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span> errorCode<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token class-name\">ClientException</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> message<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>        <span class=\"token keyword\">this</span><span class=\"token punctuation\">(</span>message<span class=\"token punctuation\">,</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">BaseErrorCode</span><span class=\"token punctuation\">.</span><span class=\"token constant\">CLIENT_ERROR</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token class-name\">ClientException</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> message<span class=\"token punctuation\">,</span> <span class=\"token class-name\">IErrorCode</span> errorCode<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>        <span class=\"token keyword\">this</span><span class=\"token punctuation\">(</span>message<span class=\"token punctuation\">,</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span> errorCode<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token class-name\">ClientException</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> message<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Throwable</span> throwable<span class=\"token punctuation\">,</span> <span class=\"token class-name\">IErrorCode</span> errorCode<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>        <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>message<span class=\"token punctuation\">,</span> throwable<span class=\"token punctuation\">,</span> errorCode<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>    <span class=\"token annotation punctuation\">@Override</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token class-name\">String</span> <span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre>        <span class=\"token keyword\">return</span> <span class=\"token string\">\"ClientException&#123;\"</span> <span class=\"token operator\">+</span></pre></td></tr><tr><td data-num=\"32\"></td><td><pre>                <span class=\"token string\">\"code='\"</span> <span class=\"token operator\">+</span> errorCode <span class=\"token operator\">+</span> <span class=\"token string\">\"',\"</span> <span class=\"token operator\">+</span></pre></td></tr><tr><td data-num=\"33\"></td><td><pre>                <span class=\"token string\">\"message='\"</span> <span class=\"token operator\">+</span> errorMessage <span class=\"token operator\">+</span> <span class=\"token string\">\"'\"</span> <span class=\"token operator\">+</span></pre></td></tr><tr><td data-num=\"34\"></td><td><pre>                <span class=\"token char\">'&#125;'</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"35\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"36\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h4 id=\"服务端异常\"><a class=\"anchor\" href=\"#服务端异常\">#</a> 服务端异常</h4>\n<p>服务端相关异常，比如：<font color='red'>消息模版不合规、消息内容包含关键字</font>......</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">package</span> <span class=\"token namespace\">org<span class=\"token punctuation\">.</span>opengoofy<span class=\"token punctuation\">.</span>index12306<span class=\"token punctuation\">.</span>framework<span class=\"token punctuation\">.</span>starter<span class=\"token punctuation\">.</span>convention<span class=\"token punctuation\">.</span>exception</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">org<span class=\"token punctuation\">.</span>opengoofy<span class=\"token punctuation\">.</span>index12306<span class=\"token punctuation\">.</span>framework<span class=\"token punctuation\">.</span>starter<span class=\"token punctuation\">.</span>convention<span class=\"token punctuation\">.</span>errorcode<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">BaseErrorCode</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">org<span class=\"token punctuation\">.</span>opengoofy<span class=\"token punctuation\">.</span>index12306<span class=\"token punctuation\">.</span>framework<span class=\"token punctuation\">.</span>starter<span class=\"token punctuation\">.</span>convention<span class=\"token punctuation\">.</span>errorcode<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">IErrorCode</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">java<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">Optional</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token comment\">/**</pre></td></tr><tr><td data-num=\"9\"></td><td><pre> * 服务端异常</pre></td></tr><tr><td data-num=\"10\"></td><td><pre> *</pre></td></tr><tr><td data-num=\"11\"></td><td><pre> * @公众号：马丁玩编程，回复：加群，添加马哥微信（备注：12306）获取项目资料</pre></td></tr><tr><td data-num=\"12\"></td><td><pre> */</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">ServiceException</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">AbstractException</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token class-name\">ServiceException</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> message<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>        <span class=\"token keyword\">this</span><span class=\"token punctuation\">(</span>message<span class=\"token punctuation\">,</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">BaseErrorCode</span><span class=\"token punctuation\">.</span><span class=\"token constant\">SERVICE_ERROR</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token class-name\">ServiceException</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">IErrorCode</span> errorCode<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>        <span class=\"token keyword\">this</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span> errorCode<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token class-name\">ServiceException</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> message<span class=\"token punctuation\">,</span> <span class=\"token class-name\">IErrorCode</span> errorCode<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>        <span class=\"token keyword\">this</span><span class=\"token punctuation\">(</span>message<span class=\"token punctuation\">,</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span> errorCode<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token class-name\">ServiceException</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> message<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Throwable</span> throwable<span class=\"token punctuation\">,</span> <span class=\"token class-name\">IErrorCode</span> errorCode<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>        <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Optional</span><span class=\"token punctuation\">.</span><span class=\"token function\">ofNullable</span><span class=\"token punctuation\">(</span>message<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">orElse</span><span class=\"token punctuation\">(</span>errorCode<span class=\"token punctuation\">.</span><span class=\"token function\">message</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> throwable<span class=\"token punctuation\">,</span> errorCode<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre></pre></td></tr><tr><td data-num=\"31\"></td><td><pre>    <span class=\"token annotation punctuation\">@Override</span></pre></td></tr><tr><td data-num=\"32\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token class-name\">String</span> <span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"33\"></td><td><pre>        <span class=\"token keyword\">return</span> <span class=\"token string\">\"ServiceException&#123;\"</span> <span class=\"token operator\">+</span></pre></td></tr><tr><td data-num=\"34\"></td><td><pre>                <span class=\"token string\">\"code='\"</span> <span class=\"token operator\">+</span> errorCode <span class=\"token operator\">+</span> <span class=\"token string\">\"',\"</span> <span class=\"token operator\">+</span></pre></td></tr><tr><td data-num=\"35\"></td><td><pre>                <span class=\"token string\">\"message='\"</span> <span class=\"token operator\">+</span> errorMessage <span class=\"token operator\">+</span> <span class=\"token string\">\"'\"</span> <span class=\"token operator\">+</span></pre></td></tr><tr><td data-num=\"36\"></td><td><pre>                <span class=\"token char\">'&#125;'</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"37\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"38\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h4 id=\"远程调用异常\"><a class=\"anchor\" href=\"#远程调用异常\">#</a> 远程调用异常</h4>\n<p>服务调用远端异常，比如：<font color='red'>短信调用三方服务发送失败、调用 MQ 失败、调用 Redis 失败</font>等......</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">org<span class=\"token punctuation\">.</span>opengoofy<span class=\"token punctuation\">.</span>index12306<span class=\"token punctuation\">.</span>framework<span class=\"token punctuation\">.</span>starter<span class=\"token punctuation\">.</span>convention<span class=\"token punctuation\">.</span>errorcode<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">BaseErrorCode</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">org<span class=\"token punctuation\">.</span>opengoofy<span class=\"token punctuation\">.</span>index12306<span class=\"token punctuation\">.</span>framework<span class=\"token punctuation\">.</span>starter<span class=\"token punctuation\">.</span>convention<span class=\"token punctuation\">.</span>errorcode<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">IErrorCode</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token comment\">/**</pre></td></tr><tr><td data-num=\"5\"></td><td><pre> * 远程服务调用异常</pre></td></tr><tr><td data-num=\"6\"></td><td><pre> *</pre></td></tr><tr><td data-num=\"7\"></td><td><pre> * @公众号：马丁玩编程，回复：加群，添加马哥微信（备注：12306）获取项目资料</pre></td></tr><tr><td data-num=\"8\"></td><td><pre> */</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">RemoteException</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">AbstractException</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token class-name\">RemoteException</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> message<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>        <span class=\"token keyword\">this</span><span class=\"token punctuation\">(</span>message<span class=\"token punctuation\">,</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">BaseErrorCode</span><span class=\"token punctuation\">.</span><span class=\"token constant\">REMOTE_ERROR</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token class-name\">RemoteException</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> message<span class=\"token punctuation\">,</span> <span class=\"token class-name\">IErrorCode</span> errorCode<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>        <span class=\"token keyword\">this</span><span class=\"token punctuation\">(</span>message<span class=\"token punctuation\">,</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span> errorCode<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token class-name\">RemoteException</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> message<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Throwable</span> throwable<span class=\"token punctuation\">,</span> <span class=\"token class-name\">IErrorCode</span> errorCode<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>        <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>message<span class=\"token punctuation\">,</span> throwable<span class=\"token punctuation\">,</span> errorCode<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>    <span class=\"token annotation punctuation\">@Override</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token class-name\">String</span> <span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>        <span class=\"token keyword\">return</span> <span class=\"token string\">\"RemoteException&#123;\"</span> <span class=\"token operator\">+</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>                <span class=\"token string\">\"code='\"</span> <span class=\"token operator\">+</span> errorCode <span class=\"token operator\">+</span> <span class=\"token string\">\"',\"</span> <span class=\"token operator\">+</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>                <span class=\"token string\">\"message='\"</span> <span class=\"token operator\">+</span> errorMessage <span class=\"token operator\">+</span> <span class=\"token string\">\"'\"</span> <span class=\"token operator\">+</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>                <span class=\"token char\">'&#125;'</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h3 id=\"异常码定义\"><a class=\"anchor\" href=\"#异常码定义\">#</a> 异常码定义</h3>\n<p>这里按照 <code>《Java开发手册（嵩山版）》</code> 中给出的异常码规定方式，确定一版以观后效。我们先看看阿里巴巴开发手册如何规定异常码。</p>\n<p><strong><font color='red'>【强制】错误码为字符串类型，共 5 位，分成两个部分：错误产生来源 + 四位数字编号</font></strong>。</p>\n<p><font color='red'>【强制】全部正常，但不得不填充错误码时返回五个零：00000</font>。</p>\n<blockquote>\n<p>错误产生来源分为 <strong>A / B / C</strong>。</p>\n<ul>\n<li>A 表示错误来源于用户，比如参数错误，用户安装版本过低，用户支付超时等问题。</li>\n<li>B 表示错误来源于当前系统，往往是业务逻辑出错，或程序健壮性差等问题。</li>\n<li>C 表示错误来源于第三方服务，比如 CDN 服务出错，消息投递超时等问题。</li>\n</ul>\n<p>四位数字编号从 0001 到 9999，大类之间的步长间距预留 100，参考文末附表 3。</p>\n</blockquote>\n<h4 id=\"如何定义异常码\"><a class=\"anchor\" href=\"#如何定义异常码\">#</a> 如何定义异常码</h4>\n<p><font color='red'>【强制】编号不与公司业务架构挂钩，更不与组织架构挂钩，以<u>先到先得</u>的原则在统一平台上（需要开发）进行，审批生效，编号即被<u>永久固定</u></font>。</p>\n<p><font color='red'>【强制】错误码使用者<u>避免随意定义</u>新的错误码</font>。</p>\n<blockquote>\n<p>尽可能在原有错误码附表中找到语义相同或者相近的错误码在代码中使用即可。</p>\n</blockquote>\n<h4 id=\"异常码示例\"><a class=\"anchor\" href=\"#异常码示例\">#</a> 异常码示例</h4>\n<table>\n<thead>\n<tr>\n<th>异常码</th>\n<th>含义</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0</td>\n<td>一切 ok</td>\n<td>正确执行后的返回</td>\n</tr>\n<tr>\n<td>A0001</td>\n<td>用户端错误</td>\n<td>一级宏观错误码</td>\n</tr>\n<tr>\n<td>A0100</td>\n<td>用户注册错误</td>\n<td>二级宏观错误码</td>\n</tr>\n<tr>\n<td>A0101</td>\n<td>用户未同意隐私协议</td>\n<td></td>\n</tr>\n<tr>\n<td>A0102</td>\n<td>注册国家或地区受限</td>\n<td></td>\n</tr>\n<tr>\n<td>A0110</td>\n<td>用户名校验失败</td>\n<td></td>\n</tr>\n<tr>\n<td>A0111</td>\n<td>用户名已存在</td>\n<td></td>\n</tr>\n<tr>\n<td>A0112</td>\n<td>用户名包含敏感词</td>\n<td></td>\n</tr>\n<tr>\n<td>A0113</td>\n<td>用户名包含特殊字符</td>\n<td></td>\n</tr>\n<tr>\n<td>A0120</td>\n<td>密码校验失败</td>\n<td></td>\n</tr>\n<tr>\n<td>A0121</td>\n<td>密码长度不够</td>\n<td></td>\n</tr>\n<tr>\n<td>A0122</td>\n<td>密码强度不够</td>\n<td></td>\n</tr>\n<tr>\n<td>A0130</td>\n<td>校验码输入错误</td>\n<td></td>\n</tr>\n<tr>\n<td>A0131</td>\n<td>短信校验码输入错误</td>\n<td></td>\n</tr>\n<tr>\n<td>A0132</td>\n<td>邮件校验码输入错误</td>\n<td></td>\n</tr>\n<tr>\n<td>A0133</td>\n<td>语音校验码输入错误</td>\n<td></td>\n</tr>\n<tr>\n<td>A0140</td>\n<td>用户证件异常</td>\n<td></td>\n</tr>\n<tr>\n<td>A0141</td>\n<td>用户证件类型未选择</td>\n<td></td>\n</tr>\n<tr>\n<td>A0142</td>\n<td>大陆身份证编号校验非法</td>\n<td></td>\n</tr>\n<tr>\n<td>A0143</td>\n<td>护照编号校验非法</td>\n<td></td>\n</tr>\n<tr>\n<td>A0144</td>\n<td>军官证编号校验非法</td>\n<td></td>\n</tr>\n<tr>\n<td>A0150</td>\n<td>用户基本信息校验失败</td>\n<td></td>\n</tr>\n<tr>\n<td>A0151</td>\n<td>手机格式校验失败</td>\n<td></td>\n</tr>\n<tr>\n<td>A0152</td>\n<td>地址格式校验失败</td>\n<td></td>\n</tr>\n<tr>\n<td>A0153</td>\n<td>邮箱格式校验失败</td>\n<td></td>\n</tr>\n<tr>\n<td>A0200</td>\n<td>用户登录异常</td>\n<td>二级宏观错误码</td>\n</tr>\n<tr>\n<td>A0201</td>\n<td>用户账户不存在</td>\n<td></td>\n</tr>\n<tr>\n<td>A0202</td>\n<td>用户账户被冻结</td>\n<td></td>\n</tr>\n<tr>\n<td>A0203</td>\n<td>用户账户已作废</td>\n<td></td>\n</tr>\n<tr>\n<td>A0210</td>\n<td>用户密码错误</td>\n<td></td>\n</tr>\n<tr>\n<td>A0211</td>\n<td>用户输入密码错误次数超限</td>\n<td></td>\n</tr>\n<tr>\n<td>A0220</td>\n<td>用户身份校验失败</td>\n<td></td>\n</tr>\n<tr>\n<td>A0221</td>\n<td>用户指纹识别失败</td>\n<td></td>\n</tr>\n<tr>\n<td>A0222</td>\n<td>用户面容识别失败</td>\n<td></td>\n</tr>\n<tr>\n<td>A0223</td>\n<td>用户未获得第三方登录授权</td>\n<td></td>\n</tr>\n<tr>\n<td>A0230</td>\n<td>用户登录已过期</td>\n<td></td>\n</tr>\n<tr>\n<td>A0240</td>\n<td>用户验证码错误</td>\n<td></td>\n</tr>\n<tr>\n<td>A0241</td>\n<td>用户验证码尝试次数超限</td>\n<td></td>\n</tr>\n<tr>\n<td>A0300</td>\n<td>访问权限异常</td>\n<td>二级宏观错误码</td>\n</tr>\n<tr>\n<td>A0301</td>\n<td>访问未授权</td>\n<td></td>\n</tr>\n<tr>\n<td>A0302</td>\n<td>正在授权中</td>\n<td></td>\n</tr>\n<tr>\n<td>A0303</td>\n<td>用户授权申请被拒绝</td>\n<td></td>\n</tr>\n<tr>\n<td>A0310</td>\n<td>因访问对象隐私设置被拦截</td>\n<td></td>\n</tr>\n<tr>\n<td>A0311</td>\n<td>授权已过期</td>\n<td></td>\n</tr>\n<tr>\n<td>A0312</td>\n<td>无权限使用 API</td>\n<td></td>\n</tr>\n<tr>\n<td>A0320</td>\n<td>用户访问被拦截</td>\n<td></td>\n</tr>\n<tr>\n<td>A0321</td>\n<td>黑名单用户</td>\n<td></td>\n</tr>\n<tr>\n<td>A0322</td>\n<td>账号被冻结</td>\n<td></td>\n</tr>\n<tr>\n<td>A0323</td>\n<td>非法 IP 地址</td>\n<td></td>\n</tr>\n<tr>\n<td>A0324</td>\n<td>网关访问受限</td>\n<td></td>\n</tr>\n<tr>\n<td>A0325</td>\n<td>地域黑名单</td>\n<td></td>\n</tr>\n<tr>\n<td>A0330</td>\n<td>服务已欠费</td>\n<td></td>\n</tr>\n<tr>\n<td>A0340</td>\n<td>用户签名异常</td>\n<td></td>\n</tr>\n<tr>\n<td>A0341</td>\n<td>RSA 签名错误</td>\n<td></td>\n</tr>\n<tr>\n<td>A0400</td>\n<td>用户请求参数错误</td>\n<td>二级宏观错误码</td>\n</tr>\n<tr>\n<td>A0401</td>\n<td>包含非法恶意跳转链接</td>\n<td></td>\n</tr>\n<tr>\n<td>A0402</td>\n<td>无效的用户输入</td>\n<td></td>\n</tr>\n<tr>\n<td>A0410</td>\n<td>请求必填参数为空</td>\n<td></td>\n</tr>\n<tr>\n<td>A0411</td>\n<td>用户订单号为空</td>\n<td></td>\n</tr>\n<tr>\n<td>A0412</td>\n<td>订购数量为空</td>\n<td></td>\n</tr>\n<tr>\n<td>A0413</td>\n<td>缺少时间戳参数</td>\n<td></td>\n</tr>\n<tr>\n<td>A0414</td>\n<td>非法的时间戳参数</td>\n<td></td>\n</tr>\n<tr>\n<td>A0420</td>\n<td>请求参数值超出允许的范围</td>\n<td></td>\n</tr>\n<tr>\n<td>A0421</td>\n<td>参数格式不匹配</td>\n<td></td>\n</tr>\n<tr>\n<td>A0422</td>\n<td>地址不在服务范围</td>\n<td></td>\n</tr>\n<tr>\n<td>A0423</td>\n<td>时间不在服务范围</td>\n<td></td>\n</tr>\n<tr>\n<td>A0424</td>\n<td>金额超出限制</td>\n<td></td>\n</tr>\n<tr>\n<td>A0425</td>\n<td>数量超出限制</td>\n<td></td>\n</tr>\n<tr>\n<td>A0426</td>\n<td>请求批量处理总个数超出限制</td>\n<td></td>\n</tr>\n<tr>\n<td>A0427</td>\n<td>请求 JSON 解析失败</td>\n<td></td>\n</tr>\n<tr>\n<td>A0430</td>\n<td>用户输入内容非法</td>\n<td></td>\n</tr>\n<tr>\n<td>A0431</td>\n<td>包含违禁敏感词</td>\n<td></td>\n</tr>\n<tr>\n<td>A0432</td>\n<td>图片包含违禁信息</td>\n<td></td>\n</tr>\n<tr>\n<td>A0433</td>\n<td>文件侵犯版权</td>\n<td></td>\n</tr>\n<tr>\n<td>A0440</td>\n<td>用户操作异常</td>\n<td></td>\n</tr>\n<tr>\n<td>A0441</td>\n<td>用户支付超时</td>\n<td></td>\n</tr>\n<tr>\n<td>A0442</td>\n<td>确认订单超时</td>\n<td></td>\n</tr>\n<tr>\n<td>A0443</td>\n<td>订单已关闭</td>\n<td></td>\n</tr>\n<tr>\n<td>A0500</td>\n<td>用户请求服务异常</td>\n<td>二级宏观错误码</td>\n</tr>\n<tr>\n<td>A0501</td>\n<td>请求次数超出限制</td>\n<td></td>\n</tr>\n<tr>\n<td>A0502</td>\n<td>请求并发数超出限制</td>\n<td></td>\n</tr>\n<tr>\n<td>A0503</td>\n<td>用户操作请等待</td>\n<td></td>\n</tr>\n<tr>\n<td>A0504</td>\n<td>WebSocket 连接异常</td>\n<td></td>\n</tr>\n<tr>\n<td>A0505</td>\n<td>WebSocket 连接断开</td>\n<td></td>\n</tr>\n<tr>\n<td>A0506</td>\n<td>用户重复请求</td>\n<td></td>\n</tr>\n<tr>\n<td>A0600</td>\n<td>用户资源异常</td>\n<td>二级宏观错误码</td>\n</tr>\n<tr>\n<td>A0601</td>\n<td>账户余额不足</td>\n<td></td>\n</tr>\n<tr>\n<td>A0602</td>\n<td>用户磁盘空间不足</td>\n<td></td>\n</tr>\n<tr>\n<td>A0603</td>\n<td>用户内存空间不足</td>\n<td></td>\n</tr>\n<tr>\n<td>A0604</td>\n<td>用户 OSS 容量不足</td>\n<td></td>\n</tr>\n<tr>\n<td>A0605</td>\n<td>用户配额已用光</td>\n<td>蚂蚁森林浇水数或每天抽奖数</td>\n</tr>\n<tr>\n<td>A0700</td>\n<td>用户上传文件异常</td>\n<td>二级宏观错误码</td>\n</tr>\n<tr>\n<td>A0701</td>\n<td>用户上传文件类型不匹配</td>\n<td></td>\n</tr>\n<tr>\n<td>A0702</td>\n<td>用户上传文件太大</td>\n<td></td>\n</tr>\n<tr>\n<td>A0703</td>\n<td>用户上传图片太大</td>\n<td></td>\n</tr>\n<tr>\n<td>A0704</td>\n<td>用户上传视频太大</td>\n<td></td>\n</tr>\n<tr>\n<td>A0705</td>\n<td>用户上传压缩文件太大</td>\n<td></td>\n</tr>\n<tr>\n<td>A0800</td>\n<td>用户当前版本异常</td>\n<td>二级宏观错误码</td>\n</tr>\n<tr>\n<td>A0801</td>\n<td>用户安装版本与系统不匹配</td>\n<td></td>\n</tr>\n<tr>\n<td>A0802</td>\n<td>用户安装版本过低</td>\n<td></td>\n</tr>\n<tr>\n<td>A0803</td>\n<td>用户安装版本过高</td>\n<td></td>\n</tr>\n<tr>\n<td>A0804</td>\n<td>用户安装版本已过期</td>\n<td></td>\n</tr>\n<tr>\n<td>A0805</td>\n<td>用户 API 请求版本不匹配</td>\n<td></td>\n</tr>\n<tr>\n<td>A0806</td>\n<td>用户 API 请求版本过高</td>\n<td></td>\n</tr>\n<tr>\n<td>A0807</td>\n<td>用户 API 请求版本过低</td>\n<td></td>\n</tr>\n<tr>\n<td>A0900</td>\n<td>用户隐私未授权</td>\n<td>二级宏观错误码</td>\n</tr>\n<tr>\n<td>A0901</td>\n<td>用户隐私未签署</td>\n<td></td>\n</tr>\n<tr>\n<td>A0902</td>\n<td>用户摄像头未授权</td>\n<td></td>\n</tr>\n<tr>\n<td>A0903</td>\n<td>用户相机未授权</td>\n<td></td>\n</tr>\n<tr>\n<td>A0904</td>\n<td>用户图片库未授权</td>\n<td></td>\n</tr>\n<tr>\n<td>A0905</td>\n<td>用户文件未授权</td>\n<td></td>\n</tr>\n<tr>\n<td>A0906</td>\n<td>用户位置信息未授权</td>\n<td></td>\n</tr>\n<tr>\n<td>A0907</td>\n<td>用户通讯录未授权</td>\n<td></td>\n</tr>\n<tr>\n<td>A1000</td>\n<td>用户设备异常</td>\n<td>二级宏观错误码</td>\n</tr>\n<tr>\n<td>A1001</td>\n<td>用户相机异常</td>\n<td></td>\n</tr>\n<tr>\n<td>A1002</td>\n<td>用户麦克风异常</td>\n<td></td>\n</tr>\n<tr>\n<td>A1003</td>\n<td>用户听筒异常</td>\n<td></td>\n</tr>\n<tr>\n<td>A1004</td>\n<td>用户扬声器异常</td>\n<td></td>\n</tr>\n<tr>\n<td>A1005</td>\n<td>用户 GPS 定位异常</td>\n<td></td>\n</tr>\n<tr>\n<td>B0001</td>\n<td>系统执行出错</td>\n<td>一级宏观错误码</td>\n</tr>\n<tr>\n<td>B0100</td>\n<td>系统执行超时</td>\n<td>二级宏观错误码</td>\n</tr>\n<tr>\n<td>B0101</td>\n<td>系统订单处理超时</td>\n<td></td>\n</tr>\n<tr>\n<td>B0200</td>\n<td>系统容灾功能被触发</td>\n<td>二级宏观错误码</td>\n</tr>\n<tr>\n<td>B0210</td>\n<td>系统限流</td>\n<td></td>\n</tr>\n<tr>\n<td>B0220</td>\n<td>系统功能降级</td>\n<td></td>\n</tr>\n<tr>\n<td>B0300</td>\n<td>系统资源异常</td>\n<td>二级宏观错误码</td>\n</tr>\n<tr>\n<td>B0310</td>\n<td>系统资源耗尽</td>\n<td></td>\n</tr>\n<tr>\n<td>B0311</td>\n<td>系统磁盘空间耗尽</td>\n<td></td>\n</tr>\n<tr>\n<td>B0312</td>\n<td>系统内存耗尽</td>\n<td></td>\n</tr>\n<tr>\n<td>B0313</td>\n<td>文件句柄耗尽</td>\n<td></td>\n</tr>\n<tr>\n<td>B0314</td>\n<td>系统连接池耗尽</td>\n<td></td>\n</tr>\n<tr>\n<td>B0315</td>\n<td>系统线程池耗尽</td>\n<td></td>\n</tr>\n<tr>\n<td>B0320</td>\n<td>系统资源访问异常</td>\n<td></td>\n</tr>\n<tr>\n<td>B0321</td>\n<td>系统读取磁盘文件失败</td>\n<td></td>\n</tr>\n<tr>\n<td>C0001</td>\n<td>调用第三方服务出错</td>\n<td>一级宏观错误码</td>\n</tr>\n<tr>\n<td>C0100</td>\n<td>中间件服务出错</td>\n<td>二级宏观错误码</td>\n</tr>\n<tr>\n<td>C0110</td>\n<td>RPC 服务出错</td>\n<td></td>\n</tr>\n<tr>\n<td>C0111</td>\n<td>RPC 服务未找到</td>\n<td></td>\n</tr>\n<tr>\n<td>C0112</td>\n<td>RPC 服务未注册</td>\n<td></td>\n</tr>\n<tr>\n<td>C0113</td>\n<td>接口不存在</td>\n<td></td>\n</tr>\n<tr>\n<td>C0120</td>\n<td>消息服务出错</td>\n<td></td>\n</tr>\n<tr>\n<td>C0121</td>\n<td>消息投递出错</td>\n<td></td>\n</tr>\n<tr>\n<td>C0122</td>\n<td>消息消费出错</td>\n<td></td>\n</tr>\n<tr>\n<td>C0123</td>\n<td>消息订阅出错</td>\n<td></td>\n</tr>\n<tr>\n<td>C0124</td>\n<td>消息分组未查到</td>\n<td></td>\n</tr>\n<tr>\n<td>C0130</td>\n<td>缓存服务出错</td>\n<td></td>\n</tr>\n<tr>\n<td>C0131</td>\n<td>key 长度超过限制</td>\n<td></td>\n</tr>\n<tr>\n<td>C0132</td>\n<td>value 长度超过限制</td>\n<td></td>\n</tr>\n<tr>\n<td>C0133</td>\n<td>存储容量已满</td>\n<td></td>\n</tr>\n<tr>\n<td>C0134</td>\n<td>不支持的数据格式</td>\n<td></td>\n</tr>\n<tr>\n<td>C0140</td>\n<td>配置服务出错</td>\n<td></td>\n</tr>\n<tr>\n<td>C0150</td>\n<td>网络资源服务出错</td>\n<td></td>\n</tr>\n<tr>\n<td>C0151</td>\n<td>VPN 服务出错</td>\n<td></td>\n</tr>\n<tr>\n<td>C0152</td>\n<td>CDN 服务出错</td>\n<td></td>\n</tr>\n<tr>\n<td>C0153</td>\n<td>域名解析服务出错</td>\n<td></td>\n</tr>\n<tr>\n<td>C0154</td>\n<td>网关服务出错</td>\n<td></td>\n</tr>\n<tr>\n<td>C0200</td>\n<td>第三方系统执行超时</td>\n<td>二级宏观错误码</td>\n</tr>\n<tr>\n<td>C0210</td>\n<td>RPC 执行超时</td>\n<td></td>\n</tr>\n<tr>\n<td>C0220</td>\n<td>消息投递超时</td>\n<td></td>\n</tr>\n<tr>\n<td>C0230</td>\n<td>缓存服务超时</td>\n<td></td>\n</tr>\n<tr>\n<td>C0240</td>\n<td>配置服务超时</td>\n<td></td>\n</tr>\n<tr>\n<td>C0250</td>\n<td>数据库服务超时</td>\n<td></td>\n</tr>\n<tr>\n<td>C0300</td>\n<td>数据库服务出错</td>\n<td>二级宏观错误码</td>\n</tr>\n<tr>\n<td>C0311</td>\n<td>表不存在</td>\n<td></td>\n</tr>\n<tr>\n<td>C0312</td>\n<td>列不存在</td>\n<td></td>\n</tr>\n<tr>\n<td>C0321</td>\n<td>多表关联中存在多个相同名称的列</td>\n<td></td>\n</tr>\n<tr>\n<td>C0331</td>\n<td>数据库死锁</td>\n<td></td>\n</tr>\n<tr>\n<td>C0341</td>\n<td>主键冲突</td>\n<td></td>\n</tr>\n<tr>\n<td>C0400</td>\n<td>第三方容灾系统被触发</td>\n<td>二级宏观错误码</td>\n</tr>\n<tr>\n<td>C0401</td>\n<td>第三方系统限流</td>\n<td></td>\n</tr>\n<tr>\n<td>C0402</td>\n<td>第三方功能降级</td>\n<td></td>\n</tr>\n<tr>\n<td>C0500</td>\n<td>通知服务出错</td>\n<td>二级宏观错误码</td>\n</tr>\n<tr>\n<td>C0501</td>\n<td>短信提醒服务失败</td>\n<td></td>\n</tr>\n<tr>\n<td>C0502</td>\n<td>语音提醒服务失败</td>\n<td></td>\n</tr>\n<tr>\n<td>C0503</td>\n<td>邮件提醒服务失败</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"异常码小结\"><a class=\"anchor\" href=\"#异常码小结\">#</a> 异常码小结</h4>\n<p>阿里巴巴开发手册中的 **<font color='red'>核心思想：规定常用的异常码，能复用就复用，实在不行就通过异常码平台去创建，先到先得</font>**。</p>\n<p>这里我是认可的，不过有一点感觉不是很合适，就是异常码的位数。</p>\n<p>阿里巴巴开发手册规定异常码位数 5 位，这对于一个公司项目很多的情况下，我觉得并不适用。所以，在刚果商城中，保留异常码基础概念，但是将 5 位扩展到 7 位。</p>\n<p><font color='red'><u>增加异常码的位数</u>可以有效防止因项目过多导致的异常码冲突问题</font>。</p>\n<h3 id=\"统一处理异常\"><a class=\"anchor\" href=\"#统一处理异常\">#</a> 统一处理异常</h3>\n<h1 id=\"从0到1实现\"><a class=\"anchor\" href=\"#从0到1实现\">#</a> 从 0 到 1 实现</h1>\n<h2 id=\"项目基础教学\"><a class=\"anchor\" href=\"#项目基础教学\">#</a> 项目基础教学</h2>\n<h3 id=\"梳理核心业务\"><a class=\"anchor\" href=\"#梳理核心业务\">#</a> 梳理核心业务</h3>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/1694240820160-615770c8-570f-4c86-9a9f-cad21b6f383a.png\" alt=\"1694240820160-615770c8-570f-4c86-9a9f-cad21b6f383a\" /></p>\n<h3 id=\"初始化数据库表\"><a class=\"anchor\" href=\"#初始化数据库表\">#</a> 初始化数据库表</h3>\n<blockquote>\n<p>-&gt;<a href=\"#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%9D%E5%A7%8B%E5%8C%96\"> 数据库初始化</a></p>\n</blockquote>\n<h3 id=\"梳理数据库表关系\"><a class=\"anchor\" href=\"#梳理数据库表关系\">#</a> 梳理数据库表关系</h3>\n<h4 id=\"用户管理\"><a class=\"anchor\" href=\"#用户管理\">#</a> 用户管理</h4>\n<h5 id=\"会员数据\"><a class=\"anchor\" href=\"#会员数据\">#</a> 会员数据</h5>\n<p>会员相关核心数据库表如下：</p>\n<ul>\n<li><code>t_user</code>  会员用户表：存储会员账号（用户名）、密码、证件号、邮箱、手机号等信息</li>\n<li><code>t_user_mail</code>  会员邮箱表：存储会员邮箱和用户名的关系</li>\n<li><code>t_user_phone</code>  会员手机号表：存储会员手机号和用户名的关系</li>\n</ul>\n<p>很多小伙伴比较疑惑，和用户直接相关的三张表之间的关系是什么？手机号和邮箱不是可以在 t_user 会员用户表中已经有了么，为什么还要再单独定义？</p>\n<p>这是因为<font color='red'>对 t_user 会员用户表进行了分库分表行为，分片键使用的 username 用户名进行拆分</font>。</p>\n<p>当我们执行新增语句时，没有分库分表前的数据长这个样子。</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">INSERT</span> <span class=\"token keyword\">INTO</span> <span class=\"token identifier\"><span class=\"token punctuation\">`</span>t_user<span class=\"token punctuation\">`</span></span> <span class=\"token punctuation\">(</span><span class=\"token identifier\"><span class=\"token punctuation\">`</span>username<span class=\"token punctuation\">`</span></span><span class=\"token punctuation\">,</span> <span class=\"token identifier\"><span class=\"token punctuation\">`</span>password<span class=\"token punctuation\">`</span></span><span class=\"token punctuation\">,</span> <span class=\"token identifier\"><span class=\"token punctuation\">`</span>real_name<span class=\"token punctuation\">`</span></span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">VALUES</span> <span class=\"token punctuation\">(</span><span class=\"token string\">'admin'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'admin123456'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'徐万里'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>通过分库分表中间件 ShardingSphere 修饰后，真正执行的 SQL 语句长这个样子。</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">INSERT</span> <span class=\"token keyword\">INTO</span> <span class=\"token identifier\"><span class=\"token punctuation\">`</span>t_user_10<span class=\"token punctuation\">`</span></span> <span class=\"token punctuation\">(</span><span class=\"token identifier\"><span class=\"token punctuation\">`</span>username<span class=\"token punctuation\">`</span></span><span class=\"token punctuation\">,</span> <span class=\"token identifier\"><span class=\"token punctuation\">`</span>password<span class=\"token punctuation\">`</span></span><span class=\"token punctuation\">,</span> <span class=\"token identifier\"><span class=\"token punctuation\">`</span>real_name<span class=\"token punctuation\">`</span></span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">VALUES</span> <span class=\"token punctuation\">(</span><span class=\"token string\">'admin'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'admin123456'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'徐万里'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>ShardingSphere 会通过分片键 username 用户名来确定数据在哪个库中的哪个表。所以，<font color='red'>分库分表后，每次增删改查都需要带上分片键用户名。不然的话，查询会请求所有库的所有用户表，新增、修改和删除会直接报错</font>。</p>\n<p>我们以新增<font color='red'>不带分片键</font>根据手机号查询用户举例，真实执行的 SQL 如下：</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">SELECT</span>  id<span class=\"token punctuation\">,</span>username<span class=\"token punctuation\">,</span>password<span class=\"token punctuation\">,</span>real_name<span class=\"token punctuation\">,</span>region<span class=\"token punctuation\">,</span>id_type<span class=\"token punctuation\">,</span>id_card <span class=\"token keyword\">AS</span> id_card<span class=\"token punctuation\">,</span>phone <span class=\"token keyword\">AS</span> phone<span class=\"token punctuation\">,</span>telephone<span class=\"token punctuation\">,</span>mail <span class=\"token keyword\">AS</span> mail<span class=\"token punctuation\">,</span>user_type<span class=\"token punctuation\">,</span>verify_status<span class=\"token punctuation\">,</span>post_code<span class=\"token punctuation\">,</span>address <span class=\"token keyword\">AS</span> address<span class=\"token punctuation\">,</span>deletion_time<span class=\"token punctuation\">,</span>create_time<span class=\"token punctuation\">,</span>update_time<span class=\"token punctuation\">,</span>del_flag  <span class=\"token keyword\">FROM</span> t_user_0 </pre></td></tr><tr><td data-num=\"2\"></td><td><pre> <span class=\"token keyword\">WHERE</span>  del_flag<span class=\"token operator\">=</span><span class=\"token number\">0</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token operator\">AND</span> <span class=\"token punctuation\">(</span>phone <span class=\"token operator\">=</span> ?<span class=\"token punctuation\">)</span> <span class=\"token keyword\">UNION</span> <span class=\"token keyword\">ALL</span> <span class=\"token keyword\">SELECT</span>  id<span class=\"token punctuation\">,</span>username<span class=\"token punctuation\">,</span>password<span class=\"token punctuation\">,</span>real_name<span class=\"token punctuation\">,</span>region<span class=\"token punctuation\">,</span>id_type<span class=\"token punctuation\">,</span>id_card <span class=\"token keyword\">AS</span> id_card<span class=\"token punctuation\">,</span>phone <span class=\"token keyword\">AS</span> phone<span class=\"token punctuation\">,</span>telephone<span class=\"token punctuation\">,</span>mail <span class=\"token keyword\">AS</span> mail<span class=\"token punctuation\">,</span>user_type<span class=\"token punctuation\">,</span>verify_status<span class=\"token punctuation\">,</span>post_code<span class=\"token punctuation\">,</span>address <span class=\"token keyword\">AS</span> address<span class=\"token punctuation\">,</span>deletion_time<span class=\"token punctuation\">,</span>create_time<span class=\"token punctuation\">,</span>update_time<span class=\"token punctuation\">,</span>del_flag  <span class=\"token keyword\">FROM</span> t_user_1 </pre></td></tr><tr><td data-num=\"5\"></td><td><pre> <span class=\"token keyword\">WHERE</span>  del_flag<span class=\"token operator\">=</span><span class=\"token number\">0</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token operator\">AND</span> <span class=\"token punctuation\">(</span>phone <span class=\"token operator\">=</span> ?<span class=\"token punctuation\">)</span> <span class=\"token keyword\">UNION</span> <span class=\"token keyword\">ALL</span> <span class=\"token keyword\">SELECT</span>  id<span class=\"token punctuation\">,</span>username<span class=\"token punctuation\">,</span>password<span class=\"token punctuation\">,</span>real_name<span class=\"token punctuation\">,</span>region<span class=\"token punctuation\">,</span>id_type<span class=\"token punctuation\">,</span>id_card <span class=\"token keyword\">AS</span> id_card<span class=\"token punctuation\">,</span>phone <span class=\"token keyword\">AS</span> phone<span class=\"token punctuation\">,</span>telephone<span class=\"token punctuation\">,</span>mail <span class=\"token keyword\">AS</span> mail<span class=\"token punctuation\">,</span>user_type<span class=\"token punctuation\">,</span>verify_status<span class=\"token punctuation\">,</span>post_code<span class=\"token punctuation\">,</span>address <span class=\"token keyword\">AS</span> address<span class=\"token punctuation\">,</span>deletion_time<span class=\"token punctuation\">,</span>create_time<span class=\"token punctuation\">,</span>update_time<span class=\"token punctuation\">,</span>del_flag  <span class=\"token keyword\">FROM</span> t_user_2 </pre></td></tr><tr><td data-num=\"8\"></td><td><pre> <span class=\"token keyword\">WHERE</span>  del_flag<span class=\"token operator\">=</span><span class=\"token number\">0</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token operator\">AND</span> <span class=\"token punctuation\">(</span>phone <span class=\"token operator\">=</span> ?<span class=\"token punctuation\">)</span> <span class=\"token keyword\">UNION</span> <span class=\"token keyword\">ALL</span> <span class=\"token keyword\">SELECT</span>  id<span class=\"token punctuation\">,</span>username<span class=\"token punctuation\">,</span>password<span class=\"token punctuation\">,</span>real_name<span class=\"token punctuation\">,</span>region<span class=\"token punctuation\">,</span>id_type<span class=\"token punctuation\">,</span>id_card <span class=\"token keyword\">AS</span> id_card<span class=\"token punctuation\">,</span>phone <span class=\"token keyword\">AS</span> phone<span class=\"token punctuation\">,</span>telephone<span class=\"token punctuation\">,</span>mail <span class=\"token keyword\">AS</span> mail<span class=\"token punctuation\">,</span>user_type<span class=\"token punctuation\">,</span>verify_status<span class=\"token punctuation\">,</span>post_code<span class=\"token punctuation\">,</span>address <span class=\"token keyword\">AS</span> address<span class=\"token punctuation\">,</span>deletion_time<span class=\"token punctuation\">,</span>create_time<span class=\"token punctuation\">,</span>update_time<span class=\"token punctuation\">,</span>del_flag  <span class=\"token keyword\">FROM</span> t_user_3 </pre></td></tr><tr><td data-num=\"11\"></td><td><pre> <span class=\"token keyword\">WHERE</span>  del_flag<span class=\"token operator\">=</span><span class=\"token number\">0</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token operator\">AND</span> <span class=\"token punctuation\">(</span>phone <span class=\"token operator\">=</span> ?<span class=\"token punctuation\">)</span> <span class=\"token keyword\">UNION</span> <span class=\"token keyword\">ALL</span> <span class=\"token keyword\">SELECT</span>  id<span class=\"token punctuation\">,</span>username<span class=\"token punctuation\">,</span>password<span class=\"token punctuation\">,</span>real_name<span class=\"token punctuation\">,</span>region<span class=\"token punctuation\">,</span>id_type<span class=\"token punctuation\">,</span>id_card <span class=\"token keyword\">AS</span> id_card<span class=\"token punctuation\">,</span>phone <span class=\"token keyword\">AS</span> phone<span class=\"token punctuation\">,</span>telephone<span class=\"token punctuation\">,</span>mail <span class=\"token keyword\">AS</span> mail<span class=\"token punctuation\">,</span>user_type<span class=\"token punctuation\">,</span>verify_status<span class=\"token punctuation\">,</span>post_code<span class=\"token punctuation\">,</span>address <span class=\"token keyword\">AS</span> address<span class=\"token punctuation\">,</span>deletion_time<span class=\"token punctuation\">,</span>create_time<span class=\"token punctuation\">,</span>update_time<span class=\"token punctuation\">,</span>del_flag  <span class=\"token keyword\">FROM</span> t_user_4 </pre></td></tr><tr><td data-num=\"14\"></td><td><pre> <span class=\"token keyword\">WHERE</span>  del_flag<span class=\"token operator\">=</span><span class=\"token number\">0</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>xxxxxx</pre></td></tr></table></figure><p>可以发现，<font color='red'>ShardingSphere 通过  <code>UNION ALL</code>  的方式查询了所有分表（<strong>读扩散问题</strong>）</font>。所以，<font color='red'>这种不带分片键的查询在实际业务中，是不被允许的</font>。</p>\n<p>那问题来了，12306 支持会员用户登录时根据手机号、邮箱以及用户名三种组合方式登录，手机号和邮箱查询性能岂不是很差，因为要查询所有表。为了解决这个问题，我们通过 **<font color='red'>路由表</font>**（即 <code>t_user_mail</code>  和 <code>t_user_phone</code> ）的方式解决这个问题，相关技术实现方案查看<a href=\"#%E6%B3%A8%E5%86%8C%E7%94%A8%E6%88%B7%E6%8E%A5%E5%8F%A3\">注册用户接口</a>。</p>\n<p>另外，还有两张用户相关扩展功能表：</p>\n<ul>\n<li><code>t_user_reuse</code>  用户名可复用表：<font color='red'>存储已被注销的可用用户名</font>。用来<font color='red'>解决业务难点中<a href=\"#%E4%BC%9A%E5%91%98%E6%B3%A8%E5%86%8C%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F\">采用布隆过滤器防止会员注册缓存穿透</a>中的布隆过滤器无法删除元素的问题</font>，具体可查看<a href=\"#%E6%B3%A8%E5%86%8C%E7%94%A8%E6%88%B7%E6%8E%A5%E5%8F%A3\">注册用户接口</a>。</li>\n<li><code>t_user_deletion</code>  用户证件注销表：<font color='red'>存储被注销过的证件号记录数据</font>。用来<font color='red'>解决用户恶意注销 12306 账号的问题</font>。假设，一个用户用一个证件号反复注册并注销，是不是应该把他拉入黑名单。因为用户名每次注册都可以使用新的，所以说我们只能针对证件号当做依据。目前系统的规则是，<font color='red'>如果同一个证件号注销超过 5 次，就拉入黑名单不再支持注册</font>。</li>\n</ul>\n<p>会员数据整体 UML 图如下所示：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20240127234324530.png\" alt=\"image-20240127234324530\" /></p>\n<h5 id=\"乘车人数据\"><a class=\"anchor\" href=\"#乘车人数据\">#</a> 乘车人数据</h5>\n<ul>\n<li><code>t_passenger</code> ：用户乘车人表</li>\n</ul>\n<p><font color='red'>一个用户可以添加多名乘车人</font>，可以用来买票时选择多人购票。会员用户表和用户乘车人之间通过会员用户名进行关联，一对多的关联关系。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20240128004043880.png\" alt=\"image-20240128004043880\" /></p>\n<h4 id=\"列车管理\"><a class=\"anchor\" href=\"#列车管理\">#</a> 列车管理</h4>\n<ul>\n<li><code>t_train</code> ：列车表，存储每天生成的行驶列车数据。</li>\n</ul>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/1691541217667-a9efa32b-3a2e-4a93-ab2c-bbe9553c9149.png\" alt=\"img\" /></p>\n<ul>\n<li><code>t_carriage</code> ：列车车厢表，存储每趟列车对应的车厢数据，包括车厢类型。</li>\n</ul>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/1691541261020-d4ce4732-3ef5-44a4-adaf-6c7e024949a1.png\" alt=\"img\" /></p>\n<ul>\n<li><code>t_train_station</code> ：列车站点表，存储列车行驶站点顺序表。比如下图中 G169 这趟列车，就需要在该表中存入 8 条数据，分别对应如下：\n<ul>\n<li>北京南 -&gt; 天津南</li>\n<li>天津南 -&gt; 沧州西</li>\n<li>沧州西 -&gt; 济南西</li>\n<li>...</li>\n<li>南京南 -&gt; 句容西</li>\n</ul>\n</li>\n</ul>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/1691541284979-d1571197-d010-4dec-8520-63166c91607a.png\" alt=\"img\" /></p>\n<ul>\n<li>\n<p><code>t_train_station_relation</code> ：列车站点关联表，存储列车行驶站点关联关系表。这是一个会把所有车站都会关联起来的数据集合，存储的数据模型如下所示：</p>\n<ul>\n<li>\n<p>北京南 -&gt; 天津西，北京南 -&gt; 沧州西，北京南 -&gt;xxx，北京南 -&gt; 句容西。</p>\n</li>\n<li>\n<p>天津西 -&gt; 沧州西，天津西 -&gt; 济南西，天津西 -&gt;xxx，天津西 -&gt; 句容西。</p>\n</li>\n<li>\n<p>沧州西 -&gt; 济南西，沧州西 -&gt; 徐州东，沧州西 -&gt;xxx，天津西 -&gt; 句容西。</p>\n</li>\n</ul>\n</li>\n</ul>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/1691541351094-386e23e5-f3cd-4a55-898c-4c9e922e72ad.png\" alt=\"img\" /></p>\n<ul>\n<li><code>t_train_station_price</code> ：列车站点价格表，存储列车站点关联关系不同座位价格表。<font color='red'>是在 t_train_station_relation 关系表的基础上，加入了两个字段，一个是价格，一个是座位类型</font>。因为列车行驶路线中，不同的站点间隔费用不一样，而且不同的座位费用也不一样。通过价格表整体区分出来。</li>\n</ul>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/1691541396876-6d3e2fea-6e0b-4808-9398-748a620744d0.png\" alt=\"img\" /></p>\n<p>列车表数据之间的关联关系如下图：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20240128010858945.png\" alt=\"image-20240128010858945\" /></p>\n<h4 id=\"订单管理\"><a class=\"anchor\" href=\"#订单管理\">#</a> 订单管理</h4>\n<ul>\n<li>\n<p><code>t_order</code> ：订单主表，用户购买的单次车票，就对应一个订单。但是<font color='red'>一个订单中可能会有多个乘车人，所以还会有订单明细表</font>。</p>\n</li>\n<li>\n<p><code>t_order_item</code> ：订单明细表，一个订单可能有多个乘车人，<font color='red'>多个乘车人就对应多个订单明细</font>。</p>\n</li>\n</ul>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/1691548149334-156addac-09b9-4cbc-a2fd-c85a38c3a149.png\" alt=\"img\" /></p>\n<ul>\n<li>\n<p><code>t_order_item_passenger</code> ：订单明细乘车人表，因为订单表和订单明细表分库分表规则所致，<font color='red'>乘车人无法查看本人车票订单，所以创建了这个关联表</font>。通过证件号关联订单。</p>\n<p>Q：为什么通过乘车人证件号关联？</p>\n<p>A：因为用户在添加乘车人进行购票时，有可能乘车人是没有注册账号的，所以只能通过证件号进行购票。那如果后来用户注册了账号，也就只能通过证件号去关联自己本人车票订单。</p>\n</li>\n</ul>\n<p>订单表数据之间的关联关系如下图：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20240128012004061.png\" alt=\"image-20240128012004061\" /></p>\n<h4 id=\"支付管理\"><a class=\"anchor\" href=\"#支付管理\">#</a> 支付管理</h4>\n<p>t_pay：订单支付表，存储用户支付车票相关数据。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20240128012059303.png\" alt=\"image-20240128012059303\" /></p>\n<h3 id=\"工程目录结构设计\"><a class=\"anchor\" href=\"#工程目录结构设计\">#</a> 工程目录结构设计</h3>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>├── checkstyle  <span class=\"token operator\">||</span> -- <span class=\"token comment\"># 代码格式检查组件</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>│   ├── 12306_checkstyle.xml  <span class=\"token operator\">||</span> -- <span class=\"token comment\"># 代码格式检查组件规则配置</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>│   └── 12306_checkstyle_suppression.xml  <span class=\"token operator\">||</span> -- <span class=\"token comment\"># 忽略代码格式检查组件规则配置</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>├── console-vue  <span class=\"token operator\">||</span> -- <span class=\"token comment\">#  12306 前端控制台项目</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>│   ├── README.md</pre></td></tr><tr><td data-num=\"6\"></td><td><pre>│   ├── babel.config.js</pre></td></tr><tr><td data-num=\"7\"></td><td><pre>│   ├── jsconfig.json</pre></td></tr><tr><td data-num=\"8\"></td><td><pre>│   ├── node_modules</pre></td></tr><tr><td data-num=\"9\"></td><td><pre>│   ├── package.json</pre></td></tr><tr><td data-num=\"10\"></td><td><pre>│   ├── public</pre></td></tr><tr><td data-num=\"11\"></td><td><pre>│   ├── src</pre></td></tr><tr><td data-num=\"12\"></td><td><pre>│   ├── vue.config.js</pre></td></tr><tr><td data-num=\"13\"></td><td><pre>│   └── yarn.lock</pre></td></tr><tr><td data-num=\"14\"></td><td><pre>├── dependencies  <span class=\"token operator\">||</span> -- <span class=\"token comment\">#  12306 后端项目全局依赖版本控制</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>│   └── pom.xml</pre></td></tr><tr><td data-num=\"16\"></td><td><pre>├── <span class=\"token function\">format</span>  <span class=\"token operator\">||</span> -- <span class=\"token comment\">#  12306 后端项目格式化组件</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>│   ├── 12306_spotless_formatter.xml  <span class=\"token operator\">||</span> -- <span class=\"token comment\">#  12306 后端项目格式化组件规则配置</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>│   └── license-header  <span class=\"token operator\">||</span> -- <span class=\"token comment\">#  12306 后端项目开源协议头格式化</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>├── frameworks  <span class=\"token operator\">||</span> -- <span class=\"token comment\">#  12306 基础架构组件库</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>│   ├── base  <span class=\"token operator\">||</span> -- <span class=\"token comment\">#  12306 顶层抽象基础组件</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>│   ├── bizs  <span class=\"token operator\">||</span> -- <span class=\"token comment\">#  12306 业务相关基础组件，比如用户上下文等</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>│   ├── cache  <span class=\"token operator\">||</span> -- <span class=\"token comment\"># 12306 缓存基础组件</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>│   ├── common  <span class=\"token operator\">||</span> -- <span class=\"token comment\"># 12306 公共工具包组件</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>│   ├── convention  <span class=\"token operator\">||</span> -- <span class=\"token comment\"># 12306 项目规约组件</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>│   ├── database  <span class=\"token operator\">||</span> -- <span class=\"token comment\"># 12306 数据库持久层组件</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>│   ├── designpattern  <span class=\"token operator\">||</span> -- <span class=\"token comment\"># 12306 设计模式抽象基础组件</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>│   ├── distributedid  <span class=\"token operator\">||</span> -- <span class=\"token comment\"># 12306 分布式 ID 基础组件</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>│   ├── idempotent  <span class=\"token operator\">||</span> -- <span class=\"token comment\"># 12306 幂等基础组件，包括 HTTP 及不同消息队列实现</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>│   ├── log  <span class=\"token operator\">||</span> -- <span class=\"token comment\"># 12306 日志打印基础组件库</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>│   └── web  <span class=\"token operator\">||</span> -- <span class=\"token comment\"># 12306 Web 相关基础组件库</span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre>│   ├── pom.xml</pre></td></tr><tr><td data-num=\"32\"></td><td><pre>├── resources  <span class=\"token operator\">||</span> -- <span class=\"token comment\"># 12306 项目数据库初始化及其它</span></pre></td></tr><tr><td data-num=\"33\"></td><td><pre>│   ├── data  <span class=\"token operator\">||</span> -- <span class=\"token comment\"># 12306 数据库数据初始化</span></pre></td></tr><tr><td data-num=\"34\"></td><td><pre>│   └── db  <span class=\"token operator\">||</span> -- <span class=\"token comment\"># 12306 数据库初始化</span></pre></td></tr><tr><td data-num=\"35\"></td><td><pre>├── services  <span class=\"token operator\">||</span> -- <span class=\"token comment\"># 12306 后端项目集合</span></pre></td></tr><tr><td data-num=\"36\"></td><td><pre>│   ├── aggregation-service  <span class=\"token operator\">||</span> -- <span class=\"token comment\"># 12306 SpringBoot 聚合模式服务</span></pre></td></tr><tr><td data-num=\"37\"></td><td><pre>│   ├── gateway-service  <span class=\"token operator\">||</span> -- <span class=\"token comment\"># 12306 网关服务</span></pre></td></tr><tr><td data-num=\"38\"></td><td><pre>│   ├── order-service  <span class=\"token operator\">||</span> -- <span class=\"token comment\"># 12306 订单服务</span></pre></td></tr><tr><td data-num=\"39\"></td><td><pre>│   ├── pay-service  <span class=\"token operator\">||</span> -- <span class=\"token comment\"># 12306 支付服务</span></pre></td></tr><tr><td data-num=\"40\"></td><td><pre>│   ├── ticket-service  <span class=\"token operator\">||</span> -- <span class=\"token comment\"># 12306 购票服务</span></pre></td></tr><tr><td data-num=\"41\"></td><td><pre>│   └── user-service  <span class=\"token operator\">||</span> -- <span class=\"token comment\"># 12306 用户服务</span></pre></td></tr><tr><td data-num=\"42\"></td><td><pre>│   ├── pom.xml</pre></td></tr><tr><td data-num=\"43\"></td><td><pre>└── tests  <span class=\"token operator\">||</span> -- <span class=\"token comment\"># 12306 单元测试集合</span></pre></td></tr><tr><td data-num=\"44\"></td><td><pre>│   ├── general  <span class=\"token operator\">||</span> -- <span class=\"token comment\"># 12306 通用单元测试</span></pre></td></tr><tr><td data-num=\"45\"></td><td><pre>└── pom.xml</pre></td></tr><tr><td data-num=\"46\"></td><td><pre>├── LICENSE</pre></td></tr><tr><td data-num=\"47\"></td><td><pre>├── mvnw</pre></td></tr><tr><td data-num=\"48\"></td><td><pre>├── mvnw.cmd</pre></td></tr><tr><td data-num=\"49\"></td><td><pre>├── pom.xml</pre></td></tr><tr><td data-num=\"50\"></td><td><pre>├── README.md</pre></td></tr></table></figure><h3 id=\"创建-springboot-单模块\"><a class=\"anchor\" href=\"#创建-springboot-单模块\">#</a> 创建 SpringBoot 单模块</h3>\n<p>SpringBoot 致力于简洁，让开发者写更少的配置文件，由于 **<font color='red'> Springboot 内置了 Servlet 容器</font>**，所以程序不需要像传统的方式，先部署到容器然后再启动容器。只需要打开创建包目录文件下  <code>$&#123;项目名&#125;Application.java</code>  文件运行  <code>main</code>  方法即可。</p>\n<h4 id=\"搭建-springboot-项目\"><a class=\"anchor\" href=\"#搭建-springboot-项目\">#</a> 搭建 SpringBoot 项目</h4>\n<p>SpringBoot 项目可以在  <code>https://start.spring.io/</code>  上创建项目进行下载，并在本地运行，也可在  <code>IDEA中</code>  进行构建。本次演示采用  <code>IDEA</code>  的方式。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/1689508925367-5e95955f-761e-406e-ac39-2b6b2b063336.png\" alt=\"img\" /></p>\n<p>选择合适的 SpringBoot 版本，这里选择  <code>2.7.13</code> 。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/1689508959199-bb69983e-b76a-45e6-96a0-4ed153f2d384.png\" alt=\"img\" /></p>\n<h5 id=\"结构目录\"><a class=\"anchor\" href=\"#结构目录\">#</a> 结构目录</h5>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/1689515316618-56839018-374e-4ad3-a772-d71df180a10f.png\" alt=\"img\" /></p>\n<p>如上图所示，SpringBoot 的基础结构一共是三个文件：</p>\n<ul>\n<li><code>src/main/java</code> ：程序开发以及主程序入口。</li>\n<li><code>src/main/resources</code> ：项目相关配置文件。</li>\n<li><code>src/test/java</code> ：测试程序文件。</li>\n</ul>\n<h5 id=\"pomxml-文件\"><a class=\"anchor\" href=\"#pomxml-文件\">#</a> pom.xml 文件</h5>\n<p>可以看到工程中有 Maven 的 Pom 文件，这里默认是依赖了 SpringBoot 的 <code>2.1.4版本</code> ，由于是测试，就不怂有什么问题，可以起到测试效果即可，构建项目不建议使用最新的；可以看到其中的一些依赖 jar 包比较少，因为这些都是 <code>内嵌</code> 到了 <code>SpringBoot 的 Jar 依赖</code> 。</p>\n<figure class=\"highlight xml\"><figcaption data-lang=\"XML\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token prolog\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>project</span> <span class=\"token attr-name\">xmlns</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>http://maven.apache.org/POM/4.0.0<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\"><span class=\"token namespace\">xmlns:</span>xsi</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>http://www.w3.org/2001/XMLSchema-instance<span class=\"token punctuation\">\"</span></span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>         <span class=\"token attr-name\"><span class=\"token namespace\">xsi:</span>schemaLocation</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>modelVersion</span><span class=\"token punctuation\">></span></span>4.0.0<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>modelVersion</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>parent</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>groupId</span><span class=\"token punctuation\">></span></span>org.springframework.boot<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>groupId</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>artifactId</span><span class=\"token punctuation\">></span></span>spring-boot-starter-parent<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>artifactId</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>version</span><span class=\"token punctuation\">></span></span>2.7.13<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>version</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>relativePath</span><span class=\"token punctuation\">/></span></span> <span class=\"token comment\">&lt;!-- lookup parent from repository --></span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>parent</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>groupId</span><span class=\"token punctuation\">></span></span>com.nageoffer.demo<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>groupId</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>artifactId</span><span class=\"token punctuation\">></span></span>spring-boot-demo<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>artifactId</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>version</span><span class=\"token punctuation\">></span></span>0.0.1-SNAPSHOT<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>version</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>name</span><span class=\"token punctuation\">></span></span>spring-boot-demo<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>name</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>description</span><span class=\"token punctuation\">></span></span>spring-boot-demo<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>description</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>properties</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>java.version</span><span class=\"token punctuation\">></span></span>1.8<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>java.version</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>properties</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>dependencies</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>dependency</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>            <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>groupId</span><span class=\"token punctuation\">></span></span>org.springframework.boot<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>groupId</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>            <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>artifactId</span><span class=\"token punctuation\">></span></span>spring-boot-starter-web<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>artifactId</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>dependency</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>dependency</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>            <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>groupId</span><span class=\"token punctuation\">></span></span>org.springframework.boot<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>groupId</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>            <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>artifactId</span><span class=\"token punctuation\">></span></span>spring-boot-starter-test<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>artifactId</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>            <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>scope</span><span class=\"token punctuation\">></span></span>test<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>scope</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>dependency</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>dependencies</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre></pre></td></tr><tr><td data-num=\"32\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>build</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"33\"></td><td><pre>        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>plugins</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"34\"></td><td><pre>            <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>plugin</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"35\"></td><td><pre>                <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>groupId</span><span class=\"token punctuation\">></span></span>org.springframework.boot<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>groupId</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"36\"></td><td><pre>                <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>artifactId</span><span class=\"token punctuation\">></span></span>spring-boot-maven-plugin<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>artifactId</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"37\"></td><td><pre>            <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>plugin</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"38\"></td><td><pre>        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>plugins</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"39\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>build</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"40\"></td><td><pre><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>project</span><span class=\"token punctuation\">></span></span></pre></td></tr></table></figure><h5 id=\"application\"><a class=\"anchor\" href=\"#application\">#</a> Application</h5>\n<p>其中有一个  <code>Application</code>  类，它就是程序的入口，右键选择 Run 即可启动该项目（ps：默认端口号为  <code>8080</code>  ）。</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">package</span> <span class=\"token namespace\">com<span class=\"token punctuation\">.</span>nageoffer<span class=\"token punctuation\">.</span>demo<span class=\"token punctuation\">.</span>springbootdemo</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">org<span class=\"token punctuation\">.</span>springframework<span class=\"token punctuation\">.</span>boot<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">SpringApplication</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">org<span class=\"token punctuation\">.</span>springframework<span class=\"token punctuation\">.</span>boot<span class=\"token punctuation\">.</span>autoconfigure<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">SpringBootApplication</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token annotation punctuation\">@SpringBootApplication</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">SpringBootDemoApplication</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>        <span class=\"token class-name\">SpringApplication</span><span class=\"token punctuation\">.</span><span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">SpringBootDemoApplication</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">,</span> args<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>在  <code>resources</code>  下面有一个  <code>application.properties</code>  配置文件，负责配置项目中的一下配置信息，默认为空；一般是采用  <code>.yml</code>  的形式进行配置，可以右键选择此配置文件将其后缀进行修改。</p>\n<h5 id=\"编写一个-controller\"><a class=\"anchor\" href=\"#编写一个-controller\">#</a> 编写一个 Controller</h5>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">/**</pre></td></tr><tr><td data-num=\"2\"></td><td><pre> * 等同于 @Controller 加上 @ResponseBody</pre></td></tr><tr><td data-num=\"3\"></td><td><pre> */</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token annotation punctuation\">@RestController</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">HelloController</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    </pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token comment\">/**</pre></td></tr><tr><td data-num=\"8\"></td><td><pre>     * 访问 /hello 或者 /hi 任何一个地址，都会返回同样的结果</pre></td></tr><tr><td data-num=\"9\"></td><td><pre>     * @GetMapping 等用于 @RequestMapping (method = RequestMethod.GET)</pre></td></tr><tr><td data-num=\"10\"></td><td><pre>     */</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token annotation punctuation\">@GetMapping</span><span class=\"token punctuation\">(</span>value <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span><span class=\"token string\">\"/hello\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"/hi\"</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token class-name\">String</span> <span class=\"token function\">say</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>        <span class=\"token keyword\">return</span> <span class=\"token string\">\"How are you?\"</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>运行  <code>SpringbootDemoApplication</code>  的  <code>main</code>  方法就会启动项目，打开浏览器输入网址： <code>localhost:8080/hi</code> ，就可以在浏览器上看到： <code>How are you?</code> 。</p>\n<h4 id=\"属性配置\"><a class=\"anchor\" href=\"#属性配置\">#</a> 属性配置</h4>\n<p>在 <code>appliction.yml</code>  文件中添加属性：</p>\n<figure class=\"highlight yaml\"><figcaption data-lang=\"YAML\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token key atrule\">girl</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>  <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> 小花</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>  <span class=\"token key atrule\">age</span><span class=\"token punctuation\">:</span> <span class=\"token number\">18</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>  <span class=\"token key atrule\">content</span><span class=\"token punctuation\">:</span> content<span class=\"token punctuation\">:</span>$<span class=\"token punctuation\">&#123;</span>name<span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span>age<span class=\"token punctuation\">:</span>$<span class=\"token punctuation\">&#123;</span>age<span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>在 Java 文件中，获取 name 属性，如下：</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token annotation punctuation\">@Value</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"$&#123;girl.name&#125;\"</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> name<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token annotation punctuation\">@Value</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"$&#123;girl.age&#125;\"</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token keyword\">private</span> <span class=\"token class-name\">Integer</span> age<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre></pre></td></tr><tr><td data-num=\"8\"></td><td><pre></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token annotation punctuation\">@Value</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"$&#123;girl.content&#125;\"</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> content<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>也可以通过  <code>ConfigurationProperties</code>  注解，将属性可以配置到  <code>Bean</code> ，通过  <code>Component</code>  注解将 Bean 注解到 Spring 容器中。</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token annotation punctuation\">@ConfigurationProperties</span><span class=\"token punctuation\">(</span>prefix<span class=\"token operator\">=</span><span class=\"token string\">\"girl\"</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token annotation punctuation\">@Component</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">GirlProperties</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> name<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token keyword\">private</span> <span class=\"token keyword\">int</span> age<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token class-name\">String</span> <span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>        <span class=\"token keyword\">return</span> name<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">setName</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> name<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> name<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">getAge</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>        <span class=\"token keyword\">return</span> age<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">setAge</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> age<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>age <span class=\"token operator\">=</span> age<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h4 id=\"小结-3\"><a class=\"anchor\" href=\"#小结-3\">#</a> 小结</h4>\n<p>使用 SpringBoot 可以 <code>非常方便</code> 、 <code>快速搭建</code> 项目，Spring 项目就相当于是个光脚大汉，boot…boot 给你双鞋总跑得过光脚的吧。另外 SpringBoot 也是构建 <code>Springcloud 微服务架构</code> 的基础。</p>\n<h3 id=\"创建-springboot-多模块\"><a class=\"anchor\" href=\"#创建-springboot-多模块\">#</a> 创建 SpringBoot 多模块</h3>\n<p>如果将 SpringBoot 框架用于单体项目，可能不存在多模块的情况。但是并不代表没有，因为父子模块并不局限于微服务，<strong>单体项目也可以进行明确的职责划分。</strong></p>\n<p>如果是构建微服务项目，基本上会对模块进行明确的划分，比如：</p>\n<ul>\n<li>抽象定义公共代码及 Util 封装进行引用。</li>\n<li>业务代码进行单独定义模块。</li>\n<li>数据库等 DB 操作相关抽离单独模块。</li>\n<li>提供外部平台调取的接口单独定义模块。</li>\n<li>...</li>\n</ul>\n<p><strong>上面的拆分也并非绝对</strong>，随着架构师对于项目结构的不同理解，可能会衍生出不同的模块。</p>\n<p>比较经典的就是 Dubbo 将接口 API 进行抽离提供生产者接口，打为 Jar 包供消费端调用。</p>\n<p>本篇文章也会从零到一创建 SpringBoot 父子模块的项目，<strong>演示聚合、继承的项目特性，并针对不引人注意的知识点进行讲解。</strong></p>\n<h4 id=\"软硬件环境\"><a class=\"anchor\" href=\"#软硬件环境\">#</a> 软硬件环境</h4>\n<p><strong>电脑：</strong> McaBook Pro</p>\n<p><strong>创建项目工具：</strong> IDEA 2023.1.2</p>\n<p><strong>JDK 版本：</strong> 还能再坚持 20 年的 JDK8（随着 JDK 17 的出现，不一定能坚持 20 年了）</p>\n<p><strong>Maven 版本：</strong> 3.5.4</p>\n<h4 id=\"创建-springboot-项目\"><a class=\"anchor\" href=\"#创建-springboot-项目\">#</a> 创建 SpringBoot 项目</h4>\n<p>1）首先打开 IDEA 工具，点击 + Create New Project。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/1689521114934-a8b99a5a-6b99-47b7-a6da-86272a49e985.png\" alt=\"img\" /></p>\n<p>2）选择 Spring Initializr（初始化），选择 Project SDK 1.8，使用默认的 SpringBoot 脚手架即可。创建项目详细信息，会逐一进行讲解。</p>\n<p>最终定义项目选项及配置名称如下，点击 Next 按钮继续进行。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/1689521167561-71cb3ad3-07a4-410f-8692-5b58f39a7f09.png\" alt=\"img\" /></p>\n<ul>\n<li>\n<p><strong>Group：</strong> 项目组织唯一的标识符，实际<font color='red'>对应 Java 的包的结构</font>，是 main 目录里 Java 的目录结构。</p>\n</li>\n<li>\n<ul>\n<li>Group 也就是 groupId，分为多个段；一般情况下 <strong>第一段为域，第二段为公司，第三段为项目名称。</strong></li>\n<li>以 Nacos 源码进行举例，Group 为 com.alibaba.nacos。</li>\n<li>com 为商业组织，alibaba 为公司名称，nacos 就是项目名称。</li>\n</ul>\n</li>\n<li>\n<p><strong>Artifact：</strong> 项目的唯一的标识符，实际<font color='red'>对应项目的名称</font>，就是项目根目录的名称。</p>\n</li>\n<li>\n<ul>\n<li>Artifact 即为 artifactId，还是以 Nacos 举例，因为最近在看它。</li>\n<li>Nacos 中不同的功能组件的 artifactId 各不相同，比如权限相关的子模块就是 nacos-auth，客户端相关是 nacos-client，具体到了项目功能组件。</li>\n</ul>\n</li>\n<li>\n<p><strong>Type：</strong> 分为四种不同的类型，日常我们选择默认第一条就行，<strong>也就是 Maven Project。</strong></p>\n</li>\n<li>\n<p><strong>Language：</strong> 开发语言的话自然就是默认的 Java。</p>\n</li>\n<li>\n<p><strong>Packaging：</strong> 打包方式，分为 War 包 和 Jar 包，这里选择 Jar 包。</p>\n</li>\n<li>\n<p><strong>Java Version：</strong> 选择 Java 的一个版本，再坚持 20 年的 JDK 1.8。</p>\n</li>\n<li>\n<p><strong>Version：</strong> <font color='red'>当前项目的一个版本</font>，SNAPSHOT 为快照的意思。开发时一般使用此类型，因为对于 Maven 仓库的同步较为友好，有不同纬度的同步选择。</p>\n</li>\n<li>\n<p><strong>Name：</strong> 定义项目名称。</p>\n</li>\n<li>\n<p><strong>Description：</strong> 定义项目描述信息，帮助别人更好的了解项目。</p>\n</li>\n<li>\n<p><strong>Package：</strong> <font color='red'>定义 main.java 目录下的结构</font>。</p>\n</li>\n</ul>\n<p>3）选择 SpringBoot 版本信息以及 Pom.xml 文件依赖组件。</p>\n<p>这里选择的 SpringBoot 版本是 <strong>2.7.13</strong>，选择了 <strong>Spring Web</strong>  当作 Maven 依赖项。后续会使用发布 Web 测试项目整体是否成功，接下来点击 Next 继续进行下一步。</p>\n<p><img data-src=\"https://cdn.nlark.com/yuque/0/2023/png/331027/1689521341373-f1ea8f56-b810-439b-b48b-3b04e0471d64.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_46%2Ctext_5pCc77yabmFnZW9mZmVyLmNvbQ%3D%3D%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10\" alt=\"img\" /></p>\n<p>4）确认无误后点击 Create，一个标准的 SpringBoot 项目就产生了。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/1689521464212-c7cfdcb3-5862-4e06-87fc-f886a6b3b7ac.png\" alt=\"img\" /></p>\n<h4 id=\"构建子-module\"><a class=\"anchor\" href=\"#构建子-module\">#</a> 构建子 Module</h4>\n<p>1）顶级项目地址右键 <strong>New -&gt; Module</strong>，创建子 Module。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/1689521551486-7ae60202-9e9d-419f-adab-a536751aa372.png\" alt=\"img\" /></p>\n<p>2）这里就是重复上述在创建 SpringBoot 项目时的步骤，<font color='red'>Group 与 Parent 项目保持一致即可，Artifact 修改为 Module 项目作用域名即可</font>，Next 下一步。</p>\n<p><img data-src=\"https://cdn.nlark.com/yuque/0/2023/png/331027/1689521649526-29681593-4c1b-4937-aad4-96175a0d25c9.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_80%2Ctext_5pCc77yabmFnZW9mZmVyLmNvbQ%3D%3D%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10\" alt=\"img\" /></p>\n<p>3）配置可按照需求进行选择，因为不同的 Module 需要引用不同的 Pom 依赖，后面会与 Parent 保持一个交互。</p>\n<p><img data-src=\"https://cdn.nlark.com/yuque/0/2023/png/331027/1689521714635-09c3d4e3-d629-41d7-a211-d3b93b3d315f.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_80%2Ctext_5pCc77yabmFnZW9mZmVyLmNvbQ%3D%3D%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10\" alt=\"img\" /></p>\n<p>4）最终结构目录如下，项目已成功创建，<font color='red'>原本根目录下 src 目录删除即可</font>。后续我们要修改其中的 Pom.xml 使其成为真正的父子项目。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/1689521977755-33b550cc-083d-48de-b384-339df8b0406b.png\" alt=\"img\" /></p>\n<h4 id=\"建立父子-module-依赖\"><a class=\"anchor\" href=\"#建立父子-module-依赖\">#</a> 建立父子 Module 依赖</h4>\n<p>如果将建立的 Parent 项目与后面创建的 Module  产生关联，需要改动以下几点：</p>\n<ul>\n<li><font color='red'>修改 Parent 项目  <code>Pom.xml</code>  的 packaging 标签打包方式为 pom</font>。</li>\n<li><font color='red'>修改 Module 项目  <code>Pom.xml</code>  文件依赖 Parent 项目</font>。</li>\n<li><font color='red'>删除不必要文件，并梳理  <code>Pom.xml</code>  依赖上下级关系</font>。</li>\n</ul>\n<h5 id=\"修改-parent-项目-packaging\"><a class=\"anchor\" href=\"#修改-parent-项目-packaging\">#</a> 修改 Parent 项目 packaging</h5>\n<p>打开 Parent 项目的根 Pom.xml 文件，新增下方代码：</p>\n<figure class=\"highlight xml\"><figcaption data-lang=\"XML\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>packaging</span><span class=\"token punctuation\">></span></span>pom<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>packaging</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>modules</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>module</span><span class=\"token punctuation\">></span></span>bootdemo-remote-api<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>module</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>modules</span><span class=\"token punctuation\">></span></span></pre></td></tr></table></figure><p>packaging 包含三个值 <strong>Jar、War、Pom</strong>，默认 Jar 的方式。modules 代表了 Parent 项目下的子 Module，体现了聚合的思想。</p>\n<ul>\n<li><strong>Jar：</strong> <font color='red'>内部调用</font>或<font color='red'>作为服务</font>进行发布使用。</li>\n<li><strong>War：</strong> <font color='red'>需要部署的项目</font>。</li>\n<li>**Pom：** 宏观而言既没有代码需要测试或者编译，也没有资源需要处理。寓意为一个<font color='red'>父级项目</font>，一般作为项目聚合和依赖传递使用。</li>\n</ul>\n<p>这里把 Parent 项目的  <code>Pom.xml</code>  配置复制出来，帮助大家后续排查问题。</p>\n<figure class=\"highlight xml\"><figcaption data-lang=\"XML\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token prolog\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>project</span> <span class=\"token attr-name\">xmlns</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>http://maven.apache.org/POM/4.0.0<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\"><span class=\"token namespace\">xmlns:</span>xsi</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>http://www.w3.org/2001/XMLSchema-instance<span class=\"token punctuation\">\"</span></span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>         <span class=\"token attr-name\"><span class=\"token namespace\">xsi:</span>schemaLocation</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>modelVersion</span><span class=\"token punctuation\">></span></span>4.0.0<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>modelVersion</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>parent</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>groupId</span><span class=\"token punctuation\">></span></span>org.springframework.boot<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>groupId</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>artifactId</span><span class=\"token punctuation\">></span></span>spring-boot-starter-parent<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>artifactId</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>version</span><span class=\"token punctuation\">></span></span>2.7.13<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>version</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>relativePath</span><span class=\"token punctuation\">/></span></span> <span class=\"token comment\">&lt;!-- lookup parent from repository --></span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>parent</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>groupId</span><span class=\"token punctuation\">></span></span>com.nageoffer.demo<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>groupId</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>artifactId</span><span class=\"token punctuation\">></span></span>spring-boot-module-demo<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>artifactId</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>version</span><span class=\"token punctuation\">></span></span>0.0.1-SNAPSHOT<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>version</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>name</span><span class=\"token punctuation\">></span></span>spring-boot-module-demo<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>name</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>description</span><span class=\"token punctuation\">></span></span>spring-boot-module-demo<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>description</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>    <span class=\"token comment\">&lt;!-- 新增开始 --></span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>packaging</span><span class=\"token punctuation\">></span></span>pom<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>packaging</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>modules</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>module</span><span class=\"token punctuation\">></span></span>bootdemo-remote-api<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>module</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>modules</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>    <span class=\"token comment\">&lt;!-- 新增结束 --></span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>properties</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>java.version</span><span class=\"token punctuation\">></span></span>1.8<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>java.version</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>properties</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>dependencies</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>dependency</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>            <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>groupId</span><span class=\"token punctuation\">></span></span>org.springframework.boot<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>groupId</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>            <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>artifactId</span><span class=\"token punctuation\">></span></span>spring-boot-starter-web<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>artifactId</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>dependency</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre></pre></td></tr><tr><td data-num=\"31\"></td><td><pre>        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>dependency</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"32\"></td><td><pre>            <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>groupId</span><span class=\"token punctuation\">></span></span>org.springframework.boot<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>groupId</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"33\"></td><td><pre>            <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>artifactId</span><span class=\"token punctuation\">></span></span>spring-boot-starter-test<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>artifactId</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"34\"></td><td><pre>            <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>scope</span><span class=\"token punctuation\">></span></span>test<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>scope</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"35\"></td><td><pre>        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>dependency</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"36\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>dependencies</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"37\"></td><td><pre></pre></td></tr><tr><td data-num=\"38\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>build</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"39\"></td><td><pre>        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>plugins</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"40\"></td><td><pre>            <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>plugin</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"41\"></td><td><pre>                <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>groupId</span><span class=\"token punctuation\">></span></span>org.springframework.boot<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>groupId</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"42\"></td><td><pre>                <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>artifactId</span><span class=\"token punctuation\">></span></span>spring-boot-maven-plugin<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>artifactId</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"43\"></td><td><pre>            <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>plugin</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"44\"></td><td><pre>        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>plugins</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"45\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>build</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"46\"></td><td><pre><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>project</span><span class=\"token punctuation\">></span></span></pre></td></tr></table></figure><p><strong>spring-boot-maven-plugin</strong> 的作用是运行 <strong>mvn package</strong> 时会将项目打包为可运行的 jar 包，<strong>java -jar</strong> 运行即可。</p>\n<p>如果不加这个 <strong>plugins</strong>，<strong>java -jar xxx.jar</strong> 会报出如下错误。</p>\n<pre><code class=\"language-Java\">xxx/target/bootdemo-remote-api-0.0.1-SNAPSHOT.jar中没有主清单属性\n</code></pre>\n<h5 id=\"修改-module-pomxml-信息\"><a class=\"anchor\" href=\"#修改-module-pomxml-信息\">#</a> 修改 Module Pom.xml 信息</h5>\n<p>创建后的 Module 项目的 Parent 信息是 SpringBoot 配置，修改后如下：</p>\n<figure class=\"highlight xml\"><figcaption data-lang=\"XML\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token prolog\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>project</span> <span class=\"token attr-name\">xmlns</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>http://maven.apache.org/POM/4.0.0<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\"><span class=\"token namespace\">xmlns:</span>xsi</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>http://www.w3.org/2001/XMLSchema-instance<span class=\"token punctuation\">\"</span></span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>\t<span class=\"token attr-name\"><span class=\"token namespace\">xsi:</span>schemaLocation</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>\t<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>modelVersion</span><span class=\"token punctuation\">></span></span>4.0.0<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>modelVersion</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>\t<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>parent</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>\t\t<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>groupId</span><span class=\"token punctuation\">></span></span>com.nageoffer.demo<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>groupId</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>\t\t<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>artifactId</span><span class=\"token punctuation\">></span></span>spring-boot-module-demo<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>artifactId</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>\t\t<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>version</span><span class=\"token punctuation\">></span></span>0.0.1-SNAPSHOT<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>version</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>\t<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>parent</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>\t<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>artifactId</span><span class=\"token punctuation\">></span></span>bootdemo-remote-api<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>artifactId</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>\t<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>version</span><span class=\"token punctuation\">></span></span>0.0.1-SNAPSHOT<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>version</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>\t<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>name</span><span class=\"token punctuation\">></span></span>bootdemo-remote-api<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>name</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>\t<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>description</span><span class=\"token punctuation\">></span></span>bootdemo-remote-api<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>description</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>\t<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>properties</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>\t\t<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>java.version</span><span class=\"token punctuation\">></span></span>1.8<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>java.version</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>\t<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>properties</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>project</span><span class=\"token punctuation\">></span></span></pre></td></tr></table></figure><h5 id=\"删除不必要文件\"><a class=\"anchor\" href=\"#删除不必要文件\">#</a> 删除不必要文件</h5>\n<p><font color='red'>删除 spring-boot-module-demo 项目下 src 包</font>，因为它作为聚合型项目，不会产生业务数据以及相关配置。</p>\n<p>另外说一下  <code>dependencies</code>  和  <code>dependencyManagement</code>  标签做一个讲解。</p>\n<p><strong>1）dependencies</strong></p>\n<p>如果 Parent 项目中使用  <code>dependencies</code>  标签，<font color='red'>标签内的依赖默认传递子 Module，不需要子 Module 进行显示书写依赖</font>。</p>\n<p><strong>2）dependencyManagement</strong></p>\n<p><code>dependencyManagement</code>  与 <code>dependencies</code>  不同的是，<strong><font color='red'>标签内的依赖不会默认传递子 Module，其作用只是为了统一版本声明，需要在子 Module 的 pom 文件中进行显示书写依赖</font></strong>。</p>\n<h4 id=\"项目继承关系\"><a class=\"anchor\" href=\"#项目继承关系\">#</a> 项目继承关系</h4>\n<p>我们按照 [构建子 Module](# 构建子 Module) 章节的内容，构建出如下所述的子 Module：</p>\n<figure class=\"highlight xml\"><figcaption data-lang=\"XML\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>groupId</span><span class=\"token punctuation\">></span></span>com.nageoffer.demo<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>groupId</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>artifactId</span><span class=\"token punctuation\">></span></span>bootdemo-biz<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>artifactId</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>version</span><span class=\"token punctuation\">></span></span>0.0.1-SNAPSHOT<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>version</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>name</span><span class=\"token punctuation\">></span></span>bootdemo-biz<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>name</span><span class=\"token punctuation\">></span></span></pre></td></tr></table></figure><p>然后修改 <strong>bootdemo-biz</strong> 子 Module 的 Pom.xml 文件如下：</p>\n<figure class=\"highlight xml\"><figcaption data-lang=\"XML\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token prolog\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>project</span> <span class=\"token attr-name\">xmlns</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>http://maven.apache.org/POM/4.0.0<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\"><span class=\"token namespace\">xmlns:</span>xsi</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>http://www.w3.org/2001/XMLSchema-instance<span class=\"token punctuation\">\"</span></span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>         <span class=\"token attr-name\"><span class=\"token namespace\">xsi:</span>schemaLocation</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>modelVersion</span><span class=\"token punctuation\">></span></span>4.0.0<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>modelVersion</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>parent</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>groupId</span><span class=\"token punctuation\">></span></span>com.nageoffer.demo<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>groupId</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>artifactId</span><span class=\"token punctuation\">></span></span>spring-boot-module-demo<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>artifactId</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>version</span><span class=\"token punctuation\">></span></span>0.0.1-SNAPSHOT<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>version</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>parent</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>artifactId</span><span class=\"token punctuation\">></span></span>bootdemo-biz<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>artifactId</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>version</span><span class=\"token punctuation\">></span></span>0.0.1-SNAPSHOT<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>version</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>name</span><span class=\"token punctuation\">></span></span>bootdemo-biz<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>name</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>description</span><span class=\"token punctuation\">></span></span>bootdemo-biz<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>description</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>properties</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>java.version</span><span class=\"token punctuation\">></span></span>1.8<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>java.version</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>properties</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>dependencies</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>dependency</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>            <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>groupId</span><span class=\"token punctuation\">></span></span>$&#123;project.groupId&#125;<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>groupId</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>            <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>artifactId</span><span class=\"token punctuation\">></span></span>bootdemo-remote-api<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>artifactId</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>            <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>version</span><span class=\"token punctuation\">></span></span>$&#123;project.version&#125;<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>version</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>dependency</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>dependency</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>            <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>groupId</span><span class=\"token punctuation\">></span></span>org.springframework.boot<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>groupId</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>            <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>artifactId</span><span class=\"token punctuation\">></span></span>spring-boot-starter-test<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>artifactId</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>            <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>scope</span><span class=\"token punctuation\">></span></span>test<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>scope</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>dependency</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>dependencies</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>project</span><span class=\"token punctuation\">></span></span></pre></td></tr></table></figure><p>通过继承关系的设置，<strong>bootdemo-remote-api</strong> 中的代码就可以被 <strong>bootdemo-biz</strong> Module 项目进行引用。</p>\n<h4 id=\"发布-web-服务\"><a class=\"anchor\" href=\"#发布-web-服务\">#</a> 发布 WEB 服务</h4>\n<p>在 Parent 项目 Pom.xml  <code>dependencies</code>  标签中定义了 <strong>spring-boot-starter-web</strong> 依赖，直接使用 web 相关内容即可。</p>\n<p>我们在 <strong>bootdemo-biz</strong> 中创建 Controller 控制器：</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token annotation punctuation\">@RestController</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">DemoController</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token annotation punctuation\">@GetMapping</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"/echo/&#123;name&#125;\"</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token class-name\">String</span> <span class=\"token function\">sayHello</span><span class=\"token punctuation\">(</span><span class=\"token annotation punctuation\">@PathVariable</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"name\"</span><span class=\"token punctuation\">)</span> <span class=\"token class-name\">String</span> name<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>        <span class=\"token keyword\">return</span> <span class=\"token string\">\"Hello World \"</span> <span class=\"token operator\">+</span> name<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>启动后端项目成功后，浏览器输入 <span class=\"exturl\" data-url=\"aHR0cDovL2xvY2FsaG9zdDo4MDgwL2VjaG8vbWFodWE=\">http://localhost:8080/echo/mahua</span> 请求后端服务。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/1689520889180-58671f85-666f-44d6-87e7-26c38d5908e5.png\" alt=\"img\" /></p>\n<h2 id=\"项目开发规范\"><a class=\"anchor\" href=\"#项目开发规范\">#</a> 项目开发规范</h2>\n<h3 id=\"编程规范\"><a class=\"anchor\" href=\"#编程规范\">#</a> 编程规范</h3>\n<h4 id=\"方法命名\"><a class=\"anchor\" href=\"#方法命名\">#</a> 方法命名</h4>\n<h5 id=\"获取单个对象的方法用-get-作前缀\"><a class=\"anchor\" href=\"#获取单个对象的方法用-get-作前缀\">#</a> 获取单个对象的方法用 get 作前缀</h5>\n<p>例如：查询单个用户  <code>getStudent</code> ，按照 ID 查询单个用户  <code>getStudentById</code> 。</p>\n<h5 id=\"获取多个对象的方法用-list-作前缀\"><a class=\"anchor\" href=\"#获取多个对象的方法用-list-作前缀\">#</a> 获取多个对象的方法用 list 作前缀</h5>\n<p>例如：按照 IDS 查询多个用户， <code>listStudentByIds</code> 。</p>\n<h5 id=\"获取统计值的方法用-count-作前缀\"><a class=\"anchor\" href=\"#获取统计值的方法用-count-作前缀\">#</a> 获取统计值的方法用 count 作前缀</h5>\n<p>例如：统计全量用户， <code>countUser</code> 。</p>\n<h5 id=\"插入的方法用-save-作前缀\"><a class=\"anchor\" href=\"#插入的方法用-save-作前缀\">#</a> 插入的方法用 save 作前缀</h5>\n<p>例如：新增用户， <code>saveUser</code> 。</p>\n<h5 id=\"删除的方法用-remove-作前缀\"><a class=\"anchor\" href=\"#删除的方法用-remove-作前缀\">#</a> 删除的方法用 remove 作前缀</h5>\n<p>例如：删除用户， <code>removeUser</code> 。</p>\n<h5 id=\"修改的方法用-update-作前缀\"><a class=\"anchor\" href=\"#修改的方法用-update-作前缀\">#</a> 修改的方法用 update 作前缀</h5>\n<p>例如：修改用户， <code>updateUser</code> 。</p>\n<h4 id=\"领域模型命名规约\"><a class=\"anchor\" href=\"#领域模型命名规约\">#</a> 领域模型命名规约</h4>\n<h5 id=\"数据对象\"><a class=\"anchor\" href=\"#数据对象\">#</a> 数据对象</h5>\n<p>xxxDO，xxx 即为数据表名。</p>\n<h5 id=\"数据传输对象\"><a class=\"anchor\" href=\"#数据传输对象\">#</a> 数据传输对象</h5>\n<p>xxxDTO，xxx 为业务领域相关的名称。</p>\n<h5 id=\"展示对象\"><a class=\"anchor\" href=\"#展示对象\">#</a> 展示对象</h5>\n<p>xxxVO，xxx 一般为网页名称。</p>\n<h5 id=\"注意事项\"><a class=\"anchor\" href=\"#注意事项\">#</a> 注意事项</h5>\n<p>POJO 是 DO/DTO/BO/VO 的统称，禁止命名成 xxxPOJO。</p>\n<h4 id=\"api-路径规约\"><a class=\"anchor\" href=\"#api-路径规约\">#</a> API 路径规约</h4>\n<h5 id=\"get-方法尽量把-id-等变量放到路径上\"><a class=\"anchor\" href=\"#get-方法尽量把-id-等变量放到路径上\">#</a> Get 方法尽量把 ID 等变量放到路径上。</h5>\n<p>例如：获取指定用户的信息。</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token operator\">/</span>user<span class=\"token operator\">/</span><span class=\"token punctuation\">&#123;</span>id<span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h5 id=\"多个不可分割的单词使用中划线拼接\"><a class=\"anchor\" href=\"#多个不可分割的单词使用中划线拼接\">#</a> 多个不可分割的单词，使用中划线拼接。</h5>\n<p>例如：用户验证码接口。</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token operator\">/</span>user<span class=\"token operator\">/</span>verify<span class=\"token operator\">-</span>code</pre></td></tr></table></figure><h5 id=\"参数使用驼峰拼写\"><a class=\"anchor\" href=\"#参数使用驼峰拼写\">#</a> 参数使用驼峰拼写。</h5>\n<p>例如：获取指定用户购买的指定商品。</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token operator\">/</span>order<span class=\"token operator\">/</span><span class=\"token punctuation\">&#123;</span>productId<span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h5 id=\"指向集合的复数名称\"><a class=\"anchor\" href=\"#指向集合的复数名称\">#</a> 指向集合的复数名称。</h5>\n<p>例如：获取所有用户列表接口。</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token operator\">/</span>users</pre></td></tr></table></figure><h5 id=\"不要使用动词定义-url\"><a class=\"anchor\" href=\"#不要使用动词定义-url\">#</a> 不要使用动词定义 URL</h5>\n<p>错误示例：</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token operator\">/</span>update<span class=\"token operator\">/</span>user</pre></td></tr></table></figure><p>或者：</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token operator\">/</span>get<span class=\"token operator\">/</span>user</pre></td></tr></table></figure><p>正确应该<font color='red'>结合 HTTP 方法的语义来定义 URL 的行为</font>。</p>\n<p>比如说获取用户：</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token constant\">GET</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token operator\">/</span>user<span class=\"token operator\">/</span><span class=\"token punctuation\">&#123;</span>id<span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>添加用户：</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token constant\">POST</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token operator\">/</span>user</pre></td></tr></table></figure><p>修改用户：</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token constant\">PUT</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token operator\">/</span>user</pre></td></tr></table></figure><h5 id=\"对非资源-url-使用动词\"><a class=\"anchor\" href=\"#对非资源-url-使用动词\">#</a> 对非资源 URL 使用动词</h5>\n<p>如果有一个接口，并不是 CRUD 操作，这种情况可以使用动词。</p>\n<p>例如：向用户发送邮件接口。</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token operator\">/</span>user<span class=\"token operator\">/</span><span class=\"token punctuation\">&#123;</span>id<span class=\"token punctuation\">&#125;</span><span class=\"token operator\">/</span>send<span class=\"token operator\">-</span>mail</pre></td></tr></table></figure><h5 id=\"在嵌套资源的-url-中使用关系\"><a class=\"anchor\" href=\"#在嵌套资源的-url-中使用关系\">#</a> 在嵌套资源的 URL 中使用关系</h5>\n<p>获取指定订单中所有商品列表。</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token constant\">GET</span> <span class=\"token operator\">/</span>order<span class=\"token operator\">/</span><span class=\"token punctuation\">&#123;</span>id<span class=\"token punctuation\">&#125;</span><span class=\"token operator\">/</span>products</pre></td></tr></table></figure><p>获取指定订单中所有指定商品信息。</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token constant\">GET</span> <span class=\"token operator\">/</span>order<span class=\"token operator\">/</span><span class=\"token punctuation\">&#123;</span>orderId<span class=\"token punctuation\">&#125;</span><span class=\"token operator\">/</span>product<span class=\"token operator\">/</span><span class=\"token punctuation\">&#123;</span>productId<span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h4 id=\"注释规范\"><a class=\"anchor\" href=\"#注释规范\">#</a> 注释规范</h4>\n<h5 id=\"注释说明意图即可无需补充冗余字段\"><a class=\"anchor\" href=\"#注释说明意图即可无需补充冗余字段\">#</a> 注释说明意图即可，无需补充冗余字段</h5>\n<p>**【强制】**Class、Interface、Enum、@interface 等文件类型，<font color='red'>类上注释仅需说明类的意图即可，不需要补充时间和创建人</font>，因为往往开发代码的不止是一个人，容易造成信息干扰。需要的话，查看提交记录即可。</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">/**</pre></td></tr><tr><td data-num=\"2\"></td><td><pre> * 适配第三方框架的线程池</pre></td></tr><tr><td data-num=\"3\"></td><td><pre> */</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">interface</span> <span class=\"token class-name\">ThreadPoolAdapter</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h5 id=\"方法上需要添加注释\"><a class=\"anchor\" href=\"#方法上需要添加注释\">#</a> 方法上需要添加注释</h5>\n<p>**【强制】** 接口的方法上需添加注释，并<font color='red'>说明清楚方法的意图（接口实现类无需注释）</font>；必要时描述  <code>@param</code>   <code>@return</code> 。</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">/**</pre></td></tr><tr><td data-num=\"2\"></td><td><pre> * 适配第三方框架的线程池</pre></td></tr><tr><td data-num=\"3\"></td><td><pre> */</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">interface</span> <span class=\"token class-name\">ThreadPoolAdapter</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token comment\">/**</pre></td></tr><tr><td data-num=\"7\"></td><td><pre>     * 修改框架线程池的核心参数</pre></td></tr><tr><td data-num=\"8\"></td><td><pre>     *</pre></td></tr><tr><td data-num=\"9\"></td><td><pre>     * @param threadPoolBaseInfo  修改线程池的基础参数</pre></td></tr><tr><td data-num=\"10\"></td><td><pre>     * @return  线程池核心参数修改结果</pre></td></tr><tr><td data-num=\"11\"></td><td><pre>     */</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    <span class=\"token keyword\">boolean</span> <span class=\"token function\">updateThreadPool</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">ThreadPoolBaseInfo</span> threadPoolBaseInfo<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>如果方法为内部引用方法，并且方法名称见名知意，无需方法注释。</p>\n<h5 id=\"方法块内部注释规范\"><a class=\"anchor\" href=\"#方法块内部注释规范\">#</a> 方法块内部注释规范</h5>\n<p>**【强制】** 方法内部的注释，应该新起一行，而不是跟在代码后面。</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>正例：</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token comment\">// 刷新动态线程池参数</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token function\">refreshDynamicPool</span><span class=\"token punctuation\">(</span>parameter<span class=\"token punctuation\">,</span> executor<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>反例：</pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token function\">refreshDynamicPool</span><span class=\"token punctuation\">(</span>parameter<span class=\"token punctuation\">,</span> executor<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 刷新动态线程池参数</span></pre></td></tr></table></figure><h5 id=\"方法命名说明方法本身意图\"><a class=\"anchor\" href=\"#方法命名说明方法本身意图\">#</a> 方法命名说明方法本身意图</h5>\n<p>**【强制】** 私有方法尽量通过方法命名说明方法语义。</p>\n<h4 id=\"代码开发规约\"><a class=\"anchor\" href=\"#代码开发规约\">#</a> 代码开发规约</h4>\n<p>**【强制】** 类、方法和变量的命名要做到顾名思义，避免使用缩写。</p>\n<p>**【强制】** 静态变量使用大写，多个单词使用下划线连接。示例：MESSAGE_CENTER_SEND_TYPR。</p>\n<p>**【强制】** 捕获的异常名称命名为 ex ；捕获异常且不做任何事情，异常名称命名为 ignored。</p>\n<p>**【强制】** 返回值变量使用 result 命名；循环中使用 each 命名循环变量；map 中使用 entry 代替 each。</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">//result 命名示范：</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">private</span> <span class=\"token keyword\">void</span> <span class=\"token function\">parseDate</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> data<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token class-name\">Result</span> result <span class=\"token operator\">=</span> <span class=\"token class-name\">JSONUtil</span><span class=\"token punctuation\">.</span><span class=\"token function\">parseObject</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Result</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token keyword\">return</span> result<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token comment\">// 或采用 result 为前缀：</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token keyword\">private</span> <span class=\"token keyword\">void</span> <span class=\"token function\">parseDate</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> data<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token class-name\">Result</span> resultDate <span class=\"token operator\">=</span> <span class=\"token class-name\">JSONUtil</span><span class=\"token punctuation\">.</span><span class=\"token function\">parseObject</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Result</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token keyword\">return</span> resultDate<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token comment\">//each 命名示范：</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>appNameLeaseMap<span class=\"token punctuation\">.</span><span class=\"token function\">values</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">forEach</span><span class=\"token punctuation\">(</span>each <span class=\"token operator\">-></span> appNameLeaseList<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>each<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre><span class=\"token comment\">// 或是 for 循环：</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre><span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Lease</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">InstanceInfo</span><span class=\"token punctuation\">></span></span> each <span class=\"token operator\">:</span> appNameLeaseMap<span class=\"token punctuation\">.</span><span class=\"token function\">values</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>    appNameLeaseList<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>each<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>**【强制】** 业务系统中优先使用 Guava、HuTool、Common3 等工具类中的方法，<font color='red'>不存在指定方法时再创建自定义工具类，禁止创建相同语义方法的工具类</font>。</p>\n<p>备注：定义组件项目时，尽量使用自定义工具类，避免因版本问题导致不确定的异常。</p>\n<p>**【强制】** 空实现接口或类不允许存在换行空格。</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">// 正例</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">interface</span> <span class=\"token class-name\">AdapterThreadPoolMonitor</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">ThreadPoolMonitor</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token comment\">// 反例</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">interface</span> <span class=\"token class-name\">AdapterThreadPoolMonitor</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">ThreadPoolMonitor</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    </pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>【建议】优先使用卫语句替换嵌套判断，提高代码简洁度。</p>\n<blockquote>\n<p>在《阿里巴巴 Java 开发手册》中强制规定：<strong>超过 3 层的</strong> <strong>if-else</strong> <strong>的逻辑判断代码可以使用卫语句</strong>、策略模式、<span class=\"exturl\" data-url=\"aHR0cHM6Ly9zby5jc2RuLm5ldC9zby9zZWFyY2g/cT0lRTclOEElQjYlRTYlODAlODElRTYlQTglQTElRTUlQkMlOEYmYW1wO3NwbT0xMDAxLjIxMDEuMzAwMS43MDIw\">状态模式</span>等来实现，其中卫语句<font color='red'>即代码逻辑先考虑失败、异常、中断、退出等直接返回的情况</font></p>\n</blockquote>\n<p>【建议】方法参数自定义实体对象别名尽量使用 requestParam，非自定义对象可以使用对应语义命名。</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token annotation punctuation\">@GetMapping</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"/add\"</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token annotation punctuation\">@ApiOperation</span><span class=\"token punctuation\">(</span>value <span class=\"token operator\">=</span> <span class=\"token string\">\"新增购物车\"</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token class-name\">Result</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">CartItemRespDTO</span><span class=\"token punctuation\">></span></span> <span class=\"token function\">addCartItem</span><span class=\"token punctuation\">(</span><span class=\"token annotation punctuation\">@RequestBody</span> <span class=\"token class-name\">CartItemAddReqDTO</span> requestParam<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token keyword\">return</span> <span class=\"token class-name\">Results</span><span class=\"token punctuation\">.</span><span class=\"token function\">success</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h3 id=\"代码格式化spotless\"><a class=\"anchor\" href=\"#代码格式化spotless\">#</a> 代码格式化（Spotless）</h3>\n<p>为什么要代码格式化？代码格式化的意义是让代码更加<strong>易读、易懂、易修改</strong>。</p>\n<p>ShardingSphere 作为 Apache 顶级开源项目，截止当前已有 380+ 贡献者。因为大部分开发人员的代码风格不一致，在 Github 多人协作的模式下，不易保障项目整体代码格式。</p>\n<p>基于以上诉求，ShardingSphere 采用了 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2RpZmZwbHVnL3Nwb3RsZXNzL3RyZWUvbWFpbi9wbHVnaW4tbWF2ZW4=\">Spotless</span> 充当代码格式统一的角色。</p>\n<h4 id=\"spotless\"><a class=\"anchor\" href=\"#spotless\">#</a> Spotless</h4>\n<p>Spotless 是支持多种语言的代码格式化工具，支持 Maven 和 Gradle 以 Plugin 的形式构建。Spotless 对开发者来说，有 2 种使用方式：</p>\n<ul>\n<li>检查代码是否存在格式问题</li>\n<li>格式化代码</li>\n</ul>\n<h4 id=\"使用示例\"><a class=\"anchor\" href=\"#使用示例\">#</a> 使用示例</h4>\n<p>下述代码是 Spotless 官方示例：</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>user@machine repo % mvn spotless:check</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">[</span>ERROR<span class=\"token punctuation\">]</span>  <span class=\"token operator\">></span> The following files had <span class=\"token function\">format</span> violations:</pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">[</span>ERROR<span class=\"token punctuation\">]</span>  src<span class=\"token punctuation\">\\</span>main<span class=\"token punctuation\">\\</span>java<span class=\"token punctuation\">\\</span>com<span class=\"token punctuation\">\\</span>diffplug<span class=\"token punctuation\">\\</span>gradle<span class=\"token punctuation\">\\</span>spotless<span class=\"token punctuation\">\\</span>FormatExtension.java</pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token punctuation\">[</span>ERROR<span class=\"token punctuation\">]</span>    -<span class=\"token punctuation\">\\</span>t<span class=\"token punctuation\">\\</span>t····if·<span class=\"token punctuation\">(</span>targets.length·<span class=\"token operator\">==</span>·0<span class=\"token punctuation\">)</span>·<span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">[</span>ERROR<span class=\"token punctuation\">]</span>    +<span class=\"token punctuation\">\\</span>t<span class=\"token punctuation\">\\</span>tif·<span class=\"token punctuation\">(</span>targets.length·<span class=\"token operator\">==</span>·0<span class=\"token punctuation\">)</span>·<span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token punctuation\">[</span>ERROR<span class=\"token punctuation\">]</span>  Run <span class=\"token string\">'mvn spotless:apply'</span> to fix these violations.</pre></td></tr><tr><td data-num=\"7\"></td><td><pre>user@machine repo % mvn spotless:apply</pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token punctuation\">[</span>INFO<span class=\"token punctuation\">]</span> BUILD SUCCESS</pre></td></tr><tr><td data-num=\"9\"></td><td><pre>user@machine repo % mvn spotless:check</pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token punctuation\">[</span>INFO<span class=\"token punctuation\">]</span> BUILD SUCCESS</pre></td></tr></table></figure><p>通过  <code>mvn spotless:check</code>  检查项目代码时发现错误，接着使用  <code>mvn spotless:apply</code>  进行代码格式化；再次检查时，格式化错误消失。</p>\n<h5 id=\"项目实战\"><a class=\"anchor\" href=\"#项目实战\">#</a> 项目实战</h5>\n<p>ShardingSphere 使用 Spotless 实现了添加 <strong>Java 文件 licenseHeader</strong> 和 <strong>Java 代码格式化</strong>。</p>\n<p>Spotless 有多种 Java 代码格式化方式，例如：googleJavaFormat、eclipse、prettier 等。基于定制化的考虑，最终采用 <font color='red'>eclipse</font> 进行 Java 代码格式化。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/1689587236721-0c9afb27-6a50-49c0-97c8-0d4201182065.png\" alt=\"img\" /></p>\n<p>1）根据项目需求添加 licenseHeader</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">/*</pre></td></tr><tr><td data-num=\"2\"></td><td><pre> * Licensed to the Apache Software Foundation (ASF) under one or more</pre></td></tr><tr><td data-num=\"3\"></td><td><pre> * contributor license agreements.  See the NOTICE file distributed with</pre></td></tr><tr><td data-num=\"4\"></td><td><pre> * this work for additional information regarding copyright ownership.</pre></td></tr><tr><td data-num=\"5\"></td><td><pre> * The ASF licenses this file to You under the Apache License, Version 2.0</pre></td></tr><tr><td data-num=\"6\"></td><td><pre> * (the \"License\"); you may not use this file except in compliance with</pre></td></tr><tr><td data-num=\"7\"></td><td><pre> * the License.  You may obtain a copy of the License at</pre></td></tr><tr><td data-num=\"8\"></td><td><pre> *</pre></td></tr><tr><td data-num=\"9\"></td><td><pre> *     http://www.apache.org/licenses/LICENSE-2.0</pre></td></tr><tr><td data-num=\"10\"></td><td><pre> *</pre></td></tr><tr><td data-num=\"11\"></td><td><pre> * Unless required by applicable law or agreed to in writing, software</pre></td></tr><tr><td data-num=\"12\"></td><td><pre> * distributed under the License is distributed on an \"AS IS\" BASIS,</pre></td></tr><tr><td data-num=\"13\"></td><td><pre> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</pre></td></tr><tr><td data-num=\"14\"></td><td><pre> * See the License for the specific language governing permissions and</pre></td></tr><tr><td data-num=\"15\"></td><td><pre> * limitations under the License.</pre></td></tr><tr><td data-num=\"16\"></td><td><pre> */</span></pre></td></tr></table></figure><p>注意，licenseHeader <strong>最后要留有一行空格</strong>。不然 licenseHeader 和 package 之间将没有空隙。</p>\n<p>2）添加 shardingsphere_eclipse_formatter.xml ：</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token operator\">&lt;</span><span class=\"token operator\">?</span>xml version<span class=\"token operator\">=</span><span class=\"token string\">\"1.0\"</span> encoding<span class=\"token operator\">=</span><span class=\"token string\">\"UTF-8\"</span> standalone<span class=\"token operator\">=</span><span class=\"token string\">\"no\"</span><span class=\"token operator\">?</span><span class=\"token operator\">></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token operator\">&lt;</span><span class=\"token operator\">!</span><span class=\"token operator\">--</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token comment\">/**</pre></td></tr><tr><td data-num=\"4\"></td><td><pre> * Licensed to the Apache Software Foundation (ASF) under one</pre></td></tr><tr><td data-num=\"5\"></td><td><pre> * or more contributor license agreements.  See the NOTICE file</pre></td></tr><tr><td data-num=\"6\"></td><td><pre> * distributed with this work for additional information</pre></td></tr><tr><td data-num=\"7\"></td><td><pre> * regarding copyright ownership.  The ASF licenses this file</pre></td></tr><tr><td data-num=\"8\"></td><td><pre> * to you under the Apache License, Version 2.0 (the</pre></td></tr><tr><td data-num=\"9\"></td><td><pre> * \"License\"); you may not use this file except in compliance</pre></td></tr><tr><td data-num=\"10\"></td><td><pre> * with the License.  You may obtain a copy of the License at</pre></td></tr><tr><td data-num=\"11\"></td><td><pre> *</pre></td></tr><tr><td data-num=\"12\"></td><td><pre> *     http://www.apache.org/licenses/LICENSE-2.0</pre></td></tr><tr><td data-num=\"13\"></td><td><pre> *</pre></td></tr><tr><td data-num=\"14\"></td><td><pre> * Unless required by applicable law or agreed to in writing, software</pre></td></tr><tr><td data-num=\"15\"></td><td><pre> * distributed under the License is distributed on an \"AS IS\" BASIS,</pre></td></tr><tr><td data-num=\"16\"></td><td><pre> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</pre></td></tr><tr><td data-num=\"17\"></td><td><pre> * See the License for the specific language governing permissions and</pre></td></tr><tr><td data-num=\"18\"></td><td><pre> * limitations under the License.</pre></td></tr><tr><td data-num=\"19\"></td><td><pre> */</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre><span class=\"token operator\">--</span><span class=\"token operator\">></span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre><span class=\"token operator\">&lt;</span>profiles version<span class=\"token operator\">=</span><span class=\"token string\">\"13\"</span><span class=\"token operator\">></span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>    <span class=\"token operator\">&lt;</span>profile kind<span class=\"token operator\">=</span><span class=\"token string\">\"CodeFormatterProfile\"</span> name<span class=\"token operator\">=</span><span class=\"token string\">\"'ShardingSphere Apache Current'\"</span> version<span class=\"token operator\">=</span><span class=\"token string\">\"13\"</span><span class=\"token operator\">></span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>        <span class=\"token operator\">&lt;</span>setting id<span class=\"token operator\">=</span><span class=\"token string\">\"org.eclipse.jdt.core.compiler.source\"</span> value<span class=\"token operator\">=</span><span class=\"token string\">\"1.8\"</span><span class=\"token operator\">/</span><span class=\"token operator\">></span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>        <span class=\"token operator\">&lt;</span>setting id<span class=\"token operator\">=</span><span class=\"token string\">\"org.eclipse.jdt.core.compiler.compliance\"</span> value<span class=\"token operator\">=</span><span class=\"token string\">\"1.8\"</span><span class=\"token operator\">/</span><span class=\"token operator\">></span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>        <span class=\"token operator\">&lt;</span>setting id<span class=\"token operator\">=</span><span class=\"token string\">\"org.eclipse.jdt.core.compiler.codegen.targetPlatform\"</span> value<span class=\"token operator\">=</span><span class=\"token string\">\"1.8\"</span><span class=\"token operator\">/</span><span class=\"token operator\">></span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>        <span class=\"token operator\">&lt;</span>setting id<span class=\"token operator\">=</span><span class=\"token string\">\"org.eclipse.jdt.core.formatter.indent_empty_lines\"</span> value<span class=\"token operator\">=</span><span class=\"token string\">\"true\"</span><span class=\"token operator\">/</span><span class=\"token operator\">></span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>        <span class=\"token operator\">&lt;</span>setting id<span class=\"token operator\">=</span><span class=\"token string\">\"org.eclipse.jdt.core.formatter.tabulation.size\"</span> value<span class=\"token operator\">=</span><span class=\"token string\">\"4\"</span><span class=\"token operator\">/</span><span class=\"token operator\">></span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>        <span class=\"token operator\">&lt;</span>setting id<span class=\"token operator\">=</span><span class=\"token string\">\"org.eclipse.jdt.core.formatter.lineSplit\"</span> value<span class=\"token operator\">=</span><span class=\"token string\">\"200\"</span><span class=\"token operator\">/</span><span class=\"token operator\">></span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>        <span class=\"token operator\">&lt;</span>setting id<span class=\"token operator\">=</span><span class=\"token string\">\"org.eclipse.jdt.core.formatter.comment.line_length\"</span> value<span class=\"token operator\">=</span><span class=\"token string\">\"200\"</span><span class=\"token operator\">/</span><span class=\"token operator\">></span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>        <span class=\"token operator\">&lt;</span>setting id<span class=\"token operator\">=</span><span class=\"token string\">\"org.eclipse.jdt.core.formatter.tabulation.char\"</span> value<span class=\"token operator\">=</span><span class=\"token string\">\"space\"</span><span class=\"token operator\">/</span><span class=\"token operator\">></span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre>        <span class=\"token operator\">&lt;</span>setting id<span class=\"token operator\">=</span><span class=\"token string\">\"org.eclipse.jdt.core.formatter.indentation.size\"</span> value<span class=\"token operator\">=</span><span class=\"token string\">\"1\"</span><span class=\"token operator\">/</span><span class=\"token operator\">></span></pre></td></tr><tr><td data-num=\"32\"></td><td><pre>        <span class=\"token operator\">&lt;</span>setting id<span class=\"token operator\">=</span><span class=\"token string\">\"org.eclipse.jdt.core.formatter.comment.format_javadoc_comments\"</span> value<span class=\"token operator\">=</span><span class=\"token string\">\"false\"</span><span class=\"token operator\">/</span><span class=\"token operator\">></span></pre></td></tr><tr><td data-num=\"33\"></td><td><pre>        <span class=\"token operator\">&lt;</span>setting id<span class=\"token operator\">=</span><span class=\"token string\">\"org.eclipse.jdt.core.formatter.join_wrapped_lines\"</span> value<span class=\"token operator\">=</span><span class=\"token string\">\"false\"</span><span class=\"token operator\">/</span><span class=\"token operator\">></span></pre></td></tr><tr><td data-num=\"34\"></td><td><pre>        <span class=\"token operator\">&lt;</span>setting id<span class=\"token operator\">=</span><span class=\"token string\">\"org.eclipse.jdt.core.formatter.insert_space_before_colon_in_conditional\"</span> value<span class=\"token operator\">=</span><span class=\"token string\">\"insert\"</span><span class=\"token operator\">/</span><span class=\"token operator\">></span></pre></td></tr><tr><td data-num=\"35\"></td><td><pre>        <span class=\"token operator\">&lt;</span>setting id<span class=\"token operator\">=</span><span class=\"token string\">\"org.eclipse.jdt.core.formatter.insert_space_before_colon_in_default\"</span> value<span class=\"token operator\">=</span><span class=\"token string\">\"do not insert\"</span><span class=\"token operator\">/</span><span class=\"token operator\">></span></pre></td></tr><tr><td data-num=\"36\"></td><td><pre>        <span class=\"token operator\">&lt;</span>setting id<span class=\"token operator\">=</span><span class=\"token string\">\"org.eclipse.jdt.core.formatter.alignment_for_enum_constants\"</span> value<span class=\"token operator\">=</span><span class=\"token string\">\"16\"</span><span class=\"token operator\">/</span><span class=\"token operator\">></span></pre></td></tr><tr><td data-num=\"37\"></td><td><pre>        <span class=\"token operator\">&lt;</span>setting id<span class=\"token operator\">=</span><span class=\"token string\">\"org.eclipse.jdt.core.formatter.insert_space_before_colon_in_labeled_statement\"</span> value<span class=\"token operator\">=</span><span class=\"token string\">\"do not insert\"</span><span class=\"token operator\">/</span><span class=\"token operator\">></span></pre></td></tr><tr><td data-num=\"38\"></td><td><pre>        <span class=\"token operator\">&lt;</span>setting id<span class=\"token operator\">=</span><span class=\"token string\">\"org.eclipse.jdt.core.formatter.insert_space_before_colon_in_case\"</span> value<span class=\"token operator\">=</span><span class=\"token string\">\"do not insert\"</span><span class=\"token operator\">/</span><span class=\"token operator\">></span></pre></td></tr><tr><td data-num=\"39\"></td><td><pre>        <span class=\"token operator\">&lt;</span>setting id<span class=\"token operator\">=</span><span class=\"token string\">\"org.eclipse.jdt.core.formatter.alignment_for_conditional_expression\"</span> value<span class=\"token operator\">=</span><span class=\"token string\">\"80\"</span><span class=\"token operator\">/</span><span class=\"token operator\">></span></pre></td></tr><tr><td data-num=\"40\"></td><td><pre>        <span class=\"token operator\">&lt;</span>setting id<span class=\"token operator\">=</span><span class=\"token string\">\"org.eclipse.jdt.core.formatter.alignment_for_assignment\"</span> value<span class=\"token operator\">=</span><span class=\"token string\">\"16\"</span><span class=\"token operator\">/</span><span class=\"token operator\">></span></pre></td></tr><tr><td data-num=\"41\"></td><td><pre>        <span class=\"token operator\">&lt;</span>setting id<span class=\"token operator\">=</span><span class=\"token string\">\"org.eclipse.jdt.core.formatter.blank_lines_after_package\"</span> value<span class=\"token operator\">=</span><span class=\"token string\">\"1\"</span><span class=\"token operator\">/</span><span class=\"token operator\">></span></pre></td></tr><tr><td data-num=\"42\"></td><td><pre>        <span class=\"token operator\">&lt;</span>setting id<span class=\"token operator\">=</span><span class=\"token string\">\"org.eclipse.jdt.core.formatter.continuation_indentation_for_array_initializer\"</span> value<span class=\"token operator\">=</span><span class=\"token string\">\"2\"</span><span class=\"token operator\">/</span><span class=\"token operator\">></span></pre></td></tr><tr><td data-num=\"43\"></td><td><pre>        <span class=\"token operator\">&lt;</span>setting id<span class=\"token operator\">=</span><span class=\"token string\">\"org.eclipse.jdt.core.formatter.alignment_for_resources_in_try\"</span> value<span class=\"token operator\">=</span><span class=\"token string\">\"160\"</span><span class=\"token operator\">/</span><span class=\"token operator\">></span></pre></td></tr><tr><td data-num=\"44\"></td><td><pre>        <span class=\"token operator\">&lt;</span>setting id<span class=\"token operator\">=</span><span class=\"token string\">\"org.eclipse.jdt.core.formatter.alignment_for_throws_clause_in_method_declaration\"</span> value<span class=\"token operator\">=</span><span class=\"token string\">\"10\"</span><span class=\"token operator\">/</span><span class=\"token operator\">></span></pre></td></tr><tr><td data-num=\"45\"></td><td><pre>        <span class=\"token operator\">&lt;</span>setting id<span class=\"token operator\">=</span><span class=\"token string\">\"org.eclipse.jdt.core.formatter.alignment_for_parameters_in_method_declaration\"</span> value<span class=\"token operator\">=</span><span class=\"token string\">\"106\"</span><span class=\"token operator\">/</span><span class=\"token operator\">></span></pre></td></tr><tr><td data-num=\"46\"></td><td><pre>        <span class=\"token operator\">&lt;</span>setting id<span class=\"token operator\">=</span><span class=\"token string\">\"org.eclipse.jdt.core.formatter.alignment_for_parameters_in_constructor_declaration\"</span> value<span class=\"token operator\">=</span><span class=\"token string\">\"106\"</span><span class=\"token operator\">/</span><span class=\"token operator\">></span></pre></td></tr><tr><td data-num=\"47\"></td><td><pre>        <span class=\"token operator\">&lt;</span>setting id<span class=\"token operator\">=</span><span class=\"token string\">\"org.eclipse.jdt.core.formatter.alignment_for_throws_clause_in_constructor_declaration\"</span> value<span class=\"token operator\">=</span><span class=\"token string\">\"106\"</span><span class=\"token operator\">/</span><span class=\"token operator\">></span></pre></td></tr><tr><td data-num=\"48\"></td><td><pre>        <span class=\"token operator\">&lt;</span>setting id<span class=\"token operator\">=</span><span class=\"token string\">\"org.eclipse.jdt.core.formatter.alignment_for_arguments_in_explicit_constructor_call.count_dependent\"</span> value<span class=\"token operator\">=</span><span class=\"token string\">\"16|5|80\"</span><span class=\"token operator\">/</span><span class=\"token operator\">></span></pre></td></tr><tr><td data-num=\"49\"></td><td><pre>    <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>profile<span class=\"token operator\">></span></pre></td></tr><tr><td data-num=\"50\"></td><td><pre><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>profiles<span class=\"token operator\">></span></pre></td></tr></table></figure><blockquote>\n<p>ShardingSphere 最新规则查看 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2FwYWNoZS9zaGFyZGluZ3NwaGVyZS9ibG9iL21hc3Rlci9zcmMvcmVzb3VyY2VzL3NoYXJkaW5nc3BoZXJlX2VjbGlwc2VfZm9ybWF0dGVyLnhtbA==\">shardingsphere_eclipse_formatter.xml</span>，另提供一份 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS9zdHlsZWd1aWRlL2Jsb2IvZ2gtcGFnZXMvZWNsaXBzZS1qYXZhLWdvb2dsZS1zdHlsZS54bWw=\">eclipse-java-google-style.xml</span> 供参考</p>\n</blockquote>\n<p>这是一个 XML 文件，看起来是 Eclipse IDE 项目中代码格式化配置文件的一部分。该文件定义了项目中代码格式化的各种设置。</p>\n<p>以下是提供的 XML 文件中一些关键设置的解释：</p>\n<ol>\n<li>\n<p><strong>Java 版本设置:</strong></p>\n<ul>\n<li>源代码兼容性： <code>1.8</code></li>\n<li>编译器兼容级别： <code>1.8</code></li>\n<li>代码生成目标平台： <code>1.8</code></li>\n</ul>\n</li>\n<li>\n<p><strong>代码格式化设置:</strong></p>\n<ul>\n<li>\n<p>缩进：</p>\n<ul>\n<li>空行进行缩进 ( <code>org.eclipse.jdt.core.formatter.indent_empty_lines</code> )。</li>\n<li>制表符大小设置为  <code>4</code>  个空格 ( <code>org.eclipse.jdt.core.formatter.tabulation.size</code> )。</li>\n<li>允许行分割达到  <code>200</code>  个字符 ( <code>org.eclipse.jdt.core.formatter.lineSplit</code> )。</li>\n<li>注释行允许达到  <code>200</code>  个字符 ( <code>org.eclipse.jdt.core.formatter.comment.line_length</code> )。</li>\n<li>使用空格进行制表 ( <code>org.eclipse.jdt.core.formatter.tabulation.char</code> )。</li>\n<li>缩进大小设置为  <code>1</code>  个空格 ( <code>org.eclipse.jdt.core.formatter.indentation.size</code> )。</li>\n</ul>\n</li>\n<li>\n<p>注释格式化：</p>\n<ul>\n<li>不对 JavaDoc 注释进行格式化 ( <code>org.eclipse.jdt.core.formatter.comment.format_javadoc_comments</code> )。</li>\n</ul>\n</li>\n<li>\n<p>其他格式化：</p>\n<ul>\n<li>不连接换行的代码 ( <code>org.eclipse.jdt.core.formatter.join_wrapped_lines</code> )。</li>\n<li>在条件语句中的冒号前插入空格 ( <code>org.eclipse.jdt.core.formatter.insert_space_before_colon_in_conditional</code> )</li>\n</ul>\n</li>\n<li>\n<p>对齐：</p>\n<ul>\n<li>枚举常量使用  <code>16</code>  个空格对齐 ( <code>org.eclipse.jdt.core.formatter.alignment_for_enum_constants</code> )。</li>\n<li>条件表达式使用  <code>80</code>  个空格对齐 ( <code>org.eclipse.jdt.core.formatter.alignment_for_conditional_expression</code> )。</li>\n<li>赋值使用  <code>16</code>  个空格对齐 ( <code>org.eclipse.jdt.core.formatter.alignment_for_assignment</code> )。</li>\n<li>在 try 块中的资源使用  <code>160</code>  个空格对齐 ( <code>org.eclipse.jdt.core.formatter.alignment_for_resources_in_try</code> )。</li>\n<li>方法和构造函数声明中的 throws 子句和参数进行对齐。</li>\n</ul>\n</li>\n<li>\n<p>空白行：</p>\n<ul>\n<li>在包声明后添加一个空白行 ( <code>org.eclipse.jdt.core.formatter.blank_lines_after_package</code> )。</li>\n</ul>\n</li>\n<li>\n<p>数组初始化：</p>\n<ul>\n<li>数组初始化器的连续缩进设置为  <code>2</code>  个空格 ( <code>org.eclipse.jdt.core.formatter.continuation_indentation_for_array_initializer</code> )</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<p>这个配置似乎是为特定的编码风格定制的，可能是为 ShardingSphere Apache 项目而设计的，使用 Eclipse IDE 版本 13。它确保根据指定的规则生成一致且可读的代码格式。</p>\n<p>shardingsphere_eclipse_formatter.xml 的内容是根据 ShardingSphere 代码规范定制开发的，可灵活变动。</p>\n<p>3）添加 Maven plugin</p>\n<figure class=\"highlight xml\"><figcaption data-lang=\"XML\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>plugin</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>groupId</span><span class=\"token punctuation\">></span></span>com.diffplug.spotless<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>groupId</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>artifactId</span><span class=\"token punctuation\">></span></span>spotless-maven-plugin<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>artifactId</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>version</span><span class=\"token punctuation\">></span></span>2.22.1<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>version</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>configuration</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>java</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>            <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>eclipse</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>                <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>file</span><span class=\"token punctuation\">></span></span>$&#123;maven.multiModuleProjectDirectory&#125;/src/resources/shardingsphere_eclipse_formatter.xml<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>file</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>            <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>eclipse</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>            <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>licenseHeader</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>                <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>file</span><span class=\"token punctuation\">></span></span>$&#123;maven.multiModuleProjectDirectory&#125;/src/resources/license-header<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>file</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>            <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>licenseHeader</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>java</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>configuration</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>plugin</span><span class=\"token punctuation\">></span></span></pre></td></tr></table></figure><p>Spotless 支持格式化指定目录，以及排除指定目录的功能，详情参考 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2RpZmZwbHVnL3Nwb3RsZXNzL3RyZWUvbWFpbi9wbHVnaW4tbWF2ZW4jamF2YQ==\">plugin-maven#java</span>。如无指定，执行 check 或 apply 时，默认项目全量代码。</p>\n<p>4）执行代码格式化：执行完上述三个步骤，就可以在项目中执行命令，检查 Java 代码是否符合规范，以及代码格式化功能。</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>user@machine repo % mvn spotless:apply</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">[</span>INFO<span class=\"token punctuation\">]</span> BUILD SUCCESS</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>user@machine repo % mvn spotless:check</pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token punctuation\">[</span>INFO<span class=\"token punctuation\">]</span> BUILD SUCCESS</pre></td></tr></table></figure><h5 id=\"绑定-maven-生命周期\"><a class=\"anchor\" href=\"#绑定-maven-生命周期\">#</a> 绑定 Maven 生命周期</h5>\n<p>在 ShardingSphere 实际应用中，选择<font color='red'>将 Spotless apply 绑定到 compile 阶段，这样本地执行 mvn install 时就能自动格式化</font>。</p>\n<figure class=\"highlight xml\"><figcaption data-lang=\"XML\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>plugin</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>groupId</span><span class=\"token punctuation\">></span></span>com.diffplug.spotless<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>groupId</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>artifactId</span><span class=\"token punctuation\">></span></span>spotless-maven-plugin<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>artifactId</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>version</span><span class=\"token punctuation\">></span></span>2.22.1<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>version</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>configuration</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>java</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>            <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>eclipse</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>                <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>file</span><span class=\"token punctuation\">></span></span>$&#123;maven.multiModuleProjectDirectory&#125;/src/resources/shardingsphere_eclipse_formatter.xml<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>file</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>            <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>eclipse</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>            <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>licenseHeader</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>                <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>file</span><span class=\"token punctuation\">></span></span>$&#123;maven.multiModuleProjectDirectory&#125;/src/resources/license-header<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>file</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>            <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>licenseHeader</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>java</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>configuration</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>executions</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>execution</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>            <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>goals</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>                <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>goal</span><span class=\"token punctuation\">></span></span>apply<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>goal</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>            <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>goals</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>            <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>phase</span><span class=\"token punctuation\">></span></span>compile<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>phase</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>execution</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>executions</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>plugin</span><span class=\"token punctuation\">></span></span></pre></td></tr></table></figure><h5 id=\"idea-格式化\"><a class=\"anchor\" href=\"#idea-格式化\">#</a> IDEA 格式化</h5>\n<p>开发者如果在写代码过程中，想<font color='red'>检查单个文件是否符合规范</font>，执行  <code>mvn spotless:check</code>  或  <code>mvn spotless:apply</code>  显得有些笨重，因为格式化范围默认是整个项目。</p>\n<p>我们<font color='red'>可以使用 shardingsphere_eclipse_formatter.xml 替换 IntelliJ IDEA 原有格式化功能</font>，这样在写代码过程中可以随时格式化，极大提升了开发效率。</p>\n<blockquote>\n<p>IDEA 版本 2019.3.4。</p>\n</blockquote>\n<p>1）安装插件 Eclipse Code Formatter</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/1689587236697-3ca0d07b-15f8-4035-89fe-2b6fbd5c3918.png\" alt=\"img\" /></p>\n<p>2）选择 shardingsphere_eclipse_formatter.xml 为默认格式化模板</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/1689587236710-ded7fe72-2a42-4bef-8dc8-87f454354177.png\" alt=\"img\" /></p>\n<p>使用 IDEA 代码格式化快捷键，就可以完成 Spotless 代码格式化。</p>\n<h4 id=\"常见问题\"><a class=\"anchor\" href=\"#常见问题\">#</a> 常见问题</h4>\n<h5 id=\"spotless-与-checkstyle-冲突\"><a class=\"anchor\" href=\"#spotless-与-checkstyle-冲突\">#</a> Spotless 与 Checkstyle 冲突</h5>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2NoZWNrc3R5bGUvY2hlY2tzdHlsZQ==\">Checkstyle</span> 是一种用于检查 Java 源代码是否符合代码标准或一组验证规则（最佳实践）的工具。</p>\n<p>极端场景下，Spotless 格式化代码后，通过 Checkstyle 检查代码会不通过。</p>\n<p>根本原因在于<font color='red'>两者设定的检查配置和格式化配置冲突</font>。举个例子，Spotless 格式化后换行缩进了 16 个空格，而 Checkstyle 的换行检查是 12 个空格。</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token class-name\">Collection</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">PreciseHintShadowValue</span><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Comparable</span><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span><span class=\"token punctuation\">></span><span class=\"token punctuation\">></span><span class=\"token punctuation\">></span></span> <span class=\"token function\">createNoteShadowValues</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">final</span> <span class=\"token class-name\">ShadowDetermineCondition</span> shadowDetermineCondition<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token comment\">// Checkstyle 可以通过的格式</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">return</span> shadowDetermineCondition<span class=\"token punctuation\">.</span><span class=\"token function\">getSqlComments</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">stream</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">PreciseHintShadowValue</span><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Comparable</span><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span><span class=\"token punctuation\">></span><span class=\"token punctuation\">></span><span class=\"token punctuation\">></span></span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>        each <span class=\"token operator\">-></span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">PreciseHintShadowValue</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span>tableName<span class=\"token punctuation\">,</span> shadowOperationType<span class=\"token punctuation\">,</span> each<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">collect</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Collectors</span><span class=\"token punctuation\">.</span><span class=\"token function\">toList</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token comment\">// Spotless 格式化后</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token keyword\">return</span> shadowDetermineCondition<span class=\"token punctuation\">.</span><span class=\"token function\">getSqlComments</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">stream</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">PreciseHintShadowValue</span><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Comparable</span><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span><span class=\"token punctuation\">></span><span class=\"token punctuation\">></span><span class=\"token punctuation\">></span></span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>            each <span class=\"token operator\">-></span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">PreciseHintShadowValue</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span>tableName<span class=\"token punctuation\">,</span> shadowOperationType<span class=\"token punctuation\">,</span> each<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">collect</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Collectors</span><span class=\"token punctuation\">.</span><span class=\"token function\">toList</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>这种情况，需要开发者衡量如何取舍。解决方案有两种：<font color='red'>修改 Spotless 的格式化规则，或修改 Checkstyle 的检查规则</font>。</p>\n<h5 id=\"crlf-与-lf-格式化冲突\"><a class=\"anchor\" href=\"#crlf-与-lf-格式化冲突\">#</a> CRLF 与 LF 格式化冲突</h5>\n<p>参考 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2RpZmZwbHVnL3Nwb3RsZXNzL2lzc3Vlcy8xMTcx\">https://github.com/diffplug/spotless/issues/1171</span></p>\n<h4 id=\"小结-4\"><a class=\"anchor\" href=\"#小结-4\">#</a> 小结</h4>\n<p>文章介绍了 <font color='red'>Apache ShardingSphere 使用 Spotless 完成历史代码格式化，以及后续代码格式的统一</font>，对项目代码的整洁起到了很大帮助。</p>\n<p>当然，Spotless 的功能不止 Java 代码的格式化，包括不限于 Pom 和 Markdown 等文件类型的格式化，后续这些都会在 ShardingSphere 得以应用。</p>\n<h3 id=\"代码检查checkstyle\"><a class=\"anchor\" href=\"#代码检查checkstyle\">#</a> 代码检查（CheckStyle）</h3>\n<blockquote>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9jaGVja3N0eWxlLm9yZy8=\">CheckStyle Site</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2NoZWNrc3R5bGUvY2hlY2tzdHlsZQ==\">CheckStyle GitHub</span></p>\n</blockquote>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/1678510337590-eda4e030-0118-4a8b-bdf1-5b276250fa9d.png\" alt=\"img\" /></p>\n<p>Checkstyle 是一种开发工具，<font color='red'>可帮助程序员编写符合编码标准的 Java 代码</font>。它使检查 Java 代码的过程自动化，从而使开发者免于完成这项无聊（但重要）的任务。这使得它非常适合想要强制执行编码标准的项目。</p>\n<p>Checkstyle 可以检查源代码的许多方面。它可以发现<font color='red'>类设计问题、方法设计问题</font>。它还能够检查<font color='red'>代码布局和格式问题</font>。</p>\n<h4 id=\"定义扫描规则\"><a class=\"anchor\" href=\"#定义扫描规则\">#</a> 定义扫描规则</h4>\n<p>CheckStyle 有着众多扫描规则，涵盖种类非常之多，容易让人眼花缭乱。这里提供<font color='red'>一份开源项目 Hippo4j 正在使用的规则文件</font>，如需个性化可参考官网进行修改。</p>\n<p>创建自定义  <code>checkstyle.xml</code>  文件：</p>\n<figure class=\"highlight xml\"><figcaption data-lang=\"XML\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token doctype\"><span class=\"token punctuation\">&lt;!</span><span class=\"token doctype-tag\">DOCTYPE</span> <span class=\"token name\">module</span> <span class=\"token name\">PUBLIC</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token string\">\"-//Puppy Crawl//DTD Check Configuration 1.3//EN\"</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token string\">\"http://www.puppycrawl.com/dtds/configuration_1_3.dtd\"</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>module</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>Checker<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>module</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>NewlineAtEndOfFile<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>module</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>RegexpSingleline<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>property</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>format<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">value</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>printStackTrace<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>property</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>message<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">value</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>Prohibit invoking printStackTrace in source code !<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>module</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>module</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>TreeWalker<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>module</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>AvoidStarImport<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>      <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>property</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>excludes<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">value</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>java.io,java.net,java.lang.Math<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>      <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>property</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>allowClassImports<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">value</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>false<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>      <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>property</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>allowStaticMemberImports<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">value</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>true<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>module</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>module</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>IllegalImport<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>module</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>RedundantImport<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>module</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>UnusedImports<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>module</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>JavadocType<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>      <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>property</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>allowUnknownTags<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">value</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>true<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>      <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>property</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>allowMissingParamTags<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">value</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>true<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>      <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>message</span> <span class=\"token attr-name\">key</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>javadoc.missing<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">value</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>Class Comments: Missing Javadoc Comments<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>module</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>    <span class=\"token comment\">&lt;!-- Do not scan method annotations for now --></span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>    <span class=\"token comment\">&lt;!--&lt;module name=\"JavadocMethod\"></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>    &lt;property name=\"tokens\" value=\"METHOD_DEF\"/></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>    &lt;property name=\"allowMissingPropertyJavadoc\" value=\"true\"/></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>    &lt;message key=\"javadoc.missing\" value=\"Method Comments: Missing Javadoc Comments\"/></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>  &lt;/module>--></span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>module</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>LocalFinalVariableName<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>module</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>LocalVariableName<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span></pre></td></tr><tr><td data-num=\"32\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>module</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>PackageName<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"33\"></td><td><pre>      <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>property</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>format<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">value</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>^[a-z]+(\\.[a-z][a-z0-9]*)*$<span class=\"token punctuation\">\"</span></span> <span class=\"token punctuation\">/></span></span></pre></td></tr><tr><td data-num=\"34\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>module</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"35\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>module</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>StaticVariableName<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span></pre></td></tr><tr><td data-num=\"36\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>module</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>TypeName<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span></pre></td></tr><tr><td data-num=\"37\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>module</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>MemberName<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span></pre></td></tr><tr><td data-num=\"38\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>module</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>MethodName<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span></pre></td></tr><tr><td data-num=\"39\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>module</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>ParameterName <span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span></pre></td></tr><tr><td data-num=\"40\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>module</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>ConstantName<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span></pre></td></tr><tr><td data-num=\"41\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>module</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>ArrayTypeStyle<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span></pre></td></tr><tr><td data-num=\"42\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>module</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>UpperEll<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span></pre></td></tr><tr><td data-num=\"43\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>module</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>LineLength<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"44\"></td><td><pre>      <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>property</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>max<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">value</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>200<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span></pre></td></tr><tr><td data-num=\"45\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>module</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"46\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>module</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>MethodLength<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"47\"></td><td><pre>      <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>property</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>tokens<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">value</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>METHOD_DEF<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span></pre></td></tr><tr><td data-num=\"48\"></td><td><pre>      <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>property</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>max<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">value</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>150<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span></pre></td></tr><tr><td data-num=\"49\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>module</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"50\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>module</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>ParameterNumber<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"51\"></td><td><pre>      <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>property</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>max<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">value</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>5<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span></pre></td></tr><tr><td data-num=\"52\"></td><td><pre>      <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>property</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>ignoreOverriddenMethods<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">value</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>true<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span></pre></td></tr><tr><td data-num=\"53\"></td><td><pre>      <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>property</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>tokens<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">value</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>METHOD_DEF<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span></pre></td></tr><tr><td data-num=\"54\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>module</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"55\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>module</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>MethodParamPad<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span></pre></td></tr><tr><td data-num=\"56\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>module</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>TypecastParenPad<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span></pre></td></tr><tr><td data-num=\"57\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>module</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>NoWhitespaceAfter<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span></pre></td></tr><tr><td data-num=\"58\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>module</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>NoWhitespaceBefore<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span></pre></td></tr><tr><td data-num=\"59\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>module</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>OperatorWrap<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span></pre></td></tr><tr><td data-num=\"60\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>module</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>ParenPad<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span></pre></td></tr><tr><td data-num=\"61\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>module</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>WhitespaceAfter<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span></pre></td></tr><tr><td data-num=\"62\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>module</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>WhitespaceAround<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span></pre></td></tr><tr><td data-num=\"63\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>module</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>ModifierOrder<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span></pre></td></tr><tr><td data-num=\"64\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>module</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>RedundantModifier<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span></pre></td></tr><tr><td data-num=\"65\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>module</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>AvoidNestedBlocks<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span></pre></td></tr><tr><td data-num=\"66\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>module</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>EmptyBlock<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span></pre></td></tr><tr><td data-num=\"67\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>module</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>LeftCurly<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span></pre></td></tr><tr><td data-num=\"68\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>module</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>NeedBraces<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span></pre></td></tr><tr><td data-num=\"69\"></td><td><pre>      <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>module</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>RightCurly<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span></pre></td></tr><tr><td data-num=\"70\"></td><td><pre>      <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>module</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>EmptyStatement<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span></pre></td></tr><tr><td data-num=\"71\"></td><td><pre>      <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>module</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>EqualsHashCode<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span></pre></td></tr><tr><td data-num=\"72\"></td><td><pre>      <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>module</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>IllegalInstantiation<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span></pre></td></tr><tr><td data-num=\"73\"></td><td><pre>      <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>module</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>InnerAssignment<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span></pre></td></tr><tr><td data-num=\"74\"></td><td><pre>      <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>module</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>MagicNumber<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"75\"></td><td><pre>      <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>property</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>ignoreNumbers<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">value</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>0, 1, 2<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span></pre></td></tr><tr><td data-num=\"76\"></td><td><pre>      <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>property</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>ignoreAnnotation<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">value</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>true<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span></pre></td></tr><tr><td data-num=\"77\"></td><td><pre>      <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>property</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>ignoreHashCodeMethod<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">value</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>true<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span></pre></td></tr><tr><td data-num=\"78\"></td><td><pre>      <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>property</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>ignoreFieldDeclaration<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">value</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>true<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span></pre></td></tr><tr><td data-num=\"79\"></td><td><pre>      <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>module</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"80\"></td><td><pre>      <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>module</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>MissingSwitchDefault<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span></pre></td></tr><tr><td data-num=\"81\"></td><td><pre>      <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>module</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>SimplifyBooleanExpression<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span></pre></td></tr><tr><td data-num=\"82\"></td><td><pre>      <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>module</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>SimplifyBooleanReturn<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span></pre></td></tr><tr><td data-num=\"83\"></td><td><pre>      <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>module</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>FinalClass<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span></pre></td></tr><tr><td data-num=\"84\"></td><td><pre>      <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>module</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>InterfaceIsType<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span></pre></td></tr><tr><td data-num=\"85\"></td><td><pre>      <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>module</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>VisibilityModifier<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"86\"></td><td><pre>      <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>property</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>packageAllowed<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">value</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>true<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span></pre></td></tr><tr><td data-num=\"87\"></td><td><pre>      <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>property</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>protectedAllowed<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">value</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>true<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span></pre></td></tr><tr><td data-num=\"88\"></td><td><pre>      <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>module</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"89\"></td><td><pre>      <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>module</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>StringLiteralEquality<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span></pre></td></tr><tr><td data-num=\"90\"></td><td><pre>      <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>module</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>NestedForDepth<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"91\"></td><td><pre>      <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>property</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>max<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">value</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>3<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span></pre></td></tr><tr><td data-num=\"92\"></td><td><pre>      <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>module</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"93\"></td><td><pre>      <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>module</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>NestedIfDepth<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"94\"></td><td><pre>      <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>property</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>max<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">value</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>4<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span></pre></td></tr><tr><td data-num=\"95\"></td><td><pre>      <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>module</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"96\"></td><td><pre>      <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>module</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>UncommentedMain<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"97\"></td><td><pre>      <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>property</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>excludedClasses<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">value</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>.*Application$<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span></pre></td></tr><tr><td data-num=\"98\"></td><td><pre>      <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>module</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"99\"></td><td><pre>      <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>module</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>Regexp<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"100\"></td><td><pre>      <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>property</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>format<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">value</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>System\\.out\\.println<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span></pre></td></tr><tr><td data-num=\"101\"></td><td><pre>      <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>property</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>illegalPattern<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">value</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>true<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span></pre></td></tr><tr><td data-num=\"102\"></td><td><pre>      <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>module</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"103\"></td><td><pre>      <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>module</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>ReturnCount<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"104\"></td><td><pre>      <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>property</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>max<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">value</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>4<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span></pre></td></tr><tr><td data-num=\"105\"></td><td><pre>      <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>module</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"106\"></td><td><pre>      <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>module</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>NestedTryDepth <span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"107\"></td><td><pre>      <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>property</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>max<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">value</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>4<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span></pre></td></tr><tr><td data-num=\"108\"></td><td><pre>      <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>module</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"109\"></td><td><pre>      <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>module</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>SuperFinalize<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span></pre></td></tr><tr><td data-num=\"110\"></td><td><pre>      <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>module</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>SuperClone<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span></pre></td></tr><tr><td data-num=\"111\"></td><td><pre>      <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>module</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"112\"></td><td><pre>      <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>module</span><span class=\"token punctuation\">></span></span></pre></td></tr></table></figure><p>这是一个 PMD 检查器的配置文件，用于在 Java 代码中执行静态代码分析和规范检查。以下是该配置文件的主要模块及其功能的简要说明：</p>\n<ol>\n<li><strong>NewlineAtEndOfFile：</strong>\n<ul>\n<li>检查文件末尾是否有换行符。</li>\n</ul>\n</li>\n<li><strong>RegexpSingleline：</strong>\n<ul>\n<li>检查源代码中是否包含  <code>printStackTrace</code> 。</li>\n<li>提供自定义消息，防止在代码中调用  <code>printStackTrace</code> 。</li>\n</ul>\n</li>\n<li><strong>TreeWalker：</strong>\n<ul>\n<li>使用多个子模块对代码进行深入检查。</li>\n<li><strong>AvoidStarImport：</strong>\n<ul>\n<li>避免使用通配符导入。</li>\n<li>可以排除  <code>java.io</code> 、 <code>java.net</code>  和  <code>java.lang.Math</code> 。</li>\n<li>不允许类导入，但允许静态成员导入。</li>\n</ul>\n</li>\n<li><strong>IllegalImport：</strong>\n<ul>\n<li>检查是否存在非法的导入。</li>\n</ul>\n</li>\n<li><strong>RedundantImport：</strong>\n<ul>\n<li>检查是否存在冗余的导入。</li>\n</ul>\n</li>\n<li><strong>UnusedImports：</strong>\n<ul>\n<li>检查是否存在未使用的导入。</li>\n</ul>\n</li>\n<li><strong>JavadocType：</strong>\n<ul>\n<li>检查类缺少 Javadoc 注释。</li>\n</ul>\n</li>\n<li><strong>LocalFinalVariableName、LocalVariableName、PackageName、StaticVariableName、TypeName、MemberName、MethodName、ParameterName、ConstantName：</strong>\n<ul>\n<li>命名约定的检查。</li>\n</ul>\n</li>\n<li><strong>ArrayTypeStyle：</strong>\n<ul>\n<li>数组声明的样式检查。</li>\n</ul>\n</li>\n<li><strong>LineLength：</strong>\n<ul>\n<li>检查代码行长度不超过 200 个字符。</li>\n</ul>\n</li>\n<li><strong>MethodLength：</strong>\n<ul>\n<li>检查方法长度不超过 150 行。</li>\n</ul>\n</li>\n<li><strong>ParameterNumber：</strong>\n<ul>\n<li>检查方法参数数量不超过 5 个。</li>\n</ul>\n</li>\n<li>其他的模块涵盖了代码格式、布尔表达式简化、代码块规范等方面的检查。</li>\n<li><strong>Regexp：</strong>\n<ul>\n<li>使用正则表达式检查代码中是否包含  <code>System.out.println</code> 。</li>\n</ul>\n</li>\n<li><strong>NestedTryDepth、NestedForDepth、NestedIfDepth：</strong>\n<ul>\n<li>分别检查嵌套的 try、for 和 if 语句的深度。</li>\n</ul>\n</li>\n<li><strong>UncommentedMain：</strong>\n<ul>\n<li>检查是否有未注释的主方法。</li>\n</ul>\n</li>\n<li><strong>MagicNumber：</strong>\n<ul>\n<li>检查是否使用了魔法数字（未解释的常量值）。</li>\n</ul>\n</li>\n<li><strong>ReturnCount：</strong>\n<ul>\n<li>检查方法返回语句的数量是否超过 4 个。</li>\n</ul>\n</li>\n<li><strong>VisibilityModifier：</strong>\n<ul>\n<li>检查不同可见性修饰符的使用。</li>\n</ul>\n</li>\n<li><strong>FinalClass：</strong>\n<ul>\n<li>检查是否有未声明为  <code>final</code>  的类。</li>\n</ul>\n</li>\n<li><strong>InterfaceIsType：</strong>\n<ul>\n<li>检查是否有未声明为接口的类型。</li>\n</ul>\n</li>\n<li><strong>StringLiteralEquality：</strong>\n<ul>\n<li>检查是否使用了字符串字面量的比较。</li>\n</ul>\n</li>\n<li><strong>MissingSwitchDefault：</strong>\n<ul>\n<li>检查是否在 switch 语句中缺少 default 分支。</li>\n</ul>\n</li>\n<li><strong>SuperFinalize、SuperClone：</strong>\n<ul>\n<li>检查是否调用了  <code>super.finalize()</code>  和  <code>super.clone()</code> 。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<p>这个配置文件涵盖了许多静态代码检查方面，用于保持代码的一致性、规范性和可读性。</p>\n<h4 id=\"如何使用\"><a class=\"anchor\" href=\"#如何使用\">#</a> 如何使用</h4>\n<p>CheckStyle 在日常生活中有两种常用的使用方式，分别是通过代码编辑器 IDEA 和 Maven 配合使用。</p>\n<h5 id=\"idea-插件\"><a class=\"anchor\" href=\"#idea-插件\">#</a> IDEA 插件</h5>\n<p>首先打开 IDEA 菜单栏的 Settings 配置中的 Plugins，搜索 CheckStyle-IDEA 并安装：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/1678510337622-2e5e2a71-018b-4c37-9b0b-227b3bc3616d.png\" alt=\"img\" /></p>\n<p>安装后，查看 Enable 是否开启，如果没有开启，将该框打勾并重启 IDEA。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/1678510337652-c3fb8ca0-2c80-45ff-a52e-37b7fae45190.png\" alt=\"img\" /></p>\n<p>安装重启 IDEA 之后，Settings 下搜索 Inspections，再查询 CheckStyle，如果能查询到内容，说明安装成功：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/1678510337645-569fb749-7e9a-4169-be90-201096220e50.png\" alt=\"img\" /></p>\n<p>在 Settings 中搜索 CheckStyle，按下图导入上一步骤新建的 checkstyle.xml 文件：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/1678510337666-1e3a909c-0615-4f4f-a190-33c8fbd45989.png\" alt=\"img\" /></p>\n<p>通过下述代码扫描 CheckStyle 代码规则，看是否需要需要变更：</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">/**</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>* 记录 C 用户用户变更日志</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>*</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>* @param customerOperationLogEvent</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>*/</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">recordCustomerUserOperationLog</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">OperationLogEvent</span> customerOperationLogEvent<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token class-name\">String</span> keys <span class=\"token operator\">=</span> <span class=\"token constant\">UUID</span><span class=\"token punctuation\">.</span><span class=\"token function\">randomUUID</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token class-name\">Message</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span><span class=\"token punctuation\">></span></span> message <span class=\"token operator\">=</span> <span class=\"token class-name\">MessageBuilder</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token punctuation\">.</span><span class=\"token function\">withPayload</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">MessageWrapper</span><span class=\"token punctuation\">(</span>keys<span class=\"token punctuation\">,</span> customerOperationLogEvent<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token punctuation\">.</span><span class=\"token function\">setHeader</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">MessageConst</span><span class=\"token punctuation\">.</span><span class=\"token constant\">PROPERTY_KEYS</span><span class=\"token punctuation\">,</span> keys<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token punctuation\">.</span><span class=\"token function\">setHeader</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">MessageConst</span><span class=\"token punctuation\">.</span><span class=\"token constant\">PROPERTY_TAGS</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">RocketMQConstants</span><span class=\"token punctuation\">.</span><span class=\"token constant\">CUSTOMER_USER_OPERATION_LOG_TAG</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    <span class=\"token punctuation\">.</span><span class=\"token function\">build</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token keyword\">long</span> startTime <span class=\"token operator\">=</span> <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span><span class=\"token function\">currentTimeMillis</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre><span class=\"token keyword\">boolean</span> sendResult <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre><span class=\"token keyword\">try</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>    sendResult <span class=\"token operator\">=</span> output<span class=\"token punctuation\">.</span><span class=\"token function\">send</span><span class=\"token punctuation\">(</span>message<span class=\"token punctuation\">,</span> <span class=\"token number\">2000L</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre><span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">finally</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>    log<span class=\"token punctuation\">.</span><span class=\"token function\">info</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"C 端用户保存用户日志，发送状态: &#123;&#125;, Keys: &#123;&#125;, 执行时间: &#123;&#125; ms, 消息内容: &#123;&#125;\"</span><span class=\"token punctuation\">,</span> sendResult<span class=\"token punctuation\">,</span> keys<span class=\"token punctuation\">,</span> <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span><span class=\"token function\">currentTimeMillis</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span> startTime<span class=\"token punctuation\">,</span> <span class=\"token constant\">JSON</span><span class=\"token punctuation\">.</span><span class=\"token function\">toJSONString</span><span class=\"token punctuation\">(</span>customerOperationLogEvent<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>通过控制台，可以看到该代码段有以下不规范的操作，双击提示，可以一步一步去解决规范的问题：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/1678510338145-441dfc3e-3860-456c-a5c7-9e875e5c83bd.png\" alt=\"img\" /></p>\n<h5 id=\"maven-插件\"><a class=\"anchor\" href=\"#maven-插件\">#</a> Maven 插件</h5>\n<p>在项目根目录新建一个 dev-support 文件夹，将代码规约配置文件放到此路径下，当然你也可以根据自己的需求去自行定义。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/1678510338312-ee096061-b7ad-43e7-86d9-ec21a4fdf0ce.png\" alt=\"img\" /></p>\n<p>在 Maven 中导入一个名为 maven-checkstyle-plugin 的插件，用于执行 <span class=\"exturl\" data-url=\"aHR0cDovL2NoZWNrc3R5bGUuc291cmNlZm9yZ2UubmV0Lw==\">CheckStyle</span> 任务。下面是一个简单的配置。在 Maven 工程中的 pom.xml 文件，添加内容如下：</p>\n<figure class=\"highlight xml\"><figcaption data-lang=\"XML\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>plugins</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>plugin</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>artifactId</span><span class=\"token punctuation\">></span></span>maven-checkstyle-plugin<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>artifactId</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>version</span><span class=\"token punctuation\">></span></span>3.1.0<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>version</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>configuration</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>      <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>configLocation</span><span class=\"token punctuation\">></span></span>$&#123;maven.multiModuleProjectDirectory&#125;/dev-support/checkstyle.xml<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>configLocation</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>      <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>includeTestSourceDirectory</span><span class=\"token punctuation\">></span></span>true<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>includeTestSourceDirectory</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>      <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>excludes</span><span class=\"token punctuation\">></span></span>**/autogen/**/*<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>excludes</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>configuration</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>executions</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>      <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>execution</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>id</span><span class=\"token punctuation\">></span></span>validate<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>id</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>goals</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>          <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>goal</span><span class=\"token punctuation\">></span></span>check<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>goal</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>goals</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>phase</span><span class=\"token punctuation\">></span></span>validate<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>phase</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>      <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>execution</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>executions</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>plugin</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>plugins</span><span class=\"token punctuation\">></span></span></pre></td></tr></table></figure><p>运行 CheckStyle 检查：</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>mvn checkstyle:check</pre></td></tr></table></figure><p>IDEA 和 Maven 插件可结合使用。</p>\n<h3 id=\"如何正确使用消息队列\"><a class=\"anchor\" href=\"#如何正确使用消息队列\">#</a> 如何正确使用消息队列</h3>\n<h4 id=\"命名规范\"><a class=\"anchor\" href=\"#命名规范\">#</a> 命名规范</h4>\n<p><strong>RocketMQ</strong> 相关命名强制使用<font color='red'>英文小写</font>。</p>\n<p>1）【强制】Topic 命名：业务线_项目名_topic。业务线或项目包含多个单词，使用 - 分割，例如： <code>common_message-center_topic</code> 。</p>\n<p>2）【强制】Tag 命名：业务线_项目_业务_tag，例如： <code>common_message-center_send-message_tag</code> 。</p>\n<p>3）【强制】生产者组命名：业务线_项目_业务_pg，例如： <code>common_message-center_send-message_pg</code> 。</p>\n<p>4）【强制】消费者组命名：业务线_项目_业务_cg，例如： <code>common_message-center_send-message_cg</code> 。</p>\n<h4 id=\"申请规范\"><a class=\"anchor\" href=\"#申请规范\">#</a> 申请规范</h4>\n<p>创建 Topic 需要走线上申请，申请时补充下述信息：</p>\n<hr />\n<p>申请人：马称</p>\n<p>Topic： <code>common_message-center_topic</code></p>\n<p>Produce：</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>生产应用</th>\n<th>生产者组</th>\n<th>Tag</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>message-center</td>\n<td>common_message-center_send-message_pg</td>\n<td>common_message-center_send-message_tag</td>\n<td>流量削峰</td>\n</tr>\n<tr>\n<td>2</td>\n<td>message-center</td>\n<td>common_message-center_send-message_pg</td>\n<td>insurance_trading-order_send-message-fail_tag</td>\n<td>微信模板消息发送失败通知保险项目</td>\n</tr>\n</tbody>\n</table>\n<p>Consume：</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>消费应用</th>\n<th>消费者组</th>\n<th>Tag</th>\n<th>消费模型</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>message-center</td>\n<td>common_message-center_send-message_cg</td>\n<td>common_message-center_send-message_tag</td>\n<td>集群模式</td>\n<td>发送微信模板、短信、小程序等消息</td>\n</tr>\n<tr>\n<td>2</td>\n<td>trading-order</td>\n<td>insurance_trading-order_send-message-fail_cg</td>\n<td>insurance_trading-order_send-message-fail_tag</td>\n<td>集群模式</td>\n<td>微信模板消息发送失败通知保险项目</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"使用规范\"><a class=\"anchor\" href=\"#使用规范\">#</a> 使用规范</h4>\n<h5 id=\"发送消息\"><a class=\"anchor\" href=\"#发送消息\">#</a> 发送消息</h5>\n<p>1）【强制】消息生产者创建时，<strong>必须指定生产者组</strong>。</p>\n<p>2）【强制】<strong>一个系统对应一个 Topic</strong>，系统下的<strong>不同业务根据 Tag 区分</strong>，参考申请规范 - 消费应用 Tag。</p>\n<p>3）【强制】发送消息时，需设置 KEYS。<strong>KEYS 建议定义为业务唯一标识</strong>，比如订单 ID。</p>\n<p>4）【强制】发送消息不管发送成功或失败，需打印 KEYS、Payload、执行时间以及 SendResult。</p>\n<p>5）【强制】发送消息时，<strong>需设置超时时间</strong>，避免应用被拖垮；建议超时时间设置为 2000ms 内。</p>\n<p>6）【建议】针对可靠性较高的消息，<strong>发送失败后可以存储到 DB，开启定时任务扫描，并重新投递</strong>。</p>\n<h5 id=\"消费消息\"><a class=\"anchor\" href=\"#消费消息\">#</a> 消费消息</h5>\n<p>1）【强制】消费端创建时，<strong>必须指定消费者组</strong>。</p>\n<p>2）【强制】消费端<strong>需要保证数据幂等</strong>。</p>\n<blockquote>\n<p>数据幂等：<strong>对同一操作的重复执行不会产生不同结果</strong>或不良影响。在数据处理和计算中，幂等性是一种重要的特性，确保系统<strong>在面对重复请求或操作时能够保持一致性和可靠性</strong>。</p>\n<p>具体来说，对于一个幂等操作，无论执行多少次，系统的状态都不会发生改变，或者改变是可控的。这对于数据处理和分布式系统尤为重要，因为在这些环境中，<font color='red'>可能会出现网络故障、请求超时、重传等情况，导致相同的请求被多次发送</font>。</p>\n<p>举例来说，假设有一个银行账户转账的操作是幂等的。如果一个用户发起了一笔转账请求，但由于网络问题或其他原因导致请求未得到及时的响应，用户可能会选择重新发送相同的请求。如果这个转账操作是幂等的，系统会确保无论接收到这个请求多少次，最终的结果都是一致的，即转账只会发生一次，不会重复扣款。</p>\n<p>在 Web 开发中，HTTP 方法的幂等性也是一个重要考虑因素。GET 请求通常是幂等的，因为它仅用于获取资源，而不会修改服务器状态。另一方面，<font color='red'>POST 请求通常不是幂等的，因为它可能会引起服务器状态的改变，而且多次执行可能产生不同的结果</font>。</p>\n</blockquote>\n<p>3）【强制】消费消息不管成功或失败，需打印 KEYS、MsgId、执行时间以及 Message。</p>\n<p>4）【强制】不同的应用集群应使用不同的消费者组，如果不同的应用集群需要订阅同一消费者组，需保证 Topic Tag 订阅关系一致。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/1663550134348-88d58115-092f-49cb-85d6-cf72280be781.png\" alt=\"img\" /></p>\n<p>5）【强制】引入  <code>easymall-rocketmq-spring-boot-starter</code>  打印消息消费日志。</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>log<span class=\"token punctuation\">.</span><span class=\"token function\">info</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Execute result: &#123;&#125;, Keys: &#123;&#125;, Dispatch time: &#123;&#125; ms, Execute time: &#123;&#125; ms, Message: &#123;&#125;\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>6）【建议】消费时<strong>尽量不设置重试</strong>，大部分情况下，执行失败的消息重试后会再次失败，反而会影响消费进度。开发者应该针对特定场景<strong>在代码中设置重试逻辑</strong>。</p>\n<p>7）【建议】消费者<strong>并发消费数量默认为 1，即串行化</strong>，应该基于不同系统场景来设置并发数，同时要考虑消费过程中其它组件的压力。</p>\n<ul>\n<li>系统 CPU 任务少： <code>CPU 核数 / (1 - 阻塞系数 0.8)</code>  。</li>\n<li>系统 CPU 任务较多，建议  <code>CPU 核数 + 1</code>  即可。</li>\n</ul>\n<h2 id=\"基础组件库\"><a class=\"anchor\" href=\"#基础组件库\">#</a> 基础组件库</h2>\n<h3 id=\"从0到1写组件库\"><a class=\"anchor\" href=\"#从0到1写组件库\">#</a> 从 0 到 1 写组件库</h3>\n<p>文章从零到一的<strong>封装设计 Starter</strong>，并提供<strong>可插拔 Starter</strong> 以及<strong>元数据配置</strong>等说明，并在可插拔上与开源 Zuul 进行比对，希望小伙伴看后有所收获。</p>\n<h4 id=\"springboot-starter\"><a class=\"anchor\" href=\"#springboot-starter\">#</a> SpringBoot Starter</h4>\n<h5 id=\"starter-定义\"><a class=\"anchor\" href=\"#starter-定义\">#</a> Starter 定义</h5>\n<p>SpringBoot Starter 类似于一种插件机制，抛弃了之前繁琐的配置，<font color='red'>将复杂依赖统一集成</font>进 Starter。</p>\n<p>所有依赖模块都遵循着约定成俗的默认配置，并允许我们调整这些配置，即遵循<font color='red'>“约定大于配置”</font>的理念。</p>\n<h5 id=\"starter-好处\"><a class=\"anchor\" href=\"#starter-好处\">#</a> Starter 好处</h5>\n<p>Starter 的出现极大地帮助开发者们<font color='red'>从繁琐的框架配置中解放出来</font>，从而更专注于业务代码。</p>\n<p>并且 SpringBoot <font color='red'>官方提供企业级项目不同场景的 Starter 依赖模块</font>，可以很便捷的集成进项目。</p>\n<p>比如 SpringBoot 项目需要依赖 Redis，我们只需要加入 spring-boot-starter-data-redis 依赖，并配置一些必须的连接信息。</p>\n<p><strong><font color='red'>使用者只需要引用 Starter 依赖，SpringBoot 就可以自动加载项目所需要的配置依赖，彻底摆脱了不同的依赖库引用以及版本问题</font></strong>。</p>\n<h4 id=\"自定义-starter\"><a class=\"anchor\" href=\"#自定义-starter\">#</a> 自定义 Starter</h4>\n<h5 id=\"starter-命名\"><a class=\"anchor\" href=\"#starter-命名\">#</a> Starter 命名</h5>\n<p>官方对 Starter 包定义的 ArtifactId 是有要求的，当然也可以不遵守（毕竟你的项目你做主）。</p>\n<p>Spring <font color='red'>官方提供 Starter 通常命名为  <code>spring-boot-starter-&#123;name&#125;</code> </font>，如：spring-boot-starter-web，spring-boot-starter-activemq 等，这里放一部分官方提供列表，详情查看 SpringBoot Starter 列表。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/1689558671062-acc51f4b-253d-4017-ae5e-4fa71f43c1a6.png\" alt=\"img\" /></p>\n<p>Spring 官方建议<font color='red'>非官方提供的 Starter 命名应遵守  <code>&#123;name&#125;-spring-boot-starter</code>  的格式</font>。</p>\n<p>比如 MyBatis 出品的：mybatis-spring-boot-starter。</p>\n<h5 id=\"创建-springboot-项目-2\"><a class=\"anchor\" href=\"#创建-springboot-项目-2\">#</a> 创建 SpringBoot 项目</h5>\n<p><font color='red'>Starter 也是基于 SpringBoot 项目创建的</font>，所以第一步应该先创建 SpringBoot 项目。</p>\n<p>创建工程完成后，删除不必要文件，目录如下：</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>├── pom<span class=\"token punctuation\">.</span>xml</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>└── src</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    ├── main</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    │   ├── java</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    │   │   └── cn</pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    │   │       └── machen</pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    │   │           └── starter</pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    │   │               └── demospringbootstarter</pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    │   └── resources</pre></td></tr></table></figure><h5 id=\"pom-依赖配置\"><a class=\"anchor\" href=\"#pom-依赖配置\">#</a> Pom 依赖配置</h5>\n<p>pom.xml 中依赖非常简洁，除了<font color='red'>项目的基本信息</font>和<font color='red'>父类引用</font>，只需<font color='red'>引用 spring-boot-starter</font> 即可。</p>\n<figure class=\"highlight xml\"><figcaption data-lang=\"XML\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token prolog\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>project</span> <span class=\"token attr-name\">xmlns</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>http://maven.apache.org/POM/4.0.0<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\"><span class=\"token namespace\">xmlns:</span>xsi</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>http://www.w3.org/2001/XMLSchema-instance<span class=\"token punctuation\">\"</span></span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>         <span class=\"token attr-name\"><span class=\"token namespace\">xsi:</span>schemaLocation</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>modelVersion</span><span class=\"token punctuation\">></span></span>4.0.0<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>modelVersion</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>parent</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>groupId</span><span class=\"token punctuation\">></span></span>org.springframework.boot<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>groupId</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>artifactId</span><span class=\"token punctuation\">></span></span>spring-boot-starter-parent<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>artifactId</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>version</span><span class=\"token punctuation\">></span></span>2.2.11.RELEASE<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>version</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>relativePath</span><span class=\"token punctuation\">/></span></span> <span class=\"token comment\">&lt;!-- lookup parent from repository --></span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>parent</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>groupId</span><span class=\"token punctuation\">></span></span>cn.machen.starter<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>groupId</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>artifactId</span><span class=\"token punctuation\">></span></span>demo-spring-boot-starter<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>artifactId</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>version</span><span class=\"token punctuation\">></span></span>0.0.1-SNAPSHOT<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>version</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>properties</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>java.version</span><span class=\"token punctuation\">></span></span>1.8<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>java.version</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>properties</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>dependencies</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>dependency</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>            <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>groupId</span><span class=\"token punctuation\">></span></span>org.springframework.boot<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>groupId</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>            <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>artifactId</span><span class=\"token punctuation\">></span></span>spring-boot-starter<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>artifactId</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>dependency</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>dependencies</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre></pre></td></tr><tr><td data-num=\"26\"></td><td><pre><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>project</span><span class=\"token punctuation\">></span></span></pre></td></tr></table></figure><h5 id=\"自动配置类\"><a class=\"anchor\" href=\"#自动配置类\">#</a> 自动配置类</h5>\n<p>创建一个注册为 Spring Bean 的 Service 类，提供一个 sayHello 方法以供后续测试。</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">ServiceBean</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token class-name\">String</span> <span class=\"token function\">sayHello</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> name<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>        <span class=\"token keyword\">return</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">.</span><span class=\"token function\">format</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Hello World, %s\"</span><span class=\"token punctuation\">,</span> name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p><font color='red'>创建自动配置类</font>，将 ServiceBean 进行<font color='red'>声明 Bean</font>，等待扫描后交付给 Spring Ioc 容器。</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token annotation punctuation\">@Configuration</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">AutoConfigurationTest</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token annotation punctuation\">@Bean</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token class-name\">ServiceBean</span> <span class=\"token function\">getServiceBean</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>        <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ServiceBean</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h5 id=\"springfactories\"><a class=\"anchor\" href=\"#springfactories\">#</a> spring.factories</h5>\n<p><font color='red'>项目 Resources 目录下新建 META-INF 文件夹</font>，然后创建 spring.factories 文件。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/1689558646997-4699c8ed-f6e0-4dff-b666-ee5bad6a5122.png\" alt=\"img\" /></p>\n<p>文件中<font color='red'>定义 Autoconfigure 指定配置类为自动装配的配置</font>。</p>\n<figure class=\"highlight xml\"><figcaption data-lang=\"XML\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>org.springframework.boot.autoconfigure.EnableAutoConfiguration=\\</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>  cn.machen.starter.demospringbootstarter.AutoConfigurationTest</pre></td></tr></table></figure><p><strong>为什么要指定 resources/META-INF 下写 spring.factories？不这么写不行啊。</strong></p>\n<p><code>SpringFactoriesLoader#loadFactories</code>  负责完成自动装配类的加载，扫描的就是 spring.factories 这个变量文件。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/1689558671063-d0f23e9a-950d-4fb0-a40b-f9c3812e44b0.png\" alt=\"img\" /></p>\n<h5 id=\"打包项目发布仓库\"><a class=\"anchor\" href=\"#打包项目发布仓库\">#</a> 打包项目，发布仓库</h5>\n<p>我们提供 Starter 肯定是要被第三方或者我们其它项目所引用的，所以要把项目打包后发布到仓库中。</p>\n<blockquote>\n<p>这里科普一下 Maven 命令知识点，一般我们打包使用比较多的命令就是 package、install、deploy。</p>\n<p>声明一点就是这三个命令都能打包，而且是步骤递增关系：</p>\n<ul>\n<li>**package：** 该命令完成了<font color='red'>项目编译、单元测试、打包</font>功能三个过程。</li>\n<li>**install：** 在 package 命令的前提下新增一个步骤，将新打好的包<font color='red'>部署到本地 Maven 仓库</font>。</li>\n<li>**deploy：** 在 install 命令的前提下新增一个步骤，将新打的包<font color='red'>部署到远端仓库（相当于本地和远端仓库同时部署一份）</font>。</li>\n</ul>\n</blockquote>\n<p>而我们只是本地仓库引用，只需要 install 命令执行即可，两种方式分别是 Maven 插件或者终端执行命令 <strong>mvn clean install。</strong></p>\n<p><img data-src=\"https://cdn.nlark.com/yuque/0/2023/png/331027/1689558671126-92a4ae4b-6986-45dd-82d3-71299e0418c3.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_28%2Ctext_5pCc77yabmFnZW9mZmVyLmNvbQ%3D%3D%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10\" alt=\"img\" /></p>\n<p>可以去对应的仓库坐标下查看 Jar 是否部署成功。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/1689558671063-60c05bbe-880b-4c34-8041-d27add2f8313.png\" alt=\"img\" /></p>\n<h5 id=\"测试-starter\"><a class=\"anchor\" href=\"#测试-starter\">#</a> 测试 Starter</h5>\n<p>我们如何测试刚才新建的 Starter 是否成功了呢？新建一个项目 demo-test ，然后在 pom.xml 文件中引用 demo 的 Starter 项目坐标就可以了。</p>\n<figure class=\"highlight xml\"><figcaption data-lang=\"XML\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token prolog\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>project</span> <span class=\"token attr-name\">xmlns</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>http://maven.apache.org/POM/4.0.0<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\"><span class=\"token namespace\">xmlns:</span>xsi</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>http://www.w3.org/2001/XMLSchema-instance<span class=\"token punctuation\">\"</span></span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>         <span class=\"token attr-name\"><span class=\"token namespace\">xsi:</span>schemaLocation</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>modelVersion</span><span class=\"token punctuation\">></span></span>4.0.0<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>modelVersion</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>parent</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>groupId</span><span class=\"token punctuation\">></span></span>org.springframework.boot<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>groupId</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>artifactId</span><span class=\"token punctuation\">></span></span>spring-boot-starter-parent<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>artifactId</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>version</span><span class=\"token punctuation\">></span></span>2.2.11.RELEASE<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>version</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>relativePath</span><span class=\"token punctuation\">/></span></span> <span class=\"token comment\">&lt;!-- lookup parent from repository --></span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>parent</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>groupId</span><span class=\"token punctuation\">></span></span>cn.machen.starter<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>groupId</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>artifactId</span><span class=\"token punctuation\">></span></span>demo-test-spring-boot-starter<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>artifactId</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>version</span><span class=\"token punctuation\">></span></span>0.0.1-SNAPSHOT<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>version</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>dependencies</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>dependency</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>            <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>groupId</span><span class=\"token punctuation\">></span></span>org.springframework.boot<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>groupId</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>            <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>artifactId</span><span class=\"token punctuation\">></span></span>spring-boot-starter<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>artifactId</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>dependency</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>        <span class=\"token comment\">&lt;!-- 引入 starter 包 --></span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>dependency</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>            <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>groupId</span><span class=\"token punctuation\">></span></span>cn.machen.starter<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>groupId</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>            <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>artifactId</span><span class=\"token punctuation\">></span></span>demo-spring-boot-starter<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>artifactId</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>            <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>version</span><span class=\"token punctuation\">></span></span>$&#123;project.version&#125;<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>version</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>dependency</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>dependency</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>            <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>groupId</span><span class=\"token punctuation\">></span></span>org.springframework.boot<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>groupId</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>            <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>artifactId</span><span class=\"token punctuation\">></span></span>spring-boot-starter-test<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>artifactId</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>            <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>scope</span><span class=\"token punctuation\">></span></span>test<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>scope</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre>            <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>exclusions</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"32\"></td><td><pre>                <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>exclusion</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"33\"></td><td><pre>                    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>groupId</span><span class=\"token punctuation\">></span></span>org.junit.vintage<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>groupId</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"34\"></td><td><pre>                    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>artifactId</span><span class=\"token punctuation\">></span></span>junit-vintage-engine<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>artifactId</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"35\"></td><td><pre>                <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>exclusion</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"36\"></td><td><pre>            <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>exclusions</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"37\"></td><td><pre>        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>dependency</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"38\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>dependencies</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"39\"></td><td><pre><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>project</span><span class=\"token punctuation\">></span></span></pre></td></tr></table></figure><p>既然是测试，<strong>达到什么样的标准才算通过呢？</strong></p>\n<p>根据我们 Starter 中定义代码，只要 demo-test 项目 <strong>引用 ServiceBean 打印输出对应信息</strong> 即算成功。</p>\n<p>src-main-test 目录下使用项目创建自带的测试类。</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token annotation punctuation\">@SpringBootTest</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">class</span> <span class=\"token class-name\">DemoTestSpringBootStarterApplicationTests</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token annotation punctuation\">@Autowired</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token keyword\">private</span> <span class=\"token class-name\">ServiceBean</span> serviceBean<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token annotation punctuation\">@Test</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token keyword\">void</span> <span class=\"token function\">contextLoads</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>serviceBean<span class=\"token punctuation\">.</span><span class=\"token function\">sayHello</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"machen\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>运行 contextLoads 测试方法，最终输出 <strong>Hello World, machen。</strong></p>\n<p>你以为这就结束了么？不不不，硬核且干的知识才刚刚开始。</p>\n<h4 id=\"可插拔-starter\"><a class=\"anchor\" href=\"#可插拔-starter\">#</a> 可插拔 Starter</h4>\n<h5 id=\"自定义可插拔-starter\"><a class=\"anchor\" href=\"#自定义可插拔-starter\">#</a> 自定义可插拔 Starter</h5>\n<p>Starter 就是 Starter，咋起了个名字叫 <strong>可插拔。</strong></p>\n<p>所谓可插拔，字面意思理解就是虽然我引入了你的 Starter Jar 包，但是<font color='red'>可以通过条件判断是否加载 Starter 的功能</font>。</p>\n<p>满足条件的话加载此 Jar 相关配置，不满足就哪凉快哪歇着吧（比较白话哈，具体点就是模块插件化，降低耦合）。</p>\n<p>实现可插拔的方式有很多，通过<font color='red'>配置文件 Key 前缀</font>或者<font color='red'>自定义注解</font>等，但是这些都绕不过 SpringBoot 的<font color='red'>条件注解</font>。</p>\n<p>文章使用<font color='gree'>自定义注解 + 条件注解</font>的形式完成，其余这里就不一一举例了，大家可以网上自行搜索。</p>\n<hr />\n<p><strong>demo-spring-boot-starter</strong></p>\n<p>1）首先在项目中创建<font color='red'>自定义注解</font> @EnableAutoConfigTest 。</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token annotation punctuation\">@Target</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">ElementType</span><span class=\"token punctuation\">.</span><span class=\"token constant\">TYPE</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token annotation punctuation\">@Retention</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">RetentionPolicy</span><span class=\"token punctuation\">.</span><span class=\"token constant\">RUNTIME</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token annotation punctuation\">@interface</span> <span class=\"token class-name\">EnableAutoConfigTest</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>2）AutoConfigurationTest 类中添加<font color='red'>条件注解</font> @ConditionalOnBean ，然后<font color='red'>重新打包</font>至本地仓库。</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token annotation punctuation\">@Configuration</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token annotation punctuation\">@ConditionalOnBean</span><span class=\"token punctuation\">(</span>annotation <span class=\"token operator\">=</span> <span class=\"token class-name\">EnableAutoConfigTest</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">AutoConfigurationTest</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token annotation punctuation\">@Bean</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token class-name\">ServiceBean</span> <span class=\"token function\">getServiceBean</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>        <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ServiceBean</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><blockquote>\n<p>解读  <code>@ConditionalOnBean(annotation = EnableAutoConfigTest.class)</code>  ：</p>\n<p><code>@ConditionalOnBean</code>  注解用于<font color='red'>指定一个或多个 bean 存在时，才会启用被注解的类或配置</font>。因此  <code>@ConditionalOnBean(annotation = EnableAutoConfigTest.class)</code>  表示被注解的类或配置（AutoConfigurationTest）只有在存在带有  <code>EnableAutoConfigTest</code>  注解的 bean（下文中的 DemoTestSpringBootStarterApplication）时才会生效。</p>\n<p>这通常用于在 Spring Boot 自动配置中，根据特定的条件来决定是否启用某个配置类。</p>\n</blockquote>\n<p><strong>demo-test-spring-boot-starter</strong></p>\n<p>1）在主程序引用 @EnableAutoConfigTest 注解 。</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token annotation punctuation\">@EnableAutoConfigTest</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token annotation punctuation\">@SpringBootApplication</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">DemoTestSpringBootStarterApplication</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>        <span class=\"token class-name\">SpringApplication</span><span class=\"token punctuation\">.</span><span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">DemoTestSpringBootStarterApplication</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">,</span> args<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p><strong>测试可插拔 starter</strong></p>\n<p>跑一下上文测试类中运行程序，这样的常规操作自然可以正常打印我们的 Hello World。</p>\n<p>跑程序谁家只跑正常的呀是不是，把 @EnableAutoConfigTest 删了试一哈，看迎接咱的是不是这玩意。</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token class-name\">Unsatisfied</span> dependency expressed through field 'serviceBean'<span class=\"token punctuation\">;</span> nested exception is <span class=\"token class-name\"><span class=\"token namespace\">org<span class=\"token punctuation\">.</span>springframework<span class=\"token punctuation\">.</span>beans<span class=\"token punctuation\">.</span>factory<span class=\"token punctuation\">.</span></span>NoSuchBeanDefinitionException</span><span class=\"token operator\">:</span> <span class=\"token class-name\">No</span> qualifying bean of type '<span class=\"token class-name\"><span class=\"token namespace\">cn<span class=\"token punctuation\">.</span>machen<span class=\"token punctuation\">.</span>starter<span class=\"token punctuation\">.</span>demospringbootstarter<span class=\"token punctuation\">.</span></span>ServiceBean</span>' available<span class=\"token operator\">:</span> expected at least <span class=\"token number\">1</span> bean which qualifies as autowire <span class=\"token class-name\"><span class=\"token namespace\">candidate<span class=\"token punctuation\">.</span></span> Dependency</span> annotations<span class=\"token operator\">:</span> <span class=\"token punctuation\">&#123;</span><span class=\"token annotation punctuation\">@org.springframework.beans.factory.annotation.Autowired</span><span class=\"token punctuation\">(</span>required<span class=\"token operator\">=</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>当然，正式环境上可不能实现的这么糙哈，不过，思路都是一致的。</p>\n<p>之前参与公司搜索业务封装 Starter，就是采用上述自定义注解结合条件注解完成的。</p>\n<p>其实除了文中可插拔的实现之外，像 SpringCloud Zuul 也是类似的思路，因为就这点玩意，也玩不出个花。</p>\n<h5 id=\"zuul-实现可插拔原理\"><a class=\"anchor\" href=\"#zuul-实现可插拔原理\">#</a> Zuul 实现可插拔原理</h5>\n<p>我们通常是通过配置类上配置 zuul 注解  <code>@EnableZuulProxy</code>  开启 Zuul 注入功能。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/1689558671095-50016818-1b35-4e51-97ca-718f984a32d0.png\" alt=\"img\" /></p>\n<p>看一下图片中标红的类起到了什么作用。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/1689558671737-05cfdd86-2429-40ff-8fae-0c8d63d24ef7.png\" alt=\"img\" /></p>\n<p>通过类上的注释得知：</p>\n<p>负责添加标记 bean 以触发 {@link  ZuulProxyAutoConfiguration} 的激活。</p>\n<p>其实到这里就已经很明白了，但是本着负责到底的良好品质，继续跟进。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/1689558671994-b1b78afb-9501-4487-8e52-0c33974fce3e.png\" alt=\"img\" /></p>\n<p>和我们上面自定义可插拔 Starter 思想一致，通过一个标记来实现可插拔特性。</p>\n<p>不同的是 Zuul 中使用过一个无实际意义的 Bean 来标记，而我们使用的注解。</p>\n<h4 id=\"配置元数据\"><a class=\"anchor\" href=\"#配置元数据\">#</a> 配置元数据</h4>\n<p>不知道小伙伴在项目配置文件中输入时，看到智能提示时，有没有疑惑怎么实现的？</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/1689558672059-9bbc286d-93e5-4bd7-848b-8858488278e1.png\" alt=\"img\" /></p>\n<p>以 <span class=\"exturl\" data-url=\"aHR0cDovL3NlcnZlci54eHg=\">server.xxx</span> 为例，带着疑惑打开 SpringBoot 源码包下的  <code>spring-configuration-metadata.json</code> 。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/1689558672204-c80f2b61-5aa1-4bf1-a0b3-4989a8027460.png\" alt=\"img\" /></p>\n<p>看到 defaultValue 和 description 熟悉么？可不就是上文中提示的默认值以及提示信息嘛。</p>\n<p>这种文件如何产生的呢？有两种方式：</p>\n<ol>\n<li>通过建立  <code>META-INF/spring-configuration-metadata.json</code>  文件，开发者<font color='red'>手动配置</font>。</li>\n<li>还有一种是通过注解  <code>@ConfigurationProperties</code>  方式<font color='red'>自动生成</font>。</li>\n</ol>\n<p>实现元数据配置只需要在 starter 包下简单三步操作：</p>\n<p>1）pom.xml 文件中<font color='red'>引入  <code>spring-boot-configuration-processor</code>  包</font>。</p>\n<figure class=\"highlight xml\"><figcaption data-lang=\"XML\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>dependency</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>groupId</span><span class=\"token punctuation\">></span></span>org.springframework.boot<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>groupId</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>artifactId</span><span class=\"token punctuation\">></span></span>spring-boot-configuration-processor<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>artifactId</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>dependency</span><span class=\"token punctuation\">></span></span></pre></td></tr></table></figure><p>2）<font color='red'>编写 Properties 配置类</font>，以 Swagger 示例。</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token annotation punctuation\">@Data</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token annotation punctuation\">@Configuration</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token annotation punctuation\">@ConfigurationProperties</span><span class=\"token punctuation\">(</span>prefix <span class=\"token operator\">=</span> <span class=\"token string\">\"swagger\"</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// 用于自动生成 swagger 相关的元数据配置</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">SwaggerProperties</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token comment\">/**</pre></td></tr><tr><td data-num=\"7\"></td><td><pre>     * 文档扫描包路径</pre></td></tr><tr><td data-num=\"8\"></td><td><pre>     */</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> basePackage <span class=\"token operator\">=</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token comment\">/**</pre></td></tr><tr><td data-num=\"12\"></td><td><pre>     * title 示例：订单创建接口</pre></td></tr><tr><td data-num=\"13\"></td><td><pre>     */</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    <span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> title <span class=\"token operator\">=</span> <span class=\"token string\">\"平台系统接口详情\"</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>    <span class=\"token comment\">/**</pre></td></tr><tr><td data-num=\"17\"></td><td><pre>     * 服务条款网址</pre></td></tr><tr><td data-num=\"18\"></td><td><pre>     */</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>    <span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> termsOfServiceUrl <span class=\"token operator\">=</span> <span class=\"token string\">\"https://www.xxxx.com/\"</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>    <span class=\"token comment\">/**</pre></td></tr><tr><td data-num=\"22\"></td><td><pre>     * 版本号</pre></td></tr><tr><td data-num=\"23\"></td><td><pre>     */</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>    <span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> version <span class=\"token operator\">=</span> <span class=\"token string\">\"V_1.0.0\"</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre></pre></td></tr><tr><td data-num=\"26\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>3）最后<font color='red'>执行打包命令</font>，更新本地仓库 Jar 包。</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>mvn clean <span class=\"token function\">install</span></pre></td></tr></table></figure><p>接下来在 demo-test-spring-boot-starter 项目更新引用，然后在 application.properties 测试一下。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/1689558672684-292abf88-e9e6-491d-aa72-96fa4958574f.png\" alt=\"img\" /></p>\n<h4 id=\"mybatis-starter-如何实现\"><a class=\"anchor\" href=\"#mybatis-starter-如何实现\">#</a> MyBatis Starter 如何实现</h4>\n<p>我们引一下相关 pom 包依赖，如果大家平常找不到相关依赖包，可以在公共仓库上搜索。</p>\n<blockquote>\n<p>公共仓库地址：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9tdm5yZXBvc2l0b3J5LmNvbS8=\">https://mvnrepository.com/</span></p>\n</blockquote>\n<figure class=\"highlight xml\"><figcaption data-lang=\"XML\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>dependency</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>groupId</span><span class=\"token punctuation\">></span></span>org.mybatis.spring.boot<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>groupId</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>artifactId</span><span class=\"token punctuation\">></span></span>mybatis-spring-boot-starter<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>artifactId</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>version</span><span class=\"token punctuation\">></span></span>1.3.2<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>version</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>dependency</span><span class=\"token punctuation\">></span></span></pre></td></tr></table></figure><p>看一下 Mybatis Starter 包里都包含什么内容，是否和我们自定义一致。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/1689558673546-dfbd5983-9ef6-4e6b-b631-f8cb8bbb4bd2.png\" alt=\"img\" /></p>\n<p>why？这里面为啥该有的配置类元信息啥的都没有？点进去可能找到答案的 pom.xml 看一哈。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/1689558674073-acccad26-b699-4580-8775-d6d7443f8ade.png\" alt=\"img\" /></p>\n<p>可以看到 pom.xml 中包含 mybatis-spring-boot-autoconfigure、mybatis、mybatis-spring 依赖。</p>\n<p>而<font color='red'>真正让 Mybatis 进行全局初始化的秘密就在  <code>mybatis-spring-boot-autoconfigure</code>  中</font>。</p>\n<p><img data-src=\"https://cdn.nlark.com/yuque/0/2023/png/331027/1689558674581-31461b29-443c-4b7b-9ef6-667c45a664a7.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_57%2Ctext_5pCc77yabmFnZW9mZmVyLmNvbQ%3D%3D%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10\" alt=\"img\" /></p>\n<p>到这里就很明确了，mybatis-spring-boot-autoconfigure 包含初始化配置类 MybatisAutoConfiguration，在其中做了 Mybatis 相关初始化。</p>\n<p><strong>MyBatis Starter 设计与我们上文讲的自定义 Starter 有何不同？</strong></p>\n<p>Mybatis Starter 并没有做什么操作，只是做了一个组合依赖作用，起到初始化作用的是其中 Autoconfigure 包。</p>\n<p>springboot 也是这种思想，只不过它是将所有包的 autoconfigure 实现统一发现的，大家看一下 spring-boot-autoconfigure-xxx.jar 就会明白。</p>\n<p>而我们<strong>自定义 Starter 中就少了依赖 Autoconfigure 包这个环节</strong>，两者无关对错，只是不同设计的体现，这里不作任何建议，看个人喜好。</p>\n<p>啥？你说要跟着主流走，严格贯彻 SpringBoot 思想？</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/1689558674652-271637d0-548a-4b36-af5e-81183739f714.jpeg\" alt=\"img\" /></p>\n<p>就料到你会这么想，所以我们也搬来了 “重量级” 选手 Netflix。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/1689558675315-f64f0b79-29aa-45a5-bda9-c7b123fd4d65.png\" alt=\"img\" /></p>\n<p>懂的人自然懂，看心情实现 Starter 吧，一天到晚写 BUG 的互联网人。</p>\n<h3 id=\"基础组件模块\"><a class=\"anchor\" href=\"#基础组件模块\">#</a> 基础组件模块</h3>\n<blockquote>\n<p>base</p>\n</blockquote>\n<h4 id=\"组件地址\"><a class=\"anchor\" href=\"#组件地址\">#</a> 组件地址</h4>\n<figure class=\"highlight xml\"><figcaption data-lang=\"XML\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>dependency</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>groupId</span><span class=\"token punctuation\">></span></span>org.opengoofy.index12306<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>groupId</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>artifactId</span><span class=\"token punctuation\">></span></span>index12306-base-spring-boot-starter<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>artifactId</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>version</span><span class=\"token punctuation\">></span></span>$&#123;project.version&#125;<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>version</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>dependency</span><span class=\"token punctuation\">></span></span></pre></td></tr></table></figure><p><code>index12306-base-spring-boot-starter</code>  在 12306 的整体规划中，属于<font color='red'>顶层组件或基础组件</font>。</p>\n<p>那什么样的组件能被称为顶层？可以从几个方面去说明这个问题：</p>\n<ul>\n<li>兼容性：能够被所有组件或者所有客户端项目所依赖，不会存在兼容性的代码组件。</li>\n<li>功能性：独立且公用的功能可被用户无感知依赖。比如当 fastjson 出现安全漏洞，可通过升级顶层组件来解决所有依赖包问题。</li>\n</ul>\n<h4 id=\"组件概览\"><a class=\"anchor\" href=\"#组件概览\">#</a> 组件概览</h4>\n<ol>\n<li>定义<font color='red'>全局配置常量</font>和<font color='red'>过滤器执行顺序</font>。</li>\n<li><font color='red'>封装 Spring 应用上下文</font>  <code>ApplicationContextHolder</code> 。</li>\n<li><font color='red'>封装 FastJSON 安全模式</font>，客户端可通过配置  <code>fastjson.safa-mode=true</code>  开启安全模式。</li>\n<li><font color='red'>封装应用初始化事件</font>，通过 Spring  <code>ApplicationReadyEvent</code>  进行发布，并保证仅执行一次  <code>ApplicationInitializingEvent</code> 。</li>\n<li><font color='red'>单例对象容器</font>，可避免重复创建对象，方便全局访问。</li>\n</ol>\n<h4 id=\"组件功能\"><a class=\"anchor\" href=\"#组件功能\">#</a> 组件功能</h4>\n<h5 id=\"全局变量-组件执行顺序\"><a class=\"anchor\" href=\"#全局变量-组件执行顺序\">#</a> 全局变量 &amp; 组件执行顺序</h5>\n<h6 id=\"全局用户常量\"><a class=\"anchor\" href=\"#全局用户常量\">#</a> 全局用户常量</h6>\n<blockquote>\n<p>UserConstant</p>\n</blockquote>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">package</span> <span class=\"token namespace\">org<span class=\"token punctuation\">.</span>opengoofy<span class=\"token punctuation\">.</span>index12306<span class=\"token punctuation\">.</span>framework<span class=\"token punctuation\">.</span>starter<span class=\"token punctuation\">.</span>bases<span class=\"token punctuation\">.</span>constant</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token comment\">/**</pre></td></tr><tr><td data-num=\"4\"></td><td><pre> * 用户常量</pre></td></tr><tr><td data-num=\"5\"></td><td><pre> *</pre></td></tr><tr><td data-num=\"6\"></td><td><pre> * @公众号：马丁玩编程，回复：加群，添加马哥微信（备注：12306）获取项目资料</pre></td></tr><tr><td data-num=\"7\"></td><td><pre> */</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">UserConstant</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token comment\">/**</pre></td></tr><tr><td data-num=\"11\"></td><td><pre>     * 用户 ID Key</pre></td></tr><tr><td data-num=\"12\"></td><td><pre>     */</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">String</span> <span class=\"token constant\">USER_ID_KEY</span> <span class=\"token operator\">=</span> <span class=\"token string\">\"userId\"</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    <span class=\"token comment\">/**</pre></td></tr><tr><td data-num=\"16\"></td><td><pre>     * 用户名 Key</pre></td></tr><tr><td data-num=\"17\"></td><td><pre>     */</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">String</span> <span class=\"token constant\">USER_NAME_KEY</span> <span class=\"token operator\">=</span> <span class=\"token string\">\"username\"</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>    <span class=\"token comment\">/**</pre></td></tr><tr><td data-num=\"21\"></td><td><pre>     * 用户真实名称 Key</pre></td></tr><tr><td data-num=\"22\"></td><td><pre>     */</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">String</span> <span class=\"token constant\">REAL_NAME_KEY</span> <span class=\"token operator\">=</span> <span class=\"token string\">\"realName\"</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>    <span class=\"token comment\">/**</pre></td></tr><tr><td data-num=\"26\"></td><td><pre>     * 用户 Token Key</pre></td></tr><tr><td data-num=\"27\"></td><td><pre>     */</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">String</span> <span class=\"token constant\">USER_TOKEN_KEY</span> <span class=\"token operator\">=</span> <span class=\"token string\">\"token\"</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>思考下，为什么要定义这个全局变量定义常量类？</p>\n<p>如果没有定义在顶级组件库中，那么这些常量都是定义在各个组件库中的。比如用户的常量定义在用户的组件库中。</p>\n<p>那又为什么把这个抽象提炼出来？</p>\n<p>一旦涉及到抽象提炼的工作，就能说明，这个常量肯定不是只在用户组件库中使用。因为在网关中，将用户 Token 进行解析，并放到 HTTP Header 中，最终放到用户请求上下文，也需要用到这些用户常量。</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token annotation punctuation\">@Override</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token class-name\">GatewayFilter</span> <span class=\"token function\">apply</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Config</span> config<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>exchange<span class=\"token punctuation\">,</span> chain<span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>        <span class=\"token class-name\">ServerHttpRequest</span> request <span class=\"token operator\">=</span> exchange<span class=\"token punctuation\">.</span><span class=\"token function\">getRequest</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>        <span class=\"token class-name\">String</span> requestPath <span class=\"token operator\">=</span> request<span class=\"token punctuation\">.</span><span class=\"token function\">getPath</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isPathInBlackPreList</span><span class=\"token punctuation\">(</span>requestPath<span class=\"token punctuation\">,</span> config<span class=\"token punctuation\">.</span><span class=\"token function\">getBlackPathPre</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>            <span class=\"token class-name\">String</span> token <span class=\"token operator\">=</span> request<span class=\"token punctuation\">.</span><span class=\"token function\">getHeaders</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getFirst</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Authorization\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>            <span class=\"token class-name\">UserInfoDTO</span> userInfo <span class=\"token operator\">=</span> <span class=\"token class-name\">JWTUtil</span><span class=\"token punctuation\">.</span><span class=\"token function\">parseJwtToken</span><span class=\"token punctuation\">(</span>token<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token function\">validateToken</span><span class=\"token punctuation\">(</span>userInfo<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>                <span class=\"token class-name\">ServerHttpResponse</span> response <span class=\"token operator\">=</span> exchange<span class=\"token punctuation\">.</span><span class=\"token function\">getResponse</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>                response<span class=\"token punctuation\">.</span><span class=\"token function\">setStatusCode</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">HttpStatus</span><span class=\"token punctuation\">.</span><span class=\"token constant\">UNAUTHORIZED</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>                <span class=\"token keyword\">return</span> response<span class=\"token punctuation\">.</span><span class=\"token function\">setComplete</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>            <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>            <span class=\"token class-name\">ServerHttpRequest<span class=\"token punctuation\">.</span>Builder</span> builder <span class=\"token operator\">=</span> exchange<span class=\"token punctuation\">.</span><span class=\"token function\">getRequest</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">mutate</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">headers</span><span class=\"token punctuation\">(</span>httpHeaders <span class=\"token operator\">-></span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>                <span class=\"token comment\">// 通过 HTTP Token 获取用户 ID 放入 HTTP Header 中</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>                httpHeaders<span class=\"token punctuation\">.</span><span class=\"token function\">set</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">UserConstant</span><span class=\"token punctuation\">.</span><span class=\"token constant\">USER_ID_KEY</span><span class=\"token punctuation\">,</span> userInfo<span class=\"token punctuation\">.</span><span class=\"token function\">getUserId</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>                <span class=\"token comment\">// 同上</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>                httpHeaders<span class=\"token punctuation\">.</span><span class=\"token function\">set</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">UserConstant</span><span class=\"token punctuation\">.</span><span class=\"token constant\">USER_NAME_KEY</span><span class=\"token punctuation\">,</span> userInfo<span class=\"token punctuation\">.</span><span class=\"token function\">getUsername</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>                <span class=\"token keyword\">try</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>                    <span class=\"token comment\">// 同上</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>                    httpHeaders<span class=\"token punctuation\">.</span><span class=\"token function\">set</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">UserConstant</span><span class=\"token punctuation\">.</span><span class=\"token constant\">REAL_NAME_KEY</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">URLEncoder</span><span class=\"token punctuation\">.</span><span class=\"token function\">encode</span><span class=\"token punctuation\">(</span>userInfo<span class=\"token punctuation\">.</span><span class=\"token function\">getRealName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"UTF-8\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>                <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">UnsupportedEncodingException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>                    <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">RuntimeException</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>                <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>            <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>            <span class=\"token keyword\">return</span> chain<span class=\"token punctuation\">.</span><span class=\"token function\">filter</span><span class=\"token punctuation\">(</span>exchange<span class=\"token punctuation\">.</span><span class=\"token function\">mutate</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">request</span><span class=\"token punctuation\">(</span>builder<span class=\"token punctuation\">.</span><span class=\"token function\">build</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">build</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>        <span class=\"token keyword\">return</span> chain<span class=\"token punctuation\">.</span><span class=\"token function\">filter</span><span class=\"token punctuation\">(</span>exchange<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>类似于 **<font color='red'>这种多处使用的变量，分别定义肯定是不优雅的</font>**，那我们只能找个地方将这个定义，并被用户和网关同时使用。<strong>基础组件库因为要被每个组件库依赖，所以是最好的选择</strong>。</p>\n<h6 id=\"全局过滤器顺序执行常量类\"><a class=\"anchor\" href=\"#全局过滤器顺序执行常量类\">#</a> 全局过滤器顺序执行常量类</h6>\n<blockquote>\n<p>FilterOrderConstant</p>\n</blockquote>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">package</span> <span class=\"token namespace\">org<span class=\"token punctuation\">.</span>opengoofy<span class=\"token punctuation\">.</span>index12306<span class=\"token punctuation\">.</span>framework<span class=\"token punctuation\">.</span>starter<span class=\"token punctuation\">.</span>bases<span class=\"token punctuation\">.</span>constant</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token comment\">/**</pre></td></tr><tr><td data-num=\"4\"></td><td><pre> * 全局过滤器顺序执行常量类</pre></td></tr><tr><td data-num=\"5\"></td><td><pre> *</pre></td></tr><tr><td data-num=\"6\"></td><td><pre> * @公众号：马丁玩编程，回复：加群，添加马哥微信（备注：12306）获取项目资料</pre></td></tr><tr><td data-num=\"7\"></td><td><pre> */</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">FilterOrderConstant</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token comment\">/**</pre></td></tr><tr><td data-num=\"11\"></td><td><pre>     * 用户信息传递过滤器执行顺序排序</pre></td></tr><tr><td data-num=\"12\"></td><td><pre>     */</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> <span class=\"token constant\">USER_TRANSMIT_FILTER_ORDER</span> <span class=\"token operator\">=</span> <span class=\"token number\">100</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>再思考下，过滤器、拦截器或 AOP 组件的执行顺序又为什么定义在基础组件库？</p>\n<p>提个问题：假设你的应用依赖了日志打印和幂等组件，方法执行时，需要打印日志和避免请求幂等。流程伪代码如下：</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token annotation punctuation\">@Log</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token annotation punctuation\">@Idempotent</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">private</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">validateToken</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">UserInfoDTO</span> userInfo<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token keyword\">return</span> userInfo <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>正常来说，要先打印日志，再触发幂等行为。但是，如果说日志和幂等的组件库开发者不是同一人，幂等在日志请求之前。如果不触发幂等还好，一旦触发幂等行为抛出异常，那么日志组件将不再执行。这对于生产日志以及排查问题来说非常不友好。</p>\n<p><strong>所以说，<font color='red'>每个基础组件的执行顺序需要在全局定义</font>，每个组件开发者要有全局思维，定义类似于这种过滤器或拦截器再或者 AOP 时，需要从组件功能再结合全局组件功能考虑到执行顺序问题。</strong></p>\n<p>正因为如此，将这些组件的执行顺序单独放到基础组件库中，一个是基础组库被全部组件库依赖，另一个就是定义组件时，也能看到其他组件库的功能以及执行顺序。避免出现信息孤岛问题。</p>\n<p>总得来说，有以下这些优势：</p>\n<ul>\n<li>解耦和可复用性：通过将组件库的执行顺序抽象到一个基础的组件库中，<font color='red'>可以将各个组件库之间的依赖和执行顺序解耦</font>。这样，每个组件库可以独立开发、测试和维护，提高了代码的可复用性和可维护性。</li>\n<li>灵活性：由于执行顺序被抽象到基础组件库中，<font color='red'>可以根据具体的业务需求对组件库进行配置，灵活地调整组件的执行顺序</font>。这种灵活性使得开发人员可以根据具体的场景和需求来定义过滤器的执行顺序，提供更好的定制化和灵活性。</li>\n<li>执行顺序的统一管理：将执行顺序抽象到一个基础组件库中，<font color='red'>可以实现对所有组件库中过滤器执行顺序的统一管理</font>。开发人员只需关注各个组件库的业务逻辑实现，而不必关心过滤器的具体执行顺序。这样可以简化开发流程，提高开发效率。</li>\n<li>扩展性：基础组件库<font color='red'>可以提供一些通用的功能和特性</font>，例如全局变量的管理、过滤器的注册和执行等。这样可以为其他组件库提供扩展性，使其能够更好地适应不同的业务场景和需求。</li>\n</ul>\n<h5 id=\"spring-容器上下文\"><a class=\"anchor\" href=\"#spring-容器上下文\">#</a> Spring 容器上下文</h5>\n<blockquote>\n<p>ApplicationContextHolder</p>\n</blockquote>\n<p>在 Spring Bean 中获取 Spring Bean，只需要通过构造器或者 @Autowired 或 @Resource 就可以了。</p>\n<p>但是很多时候，我们也<font color='red'>需要在非 Spring Bean 中使用到 Spring Bean</font>。</p>\n<p>举个简单的例子，大家定义线程池任务实现类时，可能需要获取到 Spring Bean。</p>\n<p>基于以上诉求，我们依赖 Spring 提供的  <code>ApplicationContextAware</code>  接口，来将 Spring IOC 容器的对象放到一个自定义容器中，并持有 Spring IOC 容器。</p>\n<p>这样就可以<font color='red'>通过实现 ApplicationContextAware 接口，自定义上下文容器，从而访问 Spring IOC 容器，获取 Spring Bean</font>。</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">/**</pre></td></tr><tr><td data-num=\"2\"></td><td><pre> * ApplicationContextHolder：用于获取 Spring 的上下文对象 ApplicationContext</pre></td></tr><tr><td data-num=\"3\"></td><td><pre> *</pre></td></tr><tr><td data-num=\"4\"></td><td><pre> * @公众号：马丁玩编程，回复：加群，添加马哥微信（备注：12306）获取项目资料</pre></td></tr><tr><td data-num=\"5\"></td><td><pre> */</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token comment\">// ApplicationContextAware 是 Spring 提供的一个接口，用于获取 Spring 的上下文对象 ApplicationContext</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">ApplicationContextHolder</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">ApplicationContextAware</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token class-name\">ApplicationContext</span> <span class=\"token constant\">CONTEXT</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 存储 Spring 的上下文对象</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token annotation punctuation\">@Override</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">setApplicationContext</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">ApplicationContext</span> applicationContext<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">BeansException</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>        <span class=\"token class-name\">ApplicationContextHolder</span><span class=\"token punctuation\">.</span><span class=\"token constant\">CONTEXT</span> <span class=\"token operator\">=</span> applicationContext<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>    <span class=\"token comment\">/**</pre></td></tr><tr><td data-num=\"17\"></td><td><pre>     * 按类型获取 ioc 容器 bean</pre></td></tr><tr><td data-num=\"18\"></td><td><pre>     */</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">></span></span> <span class=\"token class-name\">T</span> <span class=\"token function\">getBean</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Class</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">></span></span> clazz<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>        <span class=\"token keyword\">return</span> <span class=\"token constant\">CONTEXT</span><span class=\"token punctuation\">.</span><span class=\"token function\">getBean</span><span class=\"token punctuation\">(</span>clazz<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>    <span class=\"token comment\">/**</pre></td></tr><tr><td data-num=\"24\"></td><td><pre>     * 按名称获取 ioc 容器 bean</pre></td></tr><tr><td data-num=\"25\"></td><td><pre>     */</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token class-name\">Object</span> <span class=\"token function\">getBean</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> name<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>        <span class=\"token keyword\">return</span> <span class=\"token constant\">CONTEXT</span><span class=\"token punctuation\">.</span><span class=\"token function\">getBean</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>    <span class=\"token comment\">/**</pre></td></tr><tr><td data-num=\"31\"></td><td><pre>     * 按名称和类型获取 ioc 容器 bean</pre></td></tr><tr><td data-num=\"32\"></td><td><pre>     */</span></pre></td></tr><tr><td data-num=\"33\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">></span></span> <span class=\"token class-name\">T</span> <span class=\"token function\">getBean</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> name<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Class</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">></span></span> clazz<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"34\"></td><td><pre>        <span class=\"token keyword\">return</span> <span class=\"token constant\">CONTEXT</span><span class=\"token punctuation\">.</span><span class=\"token function\">getBean</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">,</span> clazz<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"35\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"36\"></td><td><pre></pre></td></tr><tr><td data-num=\"37\"></td><td><pre>    <span class=\"token comment\">/**</pre></td></tr><tr><td data-num=\"38\"></td><td><pre>     * 按类型获取一组 ioc 容器 beans</pre></td></tr><tr><td data-num=\"39\"></td><td><pre>     */</span></pre></td></tr><tr><td data-num=\"40\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">></span></span> <span class=\"token class-name\">Map</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">T</span><span class=\"token punctuation\">></span></span> <span class=\"token function\">getBeansOfType</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Class</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">></span></span> clazz<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"41\"></td><td><pre>        <span class=\"token keyword\">return</span> <span class=\"token constant\">CONTEXT</span><span class=\"token punctuation\">.</span><span class=\"token function\">getBeansOfType</span><span class=\"token punctuation\">(</span>clazz<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"42\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"43\"></td><td><pre></pre></td></tr><tr><td data-num=\"44\"></td><td><pre>    <span class=\"token comment\">/**</pre></td></tr><tr><td data-num=\"45\"></td><td><pre>     * 查找 bean 是否有注释</pre></td></tr><tr><td data-num=\"46\"></td><td><pre>     */</span></pre></td></tr><tr><td data-num=\"47\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">A</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Annotation</span><span class=\"token punctuation\">></span></span> <span class=\"token class-name\">A</span> <span class=\"token function\">findAnnotationOnBean</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> beanName<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Class</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">A</span><span class=\"token punctuation\">></span></span> annotationType<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"48\"></td><td><pre>        <span class=\"token keyword\">return</span> <span class=\"token constant\">CONTEXT</span><span class=\"token punctuation\">.</span><span class=\"token function\">findAnnotationOnBean</span><span class=\"token punctuation\">(</span>beanName<span class=\"token punctuation\">,</span> annotationType<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"49\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"50\"></td><td><pre></pre></td></tr><tr><td data-num=\"51\"></td><td><pre>    <span class=\"token comment\">/**</pre></td></tr><tr><td data-num=\"52\"></td><td><pre>     * 获取应用程序上下文 applicationContext</pre></td></tr><tr><td data-num=\"53\"></td><td><pre>     */</span></pre></td></tr><tr><td data-num=\"54\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token class-name\">ApplicationContext</span> <span class=\"token function\">getInstance</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"55\"></td><td><pre>        <span class=\"token keyword\">return</span> <span class=\"token constant\">CONTEXT</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"56\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"57\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h5 id=\"fastjson-安全模式\"><a class=\"anchor\" href=\"#fastjson-安全模式\">#</a> FastJSON 安全模式</h5>\n<blockquote>\n<p>FastJsonSafeMode</p>\n</blockquote>\n<p>Fastjson 的 <font color='red'>&quot;autoType&quot; 特性是指在反序列化过程中，允许将 JSON 字符串自动转换为指定的 Java 类型</font>。它提供了一种方便的方式，使得开发人员可以直接将 JSON 数据转换为相应的 Java 对象，而无需手动指定目标类。</p>\n<p>然而，这个特性也存在一定的安全风险。<font color='red'>攻击者可以构造恶意的 JSON 数据，其中包含对不受信任的类的引用。当 &quot;autoType&quot; 特性被启用时，Fastjson 会尝试根据 JSON 字符串中的类信息实例化相应的对象，而不考虑该类是否可信或预期，从而可能导致潜在的安全问题，例如远程代码执行攻击。</font></p>\n<p>为了说明这个问题，考虑以下示例：</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token class-name\">String</span> jsonString <span class=\"token operator\">=</span> <span class=\"token string\">\"&#123;\\\"@type\\\":\\\"com.example.EvilClass\\\",\\\"data\\\":\\\"Malicious Data\\\"&#125;\"</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token class-name\">Object</span> obj <span class=\"token operator\">=</span> <span class=\"token constant\">JSON</span><span class=\"token punctuation\">.</span><span class=\"token function\">parseObject</span><span class=\"token punctuation\">(</span>jsonString<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>在上述示例中，JSON 字符串中的 &quot;@type&quot; 属性指定了一个名为 &quot;com.example.EvilClass&quot; 的类。如果 Fastjson 的 &quot;autoType&quot; 特性被启用，它将尝试将该 JSON 字符串转换为 &quot;com.example.EvilClass&quot; 类的实例，而不考虑该类是否可信或预期。</p>\n<p><strong><font color='red'>为了防止这种安全问题，Fastjson 默认情况下禁用了 &quot;autoType&quot; 特性，以提供一定的安全性</font></strong>。但是，在某些特定场景下，开发人员可能会手动启用该特性，例如在处理受信任的 JSON 数据时需要转换为多态对象。</p>\n<p>我们 FastJSON 安全模式，会关闭该 autoType 特性。</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">package</span> <span class=\"token namespace\">org<span class=\"token punctuation\">.</span>opengoofy<span class=\"token punctuation\">.</span>index12306<span class=\"token punctuation\">.</span>framework<span class=\"token punctuation\">.</span>starter<span class=\"token punctuation\">.</span>bases<span class=\"token punctuation\">.</span>safa</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">org<span class=\"token punctuation\">.</span>springframework<span class=\"token punctuation\">.</span>beans<span class=\"token punctuation\">.</span>factory<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">InitializingBean</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token comment\">/**</pre></td></tr><tr><td data-num=\"6\"></td><td><pre> * FastJson 安全模式，开启后关闭类型隐式传递</pre></td></tr><tr><td data-num=\"7\"></td><td><pre> *</pre></td></tr><tr><td data-num=\"8\"></td><td><pre> * @公众号：马丁玩编程，回复：加群，添加马哥微信（备注：12306）获取项目资料</pre></td></tr><tr><td data-num=\"9\"></td><td><pre> */</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token comment\">// InitializingBean 接口是 Spring 提供的一个初始化 bean 的接口</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">FastJsonSafeMode</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">InitializingBean</span> <span class=\"token punctuation\">&#123;</span> </pre></td></tr><tr><td data-num=\"12\"></td><td><pre></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    <span class=\"token annotation punctuation\">@Override</span> <span class=\"token comment\">// 该方法在 bean 初始化后执行</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">afterPropertiesSet</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">Exception</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span><span class=\"token function\">setProperty</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"fastjson2.parser.safeMode\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"true\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 启用 fastjson 的安全模式，更加严格地检查 JSON 数据的结构，防止一些潜在的安全风险，例如防止恶意构造的 JSON 数据导致的攻击。</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>如果配置文件中配置了  <code>framework.fastjson.safa-mode=true</code>  那么则开启安全模式，反之无任何变化。</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">package</span> <span class=\"token namespace\">org<span class=\"token punctuation\">.</span>opengoofy<span class=\"token punctuation\">.</span>index12306<span class=\"token punctuation\">.</span>framework<span class=\"token punctuation\">.</span>starter<span class=\"token punctuation\">.</span>bases<span class=\"token punctuation\">.</span>config</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">org<span class=\"token punctuation\">.</span>opengoofy<span class=\"token punctuation\">.</span>index12306<span class=\"token punctuation\">.</span>framework<span class=\"token punctuation\">.</span>starter<span class=\"token punctuation\">.</span>bases<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">ApplicationContextHolder</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">org<span class=\"token punctuation\">.</span>opengoofy<span class=\"token punctuation\">.</span>index12306<span class=\"token punctuation\">.</span>framework<span class=\"token punctuation\">.</span>starter<span class=\"token punctuation\">.</span>bases<span class=\"token punctuation\">.</span>init<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">ApplicationContentPostProcessor</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">org<span class=\"token punctuation\">.</span>opengoofy<span class=\"token punctuation\">.</span>index12306<span class=\"token punctuation\">.</span>framework<span class=\"token punctuation\">.</span>starter<span class=\"token punctuation\">.</span>bases<span class=\"token punctuation\">.</span>safa<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">FastJsonSafeMode</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">org<span class=\"token punctuation\">.</span>springframework<span class=\"token punctuation\">.</span>boot<span class=\"token punctuation\">.</span>autoconfigure<span class=\"token punctuation\">.</span>condition<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">ConditionalOnMissingBean</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">org<span class=\"token punctuation\">.</span>springframework<span class=\"token punctuation\">.</span>boot<span class=\"token punctuation\">.</span>autoconfigure<span class=\"token punctuation\">.</span>condition<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">ConditionalOnProperty</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">org<span class=\"token punctuation\">.</span>springframework<span class=\"token punctuation\">.</span>context<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">ApplicationContext</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">org<span class=\"token punctuation\">.</span>springframework<span class=\"token punctuation\">.</span>context<span class=\"token punctuation\">.</span>annotation<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">Bean</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token comment\">/**</pre></td></tr><tr><td data-num=\"12\"></td><td><pre> * 应用基础自动装配</pre></td></tr><tr><td data-num=\"13\"></td><td><pre> *</pre></td></tr><tr><td data-num=\"14\"></td><td><pre> * @公众号：马丁玩编程，回复：加群，添加马哥微信（备注：12306）获取项目资料</pre></td></tr><tr><td data-num=\"15\"></td><td><pre> */</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">ApplicationBaseAutoConfiguration</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>    <span class=\"token annotation punctuation\">@Bean</span> <span class=\"token comment\">// 注册一个 bean</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>    <span class=\"token annotation punctuation\">@ConditionalOnMissingBean</span> <span class=\"token comment\">// 当容器中没有该 bean 的情况下创建该 bean</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>    <span class=\"token comment\">// ApplicationContextHolder 是自定义的一个 bean，用于获取 Spring 的上下文对象 ApplicationContext，用于获取 bean</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token class-name\">ApplicationContextHolder</span> <span class=\"token function\">congoApplicationContextHolder</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>        <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ApplicationContextHolder</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>    <span class=\"token annotation punctuation\">@Bean</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>    <span class=\"token annotation punctuation\">@ConditionalOnMissingBean</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>    <span class=\"token comment\">// ApplicationContentPostProcessor 是自定义的一个 bean，用于防止 Spring 事件被多次执行</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token class-name\">ApplicationContentPostProcessor</span> <span class=\"token function\">congoApplicationContentPostProcessor</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">ApplicationContext</span> applicationContext<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>        <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ApplicationContentPostProcessor</span><span class=\"token punctuation\">(</span>applicationContext<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre></pre></td></tr><tr><td data-num=\"32\"></td><td><pre>    <span class=\"token annotation punctuation\">@Bean</span></pre></td></tr><tr><td data-num=\"33\"></td><td><pre>    <span class=\"token annotation punctuation\">@ConditionalOnMissingBean</span></pre></td></tr><tr><td data-num=\"34\"></td><td><pre>    <span class=\"token annotation punctuation\">@ConditionalOnProperty</span><span class=\"token punctuation\">(</span>value <span class=\"token operator\">=</span> <span class=\"token string\">\"framework.fastjson.safa-mode\"</span><span class=\"token punctuation\">,</span> havingValue <span class=\"token operator\">=</span> <span class=\"token string\">\"true\"</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"35\"></td><td><pre>    <span class=\"token comment\">// 当 framework.fastjson.safa-mode 为 true 时创建该 bean</span></pre></td></tr><tr><td data-num=\"36\"></td><td><pre>    <span class=\"token comment\">// FastJsonSafeMode 是自定义的一个 bean，用于开启 fastjson 的安全模式</span></pre></td></tr><tr><td data-num=\"37\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token class-name\">FastJsonSafeMode</span> <span class=\"token function\">congoFastJsonSafeMode</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"38\"></td><td><pre>        <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">FastJsonSafeMode</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"39\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"40\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h5 id=\"安全初始化事件\"><a class=\"anchor\" href=\"#安全初始化事件\">#</a> 安全初始化事件</h5>\n<blockquote>\n<p>ApplicationInitializingEvent</p>\n</blockquote>\n<p>我们在实际应用开发中，会依赖很多应用初始化时执行任务，比如说  <code>InitializingBean</code> 、 <code>CommandLineRunner</code>  等。</p>\n<p>除此之外，还有<font color='gree'>一些依赖 Spring 初始化的事件</font>。</p>\n<ol>\n<li><code>ContextRefreshedEvent</code> ： <font color='red'>当应用程序上下文（ApplicationContext）初始化或刷新完成后触发</font>。这通常发生在应用程序启动过程中，并且表示应用程序已准备好接收请求和执行业务逻辑。可以使用该事件来 **<font color='red'>执行一些初始化操作，例如加载缓存数据、启动后台任务等</font>**。</li>\n<li><code>ContextStartedEvent</code> ： <font color='red'>当 ApplicationContext 启动时触发</font>。这个事件在调用 ConfigurableApplicationContext 的 start () 方法后被发布。可以使用该事件来 **<font color='red'>执行启动应用程序所需的特定逻辑，例如启动定时任务、启动消息监听器等</font>**。</li>\n<li><code>ContextStoppedEvent</code> ： <font color='red'>当 ApplicationContext 停止时触发</font>。这个事件在调用 ConfigurableApplicationContext 的 stop () 方法后被发布。可以使用该事件来 **<font color='red'>执行停止应用程序所需的清理逻辑，例如关闭连接、释放资源等</font>**。</li>\n<li><code>ContextClosedEvent</code> ： <font color='red'>当 ApplicationContext 关闭时触发</font>。这个事件在调用 ConfigurableApplicationContext 的 close () 方法后被发布。可以使用该事件来 **<font color='red'>执行一些最终的清理操作，例如释放数据库连接、销毁单例对象等</font>**。</li>\n<li><code>ServletRequestHandledEvent</code> ： <font color='red'>当 Spring MVC 处理完一个 HTTP 请求时触发</font>。该事件提供了有关请求处理的详细信息，包括请求的处理时间、处理器、处理器适配器等。可以使用该事件来 **<font color='red'>进行请求处理的监控、日志记录或统计信息收集等操作</font>**。</li>\n<li><code>ApplicationStartedEvent</code> （Spring Boot）： <font color='red'>当 Spring Boot 应用程序启动时触发</font>。这个事件在 SpringApplication.run () 方法完成后被发布。可以使用该事件来 **<font color='red'>执行特定于应用程序的初始化逻辑</font>**。</li>\n<li><code>ApplicationReadyEvent</code> （Spring Boot）： <font color='red'>当 Spring Boot 应用程序准备就绪时触发</font>。这个事件表示应用程序已经启动完毕，并且已经可以提供服务。可以使用该事件来 **<font color='red'>执行应用程序的后续初始化操作，例如加载数据、发送通知等</font>**。</li>\n</ol>\n<p>有些场景是依赖 Spring 容器初始化完成后调用的， <code>ContextRefreshedEvent</code>  这个时间就比较合适。但是大家发现没有，它除了初始化调用，容器刷新也会调用。</p>\n<p><font color='gree'>为了避免容器刷新造成二次调用初始化逻辑，我们对一些比较常用的事件简单封装了一层逻辑</font>。</p>\n<p>1）首先定义 应用初始化事件 对象类  <code>ApplicationInitializingEvent</code></p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">package</span> <span class=\"token namespace\">org<span class=\"token punctuation\">.</span>opengoofy<span class=\"token punctuation\">.</span>index12306<span class=\"token punctuation\">.</span>framework<span class=\"token punctuation\">.</span>starter<span class=\"token punctuation\">.</span>bases<span class=\"token punctuation\">.</span>init</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">org<span class=\"token punctuation\">.</span>springframework<span class=\"token punctuation\">.</span>context<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">ApplicationEvent</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token comment\">/**</pre></td></tr><tr><td data-num=\"6\"></td><td><pre> * 应用初始化事件</pre></td></tr><tr><td data-num=\"7\"></td><td><pre> *</pre></td></tr><tr><td data-num=\"8\"></td><td><pre> * &lt;p> 规约事件，通过此事件可以查看业务系统所有初始化行为</pre></td></tr><tr><td data-num=\"9\"></td><td><pre> *</pre></td></tr><tr><td data-num=\"10\"></td><td><pre> * @公众号：马丁玩编程，回复：加群，添加马哥微信（备注：12306）获取项目资料</pre></td></tr><tr><td data-num=\"11\"></td><td><pre> */</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token comment\">// ApplicationEvent 是 Spring 的事件模型，用于监听应用的初始化和销毁</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">ApplicationInitializingEvent</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">ApplicationEvent</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    <span class=\"token comment\">/**</pre></td></tr><tr><td data-num=\"16\"></td><td><pre>     * Create a new &#123;@code ApplicationEvent&#125;.</pre></td></tr><tr><td data-num=\"17\"></td><td><pre>     *</pre></td></tr><tr><td data-num=\"18\"></td><td><pre>     * @param source the object on which the event initially occurred or with</pre></td></tr><tr><td data-num=\"19\"></td><td><pre>     *               which the event is associated (never &#123;@code null&#125;)</pre></td></tr><tr><td data-num=\"20\"></td><td><pre>     */</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token class-name\">ApplicationInitializingEvent</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Object</span> source<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>        <span class=\"token comment\">/*</pre></td></tr><tr><td data-num=\"23\"></td><td><pre>         * source 是事件源，即事件发生的地方</pre></td></tr><tr><td data-num=\"24\"></td><td><pre>         * 这里调用父类的构造方法，将 source 传递给父类</pre></td></tr><tr><td data-num=\"25\"></td><td><pre>         */</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>        <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>source<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>2）其次，定义 应用初始化后置处理器  <code>ApplicationContentPostProcessor</code> ，防止 Spring 事件被多次执行。</p>\n<p>整体逻辑也比较简单，<font color='red'>通过锁来保证同一时间只有一个事件进行初始化</font>。初始化后设置一个标识，下次如果再触发，就不再执行，类似于幂等处理的逻辑。</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">/**</pre></td></tr><tr><td data-num=\"2\"></td><td><pre> * 应用初始化后置处理器，防止 Spring 事件被多次执行</pre></td></tr><tr><td data-num=\"3\"></td><td><pre> *</pre></td></tr><tr><td data-num=\"4\"></td><td><pre> * @公众号：马丁玩编程，回复：加群，添加马哥微信（备注：12306）获取项目资料</pre></td></tr><tr><td data-num=\"5\"></td><td><pre> */</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token annotation punctuation\">@RequiredArgsConstructor</span> <span class=\"token comment\">// 生成一个包含 final 常量，构造方法，get 和 set 方法的构造函数</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token comment\">/*</pre></td></tr><tr><td data-num=\"8\"></td><td><pre> * ApplicationListener 是 Spring 的事件监听器接口，用于监听 Spring 的事件</pre></td></tr><tr><td data-num=\"9\"></td><td><pre> * ApplicationReadyEvent 是 Spring 的事件模型，用于监听应用的初始化和销毁</pre></td></tr><tr><td data-num=\"10\"></td><td><pre> * 该类实现了 ApplicationListener 接口，用于监听 Spring 的 ApplicationReadyEvent 事件</pre></td></tr><tr><td data-num=\"11\"></td><td><pre> */</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">ApplicationContentPostProcessor</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">ApplicationListener</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">ApplicationReadyEvent</span><span class=\"token punctuation\">></span></span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    <span class=\"token comment\">// 声明一个 ApplicationContext 对象，用于获取 Spring 上下文</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    <span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">ApplicationContext</span> applicationContext<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>    <span class=\"token comment\">/**</pre></td></tr><tr><td data-num=\"17\"></td><td><pre>     * 执行标识，确保 Spring 事件 &#123;@link ApplicationReadyEvent&#125; 有且执行一次。</pre></td></tr><tr><td data-num=\"18\"></td><td><pre>     * AtomicBoolean 是一个原子操作类，用于在多线程环境下对 boolean 类型的变量进行原子操作</pre></td></tr><tr><td data-num=\"19\"></td><td><pre>     */</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>    <span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">AtomicBoolean</span> executeOnlyOnce <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">AtomicBoolean</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>    <span class=\"token annotation punctuation\">@Override</span> <span class=\"token comment\">// 该方法用于监听 Spring 的 ApplicationReadyEvent 事件</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">onApplicationEvent</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">ApplicationReadyEvent</span> event<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>        <span class=\"token comment\">// 如果 executeOnlyOnce 为 true，说 ApplicationReadyEvent 事件已经发布过了，直接返回</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>executeOnlyOnce<span class=\"token punctuation\">.</span><span class=\"token function\">compareAndSet</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>            <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>        <span class=\"token comment\">// 如果 executeOnlyOnce 为 false，则发布一个 ApplicationInitializingEvent 事件，用于查看业务系统所有初始化行为</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>        applicationContext<span class=\"token punctuation\">.</span><span class=\"token function\">publishEvent</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">ApplicationInitializingEvent</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>该类确保当应用准备就绪时，仅执行一次 <code>onApplicationEvent</code>  方法内的逻辑。如果该方法已经执行过，它将直接返回，不执行任何额外的操作。</p>\n<h5 id=\"单例对象容器\"><a class=\"anchor\" href=\"#单例对象容器\">#</a> 单例对象容器</h5>\n<blockquote>\n<p>Singleton</p>\n</blockquote>\n<p>提供一种单例的访问模式，单例的优点如下：</p>\n<ol>\n<li><font color='red'>全局访问</font>：单例对象可以在应用程序的任何地方被访问，而不需要传递对象的引用。这样可以方便地共享对象的状态和功能，简化了对象之间的通信和协作。</li>\n<li><font color='red'>节省资源</font>：由于只有一个对象实例存在，可以减少重复创建对象的开销。在需要频繁创建和销毁对象的情况下，单例对象可以显著节省系统资源，提高性能。</li>\n</ol>\n<p>应用场景也比较多，比如说，发送邮件时需要加载邮件的模板文件，重复加载就比较浪费性能。<strong><font color='red'>完全可以加载一次后，将该对象放到单例对象容器中缓存，下次使用时直接获取就好</font></strong>。</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">package</span> <span class=\"token namespace\">org<span class=\"token punctuation\">.</span>opengoofy<span class=\"token punctuation\">.</span>index12306<span class=\"token punctuation\">.</span>framework<span class=\"token punctuation\">.</span>starter<span class=\"token punctuation\">.</span>bases</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">lombok<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">AccessLevel</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">lombok<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">NoArgsConstructor</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">java<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span>concurrent<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">ConcurrentHashMap</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">java<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span>function<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">Supplier</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token comment\">/**</pre></td></tr><tr><td data-num=\"10\"></td><td><pre> * 单例对象容器</pre></td></tr><tr><td data-num=\"11\"></td><td><pre> *</pre></td></tr><tr><td data-num=\"12\"></td><td><pre> * @公众号：马丁玩编程，回复：加群，添加马哥微信（备注：12306）获取项目资料</pre></td></tr><tr><td data-num=\"13\"></td><td><pre> */</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre><span class=\"token annotation punctuation\">@NoArgsConstructor</span><span class=\"token punctuation\">(</span>access <span class=\"token operator\">=</span> <span class=\"token class-name\">AccessLevel</span><span class=\"token punctuation\">.</span><span class=\"token constant\">PRIVATE</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// 生成一个私有的无参构造函数，以确保该类不会被外部直接实例化</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Singleton</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token comment\">// 声明为 final 类，以确保该类不会被继承</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>    <span class=\"token comment\">/**</pre></td></tr><tr><td data-num=\"18\"></td><td><pre>     * 声明一个单例对象容器，使用 ConcurrentHashMap（线程安全的 HashMap）存储单例对象</pre></td></tr><tr><td data-num=\"19\"></td><td><pre>     * 其中 key 为对象的类名（String），value 为对象实例（Object）</pre></td></tr><tr><td data-num=\"20\"></td><td><pre>     */</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">ConcurrentHashMap</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">Object</span><span class=\"token punctuation\">></span></span> <span class=\"token constant\">SINGLE_OBJECT_POOL</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ConcurrentHashMap</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>    <span class=\"token comment\">/**</pre></td></tr><tr><td data-num=\"24\"></td><td><pre>     * 根据 key 获取单例对象</pre></td></tr><tr><td data-num=\"25\"></td><td><pre>     */</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">></span></span> <span class=\"token class-name\">T</span> <span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> key<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>        <span class=\"token class-name\">Object</span> result <span class=\"token operator\">=</span> <span class=\"token constant\">SINGLE_OBJECT_POOL</span><span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>        <span class=\"token keyword\">return</span> result <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">?</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">)</span> result<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 如果 result 为空，则返回 null；否则，返回 result 强制转换为 T 类型</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre></pre></td></tr><tr><td data-num=\"31\"></td><td><pre>    <span class=\"token comment\">/**</pre></td></tr><tr><td data-num=\"32\"></td><td><pre>     * 根据 key 获取单例对象</pre></td></tr><tr><td data-num=\"33\"></td><td><pre>     *</pre></td></tr><tr><td data-num=\"34\"></td><td><pre>     * &lt;p> 为空时，通过 supplier 构建单例对象并放入容器</pre></td></tr><tr><td data-num=\"35\"></td><td><pre>     */</span></pre></td></tr><tr><td data-num=\"36\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">></span></span> <span class=\"token class-name\">T</span> <span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> key<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Supplier</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">></span></span> supplier<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"37\"></td><td><pre>        <span class=\"token class-name\">Object</span> result <span class=\"token operator\">=</span> <span class=\"token constant\">SINGLE_OBJECT_POOL</span><span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"38\"></td><td><pre>        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>result <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token punctuation\">(</span>result <span class=\"token operator\">=</span> supplier<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"39\"></td><td><pre>            <span class=\"token constant\">SINGLE_OBJECT_POOL</span><span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">,</span> result<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"40\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"41\"></td><td><pre>        <span class=\"token keyword\">return</span> result <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">?</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">)</span> result <span class=\"token operator\">:</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"42\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"43\"></td><td><pre></pre></td></tr><tr><td data-num=\"44\"></td><td><pre>    <span class=\"token comment\">/**</pre></td></tr><tr><td data-num=\"45\"></td><td><pre>     * 对象放入容器</pre></td></tr><tr><td data-num=\"46\"></td><td><pre>     */</span></pre></td></tr><tr><td data-num=\"47\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">put</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Object</span> value<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"48\"></td><td><pre>        <span class=\"token function\">put</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">.</span><span class=\"token function\">getClass</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"49\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"50\"></td><td><pre></pre></td></tr><tr><td data-num=\"51\"></td><td><pre>    <span class=\"token comment\">/**</pre></td></tr><tr><td data-num=\"52\"></td><td><pre>     * 对象放入容器</pre></td></tr><tr><td data-num=\"53\"></td><td><pre>     */</span></pre></td></tr><tr><td data-num=\"54\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">put</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> key<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Object</span> value<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"55\"></td><td><pre>        <span class=\"token constant\">SINGLE_OBJECT_POOL</span><span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">,</span> value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"56\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"57\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>这个类的设计使得在应用程序中可以方便地<font color='red'>通过 key（类名）获取和存储单例对象</font>，同时确保在多线程环境中的<font color='red'>线程安全性</font>。需要注意的是，<font color='red'>这里的单例是指在容器中具有相同 key 的对象是唯一的，而不是传统的单例模式中只有一个实例</font>。</p>\n<h3 id=\"规约组件模块\"><a class=\"anchor\" href=\"#规约组件模块\">#</a> 规约组件模块</h3>\n<blockquote>\n<p>convention</p>\n</blockquote>\n<h4 id=\"组件地址-2\"><a class=\"anchor\" href=\"#组件地址-2\">#</a> 组件地址</h4>\n<figure class=\"highlight xml\"><figcaption data-lang=\"XML\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>dependency</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>groupId</span><span class=\"token punctuation\">></span></span>org.opengoofy.index12306<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>groupId</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>artifactId</span><span class=\"token punctuation\">></span></span>index12306-convention-spring-boot-starter<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>artifactId</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>version</span><span class=\"token punctuation\">></span></span>$&#123;project.version&#125;<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>version</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>dependency</span><span class=\"token punctuation\">></span></span></pre></td></tr></table></figure><h4 id=\"组件概述\"><a class=\"anchor\" href=\"#组件概述\">#</a> 组件概述</h4>\n<ol>\n<li>定义异常码抽象和公共异常码。</li>\n<li>定义抽象异常和客户端、服务端以及远程调用异常。</li>\n<li>封装分页对象请求参数和返回参数实体。</li>\n<li>封装公共响应对象。</li>\n</ol>\n<h4 id=\"组件功能-2\"><a class=\"anchor\" href=\"#组件功能-2\">#</a> 组件功能</h4>\n<h5 id=\"异常码\"><a class=\"anchor\" href=\"#异常码\">#</a> 异常码</h5>\n<p><font color='red'>异常码的不统一，带来的最直接后果就是<strong>返回结果异常码混乱</strong>，没有规律，也不方便排查问题</font>。</p>\n<p>为此，我参考了阿里开发规约中，关于异常码的定义部分，最终抽象了异常码接口以及公共异常码。</p>\n<p>1）异常码接口抽象</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">package</span> <span class=\"token namespace\">org<span class=\"token punctuation\">.</span>opengoofy<span class=\"token punctuation\">.</span>index12306<span class=\"token punctuation\">.</span>framework<span class=\"token punctuation\">.</span>starter<span class=\"token punctuation\">.</span>convention<span class=\"token punctuation\">.</span>errorcode</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token comment\">/**</pre></td></tr><tr><td data-num=\"4\"></td><td><pre> * 平台错误码接口</pre></td></tr><tr><td data-num=\"5\"></td><td><pre> *</pre></td></tr><tr><td data-num=\"6\"></td><td><pre> * @公众号：马丁玩编程，回复：加群，添加马哥微信（备注：12306）获取项目资料</pre></td></tr><tr><td data-num=\"7\"></td><td><pre> */</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">interface</span> <span class=\"token class-name\">IErrorCode</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token comment\">/**</pre></td></tr><tr><td data-num=\"11\"></td><td><pre>     * 错误码</pre></td></tr><tr><td data-num=\"12\"></td><td><pre>     */</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    <span class=\"token class-name\">String</span> <span class=\"token function\">code</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    <span class=\"token comment\">/**</pre></td></tr><tr><td data-num=\"16\"></td><td><pre>     * 错误信息</pre></td></tr><tr><td data-num=\"17\"></td><td><pre>     */</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>    <span class=\"token class-name\">String</span> <span class=\"token function\">message</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>2）封装常用的公共异常码</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">package</span> <span class=\"token namespace\">org<span class=\"token punctuation\">.</span>opengoofy<span class=\"token punctuation\">.</span>index12306<span class=\"token punctuation\">.</span>framework<span class=\"token punctuation\">.</span>starter<span class=\"token punctuation\">.</span>convention<span class=\"token punctuation\">.</span>errorcode</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token comment\">/**</pre></td></tr><tr><td data-num=\"4\"></td><td><pre> * 基础错误码定义</pre></td></tr><tr><td data-num=\"5\"></td><td><pre> *</pre></td></tr><tr><td data-num=\"6\"></td><td><pre> * @公众号：马丁玩编程，回复：加群，添加马哥微信（备注：12306）获取项目资料</pre></td></tr><tr><td data-num=\"7\"></td><td><pre> */</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">enum</span> <span class=\"token class-name\">BaseErrorCode</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">IErrorCode</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token comment\">// 定义了一个枚举类，实现了 IErrorCode 接口</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token comment\">// ========== 一级宏观错误码 客户端错误 ==========</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token function\">CLIENT_ERROR</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"A000001\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"用户端错误\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    <span class=\"token comment\">// ========== 二级宏观错误码 用户注册错误 ==========</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    <span class=\"token function\">USER_REGISTER_ERROR</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"A000100\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"用户注册错误\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    <span class=\"token function\">USER_NAME_VERIFY_ERROR</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"A000110\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"用户名校验失败\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>    <span class=\"token function\">USER_NAME_EXIST_ERROR</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"A000111\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"用户名已存在\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>    <span class=\"token function\">USER_NAME_SENSITIVE_ERROR</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"A000112\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"用户名包含敏感词\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>    <span class=\"token function\">USER_NAME_SPECIAL_CHARACTER_ERROR</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"A000113\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"用户名包含特殊字符\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>    <span class=\"token function\">PASSWORD_VERIFY_ERROR</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"A000120\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"密码校验失败\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>    <span class=\"token function\">PASSWORD_SHORT_ERROR</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"A000121\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"密码长度不够\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>    <span class=\"token function\">PHONE_VERIFY_ERROR</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"A000151\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"手机格式校验失败\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>    <span class=\"token comment\">// ========== 二级宏观错误码 系统请求缺少幂等 Token ==========</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>    <span class=\"token function\">IDEMPOTENT_TOKEN_NULL_ERROR</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"A000200\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"幂等Token为空\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>    <span class=\"token function\">IDEMPOTENT_TOKEN_DELETE_ERROR</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"A000201\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"幂等Token已被使用或失效\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>    <span class=\"token comment\">// ========== 一级宏观错误码 系统执行出错 ==========</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>    <span class=\"token function\">SERVICE_ERROR</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"B000001\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"系统执行出错\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>    <span class=\"token comment\">// ========== 二级宏观错误码 系统执行超时 ==========</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>    <span class=\"token function\">SERVICE_TIMEOUT_ERROR</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"B000100\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"系统执行超时\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre></pre></td></tr><tr><td data-num=\"32\"></td><td><pre>    <span class=\"token comment\">// ========== 一级宏观错误码 调用第三方服务出错 ==========</span></pre></td></tr><tr><td data-num=\"33\"></td><td><pre>    <span class=\"token function\">REMOTE_ERROR</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"C000001\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"调用第三方服务出错\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"34\"></td><td><pre></pre></td></tr><tr><td data-num=\"35\"></td><td><pre>    <span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">String</span> code<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"36\"></td><td><pre></pre></td></tr><tr><td data-num=\"37\"></td><td><pre>    <span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">String</span> message<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"38\"></td><td><pre></pre></td></tr><tr><td data-num=\"39\"></td><td><pre>    <span class=\"token class-name\">BaseErrorCode</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> code<span class=\"token punctuation\">,</span> <span class=\"token class-name\">String</span> message<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"40\"></td><td><pre>        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>code <span class=\"token operator\">=</span> code<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"41\"></td><td><pre>        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>message <span class=\"token operator\">=</span> message<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"42\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"43\"></td><td><pre></pre></td></tr><tr><td data-num=\"44\"></td><td><pre>    <span class=\"token annotation punctuation\">@Override</span></pre></td></tr><tr><td data-num=\"45\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token class-name\">String</span> <span class=\"token function\">code</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"46\"></td><td><pre>        <span class=\"token keyword\">return</span> code<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"47\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"48\"></td><td><pre></pre></td></tr><tr><td data-num=\"49\"></td><td><pre>    <span class=\"token annotation punctuation\">@Override</span></pre></td></tr><tr><td data-num=\"50\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token class-name\">String</span> <span class=\"token function\">message</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"51\"></td><td><pre>        <span class=\"token keyword\">return</span> message<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"52\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"53\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><blockquote>\n<p>异常码如何设计与定义：<a href=\"#%E5%BC%82%E5%B8%B8%E7%A0%81%E5%AE%9A%E4%B9%89\">异常码定义</a></p>\n</blockquote>\n<h5 id=\"抽象异常体系\"><a class=\"anchor\" href=\"#抽象异常体系\">#</a> 抽象异常体系</h5>\n<h5 id=\"封装分页对象\"><a class=\"anchor\" href=\"#封装分页对象\">#</a> 封装分页对象</h5>\n<h5 id=\"封装公共响应对象\"><a class=\"anchor\" href=\"#封装公共响应对象\">#</a> 封装公共响应对象</h5>\n<h3 id=\"用户基础组件库\"><a class=\"anchor\" href=\"#用户基础组件库\">#</a> 用户基础组件库</h3>\n<h3 id=\"设计模式组件库\"><a class=\"anchor\" href=\"#设计模式组件库\">#</a> 设计模式组件库</h3>\n<h2 id=\"核心业务实现\"><a class=\"anchor\" href=\"#核心业务实现\">#</a> 核心业务实现</h2>\n<h3 id=\"注册用户接口\"><a class=\"anchor\" href=\"#注册用户接口\">#</a> 注册用户接口</h3>\n<h4 id=\"用户表结构\"><a class=\"anchor\" href=\"#用户表结构\">#</a> 用户表结构</h4>\n<p>以下表结构为用户原始表结构，而大家执行过建表语句后，看到数据库中大多为  <code>t_user_0-15</code>  的表名。这是因为，<font color='red'>考虑到用户量过大，对用户表进行了分库分表处理</font>。</p>\n<pre><code class=\"language-SQL\">CREATE TABLE `t_user` (\n  `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT COMMENT 'ID',\n  `username` varchar(256) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '用户名',\n  `password` varchar(512) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '密码',\n  `real_name` varchar(256) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '真实姓名',\n  `region` varchar(64) COLLATE utf8mb4_unicode_ci DEFAULT '0' COMMENT '国家/地区',\n  `id_type` int(3) DEFAULT NULL COMMENT '证件类型',\n  `id_card` varchar(256) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '证件号',\n  `phone` varchar(128) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '手机号',\n  `telephone` varchar(128) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '固定电话',\n  `mail` varchar(256) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '邮箱',\n  `user_type` int(3) DEFAULT NULL COMMENT '旅客类型',\n  `verify_status` int(3) DEFAULT NULL COMMENT '审核状态',\n  `post_code` varchar(64) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '邮编',\n  `address` varchar(1024) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '地址',\n  `deletion_time` bigint(20) DEFAULT '0' COMMENT '注销时间戳',\n  `create_time` datetime DEFAULT NULL COMMENT '创建时间',\n  `update_time` datetime DEFAULT NULL COMMENT '修改时间',\n  `del_flag` tinyint(1) DEFAULT NULL COMMENT '删除标识',\n  PRIMARY KEY (`id`),\n  UNIQUE KEY `idx_username` (`username`,`deletion_time`) USING BTREE\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='用户表';\n</code></pre>\n<h4 id=\"分库分表策略\"><a class=\"anchor\" href=\"#分库分表策略\">#</a> 分库分表策略</h4>\n<p>用户数据分库分表相关文档参考<a href=\"#%E5%AF%B9%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E8%BF%9B%E8%A1%8C%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8\">对用户数据进行分库分表</a>，一定程度上解决了业务难点中的<a href=\"#%E6%95%B0%E5%8D%81%E4%BA%BF%E7%BA%A7%E6%95%B0%E6%8D%AE%E9%87%8F\">数十亿级数据量</a>问题。</p>\n<h3 id=\"对用户数据进行分库分表\"><a class=\"anchor\" href=\"#对用户数据进行分库分表\">#</a> 对用户数据进行分库分表</h3>\n<h4 id=\"分库分表组件介绍\"><a class=\"anchor\" href=\"#分库分表组件介绍\">#</a> 分库分表组件介绍</h4>\n<p>选择  <code>ShardingSphere</code>  进行分库分表，原因如下：</p>\n<ul>\n<li>拥有活跃的社区，能够提供及时的技术支持和更新；</li>\n<li>代码质量极高，经过严格测试和验证，稳定可靠；</li>\n<li>提供丰富的功能，满足多样化的业务需求。</li>\n</ul>\n<p>可以阅读<a href=\"#%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%AD%A6%E4%B9%A0\">中间件学习</a>中的介绍。</p>\n<p>ShardingSphere 有两种组件，二者的优缺点对比如下：</p>\n<ul>\n<li><code>ShardingSphere-JDBC</code> ：\n<ul>\n<li>优点：\n<ul>\n<li>性能较高，通过 JDBC 直接向 MySQL 发起请求调用</li>\n<li>使用较为简单，理论上无需修改代码，仅需使用 ShardingSphere 的配置即可</li>\n</ul>\n</li>\n<li>缺点：\n<ul>\n<li>需要修改项目配置以及引入 Jar 包</li>\n<li>对应用的内存有一定影响</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><code>ShardingSphere-Proxy</code> ：\n<ul>\n<li>优点：\n<ul>\n<li>无需对现有项目做任何配置或代码变更，将数据库的地址改为 Proxy 的地址即可</li>\n<li>Proxy 对 Java 应用内存没有任何影响</li>\n<li>分片后无法知道一条数据记录到底在那张表，Proxy 屏蔽了分片逻辑，可直接操作逻辑表</li>\n</ul>\n</li>\n<li>缺点：\n<ul>\n<li>JDBC 操作 MySQL 是点对点的，但是 Proxy 多了一层链路</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"用户数据分库分表策略\"><a class=\"anchor\" href=\"#用户数据分库分表策略\">#</a> 用户数据分库分表策略</h4>\n<p>根据 2022 年的全国人口统计数据，现有 14 亿多总人口，每年新生人口约 956 万。为便于后续业务数据规模的判断，本文先基于这一人口总量和增长数据进行估算。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/1690195510129-f5e52c9b-459b-412e-b98b-695d32fca81e.png\" alt=\"img\" /></p>\n<p>根据系统设计的假设，12306 的注册用户规模约为 10 亿，每年新增用户约 1000 万。</p>\n<p>在用户数据分库或分表之前，我们需要<font color='red'>先考虑拆分成多少个库或表才能达到最优性能</font>。为了进行这样的决策，我们可以预估单个表的最大数据量。根据过去的经验，通常我们会选择 2000 万作为一个经验值。这个数据量既不会过小，同时又能保证增删改查等操作相对流畅。</p>\n<p>根据当前用户表的数据量为 10 亿，并且每年新增 1000 万用户，预估未来系统的生命周期较长，数据量大概会达到 30 亿左右。<font color='red'>基于这个数据量，我们预估单表的数据量在 2000 万左右，因此需要分大约 150 张表来容纳这些数据</font>。</p>\n<p>在进行分库分表容量评估时，我们通常会尽可能多地进行评估。这样做的好处是，即使每张表的数据量不多，也能及早发现拆分后是否存在数据问题，以便及时进行调整和优化。</p>\n<p>此外，需要特别指出的是，我们对表数据量考虑的阈值相对较小，这是因为我们的系统具备良好的可扩展性，可以轻松应对大量的数据增长。因此，基于这种情况的分库分表策略，即使在几百年后，这个分库分表依然能够处理数据，并且不会出现性能问题。这为我们的系统提供了稳定可靠的性能保障。</p>\n<h4 id=\"选择用户分片键\"><a class=\"anchor\" href=\"#选择用户分片键\">#</a> 选择用户分片键</h4>\n<p>选择分库分表中的分片键（Sharding Key）是一个关键决策，它直接影响了分库分表的性能和可扩展性。以下是<font color='red'>一些选择分片键的关键因素</font>：</p>\n<ol>\n<li><font color='red'>访问频率</font>：选择分片键应考虑数据的访问频率。将经常访问的数据集合放在同一个分片上，可以提高查询性能和降低跨分片查询的开销。</li>\n<li><font color='red'>数据均匀性</font>：分片键应该保证数据的均匀分布在各个分片上，避免出现热点数据集中在某个分片上的情况。</li>\n<li><font color='red'>业务关联性</font>：分片键应该与业务关联紧密，这样可以避免跨分片查询和跨库事务的复杂性。</li>\n<li><font color='red'>数据不可变</font>：一旦选择了分片键，它应该是不可变的，不能随着业务的变化而频繁修改。</li>\n</ol>\n<p>基于以上考虑，我们选择使用  <code>username</code>  用户名作为分片键。</p>\n<h4 id=\"改造用户分库分表\"><a class=\"anchor\" href=\"#改造用户分库分表\">#</a> 改造用户分库分表</h4>\n<p>如果你没有使用过 ShardingSphere 分库分表操作，可以查看官网<span class=\"exturl\" data-url=\"aHR0cHM6Ly9zaGFyZGluZ3NwaGVyZS5hcGFjaGUub3JnL2RvY3VtZW50LzUuMy4yL2NuL2ZlYXR1cmVzL3NoYXJkaW5nLw==\">数据分片 :: ShardingSphere</span> 进行一些前置条件理解。</p>\n<h5 id=\"引入-shardingsphere-jdbc-依赖\"><a class=\"anchor\" href=\"#引入-shardingsphere-jdbc-依赖\">#</a> 引入 ShardingSphere-JDBC 依赖</h5>\n<figure class=\"highlight xml\"><figcaption data-lang=\"XML\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>dependency</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>groupId</span><span class=\"token punctuation\">></span></span>org.apache.shardingsphere<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>groupId</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>artifactId</span><span class=\"token punctuation\">></span></span>shardingsphere-jdbc-core<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>artifactId</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>version</span><span class=\"token punctuation\">></span></span>5.3.2<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>version</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>dependency</span><span class=\"token punctuation\">></span></span></pre></td></tr></table></figure><h5 id=\"定义分片规则\"><a class=\"anchor\" href=\"#定义分片规则\">#</a> 定义分片规则</h5>\n<figure class=\"highlight yaml\"><figcaption data-lang=\"YAML\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token key atrule\">spring</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>  <span class=\"token key atrule\">datasource</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>  \t<span class=\"token comment\"># ShardingSphere 对 Driver 自定义，实现分库分表等隐藏逻辑</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token key atrule\">driver-class-name</span><span class=\"token punctuation\">:</span> org.apache.shardingsphere.driver.ShardingSphereDriver</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token comment\"># ShardingSphere 配置文件路径</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token key atrule\">url</span><span class=\"token punctuation\">:</span> jdbc<span class=\"token punctuation\">:</span>shardingsphere<span class=\"token punctuation\">:</span>classpath<span class=\"token punctuation\">:</span>shardingsphere<span class=\"token punctuation\">-</span>config.yaml</pre></td></tr></table></figure><p>配置文件路径信息如下：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/1690862608819-ad91212a-c24f-4884-aa56-021bb2c3b87f.png\" alt=\"img\" /></p>\n<h5 id=\"用户分片配置\"><a class=\"anchor\" href=\"#用户分片配置\">#</a> 用户分片配置</h5>\n<p>因为 12306 更多的是向大家演示分库分表，所以分 2 个库以及对应业务 16 张表。</p>\n<p><code>shardingsphere-config.yaml</code> ：</p>\n<figure class=\"highlight yaml\"><figcaption data-lang=\"YAML\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># 数据源集合</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token key atrule\">dataSources</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>  <span class=\"token key atrule\">ds_0</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token key atrule\">dataSourceClassName</span><span class=\"token punctuation\">:</span> com.zaxxer.hikari.HikariDataSource</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token key atrule\">driverClassName</span><span class=\"token punctuation\">:</span> com.mysql.cj.jdbc.Driver</pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token key atrule\">jdbcUrl</span><span class=\"token punctuation\">:</span> jdbc<span class=\"token punctuation\">:</span>mysql<span class=\"token punctuation\">:</span>//127.0.0.1<span class=\"token punctuation\">:</span>3306/12306_user_0<span class=\"token punctuation\">?</span>useUnicode=true<span class=\"token important\">&amp;characterEncoding=UTF-8&amp;rewriteBatchedStatements=true&amp;allowMultiQueries=true&amp;serverTimezone=Asia/Shanghai</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token key atrule\">username</span><span class=\"token punctuation\">:</span> root</pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token key atrule\">password</span><span class=\"token punctuation\">:</span> root</pre></td></tr><tr><td data-num=\"9\"></td><td><pre></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>  <span class=\"token key atrule\">ds_1</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token key atrule\">dataSourceClassName</span><span class=\"token punctuation\">:</span> com.zaxxer.hikari.HikariDataSource</pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    <span class=\"token key atrule\">driverClassName</span><span class=\"token punctuation\">:</span> com.mysql.cj.jdbc.Driver</pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    <span class=\"token key atrule\">jdbcUrl</span><span class=\"token punctuation\">:</span> jdbc<span class=\"token punctuation\">:</span>mysql<span class=\"token punctuation\">:</span>//127.0.0.1<span class=\"token punctuation\">:</span>3306/12306_user_1<span class=\"token punctuation\">?</span>useUnicode=true<span class=\"token important\">&amp;characterEncoding=UTF-8&amp;rewriteBatchedStatements=true&amp;allowMultiQueries=true&amp;serverTimezone=Asia/Shanghai</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    <span class=\"token key atrule\">username</span><span class=\"token punctuation\">:</span> root</pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    <span class=\"token key atrule\">password</span><span class=\"token punctuation\">:</span> root</pre></td></tr><tr><td data-num=\"16\"></td><td><pre></pre></td></tr><tr><td data-num=\"17\"></td><td><pre><span class=\"token key atrule\">rules</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>  <span class=\"token punctuation\">-</span> <span class=\"token tag\">!SHARDING</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>    <span class=\"token key atrule\">tables</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>      <span class=\"token key atrule\">t_user</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>        <span class=\"token comment\"># 真实数据节点，比如数据库源以及数据库在数据库中真实存在的</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>        <span class=\"token key atrule\">actualDataNodes</span><span class=\"token punctuation\">:</span> ds_$<span class=\"token punctuation\">&#123;</span>0..1<span class=\"token punctuation\">&#125;</span>.t_user_$<span class=\"token punctuation\">&#123;</span>0..15<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>        <span class=\"token comment\"># 分库策略</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>        <span class=\"token key atrule\">databaseStrategy</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>          <span class=\"token comment\"># 用于单分片键的标准分片场景</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>          <span class=\"token key atrule\">standard</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>            <span class=\"token comment\"># 分片键</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>            <span class=\"token key atrule\">shardingColumn</span><span class=\"token punctuation\">:</span> username</pre></td></tr><tr><td data-num=\"29\"></td><td><pre>            <span class=\"token comment\"># 分片算法，对应 rules [0].shardingAlgorithms</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>            <span class=\"token key atrule\">shardingAlgorithmName</span><span class=\"token punctuation\">:</span> user_database_hash_mod</pre></td></tr><tr><td data-num=\"31\"></td><td><pre>        <span class=\"token comment\"># 分表策略</span></pre></td></tr><tr><td data-num=\"32\"></td><td><pre>        <span class=\"token key atrule\">tableStrategy</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"33\"></td><td><pre>          <span class=\"token comment\"># 用于单分片键的标准分片场景</span></pre></td></tr><tr><td data-num=\"34\"></td><td><pre>          <span class=\"token key atrule\">standard</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"35\"></td><td><pre>            <span class=\"token comment\"># 分片键</span></pre></td></tr><tr><td data-num=\"36\"></td><td><pre>            <span class=\"token key atrule\">shardingColumn</span><span class=\"token punctuation\">:</span> username</pre></td></tr><tr><td data-num=\"37\"></td><td><pre>            <span class=\"token comment\"># 分片算法，对应 rules [0].shardingAlgorithms</span></pre></td></tr><tr><td data-num=\"38\"></td><td><pre>            <span class=\"token key atrule\">shardingAlgorithmName</span><span class=\"token punctuation\">:</span> user_table_hash_mod</pre></td></tr><tr><td data-num=\"39\"></td><td><pre>    <span class=\"token comment\"># 分片算法</span></pre></td></tr><tr><td data-num=\"40\"></td><td><pre>    <span class=\"token key atrule\">shardingAlgorithms</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"41\"></td><td><pre>      <span class=\"token comment\"># 数据库分片算法</span></pre></td></tr><tr><td data-num=\"42\"></td><td><pre>      <span class=\"token key atrule\">user_database_hash_mod</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"43\"></td><td><pre>        <span class=\"token comment\"># 根据分片键 Hash 分片</span></pre></td></tr><tr><td data-num=\"44\"></td><td><pre>        <span class=\"token key atrule\">type</span><span class=\"token punctuation\">:</span> HASH_MOD</pre></td></tr><tr><td data-num=\"45\"></td><td><pre>        <span class=\"token comment\"># 分片数量</span></pre></td></tr><tr><td data-num=\"46\"></td><td><pre>        <span class=\"token key atrule\">props</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"47\"></td><td><pre>          <span class=\"token key atrule\">sharding-count</span><span class=\"token punctuation\">:</span> <span class=\"token number\">2</span></pre></td></tr><tr><td data-num=\"48\"></td><td><pre>      <span class=\"token comment\"># 数据表分片算法</span></pre></td></tr><tr><td data-num=\"49\"></td><td><pre>      <span class=\"token key atrule\">user_table_hash_mod</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"50\"></td><td><pre>        <span class=\"token comment\"># 根据分片键 Hash 分片</span></pre></td></tr><tr><td data-num=\"51\"></td><td><pre>        <span class=\"token key atrule\">type</span><span class=\"token punctuation\">:</span> HASH_MOD</pre></td></tr><tr><td data-num=\"52\"></td><td><pre>        <span class=\"token comment\"># 分片数量</span></pre></td></tr><tr><td data-num=\"53\"></td><td><pre>        <span class=\"token key atrule\">props</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"54\"></td><td><pre>          <span class=\"token key atrule\">sharding-count</span><span class=\"token punctuation\">:</span> <span class=\"token number\">16</span></pre></td></tr><tr><td data-num=\"55\"></td><td><pre><span class=\"token comment\"># 展现逻辑 SQL &amp; 真实 SQL</span></pre></td></tr><tr><td data-num=\"56\"></td><td><pre><span class=\"token key atrule\">props</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"57\"></td><td><pre>  <span class=\"token key atrule\">sql-show</span><span class=\"token punctuation\">:</span> <span class=\"token boolean important\">true</span></pre></td></tr></table></figure><p>写好以上配置后，就可以愉快使用数据库分库分表了。</p>\n<p><code>props.sql-show</code>  配置尽量打开，它能打印应用的逻辑 SQL 以及真正查询数据库的真实 SQL。</p>\n<h4 id=\"小结-5\"><a class=\"anchor\" href=\"#小结-5\">#</a> 小结</h4>\n<p>分库分表是一种数据库架构设计和优化手段，用于应对大规模数据量和高并发访问的情况。它将原本的单库单表拆分为多个数据库或表，从而分散数据存储和查询压力，提高系统的性能和可扩展性。分库分表的场景通常是在系统运行过程中，出现数据量庞大或查询性能慢等问题时引入的。</p>\n<p>分库分表主要有两种模式：</p>\n<ul>\n<li><font color='cornflowerblue'>垂直拆分</font>：将原本的单库<font color='red'>按照业务</font>拆分为多个数据库，每个数据库存储特定的业务数据，如用户库、订单库等。</li>\n<li><font color='cornflowerblue'>水平拆分</font>：将原本的单表拆分为多个表，每个表存储<font color='red'>部分数据</font>，如订单表拆分为 OrderTable_0、OrderTable_1 等。</li>\n</ul>\n<p>在选择分库分表的关键因素中，需要考虑数据的访问频率、数据均匀性、业务关联性和分片键的不可变性。<font color='red'>分片键</font>是用于决定数据分片的字段，合理选择分片键可以提高查询性能和降低跨分片查询的开销。</p>\n<p>对于用户数据分库分表的场景，我们根据当前用户表的数据量和每年新增用户数，预估了未来的数据量。选择了适当的分片键，并进行了分库分表的配置，保证了系统在未来较长时间内的性能和可扩展性。</p>\n<p>我们选择了使用 <font color='red'>ShardingSphere</font> 来实现分库分表，因为 ShardingSphere 拥有活跃的社区，高质量的代码和丰富的功能，能够满足多样化的业务需求。根据实际情况，我们可以选择 ShardingSphere 的 JDBC 或 Proxy 模式来进行分库分表操作，根据项目的具体需求选择最适合的方式。</p>\n<p>总的来说，分库分表是一种重要的数据库优化策略，可以帮助解决大规模数据和高并发访问带来的性能问题。在设计分库分表方案时，需要考虑系统的实际情况和未来的数据增长，合理选择分片键和分片策略，以保证系统的稳定性和可扩展性。同时，选择一个可靠的分库分表工具，如 ShardingSphere，可以帮助我们更加便捷地实现分库分表操作。</p>\n<h1 id=\"面试系列\"><a class=\"anchor\" href=\"#面试系列\">#</a> 面试系列</h1>\n<h2 id=\"如何写在简历上-内推\"><a class=\"anchor\" href=\"#如何写在简历上-内推\">#</a> 如何写在简历上 &amp; 内推</h2>\n<h2 id=\"面经\"><a class=\"anchor\" href=\"#面经\">#</a> 面经</h2>\n<h2 id=\"常见问题与解答\"><a class=\"anchor\" href=\"#常见问题与解答\">#</a> 常见问题与解答</h2>\n",
            "tags": []
        },
        {
            "id": "http://example.com/distributed-microservices/API%E7%BD%91%E5%85%B3&SpringCloud%20Gateway/",
            "url": "http://example.com/distributed-microservices/API%E7%BD%91%E5%85%B3&SpringCloud%20Gateway/",
            "title": "API网关 & SpringCloud Gateway",
            "date_published": "2024-01-06T04:04:44.202Z",
            "content_html": "<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/spring-cloud-gateway-workflow.png\" alt=\"Spring Cloud Gateway 的工作流程\" /></p>\n<h1 id=\"api网关基础\"><a class=\"anchor\" href=\"#api网关基础\">#</a> API 网关基础</h1>\n<h2 id=\"网关是什么\"><a class=\"anchor\" href=\"#网关是什么\">#</a> 网关是什么？</h2>\n<p>微服务背景下，一个系统被拆分为多个服务，但是像安全认证，流量控制，日志，监控等功能是每个服务都需要的，<font color='red'>没有网关的话，就需要在每个服务中单独实现这些功能</font>，这使得我们做了很多重复的事情，并且没有一个全局的视图来统一管理这些功能。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/api-gateway-overview.png\" alt=\"网关示意图\" /></p>\n<center>网关示意图</center>\n<p>一般情况下，网关可以为我们提供<font color='red'>请求转发、安全认证（身份 / 权限认证）、流量控制、负载均衡、降级熔断、日志、监控、参数校验、协议转换</font>等功能。</p>\n<p>上面介绍了这么多功能，实际上，网关主要做了两件事情：<strong><font color='#B32015'>请求转发</font></strong> + <strong><font color='#B32015'>请求过滤</font></strong>。</p>\n<p>由于引入网关之后，会多一步网络转发，因此性能会有一点影响（几乎可以忽略不计，尤其是内网访问的情况下）。另外，我们<font color='red'>需要保障网关服务的高可用，避免单点风险</font>。</p>\n<p>如下图所示，<font color='red'>网关服务外层通过  <code>Nginx</code> （其他负载均衡设备 / 软件也行）进⾏负载转发，以达到⾼可⽤</font>。Nginx 在部署的时候，尽量也要考虑高可用，避免单点风险。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/server-load-balancing.png\" alt=\"基于 Nginx 的服务端负载均衡\" /></p>\n<center>基于 Nginx 的服务端负载均衡</center>\n<h2 id=\"网关的功能\"><a class=\"anchor\" href=\"#网关的功能\">#</a> 网关的功能</h2>\n<p>绝大部分网关可以提供下面这些功能（有一些功能需要借助其他框架或者中间件）：</p>\n<ul>\n<li>\n<p><strong>请求转发</strong>：将请求转发到目标微服务。</p>\n</li>\n<li>\n<p><strong>负载均衡</strong>：根据各个微服务实例的负载情况或者具体的负载均衡策略配置对请求实现动态的负载均衡。</p>\n</li>\n<li>\n<p><strong>安全认证</strong>：对用户请求进行身份验证，并仅允许可信客户端访问 API，并且还能够使用类似 RBAC 等方式来授权。</p>\n</li>\n<li>\n<p><strong>参数校验</strong>：支持参数映射与校验逻辑。</p>\n</li>\n<li>\n<p><strong>日志记录</strong>：记录所有请求的行为日志供后续使用。</p>\n</li>\n<li>\n<p><strong>监控告警</strong>：从业务指标、机器指标、JVM 指标等方面进行监控，并提供配套的告警机制。</p>\n</li>\n<li>\n<p><strong>流量控制</strong>：对请求的流量进行控制，也就是限制某一时刻内的请求数。</p>\n</li>\n<li>\n<p><strong>熔断降级</strong>：实时监控请求的统计信息，达到配置的失败阈值后，自动熔断，返回默认值。</p>\n</li>\n<li>\n<p><strong>响应缓存</strong>：当用户请求获取的是一些静态的或更新不频繁的数据时，一段时间内多次请求获取到的数据很可能是一样的。对于这种情况可以将响应缓存起来。这样用户请求可以直接在网关层得到响应数据，无需再去访问业务服务，减轻业务服务的负担。</p>\n</li>\n<li>\n<p><strong>响应聚合</strong>：某些情况下用户请求要获取的响应内容可能会来自于多个业务服务。网关作为业务服务的调用方，可以把多个服务的响应整合起来，再一并返回给用户。</p>\n</li>\n<li>\n<p><strong>灰度发布</strong>：将请求动态分流到不同的服务版本（最基本的一种灰度发布）。</p>\n</li>\n<li>\n<p><strong>异常处理</strong>：对于业务服务返回的异常响应，可以在网关层在返回给用户之前做转换处理。这样可以把一些业务侧返回的异常细节隐藏，转换成用户友好的错误提示返回。</p>\n</li>\n<li>\n<p><strong>API 文档：</strong> 如果计划将 API 暴露给组织以外的开发人员，那么必须考虑使用 API 文档，例如 Swagger 或 OpenAPI。</p>\n</li>\n<li>\n<p><strong>协议转换</strong>：通过协议转换整合后台基于 REST、AMQP、Dubbo 等不同风格和实现技术的微服务，面向 Web Mobile、开放平台等特定客户端提供统一服务。</p>\n</li>\n<li>\n<p><strong>证书管理</strong>：将 SSL 证书部署到 API 网关，由一个统一的入口管理接口，降低了证书更换时的复杂度。</p>\n</li>\n</ul>\n<p>下图来源于 [百亿规模 API 网关服务 Shepherd 的设计与实现 - 美团技术团队 - 2021 这篇文章。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/up-35e102c633bbe8e0dea1e075ea3fee5dcfb.png\" alt=\"img\" /></p>\n<h2 id=\"常见的网关系统\"><a class=\"anchor\" href=\"#常见的网关系统\">#</a> 常见的网关系统</h2>\n<h3 id=\"netflix-zuul\"><a class=\"anchor\" href=\"#netflix-zuul\">#</a> Netflix Zuul</h3>\n<p>Zuul 是 Netflix 开发的一款提供动态路由、监控、弹性、安全的网关服务，基于 Java 技术栈开发，可以和 Eureka、Ribbon、Hystrix 等组件配合使用。</p>\n<p>Zuul 核心架构如下：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/zuul-core-architecture.webp\" alt=\"Zuul 核心架构\" /></p>\n<center>Zuul 核心架构</center>\n<p>Zuul 主要通过<font color='red'>过滤器</font>（类似于 AOP）来过滤请求，从而实现网关必备的各种功能。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/zuul-request-lifecycle.webp\" alt=\"Zuul 请求声明周期\" /></p>\n<center>Zuul 请求声明周期</center>\n<p>我们可以<font color='red'>自定义过滤器来处理请求</font>，并且，Zuul 生态本身就有很多现成的过滤器供我们使用。就比如<font color='red'>限流</font>可以直接用国外朋友写的 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL21hcmNvc2JhcmJlcm8vc3ByaW5nLWNsb3VkLXp1dWwtcmF0ZWxpbWl0\">spring-cloud-zuul-ratelimit</span> (这里只是举例说明，一般是配合 hystrix 来做限流)：</p>\n<figure class=\"highlight xml\"><figcaption data-lang=\"XML\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>dependency</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>groupId</span><span class=\"token punctuation\">></span></span>org.springframework.cloud<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>groupId</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>artifactId</span><span class=\"token punctuation\">></span></span>spring-cloud-starter-netflix-zuul<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>artifactId</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>dependency</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>dependency</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>groupId</span><span class=\"token punctuation\">></span></span>com.marcosbarbero.cloud<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>groupId</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>artifactId</span><span class=\"token punctuation\">></span></span>spring-cloud-zuul-ratelimit<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>artifactId</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>version</span><span class=\"token punctuation\">></span></span>2.2.0.RELEASE<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>version</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>dependency</span><span class=\"token punctuation\">></span></span></pre></td></tr></table></figure><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9uZXRmbGl4dGVjaGJsb2cuY29tL2Fubm91bmNpbmctenV1bC1lZGdlLXNlcnZpY2UtaW4tdGhlLWNsb3VkLWFiM2FmNWJlMDhlZQ==\">Zuul 1.x</span> 基于同步 IO，性能较差。<span class=\"exturl\" data-url=\"aHR0cHM6Ly9uZXRmbGl4dGVjaGJsb2cuY29tL29wZW4tc291cmNpbmctenV1bC0yLTgyZWE0NzZjYjJiMw==\">Zuul 2.x</span> <font color='red'>基于 Netty 实现了异步 IO</font>，性能得到了大幅改进。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/zuul2-core-architecture.png\" alt=\"Zuul2 架构\" /></p>\n<ul>\n<li>\n<p>GitHub 地址： <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL05ldGZsaXgvenV1bA==\">https://github.com/Netflix/zuul</span></p>\n</li>\n<li>\n<p>官方 Wiki： <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL05ldGZsaXgvenV1bC93aWtp\">https://github.com/Netflix/zuul/wiki</span></p>\n</li>\n</ul>\n<h3 id=\"spring-cloud-gateway\"><a class=\"anchor\" href=\"#spring-cloud-gateway\">#</a> Spring Cloud Gateway</h3>\n<p>SpringCloud Gateway 属于 Spring Cloud 生态系统中的网关，其诞生的目标是<font color='red'>为了替代老牌网关 <strong>Zuul</strong></font>。准确点来说，应该是 Zuul 1.x。SpringCloud Gateway 起步要比 Zuul 2.x 更早。</p>\n<p>为了提升网关的性能，SpringCloud Gateway <font color='red'>基于 Spring WebFlux</font> 。Spring WebFlux 使用 Reactor 库来实现<font color='red'>响应式编程模型</font>，底层<font color='red'>基于 Netty 实现同步非阻塞的 I/O</font>。</p>\n<p>![img](<span class=\"exturl\" data-url=\"aHR0cHM6Ly9vc3MuamF2YWd1aWRlLmNuL2dpdGh1Yi9qYXZhZ3VpZGUvc3lzdGVtLWRlc2lnbi9kaXN0cmlidXRlZC1zeXN0ZW0vYXBpLWdhdGV3YXkvc3ByaW5nY2xvdWQtZ2F0ZXdheS0=\">https://oss.javaguide.cn/github/javaguide/system-design/distributed-system/api-gateway/springcloud-gateway-</span> demo.png)</p>\n<p>Spring Cloud Gateway 不仅提供统一的路由方式，并且 **<font color='red'>基于 Filter 链</font>** 的方式提供了网关基本的功能，例如：安全，监控 / 指标，限流。</p>\n<p>Spring Cloud Gateway 和 Zuul 2.x 的差别不大，也是通过过滤器来处理请求。不过，目前更加<font color='red'>推荐使用 Spring Cloud Gateway </font>而非 Zuul，Spring Cloud 生态对其支持更加友好。</p>\n<ul>\n<li>Github 地址： <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3NwcmluZy1jbG91ZC9zcHJpbmctY2xvdWQtZ2F0ZXdheQ==\">https://github.com/spring-cloud/spring-cloud-gateway</span></li>\n<li>官网： <span class=\"exturl\" data-url=\"aHR0cHM6Ly9zcHJpbmcuaW8vcHJvamVjdHMvc3ByaW5nLWNsb3VkLWdhdGV3YXk=\">https://spring.io/projects/spring-cloud-gateway</span></li>\n</ul>\n<h3 id=\"openresty\"><a class=\"anchor\" href=\"#openresty\">#</a> OpenResty</h3>\n<p>根据官方介绍：</p>\n<blockquote>\n<p>OpenResty 是一个基于 Nginx 与 Lua 的高性能 Web 平台，其内部集成了大量精良的 Lua 库、第三方模块以及大多数的依赖项。用于方便地搭建能够处理超高并发、扩展性极高的动态 Web 应用、Web 服务和动态网关。</p>\n</blockquote>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/api-gatewaynginx-lua-openresty.png\" alt=\"OpenResty 和 Nginx 以及 Lua 的关系\" /> OpenResty 和 Nginx 以及 Lua 的关系</p>\n<p>OpenResty 基于 Nginx，主要还是看中了其优秀的高并发能力。不过，由于 Nginx 采用 C 语言开发，二次开发门槛较高。如果想在 Nginx 上实现一些自定义的逻辑或功能，就需要编写 C 语言的模块，并重新编译 Nginx。</p>\n<p>为了解决这个问题，OpenResty 通过实现  <code>ngx_lua</code>  和  <code>stream_lua</code>  等 Nginx 模块，把 Lua/LuaJIT 完美地整合进了 Nginx，从而让我们能够在 Nginx 内部里嵌入 Lua 脚本，使得可以通过简单的 Lua 语言来扩展网关的功能，比如实现自定义的路由规则、过滤器、缓存策略等。</p>\n<blockquote>\n<p>Lua 是一种非常快速的动态脚本语言，它的运行速度接近于 C 语言。LuaJIT 是 Lua 的一个即时编译器，它可以显著提高 Lua 代码的执行效率。LuaJIT 将一些常用的 Lua 函数和工具库预编译并缓存，这样在下次调用时就可以直接使用缓存的字节码，从而大大加快了执行速度。</p>\n</blockquote>\n<p>关于 OpenResty 的入门以及网关安全实战推荐阅读这篇文章：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvM0hnbFpzMDZXOTV2RjN0U2EzS3JYdw==\">每个后端都应该了解的 OpenResty 入门以及网关安全实战</span>。</p>\n<ul>\n<li>Github 地址： <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL29wZW5yZXN0eS9vcGVucmVzdHk=\">https://github.com/openresty/openresty</span></li>\n<li>官网地址： <span class=\"exturl\" data-url=\"aHR0cHM6Ly9vcGVucmVzdHkub3JnLw==\">https://openresty.org/</span></li>\n</ul>\n<h3 id=\"kong\"><a class=\"anchor\" href=\"#kong\">#</a> Kong</h3>\n<p>Kong 是一款基于 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL29wZW5yZXN0eS8=\">OpenResty</span> （Nginx + Lua）的高性能、云原生、可扩展、生态丰富的网关系统，主要由 3 个组件组成：</p>\n<ul>\n<li>Kong Server：基于 Nginx 的服务器，用来接收 API 请求。</li>\n<li>Apache Cassandra/PostgreSQL：用来存储操作数据。</li>\n<li>Kong Dashboard：官方推荐 UI 管理工具，当然，也可以使用 RESTful 方式 管理 Admin api。</li>\n</ul>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/kong-way.webp\" alt=\"img\" /></p>\n<p>由于默认使用 Apache Cassandra/PostgreSQL 存储数据，Kong 的<font color='red'>整个架构比较臃肿，并且会带来高可用的问题</font>。</p>\n<p>Kong 提供了<font color='red'>插件机制</font>来扩展其功能，插件在 API 请求响应循环的生命周期中被执行。比如在服务上启用 Zipkin 插件：</p>\n<figure class=\"highlight sh\"><figcaption data-lang=\"sh\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">curl</span> <span class=\"token parameter variable\">-X</span> POST http://kong:8001/services/<span class=\"token punctuation\">&#123;</span>service<span class=\"token punctuation\">&#125;</span>/plugins <span class=\"token punctuation\">\\</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token parameter variable\">--data</span> <span class=\"token string\">\"name=zipkin\"</span>  <span class=\"token punctuation\">\\</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token parameter variable\">--data</span> <span class=\"token string\">\"config.http_endpoint=http://your.zipkin.collector:9411/api/v2/spans\"</span> <span class=\"token punctuation\">\\</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token parameter variable\">--data</span> <span class=\"token string\">\"config.sample_ratio=0.001\"</span></pre></td></tr></table></figure><p>Kong 本身就是一个 Lua 应用程序，并且是在 Openresty 的基础之上做了一层封装的应用。归根结底就是利用 Lua 嵌入 Nginx 的方式，赋予了 Nginx 可编程的能力，这样以插件的形式在 Nginx 这一层能够做到无限想象的事情。例如限流、安全访问策略、路由、负载均衡等等。编写一个 Kong 插件，就是按照 Kong 插件编写规范，写一个自己自定义的 Lua 脚本，然后加载到 Kong 中，最后引用即可。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/kong-gateway-overview.png\" alt=\"img\" /></p>\n<p>除了 Lua，Kong 还可以基于 Go 、JavaScript、Python 等语言开发插件，得益于对应的 PDK（插件开发工具包）。</p>\n<p>关于 Kong 插件的详细介绍，推荐阅读官方文档：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb2NzLmtvbmdocS5jb20vZ2F0ZXdheS9sYXRlc3Qva29uZy1wbHVnaW5zLw==\">https://docs.konghq.com/gateway/latest/kong-plugins/</span>，写的比较详细。</p>\n<ul>\n<li>Github 地址： <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL0tvbmcva29uZw==\">https://github.com/Kong/kong</span></li>\n<li>官网地址： <span class=\"exturl\" data-url=\"aHR0cHM6Ly9rb25naHEuY29tL2tvbmc=\">https://konghq.com/kong</span></li>\n</ul>\n<h3 id=\"apisix\"><a class=\"anchor\" href=\"#apisix\">#</a> APISIX</h3>\n<p>APISIX 是一款基于 OpenResty 和 etcd 的高性能、云原生、可扩展的网关系统。</p>\n<blockquote>\n<p>etcd 是使用 Go 语言开发的一个开源的、高可用的分布式 key-value 存储系统，使用 Raft 协议做分布式共识。</p>\n</blockquote>\n<p>与传统 API 网关相比，APISIX 具有<font color='red'>动态路由</font>和<font color='red'>插件热加载</font>，特别适合微服务系统下的 API 管理。并且，APISIX 与 SkyWalking（分布式链路追踪系统）、Zipkin（分布式链路追踪系统）、Prometheus（监控系统） 等 DevOps 生态工具对接都十分方便。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/apisix-architecture.png\" alt=\"APISIX 架构图\" /></p>\n<center>APISIX 架构图</center>\n<p>作为 Nginx 和 Kong 的替代项目，<font color='red'>APISIX 目前已经是 Apache 顶级开源项目，并且是最快毕业的国产开源项目</font>。国内目前已经有很多知名企业（比如金山、有赞、爱奇艺、腾讯、贝壳）使用 APISIX 处理核心的业务流量。</p>\n<p>根据官网介绍：“APISIX 已经生产可用，功能、性能、架构全面优于 Kong”。</p>\n<p>APISIX 同样支持定制化的插件开发。开发者除了能够使用 Lua 语言开发插件，还能通过下面两种方式开发来避开 Lua 语言的学习成本：</p>\n<ul>\n<li>通过 Plugin Runner 来支持更多的主流编程语言（比如 Java、Python、Go 等等）。通过这样的方式，可以让后端工程师通过本地 RPC 通信，使用熟悉的编程语言开发 APISIX 的插件。这样做的好处是减少了开发成本，提高了开发效率，但是在性能上会有一些损失。</li>\n<li>使用 Wasm（WebAssembly） 开发插件。Wasm 被嵌入到了 APISIX 中，用户可以使用 Wasm 去编译成 Wasm 的字节码在 APISIX 中运行。</li>\n</ul>\n<blockquote>\n<p>Wasm 是基于堆栈的虚拟机的二进制指令格式，一种低级汇编语言，旨在非常接近已编译的机器代码，并且非常接近本机性能。Wasm 最初是为浏览器构建的，但是随着技术的成熟，在服务器端看到了越来越多的用例。</p>\n</blockquote>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/up-a240d3b113cde647f5850f4c7cc55d4ff5c.png\" alt=\"img\" /></p>\n<ul>\n<li>Github 地址：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2FwYWNoZS9hcGlzaXg=\">https://github.com/apache/apisix</span></li>\n<li>官网地址： <span class=\"exturl\" data-url=\"aHR0cHM6Ly9hcGlzaXguYXBhY2hlLm9yZy96aC8=\">https://apisix.apache.org/zh/</span></li>\n</ul>\n<h3 id=\"shenyu\"><a class=\"anchor\" href=\"#shenyu\">#</a> Shenyu</h3>\n<p>Shenyu 是一款<font color='red'>基于 WebFlux </font>的可扩展、高性能、<font color='red'>响应式网关</font>，Apache 顶级开源项目。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/shenyu-architecture.png\" alt=\"Shenyu 架构\" /></p>\n<center>Shenyu 架构</center>\n<p>Shenyu 通过<font color='red'>插件</font>扩展功能，插件是 ShenYu 的灵魂，并且插件也是可扩展和热插拔的。不同的插件实现不同的功能。Shenyu 自带了诸如<font color='red'>限流、熔断、转发、重写、重定向、和路由监控</font>等插件。</p>\n<ul>\n<li>Github 地址： <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2FwYWNoZS9pbmN1YmF0b3Itc2hlbnl1\">https://github.com/apache/incubator-shenyu</span></li>\n<li>官网地址： <span class=\"exturl\" data-url=\"aHR0cHM6Ly9zaGVueXUuYXBhY2hlLm9yZy8=\">https://shenyu.apache.org/</span></li>\n</ul>\n<h2 id=\"如何选择\"><a class=\"anchor\" href=\"#如何选择\">#</a> 如何选择？</h2>\n<p>上面介绍的几个常见的网关系统，最常用的是 Spring Cloud Gateway、Kong、APISIX 这三个。</p>\n<p>对于公司业务以 Java 为主要开发语言的情况下，Spring Cloud Gateway 通常是个不错的选择，其优点有：简单易用、成熟稳定、与 Spring Cloud 生态系统兼容、Spring 社区成熟等等。不过，Spring Cloud Gateway 也有一些局限性和不足之处，一般还需要结合其他网关一起使用比如 OpenResty。并且，<font color='red'>Spring Cloud Gateway 的性能相比较于 Kong 和 APISIX 还是差一些</font>。如果对性能要求比较高的话，Spring Cloud Gateway 不是一个好的选择。</p>\n<p>Kong 和 APISIX 功能更丰富，性能更强大，技术架构更贴合云原生。Kong 是开源 API 网关的鼻祖，生态丰富，用户群体庞大。APISIX 属于后来者，更优秀一些，根据 APISIX 官网介绍：“APISIX 已经生产可用，功能、性能、架构全面优于 Kong”。下面简单对比一下二者：</p>\n<ul>\n<li>APISIX 基于 etcd 来做配置中心，不存在单点问题，云原生友好；而<font color='red'> Kong 基于 Apache Cassandra/PostgreSQL ，存在单点风险</font>，需要额外的基础设施保障做高可用。</li>\n<li>APISIX 支持热更新，并且实现了毫秒级别的热更新响应；而<font color='red'> Kong 不支持热更新</font>。</li>\n<li><font color='red'>APISIX 的性能要优于 Kong </font>。</li>\n<li><font color='red'>APISIX 支持的插件更多</font>，功能更丰富。</li>\n</ul>\n<h1 id=\"springcloud-gateway-常见问题\"><a class=\"anchor\" href=\"#springcloud-gateway-常见问题\">#</a> SpringCloud Gateway 常见问题</h1>\n<h2 id=\"是什么\"><a class=\"anchor\" href=\"#是什么\">#</a> 是什么</h2>\n<p>Spring Cloud Gateway 属于 Spring Cloud 生态系统中的网关，其诞生的目标是为了替代老牌网关 <strong>Zuul</strong>。准确点来说，应该是 Zuul 1.x。Spring Cloud Gateway 起步要比 Zuul 2.x 更早。</p>\n<p>为了提升网关的性能，Spring Cloud Gateway 基于 Spring WebFlux 。Spring WebFlux 使用 Reactor 库来实现响应式编程模型，底层基于 Netty 实现同步非阻塞的 I/O。</p>\n<p>![img](<span class=\"exturl\" data-url=\"aHR0cHM6Ly9vc3MuamF2YWd1aWRlLmNuL2dpdGh1Yi9qYXZhZ3VpZGUvc3lzdGVtLWRlc2lnbi9kaXN0cmlidXRlZC1zeXN0ZW0vYXBpLWdhdGV3YXkvc3ByaW5nY2xvdWQtZ2F0ZXdheS0=\">https://oss.javaguide.cn/github/javaguide/system-design/distributed-system/api-gateway/springcloud-gateway-</span> demo.png)</p>\n<p>Spring Cloud Gateway 不仅提供统一的路由方式，并且基于 Filter 链的方式提供了网关基本的功能，例如：安全，监控 / 指标，限流。</p>\n<p>Spring Cloud Gateway 和 Zuul 2.x 的差别不大，也是通过过滤器来处理请求。不过，目前更加推荐使用 Spring Cloud Gateway 而非 Zuul，Spring Cloud 生态对其支持更加友好。</p>\n<ul>\n<li>GitHub 地址： <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3NwcmluZy1jbG91ZC9zcHJpbmctY2xvdWQtZ2F0ZXdheQ==\">https://github.com/spring-cloud/spring-cloud-gateway</span></li>\n<li>官网： <span class=\"exturl\" data-url=\"aHR0cHM6Ly9zcHJpbmcuaW8vcHJvamVjdHMvc3ByaW5nLWNsb3VkLWdhdGV3YXk=\">https://spring.io/projects/spring-cloud-gateway</span></li>\n</ul>\n",
            "tags": [
                "分布式微服务"
            ]
        },
        {
            "id": "http://example.com/distributed-microservices/%E5%88%86%E5%B8%83%E5%BC%8FID&%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81&%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1&%E5%88%86%E5%B8%83%E5%BC%8F%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/",
            "url": "http://example.com/distributed-microservices/%E5%88%86%E5%B8%83%E5%BC%8FID&%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81&%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1&%E5%88%86%E5%B8%83%E5%BC%8F%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/",
            "title": "分布式ID&分布式锁&分布式事务&分布式配置中心",
            "date_published": "2024-01-06T04:02:34.051Z",
            "content_html": "<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/distributed-lock.png\" alt=\"分布式锁\" /></p>\n",
            "tags": [
                "分布式微服务"
            ]
        },
        {
            "id": "http://example.com/distributed-microservices/%E5%88%86%E5%B8%83%E5%BC%8F%E7%90%86%E8%AE%BA&%E7%AE%97%E6%B3%95&%E5%8D%8F%E8%AE%AE/",
            "url": "http://example.com/distributed-microservices/%E5%88%86%E5%B8%83%E5%BC%8F%E7%90%86%E8%AE%BA&%E7%AE%97%E6%B3%95&%E5%8D%8F%E8%AE%AE/",
            "title": "分布式理论&算法&协议",
            "date_published": "2023-12-16T07:52:05.004Z",
            "content_html": "<h1 id=\"cap-base-理论详解\"><a class=\"anchor\" href=\"#cap-base-理论详解\">#</a> CAP &amp; BASE 理论详解</h1>\n<h2 id=\"cap-理论\"><a class=\"anchor\" href=\"#cap-理论\">#</a> CAP 理论</h2>\n<h3 id=\"简介\"><a class=\"anchor\" href=\"#简介\">#</a> 简介</h3>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231217154635468.png\" alt=\"CAP理论\" /></p>\n<p>CAP 理论指的是 **<font color='#B32015'>在一个分布式系统中，在设计读写操作时，只能同时满足以下三点中的两个：一致性（C）、可用性（A）、分区容错性（P）</font>**。</p>\n<ul>\n<li>\n<p><font color='cornflowerblue'>一致性（ <code>C</code> onsistency）</font>：分布式系统中多个主机之间是否能够保持数据一致的特性。即，<font color='red'>当系统数据发生更新操作后，各个主机中的数据仍然处于一致的状态</font>。所有节点访问同一份最新的数据副本。</p>\n</li>\n<li>\n<p><font color='cornflowerblue'>可用性（ <code>A</code> vailability）</font>：<font color='red'>系统提供的服务必须一直处于可用的状态</font>。即，对于用户的每一个请求，系统（非故障节点）总是可以在有限的时间内对用户做出合理响应（不是错误 / 超时的响应）。</p>\n</li>\n<li>\n<p><font color='cornflowerblue'>分区容错性（ <code>P</code> artition tolerance）</font>：<font color='red'>分布式系统在遇到任何<strong>网络分区故障</strong>时，仍能够保证对外提供（满足一致性和可用性的）服务</font>。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/partition-tolerance.png\" alt=\"partition-tolerance\" /></p>\n<center>partition-tolerance</center>\n<blockquote>\n<p><strong>网络分区</strong>：分布式系统中，多个节点之间的网络本来是连通的，但是因为某些故障（比如部分节点网络出了问题）<font color='red'>某些节点之间不连通了，整个网络就分成了几块区域</font>，这就叫网络分区。</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"不是所谓的3选2\"><a class=\"anchor\" href=\"#不是所谓的3选2\">#</a> 不是所谓的 “3 选 2”</h3>\n<p>大部分人解释这一定律时，常常简单的表述为：“一致性、可用性、分区容忍性三者你只能同时达到其中两个，不可能同时达到”。实际上这是一个非常具有误导性质的说法，而且在 CAP 理论诞生 12 年之后，CAP 之父也在 2012 年重写了之前的论文。</p>\n<blockquote>\n<p>当发生网络分区的时候，如果我们要继续服务，那么强一致性和可用性只能 2 选 1。也就是说当网络分区之后 P 是前提，决定了 P 之后才有 C 和 A 的选择。也就是说分区容错性（Partition tolerance）我们是必须要实现的。</p>\n<p>简而言之就是：<strong><font color='#B32015'>CAP 理论中分区容错性 P 是一定要满足的，在此基础上，只能满足可用性 A 或者强一致性 C</font></strong>。</p>\n</blockquote>\n<p>因此，<font color='red'>分布式系统理论上不可能选择 CA 架构，只能选择 CP 或者 AP 架构</font>。比如 ZooKeeper、HBase 就是 CP 架构，Cassandra、Eureka 就是 AP 架构，Nacos 不仅支持 CP 架构也支持 AP 架构。</p>\n<p>为啥不可能选择 CA 架构呢？举个例子：若系统出现 “分区”，系统中的某个节点在进行写操作。为了保证 C，必须要禁止其他节点的读写操作，这就和 A 发生冲突了。如果为了保证 A，其他节点的读写操作正常的话，那就和 C 发生冲突了。</p>\n<p><font color='red'>选择 CP 还是 AP 的关键在于当前的业务场景，没有定论，比如对于需要确保强一致性的场景如银行一般会选择保证 CP 。</font></p>\n<p>另外，需要补充说明的一点是：<font color='red'>如果网络分区正常的话（系统在绝大部分时候所处的状态），也就说不需要保证 P 的时候，C 和 A 能够同时保证。</font></p>\n<h3 id=\"cap-实际应用案例注册中心\"><a class=\"anchor\" href=\"#cap-实际应用案例注册中心\">#</a> CAP 实际应用案例：注册中心</h3>\n<p>我这里以注册中心来探讨一下 CAP 的实际应用。考虑到很多小伙伴不知道注册中心是干嘛的，这里简单以 Dubbo 为例说一说。</p>\n<p>下图是 Dubbo 的架构图。注册中心 Registry 在其中扮演了什么角色呢？提供了什么服务呢？</p>\n<p><font color='red'>注册中心负责服务地址的注册与查找，相当于服务的目录，服务提供者和消费者只在启动时与注册中心交互，注册中心不转发请求，压力较小</font>。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231217154850034.png\" alt=\"image-20231217154850034\" /></p>\n<p>常见的可以作为注册中心的组件有：ZooKeeper、Eureka、Nacos...。</p>\n<ol>\n<li>**ZooKeeper 保证的是 CP。** 任何时刻对 ZooKeeper 的读请求都能得到一致性的结果，但是，<font color='red'>ZooKeeper 不保证每次请求的可用性，比如在 Leader 选举过程中，或者半数以上的机器不可用的时候，或者当 Leader 节点中的数据发生了变化但 Follower 还没有同步完成之前，整个 ZooKeeper 集群是不对外提供服务的</font>。</li>\n<li><strong>Eureka 保证的则是 AP。</strong> Eureka 在设计的时候就是优先保证 A （可用性）。<font color='red'>在 Eureka 中不存在什么 Leader 节点，每个节点都是一样的、平等的</font>。因此 Eureka 不会像 ZooKeeper 那样出现选举过程中或者半数以上的机器不可用的时候服务就是不可用的情况。 <font color='red'>Eureka 保证即使大部分节点挂掉也不会影响正常提供服务，只要有一个节点是可用的就行了，只不过这个节点上的数据可能并不是最新的</font>。</li>\n<li><strong>Nacos 不仅支持 CP 也支持 AP。</strong></li>\n</ol>\n<p><strong>🐛 修正（参见：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL1NuYWlsY2xpbWIvSmF2YUd1aWRlL2lzc3Vlcy8xOTA2\">issue#1906</span>）</strong>：</p>\n<p>ZooKeeper 通过可线性化（Linearizable）写入、全局 FIFO 顺序访问等机制来保障数据一致性。多节点部署的情况下， ZooKeeper 集群处于 Quorum 模式。Quorum 模式下的 ZooKeeper 集群，是一组 ZooKeeper 服务器节点组成的集合，其中大多数节点必须同意任何变更才能被视为有效。</p>\n<p>由于 Quorum 模式下的读请求不会触发各个 ZooKeeper 节点之间的数据同步，因此在某些情况下还是可能会存在读取到旧数据的情况，导致不同的客户端视图上看到的结果不同，这可能是由于网络延迟、丢包、重传等原因造成的。ZooKeeper 为了解决这个问题，提供了 Watcher 机制和版本号机制来帮助客户端检测数据的变化和版本号的变更，以保证数据的一致性。</p>\n<h3 id=\"小结\"><a class=\"anchor\" href=\"#小结\">#</a> 小结</h3>\n<p>在进行分布式系统设计和开发时，我们不应该仅仅局限在 CAP 问题上，还要关注系统的扩展性、可用性等等。</p>\n<p><font color='red'>在系统发生 “分区” 的情况下，CAP 理论只能满足 CP 或者 AP</font>。要注意的是，这里的前提是系统发生了 “分区”。</p>\n<p><font color='red'>如果系统没有发生 “分区” 的话，节点间的网络连接通信正常的话，也就不存在 P 了。这个时候，我们就可以同时保证 C 和 A 了</font>。</p>\n<p>总结：<strong><font color='red'>如果系统发生 “分区”，我们要考虑选择 CP 还是 AP。如果系统没有发生 “分区” 的话，我们要思考如何保证 CA 。</font></strong></p>\n<h2 id=\"base-理论\"><a class=\"anchor\" href=\"#base-理论\">#</a> BASE 理论</h2>\n<h3 id=\"简介-2\"><a class=\"anchor\" href=\"#简介-2\">#</a> 简介</h3>\n<p><font color='red'>BASE 是对 CAP 中一致性 C 和可用性 A 权衡的结果</font>，其来源于对大规模互联网系统分布式实践的总结，是基于 CAP 定理逐步演化而来的，它大大降低了我们对系统的要求，由以下三个短语的简写组成：</p>\n<ul>\n<li><font color='cornflowerblue'> <code>B</code> asically  <code>A</code> vailable（基本可用）</font>：分布式系统在出现不可预知故障的时候，<font color='red'>允许损失部分可用性</font>。但这绝不等价于系统不可用。</li>\n<li><font color='cornflowerblue'> <code>S</code> oft state（软状态）</font>：允许系统数据存在的中间状态，并认为该中间状态的存在不会影响系统的整体可用性。即，<font color='red'>允许系统主机间进行数据同步的过程存在一定延时</font>。软状态，其实就是一种灰度状态，过渡状态。</li>\n<li><font color='cornflowerblue'> <code>E</code> ventually consistent（最终一致性）</font>：强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。因此，最终一致性的本质是<font color='red'>需要系统保证最终数据能够达到一致，而不需要保证系统数据的实时一致性</font>。</li>\n</ul>\n<h3 id=\"核心思想\"><a class=\"anchor\" href=\"#核心思想\">#</a> 核心思想</h3>\n<p>BASE 理论的核心思想：<font color='red'>即使无法做到强一致性 C ，但每个系统都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性 E </font>。</p>\n<blockquote>\n<p>也就是 **<font color='red'>牺牲数据的强一致性 C 来满足系统的基本可用性 BA</font>** ，系统中一部分数据不可用或者不一致时，仍需要保持系统整体 “基本可用”。</p>\n</blockquote>\n<p>**BASE 理论本质上是对 CAP 的延伸和补充，更具体地说，是对 CAP 中 AP 方案的一个补充。**AP 方案只是在系统发生分区的时候放弃一致性，而不是永远放弃一致性。<font color='red'>在分区故障恢复后，系统应该达到最终一致性</font>。这一点其实就是 BASE 理论延伸的地方。</p>\n<h3 id=\"三要素\"><a class=\"anchor\" href=\"#三要素\">#</a> 三要素</h3>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC81LzI0LzE2MzkxNDgwNmQ5ZTE1YzY\" alt=\"BASE理论三要素\" /></p>\n<h4 id=\"基本可用ba\"><a class=\"anchor\" href=\"#基本可用ba\">#</a> 基本可用（BA）</h4>\n<p>基本可用是指分布式系统在出现不可预知故障的时候，<font color='red'>允许损失部分可用性</font>。但是，这绝不等价于系统不可用。</p>\n<ul>\n<li><strong>响应时间上的损失</strong>：正常情况下，处理用户请求需要 0.5s 返回结果，但是由于系统出现故障，处理用户请求的时间变为 3 s。</li>\n<li><strong>系统功能上的损失</strong>：正常情况下，用户可以使用系统的全部功能，但是由于系统访问量突然剧增，系统的部分非核心功能无法使用。</li>\n</ul>\n<h4 id=\"软状态s\"><a class=\"anchor\" href=\"#软状态s\">#</a> 软状态（S）</h4>\n<p>软状态指允许系统中的数据存在中间状态（<strong>CAP 理论中的数据不一致</strong>），并认为该中间状态的存在不会影响系统的整体可用性，即<font color='red'>允许系统在不同节点的数据副本之间进行数据同步的过程存在延时</font>。</p>\n<h4 id=\"最终一致性e\"><a class=\"anchor\" href=\"#最终一致性e\">#</a> 最终一致性（E）</h4>\n<p>最终一致性强调的是<font color='red'>系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态</font>。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，<font color='red'>而不需要实时保证系统数据的强一致性</font>。</p>\n<blockquote>\n<p>分布式一致性的 3 种级别：</p>\n<ol>\n<li><strong>强一致性</strong>：系统写入了什么，读出来的就是什么。</li>\n<li><strong>弱一致性</strong>：不一定可以读取到最新写入的值，也不保证多少时间之后读取到的数据是最新的，只是会尽量保证某个时刻达到数据一致的状态。</li>\n<li><strong>最终一致性</strong>：弱一致性的升级版，系统会保证在一定时间内达到数据一致的状态。</li>\n</ol>\n<p><strong><font color='red'>业界比较推崇是最终一致性级别，但是某些对数据一致要求十分严格的场景比如银行转账还是要保证强一致性。</font></strong></p>\n</blockquote>\n<p>那实现最终一致性的具体方式是什么呢？<span class=\"exturl\" data-url=\"aHR0cDovL2drLmxpbmsvYS8xMHJaTQ==\">《分布式协议与算法实战》</span> 中是这样介绍：</p>\n<blockquote>\n<ul>\n<li><strong>读时修复</strong>：在读取数据时，检测数据的不一致，进行修复。比如 Cassandra 的 Read Repair 实现，具体来说，在向 Cassandra 系统查询数据的时候，如果检测到不同节点的副本数据不一致，系统就自动修复数据。</li>\n<li><strong><font color='red'>写时修复</font></strong>: 在写入数据，检测数据的不一致时，进行修复。比如 Cassandra 的 Hinted Handoff 实现。具体来说，Cassandra 集群的节点之间远程写数据的时候，如果写失败 就将数据缓存下来，然后定时重传，修复数据的不一致性。</li>\n<li><strong>异步修复</strong>：这个是最常用的方式，通过定时对账检测副本数据的一致性，并修复。</li>\n</ul>\n</blockquote>\n<p>比较推荐 <strong>写时修复</strong>，这种方式对性能消耗比较低。</p>\n<h3 id=\"小结-2\"><a class=\"anchor\" href=\"#小结-2\">#</a> 小结</h3>\n<p><strong><font color='#B32015'>ACID 是数据库事务完整性的理论，CAP 是分布式系统设计理论，BASE 是 CAP 理论中 AP 方案的延伸。</font></strong></p>\n<h1 id=\"paxos-算法详解\"><a class=\"anchor\" href=\"#paxos-算法详解\">#</a> Paxos 算法详解</h1>\n<h2 id=\"背景\"><a class=\"anchor\" href=\"#背景\">#</a> 背景</h2>\n<p>Paxos 算法是 Leslie Lamport（<span class=\"exturl\" data-url=\"aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU4JThFJUIxJUU2JTk2JUFGJUU1JTg4JUE5JUMyJUI3JUU1JTg1JUIwJUU0JUJDJUFGJUU3JTg5JUI5\">莱斯利・兰伯特</span>）在 1990 年提出了一种 **<font color='#B32015'>分布式系统共识算法</font>**。这也是第一个被证明完备的共识算法（前提是不存在拜占庭将军问题，也就是没有恶意节点）。</p>\n<p>为了介绍 Paxos 算法，兰伯特专门写了一篇幽默风趣的论文。在这篇论文中，他虚拟了一个叫做 Paxos 的希腊城邦来更形象化地介绍 Paxos 算法。</p>\n<p>不过，审稿人并不认可这篇论文的幽默。于是，他们就给兰伯特说：“如果你想要成功发表这篇论文的话，必须删除所有 Paxos 相关的故事背景”。兰伯特一听就不开心了：“我凭什么修改啊，你们这些审稿人就是缺乏幽默细胞，发不了就不发了呗！”。</p>\n<p>于是乎，提出 Paxos 算法的那篇论文在当时并没有被成功发表。</p>\n<p>直到 1998 年，系统研究中心 (Systems Research Center，SRC）的两个技术研究员需要找一些合适的分布式算法来服务他们正在构建的分布式系统，Paxos 算法刚好可以解决他们的部分需求。因此，兰伯特就把论文发给了他们。在看了论文之后，这俩大佬觉得论文还是挺不错的。于是，兰伯特在 1998 年重新发表论文 <span class=\"exturl\" data-url=\"aHR0cDovL2xhbXBvcnQuYXp1cmV3ZWJzaXRlcy5uZXQvcHVicy9sYW1wb3J0LXBheG9zLnBkZg==\">《The Part-Time Parliament》</span>。</p>\n<p>论文发表之后，各路学者直呼看不懂，言语中还略显调侃之意。这谁忍得了，在 2001 年的时候，兰伯特专门又写了一篇 <span class=\"exturl\" data-url=\"aHR0cDovL2xhbXBvcnQuYXp1cmV3ZWJzaXRlcy5uZXQvcHVicy9wYXhvcy1zaW1wbGUucGRm\">《Paxos Made Simple》</span> 的论文来简化对 Paxos 的介绍，主要讲述<font color='red'>两阶段共识协议</font>部分，顺便还不忘嘲讽一下这群学者。</p>\n<p>《Paxos Made Simple》这篇论文就 14 页，相比于 《The Part-Time Parliament》的 33 页精简了不少。最关键的是这篇论文的摘要就一句话：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/paxos-made-simple-L9ik01kM.png\" alt=\"img\" /></p>\n<blockquote>\n<p>The Paxos algorithm, when presented in plain English, is very simple.</p>\n</blockquote>\n<p>翻译过来的意思大概就是：<font color='red'>当我用无修饰的英文来描述时，Paxos 算法真心简单！</font></p>\n<p>有没有感觉到来自兰伯特大佬满满地嘲讽的味道？</p>\n<h2 id=\"介绍\"><a class=\"anchor\" href=\"#介绍\">#</a> 介绍</h2>\n<p>Paxos 算法是第一个被证明完备的分布式系统共识算法。共识算法的作用是 **<font color='red'>让分布式系统中的多个节点之间对某个提案（Proposal）达成一致的看法</font>**。提案的含义在分布式系统中十分宽泛，像哪一个节点是 Leader 节点、多个事件发生的顺序等等都可以是一个提案。</p>\n<p>兰伯特当时提出的 Paxos 算法主要包含 2 个部分:</p>\n<ul>\n<li><strong><font color='cornflowerblue'>Basic Paxos 算法</font></strong>：描述的是<font color='red'>多节点之间如何就某个值 (提案 Value) 达成共识</font>。</li>\n<li><strong><font color='cornflowerblue'>Multi-Paxos 思想</font></strong>：描述的是执行多个 Basic Paxos 实例，就一系列值达成共识。<font color='red'>Multi-Paxos 说白了就是执行多次 Basic Paxos </font>，核心还是 Basic Paxos 。</li>\n</ul>\n<p>由于 Paxos 算法在国际上被公认的非常难以理解和实现，因此不断有人尝试简化这一算法。到了 2013 年才诞生了<font color='red'>一个比 Paxos 算法更易理解和实现的共识算法 —<span class=\"exturl\" data-url=\"aHR0cHM6Ly9qYXZhZ3VpZGUuY24vZGlzdHJpYnV0ZWQtc3lzdGVtL3RoZW9yZW0mYW1wO2FsZ29yaXRobSZhbXA7cHJvdG9jb2wvcmFmdC1hbGdvcml0aG0uaHRtbA==\">Raft 算法</span></font> 。更具体点来说，<font color='red'>Raft 是 Multi-Paxos 的一个简化变种</font>，其简化了 Multi-Paxos 的思想，变得更容易被理解以及工程实现。</p>\n<p>针对没有恶意节点的情况，除了 Raft 算法之外，当前最常用的一些共识算法比如 <strong>ZAB 协议</strong>、 <strong>Fast Paxos</strong> 算法都是基于 Paxos 算法改进的。</p>\n<p>针对存在恶意节点的情况，一般使用的是 <strong>工作量证明（POW，Proof-of-Work）</strong>、 <strong>权益证明（PoS，Proof-of-Stake ）</strong> 等共识算法。这类共识算法最典型的应用就是<font color='red'>区块链</font>，就比如说前段时间以太坊官方宣布其共识机制正在从工作量证明 (PoW) 转变为权益证明 (PoS)。</p>\n<p>区块链系统使用的共识算法需要解决的核心问题是 **<font color='red'>拜占庭将军问题</font>** ，这和我们日常接触到的 ZooKeeper、Etcd、Consul 等分布式中间件不太一样。</p>\n<hr />\n<p>下面我们来对 Paxos 算法的定义做一个总结：</p>\n<ul>\n<li>Paxos 算法是兰伯特在 1990 年提出了一种分布式系统共识算法。</li>\n<li>兰伯特当时提出的 Paxos 算法主要包含 2 个部分: Basic Paxos 算法和 Multi-Paxos 思想。</li>\n<li><font color='red'>Raft 算法、ZAB 协议、 Fast Paxos 算法都是基于 Paxos 算法改进而来</font>。</li>\n</ul>\n<h2 id=\"basic-paxos-算法\"><a class=\"anchor\" href=\"#basic-paxos-算法\">#</a> Basic Paxos 算法</h2>\n<p>Basic Paxos 中存在 3 个重要的角色：</p>\n<ol>\n<li><strong><font color='cornflowerblue'>提议者（Proposer）</font></strong>：也可以叫做协调者（coordinator），提议者<font color='red'>负责接受客户端的请求，并发起提案</font>。提案信息通常包括提案编号 (Proposal ID) 、提议的值 (Value)。</li>\n<li><strong><font color='cornflowerblue'>接受者（Acceptor）</font></strong>：也可以叫做投票员（voter），<font color='red'>负责对提议者的提案进行投票，同时需要记住自己的投票历史</font>；</li>\n<li><strong><font color='cornflowerblue'>学习者（Learner）</font></strong>：<font color='red'>如果有超过半数接受者就某个提议达成了共识，那么学习者就需要接受这个提议，并就该提议作出运算，然后将运算结果返回给客户端</font>。</li>\n</ol>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/up-890fa3212e8bf72886a595a34654918486c.png\" alt=\"img\" /></p>\n<blockquote>\n<p>为了减少实现该算法所需的节点数，<font color='red'>一个节点可以身兼多个角色</font>。并且，一个提案被选定需要被半数以上的 Acceptor 接受。这样的话，Basic Paxos 算法还<font color='red'>具备容错性，在少于一半的节点出现故障时，集群仍能正常工作</font>。</p>\n</blockquote>\n<h2 id=\"multi-paxos-思想\"><a class=\"anchor\" href=\"#multi-paxos-思想\">#</a> Multi Paxos 思想</h2>\n<p>Basic Paxos 算法的仅能就单个值达成共识，为了能够对一系列的值达成共识，我们需要用到 Multi Paxos 思想。</p>\n<blockquote>\n<p>⚠️<strong>注意</strong>：Multi-Paxos 只是一种思想，这种思想的核心就是<font color='red'>通过多个 Basic Paxos 实例就一系列值达成共识</font>。也就是说，Basic Paxos 是 Multi-Paxos 思想的核心，Multi-Paxos 就是多执行几次 Basic Paxos。</p>\n</blockquote>\n<p>由于兰伯特提到的 Multi-Paxos 思想缺少代码实现的必要细节 (比如怎么选举领导者)，所以<font color='red'>在理解和实现上比较困难</font>。</p>\n<p>不过，也不需要担心，我们并不需要自己实现基于 Multi-Paxos 思想的共识算法，业界已经有了比较出名的实现。<font color='red'>像 Raft 算法就是 Multi-Paxos 的一个变种，其简化了 Multi-Paxos 的思想，变得更容易被理解以及工程实现，实际项目中可以优先考虑 Raft 算法</font>。</p>\n<h1 id=\"raft-算法详解\"><a class=\"anchor\" href=\"#raft-算法详解\">#</a> Raft 算法详解</h1>\n<h2 id=\"背景-2\"><a class=\"anchor\" href=\"#背景-2\">#</a> 背景</h2>\n<p>当今的数据中心和应用程序在高度动态的环境中运行，为了应对高度动态的环境，它们通过额外的服务器进行横向扩展，并且根据需求进行扩展和收缩。同时，服务器和网络故障也很常见。</p>\n<p>因此，<font color='red'>系统必须在正常操作期间处理服务器的上下线。它们必须对变故做出反应并在几秒钟内自动适应</font>；对客户来说的话，明显的中断通常是不可接受的。</p>\n<p>幸运的是，<font color='red'>分布式共识</font>可以帮助应对这些挑战。</p>\n<h3 id=\"拜占庭将军问题\"><a class=\"anchor\" href=\"#拜占庭将军问题\">#</a> 拜占庭将军问题</h3>\n<p>在介绍共识算法之前，先介绍一个简化版拜占庭将军的例子来帮助理解共识算法。</p>\n<blockquote>\n<p>假设多位拜占庭将军中没有叛军，信使的信息可靠但有可能被暗杀的情况下，将军们如何达成是否要进攻的一致性决定？</p>\n</blockquote>\n<p>解决方案大致可以理解成：<font color='red'>先在所有的将军中选出一个大将军，用来做出所有的决定</font>。</p>\n<p>举例如下：假如现在一共有 3 个将军 A，B 和 C，每个将军都有一个随机时间的倒计时器。</p>\n<ol>\n<li>假设 A 将军的倒计时先结束，这个将军就把自己当成大将军候选人，然后派信使传递选举投票的信息给将军 B 和 C；</li>\n<li>如果将军 B 和 C 还没有把自己当作候选人（自己的倒计时还没有结束），并且没有把选举票投给其他人，它们就会把票投给将军 A；</li>\n<li>信使回到将军 A 时，它知道自己收到了足够的票数，成为了大将军，此后是否需要进攻就由大将军 A 决定；</li>\n<li>然后 A 将军再去派信使通知另外两个将军，自己已经成为了大将军。如果一段时间还没收到将军 B 和 C 的回复（信使可能会被暗杀），那就再重派一个信使，直到收到回复。</li>\n</ol>\n<h3 id=\"共识算法\"><a class=\"anchor\" href=\"#共识算法\">#</a> 共识算法</h3>\n<p>共识是可容错系统中的一个基本问题：<strong><font color='red'>即使面对故障，服务器也可以在共享状态上达成一致</font></strong>。</p>\n<p>共识算法允许<font color='red'>一组节点像一个整体一样一起工作，即使其中的一些节点出现故障也能够继续工作下去</font>，其正确性主要是源于复制状态机的性质：一组  <code>Server</code>  的状态机计算相同状态的副本，即使有一部分的  <code>Server</code>  宕机了，它们仍然能够继续运行。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/paxos-rsm-architecture.png\" alt=\"rsm-architecture.png\" /></p>\n<center>复制状态机架构</center>\n<p>一般通过使用<font color='red'>复制日志</font>来实现复制状态机。每个  <code>Server</code>  存储着一份包括命令序列的日志文件，状态机会按顺序执行这些命令。因为每个日志包含相同的命令，并且顺序也相同，所以每个状态机处理相同的命令序列。由于状态机是确定性的，所以处理相同的状态，得到相同的输出。</p>\n<p>因此，<font color='red'>共识算法的工作就是保持复制日志的一致性</font>。服务器上的共识模块从客户端接收命令并将它们添加到日志中。它与其他服务器上的共识模块通信，以确保即使某些服务器发生故障。每个日志最终包含相同顺序的请求。一旦命令被正确地复制，它们就被称为已提交。每个服务器的状态机按照日志顺序处理已提交的命令，并将输出返回给客户端。因此，这些服务器形成了一个单一的、高度可靠的状态机。</p>\n<p>适用于实际系统的共识算法通常具有以下特性：</p>\n<ul>\n<li>安全。确保在非拜占庭条件（也就是上文中提到的简易版拜占庭）下的安全性，包括网络延迟、分区、包丢失、复制和重新排序。</li>\n<li>高可用。只要大多数服务器都是可操作的，并且可以相互通信，也可以与客户端进行通信，那么这些服务器就可以看作完全功能可用的。因此，一个典型的由五台服务器组成的集群可以容忍任何两台服务器端故障。假设服务器因停止而发生故障；它们稍后可能会从稳定存储上的状态中恢复并重新加入集群。</li>\n<li>一致性不依赖时序。错误的时钟和极端的消息延迟，在最坏的情况下也只会造成可用性问题，而不会产生一致性问题。</li>\n<li>在集群中大多数服务器响应，命令就可以完成，不会被少数运行缓慢的服务器来影响整体系统性能。</li>\n</ul>\n<h2 id=\"raft-算法基础\"><a class=\"anchor\" href=\"#raft-算法基础\">#</a> Raft 算法基础</h2>\n<p>Raft 算法是一种 **<font color='#B32015'>通过对日志复制管理来达到集群节点一致性</font>** 的算法。这个日志复制管理发生在集群节点中的 Leader 与 Followers 之间。<font color='red'>Raft 通过选举出的 Leader 节点负责管理日志复制过程，以实现各个节点间数据的一致性</font>。</p>\n<h3 id=\"节点类型\"><a class=\"anchor\" href=\"#节点类型\">#</a> 节点类型</h3>\n<p>一个 Raft 集群包括若干服务器，在任意的时间，每个服务器一定会处于以下<font color='red'>三个状态</font>中的一个：</p>\n<ul>\n<li><code>Leader</code> ：负责发起心跳；响应客户端的读写请求；创建、同步（复制）日志；</li>\n<li><code>Candidate</code> ：Leader 选举的候选人，由 Follower 转化而来；发起投票参与竞选；</li>\n<li><code>Follower</code> ：可以处理客户端的读请求；接受 Leader 的心跳；同步来自于 Leader 的日志；当接收到其它 Candidate 的投票请求后，可以进行投票；当 Leader 挂了后，会转变为 Candidate 发起 Leader 选举；</li>\n</ul>\n<p>在正常的情况下，只有一个服务器是 Leader，剩下的服务器是 Follower。Follower 是被动的，它们不会发送任何请求，只是响应来自 Leader 和 Candidate 的请求。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/paxos-server-state.png\" alt=\"img\" /></p>\n<h3 id=\"任期term\"><a class=\"anchor\" href=\"#任期term\">#</a> 任期（term）</h3>\n<p>如下图所示，<font color='red'>raft 算法将时间划分为任意长度的任期（term），任期用连续的数字表示，看作当前 term 号</font>。</p>\n<ul>\n<li>每一个任期的开始都是一次选举，在选举开始时，一个或多个 Candidate 会尝试成为 Leader。</li>\n<li>如果一个 Candidate 赢得了选举，它就会在该任期内担任 Leader。</li>\n<li>如果没有选出 Leader，将会开启另一个任期，并立刻开始下一次选举。【t3】</li>\n<li><font color='red'>raft 算法保证在给定的一个任期最少要有一个 Leader</font>。</li>\n</ul>\n<p>任期规则：</p>\n<ul>\n<li>每个节点都会存储当前的 term 号，当服务器之间进行通信时会交换当前的 term 号；</li>\n<li>如果有服务器发现自己的 term 号比其他人小，那么他会更新到较大的 term 值；</li>\n<li>如果一个 Candidate 或者 Leader 发现自己的 term 过期了，他会立即退回成 Follower；</li>\n<li>如果一台服务器收到的请求的 term 号是过期的，那么它会拒绝此次请求；</li>\n</ul>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/paxos-term.png\" alt=\"img\" /></p>\n<h3 id=\"日志\"><a class=\"anchor\" href=\"#日志\">#</a> 日志</h3>\n<ul>\n<li>\n<p><code>entry</code>  ：每一个事件成为 entry，只有 Leader 可以创建 entry。entry 的内容为  <code>&lt;term,index,cmd&gt;</code>  其中 cmd 是可以应用到状态机的操作。</p>\n</li>\n<li>\n<p><code>log</code>  ：<font color='red'>由 entry 构成的数组</font>，每一个 entry 都有一个表明自己在 log 中的 index。只有 Leader 才可以改变其他节点的 log。entry 总是先被 Leader 添加到自己的 log 数组中，然后再发起共识请求，获得同意后才会被 Leader 提交给状态机。Follower 只能从 Leader 获取新日志和当前的 commitIndex，然后把对应的 entry 应用到自己的状态机中。</p>\n</li>\n</ul>\n<h2 id=\"leader-选举\"><a class=\"anchor\" href=\"#leader-选举\">#</a> <mark>🌟Leader 选举</mark></h2>\n<p>Raft 算法使用<font color='red'>心跳机制</font>来触发集群中 Leader 的选举。</p>\n<p>如果一台服务器能够收到来自 Leader 或者 Candidate 的有效信息，那么它会一直保持为 Follower 状态，并且刷新自己的 electionElapsed（选举已用时间），重新计时。</p>\n<p>Leader 会向所有的 Follower 周期性发送心跳来保证自己的 Leader 地位。<font color='red'>如果一个 Follower 在一个心跳超时周期内没有收到 Leader 的心跳信息，则认为 Leader 挂了，这叫做<strong>选举超时</strong></font>。</p>\n<p>为了开始新的选举，Follower 会自增自己的 term 号，并且转换状态为 Candidate。然后他会向所有节点发起 RequestVoteRPC 请求， Candidate 的状态会持续到以下情况发生：</p>\n<ul>\n<li>\n<p><font color='gree'>该节点赢得选举</font>。条件是该 Candidate <font color='red'>在一个任期内，收到了来自集群内的多数选票 <code>（N/2+1）</code> </font>，它就可以成为 Leader。然后会将消息广播给所有其它节点，通知大家我是新的 Leader 了。</p>\n</li>\n<li>\n<p><font color='gree'>其他节点赢得选举</font>。在该 Candidate 等待选票的时候，它可能<font color='red'>收到其他节点声明自己是 Leader 的心跳</font>，此时有两种情况：</p>\n<ul>\n<li><font color='red'>对方的 term 号 ≥ 自己的 term 号，说明对方已经成为 Leader，则自己回退为 Follower</font> 。</li>\n<li>对方的 term 号 ＜ 自己的 term 号，那么会拒绝该请求，并让对方节点更新 term 。</li>\n</ul>\n</li>\n<li>\n<p><font color='gree'>一轮选举结束无人胜出，重新选举</font>。由于可能<font color='red'>同一时刻出现多个 Candidate，导致没有 Candidate 获得大多数选票（即：没有收到过半选票，也没有收到新 Leader 通知）</font>。如果没有其他手段来重新分配选票的话，那么可能会无限重复下去。</p>\n<blockquote>\n<p>raft 使用了 **<font color='red'>随机的选举超时时间</font>**（ <code>randomized election timeouts   </code> ）来避免上述情况。<font color='red'>其会为这些 Follower 随机分配一个选举发起时间 election timeout，只有到达了 election timeout 时间的 Follower 才能转变为 candidate，否则等待</font>。那么 election timeout 较小的 Follower 则会转变为 candidate 然后先发起选举，一般情况下其会优先获取到过半选票成为新的 leader。</p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"日志复制数据同步\"><a class=\"anchor\" href=\"#日志复制数据同步\">#</a> 日志复制（数据同步）</h2>\n<p>一旦选出了 Leader，它就开始接受客户端的请求。<font color='red'>每一个客户端的请求都包含一条需要被复制状态机（ <code>Replicated State Machine</code> ）执行的命令</font>。</p>\n<ol>\n<li>\n<p>Leader 收到客户端请求后，会生成一个 entry，包含 <code>&lt;index,term,cmd&gt;</code> 。将这个 entry 添加到自己的日志末尾后，<font color='red'>向所有的节点广播该 entry，要求其他服务器复制这条 entry</font>。</p>\n</li>\n<li>\n<p><font color='red'>如果 Follower 接受该 entry，则会将 entry 添加到自己的日志后面</font>，同时返回给 Leader 同意。</p>\n</li>\n<li>\n<p>如果 Leader 收到了多数的成功响应，<font color='red'>Leader 会将这个 entry 应用到自己的状态机中</font>，之后可以认为这个 entry 是 committed 的，并且向客户端返回执行结果。</p>\n</li>\n</ol>\n<p>raft 保证以下两个性质：</p>\n<ul>\n<li>在两个日志里，有两个 entry 拥有相同的 index 和 term，那么它们一定有相同的 cmd</li>\n<li>在两个日志里，有两个 entry 拥有相同的 index 和 term，那么它们前面的 entry 也一定相同</li>\n</ul>\n<blockquote>\n<p>通过 “仅有 Leader 可以生成 entry” 来保证第一个性质，第二个性质需要 **<font color='red'>一致性检查</font>** 来进行保证。</p>\n</blockquote>\n<p>一般情况下，Leader 和 Follower 的日志保持一致，然后，Leader 的崩溃会导致日志不一样，这样一致性检查会产生失败。<font color='red'>Leader 通过强制 Follower 复制自己的日志来处理日志的不一致</font>。这就意味着，在 Follower 上的冲突日志会被 Leader 的日志覆盖。为了使得 Follower 的日志和 Leader 的日志一致，Leader 需要找到 Follower 与它日志一致的地方，然后删除 Follower 在该位置之后的日志，接着把 Leader 自己在这之后的日志发送给 Follower。</p>\n<p><font color='red'>Leader 给每一个 Follower 维护了一个  <code>nextIndex</code> ，它表示 Leader 将要发送给该 Follower 的下一条日志条目的索引</font>。当一个 Leader 开始掌权时，它会将  <code>nextIndex</code>  初始化为它的最新的日志条目索引数 + 1。如果一个 Follower 的日志和 Leader 的不一致， <code>AppendEntries</code>  一致性检查会在下一次  <code>AppendEntries RPC</code>  时返回失败。在失败之后，Leader 会将  <code>nextIndex</code>  递减然后重试  <code>AppendEntries RPC</code> 。<font color='red'>最终  <code>nextIndex</code>  会达到一个 Leader 和 Follower 日志一致的地方</font>。这时， <code>AppendEntries</code>  会返回成功，Follower 中冲突的日志条目都被移除了，并且添加所缺少的上了 Leader 的日志条目。<font color='red'>一旦  <code>AppendEntries</code>  返回成功，Follower 和 Leader 的日志就一致了，这样的状态会保持到该任期结束</font>。</p>\n<h2 id=\"leader-宕机处理\"><a class=\"anchor\" href=\"#leader-宕机处理\">#</a> Leader 宕机处理</h2>\n<h3 id=\"请求到达前-leader-挂了\"><a class=\"anchor\" href=\"#请求到达前-leader-挂了\">#</a> 请求到达前 Leader 挂了</h3>\n<p>Leader 在 client 发送写操作请求到达之前就挂了，因为请求还没有到达集群，所以这个请求对于集群来说就没有存在过，<font color='red'>对集群数据的一致性没有任何影响</font>。Leader 挂了之后，<font color='red'>会选举产生新的 Leader</font>。</p>\n<p>由于 Stale Leader （旧领导）并未向 client 发送成功处理响应，所以<font color='red'> client 会重新发送该写操作请求</font>。</p>\n<h3 id=\"未开始同步数据前-leader-挂了\"><a class=\"anchor\" href=\"#未开始同步数据前-leader-挂了\">#</a> 未开始同步数据前 Leader 挂了</h3>\n<p>client 发送写操作请求给 Leader，请求到达 Leader 后，Leader 还没有开始向 Followers 发出数据就挂了。这时集群会<font color='red'>选举产生新的 Leader</font>。<font color='red'>Stale Leader 重启后会作为 Follower 重新加入集群，并同步新 Leader 中的数据以保证数据一致性</font>。之前接收到 client 的数据被丢弃。</p>\n<p>由于 Stale Leader 并未向 client 发送成功处理响应，所以<font color='red'> client 会重新发送该写操作请求</font>。</p>\n<h3 id=\"同步完部分后-leader-挂了\"><a class=\"anchor\" href=\"#同步完部分后-leader-挂了\">#</a> 同步完部分后 Leader 挂了</h3>\n<p>client 发送写操作请求给 Leader，Leader 接收完数据后向所有 Follower 发送数据。在部分 Follower 接收到数据后 Leader 挂了。由于 Leader 挂了，就<font color='red'>会发起新的 Leader 选举</font>。</p>\n<ul>\n<li><font color='gree'>若 Leader 产生于已完成数据接收的 Follower</font>，其会继续将前面接收到的写操作请求转换为日志，并写入到本地状态机，并向所有 Flollower 发出询问。在获取过半同意响应后会向所有 Followers 发送 commit 指令，同时向 client 进行响应。</li>\n<li><font color='gree'>若 Leader 产生于尚未完成数据接收的 Follower</font>，那么原来已完成接收的 Follower 则会放弃曾接收到的数据。由于 client 没有接收到响应，所以 client 会重新发送该写操作请求。</li>\n</ul>\n<h3 id=\"commit-通知发出后-leader-挂了\"><a class=\"anchor\" href=\"#commit-通知发出后-leader-挂了\">#</a> commit 通知发出后 Leader 挂了</h3>\n<p>client 发送写操作请求给 Leader， Leader 也成功向所有 Followers 发出的 commit 指令，并向 client 发出响应后，Leader 挂了。</p>\n<p>由于 Stale Leader 已经向 client 发送成功接收响应，且 commit 通知已经发出，说明<font color='red'>这个写操作请求已经被 server 成功处理</font>。</p>\n<h2 id=\"安全性\"><a class=\"anchor\" href=\"#安全性\">#</a> 安全性</h2>\n<h3 id=\"选举限制\"><a class=\"anchor\" href=\"#选举限制\">#</a> 选举限制</h3>\n<p><font color='red'>Leader 需要保证自己存储全部已经提交的日志条目</font>。这样才可以使日志条目只有一个流向：从 Leader 流向 Follower，Leader 永远不会覆盖已经存在的日志条目。</p>\n<p><font color='red'>每个 Candidate 发送 RequestVoteRPC 时，都会带上最后一个 entry 的信息。所有节点收到投票信息时，会对该 entry 进行比较，<strong>如果发现自己的日志更新，则拒绝投票给该 Candidate</strong></font>。</p>\n<blockquote>\n<p>判断日志新旧的方式：</p>\n<ul>\n<li>如果两个日志的 term 不同，term 大的更新</li>\n<li>如果 term 相同，更长的 index 更新</li>\n</ul>\n</blockquote>\n<h3 id=\"节点崩溃\"><a class=\"anchor\" href=\"#节点崩溃\">#</a> 节点崩溃</h3>\n<p>如果 Leader 崩溃，集群中的节点在 electionTimeout 时间内没有收到 Leader 的心跳信息就会触发新一轮的 Leader 选举，<strong><font color='red'>在 Leader 选举期间，整个集群对外是不可用的</font></strong>。</p>\n<p>如果 Follower 和 Candidate 崩溃，处理方式会简单很多。之后发送给它的 RequestVoteRPC 和 AppendEntriesRPC 会失败。由于 raft 的所有请求都是幂等的，所以失败的话会无限的重试。如果崩溃恢复后，就可以收到新的请求，然后选择追加或者拒绝 entry。</p>\n<h3 id=\"时间与可用性\"><a class=\"anchor\" href=\"#时间与可用性\">#</a> 时间与可用性</h3>\n<p>raft 的要求之一就是<font color='red'>安全性不依赖于时间：系统不能仅仅因为一些事件发生的比预想的快一些或者慢一些就产生错误</font>。为了保证上述要求，最好能满足以下的时间条件：</p>\n<pre><code>broadcastTime &lt;&lt; electionTimeout &lt;&lt; MTBF\n</code></pre>\n<ul>\n<li><code>broadcastTime</code> ：向其他节点并发发送消息的平均响应时间；</li>\n<li><code>electionTimeout</code> ：选举超时时间；</li>\n<li><code>MTBF(mean time between failures)</code> ：单台机器的平均健康时间；</li>\n</ul>\n<p><code>broadcastTime</code>  应该比 <code>electionTimeout</code>  小一个数量级，为的是使 <code>Leader</code>  能够持续发送心跳信息（heartbeat）来阻止 <code>Follower</code>  开始选举；</p>\n<p><code>electionTimeout</code>  也要比 <code>MTBF</code>  小几个数量级，为的是使得系统稳定运行。当 <code>Leader</code>  崩溃时，大约会在整个 <code>electionTimeout</code>  的时间内不可用；我们希望这种情况仅占全部时间的很小一部分。</p>\n<p>由于 <code>broadcastTime</code>  和 <code>MTBF</code>  是由系统决定的属性，因此需要决定 <code>electionTimeout</code>  的时间。</p>\n<p>一般来说，broadcastTime 一般为  <code>0.5～20ms</code> ，electionTimeout 可以设置为  <code>10～500ms</code> ，MTBF 一般为一两个月。</p>\n<h2 id=\"动画演示\"><a class=\"anchor\" href=\"#动画演示\">#</a> 动画演示</h2>\n<blockquote>\n<p><span class=\"exturl\" data-url=\"aHR0cDovL3RoZXNlY3JldGxpdmVzb2ZkYXRhLmNvbS9yYWZ0Lw==\">http://thesecretlivesofdata.com/raft/</span></p>\n</blockquote>\n<h3 id=\"raft-概述\"><a class=\"anchor\" href=\"#raft-概述\">#</a> raft 概述</h3>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231218145626883.png\" alt=\"image-20231218145626883\" /></p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231218145641429.png\" alt=\"image-20231218145641429\" /></p>\n<h3 id=\"leader-选举-2\"><a class=\"anchor\" href=\"#leader-选举-2\">#</a> Leader 选举</h3>\n<p>在 Raft 中，有两个控制选举的超时设置：</p>\n<ul>\n<li><font color='cornflowerblue'> <code>election timeout</code> （选举超时）</font>：表示 Follower 等待转变为 Candidate 的倒计时间，随机设置在 150ms ~ 300ms 之间。某个 Follower 率先选举超时后，它成为 Candidate，开始新的选举任期（term 加 1），并为自己投一票，同时向其他节点发送请求投票的消息。如果接收节点在本任期内尚未投票，那么它将投票给 Candidate。</li>\n<li><font color='cornflowerblue'> <code>heartbeat timeout</code> （心跳超时）</font>：</li>\n</ul>\n<hr />\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231218110127195.png\" alt=\"image-20231218110127195\" /></p>\n<center>【<font color='cornflowerblue'>election timeout（选举超时）</font></font>表示 Follower 等待转变为 Candidate 的倒计时间，随机设置在 150ms ~ 300ms 之间。】</center>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231218142116228.png\" alt=\"image-20231218142116228\" /></p>\n<center>【某个 Follower 率先选举超时后，它成为 Candidate，开始新的选举任期（term 加1），并为自己投一票】</center>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231218142238093.png\" alt=\"image-20231218142238093\" /></p>\n<center>【同时 Candidate 向其他节点发送请求投票的消息】</center>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231218142326741.png\" alt=\"image-20231218142326741\" /></p>\n<center>【如果接收节点在本任期内尚未投票，那么它将投票给 Candidate】</center>\n<center>【节点重置其选举超时】</center>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231218143246476.png\" alt=\"image-20231218143246476\" /></p>\n<center>【一旦 Candidate 获得多数票，他就会成为 Leader】</center>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231218143321866.png\" alt=\"image-20231218143321866\" /></p>\n<center>【Leader 开始向其 Follower 周期性地发送 Append Entries 消息。这些消息按照<font color='cornflowerblue'> heartbeat timeout（心跳超时）</font></font>指定的时间间隔发送。】</center>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231218143548477.png\" alt=\"image-20231218143548477\" /></p>\n<center>【然后 Followers 回复每条 Append Entries 消息。】</center>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231218144001221.png\" alt=\"image-20231218144001221\" /></p>\n<center>【这个选举 term 将持续到某个 Follower 停止接收心跳，并成为 Candidate 为止。让我们阻止 Leader 并观看重新选举的发生。】</center>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231218144043076.png\" alt=\"image-20231218144043076\" /></p>\n<center>【节点 B 现在是第 2 个 term 的 Leader。需要多数票才能保证每个任期只能选举一名领导人。如果两个节点同时成为候选人，则可能会发生<font color='red'>分裂投票</font></font>。】</center>\n<hr />\n<p>分裂投票的例子：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231218144355618.png\" alt=\"image-20231218144355618\" /></p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231218144415586.png\" alt=\"image-20231218144415586\" /></p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231218144428586.png\" alt=\"image-20231218144428586\" /></p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231218144443566.png\" alt=\"image-20231218144443566\" /></p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231218144459719.png\" alt=\"image-20231218144459719\" /></p>\n<h3 id=\"日志复制\"><a class=\"anchor\" href=\"#日志复制\">#</a> 日志复制</h3>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231218144528293.png\" alt=\"image-20231218144528293\" /></p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231218144543849.png\" alt=\"image-20231218144543849\" /></p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231218144606513.png\" alt=\"image-20231218144606513\" /></p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231218144617130.png\" alt=\"image-20231218144617130\" /></p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231218144634196.png\" alt=\"image-20231218144634196\" /></p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231218144648281.png\" alt=\"image-20231218144648281\" /></p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231218144657566.png\" alt=\"image-20231218144657566\" /></p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231218144711183.png\" alt=\"image-20231218144711183\" /></p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231218144727919.png\" alt=\"image-20231218144727919\" /></p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231218144744496.png\" alt=\"image-20231218144744496\" /></p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231218144802996.png\" alt=\"image-20231218144802996\" /></p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231218144841610.png\" alt=\"image-20231218144841610\" /></p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231218144911945.png\" alt=\"image-20231218144911945\" /></p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231218144924949.png\" alt=\"image-20231218144924949\" /></p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231218144938649.png\" alt=\"image-20231218144938649\" /></p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231218144957469.png\" alt=\"image-20231218144957469\" /></p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231218145013862.png\" alt=\"image-20231218145013862\" /></p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231218145026793.png\" alt=\"image-20231218145026793\" /></p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231218145349524.png\" alt=\"image-20231218145349524\" /></p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231218145426830.png\" alt=\"image-20231218145426830\" /></p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231218145447316.png\" alt=\"image-20231218145447316\" /></p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231218145505919.png\" alt=\"image-20231218145505919\" /></p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231218145519321.png\" alt=\"image-20231218145519321\" /></p>\n<h1 id=\"gossip-协议详解\"><a class=\"anchor\" href=\"#gossip-协议详解\">#</a> Gossip 协议详解</h1>\n<blockquote>\n<p>gossip：闲话、流言蜚语</p>\n</blockquote>\n<h2 id=\"背景-3\"><a class=\"anchor\" href=\"#背景-3\">#</a> 背景</h2>\n<p>在分布式系统中，不同的节点进行数据 / 信息共享是一个基本的需求。</p>\n<p>一种比较简单粗暴的方法就是<strong>集中式发散消息</strong>，简单来说就是<font color='red'>一个主节点同时共享最新信息给其他所有节点</font>，比较适合中心化系统。这种方法的缺陷也很明显，节点多的时候不光<font color='red'>同步消息的效率低，还太依赖与中心节点，存在单点风险问题</font>。</p>\n<p>于是，<strong>分散式发散消息</strong>的 <strong><font color='cornflowerblue'>Gossip 协议</font></strong> 就诞生了。</p>\n<h2 id=\"介绍-2\"><a class=\"anchor\" href=\"#介绍-2\">#</a> 介绍</h2>\n<p>Gossip 协议 也叫 Epidemic 协议（流行病协议）或者 Epidemic propagation 算法（疫情传播算法），别名很多。不过这些名字的特点都具有 **<font color='red'>随机传播特性</font>**（联想一下病毒传播、癌细胞扩散等生活中常见的情景），这也正是 Gossip 协议最主要的特点。</p>\n<p>Gossip 协议最早是在 ACM 上的一篇 1987 年发表的论文 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9kbC5hY20ub3JnL2RvaS8xMC4xMTQ1LzQxODQwLjQxODQx\">《Epidemic Algorithms for Replicated Database Maintenance》</span>中被提出的。根据论文标题，我们大概就能知道 Gossip 协议当时提出的主要应用是在<font color='red'>分布式数据库系统中各个副本节点同步数据</font>。</p>\n<p>正如 Gossip 协议其名一样，这是<font color='red'>一种随机且带有传染性的方式，将信息传播到整个网络中，并在一定时间内，使得系统内的所有节点数据一致</font>。</p>\n<p>在 Gossip 协议下，<font color='red'>没有所谓的中心节点，每个节点周期性地随机找一个节点互相同步彼此的信息</font>，理论上来说，各个节点的状态最终会保持一致。</p>\n<p>下面我们来对 Gossip 协议的定义做一个总结：<strong><font color='#B32015'>Gossip 协议是一种允许在分布式系统中共享状态的去中心化通信协议，通过这种通信协议，我们可以将信息传播给网络或集群中的所有成员。</font></strong></p>\n<h2 id=\"应用\"><a class=\"anchor\" href=\"#应用\">#</a> 应用</h2>\n<p>NoSQL 数据库 Redis 和 Apache Cassandra、服务网格解决方案 Consul 等知名项目都用到了 Gossip 协议，学习 Gossip 协议有助于我们搞清很多技术的底层原理。</p>\n<p>我们这里以 <font color='gree'>Redis Cluster</font> 为例说明 Gossip 协议的实际应用。</p>\n<p>我们经常使用的分布式缓存 Redis 的官方集群解决方案（3.0 版本引入） Redis Cluster 就是<font color='red'>基于 Gossip 协议来实现集群中各个节点数据的最终一致性</font>。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/up-fcacc1eefca6e51354a5f1fc9f2919f51ec.png\" alt=\"Redis 的官方集群解决方案\" /></p>\n<center>Redis 的官方集群解决方案</center>\n<p>Redis Cluster 是一个典型的分布式系统，分布式系统中的各个节点需要互相通信。既然要相互通信就要遵循一致的通信协议，<font color='red'>Redis Cluster 中的各个节点基于 <strong>Gossip 协议</strong> 来进行通信共享信息，每个 Redis 节点都维护了一份集群的状态信息</font>。</p>\n<p>Redis Cluster 的节点之间会相互发送多种 Gossip 消息：</p>\n<ul>\n<li><strong><font color='cornflowerblue'>MEET</font></strong>：在 Redis Cluster 中的某个 Redis 节点上执行  <code>CLUSTER MEET ip port</code>  命令，<font color='red'>可以向指定的 Redis 节点发送一条 MEET 信息，用于将其添加进 Redis Cluster 成为新的 Redis 节点</font>。</li>\n<li><strong><font color='cornflowerblue'>PING/PONG</font></strong>：Redis Cluster 中的节点都会<font color='red'>定时地向其他节点发送 PING 消息，来交换各个节点状态信息，检查各个节点状态</font>，包括在线状态、疑似下线状态 PFAIL 和已下线状态 FAIL。</li>\n<li><strong><font color='cornflowerblue'>FAIL</font></strong>：Redis Cluster 中的节点 A 发现 B 节点 PFAIL，并且在下线报告的有效期限内集群中半数以上的节点将 B 节点标记为 PFAIL，节点 A 就会向集群广播一条 FAIL 消息，通知其他节点将故障节点 B 标记为 FAIL 。</li>\n<li>……</li>\n</ul>\n<p>下图就是主从架构的 Redis Cluster 的示意图，图中的虚线代表的就是各个节点之间使用 Gossip 进行通信 ，实线表示主从复制。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/redis-cluster-gossip-fO4qDqt2.png\" alt=\"img\" /></p>\n<p>有了 Redis Cluster 之后，不需要专门部署 Sentinel 集群服务了。<strong><font color='red'>Redis Cluster 相当于是内置了 Sentinel 机制，内部的各个节点通过 Gossip 协议互相探测健康状态，在故障时可以自动切换</font></strong>。</p>\n<h2 id=\"消息传播模式\"><a class=\"anchor\" href=\"#消息传播模式\">#</a> 消息传播模式</h2>\n<p>Gossip 设计了两种可能的消息传播模式：<strong>反熵（Anti-Entropy）</strong> 和 <strong>传谣（Rumor-Mongering）</strong>。</p>\n<h3 id=\"反熵anti-entropy\"><a class=\"anchor\" href=\"#反熵anti-entropy\">#</a> 反熵（Anti-Entropy）</h3>\n<p>根据维基百科：</p>\n<blockquote>\n<p>熵的概念最早起源于<span class=\"exturl\" data-url=\"aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU3JTg5JUE5JUU3JTkwJTg2JUU1JUFEJUE2\">物理学</span>，用于度量一个热力学系统的混乱程度。熵最好理解为<font color='red'>不确定性的量度</font>，而不是确定性的量度，因为越随机的信源的熵越大。</p>\n</blockquote>\n<p>在这里，你可以把反熵中的熵理解为节点之间数据的混乱程度 / 差异性，<font color='red'>反熵就是指消除不同节点中数据的差异，提升节点间数据的相似度，从而降低熵值</font>。</p>\n<p>具体是如何反熵的呢？<font color='red'>集群中的节点，每隔段时间就随机选择某个其他节点，然后通过互相交换自己的所有数据，来消除两者之间的差异，实现数据的最终一致性</font>。</p>\n<p>在实现反熵的时候，主要有推、拉和推拉三种方式：</p>\n<ul>\n<li>推：就是将自己的所有副本数据，推给对方，修复对方副本中的熵。</li>\n<li>拉：就是拉取对方的所有副本数据，修复自己副本中的熵。</li>\n<li>推拉：就是同时修复自己副本和对方副本中的熵。</li>\n</ul>\n<p>伪代码如下：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/up-df16e98bf71e872a7e1f01ca31cee93d77b.png\" alt=\"反熵伪代码\" /></p>\n<p>在我们实际应用场景中，<font color='red'>一般不会采用随机的节点进行反熵</font>，而是需要可以的设计一个闭环。这样的话，我们能够在一个确定的时间范围内实现各个节点数据的最终一致性，而不是基于随机的概率。像  <code>InfluxDB</code>  就是这样来实现反熵的。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/%E5%8F%8D%E7%86%B5-%E9%97%AD%E7%8E%AF-TwBsP6eP.png\" alt=\"img\" /></p>\n<ol>\n<li>节点 A 推送数据给节点 B，节点 B 获取到节点 A 中的最新数据。</li>\n<li>节点 B 推送数据给 C，节点 C 获取到节点 A，B 中的最新数据。</li>\n<li>节点 C 推送数据给 A，节点 A 获取到节点 B，C 中的最新数据。</li>\n<li>节点 A 再推送数据给 B 形成闭环，这样节点 B 就获取到节点 C 中的最新数据。</li>\n</ol>\n<p>虽然反熵很简单实用，<font color='red'>但是节点过多或者节点动态变化的话，反熵就不太适用了</font>。这个时候，我们想要实现最终一致性就要靠 传谣 (Rumor mongering) 。</p>\n<h3 id=\"传谣rumor-mongering\"><a class=\"anchor\" href=\"#传谣rumor-mongering\">#</a> 传谣（Rumor-Mongering）</h3>\n<p>谣言传播指的是分布式系统中的一个节点一旦有了新数据之后，就会变为活跃节点，活跃节点会周期性地联系其他节点向其发送新数据，直到所有的节点都存储了该新数据。</p>\n<p>如下图所示（下图来自于<span class=\"exturl\" data-url=\"aHR0cHM6Ly9tYW5hZ2VtZW50ZnJvbXNjcmF0Y2gud29yZHByZXNzLmNvbS8yMDE2LzA0LzAxL2ludHJvZHVjdGlvbi10by1nb3NzaXAv\"> INTRODUCTION TO GOSSIP</span> 这篇文章）：</p>\n<p>伪代码如下：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/20210605170707933.png\" alt=\"img\" /></p>\n<p>谣言传播比较适合节点数量比较多的情况，不过，这种模式下<font color='red'>要尽量避免传播的信息包不能太大，避免网络消耗太大</font>。</p>\n<h3 id=\"小结-3\"><a class=\"anchor\" href=\"#小结-3\">#</a> 小结</h3>\n<ul>\n<li>\n<p>反熵（Anti-Entropy）会传播节点的所有数据，而谣言传播（Rumor-Mongering）只会传播节点新增的数据。</p>\n</li>\n<li>\n<p>一般会给反熵设计一个闭环。</p>\n</li>\n<li>\n<p>谣言传播（Rumor-Mongering）比较适合节点数量比较多或者节点动态变化的场景。</p>\n</li>\n</ul>\n<h2 id=\"优缺点\"><a class=\"anchor\" href=\"#优缺点\">#</a> 优缺点</h2>\n<p><strong>优势：</strong></p>\n<p>1、相比于其他分布式协议 / 算法来说，<font color='red'>Gossip 协议理解起来非常简单</font>。</p>\n<p>2、能够容忍网络上节点的随意地增加或者减少，宕机或者重启，因为 Gossip 协议下这些<font color='red'>节点都是平等的，去中心化的</font>。新增加或者重启的节点在理想情况下最终是一定会和其他节点的状态达到一致。</p>\n<p>3、<font color='red'>速度相对较快</font>。节点数量比较多的情况下，扩散速度比一个主节点向其他节点传播信息要更快（多播）。</p>\n<p><strong>缺陷</strong> :</p>\n<p>1、消息需要通过多个传播的轮次才能传播到整个网络中，因此，<font color='red'>必然会出现各节点状态不一致的情况</font>。毕竟，Gossip 协议强调的是最终一致，至于达到各个节点的状态一致需要多长时间，谁也无从得知。</p>\n<p>2、由于拜占庭将军问题，<font color='red'>不允许存在恶意节点</font>。</p>\n<p>3、可能会出现<font color='red'>消息冗余</font>的问题。由于消息传播的随机性，同一个节点可能会重复收到相同的消息。</p>\n<h2 id=\"总结\"><a class=\"anchor\" href=\"#总结\">#</a> 总结</h2>\n<ul>\n<li>\n<p>Gossip 协议是一种<font color='red'>允许在分布式系统中共享状态</font>的通信协议，通过这种通信协议，我们可以将信息传播给网络或集群中的所有成员。</p>\n</li>\n<li>\n<p>Gossip 协议被 Redis、Apache Cassandra、Consul 等项目应用。</p>\n</li>\n<li>\n<p>谣言传播（Rumor-Mongering）比较适合节点数量比较多或者节点动态变化的场景</p>\n</li>\n</ul>\n",
            "tags": [
                "分布式微服务"
            ]
        },
        {
            "id": "http://example.com/photography/%E6%95%85%E5%AE%AB%E9%9B%AA%E6%99%AF/",
            "url": "http://example.com/photography/%E6%95%85%E5%AE%AB%E9%9B%AA%E6%99%AF/",
            "title": "故宫雪景",
            "date_published": "2023-12-13T16:00:00.000Z",
            "content_html": "<p><img data-src=\"https://pic.imgdb.cn/item/657b2e7bc458853aef44253b.jpg\" alt=\"\" /><br />\n<img data-src=\"https://pic.imgdb.cn/item/657b2f71c458853aef4833c3.jpg\" alt=\"\" /></p>\n<p><img data-src=\"https://pic.imgdb.cn/item/657b2f9cc458853aef48dd81.jpg\" alt=\"\" height=\"700px\" /></p>\n<p><img data-src=\"https://pic.imgdb.cn/item/657b3842c458853aef69a74d.jpg\" alt=\"\" /></p>\n<p><img data-src=\"https://pic.imgdb.cn/item/657b2fe1c458853aef4a0229.jpg\" alt=\"\" height=\"700px\" /></p>\n<p><img data-src=\"https://pic.imgdb.cn/item/657b301ec458853aef4b1989.jpg\" alt=\"\" height=\"700px\" /></p>\n<p><img data-src=\"https://pic.imgdb.cn/item/657b30a0c458853aef4d2cdd.jpg\" alt=\"\" height=\"700px\" /></p>\n<p><img data-src=\"https://pic.imgdb.cn/item/657b3433c458853aef5b2a28.jpg\" alt=\"\" height=\"700px\" /></p>\n<p><img data-src=\"https://pic.imgdb.cn/item/657b30efc458853aef4e8321.jpg\" alt=\"\" height=\"700px\" /></p>\n<p><img data-src=\"https://pic.imgdb.cn/item/657b3380c458853aef58a96f.jpg\" alt=\"\" /></p>\n<p><img data-src=\"https://pic.imgdb.cn/item/657b33c1c458853aef59833b.jpg\" alt=\"\" /></p>\n<p><img data-src=\"https://pic.imgdb.cn/item/657b33e6c458853aef5a136f.jpg\" alt=\"\" height=\"700px\" /></p>\n<p><img data-src=\"https://pic.imgdb.cn/item/657b3486c458853aef5c3243.jpg\" alt=\"\" /></p>\n<p><img data-src=\"https://pic.imgdb.cn/item/657b34c2c458853aef5d1fa7.jpg\" alt=\"\" /></p>\n<p><img data-src=\"https://pic.imgdb.cn/item/657b3536c458853aef5ec5bc.jpg\" alt=\"\" height=\"700px\" /></p>\n<p><img data-src=\"https://pic.imgdb.cn/item/657b3570c458853aef5fb89f.jpg\" alt=\"\" height=\"700px\" /></p>\n<p><img data-src=\"https://pic.imgdb.cn/item/657b3571c458853aef5fbdad.jpg\" alt=\"\" /></p>\n<p><img data-src=\"https://pic.imgdb.cn/item/657b3571c458853aef5fbbf1.jpg\" alt=\"\" height=\"700px\" /></p>\n<p><img data-src=\"https://pic.imgdb.cn/item/657b3570c458853aef5fbaa4.jpg\" alt=\"\" height=\"700px\" /></p>\n<p><img data-src=\"https://pic.imgdb.cn/item/657b3570c458853aef5fb9a7.jpg\" alt=\"\" /></p>\n<p><img data-src=\"https://pic.imgdb.cn/item/657b3649c458853aef62aa57.jpg\" alt=\"\" height=\"700px\" /></p>\n<p><img data-src=\"https://pic.imgdb.cn/item/657b3648c458853aef62a962.jpg\" alt=\"\" height=\"700px\" /></p>\n<p><img data-src=\"https://pic.imgdb.cn/item/657b3648c458853aef62a8b6.jpg\" alt=\"\" /></p>\n<p><img data-src=\"https://pic.imgdb.cn/item/657b3648c458853aef62a821.jpg\" alt=\"\" /></p>\n<p><img data-src=\"https://pic.imgdb.cn/item/657b3648c458853aef62a77b.jpg\" alt=\"\" height=\"700px\" /></p>\n<p><img data-src=\"https://pic.imgdb.cn/item/657b36aec458853aef6420a6.jpg\" alt=\"\" height=\"700px\" /></p>\n<p><img data-src=\"https://pic.imgdb.cn/item/657b36efc458853aef650fe3.jpg\" alt=\"\" /></p>\n<p><img data-src=\"https://pic.imgdb.cn/item/657b36edc458853aef650c52.jpg\" alt=\"\" /></p>\n<p><img data-src=\"https://pic.imgdb.cn/item/657b36edc458853aef650b88.jpg\" alt=\"\" /></p>\n<p><img data-src=\"https://pic.imgdb.cn/item/657b36ecc458853aef650a34.jpg\" alt=\"\" /></p>\n<p><img data-src=\"https://pic.imgdb.cn/item/657b36eec458853aef650e56.jpg\" alt=\"\" height=\"700px\" /></p>\n<p><img data-src=\"https://pic.imgdb.cn/item/657b3803c458853aef68dfd7.jpg\" alt=\"\" height=\"700px\" /></p>\n<p><img data-src=\"https://pic.imgdb.cn/item/657b3843c458853aef69a8d7.jpg\" alt=\"\" /></p>\n<p><img data-src=\"https://pic.imgdb.cn/item/657b3842c458853aef69a646.jpg\" alt=\"\" /></p>\n<p><img data-src=\"https://pic.imgdb.cn/item/657b3842c458853aef69a581.jpg\" alt=\"\" /></p>\n<p><img data-src=\"https://pic.imgdb.cn/item/657b3935c458853aef6ce27d.jpg\" alt=\"\" height=\"700px\" /></p>\n<p><img data-src=\"https://pic.imgdb.cn/item/657b3842c458853aef69a4b4.jpg\" alt=\"\" height=\"700px\" /></p>\n<p><img data-src=\"https://pic.imgdb.cn/item/657b3935c458853aef6ce387.jpg\" alt=\"\" /></p>\n<p><img data-src=\"https://pic.imgdb.cn/item/657b3935c458853aef6ce43a.jpg\" alt=\"\" /></p>\n<p><img data-src=\"https://pic.imgdb.cn/item/657b3935c458853aef6ce316.jpg\" alt=\"\" height=\"700px\" /></p>\n",
            "tags": [
                "摄影"
            ]
        },
        {
            "id": "http://example.com/photography/%E4%B8%AD%E6%B3%95%E5%A4%A7%E5%AD%A6%E6%97%A7%E5%9D%80&%E5%8C%97%E6%B5%B7%E5%85%AC%E5%9B%AD/",
            "url": "http://example.com/photography/%E4%B8%AD%E6%B3%95%E5%A4%A7%E5%AD%A6%E6%97%A7%E5%9D%80&%E5%8C%97%E6%B5%B7%E5%85%AC%E5%9B%AD/",
            "title": "京秋的胶片味",
            "date_published": "2023-12-03T02:40:32.059Z",
            "content_html": "<p><img data-src=\"https://pic.imgdb.cn/item/656f27bac458853aef5f729f.jpg\" alt=\"\" /><br />\n<img data-src=\"https://pic.imgdb.cn/item/656f2724c458853aef5c162b.jpg\" alt=\"\" /></p>\n<p><img data-src=\"https://pic.imgdb.cn/item/656f27b9c458853aef5f7159.jpg\" alt=\"\" height=\"700px\" /></p>\n<p><img data-src=\"https://pic.imgdb.cn/item/656f2723c458853aef5c1132.jpg\" alt=\"\" /></p>\n<p><img data-src=\"https://pic.imgdb.cn/item/656f2722c458853aef5c0e99.jpg\" alt=\"\" title=\"树影斑驳\" /></p>\n<p><img data-src=\"https://pic.imgdb.cn/item/656f2723c458853aef5c1279.jpg\" alt=\"\" title=\"在光里\" /></p>\n<p><img data-src=\"https://pic.imgdb.cn/item/656f2723c458853aef5c1476.jpg\" alt=\"\" title=\"日落北海\" /></p>\n",
            "tags": [
                "摄影"
            ]
        },
        {
            "id": "http://example.com/database/redis/%E5%B0%9A%E7%A1%85%E8%B0%B7-%E5%91%A8%E9%98%B3-Redis7/",
            "url": "http://example.com/database/redis/%E5%B0%9A%E7%A1%85%E8%B0%B7-%E5%91%A8%E9%98%B3-Redis7/",
            "title": "Redis7-尚硅谷-周阳",
            "date_published": "2023-12-01T08:11:24.031Z",
            "content_html": "<h1 id=\"入门篇\"><a class=\"anchor\" href=\"#入门篇\">#</a> 入门篇</h1>\n<h2 id=\"1-redis入门概述\"><a class=\"anchor\" href=\"#1-redis入门概述\">#</a> 1、Redis 入门概述</h2>\n<h3 id=\"redis是什么\"><a class=\"anchor\" href=\"#redis是什么\">#</a> Redis 是什么</h3>\n<p>Redis： <code>RE</code> mote  <code>Di</code> ctionary  <code>S</code> erver（远程字典服务器），一种基于<strong> Key-Value</strong> 的<strong>内存</strong>数据库。</p>\n<p>Remote Dictionary Server (远程字典服务) 是完全开源的，使用<font color='red'>ANSIC 语言</font>编写遵守 BSD 协议，是一个高性能的<font color='red'>Key-Value</font>数据库提供了丰富的数据结构，例如 String、Hash、List、Set、SortedSet 等等。数据是存在<font color='red'>内存中的</font>，同时 Redis<font color='red'>支持事务、持久化、LUA 脚本、发布 / 订阅、缓存淘汰、流技术等</font>多种功能特性提供了<font color='red'>主从模式</font>、<font color='red'>Redis Sentinel</font>和<font color='red'>Redis Cluster 集群架构</font>方案。</p>\n<h3 id=\"redis的功能与优势\"><a class=\"anchor\" href=\"#redis的功能与优势\">#</a> Redis 的功能与优势</h3>\n<p>Redis 的主流功能与应用如下：</p>\n<ul>\n<li>\n<p><strong><font color='orange'>分布式缓存</font></strong>，帮 MySQL 减负</p>\n<blockquote>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230802153755454.png\" alt=\"image-20230802153755454\" /></p>\n<p>MySQL 与 Redis 的对比：</p>\n<ul>\n<li>MySQL 是关系型数据库，Redis 是<font color='red'>key-value</font>数据库（NoSQL 的一种）</li>\n<li>MySQL 主要存储在磁盘，Redis 数据操作主要在<font color='red'>内存</font></li>\n<li>Redis 在一些场景中明显优于 MySQL，例如计数器、排行榜等</li>\n<li>Redis 通常用于一些特定场景，需要与 Mysql 一起配合使用，两者并不是相互替换和竞争关系，而是共用和<strong>配合使用</strong></li>\n</ul>\n</blockquote>\n</li>\n<li>\n<p><strong>内存存储</strong>和<strong>持久化</strong>（RDB+AOF）：Redis 支持异步将内存中的数据写到硬盘上，同时不影响继续服务</p>\n</li>\n<li>\n<p><strong>高可用架构搭配</strong>：避免某台 Redis 挂了后，影响系统运行</p>\n<ul>\n<li>单机</li>\n<li>主从</li>\n<li>哨兵</li>\n<li>集群</li>\n</ul>\n</li>\n<li>\n<p>缓存穿透、击穿、雪崩</p>\n</li>\n<li>\n<p><strong>分布式锁</strong>：跨服务器加锁</p>\n</li>\n<li>\n<p><strong>消息队列平台</strong>：Reids<font color='red'>提供 list 和 set 操作</font>，这使得 Redis 能作为一个很好的消息队列平台来使用。</p>\n<blockquote>\n<p>通过 Reids 的队列功能做<strong>购买限制</strong>。比如到节假日或者推广期间，进行一些活动，对用户购买行为进行限制，限制今天只能购买几次商品或者一段时间内只能购买一次。</p>\n</blockquote>\n</li>\n<li>\n<p><strong>排行榜</strong> +<strong> 点赞</strong>：Redis 提供的<font color='red'>zset 数据类型</font>能够快速实现这些复杂的排行榜。</p>\n</li>\n</ul>\n<p>Redis 的总体功能概览图：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230802154814479.png\" alt=\"image-20230802154814479\" /></p>\n<p>Redis 的优势：</p>\n<ul>\n<li><strong>读写性能极高</strong></li>\n<li><strong>数据类型丰富</strong>：不仅支持<font color='red'>key-value</font>类型的数据，同时还提供<font color='red'>list，set，zset，hash</font>等数据结构的存储</li>\n<li><strong>支持数据持久化</strong>：可将内存中的数据存入磁盘中，重启时再加载到内存使用</li>\n<li><strong>支持数据备份</strong>，即 master-slave 模式的数据备份</li>\n</ul>\n<p>小结：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230802155434366.png\" alt=\"image-20230802155434366\" /></p>\n<h3 id=\"redis下载\"><a class=\"anchor\" href=\"#redis下载\">#</a> Redis 下载</h3>\n<p>英文官网：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9yZWRpcy5pby8=\">https://redis.io/</span></p>\n<p>中文网站：<span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5yZWRpcy5jbi8=\">http://www.redis.cn/</span></p>\n<p>下载网站：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb3dubG9hZC5yZWRpcy5pby9yZWxlYXNlcy8=\">https://download.redis.io/releases/</span></p>\n<p>中文文档：<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cucmVkaXMuY29tLmNuL2RvY3VtZW50YXRpb24uaHRtbA==\">https://www.redis.com.cn/documentation.html</span></p>\n<p>Redis 源码网站：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3JlZGlzL3JlZGlz\">https://github.com/redis/redis</span></p>\n<p>Redis 在线测试：<span class=\"exturl\" data-url=\"aHR0cHM6Ly90cnkucmVkaXMuaW8v\">https://try.redis.io/</span></p>\n<p>Redis 命令参考：<span class=\"exturl\" data-url=\"aHR0cDovL2RvYy5yZWRpc2ZhbnMuY29tLw==\">http://doc.redisfans.com/</span></p>\n<h3 id=\"redis怎么玩\"><a class=\"anchor\" href=\"#redis怎么玩\">#</a> Redis 怎么玩</h3>\n<ul>\n<li>多种数据类型基本操作和配置</li>\n<li>持久化和复制，RDB/AOF</li>\n<li>事务的控制</li>\n<li>复制，集群等</li>\n</ul>\n<h3 id=\"redis的迭代历史\"><a class=\"anchor\" href=\"#redis的迭代历史\">#</a> Redis 的迭代历史</h3>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230802161140294.png\" alt=\"image-20230802161140294\" /></p>\n<center>Redis重要版本</center>\n<p><font color='red'>5.0 版本</font>是直接升级到<font color='red'>6.0 版本</font>，对于这个激进的升级，Redis 之父 antirez 表现得很有信心和兴奋，所以第一时间发文来阐述 6.0 的一些重大功能 &quot;Redis 6.0.0 GA is out!&quot;</p>\n<p>随后 Redis 再接再厉，直接王炸<font color='red'>Redis7.0</font>---2023 年爆款。2022 年 4 月 27 日 Redis 正式发布了 7.0 更新（其实早在 2022 年 1 月 31 日，Redis 已经预发布了 7.0rc-1，经过社区的考验后，确认没重大 Bug 才会正式发布）</p>\n<p>Redis<strong> 版本的命名规则</strong>：</p>\n<ul>\n<li>版本号第二位如果是奇数，则为非稳定版本。如 2.7、2.9、3.1</li>\n<li>版本号第二位如果是偶数，则为稳定版本。如 2.6、2.8、3.0、3.2</li>\n<li>当前奇数版本就是下一个稳定版本的开发版本。如 2.9 版本是 3.0 版本的开发版本</li>\n</ul>\n<h3 id=\"redis7的新特性\"><a class=\"anchor\" href=\"#redis7的新特性\">#</a> Redis7 的新特性</h3>\n<p>可以从 redis 的 GitHub 的 releases 中查看当前版本的新特性，Redis7 的部分新特性总览：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230802162007264.png\" alt=\"image-20230802162007264\" /></p>\n<ul>\n<li>\n<p>Redis Functions：Redis 函数，一种新的通过服务端脚本扩展 Redis 的方式，函数与数据本身一起存储。简言之，redis 自己要去<font color='red'>抢夺 Lua 脚本的饭碗</font>，但是 Lua 已经稳定且普及，所以 Redis Functions<font color='red'>没必要学</font></p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230802162230304.png\" alt=\"image-20230802162230304\" /></p>\n</li>\n<li>\n<p><strong>Client-eviction</strong>：客户端相关优化，能让更多 client 连接上</p>\n<p><font color='red'>限制客户端内存使用</font>，一旦 Redis 连接较多，再加上每个连接的内存占用都比较大的时候，Redis 总连接内存占用可能会达到 maxmemory 的上限，可以增加允许限制所有客户端的总内存使用量配置项，redis.config 中对应的配置项，有两种配置形式：</p>\n<ul>\n<li><font color='red'>指定内存大小</font>。例如 maxmemory-clients 1g</li>\n<li><font color='red'>基于 maxmemory 的百分比</font>。例如 maxmemory-clients 10%</li>\n</ul>\n<img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230802162439869.png\" alt=\"image-20230802162439869\" style=\"zoom:80%;\" />\n</li>\n<li>\n<p><strong>Multi-part AOF</strong>：多 AOF 文件支持，AOF 文件由一个变成了多个，主要分为两种类型：<font color='red'>基本文件 (base files)</font>、<font color='red'>增量文件 (incr files)</font>，请注意这些文件名称是复数形式说明每一类文件不仅仅只有一个。在此之外还引入了一个<font color='red'>清单文件 (manifest) </font>用于跟踪文件以及文件的创建和应用顺序（恢复）。性能急剧上升，再也不用担心 AOFRW 异步读写时的运维痛点</p>\n<img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230802163004405.png\" alt=\"image-20230802163004405\" style=\"zoom:80%;\" />\n</li>\n<li>\n<p><strong>config 命令增强</strong>：对于<font color='red'>Config Set 和 Get 命令</font>，支持在一次调用过程中<font color='red'>传递多个配置参数</font>。例如，现在我们可以在执行一次 Config Set 命令中更改多个参数： config set maxmemory 10000001 maxmemory-clients 50% port 6399</p>\n</li>\n<li>\n<p><strong>访问安全性增强 ACL V2</strong>：访问控制，在 redis.conf 配置文件中，<font color='red'>protected-mode 默认为 yes</font>，只有当你希望你的客户端在没有授权的情况下可以连接到 Redis server 的时候可以将 protected-mode 设置为 no</p>\n<img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230802163118585.png\" alt=\"image-20230802163118585\" style=\"zoom:80%;\" />\n</li>\n<li>\n<p><strong>listpack 紧凑列表调整</strong>：listpack 是用来<font color='red'>替代 ziplist 的新数据结构</font>，在 7.0 版本已经没有 ziplist 的配置了（6.0 版本仅部分数据类型作为过渡阶段在使用），listpack 已经替换了 ziplist 类似 hash-max-ziplist-entries 的配置</p>\n</li>\n<li>\n<p>RDB 保存时间调整：将持久化文件 RDB 的保存规则发生了改变，尤其是时间记录频度变化</p>\n</li>\n<li>\n<p>命令新增和变动：</p>\n<ul>\n<li>Zset (有序集合) 增加 ZMPOP、BZMPOP、ZINTERCARD 等命令</li>\n<li>Set (集合) 增加 SINTERCARD 命令</li>\n<li>LIST (列表) 增加 LMPOP、BLMPOP ，从提供的键名列表中的第一个非空列表键中弹出一个或多个元素</li>\n</ul>\n</li>\n<li>\n<p><strong>性能资源利用率、安全、等改进</strong>：自身<font color='red'>底层部分优化</font>改动，Redis 核心在许多方面进行了重构和改进</p>\n<ul>\n<li><font color='red'>主动碎片整理 V2</font>：增强版主动碎片整理，配合 Jemalloc 版本更新，更快更智能，延时更低</li>\n<li><font color='red'>HyperLogLog 改进</font>：在 Redis5.0 中，HyperLogLog 算法得到改进，优化了计数统计时的内存使用效率，7 更加优秀</li>\n<li><font color='red'>更好的内存统计报告</font></li>\n<li>如果不为了 API 向后兼容，我们将<font color='red'>不再使用 slave 一词</font>......(政治正确)</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"2-redis安装与配置\"><a class=\"anchor\" href=\"#2-redis安装与配置\">#</a> 2、Redis 安装与配置</h2>\n<p>Redis 一般在<strong> Linux 环境</strong>上使用，那么就有两种方式：</p>\n<ul>\n<li>购买云服务器</li>\n<li>VMWare 本地虚拟机</li>\n</ul>\n<p>需要确保 Linux 是 64 位的，命令 <code>getconf LONG_BIT</code></p>\n<h3 id=\"linux环境需要gcc编译环境\"><a class=\"anchor\" href=\"#linux环境需要gcc编译环境\">#</a> Linux 环境需要 gcc 编译环境</h3>\n<p>安装 gcc： <code>yum -y install gcc-c++</code></p>\n<p>查看 gcc 版本： <code>gcc -v</code></p>\n<h3 id=\"redis7安装步骤\"><a class=\"anchor\" href=\"#redis7安装步骤\">#</a> Redis7 安装步骤</h3>\n<p>至少 6.0.8 以上，本次使用 Redis7.0</p>\n<p>具体安装流程看脑图。</p>\n<h2 id=\"3-redis的10种数据类型\"><a class=\"anchor\" href=\"#3-redis的10种数据类型\">#</a> <mark>3、Redis 的 10 种数据类型</mark></h2>\n<blockquote>\n<p>前文已声明过 Redis 是基于 Key-Value 的，而<strong> key 类型一般是 String</strong>，这里所介绍的<strong> 10 种数据类型指的是 value 的数据类型</strong>。</p>\n</blockquote>\n<h3 id=\"10种数据类型value\"><a class=\"anchor\" href=\"#10种数据类型value\">#</a> 10 种数据类型 (value)</h3>\n<img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230803183405953.png\" alt=\"image-20230803183405953\" style=\"zoom:67%;\" />\n<ul>\n<li>\n<p><strong>字符串（String）</strong>：60% 的场景，常用</p>\n<ul>\n<li>String 是 redis<font color='red'>最基本的类型</font>，一个 key 对应一个 value。</li>\n<li>String 类型是<font color='orange'>二进制安全</font>的，意思是 redis 的 String<font color='red'>可以包含任何数据</font>，比如<font color='red'>jpg 图片</font>或者<font color='red'>序列化的对象</font>。</li>\n<li>String 类型是 Redis 最基本的数据类型，一个 redis 中<font color='red'>字符串 value 最多可以是 512M</font></li>\n</ul>\n</li>\n<li>\n<p><strong>列表（List）</strong>：</p>\n<ul>\n<li>Redis 列表是简单的<font color='red'>字符串列表</font>，<font color='red'>按照插入顺序排序</font>。你可以添加一个元素到列表的<font color='red'>头部（左边）</font>或者<font color='red'>尾部（右边）</font></li>\n<li>它的底层实际是个<font color='orange'>双端链表</font>，最多可以包含<font color='red'> 2<sup>32</sup> - 1 </font>个元素 (4294967295, 每个列表超过 40 亿个元素)</li>\n</ul>\n</li>\n<li>\n<p><strong>哈希集（Hash）</strong>：</p>\n<ul>\n<li>Redis hash 是一个 String 类型的<font color='orange'> field（字段） 和 value（值） 的映射表</font>，hash 特别适合用于<font color='red'>存储对象</font>。</li>\n<li>Redis 中每个 hash 可以存储<font color='red'> 2<sup>32</sup> - 1 键值对</font>（40 多亿）</li>\n</ul>\n</li>\n<li>\n<p><strong>集合（Set）</strong>：</p>\n<ul>\n<li>Redis 的 Set 是 String 类型的<font color='orange'>无序集合</font>。集合成员是唯一的，这就意味着集合中的元素<font color='red'>不能重复</font>，集合对象的<font color='red'>编码可以是 intset 或者 hashtable</font>。</li>\n<li>Redis 中 Set 集合是<font color='red'>通过哈希集实现</font>的，所以添加，删除，查找的复杂度都是 O (1)。</li>\n<li>集合中<font color='red'>最大的成员数为 2<sup>32</sup> - 1</font> (4294967295, 每个集合可存储 40 多亿个成员)</li>\n</ul>\n</li>\n<li>\n<p><strong>有序集合（ZSet）</strong>：即上图中的 Sorted Set</p>\n<ul>\n<li>Redis zset 和 set 一样也是 string 类型元素的集合，且<font color='red'>不允许重复</font>的成员</li>\n<li>不同的是<font color='orange'>每个元素都会关联一个 double 类型的分数</font>，redis 正是通过分数来为集合中的成员进行从小到大的排序。</li>\n<li>zset 的<font color='red'>成员是唯一的，但分数 (score) 却可以重复</font>。</li>\n<li>zset 集合是<font color='red'>通过哈希集实现</font>的，所以添加，删除，查找的复杂度都是 O (1)。 集合中<font color='red'>最大的成员数为 2<sup>32</sup> - 1</font></li>\n</ul>\n</li>\n<li>\n<p><strong>地理空间（GEO）</strong>：即<font color='red'>经纬度</font></p>\n<ul>\n<li>Redis GEO 主要用于<font color='orange'>存储地理位置信息</font>，并对存储的信息进行操作，包括\n<ul>\n<li>添加地理位置的坐标。</li>\n<li>获取地理位置的坐标。</li>\n<li>计算两个位置之间的距离。</li>\n<li>根据用户给定的经纬度坐标来获取指定范围内的地理位置集合</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>基数统计（HyperLogLog）</strong>：<font color='red'>基数指的是不重复的数字</font>，例如统计网站的访问量</p>\n<ul>\n<li>HyperLoglog 是<font color='orange'>一种估计集合基数的数据结构</font>，作为<font color='red'>一种概率数据结构</font>，HyperLoglog 为有效的空间利用率提供了完美的精度。</li>\n<li>HyperLogLog 实现<font color='red'>最多使用 12 KB</font>，并<font color='red'>提供 0.81% 的标准错误</font>。</li>\n<li>HyperLogLog 是用来<font color='orange'>做基数统计的算法</font>，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，<font color='red'>计算基数所需的空间总是固定，且很小</font></li>\n<li>在 Redis 里面，每个 HyperLogLog 键<font color='red'>只需要花费 12 KB 内存，就可以计算接近 2<sup>64</sup> 个不同元素的基数</font>。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。</li>\n<li>但是，因为 HyperLogLog <font color='red'>只会根据输入元素来计算基数，而不会储存输入元素本身</font>，所以 HyperLogLog <font color='red'>不能像集合那样，返回输入的各个元素</font>。</li>\n</ul>\n</li>\n<li>\n<p><strong>位图（bitmap）</strong>：例如每日签到，是否点赞</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230803185955581.png\" alt=\"image-20230803185955581\" /></p>\n<ul>\n<li>由<font color='orange'>0 和 1</font>状态表现二进制位的<font color='orange'>bit 数组</font></li>\n</ul>\n</li>\n<li>\n<p><strong>位域（bitfield）</strong>：</p>\n<ul>\n<li>通过 bitfield 命令可以一次性操作多个比特位域 (指的是<font color='orange'>连续的多个比特位</font>)，它会执行一系列操作并返回一个响应数组，这个数组中的元素对应参数列表中的相应操作的执行结果。</li>\n<li>说白了就是<font color='red'>通过 bitfield 命令我们可以一次性对多个比特位域进行操作</font>。</li>\n</ul>\n</li>\n<li>\n<p><strong>流（Stream）</strong>：Redis 自己的<font color='red'>消息（队列）中间件</font>，但还是不如别人的好</p>\n<ul>\n<li>Redis Stream 是 Redis <font color='red'>5.0 版本新增加</font>的数据结构。</li>\n<li>Redis Stream 主要<font color='orange'>用于消息队列（MQ，Message Queue）</font>，Redis 本身是有一个 Redis 发布订阅 (pub/sub) 来实现消息队列的功能，但它有个缺点就是消息无法持久化，如果出现网络断开、Redis 宕机等，消息就会被丢弃。</li>\n<li>简单来说<font color='red'>发布订阅 (pub/sub) 可以分发消息，但无法记录历史消息</font>。</li>\n<li>而 Redis Stream 提供了<font color='red'>消息的持久化</font>和<font color='red'>主备复制</font>功能，可以让任何客户端访问任何时刻的数据，并且能记住每一个客户端的访问位置，还能<font color='red'>保证消息不丢失</font></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"常见数据类型的操作命令手册\"><a class=\"anchor\" href=\"#常见数据类型的操作命令手册\">#</a> 常见数据类型的操作命令手册</h3>\n<p>英文官网：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9yZWRpcy5pby9jb21tYW5kcy8=\">https://redis.io/commands/</span></p>\n<p>中文官网：<span class=\"exturl\" data-url=\"aHR0cDovL3JlZGlzLmNuL2NvbW1hbmRzLmh0bWw=\">http://redis.cn/commands.html</span></p>\n<h3 id=\"key相关的操作命令\"><a class=\"anchor\" href=\"#key相关的操作命令\">#</a> key 相关的操作命令</h3>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230803191631855.png\" alt=\"image-20230803191631855\" /></p>\n<ul>\n<li>\n<p><strong> <code>KEYS *</code> </strong>：查看当前库所有的 key</p>\n</li>\n<li>\n<p><strong> <code>EXISTS key</code> </strong>：判断某个 key 是否存在</p>\n</li>\n<li>\n<p><strong> <code>TYPE key</code> </strong>：查看某个 key 的<strong> value 的数据类型</strong></p>\n</li>\n<li>\n<p><strong> <code>DEL key</code> </strong>：删除某个 key 数据</p>\n</li>\n<li>\n<p><strong> <code>UNLINK key</code> </strong>：非阻塞删除某个 key，仅仅将 key 从 keyspace 元数据中删除，真正的删除会在后续异步中操作。</p>\n</li>\n<li>\n<p><strong> <code>TTL key</code> </strong>：查看某个 key 还有多少秒过期，-1 表示永不过期，-2 表示已过期</p>\n</li>\n<li>\n<p><strong> <code>EXPIRE key 秒钟</code> </strong>：设置某个 key 的过期时间，默认 - 1 表示永不过期。</p>\n<blockquote>\n<p>Redis 的过期时间设置有四种形式：</p>\n<p>・EXPIRE 秒 —— 设置指定的过期时间 (秒)，表示的是时间间隔。</p>\n<p>・PEXPIRE 毫秒 —— 设置指定的过期时间，以毫秒为单位，表示的是时间间隔。</p>\n<p>・EXPIREAT 时间戳 - 秒 —— 设置指定的 Key 过期的 Unix 时间，单位为秒，表示的是时间 / 时刻。</p>\n<p>・PEXPIREAT 时间戳 - 毫秒 —— 设置指定的 Key 到期的 Unix 时间，以毫秒为单位，表示的是时间 / 时刻。</p>\n<p>expire key seconds [NX|XX|GT|LT]</p>\n</blockquote>\n</li>\n<li>\n<p><code>MOVE key dbindex[0-15]</code> ：将当前数据库中的某个 key 剪切到指定的数据库 db 中</p>\n</li>\n<li>\n<p><code>SELECT dbindex</code> ：切换到指定的数据库 [0-15]，默认为 0</p>\n</li>\n<li>\n<p><code>DBSIZE</code> ：查看当前数据库的 key 数量</p>\n</li>\n<li>\n<p><code>FLUSHDB</code> ：清空当前库</p>\n</li>\n<li>\n<p><code>FLUSHALL</code> ：通杀全部库</p>\n</li>\n</ul>\n<h3 id=\"value数据类型相关的操作命令\"><a class=\"anchor\" href=\"#value数据类型相关的操作命令\">#</a> value 数据类型相关的操作命令</h3>\n<blockquote>\n<ul>\n<li><font color='orange'>命令是不区分大小写的，但是 key 是区分大小写的</font></li>\n<li>帮助命令： <code>HELP @数据类型</code></li>\n</ul>\n</blockquote>\n<h4 id=\"字符串string\"><a class=\"anchor\" href=\"#字符串string\">#</a> 字符串（String）</h4>\n<blockquote>\n<p>单 key 单 value，最常用</p>\n</blockquote>\n<h5 id=\"命令概览\"><a class=\"anchor\" href=\"#命令概览\">#</a> 命令概览</h5>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230803204957896.png\" alt=\"image-20230803204957896\" /></p>\n<h5 id=\"设置获取单个键值\"><a class=\"anchor\" href=\"#设置获取单个键值\">#</a> 设置 / 获取单个键值</h5>\n<ul>\n<li>\n<p><strong> <code>SET key value</code> </strong>：将键 <code>key</code>  设定为指定的 “字符串” <code>value</code>  值。</p>\n<ul>\n<li>如果  <code>key</code>  已经保存了一个值，那么这个操作会直接覆盖原来的值，并且忽略原始类型。</li>\n<li>当 <code>set</code>  命令执行成功之后，之前设置的过期时间都将失效，除非设置了 <code>KEEPTTL</code>  参数。</li>\n<li>返回值： <code>simple-string-reply</code> ：如果 <code>SET</code>  命令正常执行那么回返回 <code>OK</code> ，否则如果加了  <code>NX</code>  或者  <code>XX</code>  选项，但是没有设置条件。那么会返回 <code>nil</code> 。</li>\n<li>时间复杂度： <code>O(1)</code></li>\n</ul>\n<blockquote>\n<p>完整的命令是： <code>set key value [NX|XX] [GET] [EX seconds|PX milliseconds|EXAT unix-time-seconds|PXAT unix-time-milliseconds|KEEPTTL]</code></p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230804102328872.png\" alt=\"image-20230804102328872\" /></p>\n<p>如何获得设置指定的 Key 过期的 Unix 时间，单位为秒：</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Long</span><span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span><span class=\"token function\">currentTimeMillis</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">/</span><span class=\"token number\">1000L</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure></blockquote>\n</li>\n<li>\n<p><strong> <code>GET key</code> </strong>：返回 <code>key</code>  的 <code>value</code> 。</p>\n<ul>\n<li>如果 <code>key</code>  不存在，返回特殊值 <code>nil</code> 。</li>\n<li>如果 <code>key</code>  的 <code>value</code>  不是 string，就返回错误，因为 <code>GET</code>  只处理 string 类型的 <code>values</code> 。</li>\n<li>时间复杂度： <code>O(1)</code></li>\n</ul>\n</li>\n</ul>\n<h5 id=\"设置获取多个键值\"><a class=\"anchor\" href=\"#设置获取多个键值\">#</a> 设置 / 获取多个键值</h5>\n<ul>\n<li>\n<p><strong> <code>MSET key value [key value ...]</code> </strong>：对应给定的 keys 到他们相应的 values 上。</p>\n<ul>\n<li><code>MSET</code>  会<font color='red'>用新的 value 覆盖旧的</font>，就像普通的 <code>SET</code>  命令一样。如果你不想覆盖已经存在的 values，请参看命令 <code>MSETNX</code> 。</li>\n<li><code>MSET</code>  是<font color='red'>原子的</font>，所以所有给定的 keys 是一次性 set 的。客户端不可能看到这种一部分 keys 被更新而另外的没有改变的情况。</li>\n<li>返回值： <code>simple-string-reply</code> ：<font color='red'>总是 OK</font>，因为 MSET 不会失败。</li>\n<li>时间复杂度： <code>O(N)</code> ，其中 N 是要设置的 key 的数量。</li>\n</ul>\n</li>\n<li>\n<p><strong> <code>MGET key [key ...]</code> </strong>：返回所有指定的 <code>key</code>  的 <code>value</code> 。</p>\n<ul>\n<li>对于每个不对应 string 或者不存在的 key，都返回特殊值 <code>nil</code> 。正因为此，<font color='red'>这个操作从来不会失败</font>。</li>\n<li>返回值： <code>array-reply</code> : 指定的 key 对应的 values 的 list</li>\n<li>时间复杂度： <code>O(N)</code> ，其中 N 是要查询的 key 的数量。</li>\n</ul>\n</li>\n<li>\n<p><strong> <code>MSETNX key value [key value ...]</code> </strong>：对应给定的 keys 到他们相应的 values 上，但是只要有一个 key 已经存在， <code>MSETNX</code>  一个操作都不会执行。</p>\n<ul>\n<li>由于这种特性， <code>MSETNX</code>  可以实现<font color='red'>要么所有的操作都成功，要么一个都不执行</font>，这样可以用来设置不同的 key，来表示一个唯一的对象的不同字段。</li>\n<li><code>MSETNX</code>  是<font color='red'>原子的</font>，所以所有给定的 keys 是一次性 set 的。客户端不可能看到这种一部分 keys 被更新而另外的没有改变的情况。</li>\n<li>返回值： <code>integer-reply</code> ，只有以下两种值：\n<ul>\n<li>1 如果所有的 key 被 set</li>\n<li>0 如果没有 key 被 set (至少其中有一个 key 是存在的)</li>\n</ul>\n</li>\n<li>时间复杂度： <code>O(N)</code> ，其中 N 是要设置的 key 的数量。</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"获取指定区间范围内的值\"><a class=\"anchor\" href=\"#获取指定区间范围内的值\">#</a> 获取指定区间范围内的值</h5>\n<ul>\n<li><strong> <code>SETRANGE key offset value</code> </strong>：覆盖 <code>key</code>  对应的 string 的一部分，从指定的 <code>offset</code>  处开始，覆盖 <code>value</code>  的长度。\n<ul>\n<li>如果 <code>offset</code>  比当前 <code>key</code>  对应 string 还要长，那这个 string 后面就<font color='red'>补 0</font>以达到 offset。</li>\n<li>不存在的 <code>key</code>  被认为是<font color='red'>空字符串</font>，所以这个命令可以确保 key 有一个足够大的字符串，能在 <code>offset</code>  处设置 value。</li>\n<li>模式：正因为有了 <code>SETRANGE</code>  和类似功能的 <code>GETRANGE</code>  命令，你可以把 Redis 的<font color='red'>字符串当成线性数组</font>，随机访问只要 O (1) 复杂度。这在很多真实场景应用里非常快和高效。</li>\n<li>返回值： <code>integer-reply</code> ：<font color='red'>修改后的字符串长度</font></li>\n<li>时间复杂度： <code>O（1）</code> ，不计算就地复制新字符串所花费的时间。\n<ul>\n<li>通常，此字符串非常小，因此摊销复杂度为 O（1）。</li>\n<li>否则复杂度为 O（M），M 是 value 参数的长度。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong> <code>GETRANGE key start end</code> </strong>：返回 <code>key</code>  对应的字符串 <code>value</code>  的子串，这个子串是由 <code>start</code>  和 <code>end</code>  位移决定的（两者都在 string 内）。\n<ul>\n<li>可以用<font color='red'>负的位移</font>来表示从 string 尾部开始数的下标。所以 - 1 就是最后一个字符，-2 就是倒数第二个，以此类推。</li>\n<li>这个函数处理超出范围的请求时，都把结果限制在 string 内。</li>\n<li>返回值： <code>bulk-reply</code> ，子串</li>\n<li>时间复杂度： <code>O(N)</code> ，其中 N 是字符串长度，复杂度由最终返回长度决定。但由于通过一个字符串创建子字符串是很容易的，它<font color='red'>可以被认为是 <code>O(1)</code> </font>。</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"数值增减\"><a class=\"anchor\" href=\"#数值增减\">#</a> 数值增减</h5>\n<blockquote>\n<p>前提：一定要是数字，才能增减！</p>\n</blockquote>\n<ul>\n<li>\n<p><strong> <code>INCR key</code> </strong>：对存储在指定 <code>key</code>  的数值执行原子的<font color='red'>加 1 操作</font>。</p>\n<ul>\n<li>如果指定的 key 不存在，那么在执行 incr 操作之前，会先将它的值设定为 <code>0</code> 。</li>\n<li>如果指定的 key 中存储的值不是字符串类型（fix：）或者存储的字符串类型不能表示为一个整数，那么执行这个命令时服务器会返回一个错误 (eq:(error) ERR value is not an integer or out of range)。</li>\n<li>返回值： <code>integer-reply</code> ，递增操作后 key 对应的值</li>\n</ul>\n</li>\n<li>\n<p><strong> <code>INCRBY key increment</code> </strong>：将 <code>key</code>  对应的数字<font color='red'>加 <code>decrement</code> </font>。</p>\n<ul>\n<li>如果 key 不存在，操作之前，key 就会被置为 0。</li>\n<li>如果 key 的 value 类型错误或者是个不能表示成数字的字符串，就返回错误。</li>\n<li>返回值： <code>integer-reply</code> ，增加操作后 key 对应的值</li>\n</ul>\n</li>\n<li>\n<p><strong> <code>DECR key</code> </strong>：对 <code>key</code>  对应的数字做<font color='red'>减 1 操作</font>。</p>\n<ul>\n<li>如果 key 不存在，那么在操作之前，这个 key 对应的值会被置为 0。</li>\n<li>如果 key 有一个错误类型的 value 或者是一个不能表示成数字的字符串，就返回错误。</li>\n<li>返回值：数字，减小后 key 对应的值</li>\n</ul>\n</li>\n<li>\n<p><strong> <code>DECRBY key decrement</code> </strong>：将 <code>key</code>  对应的数字<font color='red'>减 <code>decrement</code> </font>。</p>\n<ul>\n<li>如果 key 不存在，操作之前，key 就会被置为 0。</li>\n<li>如果 key 的 value 类型错误或者是个不能表示成数字的字符串，就返回错误。</li>\n<li>返回值：返回一个数字：减少之后的 value 值</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"获取字符串长度以及内容追加\"><a class=\"anchor\" href=\"#获取字符串长度以及内容追加\">#</a> 获取字符串长度以及内容追加</h5>\n<ul>\n<li><strong> <code>STRLEN key</code> </strong>：返回 <code>key</code>  的 string 类型 <code>value</code>  的长度。</li>\n<li><strong> <code>APPEND key value</code> </strong>：将 <code>value</code> <font color='red'>追加</font>到 <code>key</code>  对应的字符串值之后，并<font color='red'>返回追加后的长度</font>。</li>\n</ul>\n<h5 id=\"分布式锁\"><a class=\"anchor\" href=\"#分布式锁\">#</a> 分布式锁</h5>\n<img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230804110715178.png\" alt=\"image-20230804110715178\" style=\"zoom:67%;\" />\n<ul>\n<li>\n<p><strong> <code>SETEX key seconds value</code> </strong>：设置 <code>key</code>  对应字符串 <code>value</code> ，并且设置 key 在给定的 <code>seconds</code>  时间之后超时过期。这个命令是<font color='red'>原子的</font>，等效于执行下面的命令：</p>\n<figure class=\"highlight txt\"><figcaption data-lang=\"txt\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>SET mykey value</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>EXPIRE mykey seconds</pre></td></tr></table></figure></li>\n<li>\n<p><strong> <code>SETNX key value</code> </strong>：</p>\n<ul>\n<li><font color='red'>如果 <code>key</code>  不存在</font>，将值设为 <code>value</code> ，这种情况下等同 <code>SET</code>  命令。</li>\n<li>当 <code>key</code>  存在时，什么也不做。 <code>SETNX</code>  是 “<strong>SET</strong> if <strong>N</strong>ot e<strong>X</strong>ists” 的简写。</li>\n<li><strong>可以与 <code>DEL</code>  命令配合使用，对资源加锁</strong></li>\n</ul>\n</li>\n</ul>\n<h5 id=\"先获取再设置\"><a class=\"anchor\" href=\"#先获取再设置\">#</a> 先获取，再设置</h5>\n<ul>\n<li><strong> <code>GETSET key value</code> </strong>：等同于 <code>set key value get</code>  命令，<font color='red'>返回 key 的旧 value，将 key 的值设置为新 value</font>。</li>\n</ul>\n<h5 id=\"应用场景\"><a class=\"anchor\" href=\"#应用场景\">#</a> 应用场景</h5>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230804111834362.png\" alt=\"image-20230804111834362\" /></p>\n<ul>\n<li>\n<p>抖音中许多人点赞某个视频，点一下加一次</p>\n</li>\n<li>\n<p>公众号上某篇文章的阅读数，只要点击了 rest 地址，直接可以使用 incr key 命令增加一个数字 1，完成记录数字。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230804111954515.png\" alt=\"image-20230804111954515\" /></p>\n</li>\n</ul>\n<h4 id=\"列表list\"><a class=\"anchor\" href=\"#列表list\">#</a> 列表（List）</h4>\n<blockquote>\n<p>单 key 多 value，有序有重复</p>\n</blockquote>\n<h5 id=\"命令概览-2\"><a class=\"anchor\" href=\"#命令概览-2\">#</a> 命令概览</h5>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230804112132538.png\" alt=\"image-20230804112132538\" /></p>\n<h5 id=\"list的数据结构\"><a class=\"anchor\" href=\"#list的数据结构\">#</a> List 的数据结构</h5>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230804112413028.png\" alt=\"image-20230804112413028\" /></p>\n<p>一个<strong>双端链表</strong>的结构，容量是 2<sup>32</sup>-1 个元素，大概 40 多亿，主要功能有 <code>push</code> / <code>pop</code>  等，一般用在栈、队列、消息队列等场景。</p>\n<p>left、right 都可以插入：</p>\n<ul>\n<li>\n<p>如果键不存在，创建新的链表；</p>\n</li>\n<li>\n<p>如果键已存在，新增内容；</p>\n</li>\n<li>\n<p>如果值全移除，对应的键也就消失了。</p>\n</li>\n</ul>\n<p>它的底层实际是个<strong>双向链表，对两端的操作性能很高，通过索引下标的操作中间的节点性能会较差。</strong></p>\n<h5 id=\"插入与遍历\"><a class=\"anchor\" href=\"#插入与遍历\">#</a> 插入与遍历</h5>\n<ul>\n<li><strong> <code>LPUSH key value [value ...]</code> </strong>：将所有的 value 从 key 列表的<strong>左端依次插入</strong>。\n<ul>\n<li>如果 key 不存在，那么在进行 push 操作前会创建一个空列表。</li>\n<li>如果 key 对应的值不是一个 list 的话，那么会返回一个错误。</li>\n<li>返回值：操作后的 list 长度。</li>\n</ul>\n</li>\n<li><strong> <code>RPUSH key value [value ...]</code> </strong>：所有的 value 从 key 列表的<strong>右端依次插入</strong>。</li>\n<li><strong> <code>LRANGE key start stop</code> </strong>：遍历 key 列表在<strong>下标 [start,stop] 中的元素，注意右区间是闭合的</strong>。\n<ul>\n<li>start 和 end 偏移量都是基于 0 的下标，即 list 的第一个元素下标是 0（list 的表头），第二个元素下标是 1，以此类推。</li>\n<li>偏移量也可以是负数，表示偏移量是从 list 尾部开始计数。例如， -1 表示列表的最后一个元素，-2 是倒数第二个，以此类推。</li>\n<li><font color='red'>当下标超过 list 范围的时候不会产生 error</font>。\n<ul>\n<li>如果 start 比 list 的尾部下标大的时候，会返回一个空列表。</li>\n<li>如果 stop 比 list 的实际尾部大的时候，Redis 会当它是最后一个元素的下标。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"弹出\"><a class=\"anchor\" href=\"#弹出\">#</a> 弹出</h5>\n<ul>\n<li><strong> <code>LPOP key</code> </strong>：从 key 列表的<strong>左端弹出一个元素</strong>，并返回该元素。</li>\n<li><strong> <code>RPOP key</code> </strong>：从 key 列表的<strong>右端弹出一个元素</strong>，并返回该元素。</li>\n</ul>\n<h5 id=\"根据下标获取元素从左到右\"><a class=\"anchor\" href=\"#根据下标获取元素从左到右\">#</a> 根据下标获取元素（从左到右）</h5>\n<ul>\n<li><strong> <code>LINDEX key index</code> </strong>：返回 <code>key</code>  列表对应索引 <code>index</code>  处的值。</li>\n</ul>\n<h5 id=\"获取列表中的元素个数\"><a class=\"anchor\" href=\"#获取列表中的元素个数\">#</a> 获取列表中的元素个数</h5>\n<ul>\n<li><strong> <code>LLEN key</code> </strong></li>\n</ul>\n<h5 id=\"删除指定数量个指定value的元素\"><a class=\"anchor\" href=\"#删除指定数量个指定value的元素\">#</a> 删除指定数量个指定 value 的元素</h5>\n<ul>\n<li><strong> <code>LREM key count value</code> </strong>：从存于  <code>key</code>  的列表里<font color='red'>移除前  <code>count</code>  次出现的值为  <code>value</code>  的元素</font>。 这个 count 参数通过下面几种方式影响这个操作：\n<ul>\n<li>count &gt; 0: <font color='red'>从头往尾移除</font>值为 value 的元素。</li>\n<li>count &lt; 0: <font color='red'>从尾往头移除</font>值为 value 的元素。</li>\n<li>count = 0: <font color='red'>移除所有</font>值为 value 的元素。</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"截取并保存指定下标区间的元素\"><a class=\"anchor\" href=\"#截取并保存指定下标区间的元素\">#</a> 截取并保存指定下标区间的元素</h5>\n<ul>\n<li><strong> <code>LTRIM key start stop</code> </strong>：修剪 (trim) 一个已存在的 list，这样 list 就会<strong>只保留指定范围 [start,stop] 的指定元素</strong>。</li>\n</ul>\n<h5 id=\"将元素移至另一个列表\"><a class=\"anchor\" href=\"#将元素移至另一个列表\">#</a> 将元素移至另一个列表</h5>\n<ul>\n<li><strong> <code>RPOPLPUSH source destination</code> </strong>：<font color='red'>原子性</font>地移除存储在  <code>source</code>  的列表的最后一个元素（列表尾部元素）， 并把该元素放入存储在  <code>destination</code>  的列表的第一个元素位置（列表头部）。\n<ul>\n<li>如果 source 和 destination 是同样的，那么这个操作等同于移除列表最后一个元素并且把该元素放在列表头部， 所以这个命令也可以当作是一个旋转列表的命令。</li>\n<li>返回值：被移除和放入的元素</li>\n<li>模式 1—— 安全的队列：RPOPLPUSH 可以实现，消费者端取到消息的同时把该消息放入一个正在处理中的列表。避免了消息丢失的安全问题。</li>\n<li>模式 2—— 循环列表</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"设置某下标对应的元素值从左到右\"><a class=\"anchor\" href=\"#设置某下标对应的元素值从左到右\">#</a> 设置某下标对应的元素值（从左到右）</h5>\n<ul>\n<li><strong> <code>LSET key index value</code> </strong>：设置  <code>index</code>  位置的 list 元素的值为  <code>value</code> 。</li>\n</ul>\n<h5 id=\"在指定元素的前后插入元素\"><a class=\"anchor\" href=\"#在指定元素的前后插入元素\">#</a> 在指定元素的前 / 后插入元素</h5>\n<ul>\n<li><strong> <code>LINSERT key BEFORE|AFTER pivot value</code> </strong>：把  <code>value</code>  插入存于  <code>key</code>  的列表中在基准值  <code>pivot</code>  的前面或后面。返回插入后的列表长度，或者当 pivot 不存在时返回 - 1。</li>\n</ul>\n<h5 id=\"应用场景-2\"><a class=\"anchor\" href=\"#应用场景-2\">#</a> 应用场景</h5>\n<ul>\n<li>微信公众号订阅的消息</li>\n</ul>\n<h4 id=\"哈希集hash\"><a class=\"anchor\" href=\"#哈希集hash\">#</a> 哈希集（Hash）</h4>\n<blockquote>\n<p>单 key，但 value 是一个键值对，即<strong>单 key 单键值对</strong>：Map&lt;String,Map&lt;Object,Object&gt;&gt;</p>\n</blockquote>\n<h5 id=\"命令概览-3\"><a class=\"anchor\" href=\"#命令概览-3\">#</a> 命令概览</h5>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230804131019423.png\" alt=\"image-20230804131019423\" /></p>\n<h5 id=\"设置-获取-删除\"><a class=\"anchor\" href=\"#设置-获取-删除\">#</a> 设置、获取、删除</h5>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230804132747399.png\" alt=\"image-20230804132747399\" /></p>\n<ul>\n<li><strong> <code>HSET key field value</code> </strong>：将 <code>key</code>  指定的哈希集中<font color='red'>指定字段 <code>field</code>  的值设置为 <code>value</code> </font>。返回值为：\n<ul>\n<li>1，如果 field 是一个新字段</li>\n<li>0，如果 field 已存在</li>\n</ul>\n</li>\n<li><strong> <code>HGET key field</code> </strong>：获取 <code>key</code>  指定的哈希集中字段 <code>field</code>  所关联的值</li>\n<li><strong> <code>HMSET key field value [field value ...]</code> </strong>：将 <code>key</code>  指定的哈希集中<font color='red'>所有指定字段 <code>field</code>  的值设置为对应 <code>value</code> </font>。将重写所有在哈希集中存在的字段。</li>\n<li><strong> <code>HMGET key field [field ...]</code> </strong>：返回  <code>key</code>  指定的哈希集中<font color='red'>所有指定字段 <code>field</code>  的值</font>。</li>\n<li><strong> <code>HGETALL key</code> </strong>：返回  <code>key</code>  指定的哈希集中<font color='red'>所有的字段和值</font>。<strong>返回值中，每个字段名的下一个是它的值</strong>，所以返回值的<font color='red'>长度是哈希集大小的两倍</font>。</li>\n<li><strong> <code>HDEL key field [field ...]</code> </strong>：从 key 指定的哈希集中<font color='red'>移除各个指定的域</font>，<strong>返回成功移除的域的数量</strong>。</li>\n</ul>\n<h5 id=\"获取哈希集的字段数量\"><a class=\"anchor\" href=\"#获取哈希集的字段数量\">#</a> 获取哈希集的字段数量</h5>\n<ul>\n<li><strong> <code>HLEN key</code> </strong>：返回  <code>key</code>  指定的哈希集包含的<strong>字段的数量</strong>。</li>\n</ul>\n<h5 id=\"判断哈希集中是否存在某个字段\"><a class=\"anchor\" href=\"#判断哈希集中是否存在某个字段\">#</a> 判断哈希集中是否存在某个字段</h5>\n<ul>\n<li><strong> <code>HEXISTS key field</code> </strong>：返回 <code>key</code>  指定的哈希集中<font color='red'>是否存在字段 <code>field</code> </font>。</li>\n</ul>\n<h5 id=\"获取哈希集中的所有keyvalue\"><a class=\"anchor\" href=\"#获取哈希集中的所有keyvalue\">#</a> 获取哈希集中的所有 key/value</h5>\n<ul>\n<li><strong> <code>HKEYS key</code> </strong>：返回  <code>key</code>  指定的哈希集中<font color='red'>所有字段的名字</font>。</li>\n<li><strong> <code>HVALS key</code> </strong>：返回  <code>key</code>  指定的哈希集中<font color='red'>所有字段的值</font>。</li>\n</ul>\n<h5 id=\"增加指定字段的数值\"><a class=\"anchor\" href=\"#增加指定字段的数值\">#</a> 增加指定字段的数值</h5>\n<ul>\n<li><strong> <code>HINCRBY key field increment</code> </strong>：将  <code>key</code>  指定的哈希集中<font color='red'>指定字段  <code>field</code>  的数值增加  <code>increment</code> </font></li>\n<li><strong> <code>HINCRBYFLOAT key field increment</code> </strong>：将  <code>key</code>  指定的哈希集中<font color='red'>指定字段  <code>field</code>  的数值增加 float 类型的  <code>increment</code> </font></li>\n</ul>\n<h5 id=\"只设置哈希集中不存在的字段\"><a class=\"anchor\" href=\"#只设置哈希集中不存在的字段\">#</a> 只设置哈希集中不存在的字段</h5>\n<ul>\n<li><strong> <code>HSETNX key field value</code> </strong>：只在  <code>key</code>  指定的哈希集中不存在指定的字段  <code>field</code>  时，设置其值为  <code>value</code> 。\n<ul>\n<li>如果  <code>key</code>  指定的哈希集不存在，会创建一个新的哈希集并与  <code>key</code>  关联。</li>\n<li><strong>如果字段已存在，该操作无效果</strong>。</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"应用场景-3\"><a class=\"anchor\" href=\"#应用场景-3\">#</a> 应用场景</h5>\n<p>京东购物车的早期设计，目前不再采用，当前中小厂可用：</p>\n<ul>\n<li>新增商品 → hset shopcar:uid1024 334488 1</li>\n<li>新增商品 → hset shopcar:uid1024 334477 1</li>\n<li>增加商品数量 → hincrby shopcar:uid1024 334477 1</li>\n<li>商品总数 → hlen shopcar:uid1024</li>\n<li>全部选择 → hgetall shopcar:uid1024</li>\n</ul>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230804143259448.png\" alt=\"image-20230804143259448\" /></p>\n<h4 id=\"集合set\"><a class=\"anchor\" href=\"#集合set\">#</a> 集合（Set）</h4>\n<blockquote>\n<p>单 key 多 value，且无序无重复</p>\n</blockquote>\n<h5 id=\"命令概览-4\"><a class=\"anchor\" href=\"#命令概览-4\">#</a> 命令概览</h5>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230804143501168.png\" alt=\"image-20230804143501168\" /></p>\n<h5 id=\"添加元素\"><a class=\"anchor\" href=\"#添加元素\">#</a> 添加元素</h5>\n<ul>\n<li><strong> <code>SADD key member [member ...]</code> </strong>：向  <code>key</code>  指定的集合中添加一个或多个指定的  <code>member</code>  元素。\n<ul>\n<li>指定的一个或者多个元素 member 如果已经在集合 key 中<font color='red'>存在则忽略</font></li>\n<li>如果集合 key 不存在，则新建集合 key , 并添加 member 元素到集合 key 中</li>\n<li>返回值：<strong>成功添加到集合中的元素数量（不包括已经存在于集合中的元素）</strong></li>\n</ul>\n</li>\n</ul>\n<h5 id=\"遍历元素\"><a class=\"anchor\" href=\"#遍历元素\">#</a> 遍历元素</h5>\n<ul>\n<li><strong> <code>SMEMBERS key</code> </strong>：返回  <code>key</code>  指定的集合中所有元素</li>\n</ul>\n<h5 id=\"判断集合中是否有某元素\"><a class=\"anchor\" href=\"#判断集合中是否有某元素\">#</a> 判断集合中是否有某元素</h5>\n<ul>\n<li><strong> <code>SISMEMBER key member</code> </strong>：判断成员  <code>member</code>  是否是集合  <code>key</code>  中的成员，是则返回 1，不是或者集合 key 不存在则返回 0</li>\n</ul>\n<h5 id=\"删除元素\"><a class=\"anchor\" href=\"#删除元素\">#</a> 删除元素</h5>\n<ul>\n<li><strong> <code>SREM key member [member ...]</code> </strong>：在  <code>key</code>  集合中<font color='red'>移除指定的元素</font>，<strong>返回成功移除的元素个数</strong></li>\n</ul>\n<h5 id=\"获取集合中的元素数量\"><a class=\"anchor\" href=\"#获取集合中的元素数量\">#</a> 获取集合中的元素数量</h5>\n<ul>\n<li><strong> <code>SCARD key</code> </strong>：返回  <code>key</code>  集合的元素数量（即集合的基数）</li>\n</ul>\n<h5 id=\"从集合中随机u展现u指定个数个元素但元素不删除\"><a class=\"anchor\" href=\"#从集合中随机u展现u指定个数个元素但元素不删除\">#</a> 从集合中随机<u>展现</u>指定个数个元素，但元素不删除</h5>\n<ul>\n<li><strong> <code>SRANDMEMBER key [count]</code> </strong>：<strong>随机<u>返回</u>  <code>key</code>  集合中的  <code>count</code>  个元素</strong>\n<ul>\n<li>如果 count 是整数且小于元素的个数，返回含有 count 个不同的元素的数组</li>\n<li>如果 count 是个整数且大于集合中元素的个数时，仅返回整个集合的所有元素</li>\n<li>当 count 是负数，则会返回一个包含 count 的绝对值的个数元素的数组</li>\n<li>如果 count 的绝对值大于元素的个数，则返回的结果集里会出现一个元素出现多次的情况</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"从集合中随机u弹出u指定个数个元素且元素删除\"><a class=\"anchor\" href=\"#从集合中随机u弹出u指定个数个元素且元素删除\">#</a> 从集合中随机<u>弹出</u>指定个数个元素，且元素删除</h5>\n<ul>\n<li><strong> <code>SPOP key [count]</code> </strong>：<strong>随机<u>弹出</u>  <code>key</code>  集合中的  <code>count</code>  个元素</strong></li>\n</ul>\n<h5 id=\"将集合中已存在的某个值移动到另一个集合\"><a class=\"anchor\" href=\"#将集合中已存在的某个值移动到另一个集合\">#</a> 将集合中已存在的某个值移动到另一个集合</h5>\n<ul>\n<li><strong> <code>SMOVE source destination member</code> </strong>：<font color='red'>将 <code>member</code>  从 <code>source</code>  集合移动到 <code>destination</code>  集合中</font>。对于其他的客户端，在特定的时间元素将会作为 source 或者 destination 集合的成员出现。\n<ul>\n<li>如果 source 集合不存在或者不包含指定的元素，这 smove 命令不执行任何操作并且返回 0。</li>\n<li>否则对象将会从 source 集合中移除，并添加到 destination 集合中去，\n<ul>\n<li>如果 destination 集合已经存在该元素，则 smove 命令仅将该元素从 source 集合中移除.</li>\n</ul>\n</li>\n<li>如果 source 和 destination 不是集合类型，则返回错误.</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"集合运算\"><a class=\"anchor\" href=\"#集合运算\">#</a> <mark>集合运算</mark></h5>\n<blockquote>\n<p>社交软件中一定会大量使用</p>\n</blockquote>\n<p>假设集合 A 的元素为 abc12，集合 B 的元素为 123ax。</p>\n<h6 id=\"差集运算\"><a class=\"anchor\" href=\"#差集运算\">#</a> 差集运算</h6>\n<p><strong>即 A-B，表示属于 A 但不属于 B 的元素构成的集合</strong>。</p>\n<ul>\n<li><strong> <code>SDIFF key [key ...]</code> </strong>：返回一个集合与给定集合的差集的元素.</li>\n</ul>\n<h6 id=\"并集运算\"><a class=\"anchor\" href=\"#并集运算\">#</a> 并集运算</h6>\n<p><strong>即 A∪B，表示属于 A 或 B 的元素合并后的集合</strong>。</p>\n<ul>\n<li><strong> <code>SUNION key [key ...]</code> </strong>：返回给定的多个集合的并集中的所有成员.</li>\n</ul>\n<h6 id=\"交集运算\"><a class=\"anchor\" href=\"#交集运算\">#</a> 交集运算</h6>\n<p><strong>即 A∩B，表示属于 A 且属于 B 的共同拥有的元素构成的集合</strong>。</p>\n<ul>\n<li><strong> <code>SINTER key [key ...]</code> </strong>：返回指定所有的集合的成员的交集.</li>\n<li><strong> <code>SINTERCARD numkeys key [key ...] [LIMIT limit]</code> </strong>：类似于 <code>SINTER</code>  命令，但是不返回结果集，<strong>只返回指定 <code>numkeys</code>  个集合的交集结果的基数</strong>，是 Redis7 的新指令。LIMIT 用来限制返回值大小，\n<ul>\n<li>若返回值小于 limit，则返回该返回值</li>\n<li>若返回值大于 limit，则返回 limit</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"应用场景-4\"><a class=\"anchor\" href=\"#应用场景-4\">#</a> 应用场景</h5>\n<h6 id=\"微信抽奖小程序\"><a class=\"anchor\" href=\"#微信抽奖小程序\">#</a> 微信抽奖小程序</h6>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230804164737598.png\" alt=\"image-20230804164737598\" /></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">步骤</th>\n<th style=\"text-align:left\">Redis 命令</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">1 用户 ID，立即参与按钮</td>\n<td style=\"text-align:left\">sadd key 用户 ID</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">2 显示已经有多少人参与了，上图 23208 人参加</td>\n<td style=\"text-align:left\">SCARD key</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">3 抽奖 (从 set 中任意选取 N 个中奖人)</td>\n<td style=\"text-align:left\">SRANDMEMBER key 2 // 随机抽奖 2 个人，元素不删除<br />SPOP key 3  // 随机抽奖 3 个人，元素会删除</td>\n</tr>\n</tbody>\n</table>\n<h6 id=\"微信朋友圈点赞查看同赞朋友\"><a class=\"anchor\" href=\"#微信朋友圈点赞查看同赞朋友\">#</a> 微信朋友圈点赞查看同赞朋友</h6>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230804165326659.png\" alt=\"image-20230804165326659\" /></p>\n<table>\n<thead>\n<tr>\n<th>步骤</th>\n<th>Redis 命令</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1 新增点赞</td>\n<td><code>sadd</code>  pub:msgID 点赞用户 ID1 点赞用户 ID2</td>\n</tr>\n<tr>\n<td>2 取消点赞</td>\n<td><code>srem</code>  pub:msgID 点赞用户 ID</td>\n</tr>\n<tr>\n<td>3 展现所有点赞过的用户</td>\n<td><code>SMEMBERS</code>  pub:msgID</td>\n</tr>\n<tr>\n<td>4 点赞用户数统计，就是常见的点赞红色数字</td>\n<td><code>scard</code>  pub:msgID</td>\n</tr>\n<tr>\n<td>5 判断某个朋友是否对楼主点赞过</td>\n<td><code>SISMEMBER</code>  pub:msgID 用户 ID</td>\n</tr>\n</tbody>\n</table>\n<h6 id=\"qq内推可能认识的人\"><a class=\"anchor\" href=\"#qq内推可能认识的人\">#</a> QQ 内推可能认识的人</h6>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230804165609346.png\" alt=\"image-20230804165609346\" /></p>\n<h4 id=\"有序集合zsetsorted-set\"><a class=\"anchor\" href=\"#有序集合zsetsorted-set\">#</a> 有序集合 Zset（sorted set）</h4>\n<blockquote>\n<p>单 key 多 value，且<font color='red'>有序</font>无重复，在每个 value 前加一个<font color='red'>score</font>分数值。</p>\n<p>例如：</p>\n<ul>\n<li>set 是 k1-&gt;v1,v2</li>\n<li>Zset 是 k1-&gt;score1 v1, score2 v2</li>\n</ul>\n</blockquote>\n<h5 id=\"命令概览-5\"><a class=\"anchor\" href=\"#命令概览-5\">#</a> 命令概览</h5>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230804170237545.png\" alt=\"image-20230804170237545\" /></p>\n<h5 id=\"添加元素-2\"><a class=\"anchor\" href=\"#添加元素-2\">#</a> 添加元素</h5>\n<ul>\n<li><strong> <code>ZADD key [NX|XX] [CH] [INCR] score member [score member ...]</code> </strong>：将多个分数 / 成员（ <code>score</code> / <code>member</code> ）对添加到键为 <code>key</code>  有序集合（sorted set）里面，以<font color='red'>递增</font>的方式排序，<font color='red'>返回新添加成员的数量</font>。\n<ul>\n<li><strong>XX</strong>: 仅仅更新存在的成员，不添加新成员。</li>\n<li><strong>NX</strong>: 不更新存在的成员，只添加新成员。</li>\n<li><strong>CH</strong>: <font color='red'>修改返回值为发生变化的成员总数</font>，原始是返回新添加成员的总数 (CH 是 <em>changed</em> 的意思)。更改的元素是<strong>新添加的成员</strong>，已经存在的成员<strong>更新分数</strong>。所以在命令中指定的成员有相同的分数将不被计算在内。</li>\n<li><strong>INCR</strong>: 当 <code>ZADD</code>  指定这个选项时，成员的操作就等同 <code>ZINCRBY</code>  命令，对成员的分数进行<font color='red'>递增</font>操作。</li>\n<li>如果指定添加的成员已经是有序集合里面的成员，则会<font color='red'>更新</font>成员的分数（scrore），并更新到正确的排序位置。</li>\n<li>时间复杂度：<font color='red'>对于每个添加的成员为 <code>O(log(N))</code> </font>，其中 N 指的是有序集合中的元素数量。</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"遍历元素-2\"><a class=\"anchor\" href=\"#遍历元素-2\">#</a> 遍历元素</h5>\n<ul>\n<li>\n<p><strong> <code>ZRANGE key start stop [WITHSCORES]</code> </strong>：遍历  <code>key</code>  指定的有序集合中<strong>下标在 [ <code>start</code> , <code>stop</code> ] 间的元素</strong>，<font color='red'>返回的元素按分数递增排序</font>。</p>\n<ul>\n<li>如果添加了  <code>WITHSCORES</code>  选项，会将元素的分数与元素一并返回。</li>\n</ul>\n</li>\n<li>\n<p><strong> <code>ZREVRANGE key start stop [WITHSCORES]</code> </strong>：与 <code>ZRANGE</code>  类似，只不过元素是<font color='red'>按分数递减排序</font>。</p>\n</li>\n<li>\n<p><strong> <code>ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]</code> </strong>：遍历  <code>key</code>  指定的有序集合中<strong> score 值在 [ <code>min</code> , <code>max</code> ] 间的元素</strong>，<font color='red'>返回的元素按分数递增排序</font>。</p>\n<ul>\n<li>\n<p>具有相同分数的元素按字典序排列</p>\n</li>\n<li>\n<p><code>LIMIT</code>  参数指定返回结果的起始<font color='red'>下标 <code>offset</code>  以及数量 <code>count</code> </font></p>\n<blockquote>\n<p>注意，如果 <code>offset</code>  太大，定位 <code>offset</code>  就可能遍历整个有序集合，这会增加 O (N) 的复杂度。</p>\n</blockquote>\n</li>\n<li>\n<p><code>min</code>  和 <code>max</code>  可以是 - inf 和 + inf，这样一来，你就可以在不知道有序集的最低和最高 score 值的情况下，使用 <code>ZRANGEBYSCORE</code>  命令。</p>\n</li>\n<li>\n<p><font color='red'>默认使用闭区间</font>，也可以通过给参数前增加 <code>(</code> 符号来使用可选的开区间 (小于或大于)</p>\n</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"获取元素的分数\"><a class=\"anchor\" href=\"#获取元素的分数\">#</a> 获取元素的分数</h5>\n<ul>\n<li><strong> <code>ZSCORE key member</code> </strong>：返回 <code>key</code>  指定的有序集合中，成员 <code>member</code>  的 score 值。</li>\n</ul>\n<h5 id=\"获取有序集合的元素数量\"><a class=\"anchor\" href=\"#获取有序集合的元素数量\">#</a> 获取有序集合的元素数量</h5>\n<ul>\n<li><strong> <code>ZCARD key</code> </strong></li>\n</ul>\n<h5 id=\"删除元素-2\"><a class=\"anchor\" href=\"#删除元素-2\">#</a> 删除元素</h5>\n<ul>\n<li><strong> <code>ZREM key member [member ...]</code> </strong>：从 <code>key</code>  指定的有序集合中<strong>删除指定的多个成员 <code>member</code> </strong>，返回的是删除的成员个数，<font color='red'>不包括不存在的成员</font>。</li>\n</ul>\n<h5 id=\"增加某个元素的分数\"><a class=\"anchor\" href=\"#增加某个元素的分数\">#</a> 增加某个元素的分数</h5>\n<ul>\n<li><strong> <code>ZINCRBY key increment member</code> </strong>：为 <code>key</code>  指定的有序集合中的成员 <code>member</code>  的 score 值加上增量 <code>increment</code> 。</li>\n</ul>\n<h5 id=\"获得指定分数范围内的元素数量\"><a class=\"anchor\" href=\"#获得指定分数范围内的元素数量\">#</a> 获得指定分数范围内的元素数量</h5>\n<ul>\n<li><strong> <code>ZCOUNT key min max</code> </strong>：返回 <code>key</code>  指定的有序集合中 score 值在 [ <code>min</code> , <code>max</code> ] 之间的成员数量。</li>\n</ul>\n<h5 id=\"弹出一个或多个元素redis7\"><a class=\"anchor\" href=\"#弹出一个或多个元素redis7\">#</a> 弹出一个或多个元素（Redis7）</h5>\n<ul>\n<li><strong> <code>ZMPOP numkeys key [key ...] &lt;MIN | MAX&gt; [COUNT count]</code> </strong>：从 <code>numkeys</code>  个有序集合 <code>key</code>  列表中的第一个非空有序集合中，弹出 <code>count</code>  个元素。\n<ul>\n<li>参数 <code>MIN</code>  表示按照 score 值<font color='red'>递增</font>的顺序依次弹出</li>\n<li>参数 <code>MAX</code>  表示按照 score 值<font color='red'>递减</font>的顺序依次弹出</li>\n<li>参数 <code>COUNT</code>  表示指定<font color='red'>要弹出的元素数量</font>，<font color='red'>默认设置为 1</font>。</li>\n</ul>\n</li>\n</ul>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230804193510087.png\" alt=\"image-20230804193510087\" /></p>\n<h5 id=\"获取元素的下标值即排名\"><a class=\"anchor\" href=\"#获取元素的下标值即排名\">#</a> 获取元素的下标值（即排名）</h5>\n<ul>\n<li><strong> <code>ZRANK key member</code> </strong>：<strong>返回有序集 <code>key</code>  中成员 <code>member</code>  的排名</strong>。其中有序集成员<font color='red'>按 score 值递增</font>(从小到大) 顺序排列。排名以 0 为底，也就是说，score 值最小的成员排名为 0。</li>\n<li><strong> <code>ZREVRANK key member</code> </strong>：与 <code>ZRANK</code>  命令类似，只不过是<font color='red'>按照 score 值递减</font>排序。</li>\n</ul>\n<h5 id=\"应用场景-5\"><a class=\"anchor\" href=\"#应用场景-5\">#</a> 应用场景</h5>\n<p>根据商品的销量对商品进行排序显示。</p>\n<p>思路：定义商品销售排行榜 (sorted set 集合)，key 为 goods:sellsort，分数为商品销售数量。</p>\n<table>\n<thead>\n<tr>\n<th>步骤</th>\n<th>Redis 命令</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>商品编号 1001 的销量是 9，商品编号 1002 的销量是 15</td>\n<td><code>zadd</code>  goods:sellsort 9 1001 15 1002</td>\n</tr>\n<tr>\n<td>有一个客户又买了 2 件商品 1001，商品编号 1001 销量加 2</td>\n<td><code>zincrby</code>  goods:sellsort 2 1001</td>\n</tr>\n<tr>\n<td>求商品销量前 10 名</td>\n<td><code>ZREVRANGE</code>  goods:sellsort 0 9 withscores</td>\n</tr>\n</tbody>\n</table>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230804193828825.png\" alt=\"image-20230804193828825\" /></p>\n<h4 id=\"位图bitmap\"><a class=\"anchor\" href=\"#位图bitmap\">#</a> 位图（bitmap）</h4>\n<blockquote>\n<p>单 key 多 value，其中 value 是由<font color='orange'>0 和 1</font>状态表现二进制位的<font color='orange'>bit 数组</font></p>\n</blockquote>\n<h5 id=\"需求\"><a class=\"anchor\" href=\"#需求\">#</a> 需求</h5>\n<p>用于<strong>状态统计</strong>，例如：</p>\n<ul>\n<li>用户是否登陆过</li>\n<li>电影、广告是否被点击播放过</li>\n<li>钉钉打卡上下班，签到统计</li>\n</ul>\n<h5 id=\"数据结构\"><a class=\"anchor\" href=\"#数据结构\">#</a> 数据结构</h5>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230804195914474.png\" alt=\"image-20230804195914474\" /></p>\n<p>说明：</p>\n<ul>\n<li><font color='red'>用<strong> String 类型作为底层数据结构</strong>实现的一种统计<strong>二值状态</strong>的数据类型</font></li>\n<li>位图<font color='red'>本质是数组</font>，它是<font color='red'>基于 String</font>数据类型的<font color='red'>按位的操作</font>。该数组由多个二进制位组成，每个二进制位都对应一个偏移量 (我们称之为一个索引)。</li>\n<li>Bitmap 支持的<font color='red'>最大位数是 2<sup>32</sup> 位</font>，它可以<font color='red'>极大的节约存储空间</font>，使用 512M 内存就可以存储多达 42.9 亿的字节信息 (2<sup>32</sup> = 4294967296)</li>\n</ul>\n<h5 id=\"常用命令\"><a class=\"anchor\" href=\"#常用命令\">#</a> 常用命令</h5>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230804200305770.png\" alt=\"image-20230804200305770\" /></p>\n<ul>\n<li>\n<p><strong> <code>SETBIT key offset value</code> </strong>：设置 <code>key</code>  指定的 bitmap（字符串）在 <code>offset</code>  处的 bit 值为 <code>value</code> 。<strong>返回 offset 处原来的 bit 值</strong>。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230804201300199.png\" alt=\"image-20230804201300199\" /></p>\n</li>\n<li>\n<p><strong> <code>GETBIT key offset</code> </strong>：返回 <code>key</code>  指定的 bitmap（字符串）在 <code>offset</code>  处的 bit 值。</p>\n<ul>\n<li>当 offset 超出了字符串长度的时候，这个字符串就被假定为由 0 比特填充的连续空间。</li>\n</ul>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230804201502414.png\" alt=\"image-20230804201502414\" /></p>\n</li>\n<li>\n<p><strong> <code>STRLEN key</code> </strong>：返回 <code>key</code>  指定的 bitmap (字符串) 的<strong>字节数</strong> (1 字节 = 8bit)，超过 8bit 后再扩容 1 字节。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230804201827460.png\" alt=\"image-20230804201827460\" /></p>\n</li>\n<li>\n<p><strong> <code>BITCOUNT key [start end]</code> </strong>：统计 <code>key</code>  指定的 bitmap (字符串) 中<strong> bit 值为 1 的数量</strong>。可以指定额外的参数 <code>start</code>  和 <code>end</code>  来限制统计范围的下标。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230804202346532.png\" alt=\"image-20230804202346532\" /></p>\n</li>\n<li>\n<p><strong> <code>BITOP operation destkey key [key ...]</code> </strong>：对一个或多个 <code>key</code>  指定的<strong> bitmap (字符串) 之间进行位元操作</strong>，并将结果保存到  <code>destkey</code>  上，其中操作方式 <code>operation</code>  有以下几种：</p>\n<ul>\n<li>AND：BITOP AND destkey srckey1 srckey2 srckey3 ... srckeyN ，对一个或多个 key 求<font color='red'>逻辑并</font>，并将结果保存到 destkey 。</li>\n<li>OR：BITOP OR destkey srckey1 srckey2 srckey3 ... srckeyN，对一个或多个 key 求<font color='red'>逻辑或</font>，并将结果保存到 destkey 。</li>\n<li>XOR：BITOP XOR destkey srckey1 srckey2 srckey3 ... srckeyN，对一个或多个 key 求<font color='red'>逻辑异或</font>，并将结果保存到 destkey 。</li>\n<li>NOT：BITOP NOT destkey srckey，对给定 key 求<font color='red'>逻辑非</font>，并将结果保存到 destkey 。</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"应用场景-6\"><a class=\"anchor\" href=\"#应用场景-6\">#</a> 应用场景</h5>\n<ul>\n<li>\n<p>统计全年天天登陆占用多少字节</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230804203608847.png\" alt=\"image-20230804203608847\" /></p>\n</li>\n<li>\n<p>按照年</p>\n<blockquote>\n<p>按年去存储一个用户的签到情况，365 天只需要 365 / 8 ≈ 46 Byte，1000W 用户量一年也只需要 44 MB 就足够了。</p>\n<p>假如是亿级的系统，</p>\n<p>每天使用 1 个 1 亿位的 Bitmap 约占 12MB 的内存（10^8/8/1024/1024），10 天的 Bitmap 的内存开销约为 120MB，<font color='red'>内存压力不算太高</font>。</p>\n<p>此外，在实际使用时，<font color='red'>最好对 Bitmap 设置过期时间</font>，让 Redis 自动删除不再需要的签到记录以节省内存开销。</p>\n</blockquote>\n</li>\n</ul>\n<h4 id=\"基数统计hyperloglog\"><a class=\"anchor\" href=\"#基数统计hyperloglog\">#</a> 基数统计（HyperLogLog）</h4>\n<blockquote>\n<p>单 key</p>\n</blockquote>\n<h5 id=\"需求-2\"><a class=\"anchor\" href=\"#需求-2\">#</a> 需求</h5>\n<p><strong>UV</strong>：Unique Visitor，独立访客，一般理解为客户端 IP，通常用于统计网站 / 文章的访问量，<font color='red'>需要考虑去重</font>，同时<font color='red'>不希望占用太大内存</font>。</p>\n<ul>\n<li>统计用户搜索网站关键词的数量</li>\n<li>统计用户每天搜索不同词条个数</li>\n</ul>\n<h5 id=\"hyperloglog是什么\"><a class=\"anchor\" href=\"#hyperloglog是什么\">#</a> HyperLogLog 是什么</h5>\n<p>一言蔽之：<strong>HyperLogLog 是一种根据条件去重的基数估计算法</strong>。</p>\n<blockquote>\n<p><strong>基数</strong>：是一种数据集，是去重后的真实数量。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230805111729020.png\" alt=\"image-20230805111729020\" /></p>\n<p><strong>基数统计</strong>：统计一个集合中不重复的元素个数。</p>\n<p><strong>大白话</strong>：去重脱水后的真实数据。</p>\n<p><strong>与 set 的区别</strong>：二者同样能达到去重的目的，区别是：<font color='red'>set 需要保存元素数据本身</font>，而<font color='red'>HyperLogLog 只含有基数相关信息，不保存元素数据本身</font>，例如只保存网站的访问量，而不保存各个访问者的信息，因此<font color='red'>HyperLogLog 占用的内存更小</font></p>\n</blockquote>\n<p>优点：在输入元素的数量或者体积非常非常大时，计算基数<font color='red'>所需的空间总是固定的、并且是很小的</font>。但是，因为 HyperLogLog<font color='orange'>只会根据输入元素来计算基数，而不会储存输入元素本身</font>，所以 HyperLogLog<font color='red'>不能像集合那样，返回输入的各个元素</font>。</p>\n<blockquote>\n<p>在 Redis 里面，<font color='red'>每个 HyperLogLog 键只需要花费 12KB 内存，就可以计算接近 2<sup>64</sup> 个不同元素的基数</font>。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。</p>\n</blockquote>\n<p>缺点：<font color='red'>有 0.81% 的标准误差</font>。</p>\n<h5 id=\"命令概览-6\"><a class=\"anchor\" href=\"#命令概览-6\">#</a> 命令概览</h5>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230805111923099.png\" alt=\"image-20230805111923099\" /></p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230805112011715.png\" alt=\"image-20230805112011715\" /></p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230805111944589.png\" alt=\"image-20230805111944589\" /></p>\n<ul>\n<li>\n<p><strong> <code>PFADD key element [element ...]</code> </strong>：向 <code>key</code>  指定的 HyperLogLog 中 **&quot;添加&quot; 若干指定元素 <code>element</code> **。</p>\n<blockquote>\n<p>这里添加的 element 仅用于计算基数，不会被存储，也无法返回！</p>\n</blockquote>\n</li>\n<li>\n<p><strong> <code>PFCOUNT key [key ...]</code> </strong>：</p>\n<ul>\n<li>当参数为一个 key 时：返回存储在 HyperLogLog 结构体的该变量的<strong>近似基数</strong></li>\n<li>当参数为多个 key 时：返回这些 HyperLogLog<strong> 并集的近似基数</strong></li>\n</ul>\n<blockquote>\n<ul>\n<li>\n<p>返回的可见集合基数并不是精确值，而是一个<font color='red'>带有 0.81% 标准错误（standard error）的近似值</font>.</p>\n</li>\n<li>\n<p>这个命令的一个副作用是<font color='red'>可能会导致 HyperLogLog 内部被更改</font>。出于缓存的目的，它会用 8 字节来记录最近一次计算得到基数，所以 <code>PFCOUNT</code>  命令在技术上是个写命令。</p>\n</li>\n</ul>\n</blockquote>\n</li>\n<li>\n<p><strong> <code>PFMERGE destkey sourcekey [sourcekey ...]</code> </strong>：将由 <code>sourcekey</code>  指定的多个 HyperLogLog <strong>合并</strong>为一个由 <code>destkey</code>  指定的 HyperLogLog ，合并后的 HyperLogLog 的基数接近于所有输入 HyperLogLog 的可见集合的并集。</p>\n</li>\n</ul>\n<h5 id=\"应用场景-7\"><a class=\"anchor\" href=\"#应用场景-7\">#</a> 应用场景</h5>\n<p>统计天猫网站首页亿级 UV 的 Redis 统计方案。高级篇见！</p>\n<h4 id=\"地理空间geo\"><a class=\"anchor\" href=\"#地理空间geo\">#</a> 地理空间（GEO）</h4>\n<blockquote>\n<p><strong>本质是有序集合 Zset</strong>，不同的是<font color='orange'>将<u>score 值</u>替换为<u>经纬度</u></font></p>\n</blockquote>\n<p>地球上的地理位置是使用二维的<strong>经纬度</strong>表示，经度范围 (-180, 180]，纬度范围 (-90, 90]。核心思想主要分为三步：</p>\n<ul>\n<li>将三维的地球变为二维的坐标</li>\n<li>将二维的坐标转换为一维的点块</li>\n<li>将一维的点块转换为二进制，再通过 base32 编码</li>\n</ul>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230805135151199.png\" alt=\"image-20230805135151199\" /></p>\n<h5 id=\"命令概览与实操\"><a class=\"anchor\" href=\"#命令概览与实操\">#</a> 命令概览与实操</h5>\n<p>如何获取某个地址的经纬度：<span class=\"exturl\" data-url=\"aHR0cDovL2FwaS5tYXAuYmFpZHUuY29tL2xic2FwaS9nZXRwb2ludC8=\">http://api.map.baidu.com/lbsapi/getpoint/</span></p>\n<ul>\n<li>\n<p><strong> <code>GEOADD key longitude latitude member [longitude latitude member ...]</code> </strong>：向 <code>key</code>  指定的 GEO 中<font color='red'>添加若干个指定的地理空间位置</font>（经度 <code>longitude</code> 、纬度 <code>latitude</code> 、位置名称 <code>member</code> ）。</p>\n<ul>\n<li>该命令以采用标准格式的参数 x,y，所以<font color='red'>经度必须在纬度之前</font>。</li>\n<li>时间复杂度：<strong>每一个元素添加是 <code>O(log(N))</code> ，因为底层是有序集合 Zset</strong>，N 是有序集合 Zset 的元素数量。</li>\n</ul>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230805141104831.png\" alt=\"image-20230805141104831\" /></p>\n</li>\n<li>\n<p><strong> <code>GEOPOS key member [member ...]</code> </strong>：从 <code>key</code>  指定的 GEO 中<font color='red'>获取若干个指定了地理位置名称 <code>member</code>  的地理位置的<strong>经纬度</strong></font>。</p>\n<ul>\n<li>返回值：一个数组，每项由两个元素组成：经度、纬度。</li>\n<li>时间复杂度：每一个元素添加是 <code>O(log(N))</code> ，N 是有序集合 Zset 的元素数量。</li>\n</ul>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230805141619345.png\" alt=\"image-20230805141619345\" /></p>\n</li>\n<li>\n<p><strong> <code>GEOHASH key member [member ...]</code> </strong>：从 <code>key</code>  指定的 GEO 中<font color='red'>获取若干个指定了地理位置名称 <code>member</code>  的地理位置的<strong> Geohash 表示</strong></font>。</p>\n<ul>\n<li>geohash 算法生成的<font color='red'>base32 编码值</font></li>\n<li>返回值：一个数组，每项是一个 geohash</li>\n<li>时间复杂度：每一个元素添加是 <code>O(log(N))</code> ，N 是有序集合 Zset 的元素数量</li>\n</ul>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230805141940907.png\" alt=\"image-20230805141940907\" /></p>\n</li>\n<li>\n<p><strong> <code>GEODIST key member1 member2 [unit]</code> </strong>：返回 <code>key</code>  指定的 GEO 中两个给定位置（ <code>member1</code>  和 <code>member2</code> ）之间的<strong>距离</strong>。</p>\n<ul>\n<li>其中参数 <code>unit</code>  可取以下四个值：\n<ul>\n<li><strong>m</strong> 表示单位为米，<font color='red'>默认单位</font></li>\n<li><strong>km</strong> 表示单位为千米</li>\n<li><strong>mi</strong> 表示单位为英里</li>\n<li><strong>ft</strong> 表示单位为英尺</li>\n</ul>\n</li>\n<li>在计算距离时会假设地球为完美的球形，在极限情况下， 这一假设<font color='red'>最大会造成 0.5% 的误差</font>。</li>\n</ul>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230805142341845.png\" alt=\"image-20230805142341845\" /></p>\n</li>\n<li>\n<p><strong> <code>GEORADIUS key longitude latitude radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count]</code> </strong>：<strong>以给定的经纬度 ( <code>longitude</code>  和 <code>latitude</code> ) 为中心，返回 <code>key</code>  指定的 GEO 中，与中心的距离不超过给定最大距离 <code>radius</code>  的所有位置元素</strong>。</p>\n<ul>\n<li>\n<p><code>WITHCOORD</code> : 将位置元素的<font color='red'>经度和纬度</font>也一并返回</p>\n</li>\n<li>\n<p><code>WITHDIST</code> : 在返回位置元素的同时，将位置元素<font color='red'>与中心之间的距离</font>也一并返回。距离的单位和用户给定的范围单位保持一致</p>\n</li>\n<li>\n<p><code>WITHHASH</code> : <font color='red'>以 52 位有符号整数的形式</font>，返回位置元素<font color='red'>经过原始 geohash 编码的有序集合分值</font>。这个选项<font color='red'>主要用于底层应用或者调试</font>，实际中的作用并不大</p>\n</li>\n<li>\n<p><code>COUNT</code> ：<font color='red'>限定返回的记录数</font></p>\n</li>\n<li>\n<p>命令<font color='red'>默认返回未排序</font>的位置元素。通过以下两个参数， 用户可以指定被返回位置元素的排序方式：</p>\n<ul>\n<li><code>ASC</code> : 根据中心的位置， 按照从近到远的方式返回位置元素。</li>\n<li><code>DESC</code> : 根据中心的位置， 按照从远到近的方式返回位置元素。</li>\n</ul>\n</li>\n<li>\n<p>时间复杂度：<strong>O（N+log（M））</strong>，其中 N 是由中心和半径限定的圆形区域的边界框内的元素数量，M 是索引内的项目数量。</p>\n</li>\n<li>\n<p>返回值：</p>\n<ul>\n<li>\n<p>在没有给定任何  <code>WITH</code>  选项的情况下，命令只会返回一个像 [“New York”,”Milan”,”Paris”] 这样的<font color='red'>线性（linear）名称列表</font>。</p>\n</li>\n<li>\n<p>在指定了  <code>WITHCOORD</code>  、  <code>WITHDIST</code>  、  <code>WITHHASH</code>  等选项的情况下，命令返回一<font color='red'>个二层嵌套数组</font>，内层的每个子数组就表示一个元素。</p>\n<blockquote>\n<p>在返回嵌套数组时，子数组的<font color='red'>第一个元素总是位置元素的名字</font>。至于额外的信息，则会作为子数组的后续元素，按照以下顺序被返回：</p>\n<ol>\n<li>以浮点数格式返回的中心<font color='red'>与位置元素之间的距离</font>，单位与用户指定范围时的单位一致</li>\n<li><font color='red'>geohash 整数</font></li>\n<li>由两个元素组成的坐标，分别为<font color='red'>经度和纬度</font></li>\n</ol>\n</blockquote>\n</li>\n</ul>\n</li>\n</ul>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230805143142149.png\" alt=\"image-20230805143142149\" /></p>\n</li>\n<li>\n<p><strong> <code>GEORADIUSBYMEMBER key member radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count]</code> </strong>：与 <code>GEORADIUS</code>  命令类似，只不过这里<strong>指定的是中心的位置名称 <code>member</code> </strong>，而不是它的经纬度。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230805143329626.png\" alt=\"image-20230805143329626\" /></p>\n</li>\n</ul>\n<blockquote>\n<p><strong>注意</strong>：</p>\n<ul>\n<li>\n<p>从 Redis 版本 6.2.0 开始，<strong> <code>GEORADIUS</code>  命令被视为已弃用</strong>。在迁移或编写新代码时，它可以<font color='red'>由 <code>GEOSEARCH</code>  命令和带有 BYRADIUS 参数的 <code>GEOSEARCHSTORE</code>  命令替换</font>。</p>\n</li>\n<li>\n<p>从 Redis 版本 6.2.0 开始，<strong> <code>GEORADIUSBYMEMBER</code>  命令被视为已弃用</strong>。在迁移或编写新代码时，它可以<font color='red'>由带有 BYRADIUS 和 FROMMEMBER 参数的 <code>GEOSEARCH</code>  命令和 <code>GEOSEARCHSTORE</code>  命令替换</font>。</p>\n</li>\n</ul>\n</blockquote>\n<h5 id=\"应用场景-8\"><a class=\"anchor\" href=\"#应用场景-8\">#</a> 应用场景</h5>\n<ul>\n<li>美团地图位置附近的酒店推送</li>\n<li>高德地图附近的核酸检查点</li>\n</ul>\n<p>具体见高级篇！</p>\n<h4 id=\"流stream\"><a class=\"anchor\" href=\"#流stream\">#</a> 流（Stream）</h4>\n<blockquote>\n<p>与 Java 中的 Stream 是两码事，几乎没有任何关系！</p>\n<p>自成一脉，<strong>类型就是 Stream！</strong></p>\n</blockquote>\n<h5 id=\"是什么\"><a class=\"anchor\" href=\"#是什么\">#</a> 是什么</h5>\n<p><font color='red'>Redis5.0 之前的痛点</font>：<u>Redis</u>消息队列的 2 种方案：</p>\n<ul>\n<li>\n<p><font color='cornflowerblue'>List 实现消息队列</font></p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230805154343768.png\" alt=\"image-20230805154343768\" /></p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230805154402852.png\" alt=\"image-20230805154402852\" /></p>\n<ul>\n<li>点对点的模式</li>\n<li>缺点：<strong>对于一对多的情况力不从心</strong></li>\n<li>常用来做<font color='red'>异步队列</font>使用，将需要延后处理的任务结构体序列化成字符串塞进 Redis 的列表，另一个线程从这个列表中轮询数据进行处理</li>\n</ul>\n</li>\n<li>\n<p><font color='cornflowerblue'>Pub/Sub（发布 / 订阅）</font></p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230805181258770.png\" alt=\"image-20230805181258770\" /></p>\n<ul>\n<li>缺点 1：<strong>消息无法持久化</strong>，如果出现网络断开、Redis 宕机等，消息就会被丢弃。</li>\n<li>缺点 2：<strong>没有 Ack 机制来保证数据的可靠性</strong>，假设一个消费者都没有，那消息就直接被丢弃了。</li>\n</ul>\n</li>\n</ul>\n<p>综上，Redis5.0 版本新增了一个更强大的数据结构 Stream。</p>\n<p>一言蔽之：<strong>Redis Steam 就是 Redis 版本的 MQ 消息中间件 + 阻塞队列</strong>。</p>\n<h5 id=\"能干嘛\"><a class=\"anchor\" href=\"#能干嘛\">#</a> 能干嘛</h5>\n<p>Redis Stream 的功能概览如下：</p>\n<ul>\n<li>实现消息队列</li>\n<li>支持消息的持久化</li>\n<li>支持自动生成全局唯一 ID</li>\n<li>支持 ack 确认消息的模式</li>\n<li>支持消费组模式</li>\n</ul>\n<p>让消息队列更加的稳定和可靠。</p>\n<h5 id=\"底层结构和原理\"><a class=\"anchor\" href=\"#底层结构和原理\">#</a> 底层结构和原理</h5>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230805155540984.png\" alt=\"image-20230805155540984\" /></p>\n<p>一个消息链表，将所有加入的消息都串起来，每个消息都有一个唯一的 ID 和对应的内容。具体角色如下：</p>\n<table>\n<thead>\n<tr>\n<th>序号</th>\n<th>角色名</th>\n<th>定义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td><strong>Message Content</strong></td>\n<td>消息内容</td>\n</tr>\n<tr>\n<td>2</td>\n<td><strong>Consumer group</strong></td>\n<td>消费组，通过 <code>XGROUP CREATE</code>  命令创建，同一个消费组可以有多个消费者</td>\n</tr>\n<tr>\n<td>3</td>\n<td><strong>Last_delivered_id</strong></td>\n<td>游标，<font color='red'>每个消费组会有个游标</font> last_delivered_id，<font color='red'>任意一个消费者</font>读取了消息都会使游标 last_delivered_id 往前移动。</td>\n</tr>\n<tr>\n<td>4</td>\n<td><strong>Consumer</strong></td>\n<td>消费者，消费组中的消费者</td>\n</tr>\n<tr>\n<td>5</td>\n<td><strong>Pending_ids</strong></td>\n<td>消费者会有一个状态变量，用于<font color='red'>记录被当前消费已读取但未 ack 的消息 Id</font>，如果客户端没有 ack，这个变量里面的消息 ID 会越来越多，一旦某个消息被 ack 它就开始减少。<br/>这个 pending_ids 变量在 Redis 官方被称之为 <strong>待处理条目列表 PEL (Pending Entries List)</strong>，记录了当前已经被客户端读取的消息，但是还没有 ack (Acknowledge character：确认字符），它用来确保客户端至少消费了消息一次，而不会在网络传输的中途丢失了没处理</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"命令的理论与实操\"><a class=\"anchor\" href=\"#命令的理论与实操\">#</a> 命令的理论与实操</h5>\n<h6 id=\"队列相关命令即生产者角度\"><a class=\"anchor\" href=\"#队列相关命令即生产者角度\">#</a> 队列相关命令（即生产者角度）</h6>\n<table>\n<thead>\n<tr>\n<th>指令名称</th>\n<th>指令作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>XADD</td>\n<td>添加消息到队列末尾</td>\n</tr>\n<tr>\n<td>XRANGE</td>\n<td>获取消息列表 (可以指定范围)，忽略删除的消息</td>\n</tr>\n<tr>\n<td>XREVRANGE</td>\n<td>反向获取消息列表，ID 从大到小</td>\n</tr>\n<tr>\n<td>XTRIM</td>\n<td>限制 Stream 的长度，如果已经超长会进行截取</td>\n</tr>\n<tr>\n<td>XDEL</td>\n<td>删除消息</td>\n</tr>\n<tr>\n<td>XLEN</td>\n<td>获取 Stream 中的消息长度</td>\n</tr>\n<tr>\n<td>XREAD</td>\n<td>获取消息 (阻塞 / 非阻塞)，返回大于指定 ID 的消息</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>\n<p><strong> <code>XADD key [NOMKSTREAM] [&lt;MAXLEN | MINID&gt; [= | ~] threshold [LIMIT count]] &lt;* | id&gt; field value [field value ...]</code> </strong>：向 <code>key</code>  指定的 Stream 队列中添加若干条消息内容（ <code>field</code>  和 <code>value</code> ）</p>\n<ul>\n<li>Redis 对 MessageID 有强制要求，必须是<font color='red'>时间戳 - 自增 ID</font>这样的方式，且同一时间戳下的后续 ID 不能小于前一个</li>\n<li>Redis 在增加 Message 条目时会检查当前 MessageID 与上一条目的 MessageID，自动纠正错误的情况，<strong>一定要保证后面的 MessageID 比前面大</strong>，一个流中信息条目的 ID 必须是单调增的，这是流的基础</li>\n<li><code>*</code>  号表示服务器<font color='red'>自动生成 MessageID</font>(类似 mysql 里面主键 auto_increment)</li>\n<li>返回值：<strong>添加的 Message 条目的 MessageID</strong>。</li>\n</ul>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230805162458455.png\" alt=\"image-20230805162458455\" /></p>\n</li>\n<li>\n<p><strong> <code>XRANGE key start end [COUNT count]</code> </strong>：返回 <code>key</code>  指定的 Stream 队列中与 ** 给定 ID 范围 [ <code>start</code> , <code>end</code> ]** 匹配的消息条目。</p>\n<ul>\n<li><code>start</code>  表示最小 ID，- 代表最小值</li>\n<li><code>end</code>  表示最大 ID，+ 代表最大值</li>\n<li><code>count</code>  表示能获取的最大消息数</li>\n</ul>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230805164434264.png\" alt=\"image-20230805164434264\" /></p>\n</li>\n<li>\n<p><strong> <code>XREVRANGE key end start [COUNT count]</code> </strong>：与 <code>XRANGE</code>  命令相反，以相反的顺序返回消息条目。需要<strong>先指定最大 ID <code>end</code> ，再指定最小 ID <code>start</code> </strong>。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230805165347529.png\" alt=\"image-20230805165347529\" /></p>\n</li>\n<li>\n<p><strong> <code>XDEL key ID [ID ...]</code> </strong>：从 <code>key</code>  指定的 Stream 队列中<strong>逻辑删除</strong>指定 <code>ID</code>  的消息条目。</p>\n<ul>\n<li>当你从 Stream 中删除一个条目的时候，条目并没有<em>真正</em>被驱逐，<strong>只是被标记为删除</strong>。</li>\n</ul>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230805165654765.png\" alt=\"image-20230805165654765\" /></p>\n</li>\n<li>\n<p><strong> <code>XLEN key</code> </strong>：返回 <code>key</code>  指定的 Stream 队列中的消息条目数。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230805165759795.png\" alt=\"image-20230805165759795\" /></p>\n</li>\n<li>\n<p><strong> <code>XTRIM key &lt;MAXLEN | MINID&gt; [= | ~] threshold [LIMIT count]</code> </strong>：<strong>通过删除较旧的消息条目（ID 较低的）来修剪 <code>key</code>  指定的 Stream 队列</strong>。可以使用以下策略之一来修剪流：</p>\n<ul>\n<li>\n<p><code>MAXLEN</code> ：只要 Stream 队列的长度超过指定的阈值 <code>threshold</code> （值为正整数），就会<font color='red'>逐出 ID 较低的旧消息条目</font>。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230805170543749.png\" alt=\"image-20230805170543749\" /></p>\n</li>\n<li>\n<p><code>MINID</code> ：驱逐 ID 低于阈值 <code>threshold</code> （值为 MessageID）的消息条目。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230805170619213.png\" alt=\"image-20230805170619213\" /></p>\n</li>\n</ul>\n</li>\n<li>\n<p><strong> <code>XREAD [COUNT count] [BLOCK milliseconds] STREAMS key [key ...] ID [ID ...]</code> </strong>：从一个或者多个 <code>key</code>  指定的 Stream 队列中读取消息条目，仅返回 ID 大于调用者报告的最后接收 ID 的消息条目。参数 <code>count</code>  表示最多读取的消息数目。参数 <code>[BLOCK milliseconds]</code>  表示是否以阻塞的方式读取消息，<font color='red'>默认不阻塞</font>：</p>\n<ul>\n<li>\n<p><font color='cornflowerblue'>非阻塞使用</font>：即不提供 <code>BLOCK</code>  参数，此时命令是同步的，会返回 Stream 队列中的一系列消息条目</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230805171740158.png\" alt=\"image-20230805171740158\" /></p>\n<blockquote>\n<ul>\n<li>\n<p>**$** 代表特殊 ID，<font color='red'>表示当前 Stream 已经存储的最大的 ID</font>作为最后一个 ID，当前 Stream 中不存在大于当前最大 ID 的消息，因此此时返回 nil</p>\n</li>\n<li>\n<p><strong>0-0</strong> 代表<font color='red'>从最小的 ID 开始</font>获取 Stream 中的消息，当不指定 count，将会返回 Stream 中的所有消息，注意也可以使用 0（00/000 也都是可以的……）</p>\n</li>\n</ul>\n</blockquote>\n</li>\n<li>\n<p><font color='cornflowerblue'>阻塞使用</font>：提供 <code>BLOCK</code>  参数，如果 milliseconds 设置为 0，表示永远阻塞</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230805172251635.png\" alt=\"image-20230805172251635\" /></p>\n</li>\n</ul>\n</li>\n</ul>\n<p>小结：Stream 的基础方法，使用 <code>xadd</code>  存入消息和 <code>xread</code>  循环阻塞读取消息的方式可以实现<strong>简易版的消息队列</strong>，交互流程如下：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230805172400243.png\" alt=\"image-20230805172400243\" /></p>\n<p>对比 List 结构实现 Redis 消息队列：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230805172428816.png\" alt=\"image-20230805172428816\" /></p>\n<h6 id=\"消费组相关命令即消费者角度\"><a class=\"anchor\" href=\"#消费组相关命令即消费者角度\">#</a> 消费组相关命令（即消费者角度）</h6>\n<table>\n<thead>\n<tr>\n<th>指令名称</th>\n<th>指令作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>XGROUP CREATE</td>\n<td>创建消费组</td>\n</tr>\n<tr>\n<td>XGROUP SETID</td>\n<td>设置消费组最后递送消息的 ID</td>\n</tr>\n<tr>\n<td>XGROUP DESTROY</td>\n<td>完全销毁消费组</td>\n</tr>\n<tr>\n<td>XGROUP DELCONSUMER</td>\n<td>移除给定的消费者</td>\n</tr>\n<tr>\n<td>XREADGROUP GROUP</td>\n<td>读取消费者组中的消息</td>\n</tr>\n<tr>\n<td>XACK</td>\n<td>将消息标记为 ack，即 “已处理”</td>\n</tr>\n<tr>\n<td>XPENDING</td>\n<td>打印待处理消息的详细信息</td>\n</tr>\n<tr>\n<td>XCLAIM</td>\n<td>转移消息的归属权（长期未被处理 / 无法处理的消息，转交给其他消费者组进行处理)</td>\n</tr>\n<tr>\n<td>XINFO</td>\n<td>打印 Stream\\Consumer\\Group 的详细信息</td>\n</tr>\n<tr>\n<td>XINFO GROUPS</td>\n<td>打印消费者组的详细信息</td>\n</tr>\n<tr>\n<td>XINFO STREAM</td>\n<td>打印 Stream 的详细信息</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>\n<p><strong> <code>XGROUP [CREATE key groupname id-or-$] [SETID key id-or-$] [DESTROY key groupname] [DELCONSUMER key groupname consumername]</code> </strong>：用于<strong>管理 <code>key</code>  指定的 Stream 队列上所关联的消费组</strong>，可以：</p>\n<ul>\n<li>\n<p><code>CREATE</code> ：在 <code>key</code>  指定的 Stream 队列上<strong>创建一个新消费组</strong></p>\n<ul>\n<li>设置消费组名为 <code>groupname</code></li>\n<li>指定从消息 <code>id</code>  开始从头到尾读取（消费）</li>\n<li>或者 <code>$</code>  表示从尾部开始反向读取（消费）</li>\n</ul>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230805174041986.png\" alt=\"image-20230805174041986\" /></p>\n</li>\n<li>\n<p><code>SETID</code> ：针对 <code>key</code>  指定的 Stream 队列，<strong>设置消费组最后递送的消息 <code>id</code> </strong>，同理也能取 <code>$</code></p>\n</li>\n<li>\n<p><code>DESTROY</code> ：从 <code>key</code>  指定的 Stream 队列上<strong>销毁一个名为 <code>groupname</code>  的消费组</strong></p>\n</li>\n<li>\n<p><code>DELCONSUMER</code> ：针对 <code>key</code>  指定的 Stream 队列，<strong>从组名为 <code>groupname</code>  的消费组中移除名为 <code>consumername</code>  的消费者</strong>。</p>\n</li>\n</ul>\n</li>\n<li>\n<p><strong> <code>XREADGROUP GROUP groupname consumername [COUNT count] [BLOCK milliseconds] STREAMS key [key ...] ID [ID ...]</code> </strong>：是 <code>XREAD</code>  命令的特殊版本，支持消费者组。针对 <code>key</code>  指定的 Stream 队列，可以<strong>让消费组 <code>groupname</code>  的不同消费者 <code>consumername</code>  来读取 Stream 的不同部分</strong>。</p>\n<ul>\n<li>\n<p>同一个消费组中的消费者<font color='red'>共享同一个游标</font>，因此：</p>\n<ul>\n<li>\n<p><strong>同一个消费组中的消费者不能消费同一条消息</strong>。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230805175640453.png\" alt=\"image-20230805175640453\" /></p>\n</li>\n<li>\n<p><strong>不同消费组中的消费者可以消费同一条消息</strong>。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230805180522655.png\" alt=\"image-20230805180522655\" /></p>\n</li>\n</ul>\n</li>\n<li>\n<p>参数 <code>COUNT</code>  限制当前消费者能够读取的消息数量，默认为 +∞</p>\n</li>\n<li>\n<p>参数 <code>BLOCK</code>  表示是否阻塞读取消息</p>\n</li>\n<li>\n<p><code>ID</code>  表示从哪条消息 id 开始读取，其中<font color='red'> <code>&gt;</code>  表示从第一条尚未被消费的消息开始读取</font></p>\n</li>\n</ul>\n<blockquote>\n<p>消费组的目的：</p>\n<p>​    让组内的多个消费者共同分担读取消息。所以，我们通常会让每个消费者读取部分消息，从而实现消息读取负载在多个消费者间是均衡分布的。（<strong>负载均衡</strong>）</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230805180648195.png\" alt=\"image-20230805180648195\" /></p>\n</blockquote>\n</li>\n</ul>\n<p><strong>重点问题：ACK 机制</strong></p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230805180956093.png\" alt=\"image-20230805180956093\" /></p>\n<blockquote>\n<p>问题：</p>\n<p>​    基于 Stream 实现的消息队列，如何保证消费者在发生故障或宕机再次重启后，仍然可以读取未处理完的消息？</p>\n<p>方案：</p>\n<ul>\n<li>Streams 会自动使用内部队列（也称为<strong>待处理条目列表 PEL (Pending Entries List)</strong>）留存每个消费组里每个消费者读取的消息保底措施，直到消费者使用  <code>XACK</code>  命令通知 Streams “消息已经处理完成”。</li>\n<li>消费确认机制增加了消息的可靠性，一般在业务处理完成之后，需要执行 XACK 命令确认消息已经被消费完成。</li>\n</ul>\n</blockquote>\n<ul>\n<li>\n<p><strong> <code>XPENDING key groupname [start end count] [consumername]</code> </strong>：查询 <code>key</code>  指定的 Stream 队列上，组名为 <code>groupname</code>  的<u>消费组</u>内<strong>已读取但未确认的情况</strong></p>\n<p><img data-src=\"C:%5CUsers%5Chuawei%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20230805182227981.png\" alt=\"image-20230805182227981\" /></p>\n<blockquote>\n<p>返回值是<strong>概要信息</strong>：</p>\n<ol>\n<li>\n<p>该消费者组的待处理消息的数量</p>\n</li>\n<li>\n<p>待处理消息的最小 ID</p>\n</li>\n<li>\n<p>待处理消息的最大 ID</p>\n</li>\n<li>\n<p>对于消费者组中每一个至少有一条待处理消息的消费者，</p>\n<ol>\n<li>他的名称</li>\n<li>他的待处理消息数量</li>\n</ol>\n</li>\n</ol>\n</blockquote>\n<ul>\n<li>\n<p>若指定消费者名 <code>consumername</code> ，也可以查看<u>某个消费者</u>的已读取但未确认的情况</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230805182430081.png\" alt=\"image-20230805182430081\" /></p>\n<blockquote>\n<p>返回值是<strong>详细信息</strong>：</p>\n<ol>\n<li>消息的 ID</li>\n<li>获取并仍然要确认消息的消费者名称，我们称之为消息的当前<em>所有者</em></li>\n<li>自上次将此消息传递给该消费者以来，经过的毫秒数</li>\n<li>该消息被传递的次数</li>\n</ol>\n</blockquote>\n</li>\n</ul>\n</li>\n<li>\n<p><strong> <code>XACK key groupname ID [ID ...]</code> </strong>：从 <code>key</code>  指定的 Stream 队列中的消费者组 <code>groupname</code>  的待处理条目列表（简称 PEL）中删除若干条指定了 <code>ID</code>  的消息，即确认消息。返回成功确认的消息数。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230805184337097.png\" alt=\"image-20230805184337097\" /></p>\n</li>\n<li>\n<p><strong> <code>XINFO [CONSUMERS key groupname] key key [HELP]</code> </strong>：打印关于 Stream 和关联的消费组的不同的信息。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230805184502786.png\" alt=\"image-20230805184502786\" /></p>\n</li>\n</ul>\n<h6 id=\"四个特殊符号\"><a class=\"anchor\" href=\"#四个特殊符号\">#</a> 四个特殊符号</h6>\n<table>\n<thead>\n<tr>\n<th>符号</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>- +</td>\n<td>最小和最大可能出现的 Id</td>\n</tr>\n<tr>\n<td>$</td>\n<td>表示只消费新的消息，当前流中最大的 id，可用于将要到来的信息</td>\n</tr>\n<tr>\n<td>&gt;</td>\n<td>用于 <code>XREADGROUP</code>  命令，表示迄今还没有发送给组中使用者的信息，会更新消费者组的最后 ID</td>\n</tr>\n<tr>\n<td>*</td>\n<td>用于 <code>XADD</code>  命令中，让系统自动生成 Id</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"使用建议\"><a class=\"anchor\" href=\"#使用建议\">#</a> 使用建议</h5>\n<p><strong>Redis Stream 不能 100% 替代 Kafka、RabbitMQ 来使用，生产案例少，慎用！</strong></p>\n<h4 id=\"位域bitfield\"><a class=\"anchor\" href=\"#位域bitfield\">#</a> 位域（Bitfield）</h4>\n<blockquote>\n<p>了解即可</p>\n</blockquote>\n<p>定义：将一个 Redis 字符串看作是<font color='red'>一个由二进制位组成的数组</font>，并能对变长位宽和任意没有字节对齐的指定整型位域进行寻址和修改。</p>\n<p>作用：</p>\n<ul>\n<li>位域修改</li>\n<li>溢出控制</li>\n</ul>\n<p>基本语法：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230805185443067.png\" alt=\"image-20230805185443067\" /></p>\n<h2 id=\"4-redis持久化persistence\"><a class=\"anchor\" href=\"#4-redis持久化persistence\">#</a> 4、Redis 持久化（persistence）</h2>\n<blockquote>\n<p>Redis 持久化：Redis 是如何将数据从内存<strong>写入磁盘</strong>的？</p>\n<p>Redis 为什么需要持久化？因为 Redis 运行过程中数据是缓存在内存中的，一旦发生意外导致宕机，数据将会消失，Redis 就会形同虚设。</p>\n<p>Redis 持久化的三种实现方式：</p>\n<ul>\n<li>RDB（Redis DataBase）</li>\n<li>AOF（Append Only File）</li>\n<li>RDB + AOF</li>\n</ul>\n</blockquote>\n<h3 id=\"持化双雄\"><a class=\"anchor\" href=\"#持化双雄\">#</a> 持化双雄</h3>\n<img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230806003810720.png\" alt=\"image-20230806003810720\"  />\n<img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230806003858469.png\" alt=\"image-20230806003858469\"  />\n<h4 id=\"rdbredis-database\"><a class=\"anchor\" href=\"#rdbredis-database\">#</a> RDB（ <code>R</code> edis  <code>D</code> ata <code>B</code> ase）</h4>\n<h5 id=\"简介\"><a class=\"anchor\" href=\"#简介\">#</a> 简介</h5>\n<p>RDB 持久化：<strong>以<u>指定的时间间隔</u>执行数据集的时间点快照</strong>，将内存中的数据集以<font color='red'>全量快照</font>的形式写入磁盘保存的文件是<font color='red'>dump.rdb</font>，恢复时将磁盘中的快照文件读回内存中。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230806005245328.png\" alt=\"image-20230806005245328\" /></p>\n<h5 id=\"触发rdb快照的时间间隔\"><a class=\"anchor\" href=\"#触发rdb快照的时间间隔\">#</a> 触发 RDB 快照的时间间隔</h5>\n<p>对于自动触发快照的时间间隔，在配置文件 <code>redis.conf</code>  中的 SNAPSHOTTING 下配置 <code>save</code>  参数，来触发 RDB 持久化条件。比如 “save m n”: 表示每隔 m 秒检测一次数据集，如果检测出超过 n 次变化时，自动触发 RDB 持久化条件，执行快照。</p>\n<blockquote>\n<p>注意，这里说的是<strong>每隔 m 秒检测一次，<font color='red'>对变化的计数是累加的</font>，只要在某次检测中发现变化数累加值达到 n 次，就会触发 RDB 持久化。<font color='red'>而不是要求 n 次变化都集中发生在某个 m 秒内！</font></strong></p>\n</blockquote>\n<ul>\n<li>\n<p><strong><font color='cornflowerblue'>Redis6.0.16 及之前</font></strong>：</p>\n<ul>\n<li>save 900 1：每隔 900s (15min) 检测一次，如果有超过 1 个 key 发生了变化，就写一份新的 RDB 文件</li>\n<li>save 300 10：每隔 300s (5min) 检测一次，如果有超过 10 个 key 发生了变化，就写一份新的 RDB 文件</li>\n<li>save 60 10000：每隔 60s (1min) 检测一次，如果有超过 10000 个 key 发生了变化，就写一份新的 RDB 文件</li>\n</ul>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230806010837837.png\" alt=\"image-20230806010837837\" /></p>\n</li>\n<li>\n<p><strong><font color='cornflowerblue'>Redis6.0.16 以后至 Redis7 至今</font></strong>：</p>\n<ul>\n<li>每隔 3600s（1hour）检测一次，如果有超过 1 处变化，就写一份新的 RDB 文件</li>\n<li>每隔 300s（5min）检测一次，如果有超过 100 处变化，就写一份新的 RDB 文件</li>\n<li>每隔 60s（1min）检测一次，如果有超过 10000 处变化，就写一份新的 RDB 文件</li>\n</ul>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230806010819707.png\" alt=\"image-20230806010819707\" /></p>\n</li>\n</ul>\n<h5 id=\"rdb快照的触发方式\"><a class=\"anchor\" href=\"#rdb快照的触发方式\">#</a> RDB 快照的触发方式</h5>\n<h6 id=\"自动触发\"><a class=\"anchor\" href=\"#自动触发\">#</a> 自动触发</h6>\n<center><font color='cornflowerblue'>修改配置信息</font></center>\n<ul>\n<li>\n<p>修改时间间隔与变化数：通过修改配置文件 <code>redis.conf</code>  中的 SNAPSHOTTING 下的 <code>save</code>  参数</p>\n</li>\n<li>\n<p>修改 dump.rdb 文件的保存路径 **（Redis 每次启动都会读取磁盘中该目录下的 dump.rdb 文件（文件名需要与配置文件中保持一致）来初始化内存中的 Redis 数据库）**：通过修改配置文件 <code>redis.conf</code>  中的 SNAPSHOTTING 下的 <code>dir</code>  参数</p>\n<blockquote>\n<p>通过 Redis 命令 <code>CONFIG GET dir</code>  可以查看 dir 参数的取值：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230806113359010.png\" alt=\"image-20230806113359010\" /></p>\n</blockquote>\n</li>\n<li>\n<p>修改 dump.rdb 文件的名称：通过修改配置文件 <code>redis.conf</code>  中的 SNAPSHOTTING 下的 <code>dbfilename</code>  参数</p>\n</li>\n</ul>\n<center><font color='cornflowerblue'>触发备份的2个案例</font></center>\n<ul>\n<li>\n<p>每隔 5 秒检测一次，检测到 2 处变化，执行备份：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230806113923793.png\" alt=\"image-20230806113923793\" /></p>\n</li>\n<li>\n<p>每隔 5 秒检测一次，先设置 k3，只检测到 1 处变化，无备份动作。再过一段时间（可以超过 5 秒！）设置 k4，检测出第 2 处变化，执行备份：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230806114111595.png\" alt=\"image-20230806114111595\" /></p>\n</li>\n</ul>\n<center><font color='cornflowerblue'>如何恢复数据</font></center>\n<ol>\n<li>\n<p>根据配置文件 <code>redis.conf</code> ，将备份文件（dump.rdb）移至保存路径下</p>\n<blockquote>\n<p>这里<font color='red'>备份文件的名称、保存路径</font>一定要与配置文件 <code>redis.conf</code>  中的设置保持一致！</p>\n</blockquote>\n</li>\n<li>\n<p>让 Redis 读取指定的配置文件 <code>redis.conf</code> ，并启动 Redis 服务</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230806114837995.png\" alt=\"image-20230806114837995\" /></p>\n</li>\n</ol>\n<blockquote>\n<p>执行 <code>flushdb</code> / <code>flushall</code>  命令会<strong>产生一个空的 dump.rdb 文件</strong>，执行 <code>shutdown</code>  会<strong>产生一个退出时的 dump.rdb 文件</strong>，且会<strong>覆盖同路径下的同名备份文件</strong>！<font color='red'>等到下次 Redis 服务启动时，读取的就是这个空的 / 上次 shutdown 时的 dump.rdb 文件</font>。</p>\n<p><img data-src=\"C:%5CUsers%5Chuawei%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20230806115618721.png\" alt=\"image-20230806115618721\" /></p>\n<p>因此，<strong>不可以把备份文件 dump.rdb 和生产 redis 服务器放在同一台机器，必须分开存储，<font color='red'>分机隔离</font>，以防生产机物理损坏后备份文件也挂了</strong>。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230806115554369.png\" alt=\"image-20230806115554369\" /></p>\n</blockquote>\n<h6 id=\"手动触发\"><a class=\"anchor\" href=\"#手动触发\">#</a> 手动触发</h6>\n<p>在默认情况下（即自动触发），Redis 将数据库快照保存在名字为 dump.rdb 的二进制文件中。你可以对 Redis 的配置文件 <code>redis.conf</code>  进行设置，让它在 “每 N 秒检测一次，当数据集有 M 个改动时” 这一条件被满足时，自动保存一次快照。</p>\n<p>也可以<strong>通过调用 <code>SAVE</code>  或者 <code>BGSAVE</code>  命令，手动让 Redis 保存数据库的快照</strong>。</p>\n<p>快照保存的工作方式：</p>\n<ul>\n<li>\n<p>Redis 调用<font color='red'>forks</font>. 同时拥有父进程和子进程。</p>\n<blockquote>\n<p>在 Linux 程序中，fork () 会产生一个和父进程完全相同的子进程，但子进程在此后多会 exec 系统调用，出于效率考虑，尽量避免膨胀。</p>\n</blockquote>\n</li>\n<li>\n<p>子进程将数据集写入到一个临时 RDB 文件中。</p>\n</li>\n<li>\n<p>当子进程完成对新 RDB 文件的写入时，Redis 用新 RDB 文件替换原来的 RDB 文件，并删除旧的 RDB 文件。</p>\n</li>\n</ul>\n<p>这种工作方式使得 Redis 可以从<font color='red'>写时复制（copy-on-write）</font>机制中获益。</p>\n<img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230806122757973.png\" alt=\"image-20230806122757973\" style=\"zoom:50%;\" />\n<center><font color='cornflowerblue'>SAVE命令</font></center>\n<blockquote>\n<p>** 线上严禁使用！** 因为在主程序中执行 SAVE 命令时，<strong>会阻塞</strong>当前 redis 服务器，Redis 不能处理其他命令，缓存功能就缺失了，直到持久化工作完成。</p>\n</blockquote>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230806123508579.png\" alt=\"image-20230806123508579\" /></p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230806123541045.png\" alt=\"image-20230806123541045\" /></p>\n<center><font color='cornflowerblue'>BGSAVE命令（默认）</font></center>\n<blockquote>\n<p>Redis 会在后台异步进行快照操作，<strong>不阻塞</strong>当前 Redis 服务器，还可以同时响应客户端请求。</p>\n</blockquote>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230806145215893.png\" alt=\"image-20230806145215893\" /></p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230806145228038.png\" alt=\"image-20230806145228038\" /></p>\n<center><font color='cornflowerblue'>LASTSAVE命令：获取最近一次快照的时间</font></center>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230806145339310.png\" alt=\"image-20230806145339310\" /></p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230806145349994.png\" alt=\"image-20230806145349994\" /></p>\n<h5 id=\"rdb的优缺点\"><a class=\"anchor\" href=\"#rdb的优缺点\">#</a> RDB 的优缺点</h5>\n<p>RDB 持久化的优点：</p>\n<ul>\n<li>适合<font color='red'>大规模</font>的数据恢复</li>\n<li>按照业务，<font color='red'>定时备份</font></li>\n<li>对数据完整性和一致性要求不高</li>\n<li>dump.rdb 文件在内存中的<font color='red'>加载速度</font>要比 AOF 快得多</li>\n</ul>\n<p>RDB 持久化的缺点：</p>\n<ul>\n<li>一定间隔时间做一次备份，所以如果 Redis 意外 down 掉的话，就会丢失从当前至最近一次快照期间的数据，<strong><font color='red'>快照之间的数据会丢失</font></strong></li>\n<li>内存数据的全量同步，如果数据量太大会导致<font color='red'>I/O 严重影响服务器性能</font></li>\n<li>RDB 依赖于主进程的 fork，在更大的数据集中，这可能会导致<font color='red'>服务请求的瞬间延迟</font></li>\n<li>fork 的时候内存中的数据被克降了一份，<font color='red'>大致 2 倍的数据膨胀性</font>，需要考虑</li>\n</ul>\n<p>快照之间的数据丢失案例：</p>\n<ol>\n<li>\n<p>正常录入数据</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230806151059638.png\" alt=\"image-20230806151059638\" /></p>\n</li>\n<li>\n<p>kill -9 故意模拟意外宕机</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230806151113184.png\" alt=\"image-20230806151113184\" /></p>\n</li>\n<li>\n<p>Redis 重启，查看数据发现丢失</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230806151151946.png\" alt=\"image-20230806151151946\" /></p>\n</li>\n</ol>\n<h5 id=\"如何检查-恢复dumprdb文件\"><a class=\"anchor\" href=\"#如何检查-恢复dumprdb文件\">#</a> 如何检查、恢复 dump.rdb 文件</h5>\n<blockquote>\n<p>当 dump.rdb 文件破损时，需要恢复它，可以使用 <code>redis-check-rdb</code>  命令进行修复。</p>\n</blockquote>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230806151515656.png\" alt=\"image-20230806151515656\" /></p>\n<h5 id=\"触发rdb快照的情况\"><a class=\"anchor\" href=\"#触发rdb快照的情况\">#</a> 触发 RDB 快照的情况</h5>\n<ul>\n<li>\n<p>配置文件 <code>redis.conf</code>  中默认的快照配置</p>\n</li>\n<li>\n<p>手动 <code>save</code> / <code>bgsave</code>  命令</p>\n</li>\n<li>\n<p>执行 <code>flushall</code> / <code>flushdb</code>  命令会产生<strong>空的</strong> <code>dump.rdb</code>  文件</p>\n</li>\n<li>\n<p>执行 <code>shutdown</code>  命令，且没有设置开启 AOF 持久化</p>\n</li>\n<li>\n<p>主从复制时，主节点自动触发</p>\n</li>\n</ul>\n<h5 id=\"如何禁用rdb快照\"><a class=\"anchor\" href=\"#如何禁用rdb快照\">#</a> 如何禁用 RDB 快照</h5>\n<p>两种方式：</p>\n<ul>\n<li>\n<p>命令： <code>res-cli config set save &quot;&quot;</code></p>\n</li>\n<li>\n<p>修改配置文件：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230806152126685.png\" alt=\"image-20230806152126685\" /></p>\n</li>\n</ul>\n<h5 id=\"rdb快照的配置优化项\"><a class=\"anchor\" href=\"#rdb快照的配置优化项\">#</a> RDB 快照的配置优化项</h5>\n<blockquote>\n<p>即配置文件 <code>redis.conf</code>  中的 SNAPSHOTTING 模块</p>\n</blockquote>\n<ul>\n<li>\n<p>save &lt;seconds&gt; &lt;changes&gt;：触发快照的<font color='red'>时间间隔、变化数</font></p>\n</li>\n<li>\n<p>dbfilename：rdb 文件的<font color='red'>名称</font></p>\n</li>\n<li>\n<p>dir：rdb 文件的<font color='red'>保存路径</font></p>\n</li>\n<li>\n<p>stop-writes-on-bgsave-error：当子进程执行快照保存出现错误时，<font color='red'>是否让主进程停止接收新的写请求</font>，默认为 yes。</p>\n<blockquote>\n<p>如果不在乎数据不一致或者有其他手段发现和控制这种不一致，也可以设置为 no。此时在快照写入失败时，也能确保 Redis 继续接受新的写请求</p>\n</blockquote>\n</li>\n<li>\n<p>rdbcompression：对于存储到磁盘中的快照，可以设置<font color='red'>是否采用 LZF 算法进行压缩存储</font>，默认为 yes。</p>\n</li>\n<li>\n<p>rdbchecksum：<font color='red'>是否采用 CRC64 算法对快照文件进行数据校验</font>，默认为 yes。</p>\n</li>\n<li>\n<p>rdb-del-sync-files：看不懂，默认情况下 no，禁用。</p>\n</li>\n</ul>\n<h5 id=\"rdb小结\"><a class=\"anchor\" href=\"#rdb小结\">#</a> RDB 小结</h5>\n<img data-src=\"C:\\Users\\huawei\\AppData\\Roaming\\Typora\\typora-user-images\\image-20230806153628002.png\" alt=\"image-20230806153628002\" style=\"zoom: 67%;\" />\n<h4 id=\"aofappend-only-file\"><a class=\"anchor\" href=\"#aofappend-only-file\">#</a> AOF（ <code>A</code> ppend  <code>O</code> nly  <code>F</code> ile）</h4>\n<h5 id=\"简介-2\"><a class=\"anchor\" href=\"#简介-2\">#</a> 简介</h5>\n<p>AOF 持久化：<strong>以日志文件的形式来记录 Redis 执行过的每个写操作指令</strong>，只许追加记录，不可改写记录。Redis 启动之初会读取该日志文件重新构建数据，换言之，Redis 重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。</p>\n<p>默认情况下，Redis 是没有开启 AOF 的，开启 AOF 功能需要在配置文件 <code>redis.conf</code>  中设置配置:  <code>appendonly yes</code> 。</p>\n<p>动机：对于 RDB 持久化的快照，如果 Redis 因为某些原因而造成故障停机，那么服务器<font color='red'>将丢失最近写入、且仍未保存到快照中的那些数据</font>。 因此，Redis 增加了一种完全耐久的持久化方式：AOF 持久化。</p>\n<p>AOF 持久化所保存的文件： <code>appendonly.aof</code>  文件。</p>\n<h5 id=\"aof持久化的工作流程\"><a class=\"anchor\" href=\"#aof持久化的工作流程\">#</a> AOF 持久化的工作流程</h5>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230806195559645.png\" alt=\"image-20230806195559645\" /></p>\n<ol>\n<li>\n<p>Client 作为命令的来源，会有多个源头以及源源不断的<font color='red'>请求写命令</font>。</p>\n</li>\n<li>\n<p>在这些命令到达 Redis Server 以后并不是直接写入 AOF 文件，会将其这些命令<font color='red'>先放入 AOF 缓存</font>中进行保存。</p>\n<blockquote>\n<p>这里的 AOF 缓冲区实际上是内存中的一片区域，存在的目的是当这些<font color='red'>命令达到一定量以后再写入磁盘</font>，避免频繁的磁盘 IO 操作。</p>\n</blockquote>\n</li>\n<li>\n<p>AOF 缓冲会根据<strong> AOF 缓冲区同步文件的三种写回策略</strong><font color='red'>将命令写入磁盘上的 AOF 文件</font>。</p>\n</li>\n<li>\n<p>随着写入 AOF 内容的增加为避免文件膨胀，会根据规则<font color='red'>进行命令的合并 (又称<strong> AOF 重写</strong>)</font>，从而起到 AOF 文件压缩的目的。</p>\n</li>\n<li>\n<p>当 Redis Server 服务器重启的时候<font color='red'>Redis 会从 AOF 文件载入数据</font>。</p>\n</li>\n</ol>\n<h5 id=\"aof缓冲区的三种写回策略\"><a class=\"anchor\" href=\"#aof缓冲区的三种写回策略\">#</a> AOF 缓冲区的三种写回策略</h5>\n<p>AOF 缓冲区需要将它保存的写命令写入磁盘上的 AOF 文件，可以修改配置文件上的 <code>参数appendfsync</code> ，有三种策略：</p>\n<ul>\n<li><code>always</code> ：<font color='red'>同步写回</font>，每个写命令执行完立刻同步地将日志写入磁盘上的 AOF 文件</li>\n<li><code>everysec</code> ：<font color='red'>每秒写回</font>，每个写命令执行完，只是先把日志写到 AOF 文件的内存缓冲区，每隔 1 秒把缓冲区中的内容写入磁盘</li>\n<li><code>no</code> ：<font color='red'>操作系统控制的写回</font>，每个写命令执行完，只是先把日志写到 AOF 文件的内存缓冲区，由操作系统决定何时将缓冲区内容写回磁盘</li>\n</ul>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230806200107294.png\" alt=\"image-20230806200107294\" /></p>\n<h5 id=\"案例演示和说明\"><a class=\"anchor\" href=\"#案例演示和说明\">#</a> 案例演示和说明</h5>\n<h6 id=\"配置文件说明6-vs-7\"><a class=\"anchor\" href=\"#配置文件说明6-vs-7\">#</a> <mark>配置文件说明（6 vs 7）</mark></h6>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230806200804696.png\" alt=\"image-20230806200804696\" /></p>\n<center><font color='cornflowerblue'>如何开启AOF</font></center>\n<p>将配置文件 <code>redis.conf</code>  中 APPEND ONLY MODE 模块下的 <code>参数appendonly</code>  设置为 yes，即打开 AOF 持久化支持。</p>\n<center><font color='cornflowerblue'>使用默认的写回策略：everysec</font></center>\n<p>将配置文件 <code>redis.conf</code>  中 APPEND ONLY MODE 模块下的 <code>参数appendfsync</code>  设置为 everysec</p>\n<center><font color='cornflowerblue'>AOF文件的保存路径</font></center>\n<p>Redis6：AOF 保存文件的位置<font color='red'>和 RDB 保存文件的位置一样</font>，都是通过配置文件 redis.conf 的 <code>参数dir</code>  配置</p>\n<blockquote>\n<p>dir/dump.rdb</p>\n</blockquote>\n<p>Redis7：在 <code>参数dir</code>  的基础上，再通过配置文件 redis.conf 中 APPEND ONLY MODE 模块下的 <code>参数appenddirname</code> ，二者拼接成为 AOF 文件的保存路径</p>\n<blockquote>\n<p>dir/appenddirname/appendonly.aof</p>\n</blockquote>\n<center><font color='cornflowerblue'>AOF文件的名称</font></center>\n<p>Redis6：有且仅有 <code>appendonly.aof</code>  一个 AOF 文件</p>\n<p>Redis7：采用了 <strong>multi part AOF 机制</strong>，将原来的<font color='red'>单个 AOF 文件拆分成多个 AOF 文件</font>，<font color='red'>文件名前缀都是 <code>appendonly.aof</code> </font>，分为<font color='red'>三种类型</font>：</p>\n<ul>\n<li>\n<p><font color='gree'>BASE AOF</font>：基础 AOF，它一般由子进程 **<font color='red'>通过重写产生</font>**，该文件最多只有一个。</p>\n</li>\n<li>\n<p><font color='gree'>INCR AOF</font>：增量 AOF，它一般会在 **<font color='red'>AOFRW 开始执行时被创建</font>**，该文件可能存在多个。</p>\n<blockquote>\n<p><font color='red'>记录写命令</font>的主力军！</p>\n</blockquote>\n</li>\n<li>\n<p>HISTORY AOF：历史 AOF，它由 BASE AOF 和 INCR AOF 变化而来。每次<font color='red'>AOFRW 成功完成时</font>，本次 AOFRW 之前对应的 BASE AOF 和 INCR AOF 都将变为 HISTORY AOF，之后<font color='red'>会被 Redis 自动删除</font>。</p>\n</li>\n</ul>\n<blockquote>\n<p>为了管理这些 AOF 文件，<font color='red'>引入了一个<font color='gree'>manifest (清单）文件</font>来跟踪、管理这些 AOF</font>。同时，为了便于 AOF 备份和拷贝，我们<font color='red'>将所有的 AOF 文件和 manifest 文件放入一个单独的文件目录中</font>，目录名由参数 appenddirname 配置 (Redis 7.0 新增配置项) 决定。</p>\n</blockquote>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230806210712843.png\" alt=\"image-20230806210712843\" /></p>\n<h6 id=\"正常恢复aof文件\"><a class=\"anchor\" href=\"#正常恢复aof文件\">#</a> 正常恢复 AOF 文件</h6>\n<p>首先开启 AOF，然后执行写操作，生成 AOF 文件到指定的目录中</p>\n<p><img data-src=\"C:%5CUsers%5Chuawei%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20230806220336112.png\" alt=\"image-20230806220336112\" /></p>\n<p>Redis 重启并重新加载，结果符合预期，具体过程见脑图。</p>\n<blockquote>\n<p><code>flushdb</code>  命令也会被增量 AOF 记录，因此 Redis 重启后也会加载并执行清空库操作。</p>\n</blockquote>\n<h6 id=\"异常恢复aof文件\"><a class=\"anchor\" href=\"#异常恢复aof文件\">#</a> 异常恢复 AOF 文件</h6>\n<blockquote>\n<p>何为异常：在高并发情况下，可能上一秒刚写入一半，突然 Redis 挂了，导致 AOF 文件有缺陷、错误，那么如何恢复 AOF 文件呢？</p>\n</blockquote>\n<p>首先故意乱写正常的增量 AOF 文件，模拟网络闪断文件写 error</p>\n<img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230806222044975.png\" alt=\"image-20230806222044975\" style=\"zoom:80%;\" />\n<p>然后尝试重启 Redis 加载 AOF 文件，发现怎样都启动不了</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230806222108149.png\" alt=\"image-20230806222108149\" /></p>\n<p>执行异常修复命令 <code>redis-check-aof --fix</code>  来修复增量 AOF 文件</p>\n<blockquote>\n<p><strong>只能修复增量 AOF 文件！</strong></p>\n</blockquote>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230806222145406.png\" alt=\"image-20230806222145406\" /></p>\n<p>重启 Redis，成功加载 AOF 文件</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230806222228890.png\" alt=\"image-20230806222228890\" /></p>\n<h5 id=\"aof的优缺点\"><a class=\"anchor\" href=\"#aof的优缺点\">#</a> AOF 的优缺点</h5>\n<p>AOF 有以下优点：</p>\n<ul>\n<li>\n<p>更好地保护数据不丢失</p>\n<blockquote>\n<p>使用 AOF Redis 更加持久∶您可以有<font color='red'>不同的 fsync 策略</font>: 根本不 fsync、每秒 fsync、每次查询时 fsync。使用每秒 fsync 的默认策略，写入性能仍然很棒。fsync 是使用后台线程执行的，当没有 fsync 正在进行时，主线程将努力执行写入，因此您<font color='red'>只能丢失一秒钟的写入</font>。</p>\n</blockquote>\n</li>\n<li>\n<p>易修复</p>\n<blockquote>\n<p>AOF 日志是一个仅附加日志，因此不会出现寻道问题，也不会在断电时出现损坏问题。即使由于某种原因（磁盘已满或其他原因）日志以写一半的命令结尾， <code>redis-check-aof</code>  工具也能够轻松修复它。</p>\n</blockquote>\n</li>\n<li>\n<p>得益于 AOF 的重写机制，能够自我压缩</p>\n<blockquote>\n<p>当 AOF 变得太大时，Redis 能够在后台自动重写 AOF。重写是完全安全的，因为当 Redis 继续附加到旧文件时，会使用创建当前数据集所需的最少操作集生成一个全新的文件，一旦第二个文件准备就绪，Redis 就会切换两者并开始附加到新的那一个。</p>\n</blockquote>\n</li>\n<li>\n<p>性能高</p>\n</li>\n<li>\n<p>文件内容易理解</p>\n<blockquote>\n<p>AOF 以易于理解和解析的格式依次包含所有操作的日志。您甚至可以轻松导出 AOF 文件。</p>\n</blockquote>\n</li>\n<li>\n<p>可做紧急恢复</p>\n<blockquote>\n<p>即使您不小心使用该 <code>FLUSHALL</code>  命令刷新了所有内容，只要在此期间没有执行日志重写，您仍然可以通过停止服务器、<font color='red'>删除最新命令</font>并重新启动 Redis 来保存您的数据集。</p>\n</blockquote>\n</li>\n</ul>\n<p>AOF 有以下缺点：</p>\n<ul>\n<li>对于相同的数据集而言，aof 文件要<font color='red'>远大于 rdb 文件</font>，<font color='red'>恢复速度慢于 rdb</font></li>\n<li>aof<font color='red'>运行效率要慢于 rdb</font>，每秒同步策略效率较好，不同步效率和 rdb 相同</li>\n</ul>\n<h5 id=\"aof重写机制\"><a class=\"anchor\" href=\"#aof重写机制\">#</a> <mark>AOF 重写机制</mark></h5>\n<h6 id=\"简介-3\"><a class=\"anchor\" href=\"#简介-3\">#</a> 简介</h6>\n<p><font color='orange'>AOF 重写机制</font>：启动 AOF 文件的内容压缩，合并其中的命令，只保留可以恢复数据的最小指令集。</p>\n<blockquote>\n<p><strong><font color='red'>重写完成后</font></strong>：</p>\n<ul>\n<li>重写结果被保存到一个新的 BASE AOF 文件中，文件名上的标号加 1。</li>\n<li>同时，新建一个空的 INCR AOF 文件，文件名上的标号加 1，旧的被删除</li>\n</ul>\n</blockquote>\n<p>AOF 重写机制有<font color='red'>两种触发方式</font>：</p>\n<ul>\n<li>\n<p><font color='cornflowerblue'>自动触发</font>：当 INCR AOF 文件<font color='red'>同时满足</font>以下两个条件时，Redis 就会<font color='red'>自动</font>启动重写机制，只保留可以恢复数据的最小指令集</p>\n<blockquote>\n<p>INCR AOF 文件负责记录从 AOF 缓冲区写回的写命令</p>\n</blockquote>\n<ul>\n<li>当 INCR AOF 文件的大小超过上一次重写结果（即 BASE AOF 文件）大小 1 倍（可以通过配置 <code>auto-aof-rewrite-percentage</code>  修改）</li>\n<li>当 INCR AOF 文件的大小超过 64MB（可以通过配置 <code>auto-aof-rewrite-min-size</code>  修改）</li>\n</ul>\n</li>\n<li>\n<p><font color='cornflowerblue'>手动触发</font>：可以手动使用命令  <code>bgrewriteaof</code>  来重写。</p>\n</li>\n</ul>\n<h6 id=\"案例演示和说明-2\"><a class=\"anchor\" href=\"#案例演示和说明-2\">#</a> 案例演示和说明</h6>\n<p>具体过程见脑图，这里只演示 AOF 重写后的效果：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230807004504357.png\" alt=\"image-20230807004504357\" /></p>\n<center>自动重写</center>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230807004613263.png\" alt=\"image-20230807004613263\" /></p>\n<center>手动重写</center>\n<p>结论：</p>\n<ul>\n<li>AOF 文件重写并不是对原文件进行重新整理，而是<font color='red'>直接读取服务器现有的键值对，然后用一条命令去代替之前记录这个键值对的多条命令</font>，生成一个新的文件后去替换原来的 AOF 文件。</li>\n<li>AOF 文件重写触发机制：通过 redis.conf 配置文件中的 <code>auto-aof-rewrite-percentage</code> : 默认值为 100，以及 <code>auto-aof-rewrite·min-size</code> : 64mb 配置，也就是说默认 Redis 会记录上次重写时的 AOF 大小，默认配置是当 AOF 文件大小是上次 rewrite 后大小的一倍<strong>且</strong>文件大于 64M 时触发。</li>\n</ul>\n<h6 id=\"重写原理\"><a class=\"anchor\" href=\"#重写原理\">#</a> 重写原理</h6>\n<ol>\n<li>\n<p>在重写开始前，redis 会创建一个 “重写子进程”，这个子进程会读取现有的 AOF 文件，并将其包含的指令进行分析压缩并写入到一个临时文件中。</p>\n</li>\n<li>\n<p>与此同时，主进程会将新接收到的写指令一边累积到内存缓冲区中，一边继续写入到原有的 AOF 文件中，这样做是保证原有的 AOF 文件的可用性，避免在重写过程中出现意外。</p>\n</li>\n<li>\n<p>当 “重写子进程” 完成重写工作后，它会给父进程发一个信号，父进程收到信号后就会将内存中缓存的写指令追加到新 AOF 文件中</p>\n</li>\n<li>\n<p>当追加结束后，redis 就会用新 AOF 文件来代替旧 AOF 文件，之后再有新的写指令，就都会追加到新的 AOF 文件中</p>\n</li>\n<li>\n<p>重写 aof 文件的操作，并没有读取旧的 aof 文件，而是将整个内存中的数据库内容用命令的方式重写了一个新的 aof 文件，这点和快照有点类似</p>\n</li>\n</ol>\n<h5 id=\"aof的配置优化项\"><a class=\"anchor\" href=\"#aof的配置优化项\">#</a> AOF 的配置优化项</h5>\n<p>模块 APPEND ONLY MODE：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230807005317244.png\" alt=\"image-20230807005317244\" /></p>\n<h5 id=\"aof小结\"><a class=\"anchor\" href=\"#aof小结\">#</a> AOF 小结</h5>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230807005534144.png\" alt=\"image-20230807005534144\" /></p>\n<h3 id=\"rdb-aof混合持久化\"><a class=\"anchor\" href=\"#rdb-aof混合持久化\">#</a> RDB-AOF 混合持久化</h3>\n<h4 id=\"简介-4\"><a class=\"anchor\" href=\"#简介-4\">#</a> 简介</h4>\n<p>Redis<strong> 默认仅使用 RDB 持久化，禁用 AOF 持久化</strong>。但是，当我们<strong>手动启用 AOF 持久化后，AOF 的优先级高于 RDB</strong>！对应的数据恢复顺序和加载流程如下图：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230807010014261.png\" alt=\"image-20230807010014261\" /></p>\n<h4 id=\"到底采用哪种持久化方式\"><a class=\"anchor\" href=\"#到底采用哪种持久化方式\">#</a> 到底采用哪种持久化方式？</h4>\n<p>二者各自的特点如下：</p>\n<ul>\n<li>RDB 持久化：（定时一锅端）能够在指定的时间间隔能对你的数据进行快照存储</li>\n<li>AOF 持久化：（实时记录写命令）记录每次对服务器写的操作，当服务器重启的时候会重新执行这些命令来恢复原始的数据，命令以 redis 协议追加保存每次写的操作到文件末尾。</li>\n</ul>\n<p>同时开启时的情况：</p>\n<ul>\n<li>当 redis 重启的时候会<font color='red'>优先载入 AOF 文件</font>来恢复原始的数据，因为在通常情况下 AOF 文件保存的数据集要比 RDB 文件保存的数据集<font color='red'>更完整</font></li>\n<li>RDB 的数据不实时，同时使用两者时服务器重启也只会找 AOF 文件。<font color='red'>但是作者建议不要只使用 AOF</font>，因为 RDB 更适合用于备份数据库 (AOF 在不断变化不好备份)，<font color='red'>留着 rdb 以防万一</font></li>\n</ul>\n<p>综上，<strong><font color='orange'>推荐方式：RDB+AOF 混合方式</font></strong>，既能快速加载又能避免丢失过多的数据。配置方式：</p>\n<ol>\n<li>默认开启混合方式，对应配置文件中的 <code>aof-use-rdb-preamble</code> ，默认为 yes</li>\n<li><font color='red'>开启 AOF 持久化</font>，对应配置文件中的 <code>appendonly</code>  设置为 yes，默认为 no</li>\n</ol>\n<blockquote>\n<p>此时，RDB 镜像做<font color='red'>全量</font>持久化，AOF 做<font color='red'>增量</font>持久化：</p>\n<ul>\n<li>先使用 RDB 进行快照存储</li>\n<li>然后使用 AOF 持久化记录所有的写操作</li>\n<li>当重写策略满足或手动触发重写的时候，将最新的数据存储为新的 RDB 记录。</li>\n<li>这样的话，重启服务的时候会从 RDB 和 AOF 两部分恢复数据，既保证了数据完整性，又提高了恢复数据的性能。简单来说：混合持久化方式产生的文件一部分是 RDB 格式，一部分是 AOF 格式。<strong>----》<font color='red'>AOF 包括了 RDB 头部 + AOF 混写</font></strong></li>\n</ul>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230807011820642.png\" alt=\"image-20230807011820642\" /></p>\n</blockquote>\n<h3 id=\"纯缓存模式\"><a class=\"anchor\" href=\"#纯缓存模式\">#</a> 纯缓存模式</h3>\n<blockquote>\n<p>Redis 作为基于 key-value 的内存数据库，<strong>Redis 最主要的功能是用作缓存</strong>，而 Redis 持久化会消耗 Redis 的性能，因此可以<strong>同时关闭 RDB+AOF</strong>。</p>\n</blockquote>\n<p><strong><font color='cornflowerblue'>禁用 RDB</font></strong>：</p>\n<blockquote>\n<p>此时仍然可以手动使用命令 <code>SAVE</code>  和 <code>BGSAVE</code>  生成 rdb 文件</p>\n</blockquote>\n<ul>\n<li>\n<p>命令： <code>res-cli config set save &quot;&quot;</code></p>\n</li>\n<li>\n<p>修改配置文件：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230807012414863.png\" alt=\"image-20230807012414863\" /></p>\n</li>\n</ul>\n<p><strong><font color='cornflowerblue'>禁用 AOF</font></strong>：</p>\n<blockquote>\n<p>此时仍然可以手动使用命令 <code>BGREWRITEAOF</code>  生成 aof 文件</p>\n</blockquote>\n<ul>\n<li>命令： <code>res-cli config set appendonly no</code></li>\n<li>修改配置文件：将 <code>redis.conf</code>  中 APPEND ONLY MODE 模块下的 <code>参数appendonly</code>  设置为 no</li>\n</ul>\n<h2 id=\"5-redis事务transactions\"><a class=\"anchor\" href=\"#5-redis事务transactions\">#</a> 5、Redis 事务（Transactions）</h2>\n<blockquote>\n<p><strong>数据库事务</strong>：由一系列数据库操作组成的一个完整的逻辑过程，不可拆分。</p>\n<blockquote>\n<p>例如银行转帐，从原账户扣除金额，以及向目标账户添加金额，这两个数据库操作的总和，构成一个完整的逻辑过程，不可拆分。</p>\n</blockquote>\n<p>具有<strong> ACID</strong> 特性：</p>\n<ul>\n<li>原子性（ <code>a</code> tomicity）\n<ul>\n<li>一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。</li>\n<li>事务在执行过程中发生错误，会被恢复（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。</li>\n</ul>\n</li>\n<li>一致性（ <code>c</code> onsistency）\n<ul>\n<li>在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。</li>\n</ul>\n</li>\n<li>隔离性（ <code>i</code> solation）\n<ul>\n<li>数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以<font color='red'>防止多个事务并发执行时由于交叉执行而导致数据的不一致</font>。</li>\n<li>事务隔离分为不同级别，包括：\n<ul>\n<li>读未提交（Read uncommitted）</li>\n<li>读已提交（read committed）</li>\n<li>可重复读（repeatable read）</li>\n<li>序列化（Serializable）</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>持久性（ <code>d</code> urability）\n<ul>\n<li>事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<h3 id=\"redis事务是什么\"><a class=\"anchor\" href=\"#redis事务是什么\">#</a> Redis 事务是什么？</h3>\n<p>Redis 事务允许<strong>在一个队列中，一次性、按顺序、排他地，执行多个命令</strong>，本质是一组命令的集合。一个事务中的所有命令都会序列化，<font color='red'>按顺序地串行化执行，而不会被其它命令插入，不许加塞</font>。</p>\n<p>Redis 事务以命令 <code>MULTI</code> 、 <code>EXEC</code> 、 <code>DISCARD</code>  和 <code>WATCH</code>  为中心，提供两个重要保证：</p>\n<ul>\n<li>事务中的所有命令都是<font color='red'>按顺序序列化、执行</font>的。由另一个客户端发送的请求将永远不会在 Redis 事务的执行过程中提供服务。这保证了命令作为单个独立操作执行。</li>\n<li><font color='red'> <code>EXEC</code>  命令触发事务中所有命令的执行</font>，因此，如果客户端在调用 <code>EXEC</code>  命令之前在事务上下文中失去了与服务器的连接，则不会执行任何操作，相反，如果调用了 <code>EXEC</code>  命令，则会执行所有操作。当使用 AOF 时，Redis 确保使用单个 write（2）系统调用将事务写入磁盘。但是，如果 Redis 服务器崩溃或被系统管理员以某种艰难的方式终止，则可能只注册了部分操作。Redis 将在重新启动时检测到这种情况，并将退出并返回错误。使用 <code>redis check aof</code>  工具，可以修复将删除部分事务的 AOF 文件，以便服务器可以重新启动。</li>\n</ul>\n<p>从版本 2.2 开始，Redis 允许以<font color='red'>乐观锁</font>的形式为上述两种操作提供额外的保证，其方式与 <code>check-and-set</code> （CAS）操作非常相似。稍后将对此进行记录。</p>\n<h3 id=\"redis事务-vs-数据库事务\"><a class=\"anchor\" href=\"#redis事务-vs-数据库事务\">#</a> Redis 事务 vs 数据库事务</h3>\n<ol>\n<li>\n<p><strong>单独的隔离操作</strong>：Redis 的事务仅仅是保证事务里的操作会被连续独占的执行，redis 命令执行是单线程架构，<font color='red'>在执行完事务内所有指令前是不可能再去同时执行其他客户端的请求</font>的</p>\n</li>\n<li>\n<p><strong>没有隔离级别的概念</strong>：因为<font color='red'>事务提交前任何指令都不会被实际执行</font>，也就不存在 “事务内的查询要看到事务里的更新，在事务外查询不能看到” 这种问题了</p>\n<blockquote>\n<p>因此不存在 “三大读问题”：不可重复读、脏读、幻读</p>\n</blockquote>\n</li>\n<li>\n<p><strong>不保证原子性</strong>：Redis 的事务 **<font color='red'>不保证原子性</font>**，也就是不保证所有指令同时成功或同时失败，只有决定是否开始执行全部指令的能力，<font color='red'>没有回滚能力</font></p>\n</li>\n<li>\n<p><strong>排它性</strong>：Redis 会保证一个事务内的命令依次执行，而<font color='red'>不会被其它命令插入</font></p>\n</li>\n</ol>\n<h3 id=\"案例说明\"><a class=\"anchor\" href=\"#案例说明\">#</a> 案例说明</h3>\n<h4 id=\"常用命令-2\"><a class=\"anchor\" href=\"#常用命令-2\">#</a> 常用命令</h4>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>描述</th>\n<th>返回值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>MULTI</code></td>\n<td><font color='red'>标记一个事务块的开始</font>。随后的一系列指令将在执行 <code>EXEC</code>  时作为一个原子执行。</td>\n<td>OK</td>\n</tr>\n<tr>\n<td><code>EXEC</code></td>\n<td><font color='red'>执行事务块中所有在排队等待的指令</font>，并将链接状态恢复到正常。<br/>当使用 <code>WATCH</code>  时，只有当被监视的键没有被修改，且允许检查设定机制时， <code>EXEC</code>  会被执行。</td>\n<td>每个元素与原子事务中的指令一一对应。<br/>使用 <code>WATCH</code>  时，如果被终止， <code>EXEC</code>  则返回一个空的应答集合。</td>\n</tr>\n<tr>\n<td><code>WATCH key [key ...]</code></td>\n<td><font color='red'>监视若干个 key</font>，如果在事务执行前这些 key 发生改动，那么事务将被打断。在事务中有条件的执行（<font color='red'>乐观锁</font>）。</td>\n<td>OK</td>\n</tr>\n<tr>\n<td><code>UNWATCH </code></td>\n<td><font color='red'>释放所有被 <code>WATCH</code>  命令监视的 key</font><br/>如果执行 <code>EXEC</code>  或者 <code>DISCARD</code> ， 则不需要手动执行该命令。</td>\n<td>OK</td>\n</tr>\n<tr>\n<td><code>DISCARD</code></td>\n<td><font color='red'>取消事务，放弃执行事务块中的所有指令</font>。<br/>同时，<font color='red'>释放所有被 <code>WATCH</code>  命令监视的 key</font>。</td>\n<td>OK</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"redis事务中的错误\"><a class=\"anchor\" href=\"#redis事务中的错误\">#</a> Redis 事务中的错误</h4>\n<p>在 Redis 事务处理过程中，可能会遇到<font color='red'>两种命令错误</font>：</p>\n<ul>\n<li><strong>命令可能无法排队</strong>，因此在调用 <code>EXEC</code>  之前可能会出现错误。例如，该命令可能在<font color='red'>语法上错误</font>（参数数量错误、命令名称错误…），或者可能存在一些关键条件，如<font color='red'>内存不足</font>（如果使用 maxmemory 指令将服务器配置为具有内存限制）。</li>\n<li><strong>调用 <code>EXEC</code>  后，命令可能会失败</strong>。例如，因为我们<font color='red'>对具有错误值的键执行了操作</font>（如对字符串值调用列表操作）。</li>\n</ul>\n<p>从 Redis 2.6.5 开始，服务器将在命令累积过程中<font color='red'>检测到错误</font>。然后，它将<font color='red'>拒绝执行在 <code>EXEC</code>  期间返回错误的事务，从而丢弃该事务</font>。</p>\n<p>对于 Redis 事务中遇到的错误，有<font color='red'>两种处理方式</font>，具体见 case3 和 case4。</p>\n<h4 id=\"case1正常执行\"><a class=\"anchor\" href=\"#case1正常执行\">#</a> case1：正常执行</h4>\n<blockquote>\n<p><code>MULTI</code>  + 一系列 Redis 命令 +  <code>EXEC</code></p>\n</blockquote>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230807133026046.png\" alt=\"image-20230807133026046\" /></p>\n<h4 id=\"case2放弃事务\"><a class=\"anchor\" href=\"#case2放弃事务\">#</a> case2：放弃事务</h4>\n<blockquote>\n<p><code>MULTI</code>  + 一系列 Redis 命令 +  <code>DISCARD</code></p>\n</blockquote>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230807115127428.png\" alt=\"image-20230807115127428\" /></p>\n<h4 id=\"case3全体连坐\"><a class=\"anchor\" href=\"#case3全体连坐\">#</a> case3：全体连坐</h4>\n<blockquote>\n<p>情况（<strong>编译时异常</strong>）：<font color='red'>在 <code>EXEC</code>  命令执行前</font>，由于<u>语法错误</u>或者<u>内存不足</u>等原因，导致事务块中<font color='red'>某条命令无法加入队列</font>。</p>\n<p>解决方式：<strong><font color='red'>EXECABORT</font></strong>，取消执行事务块中队列里的所有命令。</p>\n</blockquote>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230807120332653.png\" alt=\"image-20230807120332653\" /></p>\n<h4 id=\"case4冤头债主\"><a class=\"anchor\" href=\"#case4冤头债主\">#</a> case4：冤头债主</h4>\n<blockquote>\n<p>情况（<strong>运行时异常</strong>）：<font color='red'>在 <code>EXEC</code>  命令执行后</font>，事务块中<font color='red'>某条命令执行失败</font>。例如，因为我们<u>对具有错误值的键执行了操作</u>（如对字符串值调用列表操作）。</p>\n<p>解决方式：<strong><font color='red'>即使事务内一个命令失败，队列中的所有其他命令都会被执行</font></strong>。</p>\n<p>补充：<font color='red'>Redis 不提供事务回滚的功能</font>，在事务执行出错后，<font color='red'>开发者必须自行恢复数据库状态</font>。</p>\n</blockquote>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230807132520648.png\" alt=\"image-20230807132520648\" /></p>\n<h4 id=\"case5watch监控\"><a class=\"anchor\" href=\"#case5watch监控\">#</a> case5：watch 监控</h4>\n<blockquote>\n<p><font color='cornflowerblue'>悲观锁（Pessimistic Lock）</font>：顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以<strong>每次访问数据的时候都会上锁</strong>，这样别人想拿这个数据就会 block 直到它拿到锁。</p>\n<p><font color='cornflowerblue'>乐观锁（Optimistic Lock）</font>： 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以<strong>不会上锁，但是在更新数据时会判断一下在此期间别人有没有去更新这个数据</strong>。</p>\n<blockquote>\n<p>乐观锁策略：只有当 **<u>提交版本</u> 大于 <u>记录当前版本</u>**，才能执行数据更新。</p>\n</blockquote>\n<p><font color='cornflowerblue'>CAS（Check-And-Set）</font></p>\n</blockquote>\n<h5 id=\"watch\"><a class=\"anchor\" href=\"#watch\">#</a> watch</h5>\n<p><code>watch</code>  命令是一种<strong>乐观锁</strong>的实现，Redis 在<font color='red'>修改时会检测数据是否被更改，如果更改了，则执行失败</font>。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230807131835629.png\" alt=\"image-20230807131835629\" /></p>\n<blockquote>\n<p>第一个窗口蓝色框第 5 步执行结果返回为 nil，也就是相当于是失败。</p>\n</blockquote>\n<p><code>WATCH</code>  命令用于为 Redis 事务提供一种<strong> CAS（check-and-set）行为</strong>。<br />\n被 <code>WATCH</code>  的 key 用来检测 key 的变化。如果在执行 <code>EXEC</code>  命令之前至少修改了一个被监视的 key，则整个事务将中止， <code>EXEC</code>  将返回一个 Null 回复以通知事务失败。</p>\n<h5 id=\"unwatch\"><a class=\"anchor\" href=\"#unwatch\">#</a> unwatch</h5>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230807132443762.png\" alt=\"image-20230807132443762\" /></p>\n<h5 id=\"小结\"><a class=\"anchor\" href=\"#小结\">#</a> 小结</h5>\n<ul>\n<li><font color='red'> <code>EXEC</code>  命令执行后</font>，会释放所有被 <code>WATCH</code>  命令监视的 key</li>\n<li><font color='red'>当客户端连接丢失的时候 (比如退出链接)</font>，会释放所有被 <code>WATCH</code>  命令监视的 key</li>\n</ul>\n<h3 id=\"总结\"><a class=\"anchor\" href=\"#总结\">#</a> 总结</h3>\n<p>Redis 事务分为三部分：</p>\n<ul>\n<li><strong>开启</strong>：以 <code>MULTI</code>  开始一个事务</li>\n<li><strong>入队</strong>：将多个命令入队到事务中，接到这些命令并不会立即执行，而是放到等待执行的事务队列里面</li>\n<li><strong>执行</strong>：由 <code>EXEC</code>  命令触发执行事务</li>\n</ul>\n<h2 id=\"6-redis管道pipeline\"><a class=\"anchor\" href=\"#6-redis管道pipeline\">#</a> 6、Redis 管道（pipeline）</h2>\n<blockquote>\n<p>Redis 管道与 Redis 事务之间的关系，类似于雷锋与雷峰塔的关系，Java 与 JavaScript 的关系，看上去相似，但实际没有任何关系！</p>\n</blockquote>\n<h3 id=\"面试题\"><a class=\"anchor\" href=\"#面试题\">#</a> 面试题</h3>\n<p><strong>如何优化命令频繁往返造成的性能瓶颈？</strong></p>\n<p>问题由来：</p>\n<p>Redis 是一种基于<font color='red'>客户端 - 服务端模型</font>以及请求 / 响应协议的 TCP 服务。一个请求会遵循以下步骤：</p>\n<ol>\n<li>\n<p><font color='red'>客户端向服务端发送命令</font>(分四步：发送命令→命令排队→命令执行→返回结果)，并监听 Socket 返回，通常<font color='red'>以阻塞模式等待服务端响应</font>。</p>\n</li>\n<li>\n<p><font color='red'>服务端处理命令，并将结果返回给客户端</font>。</p>\n</li>\n</ol>\n<p>上述两步的总耗时称为：<strong>Round Trip Time（即 RTT, 数据包往返于两端的时间)</strong>。</p>\n<blockquote>\n<p>如果同时需要执行大量的命令，那么就<font color='red'>要等待上一条命令应答后再执行</font>，这中间不仅仅多了 RTT（Round Time Trip），而且还频繁调用系统 IO，发送网络请求，同时需要 redis 调用多次 read () 和 write () 系统方法，系统方法会将数据从用户态转移到内核态，这样就会对进程上下文有比较大的影响了，<font color='red'>性能不太好</font>o(╥﹏╥)o</p>\n</blockquote>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230807140057973.png\" alt=\"image-20230807140057973\" /></p>\n<h3 id=\"简介-5\"><a class=\"anchor\" href=\"#简介-5\">#</a> 简介</h3>\n<blockquote>\n<p>通过<font color='red'>批处理 Redis 命令</font>来<font color='red'>优化往返时间 RTT</font></p>\n</blockquote>\n<p><strong>Redis 管道 (pipeline)</strong>：为了优化 RTT 往返时间，可以<font color='orange'>一次性打包发送多条命令</font>给服务端，而<font color='red'>无需等待对每个命令的响应</font>。服务端依次处理完完毕后，<font color='red'>通过一条响应一次性将结果返回</font>，通过减少客户端与 redis 的通信次数来实现降低往返延时时间。pipeline 的<font color='orange'>实现原理是队列</font>，先进先出特性就保证数据的顺序性。</p>\n<blockquote>\n<p>是<strong>一种批处理命令的变种优化措施</strong>，类似 Redis 原生的批命令（例如 mget 和 mset）。</p>\n</blockquote>\n<h3 id=\"案例\"><a class=\"anchor\" href=\"#案例\">#</a> 案例</h3>\n<ol>\n<li>将欲执行的命令全部写到一个 txt 文件中</li>\n<li>将 txt 文件的内容传递给 Redis 的 pipe 参数</li>\n</ol>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230807140935362.png\" alt=\"image-20230807140935362\" /></p>\n<h3 id=\"总结-2\"><a class=\"anchor\" href=\"#总结-2\">#</a> 总结</h3>\n<h4 id=\"管道-vs-原生批量命令\"><a class=\"anchor\" href=\"#管道-vs-原生批量命令\">#</a> 管道 vs 原生批量命令</h4>\n<table>\n<thead>\n<tr>\n<th>原生批量命令</th>\n<th>管道</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>原子性</td>\n<td><font color='red'>非原子性</font></td>\n</tr>\n<tr>\n<td>一次只能执行一种命令</td>\n<td>支持批量执行不同命令</td>\n</tr>\n<tr>\n<td>服务端实现</td>\n<td>服务端与客户端共同完成</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"管道-vs-事务\"><a class=\"anchor\" href=\"#管道-vs-事务\">#</a> 管道 vs 事务</h4>\n<table>\n<thead>\n<tr>\n<th>事务</th>\n<th>管道</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><font color='red'>不保证原子性</font></td>\n<td>非原子性</td>\n</tr>\n<tr>\n<td>逐条发送命令</td>\n<td>一次性发送多条命令</td>\n</tr>\n<tr>\n<td>会阻塞其他命令的执行</td>\n<td><font color='red'>非阻塞</font></td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"使用管道的注意事项\"><a class=\"anchor\" href=\"#使用管道的注意事项\">#</a> 使用管道的注意事项</h4>\n<ul>\n<li>\n<p>pipeline 缓冲的指令只是会依次执行，<font color='red'>不保证原子性，如果执行中指令发生异常，将会继续执行后续的指令</font></p>\n<blockquote>\n<p>与 Redis 事务发生命令的运行时异常类似，冤头债主，不会连坐</p>\n</blockquote>\n</li>\n<li>\n<p>使用 pipeline 组装的<font color='red'>命令个数不能太多</font>（例如 10k），不然数据量过大客户端阻塞的时间可能过久，同时<font color='red'>服务端此时也被迫回复一个队列答复，占用很多内存</font></p>\n</li>\n</ul>\n<h2 id=\"7-redis发布订阅pubsub\"><a class=\"anchor\" href=\"#7-redis发布订阅pubsub\">#</a> 7、Redis 发布订阅（pub/sub）</h2>\n<blockquote>\n<p>这是 Redis 的第一代消息中间件，第二代是 Stream，然而<strong>一般使用的都是更加成熟的第三方消息中间件</strong>。</p>\n<p><strong>了解即可</strong>，实际工作中用的很少，一般都是将 Redis 用作<strong>分布式缓存</strong>。</p>\n</blockquote>\n<h3 id=\"简介-6\"><a class=\"anchor\" href=\"#简介-6\">#</a> 简介</h3>\n<p>Redis 发布订阅（pub/sub）是一种消息通信模式：<font color='red'>发送者 (PUBLISH) 发送消息，订阅者 (SUBSCRIBE) 接收消息</font>，可以实现进程间的消息传递。</p>\n<p>一言蔽之：Redis 可以通过发布订阅实现消息的引导和分流，实现消息中间件 MQ 的功能。但是<font color='red'>不推荐使用</font>该功能，专业的事情交给专业的中间件处理，redis 就做好分布式缓存功能。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230807173639960.png\" alt=\"image-20230807173639960\" /></p>\n<center>Redis客户端可以订阅任意数量的频道，类似微信关注多个公众号</center>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230807173711847.png\" alt=\"image-20230807173711847\" /></p>\n<center>当有新消息通过PUBLISH命令发送给频道时\n</center>\n<p>小结：发布 / 订阅其实是<strong>一个轻量的队列</strong>，只不过<strong>数据不会被持久化</strong>，一般<strong>用来处理实时性较高的异步消息</strong>。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230807173943443.png\" alt=\"image-20230807173943443\" /></p>\n<h3 id=\"常用命令-3\"><a class=\"anchor\" href=\"#常用命令-3\">#</a> 常用命令</h3>\n<img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230807174014734.png\" alt=\"image-20230807174014734\"  />\n<h3 id=\"缺点\"><a class=\"anchor\" href=\"#缺点\">#</a> 缺点</h3>\n<ul>\n<li>\n<p>发布的消息在 Redis 系统中<strong>不能持久化</strong>，因此，必须先执行订阅，再等待消息发布。如果先发布了消息，那么该消息由于没有订阅者，消息将被直接丢弃</p>\n</li>\n<li>\n<p>消息只管发送对于发布者而言消息是即发即失的，不管接收，也<strong>没有 ACK 机制</strong>，无法保证消息的消费成功。</p>\n</li>\n<li>\n<p>以上的缺点导致<strong> Redis 的 Pub/Sub 模式就像个小玩具</strong>，在生产环境中几乎无用武之地。</p>\n<blockquote>\n<p>为此 Redis5.0 版本新增了 Stream 数据结构，不但支持多播，还支持数据持久化，相比 Pub/Sub 更加的强大，但是也不推荐使用。</p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"8-redis主从复制replica\"><a class=\"anchor\" href=\"#8-redis主从复制replica\">#</a> 8、Redis 主从复制（replica）</h2>\n<blockquote>\n<p>承上启下的一章，前文都是在单机场景下，从此开始介绍 Redis 多台机器的场景，即<strong>通过主从复制支持多可用性和故障切换</strong>。</p>\n</blockquote>\n<h3 id=\"简介-7\"><a class=\"anchor\" href=\"#简介-7\">#</a> 简介</h3>\n<p>Redis 数据库的主从复制，其中<strong> master 数据库以写为主，slave 数据库以读为主</strong>。</p>\n<blockquote>\n<p>当 master 数据库上的数据变化时，会自动将新的数据以<font color='red'>异步</font>的方式同步到其他 slave 数据库上。</p>\n</blockquote>\n<p>Redis 主从复制（replica）的功能如下：</p>\n<ul>\n<li><strong>读写分离</strong></li>\n<li><strong>容灾恢复</strong></li>\n<li><strong>数据备份</strong></li>\n<li><strong>水平扩容支撑高并发</strong></li>\n</ul>\n<p>配置方法：<strong>配从不配主</strong></p>\n<ul>\n<li>\n<p>master 如果配置了 <code>requirepass</code>  参数，需要密码登陆</p>\n</li>\n<li>\n<p>那么 slave 就要配置 <code>masterauth</code>  来设置校验密码，否则 master 会拒绝 slave 的访问请求</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230807183910365.png\" alt=\"image-20230807183910365\" /></p>\n</li>\n</ul>\n<h3 id=\"基本命令\"><a class=\"anchor\" href=\"#基本命令\">#</a> 基本命令</h3>\n<ul>\n<li>\n<p><strong> <code>INFO replication</code> </strong>：以一种易于理解和阅读的格式，返回关于当前 Redis 服务器的<strong>直接主 / 从</strong>复制信息</p>\n</li>\n<li>\n<p><strong> <code>REPLICAOF masterIp masterPort</code> </strong>：在线修改当前 Redis 服务器的主 / 从复制设置（自动配置）</p>\n<blockquote>\n<p>一般写入进 redis.conf 配置文件内</p>\n</blockquote>\n</li>\n<li>\n<p><strong> <code>SLAVEOF masterIp masterPort</code> </strong>：将当前 Redis 服务器转变为指定服务器的从属服务器（手动配置）</p>\n<ul>\n<li>每次与 master 断开之后，都需要<font color='red'>重新连接</font>，除非你配置进 redis.conf 文件</li>\n<li>在运行期间修改 slave 节点的信息，如果该数据库已经是某个主数据库的从数据库，那么会停止和原主数据库的同步关系转而和新的主数据库同步，<font color='red'>改换门庭</font></li>\n</ul>\n</li>\n<li>\n<p><strong> <code>SLAVEOF NO ONE</code> </strong>：将使得这个从属服务器关闭复制功能，并从从属服务器<font color='red'>转回主服务器，自立为王</font>，同时原来同步所得的数据集不会被丢弃。</p>\n</li>\n</ul>\n<h3 id=\"案例演示\"><a class=\"anchor\" href=\"#案例演示\">#</a> 案例演示</h3>\n<h4 id=\"架构说明\"><a class=\"anchor\" href=\"#架构说明\">#</a> 架构说明</h4>\n<p>一主二从，一个 master，两个 slave，示意图如下：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230807185141276.png\" alt=\"image-20230807185141276\" /></p>\n<p>拷贝多份配置文件，分别命名为：</p>\n<ul>\n<li>redis6379.conf</li>\n<li>redis6380.conf</li>\n<li>redis6381.conf</li>\n</ul>\n<h4 id=\"口诀\"><a class=\"anchor\" href=\"#口诀\">#</a> <mark>口诀</mark></h4>\n<blockquote>\n<p>面试重点</p>\n</blockquote>\n<p>前提：三边网络互相 ping 通，同时注意防火墙配置。</p>\n<p>三大命令：</p>\n<ul>\n<li>主从复制： <code>REPLICAOF masterIp masterPort</code> ，配从不配主</li>\n<li>改换门庭： <code>SLAVEOF masterIp masterPort</code></li>\n<li>自立为王： <code>SLAVEOF NO ONE</code></li>\n</ul>\n<h4 id=\"修改配置文件的操作细节\"><a class=\"anchor\" href=\"#修改配置文件的操作细节\">#</a> 修改配置文件的操作细节</h4>\n<p>以 redis6379.conf 为例，步骤如下：</p>\n<ol>\n<li>\n<p>要求 Redis 后台运行，不要弹出命令行窗口： <code>daemonize yes</code></p>\n</li>\n<li>\n<p>取消 IP 的绑定，否则影响远程 IP 连接，注释掉 <code>bind 127.0.0.1</code></p>\n</li>\n<li>\n<p>关闭保护模式，否则影响远程访问 / 连接： <code>protected-mode no</code></p>\n</li>\n<li>\n<p>指定端口： <code>port 6379</code></p>\n</li>\n<li>\n<p>指定当前工作目录， <code>dir /myredis</code></p>\n</li>\n<li>\n<p>设置 pid（进程 id）文件的路径和名字： <code>pidfile /var/run/redis_6379.pid</code></p>\n</li>\n<li>\n<p>设置 log 文件的路径和名字： <code>logfile &quot;/myredis/6379.log&quot;</code></p>\n</li>\n<li>\n<p><font color='red'>设置 Redis 服务器的密码</font>： <code>requirepass 111111</code></p>\n<blockquote>\n<p>master、slave 均配置</p>\n</blockquote>\n</li>\n<li>\n<p>设置 rdb 文件的名称： <code>dbfilename dump6379.rdb</code></p>\n</li>\n<li>\n<p>若开启 AOF，还需设置 aof 文件的名字：appendfilename 。这里不开启了。</p>\n</li>\n<li>\n<p><font color='red'>slaveslave 设置所访问的 mastermaster 的 IP 和端口： <code>replicaof masterIp 6379</code> ，并设置通行密码 <code>masterauth &quot;111111&quot;</code> </font></p>\n<blockquote>\n<p>slave 需要配置</p>\n</blockquote>\n</li>\n</ol>\n<h4 id=\"常用的3招\"><a class=\"anchor\" href=\"#常用的3招\">#</a> 常用的 3 招</h4>\n<h5 id=\"一主二从\"><a class=\"anchor\" href=\"#一主二从\">#</a> 一主二从</h5>\n<blockquote>\n<p>1 个 master，2 个 slave</p>\n</blockquote>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230807201752116.png\" alt=\"image-20230807201752116\" /></p>\n<h6 id=\"方案1配置文件固定写死\"><a class=\"anchor\" href=\"#方案1配置文件固定写死\">#</a> 方案 1：配置文件固定写死</h6>\n<ol>\n<li>\n<p>配从（6380 和 6381）不配主</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230807193239828.png\" alt=\"image-20230807193239828\" /></p>\n</li>\n<li>\n<p>依次启动 master 和两台 slave</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230807193418057.png\" alt=\"image-20230807193418057\" /></p>\n</li>\n<li>\n<p>查看主从关系</p>\n<ol>\n<li>\n<p>通过日志文件：通过 <code>vim 6379.log</code>  查看 master 日志，通过 <code> vim 6380/6381.log</code>  查看 slave 日志</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230807193701621.png\" alt=\"image-20230807193701621\" /></p>\n<center>master日志</center>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230807193733743.png\" alt=\"image-20230807193733743\" /></p>\n<center>slave日志</center>\n</li>\n<li>\n<p>通过命令： <code>info relication</code></p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230807193843707.png\" alt=\"image-20230807193843707\" /></p>\n<center>master的主从复制信息</center>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230807193915854.png\" alt=\"image-20230807193915854\" /></p>\n<center>slave的主从复制信息</center>\n</li>\n</ol>\n</li>\n</ol>\n<h6 id=\"主从复制问题演示\"><a class=\"anchor\" href=\"#主从复制问题演示\">#</a> 主从复制问题演示</h6>\n<ul>\n<li>\n<p>问题 1：<strong>slave 不能执行写命令！</strong></p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230807194936720.png\" alt=\"image-20230807194936720\" /></p>\n</li>\n<li>\n<p>问题 2：slave 切入点问题。当某台 slave shutdown 并重启后，<strong>slave 对 master 首次进行全量复制，然后进行增量复制</strong>。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230807194924560.png\" alt=\"image-20230807194924560\" /></p>\n</li>\n<li>\n<p>问题 3：master shutdown 后，slave 原地待命，数据仍可以正常使用，<strong>slave 等待 master 重启归来</strong>！</p>\n</li>\n<li>\n<p>问题 4：shutdown 后的<strong> master 重启归来，主从关系还在！slave 还能顺利复制！</strong></p>\n</li>\n</ul>\n<h6 id=\"方案2命令操作手动指定\"><a class=\"anchor\" href=\"#方案2命令操作手动指定\">#</a> 方案 2：命令操作手动指定</h6>\n<ol>\n<li>\n<p>slave 停机并去掉配置项，清空主从关系。此时 3 机都是 master，互不从属。</p>\n</li>\n<li>\n<p>在预设的 2 个 slave 上执行命令 <code>SLAVEOF masterIp masterHost</code>  指定 master</p>\n</li>\n</ol>\n<p>这种情况下，<strong>若 slave shutdown 并重启，主从关系就不存在了（因为没有设置配置文件）！</strong></p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230807200155294.png\" alt=\"image-20230807200155294\" /></p>\n<h6 id=\"配置-vs-命令\"><a class=\"anchor\" href=\"#配置-vs-命令\">#</a> 配置 vs 命令</h6>\n<p><strong>配置（即方案 1）持久稳定，命令（即方案 2）临时生效</strong>。</p>\n<h5 id=\"薪火相传\"><a class=\"anchor\" href=\"#薪火相传\">#</a> 薪火相传</h5>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230807202217260.png\" alt=\"image-20230807202217260\" /></p>\n<p>要点：</p>\n<ul>\n<li>slave（6380）也可以作为 master（6379），接收其他 slave（6381）的连接和同步请求，可以<strong>有效减轻主 master 的写压力</strong>。</li>\n<li>改变 master 的命令： <code>SLAVEOF newMasterIp newMasterPort</code></li>\n<li><strong>slave（6380）仍然无法执行写命令！</strong></li>\n<li>slave（6381）中途变更转向，master 从 6379 变为 6380，<strong>会清除之前 master（6379）的数据，重新建立拷贝新的 master（6380）的数据</strong>。</li>\n</ul>\n<h5 id=\"自立为王\"><a class=\"anchor\" href=\"#自立为王\">#</a> 自立为王</h5>\n<blockquote>\n<p>slave 转成 master</p>\n</blockquote>\n<p>命令 <code>SLAVEOF NO ONE</code> ：<strong>停止与其他数据库的同步，清空数据，转成主数据库</strong>。</p>\n<h3 id=\"主从复制的原理-工作流程\"><a class=\"anchor\" href=\"#主从复制的原理-工作流程\">#</a> <mark>主从复制的原理、工作流程</mark></h3>\n<blockquote>\n<p>面试重点</p>\n</blockquote>\n<ol>\n<li>\n<p><strong><font color='black'>slave 首次连接，请求完全同步</font></strong>：slave<font color='red'>首次连接</font>master 后会发送一个 <code>sync</code>  命令，<font color='red'>请求完全同步（全量复制）</font></p>\n<blockquote>\n<p>执行一次完全同步（<font color='red'>全量复制</font>），slave 自身原有数据会被<font color='red'>覆盖清除</font></p>\n</blockquote>\n</li>\n<li>\n<p><strong><font color='black'>master 保存快照、缓存写命令，响应给 slave 进行初始化</font></strong>：</p>\n<ul>\n<li>master 节点收到 <code>sync</code>  命令后会开始在后台<font color='red'>保存快照</font>(即 RDB 持久化，主从复制时会触发 RDB)，同时<font color='red'>缓存所有接收到的写命令</font>，master 节点执行 RDB 持久化完后，<font color='red'>master 将 rdb 快照文件和所有缓存的写命令发送到所有 slave</font>，以完成一次完全同步</li>\n<li>而 slave 服务在接收到数据库文件数据后，将其<font color='red'>存盘并加载到内存中</font>，从而<font color='red'>完成复制初始化</font></li>\n</ul>\n</li>\n<li>\n<p><strong><font color='black'>心跳持续，保持通信</font></strong>：master 向 slave 发出 PING 包的周期，默认是 10 秒。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230807205137957.png\" alt=\"image-20230807205137957\" /></p>\n</li>\n<li>\n<p><strong><font color='black'>进入平稳，增量复制</font></strong>：master 继续将新的所有收集到的写命令自动依次传给 slave，完成同步</p>\n</li>\n<li>\n<p><strong><font color='b'>slave 下线，重连续传</font></strong>：假设某台 slave 宕机并重启了，master 会检查 backlog 里面的 <code>offset</code> ，master 和 slave 都会保存一个复制的 <code>offset</code>  和一个 masterId， <code>offset</code>  是保存在 backlog 中的。<font color='red'>master 只会把已经复制的 <code>offset</code>  后面的数据复制给 slave</font>，类似<strong>断点续传</strong>。</p>\n</li>\n</ol>\n<h3 id=\"主从复制的缺点\"><a class=\"anchor\" href=\"#主从复制的缺点\">#</a> <mark>主从复制的缺点</mark></h3>\n<blockquote>\n<p>面试重点</p>\n</blockquote>\n<ul>\n<li>\n<p><strong>复制延时，信号衰减</strong></p>\n<blockquote>\n<p>由于所有的写操作都是先在 Master 上操作，然后同步更新到 Slave 上，所以从 Master 同步到 Slave 机器有一定的延迟，当<font color='red'>系统很繁忙</font>的时候，延迟问题会更加严重，<font color='red'>Slave 机器数量的增加</font>也会使这个问题更加严重。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230807210259342.png\" alt=\"image-20230807210259342\" /></p>\n</blockquote>\n</li>\n<li>\n<p><font color='red'>**master 挂了咋办？** 默认情况下，不会从 slave 中重选一个 master，岂不是群龙无首？系统会陷入半瘫痪状态（只能读取，不能写入）</font>那客户端的写命令如何执行啊？</p>\n<blockquote>\n<p>期待有一种高可用的备份、恢复机制，能够从剩下的 slave 中选出一个 master！（<strong><font color='red'>无人值守安装：哨兵！</font></strong>）</p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"9-redis哨兵sentinel\"><a class=\"anchor\" href=\"#9-redis哨兵sentinel\">#</a> 9、Redis 哨兵（sentinel）</h2>\n<blockquote>\n<p>Redis 为了支持高可用，有 2 套机制：</p>\n<ul>\n<li>主从复制（replica）+ 哨兵（sentinel）</li>\n<li>集群（cluster）</li>\n</ul>\n</blockquote>\n<h3 id=\"简介-8\"><a class=\"anchor\" href=\"#简介-8\">#</a> 简介</h3>\n<p>哨兵（sentinel）巡查监控后台 master 是否故障，如果故障了根据 **<font color='orange'>投票数</font>** 自动将某一个 slave 转换为新 master，继续对外服务。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230808215652689.png\" alt=\"image-20230808215652689\" /></p>\n<p>哨兵的作用：</p>\n<ul>\n<li>\n<p><strong>主从监控</strong>：哨兵能监控主从 Redis 库是否正常运行</p>\n</li>\n<li>\n<p><strong>故障转移</strong>：如果 master 异常，哨兵会将根据投票数将某个 slave 转为新的 master，即主从切换</p>\n</li>\n<li>\n<p><strong>消息通知</strong>：哨兵可将故障转移的结果发送给客户端</p>\n</li>\n<li>\n<p><strong>配置中心</strong>：客户端通过连接哨兵来获得当前 Redis 服务的 master 地址</p>\n</li>\n</ul>\n<h3 id=\"案例演示-2\"><a class=\"anchor\" href=\"#案例演示-2\">#</a> 案例演示</h3>\n<h4 id=\"架构说明-2\"><a class=\"anchor\" href=\"#架构说明-2\">#</a> 架构说明</h4>\n<p>3 个哨兵：自动监控和维护集群，不存放数据</p>\n<blockquote>\n<p>哨兵必须要配置集群，且数量最好是奇数，方便投票。</p>\n</blockquote>\n<p>3 个 Redis 库（1 主 2 从）：用于数据读取和存放</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230808002037403.png\" alt=\"image-20230808002037403\" /></p>\n<h4 id=\"哨兵配置文件sentinelconf\"><a class=\"anchor\" href=\"#哨兵配置文件sentinelconf\">#</a> 哨兵配置文件 ( <code>sentinel.conf</code> )</h4>\n<blockquote>\n<p>默认在 /opt/redis-7.0.0 目录下</p>\n</blockquote>\n<p>重点参数说明：</p>\n<ul>\n<li>\n<p><code>bind</code> ：服务监听地址，用于客户端连接，默认为本机地址</p>\n</li>\n<li>\n<p><code>daemonize</code> ：是否以后台 daemon（后台进程）方式运行，设为 yes</p>\n</li>\n<li>\n<p><code>protected-mode</code> ：是否开启安全保护模式，设为 no，否则影响远程访问 / 连接</p>\n</li>\n<li>\n<p><code>port</code> ：端口，默认是 26379</p>\n</li>\n<li>\n<p><code>logfile</code> ：日志文件路径</p>\n</li>\n<li>\n<p><code>pidfile</code> ：pid 文件路径</p>\n</li>\n<li>\n<p><code>dir</code> ：工作目录</p>\n</li>\n<li>\n<p><strong> <code>sentinel monitor &lt;master-name&gt; &lt;master-ip&gt; &lt;master-port&gt; &lt;quorum&gt;</code> </strong>：设置哨兵要监控的 master</p>\n<ul>\n<li>\n<p><code>quorum</code> ：<strong>确认<font color='cornflowerblue'>客观下线</font>的最少哨兵数量</strong>，同意故障迁移的法定<strong>投票数</strong>。</p>\n<blockquote>\n<p>sentinel 通过<strong>定时向 master 发出 PING 包</strong>来确认 master 是否挂掉。</p>\n<p>但网络是不可靠的，有时某个 sentinel 可能因为<strong>网络拥堵</strong>没收到 master 的响应，从而<strong>误以为 master 已挂掉</strong>。因此需要多个 sentinel 都一致任务 master 已挂，才可进行主从切换、故障转移，保证了公平性和高可用。</p>\n</blockquote>\n</li>\n</ul>\n</li>\n<li>\n<p><code>sentinel auth-pass &lt;master-name&gt; &lt;password&gt;</code> ：设置连接 master 服务器的密码</p>\n</li>\n<li>\n<p><strong> <code>sentinel down-after-milliseconds &lt;master-name&gt; &lt;milliseconds&gt;</code> </strong>：指定如果 master 在多少毫秒之后没有应答 sentinel，sentinel 则主观上认为 master 下线（<strong><font color='cornflowerblue'>主观下线</font></strong>）</p>\n</li>\n<li>\n<p><code>sentinel parallel-syncs &lt;master-name&gt; &lt;nums&gt;</code> ：表示允许并行同步的 slave 个数，当 master 挂了后，哨兵会选出新的 master，此时，剩余的 slave 会向新的 master 发起同步数据</p>\n</li>\n<li>\n<p><code>sentinel failover-timeout &lt;master-name&gt; &lt;milliseconds&gt;</code> ：故障转移的超时时间，进行故障转移时，如果超过设置的毫秒，表示故障转移失败</p>\n</li>\n<li>\n<p><code>sentinel notification-script &lt;master-name&gt; &lt;script-path&gt; </code> ：配置当某一事件发生时所需要执行的脚本</p>\n</li>\n<li>\n<p><code>sentinel client-reconfig-script &lt;master-name&gt; &lt;script-path&gt;</code> ：客户端重新配置 master 参数脚本</p>\n</li>\n</ul>\n<h4 id=\"本次案例中sentinelconf的通用配置\"><a class=\"anchor\" href=\"#本次案例中sentinelconf的通用配置\">#</a> 本次案例中 sentinel.conf 的通用配置</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230808105627695.png\" alt=\"image-20230808105627695\" /></p>\n<p>由于机器硬件关系，我们的 3 个哨兵都同时配置进 192.168.111.169 同一台机器，即<font color='red'>3 个哨兵和 master 在一台机器上</font>。</p>\n<p>配置这 3 个哨兵的配置文件：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230808104641977.png\" alt=\"image-20230808104641977\" /></p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230808104655030.png\" alt=\"image-20230808104655030\" /></p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230808104707250.png\" alt=\"image-20230808104707250\" /></p>\n<p>master 配置文件说明：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230808104812771.png\" alt=\"image-20230808104812771\" /></p>\n<h4 id=\"先测试正常的主从复制一主二从\"><a class=\"anchor\" href=\"#先测试正常的主从复制一主二从\">#</a> 先测试正常的主从复制（一主二从）</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230807201752116.png\" alt=\"image-20230807201752116\" /></p>\n<ol>\n<li>169 机器上新建 redis6379.conf 配置文件，由于 6379 后续可能会变成从机，需要设置访问新主机的密码， 请设置 masterauth 项访问密码为 111111，不然后续可能报错 master_link_status:down</li>\n<li>172 机器上新建 redis6380.conf 配置文件，设置好 <code>replicaof \\&lt;masterip&gt; \\&lt;masterport&gt;</code> ，以及 masterauth 项访问密码为 111111</li>\n<li>173 机器上新建 redis6381.conf 配置文件，设置好 <code>replicaof \\&lt;masterip&gt; \\&lt;masterport&gt;</code> ，以及 masterauth 项访问密码为 111111</li>\n<li>启动 3 台机器实例：\n<ol>\n<li><code>redis-cli -a 111111 -p 6379</code></li>\n<li><code>redis-cli -a 111111 -p 6380</code></li>\n<li><code>redis-cli -a 111111 -p 6381</code></li>\n</ol>\n</li>\n<li>测试</li>\n</ol>\n<h4 id=\"哨兵来了\"><a class=\"anchor\" href=\"#哨兵来了\">#</a> 哨兵来了！</h4>\n<blockquote>\n<p>sentinel 之间通过 master 来获取：</p>\n<ul>\n<li>slave 信息</li>\n<li>其他 sentinel 信息</li>\n</ul>\n<p>从而实现通信。</p>\n</blockquote>\n<ol>\n<li>\n<p>在 master（6379）这台机器上<font color='red'>启动 3 个 sentinel</font>（26379/26380/26381），完成监控</p>\n<ol>\n<li><code>redis-sentinel sentinel26379.conf --sentinel</code></li>\n<li><code>redis-sentinel sentinel26380.conf --sentinel</code></li>\n<li><code>redis-sentinel sentinel26381.conf --sentinel</code></li>\n</ol>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230808110202022.png\" alt=\"image-20230808110202022\" /></p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230808110255818.png\" alt=\"image-20230808110255818\" /></p>\n</li>\n<li>\n<p>查看哨兵的日志文件 <code>sentinel26379.log</code> ，可以看到<font color='red'>当前 sentinel 的信息</font>、<font color='red'>所监控 master 以及 slave 的信息</font>、<font color='red'>其他 sentinel 的信息</font>：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230808111127304.png\" alt=\"image-20230808111127304\" /></p>\n</li>\n<li>\n<p>再测试一次主从复制，木有问题</p>\n</li>\n</ol>\n<h4 id=\"master挂了\"><a class=\"anchor\" href=\"#master挂了\">#</a> master 挂了！</h4>\n<p>通过命令 <code>SHUTDOWN</code>  手动关闭 6379 服务器，模拟 master 挂掉。</p>\n<p>思考以下问题：</p>\n<ul>\n<li>\n<p>问题 1：<font color='red'>两台 slave 上的数据还 OK！</font></p>\n</li>\n<li>\n<p>问题 2：** 会从这两台 slave 上选出新的 master！** 具体信息可查看 sentinel 的 log 文件。</p>\n<blockquote>\n<p>在此过程中，哨兵配置文件 <code>sentinel.conf</code>  中会自动生成内容信息</p>\n</blockquote>\n</li>\n<li>\n<p>问题 3：<strong>down 机的旧 master 重启归来，也只能拜认新 master，作它的 slave！</strong></p>\n</li>\n</ul>\n<p>在 master6379 宕机后，会出现两种错误：</p>\n<ul>\n<li>\n<p>Error：Server closed the connection</p>\n</li>\n<li>\n<p>Error：Broken pipe</p>\n<blockquote>\n<p><strong>broken pipe</strong>：pipe 是管道的意思，管道里面是数据流，通常是从文件或网络套接字读取的数据。<font color='red'>当该管道从另一端突然关闭时，会发生数据突然中断</font>，即是 broken，对于 socket 来说，可能是网络被拔出或另一端的进程崩溃。</p>\n<p><strong>如何解决</strong>：当该异常产生的时候，<font color='red'>对于服务端来说，并没有多少影响</font>。因为可能是某个客户端突然中止了进程导致了该错误。</p>\n<p><strong>总结</strong>：这个异常是<font color='red'>客户端读取超时</font>关闭了连接，这时候服务器端再向客户端已经断开的连接写数据时就发生了 broken pipe 异常！</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230808113740061.png\" alt=\"image-20230808113740061\" /></p>\n</blockquote>\n</li>\n</ul>\n<p>针对本次案例，分析谁是 master：</p>\n<ol>\n<li>6381 被选为新 master，上位成功</li>\n<li>以前的 6379 从 master 降级变成了 slave</li>\n<li>6380 还是 slave，只不过换了个新老大 6381 (6379 变 6381)，6380 还是 slave</li>\n</ol>\n<h4 id=\"对比新老master的配置文件\"><a class=\"anchor\" href=\"#对比新老master的配置文件\">#</a> 对比新老 master 的配置文件</h4>\n<p>旧 master  <code>redis6379.conf</code>  中会自动生成以下内容，让 6379 去做 6381 的 slave：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230808115231877.png\" alt=\"image-20230808115231877\" /></p>\n<p>新 master  <code>redis6381.conf</code>  中：</p>\n<ul>\n<li>自动删掉 <code>replicaof</code>  参数的配置</li>\n<li>自动生成以下内容：</li>\n</ul>\n<p>结论：</p>\n<ul>\n<li>conf 文件的内容会被 sentinel 动态更改</li>\n<li>Master-Slave 切换后，master_redis.conf、slave_redis.conf 和 sentinel.conf 的内容都会发生改变，即<font color='red'>master_redis.conf 中会多一行 slaveof 的配置</font>，<font color='red'>sentinel.conf 的监控目标会随之调换</font></li>\n</ul>\n<h4 id=\"其他备注\"><a class=\"anchor\" href=\"#其他备注\">#</a> 其他备注</h4>\n<ul>\n<li>生产都是不同机房不同服务器，<strong>很少出现哨兵全挂掉的情况</strong></li>\n<li><strong>可以同时监控多个 master</strong>，一行一个</li>\n</ul>\n<h3 id=\"哨兵运行流程-选举原理\"><a class=\"anchor\" href=\"#哨兵运行流程-选举原理\">#</a> <mark>哨兵运行流程、选举原理</mark></h3>\n<blockquote>\n<p>面试重点</p>\n</blockquote>\n<p>当一个主从配置中的 master 失效之后，sentinel 可以从 slave 中选举出一个新的 master，用于接替原 master 的工作。</p>\n<p>主从配置中的<font color='red'>其他 redis 服务器自动指向新的 master 同步数据</font>。</p>\n<p>一般<font color='red'>建议 sentinel 采取奇数台</font>，一是防止某一台 sentinel 无法连接到 master 导致误切换，二是利于投票选举。</p>\n<p>故障切换的流程：</p>\n<ol>\n<li>\n<p>3 个 sentinel 监控一 master 二 slave，正常运行中</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230808161905591.png\" alt=\"image-20230808161905591\" /></p>\n</li>\n<li>\n<p><strong><font color='cornflowerblue'>SDown 主观下线（Subjectively Down）</font></strong>：指的是<font color='red'>单个 Sentinel 实例</font>对 master 服务器做出的下线判断（有可能是接收不到订阅，之间的网络不通等等原因）。如果 master 服务器在 [ <code>sentinel down-after-milliseconds</code> ] 给定的毫秒数之内没有回应 PING 命令或者返回一个错误消息，那么这个 Sentinel 会主观的 (<font color='red'>单方面的</font>) 认为这个 master 不可以用了。</p>\n<blockquote>\n<p>sentinel 配置文件中的 <code>sentinel down-after-milliseconds &lt;masterName&gt; &lt;timeout&gt;</code>  设置了判断主观下线的时间长度，表示 master 被当前 sentinel 实例认定为失效的间隔时间。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230808162539926.png\" alt=\"image-20230808162539926\" /></p>\n</blockquote>\n</li>\n<li>\n<p><strong><font color='cornflowerblue'>ODown 客观下线（Objectively Down）</font></strong>：需要一定数量的 sentinel，<font color='red'>多个哨兵达成一致意见</font>才能认为一个 master 客观上已经宕掉。</p>\n<blockquote>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230808162827271.png\" alt=\"image-20230808162827271\" /></p>\n<ul>\n<li><code>master-name</code>  是对某个 master+slave 组合的一个区分标识 (一套 sentinel 可以监听多组 master+slave 这样的组合)</li>\n<li><strong> <code>quorum</code>  这个参数是进行客观下线的一个依据</strong>，即法定人数 / 法定票数。意思是至少有 quorum 个 sentinel 认为这个 master 有故障才会对这个 master 进行下线以及故障转移。因为有的时候，某个 sentinel 节点可能因为自身网络原因导致无法连接 master，而此时 master 并没有出现故障，所以这就需要多个 sentinel 都一致认为该 master 有问题，才可以进行下一步操作，这就保证了公平性和高可用。</li>\n</ul>\n</blockquote>\n</li>\n<li>\n<p>从哨兵中选出<strong>兵王</strong>：当 master 被判断 ODown 以后，各个 sentinel 节点会进行协商，先通过<font color='orange'>Raft 算法</font>选举出一个兵王，<font color='red'>由它进行 failover (故障迁移)</font>。</p>\n<blockquote>\n<p>监视该主节点的所有哨兵都有可能被选为领导者，选举使用的算法是 Raft 算法，其基本思路是 **<font color='red'>先到先得</font>**：即在一轮选举中，哨兵 A 向 B 发送成为领导者的申请，如果 B 没有同意过其他哨兵，则会同意 A 成为领导者。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230808164314705.png\" alt=\"image-20230808164314705\" /></p>\n</blockquote>\n<p>从三个 sentinel 实例的 log 文件中可以看见兵王的诞生过程以及兵王执行故障迁移的过程：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230808163922904.png\" alt=\"image-20230808163922904\" /></p>\n<center>sentinel26379.log</center>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230808163958440.png\" alt=\"image-20230808163958440\" /></p>\n<center><font color='red'>sentinel26380.log</font></font></center>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230808164037410.png\" alt=\"image-20230808164037410\" /></p>\n<center>sentinel26381.log</center>\n</li>\n<li>\n<p><strong><font color='orange'>兵王开始故障切换，选举新的 master</font></strong>：</p>\n<ol>\n<li>\n<p><strong>新主登基</strong>：**<font color='orange'>新 master 选举算法</font>** 如下：</p>\n<ol>\n<li>\n<p><font color='gree'>优先级高</font>：所有 slave 中，根据 redis.conf 配置文件中的优先级 <code>slave-priority</code>  或者 <code>replica-priority</code> ，选择优先级最高的 slave 作为新 master。</p>\n<blockquote>\n<p>数字越小优先级越高</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230808170206385.png\" alt=\"image-20230808170206385\" /></p>\n</blockquote>\n</li>\n<li>\n<p><font color='gree'>复制偏移大</font>：所有 slave 中，根据复制偏移位置 <code>offset</code> ，该值最大的 slave 作为新 master。</p>\n</li>\n<li>\n<p><font color='gree'>Run ID 小</font>：所有 slave 中，选择 Run ID 最小的 slave 作为新 master，是按照字典顺序，ASCII 码。</p>\n</li>\n</ol>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230808165640759.png\" alt=\"image-20230808165640759\" /></p>\n</li>\n<li>\n<p><strong>群臣俯首</strong>：一朝天子一朝臣，换个码头重新拜</p>\n<ol>\n<li>Sentinel leader 会对选举出的 slave 执行 <code>SLAVEOF NO ONE</code>  命令，将其提拔为新 master</li>\n<li>Sentinel leader 向其余 slave 发送 <code>SLAVEOF</code>  命令，使它们成为新 master 的 slave</li>\n</ol>\n</li>\n<li>\n<p><strong>旧主拜服</strong>：老 master 回来也认怂</p>\n<ol>\n<li>老 master 成为新 master 的 slave</li>\n<li>Sentinel leader 会让老 master 降级为 slave，并恢复正常工作</li>\n</ol>\n</li>\n</ol>\n<p>总结：上述 failover（故障迁移）均由 sentinel 独自完成，无需人工干预，因此称之为<strong>无人值守安装</strong>！</p>\n</li>\n</ol>\n<h3 id=\"哨兵使用建议\"><a class=\"anchor\" href=\"#哨兵使用建议\">#</a> 哨兵使用建议</h3>\n<ol>\n<li>\n<p><strong>哨兵的数量应为多个且奇数</strong>。哨兵本身应该集群，保证高可用。</p>\n</li>\n<li>\n<p><strong>各个哨兵的配置应一致</strong>。</p>\n</li>\n<li>\n<p>如果哨兵部署在 Docker 等容器里面，尤其要<font color='red'>注意端口的正确映射</font>。</p>\n</li>\n<li>\n<p><code>主从复制 + 哨兵</code> 机制<strong>并不能确保数据零丢失</strong>。因为从 master 挂掉到选举出新 master 的这段时间内，无法执行写命令！</p>\n<blockquote>\n<p>引出<strong>集群</strong></p>\n</blockquote>\n</li>\n</ol>\n<h2 id=\"10-redis集群cluster\"><a class=\"anchor\" href=\"#10-redis集群cluster\">#</a> <mark>10、Redis 集群（cluster）</mark></h2>\n<blockquote>\n<p>我尼玛又白雪，<strong>集群才是 yyds！</strong></p>\n</blockquote>\n<h3 id=\"简介-9\"><a class=\"anchor\" href=\"#简介-9\">#</a> 简介</h3>\n<p><strong><font color='red'>由于数据量过大</font></strong>，<font color='red'>单个 Master 复制集</font>难以承担，因此需要对多个复制集进行集群，形成<font color='red'>水平扩展</font>每个复制集<font color='red'>只负责存储整个数据集的一部分</font>，这就是 Redis 的集群。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230808220609079.png\" alt=\"image-20230808220609079\" /></p>\n<p>总之，Redis 集群是<font color='red'>一个提供在多个 Redis 节点间共享数据的程序集</font>。其功能总结如下：</p>\n<ul>\n<li><strong>支持多个 Master</strong>，每个 Master 又可以挂载多个 Slave。\n<ul>\n<li>读写分离</li>\n<li>支持数据的高可用</li>\n<li>支持海量数据的读写存储操作</li>\n</ul>\n</li>\n<li><strong>自带 failover（故障转移）机制</strong>，内置了高可用的支持，<font color='red'>无需再去使用哨兵功能</font>。</li>\n<li><strong>客户端只需连接集群中的任意一个可用 Master 节点即可</strong>，不需要连接集群中的所有 Master 节点。</li>\n<li><strong>槽位 slot</strong> 负责分配到各个物理服务节点，由对应的集群来负责<strong>维护 Redis 节点、插槽、数据之间的关系</strong>。</li>\n</ul>\n<h3 id=\"集群算法-分片-槽位slot\"><a class=\"anchor\" href=\"#集群算法-分片-槽位slot\">#</a> 集群算法、分片、槽位 slot</h3>\n<h4 id=\"官网介绍\"><a class=\"anchor\" href=\"#官网介绍\">#</a> 官网介绍</h4>\n<p>Redis 集群的 key 空间被划分为<strong> 16384 个插槽 slot</strong>，有效地设置了 16384 个 master 节点的集群大小上限（然而，<strong>master 节点的最大数量建议为 1000</strong>）。</p>\n<blockquote>\n<p>插槽，也称哈希槽</p>\n</blockquote>\n<p>集群中的<font color='red'>每个 master 节点处理 16384 个哈希槽的子集</font>。当没有正在进行的集群重新配置时（即哈希槽从一个节点移动到另一个节点），集群是稳定的。当集群稳定时，单个哈希槽将由单个节点提供服务（但是，服务节点可以有一个或多个副本，在网络分裂或故障的情况下，这些副本将替换它，并且可以用于扩展读取过时数据的读取操作）。</p>\n<p>用于将 key 映射到哈希槽的基本算法如下（请阅读下一段以了解此规则的哈希标记异常）：</p>\n<pre><code>HASH_SLOT = CRC16(key) mod 16384\n</code></pre>\n<h4 id=\"插槽\"><a class=\"anchor\" href=\"#插槽\">#</a> 插槽</h4>\n<p>Redis 集群没有使用一致性哈希算法，而是引入了 <code>hash槽</code> 的概念。<br />\nRedis 集群有 16384 个哈希槽，<strong>每个 key 通过 <code>CRC16</code>  校验后，再对 16384 取模来决定放置哪个槽</strong>。集群的<strong>每个 Redis 节点负责一部分 hash 槽</strong>。</p>\n<p>举个例子，比如当前集群有 3 个节点，那么：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230809002715513.png\" alt=\"image-20230809002715513\" /></p>\n<h4 id=\"数据分片\"><a class=\"anchor\" href=\"#数据分片\">#</a> 数据分片</h4>\n<p><code>数据分片</code> ：Redis 集群中会<font color='red'>将存储的数据分散到多台 redis 机器上</font>。每个 Redis 实例都被认为是整个数据的一个分片。</p>\n<p><font color='gree'>如何找到给定 key 的分片？</font></p>\n<ol>\n<li>对 key 进行<font color='red'>CRC16(key)</font>算法处理，并通过对总分片数量<font color='red'>取模</font>。</li>\n<li>然后，使用<font color='red'><strong>确定性哈希函数</strong></font>，这意味着 **<font color='red'>给定的 key 将始终映射到同一个分片</font>**，我们可以推断将来读取特定 key 的位置。</li>\n</ol>\n<h4 id=\"分片插槽的优点\"><a class=\"anchor\" href=\"#分片插槽的优点\">#</a> 分片 + 插槽的优点</h4>\n<ul>\n<li>\n<p><strong>方便 Redis 节点的扩容和缩容</strong>。</p>\n<blockquote>\n<ul>\n<li>添加 Redis 节点：比如我想新添加个节点 D，我需要从节点 A，B，C 中移动部分槽到 D 上。</li>\n<li>删除 Redis 节点：如果我想移除节点 A，需要将 A 中的槽移到 B 和 C 节点上，然后将没有任何槽的 A 节点从集群中移除即可。</li>\n<li>由于从一个节点将哈希槽移动到另一个节点并不会停止服务，所以<strong>无论添加删除节点，或者改变某个节点的哈希槽的数量都<font color='red'>不会造成集群不可用的状态</font></strong>。</li>\n</ul>\n</blockquote>\n</li>\n<li>\n<p><strong>方便数据的分派和查找</strong>。</p>\n</li>\n</ul>\n<h4 id=\"槽位映射的3种方案\"><a class=\"anchor\" href=\"#槽位映射的3种方案\">#</a> 槽位映射的 3 种方案</h4>\n<h5 id=\"哈希取余分区\"><a class=\"anchor\" href=\"#哈希取余分区\">#</a> 哈希取余分区</h5>\n<blockquote>\n<p>小厂</p>\n</blockquote>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230809004525207.png\" alt=\"image-20230809004525207\" /></p>\n<p>假设有 N 台机器构成一个集群，用户每次对 key 的读写操作都是根据公式：</p>\n<pre><code>hash(key) % N\n</code></pre>\n<p>计算出哈希值，用来决定数据映射到哪一个节点上。</p>\n<p><font color='gree'>优点</font>：</p>\n<ul>\n<li>简单有效。只需要预估好数据规模，规划好节点，就能保证一段时间的数据支撑。</li>\n<li>负载均衡。使用 Hash 算法让固定的一部分请求落到同一台服务器上，这样<font color='red'>每台服务器固定处理一部分请求</font>（并维护这些请求的信息）。</li>\n</ul>\n<p><font color='gree'>缺点</font>：</p>\n<ul>\n<li><strong>Redis 节点的扩容 / 缩容麻烦</strong>。如果需要弹性扩容或故障停机，导致节点有变动，映射关系需要重新进行计算。原来的取模公式就会发生变化： <code>Hash(key)/3</code>  会变成 <code>Hash(key) /?</code> 。此时地址经过取余运算的结果将发生很大变化，<font color='red'>根据公式获取的服务器也会变得不可控</font>。</li>\n<li>某个 Redis 机器宕机了，由于台数数量变化，会导致 hash 取余全部数据重新洗牌。</li>\n</ul>\n<h5 id=\"一致性哈希算法分区\"><a class=\"anchor\" href=\"#一致性哈希算法分区\">#</a> 一致性哈希算法分区</h5>\n<blockquote>\n<p>一致性：意味着取余的分母是固定的。</p>\n</blockquote>\n<p><font color='gree'>设计目标</font>：为了解决<font color='red'>分布式缓存数据变动和映射问题</font>，某个机器宕机了，分母数量改变了，自然取余数不 OK 了。目的是<font color='red'>当 Redis 服务器个数发生变动时，尽量减少客户端到服务器的映射关系的影响</font>。</p>\n<p><strong><font color='gree'>3 大步骤</font></strong>：</p>\n<ol>\n<li>\n<p><strong>构建一致性哈希环</strong>：</p>\n<p>一致性哈希算法必然有个 hash 函数用于产生 hash 值，这个算法的所有可能哈希值会构成一个<font color='red'>全量集</font>，这个集合可以成为一个 **<font color='red'>hash 空间 [0,2<sup>32</sup>-1]</font><strong>，这个是一个线性空间，但是在算法中，我们通过适当的逻辑控制将它</strong><font color='red'>首尾相连 (0 = 2<sup>32</sup>)</font>**, 这样让它形成了一个<font color='red'>逻辑上的环形空间</font>。</p>\n<p>它也是按照使用取模的方法，<font color='red'>前面介绍的是对 Redis 节点的数量进行取模</font>。而 **<font color='orange'>一致性 Hash 算法是对 2<sup>32</sup> 取模</font>**。</p>\n<p>简单来说，一致性 Hash 算法将整个哈希值空间组织成一个虚拟的圆环，如假设某哈希函数的值空间为 [0,2<sup>32</sup>-1]（即哈希值是一个 32 位无符号整形），整个哈希环如下图：整个空间按顺时针方向组织，圆环的正上方的点代表 0，0 点右侧的第一个点代表 1，以此类推，2、3、4、…… 直到 2<sup>32</sup>-1，也就是说<font color='red'>0 点左侧的第一个点代表 2<sup>32</sup>-1</font>， 0 和 2<sup>32</sup>-1 在零点中方向重合，我们把这个 **<font color='red'>由 2<sup>32</sup> 个点组成</font>** 的圆环称为 <code>Hash环</code> 。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230809010605612.png\" alt=\"image-20230809010605612\" /></p>\n</li>\n<li>\n<p><strong>Redis 服务器节点 IP 映射</strong>：</p>\n<p>将集群中各个 Redis 节点的 IP 映射到环上的某一个位置。</p>\n<p>将各个 Redis 服务器的 IP 或主机名作为关键字使用 Hash 进行哈希，这样每台机器就能确定其在哈希环上的位置。假如 4 个 Redis 节点 NodeA、NodeB、NodeC、NodeD，经过<font color='red'>IP 地址的哈希函数计算 hash (ip)</font>，使用 IP 地址哈希后在环空间的位置如下：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230809114247849.png\" alt=\"image-20230809114247849\" /></p>\n</li>\n<li>\n<p><strong>落 key 规则</strong>：</p>\n<p>当我们需要存储一个键值对时，<font color='red'>首先计算 key 的 hash 值，hash (key)</font>，确定此数据在环上的位置，从此位置沿环 **<font color='red'>顺时针</font>**“行走”，<font color='red'>第一台遇到的 Redis 服务器</font>就是其应该定位到的服务器，并将该键值对存储在该节点上。</p>\n<p>如我们有 Object A、Object B、Object C、Object D 四个数据对象，经过哈希计算后，在环空间上的位置如下：根据一致性 Hash 算法，Object A 会被定为到 Node A 上，Object B 被定为到 Node B 上，Object C 被定为到 Node C 上，Object D 被定为到 Node D 上。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230809114625589.png\" alt=\"image-20230809114625589\" /></p>\n</li>\n</ol>\n<p><font color='gree'>优点</font>：</p>\n<ul>\n<li>\n<p><strong>容错性</strong></p>\n<blockquote>\n<p>假设 Node C 宕机，可以看到此时对象 A、B、D 不会受到影响。一般的，在一致性 Hash 算法中，如果一台服务器不可用，则受影响的数据仅仅是此服务器到其环空间中前一台服务器（即沿着逆时针方向行走遇到的第一台服务器）之间数据，其它不会受到影响。<font color='red'>简单说，就是 C 挂了，受到影响的只是 B、C 之间的数据，且这些数据会转移到 D 进行存储</font>。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230809115305990.png\" alt=\"image-20230809115305990\" /></p>\n</blockquote>\n</li>\n<li>\n<p><strong>扩展性</strong></p>\n<blockquote>\n<p>随着数据量的增加，需要增加一台节点 NodeX，位置在 A 和 B 之间，<font color='red'>那受到影响的也就是 A 到 X 之间的数据，重新把 A 到 X 的数据录入到 X 上即可，不会导致 hash 取余全部数据重新洗牌</font>。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230809120153493.png\" alt=\"image-20230809120153493\" /></p>\n</blockquote>\n</li>\n</ul>\n<p><font color='gree'>缺点</font>：<strong>数据倾斜</strong>问题</p>\n<blockquote>\n<p>在<strong> Redis 服务节点太少时</strong>，容易因为<font color='red'>节点分布不均匀</font>而造成<strong>数据倾斜</strong>（被缓存的数据对象大部分集中缓存在某一台服务器上）问题。</p>\n<p>例如系统中只有两台服务器：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230809120432504.png\" alt=\"image-20230809120432504\" /></p>\n</blockquote>\n<p><font color='gree'>小结</font>：</p>\n<ul>\n<li>设计目标：在 Redis 节点的数目发生改变时，尽可能地减少数据的迁移</li>\n<li>设计思路：将所有的 Redis 节点排列在首尾相接的 Hash 环上，每个 key 在计算 Hash 后会<font color='red'>顺时针</font>找到临近的 Redis 节点存放。而当有 Redis 节点加入或退出时仅影响该节点在 Hash 环上<font color='red'>顺时针相邻的后续节点</font>。</li>\n<li>优点：加入和删除节点只影响哈希环中顺时针方向的相邻的节点，对其他节点无影响。</li>\n<li>缺点：数据的分布和节点的位置有关，因为这些节点不是均匀的分布在哈希环上的，所以数据在进行存储时达不到均匀分布的效果。</li>\n</ul>\n<h5 id=\"哈希槽分区\"><a class=\"anchor\" href=\"#哈希槽分区\">#</a> 哈希槽分区 (√)</h5>\n<blockquote>\n<p>大厂</p>\n</blockquote>\n<p><font color='gree'>为什么出现</font>：因为一致性哈希算法具有数据倾斜的问题。</p>\n<p><font color='gree'>哈希槽是什么</font>：哈希槽实质是<font color='red'>一个数组</font>，<font color='red'>哈希槽空间为 [0,2<sup>14</sup>-1]</font>。</p>\n<blockquote>\n<p>2<sup>14</sup>=16384</p>\n</blockquote>\n<p><font color='gree'>能干嘛</font>：</p>\n<p><strong>解决数据分配不均匀的问题</strong>，在数据和节点之间又加入了一层，把这层称为 <code>哈希槽（slot）</code> ，用于<font color='red'>管理数据和节点之间的关系</font>，现在就相当于节点上放的是槽，槽里放的是数据。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230809130342790.png\" alt=\"image-20230809130342790\" /></p>\n<p>槽解决的是粒度问题，相当于<font color='red'>把粒度变大了，这样便于数据移动</font>。</p>\n<p>哈希解决的是映射问题，<font color='red'>使用 key 的哈希值来计算所在的槽，便于数据分配</font>。</p>\n<p><font color='gree'>哈希槽的个数</font>：</p>\n<p><strong>一个集群只能有 16384 个哈希槽</strong>，编号 0-16383（0-2<sup>14</sup>-1）。<font color='red'>这些槽会分配给集群中的所有 master 节点</font>，分配策略没有要求。</p>\n<p>集群会<font color='red'>记录 Redis 节点和槽的对应关系</font>，解决了节点和槽的关系后，接下来就需要<font color='red'>对 key 求哈希值，然后对 16384 取模</font>，余数是几 key 就落入对应的槽里。 <code>HASH_SLOT = CRC16(key) mod 16384</code> 。<font color='red'>以槽为单位移动数据</font>，因为槽的数目是固定的，处理起来比较容易，这样数据移动问题就解决了。</p>\n<p><font color='gree'>哈希槽计算</font>：</p>\n<p>Redis 集群中内置了 16384 个哈希槽，redis 会根据节点数量大致均等的将哈希槽映射到不同的节点。当需要在 Redis 集群中放置一个 key-value 时，redis 先对 key 使用 crc16 算法算出一个结果然后用结果对 16384 求余数 [  <code>CRC16(key) % 16384</code> ]，这样每个 key 都会对应一个编号在 0-16383 之间的哈希槽，也就是映射到某个节点上。</p>\n<p>如下代码，key 之 A 、B 在 Node2， key 之 C 落在 Node3 上：</p>\n<p><img data-src=\"C:%5CUsers%5Chuawei%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20230809131108267.png\" alt=\"image-20230809131108267\" /></p>\n<h4 id=\"经典面试题为什么redis集群的最大哈希槽数目是16384个\"><a class=\"anchor\" href=\"#经典面试题为什么redis集群的最大哈希槽数目是16384个\">#</a> <mark>经典面试题：为什么 Redis 集群的最大哈希槽数目是 16384 个？</mark></h4>\n<blockquote>\n<p><font color='red'><strong>CRC16 算法产生的哈希值有 16bit</strong>，即 2<sup>16</sup>=65536 个值，为什么 Redis 集群的算法只采用 2<sup>14</sup>=16384 个哈希槽？</font>在进行 mode 运算时，为什么是 <code>HASH_SLOT = CRC16(key) mod 16384</code>  而不是 <code>HASH_SLOT = CRC16(key) mod 65536</code> ？</p>\n</blockquote>\n<p><font color='gree'>作者的回复</font>：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230809132510614.png\" alt=\"image-20230809132510614\" /></p>\n<p><font color='gree'>消息头 clusterMsg 的结构</font>：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230809132604570.png\" alt=\"image-20230809132604570\" /></p>\n<p><strong><font color='gree'>标准回答</font></strong>：</p>\n<ul>\n<li>\n<p><font color='red'>如果槽位为 65536，发送心跳信息的消息头达 8k，<strong>发送的心跳包过于庞大</strong>。</font></p>\n<blockquote>\n<p>在消息头中最占空间的是 <code>myslots[CLUSTER_SLOTS/8]</code> :</p>\n<ul>\n<li>当槽位为 65536 时，这块的大小是: 65536÷8÷1024=<font color='red'>8kb</font></li>\n<li>当槽位为 16384 时，这块的大小是: 16384÷8÷1024=<font color='red'>2kb</font></li>\n</ul>\n<p>因为每秒钟 redis 节点需要发送一定数量的 ping 消息作为心跳包，如果槽位为 65536，这个<font color='red'>ping 消息的消息头太大了，浪费带宽</font>。</p>\n</blockquote>\n</li>\n<li>\n<p><font color='red'>对于基本不可能超过 1000 个 master 节点数量的 redis 集群而言，<strong>16384 个槽位就已经够用了</strong>。</font></p>\n<blockquote>\n<p>集群的节点越多，心跳包的消息体内携带的数据越多。如果节点过 1000 个，也会导致网络拥堵。因此 redis 作者不建议 redis cluster 节点数量超过 1000 个。那么，<font color='red'>对于节点数在 1000 以内的 redis cluster 集群，16384 个槽位够用了</font>。没有必要拓展到 65536 个。</p>\n</blockquote>\n</li>\n<li>\n<p><font color='red'>槽位越小，节点少的情况下，<strong>压缩比高，容易传输</strong></font></p>\n<blockquote>\n<p>Redis 的 master 节点的配置信息中它所负责的哈希槽是通过一张 bitmap 的形式来保存的，在传输过程中会对 bitmap 进行压缩，但是<font color='red'>如果 bitmap 的填充率 slots / N 很高的话 (N 表示节点数)，bitmap 的压缩率就很低</font>。如果节点数很少，而哈希槽数量很多的话，bitmap 的压缩率就很低。</p>\n</blockquote>\n</li>\n</ul>\n<h4 id=\"redis集群不保证强一致性\"><a class=\"anchor\" href=\"#redis集群不保证强一致性\">#</a> Redis 集群不保证强一致性</h4>\n<p><strong>Redis 集群不保证强一致性</strong>，这意味着在特定的条件下，Redis 集群<font color='red'>可能会丢掉一些被系统收到的写入请求命令</font>。</p>\n<p>Redis 集群使用<font color='red'>节点之间的异步复制</font>，最后一次故障切换隐式合并功能。这意味着<font color='red'>最后一次选择的主数据会完全替换所有其他副本</font>。在分区期间，<font color='red'>总是有一个可能丢失写入的时间窗口</font>。然而，在连接到大多数主数据的客户端的情况下，这些窗口非常不同，以及与少数 master 有联系的客户。</p>\n<h3 id=\"案例演示-3\"><a class=\"anchor\" href=\"#案例演示-3\">#</a> 案例演示</h3>\n<h4 id=\"3主3从redis集群配置\"><a class=\"anchor\" href=\"#3主3从redis集群配置\">#</a> 3 主 3 从 redis 集群配置</h4>\n<p>在 3 台虚拟机上新建 6 个独立的 Redis 实例服务，每台机器上一主一从，<font color='gree'>设计图</font>如下：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/IMG_8445(20230809-135635).JPEG\" alt=\"IMG_8445(20230809-135635)\" /></p>\n<p>配置这 6 个 Redis 实例的<font color='gree'>conf 文件</font>，下面以 6381 为例：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230809135942477.png\" alt=\"image-20230809135942477\" /></p>\n<p><font color='gree'>启动</font>6 台 Redis 实例，以 6381 为例： <code>redis-server /myredis/cluster/redisCluster6381.conf</code> 。</p>\n<p>构建 6 个 Redis 实例的<font color='gree'>集群关系</font>，命令如下：</p>\n<p><font color='red'>redis-cli -a 111111 <br/><strong>--cluster create</strong> -<strong>-cluster-replicas 1</strong> <br/> 192.168.111.175:6381 192.168.111.175:6382 <br/> 192.168.111.172:6383 192.168.111.172:6384 <br/> 192.168.111.174:6385 192.168.111.174:6386</font></p>\n<blockquote>\n<p><code>--cluster-replicas 1</code>  表示为每个 master 创建一个 slave 节点，<strong><font color='red'>主从的实际分配是随机的！</font></strong></p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230809141622996.png\" alt=\"image-20230809141622996\" /></p>\n</blockquote>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230809141121945.png\" alt=\"image-20230809141121945\" /></p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230809141157047.png\" alt=\"image-20230809141157047\" /></p>\n<p>启动 6381，查看 6381 的<font color='gree'>主从复制信息</font> <code>info replication</code> ：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230809141652111.png\" alt=\"image-20230809141652111\" /></p>\n<p>查看 6381 的<font color='gree'>集群信息</font> <code>cluster info</code> ：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230809141857437.png\" alt=\"image-20230809141857437\" /></p>\n<p>再查看集群的<font color='gree'>节点信息</font> <code>cluster nodes</code> ：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230809141717499.png\" alt=\"image-20230809141717499\" /></p>\n<blockquote>\n<p>slave 后跟着 master 信息，而 master 后没有 slave 信息。</p>\n<p>目前的主从关系：</p>\n<p>6381 的 slave 是 6384，6383 的 slave 是 6386，6385 的 slave 是 6382。</p>\n</blockquote>\n<h4 id=\"3主3从redis集群读写\"><a class=\"anchor\" href=\"#3主3从redis集群读写\">#</a> 3 主 3 从 redis 集群读写</h4>\n<p><code>redis-cli -a 111111 -p 6381</code>  启动 master 6381，并新增 2 个 key：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230809143452632.png\" alt=\"image-20230809143452632\" /></p>\n<blockquote>\n<p>在设置 k1 时遇到报错，提示 k1 对应的哈希槽是 12706，应该存到 master 6385 上。因此，<strong><font color='red'>要注意槽位的范围区间，需要将 key 路由到正确的槽位上</font></strong>。</p>\n</blockquote>\n<p><font color='gree'>解决方法</font>：** 启动 Redis 实例时添加 <code>-c</code>  参数，表示以集群模式运行，防止路由失效。** 即 <code>redis-cli -a 111111 -p 6381 -c</code> 。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230809144237468.png\" alt=\"image-20230809144237468\" /></p>\n<blockquote>\n<p>此时 key 会<font color='red'>自动重定向</font>到对应 Redis 实例的哈希槽上。</p>\n</blockquote>\n<p><font color='gree'>查看某个 key 对应的槽位置</font>： <code>CLUSTER KEYSLOT key</code> 。</p>\n<h4 id=\"主从容错切换迁移failover\"><a class=\"anchor\" href=\"#主从容错切换迁移failover\">#</a> 主从容错切换迁移 (failover)</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230809144752893.png\" alt=\"image-20230809144752893\" /></p>\n<ol>\n<li>\n<p>假如 master 6381 宕机，其对应的 slave 6384 会上位成为新的 master</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230809145659230.png\" alt=\"image-20230809145659230\" /></p>\n</li>\n<li>\n<p>当 6381 重启恢复，自动成为 master 6384 的 slave</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230809145905827.png\" alt=\"image-20230809145905827\" /></p>\n</li>\n</ol>\n<h4 id=\"手动切换主从调整节点从属关系\"><a class=\"anchor\" href=\"#手动切换主从调整节点从属关系\">#</a> 手动切换主从 / 调整节点从属关系</h4>\n<p>上面一换后 6381、6384 主从对调了，和原始设计图不一样了，该如何恢复原来的主从关系？</p>\n<p><strong>重启 6381，执行命令 <code>CLUSTER FAILOVER</code> ，自动调整 6381 的主从关系</strong>。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230809150634974.png\" alt=\"image-20230809150634974\" /></p>\n<h4 id=\"主从扩容\"><a class=\"anchor\" href=\"#主从扩容\">#</a> 主从扩容</h4>\n<blockquote>\n<p>三主三从 -&gt; 四主四从</p>\n<ol>\n<li>新 master 加入集群</li>\n<li>重新分配槽号（reshard）</li>\n<li>为新 master 分配 slave</li>\n</ol>\n</blockquote>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230809151024511.png\" alt=\"image-20230809151024511\" /></p>\n<p>思考问题：</p>\n<ul>\n<li>如何将新机加入原有集群中？</li>\n<li>新机的槽位如何分配？<strong>重新洗牌！</strong></li>\n</ul>\n<ol>\n<li>\n<p>配置 2 台新机的 redis.conf 文件，以 6387 为例：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230809151526914.png\" alt=\"image-20230809151526914\" /></p>\n</li>\n<li>\n<p>启动 2 台新机，此时它们都是 master：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230809151554375.png\" alt=\"image-20230809151554375\" /></p>\n</li>\n<li>\n<p>将新增的 6387（空槽号）作为<font color='gree'>master 节点加入原有集群</font>，执行命令：</p>\n<p><font color='orange'>redis-cli -a 111111 <br/>--cluster <strong>add-node</strong> <br/>192.168.111.174:6387 <br/>192.168.111.175:6381</font></p>\n<blockquote>\n<ul>\n<li>\n<p>6387 就是将要作为<font color='red'>master 新增节点</font></p>\n</li>\n<li>\n<p>6381 就是原来集群节点里面的<font color='red'>领路人</font>，相当于 6387 拜拜 6381 的码头从而找到组织加入集群</p>\n</li>\n</ul>\n</blockquote>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230809152412183.png\" alt=\"image-20230809152412183\" /></p>\n</li>\n<li>\n<p>检查集群情况，执行命令：</p>\n<p><font color='orange'>redis-cli -a 111111 <br/>--cluster <strong>check</strong> <br/>192.168.111.175:6381</font></p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230809152820379.png\" alt=\"image-20230809152820379\" /></p>\n<blockquote>\n<p>此时新加入的 6387 节点还没分配哈希槽</p>\n</blockquote>\n</li>\n<li>\n<p><font color='gree'>重新分配槽号</font>，执行命令：</p>\n<p><font color='orange'>redis-cli -a 密码 <br/>--cluster <strong>reshard</strong> <br/>192.168.111.175:6381</font></p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230809153203484.png\" alt=\"image-20230809153203484\" /></p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230809153429470.png\" alt=\"image-20230809153429470\" /></p>\n</li>\n<li>\n<p>再次检查集群情况，执行命令：</p>\n<p><font color='orange'>redis-cli -a 111111 <br/>--cluster <strong>check</strong> <br/>192.168.111.175:6381</font></p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230809153519681.png\" alt=\"image-20230809153519681\" /></p>\n<blockquote>\n<p>此时槽号重新分派完成！但是为什么 6387 是 3 个新的区间，以前的还是连续？</p>\n<p><strong>重新分配的成本太高，所以之前的 Redis 节点各自匀出来一部分给新节点</strong>。从 6381/6383/6385 三个旧节点分别匀出 1364 个坑位给新节点 6387。</p>\n</blockquote>\n</li>\n<li>\n<p>为 master 6387<font color='gree'>分配 slave</font> 6388，执行命令：</p>\n<p><font color='orange'>redis-cli -a 密码 <br/>--cluster <strong>add-node</strong> <br/>ip: 新 slave 端口 ip: 新 master 端口 <br/><strong>--cluster-slave</strong> <strong>--cluster-master-id</strong> <strong>新 master 节点 ID</strong></font></p>\n<blockquote>\n<p>redis-cli -a 111111 <br/>--cluster add-node <br/>192.168.111.174:6388 192.168.111.174:6387 <br/>--cluster-slave --cluster-master-id 4feb6a7ee0ed2b39ff86474cf4189ab2a554a40f</p>\n</blockquote>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230809154138459.png\" alt=\"image-20230809154138459\" /></p>\n</li>\n<li>\n<p>第三次检查集群情况：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230809154202088.png\" alt=\"image-20230809154202088\" /></p>\n</li>\n</ol>\n<p>至此，完成 Redis 集群中的主从扩容：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230809154357068.png\" alt=\"image-20230809154357068\" /></p>\n<h4 id=\"主从缩容\"><a class=\"anchor\" href=\"#主从缩容\">#</a> 主从缩容</h4>\n<blockquote>\n<p>四主四从 -&gt; 三主三从</p>\n</blockquote>\n<p>目的：让 6387、6388 下线</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230809160221198.png\" alt=\"image-20230809160221198\" /></p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230809155155205.png\" alt=\"image-20230809155155205\" /></p>\n<ol>\n<li>\n<p>检查集群情况，获取 slave 6388 的节点 ID：</p>\n<p><font color='orange'>redis-cli -a 密码 <br/>--cluster <strong>check</strong> <br/>192.168.111.174:6388</font></p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230809155313502.png\" alt=\"image-20230809155313502\" /></p>\n</li>\n<li>\n<p>从集群中<font color='gree'>将 slave 6388 删除</font>：</p>\n<p><font color='orange'>redis-cli -a 111111 <br/>--cluster <strong>del-node</strong> <br/>192.168.111.174:6388 <br/> 218e7b8b4f81be54ff173e4776b4f4faaf7c13da</font></p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230809155525228.png\" alt=\"image-20230809155525228\" /></p>\n</li>\n<li>\n<p>检查集群情况，发现 slave 6388 被成功删除：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230809155602447.png\" alt=\"image-20230809155602447\" /></p>\n</li>\n<li>\n<p><font color='gree'>将 master 6387 的槽号清空</font>，本例中将其<font color='gree'>重新分派</font>给 master 6381：</p>\n<p><font color='orange'>redis-cli -a 111111 <br/>--cluster <strong>reshard</strong> <br/>192.168.111.175:6381</font></p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230809155839782.png\" alt=\"image-20230809155839782\" /></p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230809155856778.png\" alt=\"image-20230809155856778\" /></p>\n</li>\n<li>\n<p>检查集群情况：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230809155927823.png\" alt=\"image-20230809155927823\" /></p>\n<blockquote>\n<p>发现：</p>\n<ul>\n<li>master 6387 的 4096 个槽位都指给了 master 6381（变成了 8192 个槽位）</li>\n<li><strong>master 6387 变成了 master 6381 的 slave</strong></li>\n</ul>\n</blockquote>\n</li>\n<li>\n<p>删除 6387：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230809160629562.png\" alt=\"image-20230809160629562\" /></p>\n</li>\n<li>\n<p>检查集群情况：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230809160704133.png\" alt=\"image-20230809160704133\" /></p>\n<blockquote>\n<p>此时 6387/6388 已从集群中移除</p>\n</blockquote>\n</li>\n<li>\n<p>此时，若再想在 6387 上写数据，会报错：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230809160827236.png\" alt=\"image-20230809160827236\" /></p>\n</li>\n</ol>\n<h3 id=\"通识占位符\"><a class=\"anchor\" href=\"#通识占位符\">#</a> 通识占位符</h3>\n<p>痛点：不在同一个 slot 槽位下的<font color='red'>批操作命令（多键操作）</font>支持不好。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230809161249034.png\" alt=\"image-20230809161249034\" /></p>\n<p><strong>可以通过 <code>通识占位符&#123;&#125;</code>  来定义同一个 slot 槽位的概念</strong>，使 key 中<font color='red'>{} 内相同内容</font>的键值对<font color='red'>放到一个 slot 槽位</font>去，对照下图类似 k1、k2、k3 都映射为 x，自然槽位一样：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230809161554065.png\" alt=\"image-20230809161554065\" /></p>\n<h3 id=\"crc16算法分析\"><a class=\"anchor\" href=\"#crc16算法分析\">#</a> CRC16 算法分析</h3>\n<p>Redis 集群有 16384 个哈希槽，每个 key 通过 CRC16 校验后对 16384 取模来决定放置哪个槽。集群的每个节点负责一部分 hash 槽。</p>\n<p>下面浅析 CRC16 算法的源码，源码文件是 <code>cluster.c</code> ：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230809161758328.png\" alt=\"image-20230809161758328\" /></p>\n<h3 id=\"集群中的常用配置与命令\"><a class=\"anchor\" href=\"#集群中的常用配置与命令\">#</a> 集群中的常用配置与命令</h3>\n<ul>\n<li>\n<p>配置参数 <code>cluster-require-full-coverage</code> ：<strong>集群是否完整时才能对外提供服务</strong>，默认为 yes。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230809162230541.png\" alt=\"image-20230809162230541\" /></p>\n<blockquote>\n<p>现在集群架构是 3 主 3 从，由 3 个 master 平分 16384 个 slot，每个 master 的小集群负责 1/3 的 slot，对应一部分数据。</p>\n<p>通常情况，如果这 3 个小集群中，任何一个（1 主 1 从）挂了，你这个集群对外可提供的数据只有 2/3 了，整个集群是不完整的，redis 默认在这种情况下，是不会对外提供服务的。</p>\n</blockquote>\n</li>\n<li>\n<p>命令 <code>CLUSTER COUNTKEYSINSLOT slotindex</code> ：<strong>查看第 <code>slotindex</code>  号槽位上的 key 数量</strong>，空则返回 0。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230809162506376.png\" alt=\"image-20230809162506376\" /></p>\n</li>\n<li>\n<p>命令 <code>CLUSTER KEYSLOT key</code> ：<strong>查看 <code>key</code>  应该存放的槽位号</strong>。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230809162815558.png\" alt=\"image-20230809162815558\" /></p>\n</li>\n</ul>\n<h2 id=\"11-springboot集成redis\"><a class=\"anchor\" href=\"#11-springboot集成redis\">#</a> 11、SpringBoot 集成 Redis</h2>\n<blockquote>\n<p>前面都是通过<font color='red'>命令</font>与 Redis 交互，实际生产中更多是通过<font color='red'>Java 程序</font>来操作 Redis。</p>\n</blockquote>\n<h3 id=\"整体概述\"><a class=\"anchor\" href=\"#整体概述\">#</a> 整体概述</h3>\n<blockquote>\n<p>对比 Jedis、lettuce、RedisTemplate</p>\n</blockquote>\n<p>Java 连接 MySQL 的驱动中间件是 JDBC，那么 Java 连接 Redis 所需要的驱动中间件有哪些呢？</p>\n<ul>\n<li>Jedis：一代目，老牌，线程池不安全</li>\n<li>lettuce：二代目，对 Jedis 的优化</li>\n<li><strong>RedisTemplate</strong>：三代目，对 lettuce 进行封装</li>\n</ul>\n<h3 id=\"本地java连接redis的常见问题\"><a class=\"anchor\" href=\"#本地java连接redis的常见问题\">#</a> 本地 Java 连接 Redis 的常见问题</h3>\n<p>以下问题可能会导致 Java 程序无法远程连接 Redis：</p>\n<ul>\n<li>redis.conf 中的 bind 配置请注释掉</li>\n<li>redis.conf 中的保护模式设置为 no</li>\n<li>Linux 系统的防火墙设置</li>\n<li>redis 服务器的 IP 地址和密码是否正确</li>\n<li>忘记写访问 redis 的服务端口号和 auth 密码</li>\n<li>无脑粘贴脑图笔记......o (...T) o</li>\n</ul>\n<h3 id=\"集成jedis\"><a class=\"anchor\" href=\"#集成jedis\">#</a> 集成 Jedis</h3>\n<p><code>Jedis Client</code>  是 Redis 官网推荐的一个面向 java 客户端，库文件实现了对各类 API 进行封装调用。</p>\n<p>集成 Jedis 的步骤如下：</p>\n<blockquote>\n<p>约定＞配置＞编码</p>\n</blockquote>\n<ol>\n<li>\n<p>创建 Module</p>\n</li>\n<li>\n<p>修改 POM</p>\n</li>\n<li>\n<p>写 YML</p>\n</li>\n<li>\n<p>主启动</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">package</span> <span class=\"token namespace\">com<span class=\"token punctuation\">.</span>atguigu<span class=\"token punctuation\">.</span>redis7</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">org<span class=\"token punctuation\">.</span>springframework<span class=\"token punctuation\">.</span>boot<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">SpringApplication</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">org<span class=\"token punctuation\">.</span>springframework<span class=\"token punctuation\">.</span>boot<span class=\"token punctuation\">.</span>autoconfigure<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">SpringBootApplication</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token comment\">/**</pre></td></tr><tr><td data-num=\"7\"></td><td><pre> * @auther zzyy</pre></td></tr><tr><td data-num=\"8\"></td><td><pre> * @create 2022-11-17 16:36</pre></td></tr><tr><td data-num=\"9\"></td><td><pre> */</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token annotation punctuation\">@SpringBootApplication</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Redis7Study7777</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>        <span class=\"token class-name\">SpringApplication</span><span class=\"token punctuation\">.</span><span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Redis7Study7777</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">,</span>args<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure></li>\n<li>\n<p>业务类</p>\n<ol>\n<li>通过指定 ip 和 port 获得 connection 对象</li>\n<li>指定访问服务器的密码</li>\n<li>得到 Jedis 客户端后，即可访问 redis</li>\n</ol>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token annotation punctuation\">@Slf4j</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">JedisDemo</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>        <span class=\"token class-name\">Jedis</span> jedis <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Jedis</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"192.168.111.185\"</span><span class=\"token punctuation\">,</span><span class=\"token number\">6379</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>        jedis<span class=\"token punctuation\">.</span><span class=\"token function\">auth</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"111111\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>        log<span class=\"token punctuation\">.</span><span class=\"token function\">info</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"redis conn status:&#123;&#125;\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"连接成功\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>        log<span class=\"token punctuation\">.</span><span class=\"token function\">info</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"redis ping retvalue:&#123;&#125;\"</span><span class=\"token punctuation\">,</span>jedis<span class=\"token punctuation\">.</span><span class=\"token function\">ping</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>        jedis<span class=\"token punctuation\">.</span><span class=\"token function\">set</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"k1\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"jedis\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>        log<span class=\"token punctuation\">.</span><span class=\"token function\">info</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"k1 value:&#123;&#125;\"</span><span class=\"token punctuation\">,</span>jedis<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"k1\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"集成lettuce\"><a class=\"anchor\" href=\"#集成lettuce\">#</a> 集成 lettuce</h3>\n<blockquote>\n<p>我来人间一趟，本想光芒万丈，奈何 springboot 太强，刚出生就被团灭！</p>\n</blockquote>\n<p>Lettuce 是一个 Redis 的 Java 驱动包，翻译为生菜。</p>\n<p>lettuce 与 Jedis 的区别：</p>\n<ul>\n<li>\n<p>Jedis 连接 Redis 时，<font color='red'>每个线程都要创建 Jedis 实例，开销大</font></p>\n</li>\n<li>\n<p><font color='red'>Jedis 是线程不安全的</font>，一个线程通过 Jedis 实例更改 Redis 服务器中的数据之后，会影响另一个线程</p>\n</li>\n<li>\n<p><strong>Lettuce 底层使用的是 Netty</strong>，当有多个线程都需要连接 Redis 服务器的时候，可以保证<font color='red'>只创建一个 Lettuce 连接</font>，使<font color='red'>所有的线程共享</font>这一个 Lettuce 连接，这样可以减少创建关闭一个 Lettuce 连接时候的开销。</p>\n</li>\n<li>\n<p>这种方式也是<font color='red'>线程安全</font>的，不会出现一个线程通过 Lettuce 更改 Redis 服务器中的数据之后而影响另一个线程的情况。</p>\n</li>\n<li>\n<p>因此，<font color='red'>在 SpringBoot2.0 之后默认都是使用的 Lettuce</font></p>\n</li>\n</ul>\n<p>案例：</p>\n<ol>\n<li>\n<p>修改 POM</p>\n</li>\n<li>\n<p>写业务类</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">package</span> <span class=\"token namespace\">com<span class=\"token punctuation\">.</span>atguigu<span class=\"token punctuation\">.</span>redis7<span class=\"token punctuation\">.</span>test</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">io<span class=\"token punctuation\">.</span>lettuce<span class=\"token punctuation\">.</span>core<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">RedisClient</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">io<span class=\"token punctuation\">.</span>lettuce<span class=\"token punctuation\">.</span>core<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">RedisFuture</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">io<span class=\"token punctuation\">.</span>lettuce<span class=\"token punctuation\">.</span>core<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">RedisURI</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">io<span class=\"token punctuation\">.</span>lettuce<span class=\"token punctuation\">.</span>core<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">SortArgs</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">io<span class=\"token punctuation\">.</span>lettuce<span class=\"token punctuation\">.</span>core<span class=\"token punctuation\">.</span>api<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">StatefulRedisConnection</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">io<span class=\"token punctuation\">.</span>lettuce<span class=\"token punctuation\">.</span>core<span class=\"token punctuation\">.</span>api<span class=\"token punctuation\">.</span>async<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">RedisAsyncCommands</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">io<span class=\"token punctuation\">.</span>lettuce<span class=\"token punctuation\">.</span>core<span class=\"token punctuation\">.</span>api<span class=\"token punctuation\">.</span>sync<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">RedisCommands</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">lombok<span class=\"token punctuation\">.</span>extern<span class=\"token punctuation\">.</span>slf4j<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">Slf4j</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">java<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">HashMap</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">java<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">List</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">java<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">Map</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">java<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">Set</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">java<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span>concurrent<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">ExecutionException</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre></pre></td></tr><tr><td data-num=\"18\"></td><td><pre><span class=\"token comment\">/**</pre></td></tr><tr><td data-num=\"19\"></td><td><pre> * @auther zzyy</pre></td></tr><tr><td data-num=\"20\"></td><td><pre> * @create 2022-11-17 17:05</pre></td></tr><tr><td data-num=\"21\"></td><td><pre> */</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre><span class=\"token annotation punctuation\">@Slf4j</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">LettuceDemo</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>    <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>        <span class=\"token comment\">// 使用构建器（链式编程） RedisURI.builder</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>        <span class=\"token class-name\">RedisURI</span> uri <span class=\"token operator\">=</span> <span class=\"token class-name\">RedisURI</span><span class=\"token punctuation\">.</span><span class=\"token function\">builder</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>                <span class=\"token punctuation\">.</span><span class=\"token function\">redis</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"192.168.111.181\"</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>                <span class=\"token punctuation\">.</span><span class=\"token function\">withPort</span><span class=\"token punctuation\">(</span><span class=\"token number\">6379</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre>                <span class=\"token punctuation\">.</span><span class=\"token function\">withAuthentication</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"default\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"111111\"</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"32\"></td><td><pre>                <span class=\"token punctuation\">.</span><span class=\"token function\">build</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"33\"></td><td><pre>        <span class=\"token comment\">// 创建连接客户端</span></pre></td></tr><tr><td data-num=\"34\"></td><td><pre>        <span class=\"token class-name\">RedisClient</span> client <span class=\"token operator\">=</span> <span class=\"token class-name\">RedisClient</span><span class=\"token punctuation\">.</span><span class=\"token function\">create</span><span class=\"token punctuation\">(</span>uri<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"35\"></td><td><pre>        <span class=\"token class-name\">StatefulRedisConnection</span> conn <span class=\"token operator\">=</span> client<span class=\"token punctuation\">.</span><span class=\"token function\">connect</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"36\"></td><td><pre>        <span class=\"token comment\">// 操作命令 api</span></pre></td></tr><tr><td data-num=\"37\"></td><td><pre>        <span class=\"token class-name\">RedisCommands</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">,</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">></span></span> commands <span class=\"token operator\">=</span> conn<span class=\"token punctuation\">.</span><span class=\"token function\">sync</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"38\"></td><td><pre></pre></td></tr><tr><td data-num=\"39\"></td><td><pre>        <span class=\"token comment\">//keys</span></pre></td></tr><tr><td data-num=\"40\"></td><td><pre>        <span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">></span></span> list <span class=\"token operator\">=</span> commands<span class=\"token punctuation\">.</span><span class=\"token function\">keys</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"*\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"41\"></td><td><pre>        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> s <span class=\"token operator\">:</span> list<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"42\"></td><td><pre>            log<span class=\"token punctuation\">.</span><span class=\"token function\">info</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"key:&#123;&#125;\"</span><span class=\"token punctuation\">,</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"43\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"44\"></td><td><pre>        <span class=\"token comment\">//String</span></pre></td></tr><tr><td data-num=\"45\"></td><td><pre>    commands<span class=\"token punctuation\">.</span><span class=\"token function\">set</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"k1\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"1111\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"46\"></td><td><pre>    <span class=\"token class-name\">String</span> s1 <span class=\"token operator\">=</span> commands<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"k1\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"47\"></td><td><pre>    <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"String s ===\"</span><span class=\"token operator\">+</span>s1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"48\"></td><td><pre></pre></td></tr><tr><td data-num=\"49\"></td><td><pre>        <span class=\"token comment\">//list</span></pre></td></tr><tr><td data-num=\"50\"></td><td><pre>    commands<span class=\"token punctuation\">.</span><span class=\"token function\">lpush</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"myList2\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"v1\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"v2\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"v3\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"51\"></td><td><pre>    <span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">></span></span> list2 <span class=\"token operator\">=</span> commands<span class=\"token punctuation\">.</span><span class=\"token function\">lrange</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"myList2\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"52\"></td><td><pre>    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> s <span class=\"token operator\">:</span> list2<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"53\"></td><td><pre>     <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"list ssss===\"</span><span class=\"token operator\">+</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"54\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"55\"></td><td><pre>    <span class=\"token comment\">//set</span></pre></td></tr><tr><td data-num=\"56\"></td><td><pre>    commands<span class=\"token punctuation\">.</span><span class=\"token function\">sadd</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"mySet2\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"v1\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"v2\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"v3\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"57\"></td><td><pre>    <span class=\"token class-name\">Set</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">></span></span> set <span class=\"token operator\">=</span> commands<span class=\"token punctuation\">.</span><span class=\"token function\">smembers</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"mySet2\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"58\"></td><td><pre>    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> s <span class=\"token operator\">:</span> set<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"59\"></td><td><pre>     <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"set ssss===\"</span><span class=\"token operator\">+</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"60\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"61\"></td><td><pre>    <span class=\"token comment\">//hash</span></pre></td></tr><tr><td data-num=\"62\"></td><td><pre>    <span class=\"token class-name\">Map</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">,</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">></span></span> map <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">HashMap</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"63\"></td><td><pre>        map<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"k1\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"138xxxxxxxx\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"64\"></td><td><pre>        map<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"k2\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"atguigu\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"65\"></td><td><pre>        map<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"k3\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"zzyybs@126.com\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">// 课后有问题请给我发邮件</span></pre></td></tr><tr><td data-num=\"66\"></td><td><pre></pre></td></tr><tr><td data-num=\"67\"></td><td><pre>    commands<span class=\"token punctuation\">.</span><span class=\"token function\">hmset</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"myHash2\"</span><span class=\"token punctuation\">,</span> map<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"68\"></td><td><pre>    <span class=\"token class-name\">Map</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">,</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">></span></span> retMap <span class=\"token operator\">=</span> commands<span class=\"token punctuation\">.</span><span class=\"token function\">hgetall</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"myHash2\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"69\"></td><td><pre>    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> k <span class=\"token operator\">:</span> retMap<span class=\"token punctuation\">.</span><span class=\"token function\">keySet</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"70\"></td><td><pre>     <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"hash  k=\"</span><span class=\"token operator\">+</span>k<span class=\"token operator\">+</span><span class=\"token string\">\" , v==\"</span><span class=\"token operator\">+</span>retMap<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>k<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"71\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"72\"></td><td><pre></pre></td></tr><tr><td data-num=\"73\"></td><td><pre>    <span class=\"token comment\">//zset</span></pre></td></tr><tr><td data-num=\"74\"></td><td><pre>    commands<span class=\"token punctuation\">.</span><span class=\"token function\">zadd</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"myZset2\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">100.0</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"s1\"</span><span class=\"token punctuation\">,</span><span class=\"token number\">110.0</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"s2\"</span><span class=\"token punctuation\">,</span><span class=\"token number\">90.0</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"s3\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"75\"></td><td><pre>    <span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">></span></span> list3 <span class=\"token operator\">=</span> commands<span class=\"token punctuation\">.</span><span class=\"token function\">zrange</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"myZset2\"</span><span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"76\"></td><td><pre>    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> s <span class=\"token operator\">:</span> list3<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"77\"></td><td><pre>     <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"zset ssss===\"</span><span class=\"token operator\">+</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"78\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"79\"></td><td><pre></pre></td></tr><tr><td data-num=\"80\"></td><td><pre>    <span class=\"token comment\">//sort</span></pre></td></tr><tr><td data-num=\"81\"></td><td><pre>    <span class=\"token class-name\">SortArgs</span> sortArgs <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">SortArgs</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"82\"></td><td><pre>    sortArgs<span class=\"token punctuation\">.</span><span class=\"token function\">alpha</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"83\"></td><td><pre>    sortArgs<span class=\"token punctuation\">.</span><span class=\"token function\">desc</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"84\"></td><td><pre></pre></td></tr><tr><td data-num=\"85\"></td><td><pre>    <span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">></span></span> list4 <span class=\"token operator\">=</span> commands<span class=\"token punctuation\">.</span><span class=\"token function\">sort</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"myList2\"</span><span class=\"token punctuation\">,</span>sortArgs<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"86\"></td><td><pre>    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> s <span class=\"token operator\">:</span> list4<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"87\"></td><td><pre>     <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"sort ssss===\"</span><span class=\"token operator\">+</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"88\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"89\"></td><td><pre></pre></td></tr><tr><td data-num=\"90\"></td><td><pre>        <span class=\"token comment\">// 关闭</span></pre></td></tr><tr><td data-num=\"91\"></td><td><pre>        conn<span class=\"token punctuation\">.</span><span class=\"token function\">close</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"92\"></td><td><pre>        client<span class=\"token punctuation\">.</span><span class=\"token function\">shutdown</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"93\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"94\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"集成redistemplate推荐\"><a class=\"anchor\" href=\"#集成redistemplate推荐\">#</a> <mark>集成 RedisTemplate（推荐）</mark></h3>\n<h4 id=\"连接单机\"><a class=\"anchor\" href=\"#连接单机\">#</a> 连接单机</h4>\n<h5 id=\"boot整合redis基础演示\"><a class=\"anchor\" href=\"#boot整合redis基础演示\">#</a> boot 整合 Redis 基础演示</h5>\n<ol>\n<li>\n<p>创建 Module</p>\n</li>\n<li>\n<p>修改 POM： <code>spring-boot-starter-data-redis</code>  包（依赖于 lettuce 包）和 <code>commons-pool2</code>  包</p>\n</li>\n<li>\n<p>写 YML</p>\n<figure class=\"highlight yaml\"><figcaption data-lang=\"YAML\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>==============redis单机==================</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>spring.redis.database=0</pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token comment\"># 修改为自己真实 IP</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>spring.redis.host=192.168.111.185</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>spring.redis.port=6379</pre></td></tr><tr><td data-num=\"6\"></td><td><pre>spring.redis.password=111111</pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token comment\"># lettuce 连接池</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>spring.redis.lettuce.pool.max<span class=\"token punctuation\">-</span>active=8</pre></td></tr><tr><td data-num=\"9\"></td><td><pre>spring.redis.lettuce.pool.max<span class=\"token punctuation\">-</span>wait=<span class=\"token punctuation\">-</span>1ms</pre></td></tr><tr><td data-num=\"10\"></td><td><pre>spring.redis.lettuce.pool.max<span class=\"token punctuation\">-</span>idle=8</pre></td></tr><tr><td data-num=\"11\"></td><td><pre>spring.redis.lettuce.pool.min<span class=\"token punctuation\">-</span>idle=0</pre></td></tr></table></figure></li>\n<li>\n<p>主启动</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token annotation punctuation\">@SpringBootApplication</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Redis7Study7777</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>        <span class=\"token class-name\">SpringApplication</span><span class=\"token punctuation\">.</span><span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Redis7Study7777</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">,</span>args<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure></li>\n<li>\n<p>业务类</p>\n<ol>\n<li>\n<p>配置类</p>\n<ol>\n<li>RedisConfig</li>\n<li>SwaggerConfig</li>\n</ol>\n</li>\n<li>\n<p>service</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token annotation punctuation\">@Service</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token annotation punctuation\">@Slf4j</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">OrderService</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">String</span> <span class=\"token constant\">ORDER_KEY</span> <span class=\"token operator\">=</span> <span class=\"token string\">\"order:\"</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token annotation punctuation\">@Resource</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token keyword\">private</span> <span class=\"token class-name\">RedisTemplate</span> redisTemplate<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">addOrder</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>        <span class=\"token keyword\">int</span> keyId <span class=\"token operator\">=</span> <span class=\"token class-name\">ThreadLocalRandom</span><span class=\"token punctuation\">.</span><span class=\"token function\">current</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">nextInt</span><span class=\"token punctuation\">(</span><span class=\"token number\">1000</span><span class=\"token punctuation\">)</span><span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>        <span class=\"token class-name\">String</span> orderNo <span class=\"token operator\">=</span> <span class=\"token constant\">UUID</span><span class=\"token punctuation\">.</span><span class=\"token function\">randomUUID</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>        redisTemplate<span class=\"token punctuation\">.</span><span class=\"token function\">opsForValue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">set</span><span class=\"token punctuation\">(</span><span class=\"token constant\">ORDER_KEY</span><span class=\"token operator\">+</span>keyId<span class=\"token punctuation\">,</span><span class=\"token string\">\"京东订单\"</span><span class=\"token operator\">+</span> orderNo<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>        log<span class=\"token punctuation\">.</span><span class=\"token function\">info</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"=====>编号\"</span><span class=\"token operator\">+</span>keyId<span class=\"token operator\">+</span><span class=\"token string\">\"的订单流水生成:&#123;&#125;\"</span><span class=\"token punctuation\">,</span>orderNo<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token class-name\">String</span> <span class=\"token function\">getOrderById</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Integer</span> id<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>    <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>        <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">)</span>redisTemplate<span class=\"token punctuation\">.</span><span class=\"token function\">opsForValue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token constant\">ORDER_KEY</span> <span class=\"token operator\">+</span> id<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure></li>\n<li>\n<p>controller</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token annotation punctuation\">@Api</span><span class=\"token punctuation\">(</span>tags <span class=\"token operator\">=</span> <span class=\"token string\">\"订单接口\"</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token annotation punctuation\">@RestController</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token annotation punctuation\">@Slf4j</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">OrderController</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token annotation punctuation\">@Resource</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token keyword\">private</span> <span class=\"token class-name\">OrderService</span> orderService<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token annotation punctuation\">@ApiOperation</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"新增订单\"</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token annotation punctuation\">@RequestMapping</span><span class=\"token punctuation\">(</span>value <span class=\"token operator\">=</span> <span class=\"token string\">\"/order/add\"</span><span class=\"token punctuation\">,</span>method <span class=\"token operator\">=</span> <span class=\"token class-name\">RequestMethod</span><span class=\"token punctuation\">.</span><span class=\"token constant\">POST</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">addOrder</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>        orderService<span class=\"token punctuation\">.</span><span class=\"token function\">addOrder</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre></pre></td></tr><tr><td data-num=\"16\"></td><td><pre></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>    <span class=\"token annotation punctuation\">@ApiOperation</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"按orderId查订单信息\"</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>    <span class=\"token annotation punctuation\">@RequestMapping</span><span class=\"token punctuation\">(</span>value <span class=\"token operator\">=</span> <span class=\"token string\">\"/order/&#123;id&#125;\"</span><span class=\"token punctuation\">,</span> method <span class=\"token operator\">=</span> <span class=\"token class-name\">RequestMethod</span><span class=\"token punctuation\">.</span><span class=\"token constant\">GET</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token class-name\">String</span> <span class=\"token function\">findUserById</span><span class=\"token punctuation\">(</span><span class=\"token annotation punctuation\">@PathVariable</span> <span class=\"token class-name\">Integer</span> id<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>    <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>        <span class=\"token keyword\">return</span> orderService<span class=\"token punctuation\">.</span><span class=\"token function\">getOrderById</span><span class=\"token punctuation\">(</span>id<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure></li>\n</ol>\n</li>\n<li>\n<p>测试</p>\n<ol>\n<li>\n<p>swagger</p>\n</li>\n<li>\n<p><font color='red'>序列化问题</font>：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230809211944574.png\" alt=\"image-20230809211944574\" /></p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230809212145565.png\" alt=\"image-20230809212145565\" /></p>\n<blockquote>\n<p><img data-src=\"C:%5CUsers%5Chuawei%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20230809212339643.png\" alt=\"image-20230809212339643\" /></p>\n<p><strong>解决方案 1</strong>：将 <code>RedisTemplate</code>  对象替换为 <code>StringRedisTemplate</code>  对象。此时除了 Redis 命令行中仍然显示中文乱码外，在 swagger、服务器中的返回值都没有乱码的问题了。</p>\n<p><strong><font color='red'>解决方案 2-1</font></strong>：<strong>启动 Redis 时添加参数 <code>--raw</code>  解决 Redis 服务器端显示乱码</strong>。</p>\n<p><strong><font color='red'>解决方案 2-2</font></strong>：看下源码  <code>RedisTemplate</code> # <code>afterPropertiesSet()</code>  发现在默认情况下，RedisTemplate 使用的数据列化方式是 <code>JdkSerializationRedisSerializer</code> ，也就是导致乱码的罪魁祸首！解决方法就是 **<font color='orange'>编写 RedisConfig 配置类，指定序列化器</font>**！</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token annotation punctuation\">@Configuration</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">RedisConfig</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token comment\">/**</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>     * redis 序列化的工具配置类，下面这个请一定开启配置</pre></td></tr><tr><td data-num=\"6\"></td><td><pre>     * 127.0.0.1:6379> keys *</pre></td></tr><tr><td data-num=\"7\"></td><td><pre>     * 1) \"ord:102\"  序列化过</pre></td></tr><tr><td data-num=\"8\"></td><td><pre>     * 2) \"\\xac\\xed\\x00\\x05t\\x00\\aord:102\"   野生，没有序列化过</pre></td></tr><tr><td data-num=\"9\"></td><td><pre>     * this.redisTemplate.opsForValue (); // 提供了操作 string 类型的所有方法</pre></td></tr><tr><td data-num=\"10\"></td><td><pre>     * this.redisTemplate.opsForList (); // 提供了操作 list 类型的所有方法</pre></td></tr><tr><td data-num=\"11\"></td><td><pre>     * this.redisTemplate.opsForSet (); // 提供了操作 set 的所有方法</pre></td></tr><tr><td data-num=\"12\"></td><td><pre>     * this.redisTemplate.opsForHash (); // 提供了操作 hash 表的所有方法</pre></td></tr><tr><td data-num=\"13\"></td><td><pre>     * this.redisTemplate.opsForZSet (); // 提供了操作 zset 的所有方法</pre></td></tr><tr><td data-num=\"14\"></td><td><pre>     * @param lettuceConnectionFactory</pre></td></tr><tr><td data-num=\"15\"></td><td><pre>     * @return</pre></td></tr><tr><td data-num=\"16\"></td><td><pre>     */</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>    <span class=\"token annotation punctuation\">@Bean</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token class-name\">RedisTemplate</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">Object</span><span class=\"token punctuation\">></span></span> <span class=\"token function\">redisTemplate</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">LettuceConnectionFactory</span> lettuceConnectionFactory<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>    <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>        <span class=\"token class-name\">RedisTemplate</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">,</span><span class=\"token class-name\">Object</span><span class=\"token punctuation\">></span></span> redisTemplate <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">RedisTemplate</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>        redisTemplate<span class=\"token punctuation\">.</span><span class=\"token function\">setConnectionFactory</span><span class=\"token punctuation\">(</span>lettuceConnectionFactory<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>        <span class=\"token comment\">// 设置 key 序列化方式 string</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>        redisTemplate<span class=\"token punctuation\">.</span><span class=\"token function\">setKeySerializer</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">StringRedisSerializer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>        <span class=\"token comment\">// 设置 value 的序列化方式 json，使用 GenericJackson2JsonRedisSerializer 替换默认序列化</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>        redisTemplate<span class=\"token punctuation\">.</span><span class=\"token function\">setValueSerializer</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">GenericJackson2JsonRedisSerializer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>        redisTemplate<span class=\"token punctuation\">.</span><span class=\"token function\">setHashKeySerializer</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">StringRedisSerializer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>        redisTemplate<span class=\"token punctuation\">.</span><span class=\"token function\">setHashValueSerializer</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">GenericJackson2JsonRedisSerializer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre></pre></td></tr><tr><td data-num=\"31\"></td><td><pre>        redisTemplate<span class=\"token punctuation\">.</span><span class=\"token function\">afterPropertiesSet</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"32\"></td><td><pre></pre></td></tr><tr><td data-num=\"33\"></td><td><pre>        <span class=\"token keyword\">return</span> redisTemplate<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"34\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"35\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure></blockquote>\n</li>\n</ol>\n</li>\n</ol>\n<h5 id=\"调用其他命令api家庭作业\"><a class=\"anchor\" href=\"#调用其他命令api家庭作业\">#</a> 调用其他命令 api（家庭作业）</h5>\n<h4 id=\"连接集群\"><a class=\"anchor\" href=\"#连接集群\">#</a> 连接集群</h4>\n<h5 id=\"步骤演示\"><a class=\"anchor\" href=\"#步骤演示\">#</a> 步骤演示</h5>\n<ol>\n<li>\n<p>启动 Redis 集群的 6 台实例（三主三从）</p>\n</li>\n<li>\n<p>改写 YML</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre># <span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">=</span>redis集群<span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">=</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>spring<span class=\"token punctuation\">.</span>redis<span class=\"token punctuation\">.</span>password<span class=\"token operator\">=</span><span class=\"token number\">111111</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre># 获取失败 最大重定向次数</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>spring<span class=\"token punctuation\">.</span>redis<span class=\"token punctuation\">.</span>cluster<span class=\"token punctuation\">.</span>max<span class=\"token operator\">-</span>redirects<span class=\"token operator\">=</span><span class=\"token number\">3</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>spring<span class=\"token punctuation\">.</span>redis<span class=\"token punctuation\">.</span>lettuce<span class=\"token punctuation\">.</span>pool<span class=\"token punctuation\">.</span>max<span class=\"token operator\">-</span>active<span class=\"token operator\">=</span><span class=\"token number\">8</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>spring<span class=\"token punctuation\">.</span>redis<span class=\"token punctuation\">.</span>lettuce<span class=\"token punctuation\">.</span>pool<span class=\"token punctuation\">.</span>max<span class=\"token operator\">-</span>wait<span class=\"token operator\">=</span><span class=\"token operator\">-</span><span class=\"token number\">1</span>ms</pre></td></tr><tr><td data-num=\"7\"></td><td><pre>spring<span class=\"token punctuation\">.</span>redis<span class=\"token punctuation\">.</span>lettuce<span class=\"token punctuation\">.</span>pool<span class=\"token punctuation\">.</span>max<span class=\"token operator\">-</span>idle<span class=\"token operator\">=</span><span class=\"token number\">8</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>spring<span class=\"token punctuation\">.</span>redis<span class=\"token punctuation\">.</span>lettuce<span class=\"token punctuation\">.</span>pool<span class=\"token punctuation\">.</span>min<span class=\"token operator\">-</span>idle<span class=\"token operator\">=</span><span class=\"token number\">0</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>spring<span class=\"token punctuation\">.</span>redis<span class=\"token punctuation\">.</span>cluster<span class=\"token punctuation\">.</span>nodes<span class=\"token operator\">=</span><span class=\"token number\">192.168</span><span class=\"token number\">.111</span><span class=\"token number\">.175</span><span class=\"token operator\">:</span><span class=\"token number\">6381</span><span class=\"token punctuation\">,</span><span class=\"token number\">192.168</span><span class=\"token number\">.111</span><span class=\"token number\">.175</span><span class=\"token operator\">:</span><span class=\"token number\">6382</span><span class=\"token punctuation\">,</span><span class=\"token number\">192.168</span><span class=\"token number\">.111</span><span class=\"token number\">.172</span><span class=\"token operator\">:</span><span class=\"token number\">6383</span><span class=\"token punctuation\">,</span><span class=\"token number\">192.168</span><span class=\"token number\">.111</span><span class=\"token number\">.172</span><span class=\"token operator\">:</span><span class=\"token number\">6384</span><span class=\"token punctuation\">,</span><span class=\"token number\">192.168</span><span class=\"token number\">.111</span><span class=\"token number\">.174</span><span class=\"token operator\">:</span><span class=\"token number\">6385</span><span class=\"token punctuation\">,</span><span class=\"token number\">192.168</span><span class=\"token number\">.111</span><span class=\"token number\">.174</span><span class=\"token operator\">:</span><span class=\"token number\">6386</span></pre></td></tr></table></figure></li>\n<li>\n<p>通过微服务访问 redis 集群：一切 ok</p>\n</li>\n</ol>\n<h5 id=\"故障转移时的经典问题\"><a class=\"anchor\" href=\"#故障转移时的经典问题\">#</a> 故障转移时的经典问题</h5>\n<ol>\n<li>\n<p>人为模拟 master 6381 机器意外宕机，手动 shutdown</p>\n</li>\n<li>\n<p>对 redis 集群命令方式，手动验证各种读写命令，slave 6384 成功上位</p>\n</li>\n<li>\n<p><font color='red'><u>Redis 侧的集群</u>能自动感知并完成主从切换</font>，对应的 slave 6384 会被选举为新的 master</p>\n</li>\n<li>\n<p><strong><u>微服务客户端</u>再次读写访问，发现连接不上 master 6381！</strong><font color='red'>SpringBoot 客户端没有动态感知到 Redis 集群的最新集群信息</font>。当 master 宕机主从切换成功，redis 手动 OK，但是有 **<font color='red'>2 个经典故障</font>**：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230809214444224.png\" alt=\"image-20230809214444224\" /></p>\n<blockquote>\n<p>报错：命令超时 1 分钟！</p>\n</blockquote>\n<p><img data-src=\"C:%5CUsers%5Chuawei%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20230809214514675.png\" alt=\"image-20230809214514675\" /></p>\n<blockquote>\n<p>报错：无法连接 6381！</p>\n</blockquote>\n<p><font color='gree'>根本原因</font>：<font color='red'>SpringBoot 2.X 版本，Redis 默认的连接池采用 Lettuce。当 Redis 集群节点发生变化后，Letture 默认是不会刷新节点拓扑</font>。</p>\n<p><strong><font color='gree'>解决方案</font>：<font color='orange'>刷新节点集群拓扑动态感应</font>。</strong><font color='red'>修改 YML 中的两个配置项即可</font>！</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230809214957793.png\" alt=\"image-20230809214957793\" /></p>\n</li>\n<li>\n<p><strong>修改 YML</strong>：</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre># <span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span>redis集群<span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>spring<span class=\"token punctuation\">.</span>redis<span class=\"token punctuation\">.</span>password<span class=\"token operator\">=</span><span class=\"token number\">111111</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre># 获取失败 最大重定向次数</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>spring<span class=\"token punctuation\">.</span>redis<span class=\"token punctuation\">.</span>cluster<span class=\"token punctuation\">.</span>max<span class=\"token operator\">-</span>redirects<span class=\"token operator\">=</span><span class=\"token number\">3</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>spring<span class=\"token punctuation\">.</span>redis<span class=\"token punctuation\">.</span>lettuce<span class=\"token punctuation\">.</span>pool<span class=\"token punctuation\">.</span>max<span class=\"token operator\">-</span>active<span class=\"token operator\">=</span><span class=\"token number\">8</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>spring<span class=\"token punctuation\">.</span>redis<span class=\"token punctuation\">.</span>lettuce<span class=\"token punctuation\">.</span>pool<span class=\"token punctuation\">.</span>max<span class=\"token operator\">-</span>wait<span class=\"token operator\">=</span><span class=\"token operator\">-</span><span class=\"token number\">1</span>ms</pre></td></tr><tr><td data-num=\"7\"></td><td><pre>spring<span class=\"token punctuation\">.</span>redis<span class=\"token punctuation\">.</span>lettuce<span class=\"token punctuation\">.</span>pool<span class=\"token punctuation\">.</span>max<span class=\"token operator\">-</span>idle<span class=\"token operator\">=</span><span class=\"token number\">8</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>spring<span class=\"token punctuation\">.</span>redis<span class=\"token punctuation\">.</span>lettuce<span class=\"token punctuation\">.</span>pool<span class=\"token punctuation\">.</span>min<span class=\"token operator\">-</span>idle<span class=\"token operator\">=</span><span class=\"token number\">0</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre># 支持集群拓扑动态感应刷新<span class=\"token punctuation\">,</span>自适应拓扑刷新是否使用所有可用的更新，默认<span class=\"token boolean\">false</span>关闭</pre></td></tr><tr><td data-num=\"10\"></td><td><pre>spring<span class=\"token punctuation\">.</span>redis<span class=\"token punctuation\">.</span>lettuce<span class=\"token punctuation\">.</span>cluster<span class=\"token punctuation\">.</span>refresh<span class=\"token punctuation\">.</span>adaptive<span class=\"token operator\">=</span><span class=\"token boolean\">true</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre># 定时刷新</pre></td></tr><tr><td data-num=\"12\"></td><td><pre>spring<span class=\"token punctuation\">.</span>redis<span class=\"token punctuation\">.</span>lettuce<span class=\"token punctuation\">.</span>cluster<span class=\"token punctuation\">.</span>refresh<span class=\"token punctuation\">.</span>period<span class=\"token operator\">=</span><span class=\"token number\">2000</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>spring<span class=\"token punctuation\">.</span>redis<span class=\"token punctuation\">.</span>cluster<span class=\"token punctuation\">.</span>nodes<span class=\"token operator\">=</span><span class=\"token number\">192.168</span><span class=\"token number\">.111</span><span class=\"token number\">.175</span><span class=\"token operator\">:</span><span class=\"token number\">6381</span><span class=\"token punctuation\">,</span><span class=\"token number\">192.168</span><span class=\"token number\">.111</span><span class=\"token number\">.175</span><span class=\"token operator\">:</span><span class=\"token number\">6382</span><span class=\"token punctuation\">,</span><span class=\"token number\">192.168</span><span class=\"token number\">.111</span><span class=\"token number\">.172</span><span class=\"token operator\">:</span><span class=\"token number\">6383</span><span class=\"token punctuation\">,</span><span class=\"token number\">192.168</span><span class=\"token number\">.111</span><span class=\"token number\">.172</span><span class=\"token operator\">:</span><span class=\"token number\">6384</span><span class=\"token punctuation\">,</span><span class=\"token number\">192.168</span><span class=\"token number\">.111</span><span class=\"token number\">.174</span><span class=\"token operator\">:</span><span class=\"token number\">6385</span><span class=\"token punctuation\">,</span><span class=\"token number\">192.168</span><span class=\"token number\">.111</span><span class=\"token number\">.174</span><span class=\"token operator\">:</span><span class=\"token number\">6386</span></pre></td></tr></table></figure></li>\n</ol>\n<h1 id=\"高级篇\"><a class=\"anchor\" href=\"#高级篇\">#</a> 高级篇</h1>\n<blockquote>\n<p>前置技术要求：微服务（boot、cloud）+ docker + Nginx + JUC + Jmeter</p>\n</blockquote>\n<h2 id=\"1-redis的单线程与多线程入门篇\"><a class=\"anchor\" href=\"#1-redis的单线程与多线程入门篇\">#</a> 1、Redis 的单线程与多线程 (入门篇)</h2>\n<h2 id=\"2-bigkey\"><a class=\"anchor\" href=\"#2-bigkey\">#</a> 2、BigKey</h2>\n<h2 id=\"3-缓存双写一致性之更新策略探讨\"><a class=\"anchor\" href=\"#3-缓存双写一致性之更新策略探讨\">#</a> 3、缓存双写一致性之更新策略探讨</h2>\n<h2 id=\"4-redis与mysql数据双写一致性工程落地案例\"><a class=\"anchor\" href=\"#4-redis与mysql数据双写一致性工程落地案例\">#</a> 4、Redis 与 MySQL 数据双写一致性工程落地案例</h2>\n<h2 id=\"5-案例落地实战bitmaphyperlogloggeo\"><a class=\"anchor\" href=\"#5-案例落地实战bitmaphyperlogloggeo\">#</a> 5、案例落地实战 bitmap/HyperLogLog/GEO</h2>\n<h2 id=\"6-布隆过滤器bloomfilter\"><a class=\"anchor\" href=\"#6-布隆过滤器bloomfilter\">#</a> 6、布隆过滤器 BloomFilter</h2>\n<h2 id=\"7-缓存预热缓存雪崩缓存击穿缓存穿透\"><a class=\"anchor\" href=\"#7-缓存预热缓存雪崩缓存击穿缓存穿透\">#</a> 7、缓存预热 + 缓存雪崩 + 缓存击穿 + 缓存穿透</h2>\n<h2 id=\"8-手写redis分布式锁\"><a class=\"anchor\" href=\"#8-手写redis分布式锁\">#</a> 8、手写 Redis 分布式锁</h2>\n<h2 id=\"9-redlock算法和底层源码分析\"><a class=\"anchor\" href=\"#9-redlock算法和底层源码分析\">#</a> 9、Redlock 算法和底层源码分析</h2>\n<h2 id=\"10-redis经典五大类型源码及底层实现\"><a class=\"anchor\" href=\"#10-redis经典五大类型源码及底层实现\">#</a> 10、Redis 经典五大类型源码及底层实现</h2>\n<h2 id=\"11-redis为什么快高性能设计之epoll和io多路复用深度解析\"><a class=\"anchor\" href=\"#11-redis为什么快高性能设计之epoll和io多路复用深度解析\">#</a> 11、Redis 为什么快？高性能设计之 epoll 和 IO 多路复用深度解析</h2>\n<h2 id=\"12-终章の总结\"><a class=\"anchor\" href=\"#12-终章の总结\">#</a> 12、终章の总结</h2>\n",
            "tags": [
                "数据库",
                "Redis"
            ]
        },
        {
            "id": "http://example.com/database/mongodb/MongoDB-JavaGuide/",
            "url": "http://example.com/database/mongodb/MongoDB-JavaGuide/",
            "title": "MongoDB-JavaGuide",
            "date_published": "2023-11-17T12:07:21.834Z",
            "content_html": "<h1 id=\"mongodb常见面试题上\"><a class=\"anchor\" href=\"#mongodb常见面试题上\">#</a> MongoDB 常见面试题（上）</h1>\n<h1 id=\"mongodb常见面试题下\"><a class=\"anchor\" href=\"#mongodb常见面试题下\">#</a> MongoDB 常见面试题（下）</h1>\n",
            "tags": [
                "数据库",
                "MongoDB"
            ]
        },
        {
            "id": "http://example.com/database/elasticsearch/Elasticsearch-JavaGuide/",
            "url": "http://example.com/database/elasticsearch/Elasticsearch-JavaGuide/",
            "title": "Elasticsearch-JavaGuide",
            "date_published": "2023-11-17T12:05:10.564Z",
            "content_html": "",
            "tags": [
                "数据库",
                "Elasticsearch"
            ]
        },
        {
            "id": "http://example.com/database/redis/Redis-JavaGuide/",
            "url": "http://example.com/database/redis/Redis-JavaGuide/",
            "title": "Redis-JavaGuide",
            "date_published": "2023-11-17T12:03:29.258Z",
            "content_html": "<h1 id=\"缓存基础常见面试题\"><a class=\"anchor\" href=\"#缓存基础常见面试题\">#</a> 缓存基础常见面试题</h1>\n<h2 id=\"为什么要用分布式缓存\"><a class=\"anchor\" href=\"#为什么要用分布式缓存\">#</a> 为什么要用分布式缓存？</h2>\n<blockquote>\n<p>相关面试题：</p>\n<ul>\n<li>为什么要用缓存？</li>\n<li>本地缓存应该怎么做？</li>\n<li>为什么要有分布式缓存？/ 为什么不直接用本地缓存？</li>\n<li>多级缓存了解么？</li>\n</ul>\n</blockquote>\n<h3 id=\"缓存的基本思想\"><a class=\"anchor\" href=\"#缓存的基本思想\">#</a> 缓存的基本思想</h3>\n<p>很多同学只知道<font color='red'>缓存可以提高系统性能，减少请求相应时间</font>。但是，不太清楚缓存的本质思想是什么。</p>\n<p>缓存的基本思想其实很简单，就是我们非常熟悉的 **<font color='red'>空间换时间</font>**。不要把缓存想的太高大上，虽然，它的确对系统的性能提升的性价比非常高。</p>\n<p>其实，我们在学习使用缓存的时候，你会发现缓存的思想实际在操作系统或者其他地方都被大量用到。比如<font color='red'> CPU Cache 缓存的是内存数据，用于解决 CPU 处理速度和内存不匹配的问题</font>；<font color='red'>内存缓存的是硬盘数据，用于解决硬盘访问速度过慢的问题</font>；<font color='red'>操作系统在页表方案基础之上引入了快表，来加速虚拟地址到物理地址的转换</font>。我们可以把快表理解为一种特殊的高速缓冲存储器（Cache）。</p>\n<p>我们知道，缓存中的数据通常存储于内存中，因此访问速度非常快。为了避免内存中的数据在重启或者宕机之后丢失，很多缓存中间件会利用磁盘做持久化。</p>\n<p>也就是说，缓存相比于我们常用的关系型数据库（比如 MySQL）来说访问速度要快非常多。<strong><font color='red'>为了避免用户请求数据库中的数据速度过慢，可以在数据库之上增加一层缓存</font></strong>。</p>\n<p>除了能够提高访问速度之外，<font color='red'>缓存支持的并发量也要更大</font>，有了缓存之后，数据库的压力也会随之变小。</p>\n<h3 id=\"缓存的分类\"><a class=\"anchor\" href=\"#缓存的分类\">#</a> 缓存的分类</h3>\n<h4 id=\"本地缓存\"><a class=\"anchor\" href=\"#本地缓存\">#</a> 本地缓存</h4>\n<h5 id=\"是什么\"><a class=\"anchor\" href=\"#是什么\">#</a> 是什么</h5>\n<p>这个实际在很多项目中用的蛮多，特别是<font color='red'>单体架构</font>的时候。<font color='red'>数据量不大，并且没有分布式要求</font>的话，使用本地缓存还是可以的。</p>\n<p><strong><font color='red'>本地缓存位于应用内部，其最大的优点是应用存在于同一个进程内部，请求本地缓存的速度非常快，不存在额外的网络开销</font></strong>。</p>\n<p>常见的单体架构图如下，我们使用 <strong>Nginx</strong> 来做<strong>负载均衡</strong>，部署两个相同的应用到服务器，两个服务使用同一个数据库，并且使用的是本地缓存。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/local-cache.png\" alt=\"local-cache.png\" /></p>\n<h5 id=\"实现方案\"><a class=\"anchor\" href=\"#实现方案\">#</a> 实现方案</h5>\n<p><strong>1、JDK 自带的 HashMap 和 ConcurrentHashMap</strong></p>\n<blockquote>\n<p>一般不用</p>\n</blockquote>\n<p>ConcurrentHashMap 可以看作是线程安全版本的 HashMap ，两者都是存放 key/value 形式的键值对。但是，大部分场景来说不会使用这两者当做缓存，因为<font color='red'>只提供了缓存的功能，并没有提供其他诸如过期时间之类的功能</font>。一个稍微完善一点的缓存框架 **<font color='red'>至少要提供：过期时间、淘汰机制、命中率统计</font>** 这三点。</p>\n<p><strong>2、 Ehcache 、 Guava Cache 、 Spring Cache 本地缓存框架</strong></p>\n<blockquote>\n<p>使用的比较多</p>\n</blockquote>\n<ul>\n<li><code>Ehcache</code> ：相比于其他两者<font color='red'>更加重量</font>，不过  <code>Ehcache</code>  支持可以嵌入到 hibernate 和 mybatis 作为<font color='red'>多级缓存</font>，并且可以将缓存的数据<font color='red'>持久化</font>到本地磁盘中、同时也提供了<font color='red'>集群方案</font>（比较鸡肋，可忽略）。</li>\n<li><code>Guava Cache</code>  和  <code>Spring Cache</code>  比较像。 <code>Guava </code> 相比于 <code>Spring Cache </code> 的话使用的更多一点，它提供了 API 非常方便我们使用，同时也提供了<font color='red'>设置缓存有效时间</font>等功能。它的内部实现也比较干净，很多地方都和  <code>ConcurrentHashMap</code>  的思想有异曲同工之妙。</li>\n<li>使用  <code>Spring Cache</code>  的注解实现缓存的话，<font color='red'>代码会看着很干净和优雅</font>，但是很容易出现问题比如<font color='red'>缓存穿透、内存溢出</font>。</li>\n</ul>\n<p><strong><font color='red'>3、后起之秀 Caffeine</font></strong></p>\n<blockquote>\n<p>使用最多</p>\n</blockquote>\n<p>相比于  <code> Guava</code>  来说  <code> Caffeine</code>  在各个方面比如性能要更加优秀，一般建议使用其来替代  <code>Guava</code> 。并且 <code>Guava</code>  和  <code>Caffeine</code>  的使用方式很像！</p>\n<h5 id=\"缺点\"><a class=\"anchor\" href=\"#缺点\">#</a> 缺点</h5>\n<p>本地的缓存的优势非常明显：低依赖、轻量、简单、成本低。</p>\n<p>但是，本地缓存存在下面这些缺陷：</p>\n<ul>\n<li><strong><font color='red'>本地缓存应用耦合，对分布式架构支持不友好</font></strong>：比如同一个相同的服务部署在多台机器上的时候，各个服务之间的缓存是无法共享的，因为本地缓存只在当前机器上有。</li>\n<li><strong><font color='red'>本地缓存的容量受服务部署所在机器的限制明显</font></strong>：如果当前系统服务所耗费的内存多，那么本地缓存可用的容量就很少。</li>\n</ul>\n<h4 id=\"分布式缓存\"><a class=\"anchor\" href=\"#分布式缓存\">#</a> 分布式缓存</h4>\n<h5 id=\"是什么-2\"><a class=\"anchor\" href=\"#是什么-2\">#</a> 是什么</h5>\n<p>我们可以把分布式缓存（Distributed Cache）看作是一种内存数据库的服务，它的最终作用就是提供缓存数据的服务。</p>\n<p><strong><font color='red'>分布式缓存脱离于应用独立存在，多个应用可直接的共同使用同一个分布式缓存服务</font></strong>。</p>\n<p>如下图所示，就是一个简单的使用分布式缓存的架构图。我们使用 Nginx 来做负载均衡，部署两个相同的应用到服务器，两个服务使用同一个数据库和缓存。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/distributed-cache.png\" alt=\"distributed-cache.png\" /></p>\n<p>使用分布式缓存之后，<font color='red'>缓存服务可以部署在一台单独的服务器上</font>，即使同一个相同的服务部署在多台机器上，也是使用的同一份缓存。 并且，单独的分布式缓存服务的<font color='red'>性能、容量和提供的功能都要更加强大</font>。</p>\n<p>** 但是，软件系统设计中没有银弹，往往任何技术的引入都像是把双刃剑。** 你使用的方式得当，就能为系统带来很大的收益。否则，只是费了精力不讨好。</p>\n<p>简单来说，为系统引入分布式缓存之后往往会带来下面这些问题：</p>\n<ul>\n<li><strong><font color='red'>系统复杂性增加</font></strong>：引入缓存之后，<font color='red'>要维护缓存和数据库的数据一致性、维护热点缓存、保证缓存服务的高可用</font>等等。</li>\n<li><strong><font color='red'>系统开发成本增加</font></strong>：引入缓存意味着系统需要一个单独的缓存服务，这是需要花费相应的成本的，并且这个成本还是很贵的，毕竟耗费的是宝贵的内存。</li>\n</ul>\n<h5 id=\"实现方案redis\"><a class=\"anchor\" href=\"#实现方案redis\">#</a> 实现方案：Redis</h5>\n<p>唯一真神：<strong><font color='red'>Redis</font></strong>！</p>\n<h4 id=\"多级缓存\"><a class=\"anchor\" href=\"#多级缓存\">#</a> 多级缓存</h4>\n<p>这里只来简单聊聊 <strong><font color='red'>本地缓存 + 分布式缓存</font></strong> 的多级缓存方案。</p>\n<p>这个时候估计有很多小伙伴就会问了：既然用了分布式缓存，为什么还要用本地缓存呢？</p>\n<p>的确，<font color='red'>一般情况下是不建议使用多级缓存的，这会增加维护负担</font>（比如你需要保证一级缓存和二级缓存的数据一致性），并且，实际带来的提升效果对于绝大部分项目来说其实并不是很大。</p>\n<p>多级缓存方案中，<strong><font color='red'>第一级缓存（L1）使用本地内存（比如 Caffeine），第二级缓存（L2）使用分布式缓存（比如 Redis）</font></strong>。读取缓存数据的时候，我们<font color='red'>先从 L1 中读取，读取不到的时候再去 L2 读取</font>。这样可以降低 L2 的压力，减少 L2 的读次数。并且，<font color='red'>本地内存的访问速度是最快的，不存在什么网络开销</font>。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/multilevel-cache.png\" alt=\"multilevel-cache.png\" /></p>\n<h2 id=\"常见的缓存更新策略有哪几种\"><a class=\"anchor\" href=\"#常见的缓存更新策略有哪几种\">#</a> 常见的缓存更新策略有哪几种？</h2>\n<p>下面介绍到的三种模式各有优劣，不存在最佳模式，根据具体的业务场景选择适合自己的缓存读写模式即可！</p>\n<h3 id=\"cache-aside-pattern旁路缓存模式\"><a class=\"anchor\" href=\"#cache-aside-pattern旁路缓存模式\">#</a> Cache Aside Pattern（旁路缓存模式）</h3>\n<blockquote>\n<p>平时使用比较多</p>\n</blockquote>\n<h4 id=\"是什么-3\"><a class=\"anchor\" href=\"#是什么-3\">#</a> 是什么</h4>\n<p>Cache Aside Pattern 是我们<font color='red'>平时使用比较多</font>的一个缓存读写模式，<font color='red'>适合读请求比较多的场景</font>。</p>\n<p>Cache Aside Pattern 中 **<font color='red'>服务端需要同时维系数据库（后文简称 db）和缓存（后文简称 cache）</font>**，并且是<font color='red'>以 db 的结果为准</font>。</p>\n<h4 id=\"缓存读写步骤\"><a class=\"anchor\" href=\"#缓存读写步骤\">#</a> 缓存读写步骤</h4>\n<p><strong>写</strong>：</p>\n<ol>\n<li>先更新 db</li>\n<li><font color='red'>直接删除 cache</font></li>\n</ol>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/fd814571-c1ae-4f7e-aad8-5dac5b741de8.png\" alt=\"img\" /></p>\n<p><strong>读</strong>：</p>\n<ol>\n<li>先从 cache 中读取数据，读取到就直接返回</li>\n<li>cache 中读取不到的话，再从 db 中读取数据返回</li>\n<li><font color='red'>再把从 db 中读取到的数据写入 cache 中</font></li>\n</ol>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/cfa0a217-53d2-45d8-b9e9-13970de9982c.png\" alt=\"img\" /></p>\n<h4 id=\"原理\"><a class=\"anchor\" href=\"#原理\">#</a> 原理</h4>\n<p>问题：<strong>写数据时为什么删除 cache，而不是更新 cache？</strong></p>\n<p>仅仅了解了上面这些内容的话是远远不够的，我们还要搞懂其中的原理。</p>\n<p>主要原因有两点：</p>\n<ol>\n<li><strong><font color='red'>对服务端资源造成浪费</font></strong>：<font color='red'>删除 cache 更加直接</font>，这是因为 cache 中存放的一些数据需要服务端经过大量的计算才能得出，会消耗服务端的资源，是一笔不小的开销。<font color='red'>如果频繁修改 db，就能会导致需要频繁更新 cache，而 cache 中的数据可能都没有被访问到</font>。</li>\n<li><strong><font color='red'>产生数据不一致问题</font></strong>：并发场景下，更新 cache 产生数据不一致性问题的概率会更大（后文会解释原因）。</li>\n</ol>\n<hr />\n<p>追问：<strong>写数据时，为什么不先删除 cache ，再更新 db ？</strong></p>\n<p>答案：那肯定是不行的！因为这样可能 **<font color='red'>会造成数据库（db）和缓存（Cache）数据不一致</font>** 的问题。</p>\n<p>举例：请求 1 先写数据 A，请求 2 随后读数据 A 的话，就很有可能产生数据不一致性的问题。这个过程可以简单描述为：</p>\n<ol>\n<li>\n<p>请求 1 先把 cache 中的 A 数据删除；</p>\n</li>\n<li>\n<p>请求 2 从 db 中读取数据；</p>\n</li>\n<li>\n<p>请求 1 再把 db 中的 A 数据更新。</p>\n</li>\n</ol>\n<p>这就会导致请求 2 读取到的是旧值。</p>\n<hr />\n<p>追问：<strong>写数据时，先更新 db，后删除 cache 就没有问题了么？</strong></p>\n<p>答案：理论上来说<font color='red'>出现数据不一致性的概率非常小，因为缓存的写入速度是比数据库的写入速度快很多</font>。</p>\n<p>举例：请求 1 先读数据 A，请求 2 随后写数据 A，并且数据 A 在请求 1 请求之前不在缓存中的话，也有可能产生数据不一致性的问题。这个过程可以简单描述为：</p>\n<ol>\n<li>\n<p>请求 1 从 db 读数据 A；</p>\n</li>\n<li>\n<p>请求 2 更新 db 中的数据 A（此时缓存中无数据 A ，故不用执行删除缓存操作 ）；</p>\n</li>\n<li>\n<p>请求 1 将数据 A 写入 cache。</p>\n</li>\n</ol>\n<p>这就会导致 cache 中存放的其实是旧值。</p>\n<h4 id=\"缺点-2\"><a class=\"anchor\" href=\"#缺点-2\">#</a> 缺点</h4>\n<ul>\n<li>\n<p>缺陷 1：<strong>首次请求数据一定不在 cache 中</strong></p>\n<blockquote>\n<p>解决办法：<font color='red'>将热点数据提前放入 cache 中</font></p>\n</blockquote>\n</li>\n<li>\n<p>缺陷 2：<strong>写操作比较频繁的话，会导致 cache 中的数据频繁被删除，影响缓存命中率</strong></p>\n<blockquote>\n<p>解决办法：</p>\n<ul>\n<li>\n<p>数据库和缓存数据强一致场景：更新 db 的时候同样更新 cache，不过我们需要加一个锁 / 分布式锁来保证更新 cache 的时候不存在线程安全问题。</p>\n</li>\n<li>\n<p>可以短暂地允许数据库和缓存数据不一致的场景：更新 db 的时候同样更新 cache，但是给缓存加一个比较短的过期时间，这样的话就可以保证即使数据不一致的话影响也比较小。</p>\n</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"readwrite-through-pattern读写穿透模式\"><a class=\"anchor\" href=\"#readwrite-through-pattern读写穿透模式\">#</a> Read/Write Through Pattern（读 / 写穿透模式）</h3>\n<blockquote>\n<p>在平时开发过程中非常少见</p>\n</blockquote>\n<h4 id=\"是什么-4\"><a class=\"anchor\" href=\"#是什么-4\">#</a> 是什么</h4>\n<p>Read/Write Through Pattern 中服务端 **<font color='red'>把 cache 视为主要数据存储，从中读 / 写数据；而 cache 服务负责将此数据读取和写入 db，从而减轻了应用程序的职责</font>**。</p>\n<p>这种缓存读写策略小伙伴们应该也发现了<font color='red'>在平时开发过程中非常少见</font>。抛去性能方面的影响，大概率是因为我们经常使用的分布式缓存<font color='red'> Redis 并没有提供将 cache 数据写入 db 的功能</font>。</p>\n<h4 id=\"缓存读写步骤-2\"><a class=\"anchor\" href=\"#缓存读写步骤-2\">#</a> 缓存读写步骤</h4>\n<p><strong>写（Write Through）</strong>：</p>\n<blockquote>\n<p>与旁路缓存模式的写步骤不同</p>\n</blockquote>\n<ol>\n<li>\n<p><font color='red'>先检查 cache 中是否存在要写入的数据</font>：</p>\n<ol>\n<li>\n<p><font color='red'>若 cache 中不存在</font>，则直接更新 db</p>\n</li>\n<li>\n<p><font color='red'>若 cache 中存在</font>，则先更新 cache；然后 cache 服务再更新 db</p>\n</li>\n</ol>\n</li>\n</ol>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/0126e23d-f0d1-4c30-a568-b60405b3dda8.png\" alt=\"img\" /></p>\n<p><strong>读（Read Through）</strong>：</p>\n<blockquote>\n<p>与旁路缓存模式的读步骤一样</p>\n</blockquote>\n<ol>\n<li>\n<p>先从 cache 中读取数据，读取到就直接返回</p>\n</li>\n<li>\n<p>从 cache 中读取不到的话，再从 db 加载，最后写入 cache ，返回响应</p>\n</li>\n</ol>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/e685e967-1655-4424-a75d-490101b52087.png\" alt=\"img\" /></p>\n<h4 id=\"原理-2\"><a class=\"anchor\" href=\"#原理-2\">#</a> 原理</h4>\n<p><strong>Read-Through Pattern 实际只是在 Cache-Aside Pattern 之上进行了封装</strong>。在 Cache-Aside Pattern 下，发生读请求的时候，如果 cache 中不存在对应的数据，是由客户端自己负责把数据写入 cache，而 Read Through Pattern 则是 cache 服务自己来写入缓存的，这对客户端是透明的。</p>\n<h4 id=\"缺点-3\"><a class=\"anchor\" href=\"#缺点-3\">#</a> 缺点</h4>\n<p>和 Cache Aside Pattern 一样， Read-Through Pattern <strong><font color='red'>也存在首次请求数据一定不在 cache 的问题，可以将热点数据提前放入 cache 中</font></strong>。</p>\n<h3 id=\"write-behind-pattern异步缓存写入模式\"><a class=\"anchor\" href=\"#write-behind-pattern异步缓存写入模式\">#</a> Write Behind Pattern（异步缓存写入模式）</h3>\n<blockquote>\n<p>在平时开发过程中也非常非常少见</p>\n</blockquote>\n<p>Write Behind Pattern 和 Read/Write Through Pattern 很相似，两者都是由 cache 服务来负责 cache 和 db 的读写。</p>\n<p>但是，两个又有很大的不同：<strong>Read/Write Through 是同步更新 cache 和 db，<font color='red'>而 Write Behind 则是只更新 cache，不直接更新 db，而是改为异步批量的方式来更新 db</font>。</strong></p>\n<p>很明显，这种方式对数据一致性带来了更大的挑战，比如 cache 数据可能还没异步更新 db 的话，cache 服务可能就就挂掉了。</p>\n<p>这种策略<font color='red'>在平时开发过程中也非常非常少见</font>，但是不代表它的应用场景少，比如消息队列中消息的异步写入磁盘、MySQL 的 Innodb Buffer Pool 机制都用到了这种策略。</p>\n<p>Write Behind Pattern 下 db 的写性能非常高，非常适合一些数据经常变化又对数据一致性要求没那么高的场景，比如浏览量、点赞量。</p>\n<h1 id=\"redis-基础\"><a class=\"anchor\" href=\"#redis-基础\">#</a> Redis 基础</h1>\n<h2 id=\"redis-是什么\"><a class=\"anchor\" href=\"#redis-是什么\">#</a> Redis 是什么</h2>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9yZWRpcy5pby8=\">Redis</span>（<strong>RE</strong>mote <strong>DI</strong>ctionary <strong>S</strong>erver，远程词典服务器）是一个基于<font color='red'> C 语言</font>开发的开源 <font color='red'>NoSQL</font> 数据库（BSD 许可）。与传统数据库不同的是，Redis 的数据是保存在内存中的（<strong><font color='red'>内存数据库，支持持久化</font></strong>），因此<font color='red'>读写速度非常快</font>，被广泛应用于<font color='red'>分布式缓存</font>方向。并且，Redis 存储的是<font color='red'> Key-Value 键值对数据</font>。</p>\n<p>为了满足不同的业务场景，Redis <font color='red'>内置多种数据类型实现</font>（比如 String、Hash、Sorted Set、Bitmap、HyperLogLog、GEO）。并且，Redis 还<font color='red'>支持事务、持久化、Lua 脚本、发布 / 订阅、缓存淘汰、流技术</font>等功能特性，提供了<font color='red'>多种集群方案（主从模式、 <code>Redis Sentinel</code> 、 <code>Redis Cluster</code> ）</font>。</p>\n<h2 id=\"redis-怎么用\"><a class=\"anchor\" href=\"#redis-怎么用\">#</a> Redis 怎么用</h2>\n<p>生产环境下，官方推荐使用 Linux 部署 Redis。</p>\n<p>个人学习的话，可以自己本机安装 Redis 或者通过 Redis 官网提供的<span class=\"exturl\" data-url=\"aHR0cHM6Ly90cnkucmVkaXMuaW8v\">在线 Redis 环境</span>（少部分命令无法使用）来实际体验 Redis。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/try.redis.io.png\" alt=\"try-redis\" /></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly90ZWNoc3RhY2tzLmlvLw==\">techstacks.io</span> 专门维护了一个<span class=\"exturl\" data-url=\"aHR0cHM6Ly90ZWNoc3RhY2tzLmlvL3RlY2gvcmVkaXM=\">使用 Redis 的热门站点列表</span> ，感兴趣的话可以看看。</p>\n<h2 id=\"redis-功能\"><a class=\"anchor\" href=\"#redis-功能\">#</a> <mark>Redis 功能</mark></h2>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/Redis-v2-01-1.jpg\" alt=\"img\" /></p>\n<center>Redis 总体功能概览图</center>\n<ul>\n<li>\n<p><strong><font color='orange'>分布式缓存</font></strong>，帮 MySQL 减负</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231202180734903.png\" alt=\"image-20231202180734903\" /></p>\n<blockquote>\n<p>MySQL 与 Redis 的对比：</p>\n<ul>\n<li>MySQL 是关系型数据库，Redis 是<font color='red'>key-value</font>数据库（NoSQL 的一种）</li>\n<li>MySQL 主要存储在磁盘，Redis 数据操作主要在<font color='red'>内存</font></li>\n<li>Redis 在一些场景中明显优于 MySQL，例如<font color='red'>计数器、排行榜</font>等</li>\n<li>Redis 通常用于一些特定场景，需要与 MySQL 一起配合使用，两者并不是相互替换和竞争关系，而是共用和<strong>配合使用</strong></li>\n</ul>\n</blockquote>\n</li>\n<li>\n<p><strong>内存存储</strong>和<strong>持久化</strong>（ <code>RDB</code> + <code>AOF</code> ）：Redis 支持异步将内存中的数据写到硬盘上，同时不影响继续服务</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231202180535935.png\" alt=\"image-20231202180535935\" /></p>\n</li>\n<li>\n<p><strong>高可用架构搭配</strong>：避免某台 Redis 挂了后，影响系统运行</p>\n<ul>\n<li>单机</li>\n<li>主从（replica）</li>\n<li>哨兵（sentinel）</li>\n<li>集群（cluster)</li>\n</ul>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231202180648762.png\" alt=\"image-20231202180648762\" /></p>\n</li>\n<li>\n<p>缓存穿透、击穿、雪崩</p>\n</li>\n<li>\n<p><strong>分布式锁</strong>：跨服务器加锁</p>\n</li>\n<li>\n<p><strong>消息队列平台</strong>：Reids<font color='red'>提供 list 和 set 操作</font>，这使得 Redis 能作为一个很好的消息队列平台来使用。</p>\n<blockquote>\n<p>通过 Reids 的队列功能做<strong>购买限制</strong>。比如到节假日或者推广期间，进行一些活动，对用户购买行为进行限制，限制今天只能购买几次商品或者一段时间内只能购买一次。</p>\n</blockquote>\n</li>\n<li>\n<p><strong>排行榜</strong> +<strong> 点赞</strong>：Redis 提供的<font color='red'>zset 数据类型</font>能够快速实现这些复杂的排行榜。</p>\n</li>\n</ul>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230802155434366.png\" alt=\"image-20230802155434366\" /></p>\n<h2 id=\"redis-优势\"><a class=\"anchor\" href=\"#redis-优势\">#</a> Redis 优势</h2>\n<ul>\n<li><strong>读写性能极高</strong></li>\n<li><strong>数据类型丰富</strong>：不仅支持<font color='red'>key-value</font>类型的数据，同时还提供<font color='red'>list，set，zset，hash</font>等数据结构的存储</li>\n<li><strong>支持数据持久化</strong>：可将内存中的数据存入磁盘中，重启时再加载到内存使用</li>\n<li><strong>支持数据备份</strong>，即 master-slave 模式的数据备份</li>\n</ul>\n<h2 id=\"redis-迭代历史\"><a class=\"anchor\" href=\"#redis-迭代历史\">#</a> Redis 迭代历史</h2>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230802161140294.png\" alt=\"image-20230802161140294\" /></p>\n<p><font color='red'>5.0 版本</font>是直接升级到<font color='red'>6.0 版本</font>，对于这个激进的升级，Redis 之父 antirez 表现得很有信心和兴奋，所以第一时间发文来阐述 6.0 的一些重大功能 &quot;Redis 6.0.0 GA is out!&quot;</p>\n<p>随后 Redis 再接再厉，直接王炸<font color='red'>Redis7.0</font>---2023 年爆款。2022 年 4 月 27 日 Redis 正式发布了 7.0 更新（其实早在 2022 年 1 月 31 日，Redis 已经预发布了 7.0rc-1，经过社区的考验后，确认没重大 Bug 才会正式发布）</p>\n<p>Redis<strong> 版本的命名规则</strong>：</p>\n<ul>\n<li>版本号第二位如果是奇数，则为非稳定版本。如 2.7、2.9、3.1</li>\n<li><font color='red'>版本号第二位如果是偶数，则为稳定版本</font>。如 2.6、2.8、3.0、3.2</li>\n<li>当前奇数版本就是下一个稳定版本的开发版本。如 2.9 版本是 3.0 版本的开发版本</li>\n</ul>\n<h2 id=\"redis7-新特性\"><a class=\"anchor\" href=\"#redis7-新特性\">#</a> Redis7 新特性</h2>\n<p>可以从 redis 的 GitHub 的 releases 中查看当前版本的新特性，Redis7 的部分新特性总览：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230802162007264.png\" alt=\"image-20230802162007264\" /></p>\n<ul>\n<li>\n<p>Redis Functions：Redis 函数，一种新的通过服务端脚本扩展 Redis 的方式，函数与数据本身一起存储。简言之，redis 自己要去<font color='red'>抢夺 Lua 脚本的饭碗</font>，但是 Lua 已经稳定且普及，所以 Redis Functions<font color='red'>没必要学</font></p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230802162230304.png\" alt=\"image-20230802162230304\" /></p>\n</li>\n<li>\n<p><strong>Client-eviction</strong>：客户端相关优化，能让更多 client 连接上</p>\n<p><font color='red'>限制客户端内存使用</font>，一旦 Redis 连接较多，再加上每个连接的内存占用都比较大的时候，Redis 总连接内存占用可能会达到 maxmemory 的上限，可以增加允许限制所有客户端的总内存使用量配置项，redis.config 中对应的配置项，有两种配置形式：</p>\n<ul>\n<li><font color='red'>指定内存大小</font>。例如 maxmemory-clients 1g</li>\n<li><font color='red'>基于 maxmemory 的百分比</font>。例如 maxmemory-clients 10%</li>\n</ul>\n<img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230802162439869.png\" alt=\"image-20230802162439869\" style=\"zoom:80%;\" />\n</li>\n<li>\n<p><strong>Multi-part AOF</strong>：多 AOF 文件支持，AOF 文件由一个变成了多个，主要分为两种类型：<font color='red'>基本文件 (base files)</font>、<font color='red'>增量文件 (incr files)</font>，请注意这些文件名称是复数形式说明每一类文件不仅仅只有一个。在此之外还引入了一个<font color='red'>清单文件 (manifest) </font>用于跟踪文件以及文件的创建和应用顺序（恢复）。性能急剧上升，再也不用担心 AOFRW 异步读写时的运维痛点</p>\n<img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230802163004405.png\" alt=\"image-20230802163004405\" style=\"zoom:80%;\" />\n</li>\n<li>\n<p><strong>config 命令增强</strong>：对于<font color='red'>Config Set 和 Get 命令</font>，支持在一次调用过程中<font color='red'>传递多个配置参数</font>。例如，现在我们可以在执行一次 Config Set 命令中更改多个参数： config set maxmemory 10000001 maxmemory-clients 50% port 6399</p>\n</li>\n<li>\n<p><strong>访问安全性增强 ACL V2</strong>：访问控制，在 redis.conf 配置文件中，<font color='red'>protected-mode 默认为 yes</font>，只有当你希望你的客户端在没有授权的情况下可以连接到 Redis server 的时候可以将 protected-mode 设置为 no</p>\n<img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230802163118585.png\" alt=\"image-20230802163118585\" style=\"zoom:80%;\" />\n</li>\n<li>\n<p><strong>listpack 紧凑列表调整</strong>：listpack 是用来<font color='red'>替代 ziplist 的新数据结构</font>，在 7.0 版本已经没有 ziplist 的配置了（6.0 版本仅部分数据类型作为过渡阶段在使用），listpack 已经替换了 ziplist 类似 hash-max-ziplist-entries 的配置</p>\n</li>\n<li>\n<p>RDB 保存时间调整：将持久化文件 RDB 的保存规则发生了改变，尤其是时间记录频度变化</p>\n</li>\n<li>\n<p>命令新增和变动：</p>\n<ul>\n<li>Zset (有序集合) 增加 ZMPOP、BZMPOP、ZINTERCARD 等命令</li>\n<li>Set (集合) 增加 SINTERCARD 命令</li>\n<li>LIST (列表) 增加 LMPOP、BLMPOP ，从提供的键名列表中的第一个非空列表键中弹出一个或多个元素</li>\n</ul>\n</li>\n<li>\n<p><strong>性能资源利用率、安全、等改进</strong>：自身<font color='red'>底层部分优化</font>改动，Redis 核心在许多方面进行了重构和改进</p>\n<ul>\n<li><font color='red'>主动碎片整理 V2</font>：增强版主动碎片整理，配合 Jemalloc 版本更新，更快更智能，延时更低</li>\n<li><font color='red'>HyperLogLog 改进</font>：在 Redis5.0 中，HyperLogLog 算法得到改进，优化了计数统计时的内存使用效率，7 更加优秀</li>\n<li><font color='red'>更好的内存统计报告</font></li>\n<li>如果不为了 API 向后兼容，我们将<font color='red'>不再使用 slave 一词</font>......(政治正确)</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"redis-为什么这么快\"><a class=\"anchor\" href=\"#redis-为什么这么快\">#</a> <mark>Redis 为什么这么快？</mark></h2>\n<p>Redis 内部做了非常多的性能优化，比较重要的有下面 3 点：</p>\n<ol>\n<li>Redis <strong><font color='red'>基于内存</font></strong>，内存的访问速度是磁盘的上千倍；</li>\n<li>Redis 基于 Reactor 模式设计开发了 **<font color='red'>一套高效的事件处理模型</font>**，主要是<font color='red'>单线程事件循环</font>和<font color='red'> IO 多路复用</font>（Redis 线程模式后面会详细介绍到）；</li>\n<li>Redis 内置了多种 **<font color='red'>优化过后的数据类型 / 结构实现</font>**，性能非常高；</li>\n</ol>\n<blockquote>\n<p>下面这张图片总结的挺不错的，分享一下，出自 <span class=\"exturl\" data-url=\"aHR0cHM6Ly90d2l0dGVyLmNvbS9hbGV4eHVieXRlL3N0YXR1cy8xNDk4NzAzODIyNTI4NTQ0Nzcw\">Why is Redis so fast?</span></p>\n</blockquote>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/why-redis-so-fast-E21l9uI2.png\" alt=\"why-redis-so-fast\" /></p>\n<h2 id=\"分布式缓存常见的技术选型方案\"><a class=\"anchor\" href=\"#分布式缓存常见的技术选型方案\">#</a> 分布式缓存常见的技术选型方案</h2>\n<p>分布式缓存的话，比较老牌同时也是使用的比较多的还是 <strong>Memcached</strong> 和 <strong>Redis</strong>。不过，<font color='red'>现在基本没有看过还有项目使用 Memcached 来做缓存</font>，都是直接用 Redis。</p>\n<p>Memcached 是分布式缓存最开始兴起的那会，比较常用的。后来，随着 Redis 的发展，大家慢慢都<font color='red'>转而使用更加强大的 Redis 了</font>。</p>\n<p>另外，腾讯也开源了一款类似于 Redis 的分布式高性能 KV 存储数据库，基于知名的开源项目 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JvY2tzZGI=\">RocksDB</span> 作为存储引擎 ，100% 兼容 Redis 协议和 Redis4.0 所有数据模型，名为 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL1RlbmNlbnQvVGVuZGlz\">Tendis</span>。</p>\n<p>关于 Redis 和 Tendis 的对比，腾讯官方曾经发过一篇文章：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvTWVZa2ZPSWRuVTZMWWxzR2IyNEtqUQ==\">Redis vs Tendis：冷热混合存储版架构揭秘</span> ，可以简单参考一下。</p>\n<p>从这个项目的 GitHub 提交记录可以看出，<font color='red'>Tendis 开源版几乎已经没有被维护更新了，加上其关注度并不高，使用的公司也比较少</font>。因此，不建议你使用 Tendis 来实现分布式缓存。</p>\n<h2 id=\"redis-和-memcached-的区别和共同点\"><a class=\"anchor\" href=\"#redis-和-memcached-的区别和共同点\">#</a> Redis 和 Memcached 的区别和共同点</h2>\n<p>现在公司一般都是用 Redis 来实现缓存，而且 Redis 自身也越来越强大了！不过，了解 Redis 和 Memcached 的区别和共同点，有助于我们在做相应的技术选型的时候，能够做到有理有据！</p>\n<p><strong>共同点</strong>：</p>\n<ol>\n<li><font color='red'>都基于内存</font>，一般都用来当做缓存使用。</li>\n<li><font color='red'>都有过期策略</font>。</li>\n<li><font color='red'>性能都非常高</font>。</li>\n</ol>\n<p><strong>区别</strong>：</p>\n<ol>\n<li><strong><font color='red'>Redis 支持更丰富的数据类型（支持更复杂的应用场景）</font></strong>。Redis 不仅仅支持简单的 k/v 类型的数据，同时还提供 <font color='red'>list，set，zset，hash</font> 等数据结构的存储。Memcached 只支持最简单的 k/v 数据类型。</li>\n<li><strong><font color='red'>Redis 支持数据的持久化</font></strong>，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用，而 Memcached 把数据全部存在内存之中。</li>\n<li><strong><font color='red'>Redis 有灾难恢复机制</font></strong>。因为可以把缓存中的数据持久化到磁盘上。</li>\n<li><strong>Redis 在服务器内存使用完之后，可以将不用的数据放到磁盘上</strong>。但是，Memcached 在服务器内存使用完之后，就会直接报异常。</li>\n<li>Memcached 没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据；但是 <strong>Redis 目前是原生支持 cluster 模式的。</strong></li>\n<li>Memcached 是多线程，非阻塞 IO 复用的网络模型；<strong><font color='red'>Redis 使用单线程的多路 IO 复用模型</font></strong>。（Redis 6.0 针对网络数据的读写引入了多线程）</li>\n<li><strong>Redis 支持发布订阅模型、Lua 脚本、事务等功能</strong>，而 Memcached 不支持。并且，Redis 支持更多的编程语言。</li>\n<li>Memcached 过期数据的删除策略只用了惰性删除，而 <strong>Redis 针对过期数据同时使用了惰性删除、定期删除。</strong></li>\n</ol>\n<p>相信看了上面的对比之后，我们已经没有什么理由可以选择使用 Memcached 来作为自己项目的分布式缓存了。</p>\n<h2 id=\"为什么要用-redis或者缓存\"><a class=\"anchor\" href=\"#为什么要用-redis或者缓存\">#</a> <mark>为什么要用 Redis（或者缓存）？</mark></h2>\n<p>1、<strong><font color='red'>高性能</font></strong></p>\n<p>假如用户第一次访问数据库中的某些数据的话，这个过程是比较慢，毕竟是从硬盘中读取的。但是如果说，用户访问的数据属于高频数据并且不会经常改变的话，那么我们就可以很放心地<font color='red'>将该用户访问的数据存在缓存中</font>。</p>\n<p>这样有什么好处呢？那就是<font color='red'>保证用户下一次再访问这些数据的时候，就可以直接从缓存中获取了</font>。操作缓存就是直接操作内存，所以速度相当快。</p>\n<p>2、<strong><font color='red'>高并发</font></strong></p>\n<p>一般像 MySQL 这类的数据库的 QPS 大概都在 1w 左右（4 核 8g），但是使用 Redis 缓存之后很容易达到 10w+，甚至最高能达到 30w+（就单机 Redis 的情况，Redis 集群的话会更高）。</p>\n<blockquote>\n<p><code>QPS（Query Per Second）</code> ：服务器每秒可以执行的查询次数；</p>\n</blockquote>\n<p>由此可见，<font color='red'>直接操作缓存能够承受的数据库请求数量是远远大于直接访问数据库的</font>，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。进而，我们也就提高了系统整体的并发。</p>\n<h2 id=\"常见的缓存读写策略\"><a class=\"anchor\" href=\"#常见的缓存读写策略\">#</a> 常见的缓存读写策略</h2>\n<p>指路→<a href=\"#%E5%B8%B8%E8%A7%81%E7%9A%84%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0%E7%AD%96%E7%95%A5%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D?\">常见的缓存更新策略有哪几种？</a></p>\n<h1 id=\"redis-应用\"><a class=\"anchor\" href=\"#redis-应用\">#</a> Redis 应用</h1>\n<h2 id=\"redis-除了做缓存还能做什么\"><a class=\"anchor\" href=\"#redis-除了做缓存还能做什么\">#</a> Redis 除了做缓存，还能做什么？</h2>\n<ul>\n<li>\n<p><strong><font color='red'>分布式锁</font></strong>：通过 Redis 来做分布式锁是一种比较常见的方式。通常情况下，我们都是基于 <font color='red'>Redisson</font> 来实现分布式锁。关于 Redis 实现分布式锁的详细介绍，可以看我写的这篇文章：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9qYXZhZ3VpZGUuY24vZGlzdHJpYnV0ZWQtc3lzdGVtL2Rpc3RyaWJ1dGVkLWxvY2suaHRtbA==\">分布式锁详解</span>。</p>\n</li>\n<li>\n<p><strong><font color='red'>限流</font></strong>：一般是通过<font color='red'> Redis + Lua 脚本</font>的方式来实现限流。相关阅读：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3Mva3lGQVdIM21WTkp2dXJRRHQ0dmNoQQ==\">《我司用了 6 年的 Redis 分布式限流器，可以说是非常厉害了！》</span>。</p>\n</li>\n<li>\n<p><strong><font color='red'>消息队列</font></strong>：Redis 自带的 <font color='red'>List</font> 数据结构可以作为一个简单的队列使用。Redis 5.0 中增加的 <font color='red'>Stream</font> 类型的数据结构更加适合用来做消息队列。它比较<font color='red'>类似于 Kafka，有主题和消费组的概念，支持消息持久化以及 ACK 机制</font>。</p>\n</li>\n<li>\n<p><strong>延时队列</strong>：Redisson 内置了延时队列（基于 <font color='red'>Sorted Set</font> 实现的）。</p>\n</li>\n<li>\n<p><strong>分布式 Session</strong>：利用<font color='red'> String 或者 Hash </font>数据类型保存 Session 数据，所有的服务器都可以访问。</p>\n</li>\n<li>\n<p><strong>复杂业务场景</strong>：通过 Redis 以及 Redis 扩展（比如 <font color='red'>Redisson</font>）提供的数据结构，我们可以很方便地完成很多复杂的业务场景，比如<font color='red'>通过 Bitmap 统计活跃用户、通过 Sorted Set 维护排行榜</font>。</p>\n</li>\n<li>\n<p>…</p>\n</li>\n</ul>\n<h2 id=\"redis-如何实现分布式锁\"><a class=\"anchor\" href=\"#redis-如何实现分布式锁\">#</a> Redis 如何实现分布式锁？</h2>\n<p>指路 -&gt;<span class=\"exturl\" data-url=\"aHR0cHM6Ly9qYXZhZ3VpZGUuY24vZGlzdHJpYnV0ZWQtc3lzdGVtL2Rpc3RyaWJ1dGVkLWxvY2suaHRtbA==\"> 分布式锁详解</span></p>\n<h2 id=\"redis-可以做消息队列么\"><a class=\"anchor\" href=\"#redis-可以做消息队列么\">#</a> Redis 可以做消息队列么？</h2>\n<blockquote>\n<p>实际项目中也没见谁使用 Redis 来做消息队列，对于这部分知识点大家了解就好了。</p>\n</blockquote>\n<p>先说结论：<strong><font color='red'>可以是可以，但不建议使用 Redis 来做消息队列，因为它不如专业的消息队列</font></strong>。</p>\n<h3 id=\"list-实现方式\"><a class=\"anchor\" href=\"#list-实现方式\">#</a> List 实现方式</h3>\n<p><strong>Redis 2.0 之前，如果想要使用 Redis 来做消息队列的话，只能通过 List 来实现。</strong></p>\n<p>通过  <code>RPUSH/LPOP</code>  或者  <code>LPUSH/RPOP</code>  即可实现简易版消息队列：</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># 生产者生产消息</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token operator\">></span> RPUSH myList msg1 msg2</pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">(</span>integer<span class=\"token punctuation\">)</span> <span class=\"token number\">2</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token operator\">></span> RPUSH myList msg3</pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">(</span>integer<span class=\"token punctuation\">)</span> <span class=\"token number\">3</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token comment\"># 消费者消费消息</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token operator\">></span> LPOP myList</pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token string\">\"msg1\"</span></pre></td></tr></table></figure><p>不过，通过  <code>RPUSH/LPOP</code>  或者  <code>LPUSH/RPOP</code>  这样的方式<font color='red'>存在性能问题，需要不断轮询去调用  <code>RPOP</code>  或  <code>LPOP</code>  来消费消息</font>。当 List 为空时，大部分的轮询的请求都是无效请求，这种方式大量浪费了系统资源。</p>\n<p>因此，Redis <font color='red'>还提供了  <code>BLPOP</code> 、 <code>BRPOP</code>  这种阻塞式读取的命令</font>（带 B：Bloking 的都是阻塞式），并且还支持一个超时参数。<font color='red'>如果 List 为空，Redis 服务端不会立刻返回结果</font>，它会等待 List 中有新数据后，再返回或者是等待最多一个超时时间后返回空。如果将超时时间设置为 0 时，即可无限等待，直到弹出消息。</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># 超时时间为 10s</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token comment\"># 如果有数据则立刻返回，否则最多等待 10 秒</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token operator\">></span> BRPOP myList <span class=\"token number\">10</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>null</pre></td></tr></table></figure><p><strong><font color='red'>List 实现消息队列功能太简单，像 <u>ACK 机制</u>等功能还需要我们自己实现，最要命的是没有<u>广播机制</u>，消息也只能被消费一次</font></strong>。</p>\n<h3 id=\"发布订阅pubsub实现方式\"><a class=\"anchor\" href=\"#发布订阅pubsub实现方式\">#</a> 发布订阅（pub/sub）实现方式</h3>\n<p><strong>Redis 2.0 引入了发布订阅 (pub/sub) 功能，解决了 List 实现消息队列没有<u>广播机制</u>的问题。</strong></p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/redis-pub-sub.png\" alt=\"Redis 发布订阅 (pub/sub) 功能\" /></p>\n<center>Redis 发布订阅 (pub/sub) 功能</center>\n<p>pub/sub 中引入了一个概念叫 <strong><font color='cornflowerblue'>channel（频道）</font></strong>，发布订阅机制的实现就是基于这个 channel 来做的。</p>\n<p>pub/sub 涉及两个角色：</p>\n<ul>\n<li><font color='cornflowerblue'>发布者（Publisher）</font>：通过  <code>PUBLISH</code>  投递消息给指定 channel。</li>\n<li><font color='cornflowerblue'>订阅者（Subscriber，也叫消费者）</font>：通过  <code>SUBSCRIBE</code>  订阅它关心的 channel。并且，订阅者可以订阅一个或者多个 channel。</li>\n</ul>\n<p>这里启动 3 个 Redis 客户端来简单演示一下：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/redis-pubsub-message-queue.png\" alt=\"pub/sub 实现消息队列演示\" /></p>\n<center>pub/sub 实现消息队列演示</center>\n<p>pub/sub 既能单播又能广播，还支持 channel 的简单正则匹配。不过，<font color='red'>消息丢失（客户端断开连接或者 Redis 宕机都会导致消息丢失）、消息堆积（发布者发布消息的时候不会管消费者的具体消费能力如何）等问题依然没有一个比较好的解决办法</font>。</p>\n<h3 id=\"stream-实现方式\"><a class=\"anchor\" href=\"#stream-实现方式\">#</a> Stream 实现方式</h3>\n<p>为此，<font color='red'>Redis 5.0</font> 新增加的一个数据结构  <code>Stream</code>  来做消息队列。 <code>Stream</code>  支持：</p>\n<ul>\n<li><font color='red'>发布订阅（pub/sub）模式</font></li>\n<li>按照<font color='red'>消费者组</font>进行消费（借鉴了 Kafka 消费者组的概念）</li>\n<li><font color='red'>消息持久化（RDB 和 AOF）</font></li>\n<li><font color='red'>ACK 机制</font>（通过确认机制来告知已经成功处理了消息）</li>\n<li><font color='red'>阻塞式获取消息</font></li>\n</ul>\n<p><code>Stream</code>  的结构如下：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/redis-stream-structure-ZjK8peV8.png\" alt=\"img\" /></p>\n<p><code>Stream</code>  使用起来相对要麻烦一些，这里就不演示了。而且，<font color='red'> <code>Stream</code>  在实际使用中依然会有一些小问题不太好解决</font>，比如在 Redis 发生故障恢复后不能保证消息至少被消费一次。</p>\n<p><code>Stream</code>  被用作消息队列时，依赖于下面这些命令：</p>\n<ul>\n<li><code>XADD</code> ：向流中添加新的消息。</li>\n<li><code>XREAD</code> ：从流中读取消息。</li>\n<li><code>XREADGROUP</code> ：从消费组中读取消息。</li>\n<li><code>XRANGE</code> ：根据消息 ID 范围读取流中的消息。</li>\n<li><code>XREVRANGE</code> ：与  <code>XRANGE</code>  类似，但以相反顺序返回结果。</li>\n<li><code>XDEL</code> ：从流中删除消息。</li>\n<li><code>XTRIM</code> ：修剪流的长度，可以指定修建策略。</li>\n<li><code>XLEN</code> ：获取流的长度。</li>\n<li><code>XGROUP</code> ：管理消费组，包括创建、删除和修改。</li>\n<li><code>XACK</code> ：确认消费组中的消息已被处理。</li>\n<li><code>XPENDING</code> ：查询消费组中挂起（未确认）的消息。</li>\n<li><code>XCLAIM</code> ：将挂起的消息从一个消费者转移到另一个消费者。</li>\n<li><code>XINFO</code> ：获取流、消费组或消费者的详细信息。</li>\n</ul>\n<p>综上，和专业的消息队列相比，使用 Redis 来实现消息队列还是有很多欠缺的地方，比如<font color='red'>消息丢失和堆积问题</font>不好解决。因此，我们<font color='red'>通常建议不要使用 Redis 来做消息队列</font>，你完全可以选择市面上比较成熟的一些消息队列比如 RocketMQ、Kafka。不过，如果你就是想要用 Redis 来做消息队列的话，那我<font color='red'>建议优先考虑  <code>Stream</code> </font>，这是目前相对最优的 Redis 消息队列实现。</p>\n<p>相关阅读：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvZ0NVVDVUY0NRUkF4WWtUSmZUUmpKdw==\">Redis 消息队列发展历程 - 阿里开发者 - 2022</span>。</p>\n<h1 id=\"redis-命令\"><a class=\"anchor\" href=\"#redis-命令\">#</a> Redis 命令</h1>\n<p>Redis 根据命令所操作对象的不同，可以分为三大类：</p>\n<ul>\n<li>对 Redis 进行基础性操作的命令</li>\n<li>对 Key 的操作命令</li>\n<li>对 Value 的操作命令</li>\n</ul>\n<h2 id=\"基础命令\"><a class=\"anchor\" href=\"#基础命令\">#</a> 基础命令</h2>\n<p>首先通过  <code>redis-cli</code>  命令进入到 Redis 命令行客户端，然后再运行下面的命令：</p>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>介绍</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>PING</code></td>\n<td><font color='red'>心跳命令</font>，会看到 PONG 响应，则说明该客户端与 Redis 的连接是正常的。</td>\n</tr>\n<tr>\n<td><code>SELECT</code>  dbindex</td>\n<td><font color='red'>切换数据库</font>。Redis 默认有 16 个数据库，这个在 RDM 图形客户端中可以直观地看到。默认使用的是 0 号 DB，可以通过 select db 索引来切换 DB。</td>\n</tr>\n<tr>\n<td><code>DBSIZE</code></td>\n<td>查看当前数据库中 key 的数量</td>\n</tr>\n<tr>\n<td><code>FLUSHDB</code></td>\n<td>删除当前数据库中的数据</td>\n</tr>\n<tr>\n<td><code>FLUSHALL</code></td>\n<td>删除所有数据库中的数据</td>\n</tr>\n</tbody>\n</table>\n<p>使用  <code>exit</code>  /  <code>quit</code>  命令均可退出 Redis 命令行客户端。</p>\n<h2 id=\"key-相关命令\"><a class=\"anchor\" href=\"#key-相关命令\">#</a> key 相关命令</h2>\n<p>因此，在介绍 Redis 中常用的 value 数据类型前，先介绍一下 key 相关的命令。</p>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>介绍</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>DEL</code>  key</td>\n<td>key 存在时，删除 key</td>\n</tr>\n<tr>\n<td><code>UNLINK</code>  key</td>\n<td>非阻塞删除 key，仅仅将 key 从 keyspace 元数据中删除，真正的删除会在后续异步中操作。</td>\n</tr>\n<tr>\n<td>DUMP key</td>\n<td>返回 key 被序列化后的值</td>\n</tr>\n<tr>\n<td><code>EXISTS</code>  key</td>\n<td>检查 key 是否存在</td>\n</tr>\n<tr>\n<td><code>EXPIRE</code>  key seconds</td>\n<td>以秒为单位，设置 key 的过期时间。<font color='red'>默认 -1 表示永不过期</font>。（时间间隔）</td>\n</tr>\n<tr>\n<td>PEXPIRE key milliseconds</td>\n<td>以毫秒为单位，设置 key 过期时间。（时间间隔）</td>\n</tr>\n<tr>\n<td><code>EXPIREAT</code>  key timestamp</td>\n<td>与 EXPIRE 类似，以秒为单位，不同点在于该命令接受的时间参数是 UNIX 时间戳（unix timestamp）<font color='red'>（时刻）</font></td>\n</tr>\n<tr>\n<td>PEXPIREAT key milliseconds-timestamp</td>\n<td>以毫秒为单位，设置 key 过期时间的 UNIX 时间戳。<font color='red'>（时刻）</font></td>\n</tr>\n<tr>\n<td><code>KEYS</code>  pattern</td>\n<td>查找所有符合给定模式（pattern）的 key。例如  <code>KEYS *</code>  查看当前数据库的所有 key。</td>\n</tr>\n<tr>\n<td><code>MOVE</code>  key dbindex[0-15]</td>\n<td>将当前数据库的 key 移动到指定数据库 [0-15] 中，默认为 0</td>\n</tr>\n<tr>\n<td><code>SELECT</code>  dbindex</td>\n<td>切换到指定的数据库 [0-15]，默认为 0</td>\n</tr>\n<tr>\n<td><code>DBSIZE</code></td>\n<td>查看当前数据库的 key 数量</td>\n</tr>\n<tr>\n<td><code>FLUSHDB</code></td>\n<td>清空当前库</td>\n</tr>\n<tr>\n<td><code>FLUSHALL</code></td>\n<td>通杀所有库</td>\n</tr>\n<tr>\n<td><code>PERSIST</code>  key</td>\n<td>持久保持 key，移除其过期时间</td>\n</tr>\n<tr>\n<td><code>TTL</code>  key</td>\n<td>以秒为单位，返回 key 的剩余生存时间（TTL，time to live）。<font color='red'>其中 -1 表示永不过期，-2 表示已过期</font>。</td>\n</tr>\n<tr>\n<td>PTTL key</td>\n<td>以毫秒为单位，返回 key 的剩余生存时间</td>\n</tr>\n<tr>\n<td>RANDOMKEY</td>\n<td>从当前数据库中随机返回一个 key</td>\n</tr>\n<tr>\n<td>RENAME key newkey</td>\n<td>将 key 改名为 newkey</td>\n</tr>\n<tr>\n<td>RENAMENX key newkey</td>\n<td>仅当 newkey 不存在时，将 key 改名为 newkey</td>\n</tr>\n<tr>\n<td><code>TYPE</code>  key</td>\n<td>返回 key 所存储<font color='red'> value 的数据类型</font></td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"redis-数据类型\"><a class=\"anchor\" href=\"#redis-数据类型\">#</a> <mark>🌟Redis 数据类型</mark></h1>\n<p>前文已声明过 Redis 是基于 Key-Value 的，而 <strong><font color='orange'>key 类型一般是 String，这里所介绍的数据类型指的是 value 的数据类型</font></strong>。</p>\n<h2 id=\"常用数据类型\"><a class=\"anchor\" href=\"#常用数据类型\">#</a> <mark>🌟常用数据类型</mark></h2>\n<blockquote>\n<p>更多 Redis value 数据类型 命令以及详细使用指南，请查看 Redis 官网对应的介绍：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9yZWRpcy5pby9jb21tYW5kcw==\">https://redis.io/commands</span></p>\n</blockquote>\n<p>Redis 中比较常见的数据类型有下面这些：</p>\n<ul>\n<li><strong><font color='red'>5 种基础数据类型</font></strong>： <code>String</code> （字符串）、 <code>List</code> （列表）、 <code>Set</code> （集合）、 <code>Hash</code> （散列）、 <code>Zset</code> （有序集合）。</li>\n<li><strong><font color='red'>3 种特殊数据类型</font></strong>： <code>HyperLogLog</code> （基数统计）、 <code>Bitmap</code> （位图）、 <code>Geospatial</code>  (地理位置)。</li>\n</ul>\n<p>除了上面提到的之外，还有一些其他的比如 <a href=\"https://javaguide.cn/cs-basics/data-structure/bloom-filter.html\"> <code>Bloom filter</code> （布隆过滤器）</a>、 <code>Bitfield</code> （位域）。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231203143049962.png\" alt=\"image-20231203143049962\" /></p>\n<h3 id=\"5-种基础数据类型\"><a class=\"anchor\" href=\"#5-种基础数据类型\">#</a> 5 种基础数据类型</h3>\n<p>Redis 共有 5 种基本数据类型：String（字符串）、List（列表）、Set（集合）、Hash（散列）、Zset（有序集合）。</p>\n<p>这 5 种数据类型是直接提供给用户使用的，是数据的保存形式，其底层实现主要依赖这 8 种数据结构：简单动态字符串（ <code>SDS</code> ）、 <code>LinkedList</code> （双向链表）、 <code>Dict</code> （哈希表 / 字典）、 <code>SkipList</code> （跳跃表）、 <code>Intset</code> （整数集合）、 <code>ZipList</code> （压缩列表）、 <code>QuickList</code> （快速列表）。</p>\n<p>**<font color='red'>5 种基本数据类型对应的底层数据结构</font>** 实现如下表所示：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">String</th>\n<th style=\"text-align:left\">List</th>\n<th style=\"text-align:left\">Hash</th>\n<th style=\"text-align:left\">Set</th>\n<th style=\"text-align:left\">Zset</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">SDS</td>\n<td style=\"text-align:left\">LinkedList/ZipList/QuickList</td>\n<td style=\"text-align:left\">Dict、ZipList</td>\n<td style=\"text-align:left\">Dict、Intset</td>\n<td style=\"text-align:left\">ZipList、SkipList</td>\n</tr>\n</tbody>\n</table>\n<p>Redis 3.2 之前，List 底层实现是 LinkedList 或者 ZipList。 Redis 3.2 之后，引入了 LinkedList 和 ZipList 的结合 QuickList，List 的底层实现变为 QuickList。从 Redis 7.0 开始， ZipList 被 ListPack 取代。</p>\n<p>你可以在 Redis 官网上找到 Redis 数据类型 / 结构非常详细的介绍：</p>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9yZWRpcy5jb20vcmVkaXMtZW50ZXJwcmlzZS9kYXRhLXN0cnVjdHVyZXMv\">Redis Data Structures</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9yZWRpcy5pby9kb2NzL21hbnVhbC9kYXRhLXR5cGVzL2RhdGEtdHlwZXMtdHV0b3JpYWwv\">Redis Data types tutorial</span></li>\n</ul>\n<p>未来随着 Redis 新版本的发布，可能会有新的数据结构出现，通过查阅 Redis 官网对应的介绍，你总能获取到最靠谱的信息。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20220720181630203.png\" alt=\"img\" /></p>\n<h4 id=\"string字符串\"><a class=\"anchor\" href=\"#string字符串\">#</a> String（字符串）</h4>\n<h5 id=\"介绍\"><a class=\"anchor\" href=\"#介绍\">#</a> 介绍</h5>\n<p>String 是 Redis 中<font color='red'>最简单、最常用</font>的一个数据类型。</p>\n<p>String 是一种 **<font color='red'>二进制安全</font>** 的数据类型，<font color='red'>可以用来存储任何类型的数据</font>，比如字符串、整数、浮点数、图片（图片的 base64 编码或者解码或者图片的路径）、序列化后的对象。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20220719124403897.png\" alt=\"img\" /></p>\n<p>虽然 Redis 是用 C 语言写的，但是 Redis 并没有使用 C 的字符串表示，而是自己构建了一种 <strong><font color='red'>简单动态字符串</font></strong>（Simple Dynamic String， <code>SDS</code> ）。相比于 C 的原生字符串，Redis 的 <font color='red'>SDS 不光可以保存文本数据，还可以保存二进制数据，并且获取字符串长度复杂度为 O (1)</font>（C 字符串为 O (N)）。此外，Redis 的 <font color='red'>SDS API 是安全的，不会造成缓冲区溢出</font>。</p>\n<h5 id=\"命令\"><a class=\"anchor\" href=\"#命令\">#</a> 命令</h5>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>介绍</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>SET key value</td>\n<td>设置指定 key 的值</td>\n</tr>\n<tr>\n<td><code>SETNX</code>  key value</td>\n<td>只有在<font color='red'> key 不存在时</font>设置 key 的值</td>\n</tr>\n<tr>\n<td>GET key</td>\n<td>获取指定 key 的值</td>\n</tr>\n<tr>\n<td><code>MSET</code>  key1 value1 key2 value2 ……</td>\n<td>设置一个或<font color='red'>多个</font>指定 key 的值</td>\n</tr>\n<tr>\n<td>MGET key1 key2 ...</td>\n<td>获取一个或多个指定 key 的值</td>\n</tr>\n<tr>\n<td><code>STRLEN</code>  key</td>\n<td>返回 key 所储存的<font color='red'>字符串值的长度</font></td>\n</tr>\n<tr>\n<td><code>INCR</code>  key</td>\n<td>将 key 中储存的数字值增一</td>\n</tr>\n<tr>\n<td><code>DECR</code>  key</td>\n<td>将 key 中储存的数字值减一</td>\n</tr>\n<tr>\n<td>EXISTS key</td>\n<td>判断指定 key 是否存在</td>\n</tr>\n<tr>\n<td><code>DEL</code>  key（通用）</td>\n<td>删除指定的 key</td>\n</tr>\n<tr>\n<td><code>EXPIRE</code>  key seconds（通用）</td>\n<td>给指定 key 设置过期时间</td>\n</tr>\n</tbody>\n</table>\n<p><strong>基本操作</strong>：</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token operator\">></span> SET key value</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>OK</pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token operator\">></span> GET key</pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token string\">\"value\"</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token operator\">></span> EXISTS key</pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token punctuation\">(</span>integer<span class=\"token punctuation\">)</span> <span class=\"token number\">1</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token operator\">></span> STRLEN key</pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token punctuation\">(</span>integer<span class=\"token punctuation\">)</span> <span class=\"token number\">5</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token operator\">></span> DEL key</pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token punctuation\">(</span>integer<span class=\"token punctuation\">)</span> <span class=\"token number\">1</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token operator\">></span> GET key</pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token punctuation\">(</span>nil<span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p><strong>批量设置</strong>：</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token operator\">></span> MSET key1 value1 key2 value2</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>OK</pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token operator\">></span> MGET key1 key2 <span class=\"token comment\"># 批量获取多个 key 对应的 value</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token string\">\"value1\"</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token string\">\"value2\"</span></pre></td></tr></table></figure><p><strong>计数器（字符串的内容为整数的时候可以使用）：</strong></p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token operator\">></span> SET number <span class=\"token number\">1</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>OK</pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token operator\">></span> INCR number <span class=\"token comment\"># 将 key 中储存的数字值增一</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token punctuation\">(</span>integer<span class=\"token punctuation\">)</span> <span class=\"token number\">2</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token operator\">></span> GET number</pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token string\">\"2\"</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token operator\">></span> DECR number <span class=\"token comment\"># 将 key 中储存的数字值减一</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token punctuation\">(</span>integer<span class=\"token punctuation\">)</span> <span class=\"token number\">1</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token operator\">></span> GET number</pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token string\">\"1\"</span></pre></td></tr></table></figure><p><strong>设置过期时间（默认为永不过期）</strong>：</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token operator\">></span> EXPIRE key <span class=\"token number\">60</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">(</span>integer<span class=\"token punctuation\">)</span> <span class=\"token number\">1</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token operator\">></span> SETEX key <span class=\"token number\">60</span> value <span class=\"token comment\"># 设置值并设置过期时间</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>OK</pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token operator\">></span> TTL key</pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token punctuation\">(</span>integer<span class=\"token punctuation\">)</span> <span class=\"token number\">56</span></pre></td></tr></table></figure><h5 id=\"string-应用\"><a class=\"anchor\" href=\"#string-应用\">#</a> String 应用</h5>\n<p><strong><font color='red'>常规数据的缓存</font></strong></p>\n<ul>\n<li>举例：缓存 Session、Token、图片地址、序列化后的对象 (相比较于 Hash 存储更节省内存)。</li>\n<li>相关命令： <code>SET</code> 、 <code>GET</code> 。</li>\n</ul>\n<p><strong>需要<font color='red'>计数</font>的场景</strong></p>\n<ul>\n<li>举例：用户单位时间的请求数（简单限流可以用到）、页面单位时间的访问数。</li>\n<li>相关命令： <code>SET</code> 、 <code>GET</code> 、  <code>INCR</code> 、 <code>DECR</code>  。</li>\n</ul>\n<p><strong><font color='red'>分布式锁</font></strong></p>\n<p>利用  <code>SETNX key value</code>  命令可以实现一个最简易的分布式锁（存在一些缺陷，通常不建议这样实现分布式锁）。</p>\n<h4 id=\"list列表\"><a class=\"anchor\" href=\"#list列表\">#</a> List（列表）</h4>\n<h5 id=\"介绍-2\"><a class=\"anchor\" href=\"#介绍-2\">#</a> 介绍</h5>\n<p>Redis 中的 List 其实就是<font color='red'>链表数据结构的实现</font>。我在 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9qYXZhZ3VpZGUuY24vY3MtYmFzaWNzL2RhdGEtc3RydWN0dXJlL2xpbmVhci1kYXRhLXN0cnVjdHVyZS5odG1s\">线性数据结构：数组、链表、栈、队列</span> 这篇文章中详细介绍了链表这种数据结构，我这里就不多做介绍了。</p>\n<p>许多高级编程语言都内置了链表的实现比如 Java 中的  <code>LinkedList</code> ，但是 C 语言并没有实现链表，所以 Redis 实现了自己的链表数据结构。Redis 的 List 的实现为一个 **<font color='#B32015'>双向链表</font>**，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20220719124413287.png\" alt=\"img\" /></p>\n<h5 id=\"命令-2\"><a class=\"anchor\" href=\"#命令-2\">#</a> 命令</h5>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>介绍</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>RPUSH</code>  key value1 value2 ...</td>\n<td>在指定列表的尾部（右边）添加一个或多个元素</td>\n</tr>\n<tr>\n<td>LPUSH key value1 value2 ...</td>\n<td>在指定列表的头部（左边）添加一个或多个元素</td>\n</tr>\n<tr>\n<td><code>LSET</code>  key index value</td>\n<td>将指定列表索引 index 位置的值设置为 value</td>\n</tr>\n<tr>\n<td><code>RPOP</code>  key</td>\n<td>移除并获取指定列表的最后一个元素 (最右边)</td>\n</tr>\n<tr>\n<td>LPOP key</td>\n<td>移除并获取指定列表的第一个元素 (最左边)</td>\n</tr>\n<tr>\n<td><code>LLEN</code>  key</td>\n<td>获取列表元素数量</td>\n</tr>\n<tr>\n<td><code>LRANGE</code>  key start end</td>\n<td>获取列表 start 和 end 之间 的元素</td>\n</tr>\n</tbody>\n</table>\n<p>通过  <code>RPUSH/LPOP</code>  或者  <code>LPUSH/RPOP</code> <strong> 实现队列（先进先出）</strong>：</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token operator\">></span> RPUSH myList value1</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">(</span>integer<span class=\"token punctuation\">)</span> <span class=\"token number\">1</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token operator\">></span> RPUSH myList value2 value3</pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token punctuation\">(</span>integer<span class=\"token punctuation\">)</span> <span class=\"token number\">3</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token operator\">></span> LPOP myList</pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token string\">\"value1\"</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token operator\">></span> LRANGE myList <span class=\"token number\">0</span> <span class=\"token number\">1</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token string\">\"value2\"</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token string\">\"value3\"</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token operator\">></span> LRANGE myList <span class=\"token number\">0</span> <span class=\"token parameter variable\">-1</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token string\">\"value2\"</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token string\">\"value3\"</span></pre></td></tr></table></figure><p>通过  <code>RPUSH/RPOP</code>  或者 <code>LPUSH/LPOP</code>  <strong>实现栈（先进后出）</strong>：</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token operator\">></span> RPUSH myList2 value1 value2 value3</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">(</span>integer<span class=\"token punctuation\">)</span> <span class=\"token number\">3</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token operator\">></span> RPOP myList2 <span class=\"token comment\"># 将 list 的最右边的元素取出</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token string\">\"value3\"</span></pre></td></tr></table></figure><p>我专门画了一个图方便大家理解  <code>RPUSH</code>  ,  <code>LPOP</code>  ,  <code>lpush</code>  ,  <code>RPOP</code>  命令：</p>\n<p><img data-src=\"https://oss.javaguide.cn/github/javaguide/database/redis/redis-list.png\" alt=\"img\" /></p>\n<p>通过  <code>LRANGE</code>  <strong>查看对应下标范围的列表元素</strong>：</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token operator\">></span> RPUSH myList value1 value2 value3</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">(</span>integer<span class=\"token punctuation\">)</span> <span class=\"token number\">3</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token operator\">></span> LRANGE myList <span class=\"token number\">0</span> <span class=\"token number\">1</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token string\">\"value1\"</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token string\">\"value2\"</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token operator\">></span> LRANGE myList <span class=\"token number\">0</span> <span class=\"token parameter variable\">-1</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token string\">\"value1\"</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token string\">\"value2\"</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token number\">3</span><span class=\"token punctuation\">)</span> <span class=\"token string\">\"value3\"</span></pre></td></tr></table></figure><p>通过  <code>LRANGE</code>  命令，你可以<font color='red'>基于 List 实现分页查询</font>，性能非常高！</p>\n<p>通过  <code>LLEN</code>  <strong>查看链表长度</strong>：</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token operator\">></span> LLEN myList</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">(</span>integer<span class=\"token punctuation\">)</span> <span class=\"token number\">3</span></pre></td></tr></table></figure><h5 id=\"应用\"><a class=\"anchor\" href=\"#应用\">#</a> 应用</h5>\n<p><strong>信息流展示</strong></p>\n<ul>\n<li>举例：最新文章、最新动态。</li>\n<li>相关命令： <code>LPUSH</code> 、 <code>LRANGE</code> 。</li>\n</ul>\n<p><strong>消息队列</strong></p>\n<p><code>List</code>  可以用来做消息队列，只是<font color='red'>功能过于简单且存在很多缺陷</font>，不建议这样做。</p>\n<p>相对来说，Redis 5.0 新增加的一个数据结构  <code>Stream</code>  更适合做消息队列一些，只是功能依然非常简陋。和专业的消息队列相比，还是有很多欠缺的地方比如<font color='red'>消息丢失和堆积问题</font>不好解决。</p>\n<h4 id=\"hash哈希\"><a class=\"anchor\" href=\"#hash哈希\">#</a> Hash（哈希）</h4>\n<h5 id=\"介绍-3\"><a class=\"anchor\" href=\"#介绍-3\">#</a> 介绍</h5>\n<p>Redis 中的 Hash 是一个<font color='red'> String 类型的 field-value（键值对） </font>的映射表，特别适合用于<font color='red'>存储对象</font>，后续操作的时候，你可以直接修改这个对象中的某些字段的值。</p>\n<p>Hash 类似于 JDK1.8 前的  <code>HashMap</code> ，内部实现也差不多 (<font color='red'>数组 + 链表</font>)。不过，Redis 的 Hash 做了更多优化。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20220719124421703.png\" alt=\"img\" /></p>\n<h5 id=\"命令-3\"><a class=\"anchor\" href=\"#命令-3\">#</a> 命令</h5>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>介绍</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>HSET</code>  key field value</td>\n<td>将指定哈希表 key 中指定字段 field 的值设置为 value</td>\n</tr>\n<tr>\n<td>HSETNX key field value</td>\n<td>仅当指定字段 field 不存在时，设置其值</td>\n</tr>\n<tr>\n<td><code>HMSET</code>  key field1 value1 field2 value2 ...</td>\n<td>同时将一个或<font color='red'>多个</font> field-value (域 - 值) 对设置到指定哈希表 key 中</td>\n</tr>\n<tr>\n<td>HGET key field</td>\n<td>获取指定哈希表中指定字段的<font color='red'>值</font></td>\n</tr>\n<tr>\n<td>HMGET key field1 field2 ...</td>\n<td>获取指定哈希表中一个或者多个指定字段的<font color='red'>值</font></td>\n</tr>\n<tr>\n<td><code>HGETALL</code>  key</td>\n<td>获取指定哈希表 key 中所有的 **<font color='red'>键值对</font>**</td>\n</tr>\n<tr>\n<td><code>HEXISTS</code>  key field</td>\n<td>查看指定哈希表中指定的字段是否存在</td>\n</tr>\n<tr>\n<td><code>HDEL</code>  key field1 field2 ...</td>\n<td>删除一个或多个哈希表字段</td>\n</tr>\n<tr>\n<td><code>HLEN</code>  key</td>\n<td>获取指定哈希表中字段的数量</td>\n</tr>\n<tr>\n<td><code>HINCRBY</code>  key field increment</td>\n<td>对指定哈希中的指定字段做运算操作（正数为加，负数为减）</td>\n</tr>\n</tbody>\n</table>\n<p><strong>模拟对象数据存储</strong>：</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token operator\">></span> HMSET userInfoKey name <span class=\"token string\">\"guide\"</span> description <span class=\"token string\">\"dev\"</span> age <span class=\"token number\">24</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>OK</pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token operator\">></span> HEXISTS userInfoKey name <span class=\"token comment\"># 查看 key 对应的 value 中指定的字段是否存在。</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token punctuation\">(</span>integer<span class=\"token punctuation\">)</span> <span class=\"token number\">1</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token operator\">></span> HGET userInfoKey name <span class=\"token comment\"># 获取存储在哈希表中指定字段的值。</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token string\">\"guide\"</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token operator\">></span> HGET userInfoKey age</pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token string\">\"24\"</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token operator\">></span> HGETALL userInfoKey <span class=\"token comment\"># 获取在哈希表中指定 key 的所有字段和值</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token string\">\"name\"</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token string\">\"guide\"</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token number\">3</span><span class=\"token punctuation\">)</span> <span class=\"token string\">\"description\"</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token number\">4</span><span class=\"token punctuation\">)</span> <span class=\"token string\">\"dev\"</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre><span class=\"token number\">5</span><span class=\"token punctuation\">)</span> <span class=\"token string\">\"age\"</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre><span class=\"token number\">6</span><span class=\"token punctuation\">)</span> <span class=\"token string\">\"24\"</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre><span class=\"token operator\">></span> HSET userInfoKey name <span class=\"token string\">\"GuideGeGe\"</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre><span class=\"token operator\">></span> HGET userInfoKey name</pre></td></tr><tr><td data-num=\"18\"></td><td><pre><span class=\"token string\">\"GuideGeGe\"</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre><span class=\"token operator\">></span> HINCRBY userInfoKey age <span class=\"token number\">2</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre><span class=\"token punctuation\">(</span>integer<span class=\"token punctuation\">)</span> <span class=\"token number\">26</span></pre></td></tr></table></figure><h5 id=\"应用-2\"><a class=\"anchor\" href=\"#应用-2\">#</a> 应用</h5>\n<p><strong><font color='#B32015'>对象数据存储场景</font></strong></p>\n<ul>\n<li>举例：用户信息、商品信息、文章信息、购物车信息。</li>\n<li>相关命令： <code>HSET</code>  （设置单个字段的值）、 <code>HMSET</code> （设置多个字段的值）、 <code>HGET</code> （获取单个字段的值）、 <code>HMGET</code> （获取多个字段的值）。</li>\n</ul>\n<h4 id=\"set集合\"><a class=\"anchor\" href=\"#set集合\">#</a> Set（集合）</h4>\n<h5 id=\"介绍-4\"><a class=\"anchor\" href=\"#介绍-4\">#</a> 介绍</h5>\n<p>Redis 中的 Set 类型是一种无序集合，集合中的 **<font color='red'>元素没有先后顺序，但都唯一（不重复）</font>**，有点类似于 Java 中的  <code>HashSet</code>  。当你需要存储一个列表数据，又不希望出现重复数据时，Set 是一个很好的选择，并且 Set 提供了判断某个元素是否在一个 Set 集合内的重要接口，这个也是 List 所不能提供的。</p>\n<p>你可以基于 Set 轻易实现<font color='red'>交集、并集、差集</font>的操作，比如你可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。这样的话，Set 可以非常方便的实现如共同关注、共同粉丝、共同喜好等功能。这个过程也就是求交集的过程。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20220719124430264.png\" alt=\"img\" /></p>\n<h5 id=\"命令-4\"><a class=\"anchor\" href=\"#命令-4\">#</a> 命令</h5>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>介绍</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>SADD</code>  key member1 member2 ...</td>\n<td>向指定集合添加一个或多个元素</td>\n</tr>\n<tr>\n<td><code>SMEMBERS</code>  key</td>\n<td>获取指定集合中的所有元素</td>\n</tr>\n<tr>\n<td><code>SCARD</code>  key</td>\n<td>获取指定集合的元素数量</td>\n</tr>\n<tr>\n<td><code>SISMEMBER</code>  key member</td>\n<td>判断指定元素是否在指定集合中</td>\n</tr>\n<tr>\n<td><code>SINTER</code>  key1 key2 ...</td>\n<td>获取给定所有集合的交集</td>\n</tr>\n<tr>\n<td>SINTERSTORE destination key1 key2 ...</td>\n<td>将给定所有集合的交集存储在 destination 中</td>\n</tr>\n<tr>\n<td><code>SUNION</code>  key1 key2 ...</td>\n<td>获取给定所有集合的并集</td>\n</tr>\n<tr>\n<td>SUNIONSTORE destination key1 key2 ...</td>\n<td>将给定所有集合的并集存储在 destination 中</td>\n</tr>\n<tr>\n<td><code>SDIFF</code>  key1 key2 ...</td>\n<td>获取给定所有集合的差集</td>\n</tr>\n<tr>\n<td>SDIFFSTORE destination key1 key2 ...</td>\n<td>将给定所有集合的差集存储在 destination 中</td>\n</tr>\n<tr>\n<td><code>SPOP</code>  key count</td>\n<td>随机移除并获取指定集合中一个或多个元素</td>\n</tr>\n<tr>\n<td><code>SRANDMEMBER</code>  key count</td>\n<td>随机获取指定集合中指定数量的元素</td>\n</tr>\n</tbody>\n</table>\n<p><strong>基本操作</strong>：</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token operator\">></span> SADD mySet value1 value2</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">(</span>integer<span class=\"token punctuation\">)</span> <span class=\"token number\">2</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token operator\">></span> SADD mySet value1 <span class=\"token comment\"># 不允许有重复元素，因此添加失败</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token punctuation\">(</span>integer<span class=\"token punctuation\">)</span> <span class=\"token number\">0</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token operator\">></span> SMEMBERS mySet</pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token string\">\"value1\"</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token string\">\"value2\"</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token operator\">></span> SCARD mySet</pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token punctuation\">(</span>integer<span class=\"token punctuation\">)</span> <span class=\"token number\">2</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token operator\">></span> SISMEMBER mySet value1</pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token punctuation\">(</span>integer<span class=\"token punctuation\">)</span> <span class=\"token number\">1</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token operator\">></span> SADD mySet2 value2 value3</pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token punctuation\">(</span>integer<span class=\"token punctuation\">)</span> <span class=\"token number\">2</span></pre></td></tr></table></figure><ul>\n<li><code>mySet</code>  :  <code>value1</code> 、 <code>value2</code></li>\n<li><code>mySet2</code> ： <code>value2</code> 、 <code>value3</code></li>\n</ul>\n<p><strong>求交集</strong>：</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token operator\">></span> SINTERSTORE mySet3 mySet mySet2</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">(</span>integer<span class=\"token punctuation\">)</span> <span class=\"token number\">1</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token operator\">></span> SMEMBERS mySet3</pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token string\">\"value2\"</span></pre></td></tr></table></figure><p><strong>求并集</strong>：</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token operator\">></span> SUNION mySet mySet2</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token string\">\"value3\"</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token string\">\"value2\"</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token number\">3</span><span class=\"token punctuation\">)</span> <span class=\"token string\">\"value1\"</span></pre></td></tr></table></figure><p><strong>求差集</strong>：</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token operator\">></span> SDIFF mySet mySet2 <span class=\"token comment\"># 差集是由所有属于 mySet 但不属于 A 的元素组成的集合</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token string\">\"value1\"</span></pre></td></tr></table></figure><h5 id=\"set-应用\"><a class=\"anchor\" href=\"#set-应用\">#</a> Set 应用</h5>\n<p><strong>需要存放的<font color='red'>数据不能重复</font>的场景</strong></p>\n<ul>\n<li>举例：<font color='red'>网站 UV （Unique Visitor，独立访客）统计</font>（数据量巨大的场景还是  <code>HyperLogLog</code>  更适合一些）、<font color='red'>点赞数统计</font>等场景。</li>\n<li>相关命令： <code>SCARD</code> （获取集合数量）。</li>\n</ul>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20220719073733851.png\" alt=\"img\" /></p>\n<p><strong>需要获取多个数据源<font color='red'>交集、并集和差集</font>的场景</strong></p>\n<ul>\n<li>举例：共同好友 (交集)、共同粉丝 (交集)、共同关注 (交集)、好友推荐（差集）、音乐推荐（差集）、订阅号推荐（差集 + 交集） 等场景。</li>\n<li>相关命令： <code>SINTER</code> （交集）、 <code>SINTERSTORE</code>  （交集）、 <code>SUNION</code>  （并集）、 <code>SUNIONSTORE</code> （并集）、 <code>SDIFF</code> （差集）、 <code>SDIFFSTORE</code>  （差集）。</li>\n</ul>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20220719074543513.png\" alt=\"img\" /></p>\n<p><strong>需要<font color='red'>随机获取数据源中的元素</font>的场景</strong></p>\n<ul>\n<li>举例：<font color='red'>抽奖系统、随机点名</font>等场景。</li>\n<li>相关命令： <code>SPOP</code> （随机获取集合中的元素并移除，适合<font color='red'>不允许重复中奖</font>的场景）、 <code>SRANDMEMBER</code> （随机获取集合中的元素，适合<font color='red'>允许重复中奖</font>的场景）。</li>\n</ul>\n<h4 id=\"sorted-setzset有序集合\"><a class=\"anchor\" href=\"#sorted-setzset有序集合\">#</a> Sorted Set/Zset（有序集合）</h4>\n<h5 id=\"介绍-5\"><a class=\"anchor\" href=\"#介绍-5\">#</a> 介绍</h5>\n<p>Sorted Set 也称 Zset，和 Set 相比 **<font color='red'>增加了一个权重参数</font>**  <code>score</code> ，使得集合中的元素能够按  <code>score</code>  进行 **<font color='red'>有序排列</font>**，还可以通过  <code>score</code>  的范围来获取元素的列表。有点像是 Java 中  <code>HashMap</code>  和  <code>TreeSet</code>  的结合体。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20220719124437791.png\" alt=\"img\" /></p>\n<h5 id=\"命令-5\"><a class=\"anchor\" href=\"#命令-5\">#</a> 命令</h5>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>介绍</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>ZADD</code>  key score1 member1 score2 member2 ...</td>\n<td>向指定有序集合添加一个或多个元素</td>\n</tr>\n<tr>\n<td><code>ZCARD</code>  KEY</td>\n<td>获取指定有序集合的元素数量</td>\n</tr>\n<tr>\n<td><code>ZSCORE</code>  key member</td>\n<td>获取指定有序集合中指定元素的 score 值</td>\n</tr>\n<tr>\n<td><code>ZINTERSTORE</code>  destination numkeys key1 key2 ...</td>\n<td>将给定所有有序集合的交集存储在 destination 中，<strong><font color='red'>对相同元素对应的 score 值进行 SUM 聚合操作</font></strong>，<font color='red'>numkeys 为集合数量</font></td>\n</tr>\n<tr>\n<td><code>ZUNIONSTORE</code>  destination numkeys key1 key2 ...</td>\n<td>求并集，其它和 ZINTERSTORE 类似</td>\n</tr>\n<tr>\n<td><code>ZDIFFSTORE</code>  destination numkeys key1 key2 ...</td>\n<td>求差集，其它和 ZINTERSTORE 类似</td>\n</tr>\n<tr>\n<td><code>ZRANGE</code>  key start end</td>\n<td>获取指定有序集合 start 和 end 之间的元素（<font color='red'>score 从低到高</font>）</td>\n</tr>\n<tr>\n<td><code>ZREVRANGE</code>  key start end</td>\n<td>获取指定有序集合 start 和 end 之间的元素（<font color='red'>score 从高到底</font>）</td>\n</tr>\n<tr>\n<td><code>ZREVRANK</code>  key member</td>\n<td>获取指定有序集合中指定元素的排名 (<font color='red'>score 从大到小排序</font>)</td>\n</tr>\n</tbody>\n</table>\n<p><strong>基本操作</strong>：</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token operator\">></span> ZADD myZset <span class=\"token number\">2.0</span> value1 <span class=\"token number\">1.0</span> value2</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">(</span>integer<span class=\"token punctuation\">)</span> <span class=\"token number\">2</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token operator\">></span> ZCARD myZset</pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token number\">2</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token operator\">></span> ZSCORE myZset value1</pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token number\">2.0</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token operator\">></span> ZRANGE myZset <span class=\"token number\">0</span> <span class=\"token number\">1</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token string\">\"value2\"</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token string\">\"value1\"</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token operator\">></span> ZREVRANGE myZset <span class=\"token number\">0</span> <span class=\"token number\">1</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token string\">\"value1\"</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token string\">\"value2\"</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token operator\">></span> ZADD myZset2 <span class=\"token number\">4.0</span> value2 <span class=\"token number\">3.0</span> value3</pre></td></tr><tr><td data-num=\"14\"></td><td><pre><span class=\"token punctuation\">(</span>integer<span class=\"token punctuation\">)</span> <span class=\"token number\">2</span></pre></td></tr></table></figure><ul>\n<li><code>myZset</code>  :  <code>value1</code> (2.0)、 <code>value2</code> (1.0) 。</li>\n<li><code>myZset2</code> ： <code>value2</code>  （4.0）、 <code>value3</code> (3.0) 。</li>\n</ul>\n<p><strong>获取指定元素的排名</strong>：</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token operator\">></span> ZREVRANK myZset value1</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token number\">0</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token operator\">></span> ZREVRANK myZset value2</pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token number\">1</span></pre></td></tr></table></figure><p><strong>求交集</strong>：</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token operator\">></span> ZINTERSTORE myZset3 <span class=\"token number\">2</span> myZset myZset2</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token number\">1</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token operator\">></span> ZRANGE myZset3 <span class=\"token number\">0</span> <span class=\"token number\">1</span> WITHSCORES</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>value2</pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token number\">5</span></pre></td></tr></table></figure><p><strong>求并集</strong>：</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token operator\">></span> ZUNIONSTORE myZset4 <span class=\"token number\">2</span> myZset myZset2</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token number\">3</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token operator\">></span> ZRANGE myZset4 <span class=\"token number\">0</span> <span class=\"token number\">2</span> WITHSCORES</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>value1</pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token number\">2</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>value3</pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token number\">3</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>value2</pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token number\">5</span></pre></td></tr></table></figure><p><strong>求差集</strong>：</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token operator\">></span> ZDIFF <span class=\"token number\">2</span> myZset myZset2 WITHSCORES</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>value1</pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token number\">2</span></pre></td></tr></table></figure><h5 id=\"zset-应用\"><a class=\"anchor\" href=\"#zset-应用\">#</a> Zset 应用</h5>\n<p><strong>需要<font color='red'>根据某个权重对元素进行排序（排行榜）</font>的场景</strong></p>\n<ul>\n<li>举例：各种排行榜比如直播间送礼物的排行榜、朋友圈的微信步数排行榜、王者荣耀中的段位排行榜、话题热度排行榜等等。</li>\n<li>相关命令： <code>ZRANGE</code>  (从小到大排序)、  <code>ZREVRANGE</code>  （从大到小排序）、 <code>ZREVRANK</code>  (获取指定元素的排名)。</li>\n</ul>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/2021060714195385.png\" alt=\"img\" /></p>\n<hr />\n<p>Sorted Set 能够轻松应对百万级别的用户数据排序，简直就是专门为排行榜设计的数据结构！下面详细介绍一下如何使用 Sorted Set 来设计制作一个排行榜：</p>\n<table>\n<thead>\n<tr>\n<th>User</th>\n<th>Score</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>user1</td>\n<td>112.0</td>\n</tr>\n<tr>\n<td>user2</td>\n<td>100.0</td>\n</tr>\n<tr>\n<td>user3</td>\n<td>123.0</td>\n</tr>\n<tr>\n<td>user4</td>\n<td>100.0</td>\n</tr>\n<tr>\n<td>user5</td>\n<td>33.0</td>\n</tr>\n<tr>\n<td>user6</td>\n<td>993.0</td>\n</tr>\n</tbody>\n</table>\n<p>把上表中的数据添加到 Sorted Set 中：</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># 通过 zadd 命令添加了 6 个元素到 cus_order_set 中</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token number\">127.0</span>.0.1:637<span class=\"token operator\"><span class=\"token file-descriptor important\">9</span>></span> ZADD cus_order_set <span class=\"token number\">112.0</span> user1 <span class=\"token number\">100.0</span> user2 <span class=\"token number\">123.0</span> user3 <span class=\"token number\">100.0</span> user4 <span class=\"token number\">33.0</span> user5 <span class=\"token number\">993.0</span> user6</pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">(</span>integer<span class=\"token punctuation\">)</span> <span class=\"token number\">6</span></pre></td></tr></table></figure><p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/up-c25cf4cc1d4d3a484b4db93672138b8c104.png\" alt=\"img\" /></p>\n<p><strong>查看包含所有用户的排行榜：</strong> 通过 ZRANGE (从小到大排序) / ZREVRANGE （从大到小排序）</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># -1 代表的是全部的用户数据，</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token number\">127.0</span>.0.1:637<span class=\"token operator\"><span class=\"token file-descriptor important\">9</span>></span> ZREVRANGE cus_order_set <span class=\"token number\">0</span> <span class=\"token parameter variable\">-1</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token string\">\"user6\"</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token string\">\"user3\"</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token number\">3</span><span class=\"token punctuation\">)</span> <span class=\"token string\">\"user1\"</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token number\">4</span><span class=\"token punctuation\">)</span> <span class=\"token string\">\"user4\"</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token number\">5</span><span class=\"token punctuation\">)</span> <span class=\"token string\">\"user2\"</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token number\">6</span><span class=\"token punctuation\">)</span> <span class=\"token string\">\"user5\"</span></pre></td></tr></table></figure><p><strong>查看只包含前 3 名的排行榜:</strong> 限定范围区间即可。</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># 0 为 start  2 为 stop</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token number\">127.0</span>.0.1:637<span class=\"token operator\"><span class=\"token file-descriptor important\">9</span>></span> ZREVRANGE cus_order_set <span class=\"token number\">0</span> <span class=\"token number\">2</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token string\">\"user6\"</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token string\">\"user3\"</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token number\">3</span><span class=\"token punctuation\">)</span> <span class=\"token string\">\"user1\"</span></pre></td></tr></table></figure><p><strong>查询某个用户的分数:</strong> 通过  <code>ZSCORE </code> 命令即可。</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token number\">127.0</span>.0.1:637<span class=\"token operator\"><span class=\"token file-descriptor important\">9</span>></span> ZSCORE  cus_order_set <span class=\"token string\">\"user1\"</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token string\">\"112\"</span></pre></td></tr></table></figure><p><strong>查询某个用户的排名:</strong> 通过  <code>ZREVRANK</code>  命令即可。</p>\n<pre><code class=\"language-bahs\">127.0.0.1:6379&gt; ZREVRANK  cus_order_set &quot;user3&quot;\n(integer) 1 # user3 排名第2\n</code></pre>\n<p><strong>对用户的排名数据进行更新:</strong> 通过  <code> ZINCRBY</code>  命令即可。</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># 对 user1 的分数加 2</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token number\">127.0</span>.0.1:637<span class=\"token operator\"><span class=\"token file-descriptor important\">9</span>></span> ZINCRBY cus_order_set +2 <span class=\"token string\">\"user1\"</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token string\">\"114\"</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token comment\"># 对 user1 的分数减 1</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token number\">127.0</span>.0.1:637<span class=\"token operator\"><span class=\"token file-descriptor important\">9</span>></span> ZINCRBY cus_order_set <span class=\"token parameter variable\">-1</span> <span class=\"token string\">\"user1\"</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token string\">\"113\"</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token comment\"># 查看 user1 的分数</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token number\">127.0</span>.0.1:637<span class=\"token operator\"><span class=\"token file-descriptor important\">9</span>></span> ZSCORE  cus_order_set <span class=\"token string\">\"user1\"</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token string\">\"113\"</span></pre></td></tr></table></figure><p>除了我上面提到的之外，还有一些其他的命令来帮助你解决更多排行榜场景的需求，想要深入研究的小伙伴可以仔细学习哦！</p>\n<p>不过，需要注意的一点是：<strong><font color='red'>Redis 中只保存了排行榜展示所需的数据，需要用户的具体信息数据的话，还是需要去对应的数据库（比如 MySQL）中查。</font></strong></p>\n<p>你以为这样就完事了？ 不存在的！还有一些无法仅仅通过 Redis 提供的命令解决的场景。</p>\n<p>比如，<strong>如何实现多条件排序？</strong> 其实，答案也比较简单，对于大部分场景，我们直接对 score 值做文章即可。</p>\n<p>更具体点的话就是，我们<font color='red'>根据特定的条件来拼接 score 值即可</font>。比如我们还要加上时间先后条件的话，直接在 score 值添加上时间戳即可。</p>\n<p>再比如，<strong>如何实现指定日期（比如最近 7 天）的用户数据排序？</strong></p>\n<p>我说一种比较简单的方法：我们把每一天的数据都按照日期为名字，比如 20350305 就代表 2035 年 3 月 5 号。</p>\n<p>如果我们需要查询最近 n 天的排行榜数据的话，直接 ZUNIONSTORE 来求 n 个  <code>sorted set </code> 的并集即可。</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>ZUNIONSTORE last_n_days n <span class=\"token number\">20350305</span> <span class=\"token number\">20350306</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span></pre></td></tr></table></figure><p>我不知道大家看懂了没有，我这里还是简单地造一些数据模拟一下吧！</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># 分别添加了 3 天的数据</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token number\">127.0</span>.0.1:637<span class=\"token operator\"><span class=\"token file-descriptor important\">9</span>></span> ZADD <span class=\"token number\">20350305</span> <span class=\"token number\">112.0</span> user1 <span class=\"token number\">100.0</span> user2 <span class=\"token number\">123.0</span> user3</pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">(</span>integer<span class=\"token punctuation\">)</span> <span class=\"token number\">3</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token number\">127.0</span>.0.1:637<span class=\"token operator\"><span class=\"token file-descriptor important\">9</span>></span> ZADD <span class=\"token number\">20350306</span> <span class=\"token number\">100.0</span> user4</pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">(</span>integer<span class=\"token punctuation\">)</span> <span class=\"token number\">1</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token number\">127.0</span>.0.1:637<span class=\"token operator\"><span class=\"token file-descriptor important\">9</span>></span> ZADD <span class=\"token number\">20350307</span> <span class=\"token number\">33.0</span> user5 <span class=\"token number\">993.0</span> user6</pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">(</span>integer<span class=\"token punctuation\">)</span> <span class=\"token number\">2</span></pre></td></tr></table></figure><p>通过 ZUNIONSTORE 命令来查看最近 3 天的排行榜情况：</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token number\">127.0</span>.0.1:637<span class=\"token operator\"><span class=\"token file-descriptor important\">9</span>></span> ZUNIONSTORE last_n_days <span class=\"token number\">3</span> <span class=\"token number\">20350305</span> <span class=\"token number\">20350306</span> <span class=\"token number\">20350307</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">(</span>integer<span class=\"token punctuation\">)</span> <span class=\"token number\">6</span></pre></td></tr></table></figure><p>现在，这 3 天的数据都集中在了 last_n_days 中。</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token number\">127.0</span>.0.1:637<span class=\"token operator\"><span class=\"token file-descriptor important\">9</span>></span> ZREVRANGE last_n_days <span class=\"token number\">0</span> <span class=\"token parameter variable\">-1</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token string\">\"user6\"</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token string\">\"user3\"</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token number\">3</span><span class=\"token punctuation\">)</span> <span class=\"token string\">\"user1\"</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token number\">4</span><span class=\"token punctuation\">)</span> <span class=\"token string\">\"user4\"</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token number\">5</span><span class=\"token punctuation\">)</span> <span class=\"token string\">\"user2\"</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token number\">6</span><span class=\"token punctuation\">)</span> <span class=\"token string\">\"user5\"</span></pre></td></tr></table></figure><p>如果一个用户同时在多个 <code> sorted set</code>  中的话，它最终的 <code>score</code>  值就等于这些 <code>sorted set</code>  中该用户的  <code>score </code> 值之和。</p>\n<p>既然可以求并集，那必然也可以求交集。你可以通过  <code>ZINTERSTORE </code> 命令来求多个 n 个  <code>sorted set</code>  的交集。</p>\n<p><strong>有哪些场景可以用到多个  <code>sorted set</code>  的交集呢？</strong> 比如每日打卡的场景，你对某一段时间每天打卡的人进行排序。</p>\n<p>这个命令还有一个常用的权重参数 <code>weights</code> （默认为 1）。在进行并集 / 交集的过程中，每个集合中的元素会将自己的  <code>score</code>  * <code>weights</code>  。</p>\n<p>我下面演示一下这个参数的作用。</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># staff_set 存放员工的排名信息</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token number\">127.0</span>.0.1:637<span class=\"token operator\"><span class=\"token file-descriptor important\">9</span>></span> ZADD staff_set <span class=\"token number\">3.0</span> staff1 <span class=\"token number\">4.0</span> staff2</pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">(</span>integer<span class=\"token punctuation\">)</span> <span class=\"token number\">2</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token comment\"># staff_set 存放管理者的排名信息</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token number\">127.0</span>.0.1:637<span class=\"token operator\"><span class=\"token file-descriptor important\">9</span>></span> ZADD manager_set <span class=\"token number\">1.0</span> manager1 <span class=\"token number\">2.0</span> manager2</pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token punctuation\">(</span>integer<span class=\"token punctuation\">)</span> <span class=\"token number\">2</span></pre></td></tr></table></figure><p>如果，我们需要将员工和管理者放在一起比较，不过，两者权重分别为 1 和 3。</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># staff_set 的权重为 1 manager_set 的权重为 3</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token number\">127.0</span>.0.1:637<span class=\"token operator\"><span class=\"token file-descriptor important\">9</span>></span> ZUNIONSTORE all_user_set <span class=\"token number\">2</span> staff_set manager_set WEIGHTS <span class=\"token number\">1</span> <span class=\"token number\">3</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">(</span>integer<span class=\"token punctuation\">)</span> <span class=\"token number\">4</span></pre></td></tr></table></figure><p>最终排序的结果如下：</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token number\">127.0</span>.0.1:637<span class=\"token operator\"><span class=\"token file-descriptor important\">9</span>></span> ZREVRANGE all_user_set <span class=\"token number\">0</span> <span class=\"token parameter variable\">-1</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token string\">\"manager2\"</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token string\">\"staff2\"</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token string\">\"staff1\"</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token number\">4</span><span class=\"token punctuation\">)</span><span class=\"token string\">\"manager1\"</span></pre></td></tr></table></figure><hr />\n<p><strong>需要存储的<font color='red'>数据有优先级</font>的场景</strong> 比如<font color='red'>优先级任务队列</font>。</p>\n<ul>\n<li>举例：优先级任务队列。</li>\n<li>相关命令： <code>ZRANGE</code>  (从小到大排序)、  <code>ZREVRANGE</code>  （从大到小排序）、 <code>ZREVRANK</code>  (指定元素排名)。</li>\n</ul>\n<h4 id=\"小结\"><a class=\"anchor\" href=\"#小结\">#</a> 小结</h4>\n<table>\n<thead>\n<tr>\n<th>数据类型</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>String</td>\n<td>一种二进制安全的数据类型，可以用来存储<font color='red'>任何类型的数据</font>比如字符串、整数、浮点数、图片（图片的 base64 编码或者解码或者图片的路径）、序列化后的对象。</td>\n</tr>\n<tr>\n<td>List</td>\n<td>Redis 的 List 的实现为一个<font color='red'>双向链表</font>，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销。</td>\n</tr>\n<tr>\n<td>Hash</td>\n<td>一个 String 类型的 <font color='red'>field-value（键值对）</font> 的映射表，特别适合用于<font color='red'>存储对象</font>，后续操作的时候，你可以直接修改这个对象中的某些字段的值。</td>\n</tr>\n<tr>\n<td>Set</td>\n<td><font color='red'>无序集合</font>，集合中的元素没有先后顺序但都唯一，有点类似于 Java 中的  <code>HashSet</code>  。</td>\n</tr>\n<tr>\n<td>Zset</td>\n<td>和 Set 相比，Sorted Set 增加了一个权重参数  <code>score</code> ，使得集合中的元素能够按  <code>score</code>  进行<font color='red'>有序排列</font>，还可以通过  <code>score</code>  的范围来获取元素的列表。有点像是 Java 中  <code>HashMap</code>  和  <code>TreeSet</code>  的结合体。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"3-种特殊数据类型\"><a class=\"anchor\" href=\"#3-种特殊数据类型\">#</a> 3 种特殊数据类型</h3>\n<h4 id=\"bitmap位图\"><a class=\"anchor\" href=\"#bitmap位图\">#</a> Bitmap（位图）</h4>\n<h5 id=\"介绍-6\"><a class=\"anchor\" href=\"#介绍-6\">#</a> 介绍</h5>\n<blockquote>\n<p>官网介绍：Bitmap 不是 Redis 中的实际数据类型，而<strong>是在 String 类型上定义的一组面向位的操作，将其视为位向量</strong>。由于字符串是二进制安全的块，且最大长度为 512 MB，它们适合用于设置最多 2<sup>32</sup> 个不同的位。</p>\n</blockquote>\n<p>Bitmap 存储的是 **<font color='red'>连续的二进制数字</font>**（0 和 1），通过 Bitmap，只需要一个 bit 位来表示某个元素对应的值或者状态，key 就是对应元素本身 。我们知道 8 个 bit 可以组成一个 byte，所以 Bitmap 本身会极大的节省储存空间。</p>\n<p>你可以将 Bitmap 看作是一个存储二进制数字（0 和 1）的数组，数组中<font color='red'>每个元素的下标叫做 offset（偏移量）</font>。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20220720194154133.png\" alt=\"img\" /></p>\n<h5 id=\"命令-6\"><a class=\"anchor\" href=\"#命令-6\">#</a> 命令</h5>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>介绍</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>SETBIT</code>  key offset value</td>\n<td>设置指定 offset 位置的值</td>\n</tr>\n<tr>\n<td><code>GETBIT</code>  key offset</td>\n<td>获取指定 offset 位置的值</td>\n</tr>\n<tr>\n<td><code>BITCOUNT</code>  key start end</td>\n<td>获取 start 和 end 之前<font color='red'>值为 1 </font>的元素个数</td>\n</tr>\n<tr>\n<td><code>BITOP</code>  operation destkey key1 key2 ...</td>\n<td>对一个或多个 Bitmap 进行运算，可用运算符有 <font color='red'>AND, OR, XOR 以及 NOT</font></td>\n</tr>\n</tbody>\n</table>\n<p>Bitmap 基本操作演示：</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># SETBIT 会返回之前位的值（默认是 0）这里会生成 7 个位</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token operator\">></span> SETBIT mykey <span class=\"token number\">7</span> <span class=\"token number\">1</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">(</span>integer<span class=\"token punctuation\">)</span> <span class=\"token number\">0</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token operator\">></span> SETBIT mykey <span class=\"token number\">7</span> <span class=\"token number\">0</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">(</span>integer<span class=\"token punctuation\">)</span> <span class=\"token number\">1</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token operator\">></span> GETBIT mykey <span class=\"token number\">7</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">(</span>integer<span class=\"token punctuation\">)</span> <span class=\"token number\">0</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token operator\">></span> SETBIT mykey <span class=\"token number\">6</span> <span class=\"token number\">1</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token punctuation\">(</span>integer<span class=\"token punctuation\">)</span> <span class=\"token number\">0</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token operator\">></span> SETBIT mykey <span class=\"token number\">8</span> <span class=\"token number\">1</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token punctuation\">(</span>integer<span class=\"token punctuation\">)</span> <span class=\"token number\">0</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token comment\"># 通过 bitcount 统计被被设置为 1 的位的数量。</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token operator\">></span> BITCOUNT mykey</pre></td></tr><tr><td data-num=\"14\"></td><td><pre><span class=\"token punctuation\">(</span>integer<span class=\"token punctuation\">)</span> <span class=\"token number\">2</span></pre></td></tr></table></figure><h5 id=\"bitmap-应用\"><a class=\"anchor\" href=\"#bitmap-应用\">#</a> Bitmap 应用</h5>\n<p><strong>需要保存<font color='red'>状态信息（0/1 即可表示）</font>的场景</strong></p>\n<ul>\n<li>举例：用户签到情况、活跃用户情况、用户行为统计（比如是否点赞过某个视频）。</li>\n<li>相关命令： <code>SETBIT</code> 、 <code>GETBIT</code> 、 <code>BITCOUNT</code> 、 <code>BITOP</code> 。</li>\n</ul>\n<h4 id=\"hyperloglog基数统计\"><a class=\"anchor\" href=\"#hyperloglog基数统计\">#</a> HyperLogLog（基数统计）</h4>\n<h5 id=\"介绍-7\"><a class=\"anchor\" href=\"#介绍-7\">#</a> 介绍</h5>\n<p>HyperLogLog 是一种有名的<font color='red'>基数计数概率算法</font> ，基于 LogLog Counting (LLC) 优化改进得来，并不是 Redis 特有的，Redis 只是实现了这个算法并提供了一些开箱即用的 API。</p>\n<p>Redis 提供的 HyperLogLog <font color='red'>占用空间非常非常小，只需要 12k 的空间就能存储接近 2<sup>64</sup> 个不同元素</font>。这是真的厉害，这就是数学的魅力么！并且，Redis 对 HyperLogLog 的存储结构做了优化，采用两种方式计数：</p>\n<ul>\n<li><strong>稀疏矩阵</strong>：计数较少的时候，占用空间很小。</li>\n<li><strong>稠密矩阵</strong>：计数达到某个阈值的时候，占用 12k 的空间。</li>\n</ul>\n<p>Redis 官方文档中有对应的详细说明：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231206160533080.png\" alt=\"image-20231206160533080\" /></p>\n<p>基数计数概率算法 **<font color='red'>为了节省内存并不会直接存储元数据，而是通过一定的概率统计方法预估基数值（集合中包含元素的个数）</font><strong>。因此，</strong><font color='red'>HyperLogLog 的计数结果并不是一个精确值，存在一定的误差</font>**（标准误差为  <code>0.81%</code>  ）。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231206160401312.png\" alt=\"image-20231206160401312\" /></p>\n<p>HyperLogLog 的使用非常简单，但原理非常复杂。HyperLogLog 的原理以及在 Redis 中的实现可以看这篇文章：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC82ODQ0OTAzNzg1NzQ0MDU2MzMz\">HyperLogLog 算法的原理讲解以及 Redis 是如何应用它的</span> 。</p>\n<p>再推荐一个可以帮助理解 HyperLogLog 原理的工具：<span class=\"exturl\" data-url=\"aHR0cDovL2NvbnRlbnQucmVzZWFyY2gubmV1c3Rhci5iaXovYmxvZy9obGwuaHRtbA==\">Sketch of the Day: HyperLogLog — Cornerstone of a Big Data Infrastructure</span> 。</p>\n<p>除了 HyperLogLog 之外，Redis 还提供了其他的概率数据结构，对应的官方文档地址：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9yZWRpcy5pby9kb2NzL2RhdGEtdHlwZXMvcHJvYmFiaWxpc3RpYy8=\">https://redis.io/docs/data-types/probabilistic/</span> 。</p>\n<h5 id=\"命令-7\"><a class=\"anchor\" href=\"#命令-7\">#</a> 命令</h5>\n<p>HyperLogLog 相关的命令非常少，最常用的也就 3 个。</p>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>介绍</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>PFADD</code>  key element1 element2 ...</td>\n<td>添加一个或多个元素到 HyperLogLog 中</td>\n</tr>\n<tr>\n<td><code>PFCOUNT</code>  key1 key2</td>\n<td>获取一个或者多个 HyperLogLog 的唯一计数。</td>\n</tr>\n<tr>\n<td><code>PFMERGE</code>  destkey sourcekey1 sourcekey2 ...</td>\n<td>将多个 HyperLogLog 合并到 destkey 中，destkey 会结合多个源，算出对应的唯一计数。</td>\n</tr>\n</tbody>\n</table>\n<p><strong>HyperLogLog 基本操作演示</strong>：</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token operator\">></span> PFADD hll foo bar zap</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">(</span>integer<span class=\"token punctuation\">)</span> <span class=\"token number\">1</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token operator\">></span> PFADD hll zap zap zap</pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token punctuation\">(</span>integer<span class=\"token punctuation\">)</span> <span class=\"token number\">0</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token operator\">></span> PFADD hll foo bar</pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token punctuation\">(</span>integer<span class=\"token punctuation\">)</span> <span class=\"token number\">0</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token operator\">></span> PFCOUNT hll</pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token punctuation\">(</span>integer<span class=\"token punctuation\">)</span> <span class=\"token number\">3</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token operator\">></span> PFADD some-other-hll <span class=\"token number\">1</span> <span class=\"token number\">2</span> <span class=\"token number\">3</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token punctuation\">(</span>integer<span class=\"token punctuation\">)</span> <span class=\"token number\">1</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token operator\">></span> PFCOUNT hll some-other-hll</pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token punctuation\">(</span>integer<span class=\"token punctuation\">)</span> <span class=\"token number\">6</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token operator\">></span> PFMERGE desthll hll some-other-hll</pre></td></tr><tr><td data-num=\"14\"></td><td><pre><span class=\"token string\">\"OK\"</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre><span class=\"token operator\">></span> PFCOUNT desthll</pre></td></tr><tr><td data-num=\"16\"></td><td><pre><span class=\"token punctuation\">(</span>integer<span class=\"token punctuation\">)</span> <span class=\"token number\">6</span></pre></td></tr></table></figure><h5 id=\"应用-3\"><a class=\"anchor\" href=\"#应用-3\">#</a> 应用</h5>\n<p><strong><font color='red'>数据量巨大（百万、千万级别以上）的计数场景</font></strong></p>\n<ul>\n<li>举例：热门网站每日 / 每周 / 每月访问 ip 数统计、热门帖子 uv 统计</li>\n<li>相关命令： <code>PFADD</code> 、 <code>PFCOUNT</code></li>\n</ul>\n<h4 id=\"geospatial地理位置\"><a class=\"anchor\" href=\"#geospatial地理位置\">#</a> Geospatial（地理位置）</h4>\n<h5 id=\"介绍-8\"><a class=\"anchor\" href=\"#介绍-8\">#</a> 介绍</h5>\n<p>Geospatial index（地理空间索引，简称 GEO） 主要 **<font color='red'>用于存储地理位置信息，基于 Sorted Set 实现</font>**。</p>\n<p>通过 GEO 我们可以轻松实现<font color='red'>两个位置距离的计算、获取指定位置附近的元素</font>等功能。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20220720194359494.png\" alt=\"img\" /></p>\n<h5 id=\"命令-8\"><a class=\"anchor\" href=\"#命令-8\">#</a> 命令</h5>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>介绍</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>GEOADD</code>  key longitude1 latitude1 member1 ...</td>\n<td>添加一个或多个元素对应的经纬度信息到 GEO 中</td>\n</tr>\n<tr>\n<td><code>GEOPOS</code>  key member1 member2 ...</td>\n<td>返回给定元素的经纬度信息</td>\n</tr>\n<tr>\n<td><code>GEODIST</code>  key member1 member2 M/KM/FT/MI</td>\n<td>返回两个给定元素之间的距离</td>\n</tr>\n<tr>\n<td><code>GEORADIUS</code>  key longitude latitude radius distance</td>\n<td>获取指定位置<font color='red'>附近 distance 范围内</font>的其他元素，支持 ASC (由近到远)、DESC（由远到近）、Count (数量) 等参数</td>\n</tr>\n<tr>\n<td><code>GEORADIUSBYMEMBER</code>  key member radius distance</td>\n<td>类似于 GEORADIUS 命令，只是<font color='red'>参照的中心点是 GEO 中的元素</font></td>\n</tr>\n</tbody>\n</table>\n<p><strong>基本操作</strong>：</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token operator\">></span> GEOADD personLocation <span class=\"token number\">116.33</span> <span class=\"token number\">39.89</span> user1 <span class=\"token number\">116.34</span> <span class=\"token number\">39.90</span> user2 <span class=\"token number\">116.35</span> <span class=\"token number\">39.88</span> user3</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token number\">3</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token operator\">></span> GEOPOS personLocation user1</pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token number\">116.3299986720085144</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token number\">39.89000061669732844</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token operator\">></span> GEODIST personLocation user1 user2 km</pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token number\">1.4018</span></pre></td></tr></table></figure><p>通过 Redis 可视化工具查看  <code>personLocation</code>  ，果不其然，底层就是 Sorted Set。</p>\n<p>GEO 中存储的地理位置信息的经纬度数据通过 GeoHash 算法转换成了一个整数，这个整数作为 Sorted Set 的 score (权重参数) 使用。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20220721201545147.png\" alt=\"img\" /></p>\n<p><strong>获取指定位置范围内的其他元素</strong>：</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token operator\">></span> GEORADIUS personLocation <span class=\"token number\">116.33</span> <span class=\"token number\">39.87</span> <span class=\"token number\">3</span> km</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>user3</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>user1</pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token operator\">></span> GEORADIUS personLocation <span class=\"token number\">116.33</span> <span class=\"token number\">39.87</span> <span class=\"token number\">2</span> km</pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token operator\">></span> GEORADIUS personLocation <span class=\"token number\">116.33</span> <span class=\"token number\">39.87</span> <span class=\"token number\">5</span> km</pre></td></tr><tr><td data-num=\"6\"></td><td><pre>user3</pre></td></tr><tr><td data-num=\"7\"></td><td><pre>user1</pre></td></tr><tr><td data-num=\"8\"></td><td><pre>user2</pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token operator\">></span> GEORADIUSBYMEMBER personLocation user1 <span class=\"token number\">5</span> km</pre></td></tr><tr><td data-num=\"10\"></td><td><pre>user3</pre></td></tr><tr><td data-num=\"11\"></td><td><pre>user1</pre></td></tr><tr><td data-num=\"12\"></td><td><pre>user2</pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token operator\">></span> GEORADIUSBYMEMBER personLocation user1 <span class=\"token number\">2</span> km</pre></td></tr><tr><td data-num=\"14\"></td><td><pre>user1</pre></td></tr><tr><td data-num=\"15\"></td><td><pre>user2</pre></td></tr></table></figure><p><code>GEORADIUS</code>  命令的底层原理解析可以看看阿里的这篇文章：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC82ODQ0OTAzOTY2MDYxMzYzMjA3\">Redis 到底是怎么实现 “附近的人” 这个功能的呢？</span> 。</p>\n<p><strong>移除元素</strong>：</p>\n<p>GEO 底层是 Sorted Set ，你可以对 GEO 使用 Sorted Set 相关的命令。</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token operator\">></span> ZREM personLocation user1</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token number\">1</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token operator\">></span> ZRANGE personLocation <span class=\"token number\">0</span> <span class=\"token parameter variable\">-1</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>user3</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>user2</pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token operator\">></span> ZSCORE personLocation user2</pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token number\">4069879562983946</span></pre></td></tr></table></figure><h5 id=\"应用-4\"><a class=\"anchor\" href=\"#应用-4\">#</a> 应用</h5>\n<p><strong>需要管理使用<font color='red'>地理空间数据</font>的场景</strong></p>\n<ul>\n<li>举例：附近的人</li>\n<li>相关命令:  <code>GEOADD</code> 、 <code>GEORADIUS</code> 、 <code>GEORADIUSBYMEMBER</code></li>\n</ul>\n<h4 id=\"小结-2\"><a class=\"anchor\" href=\"#小结-2\">#</a> 小结</h4>\n<table>\n<thead>\n<tr>\n<th>数据类型</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Bitmap</td>\n<td>可以将 Bitmap 看作一个存储二进制数字（0 和 1）的数组，数组中每个元素的下标叫做 offset（偏移量）。通过 Bitmap，只需要一个 bit 位来表示某个元素对应的值或者状态，key 就是对应元素本身 。我们知道 8 个 bit 可以组成一个 byte，所以 Bitmap 本身会极大的节省储存空间。</td>\n</tr>\n<tr>\n<td>HyperLogLog</td>\n<td>Redis 提供的<font color='red'> HyperLogLog 占用空间非常非常小</font>，只需要 12k 的空间就能存储接近 <code>2^64</code>  个不同元素。不过，HyperLogLog 的计数结果并不是一个精确值，<font color='red'>存在一定的误差</font>（标准误差为  <code>0.81%</code>  ）。</td>\n</tr>\n<tr>\n<td>Geospatial index</td>\n<td>Geospatial index（地理空间索引，简称 GEO） 主要<font color='red'>用于存储地理位置信息，基于 Sorted Set 实现</font>。</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"string-应用场景\"><a class=\"anchor\" href=\"#string-应用场景\">#</a> String 应用场景</h2>\n<p>[String 应用](#String 应用)</p>\n<h2 id=\"对象数据的存储建议使用-string\"><a class=\"anchor\" href=\"#对象数据的存储建议使用-string\">#</a> 对象数据的存储建议使用 String</h2>\n<ul>\n<li><strong><font color='red'>String 存储的是序列化后的对象数据，存放的是整个对象</font></strong>。Hash 是对对象的每个字段单独存储，可以获取部分字段的信息，也可以修改或者添加部分字段，节省网络流量。<font color='red'>如果对象中某些字段需要经常变动，或者需要经常单独查询对象中的个别字段信息，Hash 就非常适合</font>。</li>\n<li><strong><font color='red'>String 存储对象相对更加节省内存</font></strong>，缓存相同数量的对象数据，String 消耗的内存约是 Hash 的一半。并且，<font color='red'>String 存储具有多层嵌套的对象时，也方便很多</font>。如果系统对性能和资源消耗非常敏感的话，String 就非常适合。</li>\n</ul>\n<p>在绝大部分情况，我们建议使用 String 来存储对象数据即可！</p>\n<h2 id=\"string-的底层实现sds\"><a class=\"anchor\" href=\"#string-的底层实现sds\">#</a> <mark>🌟String 的底层实现：SDS</mark></h2>\n<h3 id=\"sds-介绍\"><a class=\"anchor\" href=\"#sds-介绍\">#</a> SDS 介绍</h3>\n<p>Redis 是基于 C 语言编写的，但 Redis 的 String 类型的底层实现并不是 C 语言中的字符串（即以空字符  <code>\\0</code>  结尾的字符数组），而是自己编写了 **<font color='cornflowerblue'><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2FudGlyZXovc2Rz\">SDS</span>（Simple Dynamic String，简单动态字符串）</font>** 来作为底层实现。</p>\n<p>SDS 最早是 Redis 作者为日常 C 语言开发而设计的 C 字符串，后来被应用到了 Redis 上，并经过了大量的修改完善以适合<font color='red'>高性能操作</font>。</p>\n<h3 id=\"sds-结构\"><a class=\"anchor\" href=\"#sds-结构\">#</a> SDS 结构</h3>\n<p>Redis7.0 的 SDS 的部分<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3JlZGlzL3JlZGlzL2Jsb2IvNy4wL3NyYy9zZHMuaA==\">源码</span>如下：</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">/* Note: sdshdr5 is never used, we just access the flags byte directly.</pre></td></tr><tr><td data-num=\"2\"></td><td><pre> * However is here to document the layout of type 5 SDS strings. */</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">struct</span> <span class=\"token keyword\">__attribute__</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>__packed__<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token class-name\">sdshdr5</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">char</span> flags<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* 3 lsb of type, and 5 msb of string length */</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token keyword\">char</span> buf<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token keyword\">struct</span> <span class=\"token keyword\">__attribute__</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>__packed__<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token class-name\">sdshdr8</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token class-name\">uint8_t</span> len<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* used */</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token class-name\">uint8_t</span> alloc<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* excluding the header and null terminator */</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">char</span> flags<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* 3 lsb of type, 5 unused bits */</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token keyword\">char</span> buf<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token keyword\">struct</span> <span class=\"token keyword\">__attribute__</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>__packed__<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token class-name\">sdshdr16</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    <span class=\"token class-name\">uint16_t</span> len<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* used */</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    <span class=\"token class-name\">uint16_t</span> alloc<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* excluding the header and null terminator */</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>    <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">char</span> flags<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* 3 lsb of type, 5 unused bits */</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>    <span class=\"token keyword\">char</span> buf<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre><span class=\"token keyword\">struct</span> <span class=\"token keyword\">__attribute__</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>__packed__<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token class-name\">sdshdr32</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>    <span class=\"token class-name\">uint32_t</span> len<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* used */</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>    <span class=\"token class-name\">uint32_t</span> alloc<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* excluding the header and null terminator */</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>    <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">char</span> flags<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* 3 lsb of type, 5 unused bits */</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>    <span class=\"token keyword\">char</span> buf<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre><span class=\"token keyword\">struct</span> <span class=\"token keyword\">__attribute__</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>__packed__<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token class-name\">sdshdr64</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>    <span class=\"token class-name\">uint64_t</span> len<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* used */</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>    <span class=\"token class-name\">uint64_t</span> alloc<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* excluding the header and null terminator */</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>    <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">char</span> flags<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* 3 lsb of type, 5 unused bits */</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>    <span class=\"token keyword\">char</span> buf<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>通过源码可以看出，SDS 共有五种实现方式 SDS_TYPE_5（并未用到）、SDS_TYPE_8、SDS_TYPE_16、SDS_TYPE_32、SDS_TYPE_64，其中只有后四种实际用到。<font color='red'>Redis 会根据初始化的长度决定使用哪种类型的 SDS，从而减少内存的使用</font>。</p>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>字节</th>\n<th>位</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>sdshdr5</td>\n<td>&lt; 1</td>\n<td>&lt;8</td>\n</tr>\n<tr>\n<td>sdshdr8</td>\n<td>1</td>\n<td>8</td>\n</tr>\n<tr>\n<td>sdshdr16</td>\n<td>2</td>\n<td>16</td>\n</tr>\n<tr>\n<td>sdshdr32</td>\n<td>4</td>\n<td>32</td>\n</tr>\n<tr>\n<td>sdshdr64</td>\n<td>8</td>\n<td>64</td>\n</tr>\n</tbody>\n</table>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/redis_sdshdr5.png\" alt=\"redis字符窜数据结构简述 - 知乎\" /></p>\n<center>SDSHDR5</center>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231206204849898.png\" alt=\"image-20231206204849898\" /></p>\n<center>SDSHDR 结构示意图</center>\n<p>对于后四种实现都包含了下面这 4 个属性：</p>\n<ul>\n<li><code>len</code> ：字符串的长度，即<font color='red'>已使用的</font>字节数</li>\n<li><code>alloc</code> ：<font color='red'>总共可用的</font>字符空间大小（字节数），<font color='red'>不包括 <code>\\0</code> </font>，alloc-len 就是 SDS 剩余的空间大小</li>\n<li><code>buf[]</code> ：<font color='red'>实际存储字符串的数组</font></li>\n<li><code>flags</code> ：大小为 1 个字节，其中<font color='red'>低 3 位保存类型标志</font>，高 5 位闲置</li>\n</ul>\n<h3 id=\"sds-相比-c-字符串的优势\"><a class=\"anchor\" href=\"#sds-相比-c-字符串的优势\">#</a> SDS 相比 C 字符串的优势</h3>\n<p>SDS 相比于 C 语言中的字符串有如下提升：</p>\n<ol>\n<li><strong><font color='red'>可以避免缓冲区溢出</font></strong>：C 语言中的字符串被修改（比如拼接）时，一旦没有分配足够长度的内存空间，就会造成缓冲区溢出。SDS 被修改时，会先根据 len 属性检查空间大小是否满足要求，如果不满足，则先扩展至所需大小再进行修改操作。</li>\n<li><strong><font color='red'>获取字符串长度的复杂度较低</font></strong>：C 语言中的字符串的长度通常是经过遍历计数来实现的，时间复杂度为 O (n)。SDS 的长度获取<font color='red'>直接读取 len 属性即可，时间复杂度为 O (1)</font>。</li>\n<li><strong><font color='red'>减少内存分配次数</font></strong>：为了避免修改（增加 / 减少）字符串时，每次都需要重新分配内存（C 语言的字符串是这样的），SDS 实现了<font color='cornflowerblue'>空间预分配</font>和<font color='cornflowerblue'>惰性空间释放</font>两种优化策略。当 SDS 需要增加字符串时，Redis 会为 SDS 分配好内存，并且根据特定的算法分配多余的内存，这样可以减少连续执行字符串增长操作所需的内存重分配次数。当 SDS 需要减少字符串时，这部分内存不会立即被回收，会被记录下来，等待后续使用（支持手动释放，有对应的 API）。</li>\n<li><strong><font color='red'>二进制安全</font></strong>：C 语言中的字符串以空字符  <code>\\0</code>  作为字符串结束的标识，这存在一些问题，像一些二进制文件（比如图片、视频、音频）就可能包括空字符，C 字符串无法正确保存。<font color='red'>SDS 使用 len 属性判断字符串是否结束，不存在这个问题</font>。</li>\n</ol>\n<h3 id=\"sds-旧版本结构\"><a class=\"anchor\" href=\"#sds-旧版本结构\">#</a> SDS 旧版本结构</h3>\n<p>🤐 多提一嘴，很多文章里 SDS 的定义是下面这样的：</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">struct</span> <span class=\"token class-name\">sdshdr</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> len<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 记录 buf 数组中已使用字节的数量 = sds 所保存字符串的长度</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> free<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 记录 buf 数组中未使用字节的数量</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token keyword\">char</span> buf<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 字节数组，用于保存字符串</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/v2-3423339183d978aed32dca64447d728d_b.jpg\" alt=\"img\" /></p>\n<center>SDS旧版本结构</center>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/redis_sds_1.png\" alt=\"img\" /></p>\n<p>这个也没错，<font color='red'>Redis 3.2 之前就是这样定义的</font>。后来，由于这种方式的定义存在问题， <code>len</code>  和  <code>free</code>  的定义用了 4 个字节，造成了浪费。Redis 3.2 之后，Redis 改进了 SDS 的定义，将其划分为了现在的 5 种类型。</p>\n<h2 id=\"购物车信息的存储建议使用-hash\"><a class=\"anchor\" href=\"#购物车信息的存储建议使用-hash\">#</a> 购物车信息的存储建议使用 Hash</h2>\n<blockquote>\n<p>你肯定会问：购物车信息也是对象数据，前文不是说了建议使用 String 存储对象数据吗？</p>\n</blockquote>\n<p><strong><font color='red'>因为购物车中的商品频繁修改和变动</font></strong>，购物车信息建议使用 Hash 存储：</p>\n<ul>\n<li>用户 id 为 key</li>\n<li>商品 id 为 field，商品数量为 value</li>\n</ul>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231206193856739.png\" alt=\"Hash维护简单的购物车信息\" /></p>\n<center>Hash维护简单的购物车信息</center>\n<p>那用户购物车信息的维护具体应该怎么操作呢？</p>\n<ul>\n<li>用户添加商品就是往 Hash 里面增加新的 field 与 value；</li>\n<li>查询购物车信息就是遍历对应的 Hash；</li>\n<li>更改商品数量直接修改对应的 value 值（直接 set 或者做运算皆可）；</li>\n<li>删除商品就是删除 Hash 中对应的 field；</li>\n<li>清空购物车直接删除对应的 key 即可。</li>\n</ul>\n<p>这里只是以业务比较简单的购物车场景举例，实际电商场景下，field 只保存一个商品 id 是没办法满足需求的。</p>\n<h2 id=\"使用-sorted-set-实现排行榜\"><a class=\"anchor\" href=\"#使用-sorted-set-实现排行榜\">#</a> 使用 Sorted Set 实现排行榜</h2>\n<p>[Zset 应用](#Zset 应用)</p>\n<h2 id=\"set-应用场景\"><a class=\"anchor\" href=\"#set-应用场景\">#</a> Set 应用场景</h2>\n<p>[Set 应用](#Set 应用)</p>\n<h2 id=\"使用-set-实现抽奖系统\"><a class=\"anchor\" href=\"#使用-set-实现抽奖系统\">#</a> 使用 Set 实现抽奖系统</h2>\n<p>如果想要使用  <code>Set</code>  实现一个简单的抽奖系统的话，直接使用下面这几个命令就可以了：</p>\n<ul>\n<li><code>SADD key member1 member2 ...</code> ：向指定集合添加一个或多个元素。</li>\n<li><code>SPOP key count</code> ：随机移除并获取指定集合中一个或多个元素，适合不允许重复中奖的场景。</li>\n<li><code>SRANDMEMBER key count</code> ：随机获取指定集合中指定数量的元素，适合允许重复中奖的场景。</li>\n</ul>\n<h2 id=\"集合的底层实现\"><a class=\"anchor\" href=\"#集合的底层实现\">#</a> <mark>🌟集合的底层实现</mark></h2>\n<p>Redis 中<font color='red'>对于 Set 类型的底层实现，直接采用了 hashTable</font>。</p>\n<p><font color='red'>对于 Hash 与 ZSet 集合，其底层的实现实际有两种</font>：</p>\n<ul>\n<li><code>zipList</code> （<font color='cornflowerblue'>压缩列表</font>）</li>\n<li><code>skipList</code> （<font color='cornflowerblue'>跳跃列表</font>）</li>\n</ul>\n<p>这两种实现对于用户来说是透明的，但用户写入不同的数据，系统会自动使用不同的实现。只要同时满足配置文件 redis.conf 中相关集合<font color='red'>元素数量阈值</font>、<font color='red'>元素大小阈值</font>两个条件，使用的就是压缩列表 zipList；只要有一个条件不满足，使用的就是跳跃列表 skipList。</p>\n<p>例如，对于 ZSet 集合中这两个条件如下：</p>\n<ul>\n<li>集合元素个数小于 redis.conf 中 zset-max-ziplist-entries 属性的值，其默认值为 128</li>\n<li>每个集合元素大小都小于 redis.conf 中 zset-max-ziplist-value 属性的值，其默认值为 64 字节</li>\n</ul>\n<h3 id=\"ziplist压缩列表\"><a class=\"anchor\" href=\"#ziplist压缩列表\">#</a> zipList（压缩列表）</h3>\n<p>zipList，通常称为压缩列表，是一个<font color='red'>经过特殊编码</font>的用于<font color='red'>存储字符串或整数</font>的 **<font color='red'>双向链表</font>**。</p>\n<p>其底层数据结构由<font color='red'>在内存上是连续存放的三部分</font>构成：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231206212946057.png\" alt=\"image-20231206212946057\" /></p>\n<center>zipList 结构</center>\n<ul>\n<li><strong><font color='green'>head</font></strong>：10 字节\n<ul>\n<li><font color='gree'>zlbytes（列表长度）</font>：4 字节，存放 zipList 列表整体数据结构所占的字节数，包括 zlbytes 本身的长度。</li>\n<li><font color='gree'>zltail（尾 entry 的偏移量）</font>：4 字节，用于存放 zipList 中最后一个 entry 在整个数据结构中的偏移量（字节）。该数据的存在可以快速定位列表的尾 entry 位置，以方便操作。</li>\n<li><font color='gree'>zllen（entry 个数）</font>：2 字节，用于存放 zipList 包含的 entry 个数。由于其只有 16 位，所以 zipList 最多可以含有的 entry 个数为 2<sup>16</sup>-1 = 65535 个。</li>\n</ul>\n</li>\n<li><strong><font color='green'>entries</font></strong>：真正的列表，由很多的元素 entry 构成。由于不同的元素类型、数值的不同，从而导致每个 entry 的长度不同。\n<ul>\n<li><strong><font color='gree'>prevlength（前一个 entry 的长度）</font></strong>： <font color='red'>1/3 字节</font>，用于记录前一个 entry 的长度，<font color='red'>以实现逆序遍历</font>。默认长度为 1 字节，只要上一个 entry 的长度小于 254 字节， prevlength 就占 1 字节，否则其会自动扩展为 3 字节长度。</li>\n<li><font color='gree'>encoding（data 具体类型）</font>：<font color='red'>1/2/5 字节</font>，用于标志后面的 data 的具体类型。如果 data 为整数类型， encoding 固定长度为 1 字节。如果 data 为字符串类型，则 encoding 长度可能会是 1 字节、 2 字<br />\n节或 5 字节。 <font color='red'>data 字符串不同的长度，对应着不同的 encoding 长度</font>。</li>\n<li><font color='gree'>data（真正的数据）</font>：数据类型只能是<font color='red'>整数类型或字符串类型</font>，不同的数据占用的字节长度不同。</li>\n</ul>\n</li>\n<li><strong><font color='green'>end</font></strong>：只包含一部分\n<ul>\n<li><font color='gree'>zlend（zipList 结束标记）</font>：1 字节，值固定为 255，即<font color='red'>二进制位为全 1</font>，表示一个 zipList 列表的结束。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"listpack紧凑列表\"><a class=\"anchor\" href=\"#listpack紧凑列表\">#</a> listPack（紧凑列表）</h3>\n<blockquote>\n<p>重写并替代 zipList（压缩列表）</p>\n</blockquote>\n<p>ziplist 实现复杂，为了逆序遍历，每个 entry 中包含前一个 entry 的长度，这样会导致<font color='red'>在 ziplist 中间修改或者插入 entry 时需要进行级联更新</font>，在高并发的写操作场景下会极度降低 Redis 的性能。为了实现更紧凑、更快的解析，更简单的实现，<strong><font color='red'>重写实现了 ziplist，并命名为 listPack</font></strong>。</p>\n<p><font color='red'>在 Redis 7.0 中，已经将 zipList 全部替换为了 listPack</font>，但为了兼容性，在配置中也保留了 zipList 的相关属性。</p>\n<p>与 zipList 一样，listPack 也是一个<font color='red'>经过特殊编码</font>的用于<font color='red'>存储字符串或整数</font>的 **<font color='red'>双向链表</font>**。</p>\n<p>其底层数据结构也由在内存上也是连续存放的三部分构成：</p>\n<blockquote>\n<p>listPack 与 zipList 的 **<font color='red'>重大区别：head 与 entry 的结构</font>**。表示列表结束的 end 与 zipList 的 zlend 是相同的，占一个字节，且 8 位全为 1</p>\n</blockquote>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231207093508520.png\" alt=\"image-20231207093508520\" /></p>\n<center>listPack 结构</center>\n<ul>\n<li>\n<p><strong><font color='green'>head</font></strong>：6 字节</p>\n<blockquote>\n<p>与 zipList 的 head 相比最大的变化：<strong><font color='red'>不再记录尾 entry 的偏移量</font></strong></p>\n</blockquote>\n<ul>\n<li><font color='gree'>totalBytes（列表长度）</font>：4 字节，用于存放 listPack 列表<font color='red'>整体数据结构</font>所占的字节数，包括 totalBytes 本身的长度。</li>\n<li><font color='gree'>elemNum（entry 个数）</font>：2 字节，用于存放列表包含的<font color='red'> entry 个数</font>。其意义与 zipList 中 zllen 的相同。</li>\n</ul>\n</li>\n<li>\n<p><strong><font color='green'>entries</font></strong>：真正的列表，由很多的元素 entry 构成。由于不同的元素类型、数值的不同，从而导致每个 entry 的长度不同。</p>\n<blockquote>\n<p>与 zipList 的 entries 相比最大的变化：<strong><font color='red'>不再记录前一个 entry 长度的 prevlength，而是记录当前 entry 长度的 element-total-len</font></strong>。而这个改变<font color='red'>仍然可以实现逆序遍历，但却避免了由于在列表中间修改或插入 entry 时引发的级联更新</font>。</p>\n</blockquote>\n<ul>\n<li><font color='gree'>encoding（data 具体类型）</font>：1/2/3/4/5/9 字节，用于标志后面的 data 的具体类型。如果 data 为整数类型，encoding 长度可能会是 1、 2、 3、 4、 5 或 9 字节。不同的字节长度，其标识位不同。如果 data 为字符串类型，则 encoding 长度可能会是 1、 2 或 5 字节。 data 字符串不同的长度，对应着不同的 encoding 长度。</li>\n<li><font color='gree'>data（真正的数据）</font>：只能是<font color='red'>整数类型或字符串类型</font>。不同的数据占用的字节长度不同。</li>\n<li><strong><font color='gree'>element-total-len（当前 entry 的长度）</font></strong>：1/2/3/4/5 字节，用于记录当前 entry 的长度，以实现逆序遍历。由于其特殊的记录方式，使其本身占有的字节数据可能会是 1、 2、 3、 4 或 5 字节。</li>\n</ul>\n</li>\n<li>\n<p><strong><font color='green'>end</font></strong>：只包含一部分</p>\n<ul>\n<li><font color='gree'>zlend（zipList 结束标记）</font>：1 字节，值固定为 255，即<font color='red'>二进制位为全 1</font>，表示一个 zipList 列表的结束。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"skiplist跳跃列表跳表\"><a class=\"anchor\" href=\"#skiplist跳跃列表跳表\">#</a> <mark>🌟skipList（跳跃列表 / 跳表）</mark></h3>\n<p>skipList，跳跃列表，简称跳表，是一种<font color='red'>随机化的</font>数据结构，基于<font color='red'>并联的链表</font>，实现简单，查找效率较高。简单来说跳表也是链表的一种，只不过它 **<font color='red'>在链表的基础上增加了跳跃功能</font>**。也正是这个跳跃功能，使得在<font color='red'>查找元素时，能够提供较高的效率</font>。</p>\n<h4 id=\"原理-3\"><a class=\"anchor\" href=\"#原理-3\">#</a> 原理</h4>\n<p>假设有一个<font color='red'>带头、尾结点的有序链表</font>。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231207150413317.png\" alt=\"image-20231207150413317\" /></p>\n<p>在该链表中，如果要查找某个数据，需要从头开始逐个进行比较，直到找到包含数据的那个节点，或者找到第一个比给定数据大的节点，或者找到最后尾结点，后两种都属于没有找到的情况。同样，当我们要插入新数据的时候，也要经历同样的查找过程，从而确定插入位置。</p>\n<p>为了提升查找效率，<strong><font color='red'>在偶数结点上增加一个指针，让其指向下一个偶数结点，形成一个新的链表（<font color='cornflowerblue'>高层链表</font>）</font></strong>。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231207150636138.png\" alt=\"image-20231207150636138\" /></p>\n<p>当然，高层链表包含的节点个数只是原来链表的一半。此时再想查找某个数据时，<font color='red'>先沿着高层链表进行查找，当遇到第一个比待查数据大的节点时，立即从前一个节点，再回到原链表中进行查找</font>。</p>\n<p>例如，若想插入一个数据 20，则先在（8， 19，31， 42）的链表中查找，找到第一个比 20 大的节点 31，然后再在高层链表中找到 31 节点的前一个节点 19，然后再在原链表中获取到其下一个节点值为 23。比 20 大，则将 20 插入到 19 节点与 23 节点之间。若插入的是 25，比节点 23 大，则插入到 23 节点与 31 节点之间。</p>\n<p>该方式明显<font color='red'>可以减少比较次数，提高查找效率</font>。如果链表元素较多，为了进一步提升查找效率，可以将原链表构建为三层链表，或再高层级链表。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231207151233404.png\" alt=\"image-20231207151233404\" /></p>\n<p>层级越高，查找效率就会越高。</p>\n<h4 id=\"存在问题\"><a class=\"anchor\" href=\"#存在问题\">#</a> 存在问题</h4>\n<p>这种对链表分层级的方式从原理上看确实提升了查找效率，但在实际操作时就出现了问题：<strong><font color='red'>由于固定序号的元素拥有固定层级，所以列表元素出现增加或删除的情况下，会导致列表整体元素层级大调整，但这样势必会大大降低系统性能</font></strong>。</p>\n<p>例如，对于划分两级的链表，可以规定奇数结点为高层级链表，偶数结点为低层级链表。对于划分三级的链表，可以按照节点序号与 3 取模结果进行划分。但如果插入了新的节点，或删除的原来的某些节点，那么定会按照原来的层级划分规则进行重新层级划分，那么势必会大大降低系统性能。</p>\n<h4 id=\"算法优化\"><a class=\"anchor\" href=\"#算法优化\">#</a> 算法优化</h4>\n<p>为了避免前面的问题，skipList 采用了 **<font color='#B32015'>随机分配层级</font>** 方式。即<font color='red'>在确定了总层级后，每添加一个新的元素时会自动为其随机分配一个层级</font>。这种随机性就<font color='red'>解决了节点序号与层级间的固定关系问题</font>。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231207151544039.png\" alt=\"image-20231207151544039\" /></p>\n<center>skipList 在生成过程中为每个元素随机分配层级的过程</center>\n<p>从这个 skiplist 的创建和插入过程可以看出，每一个节点的层级数都是随机分配的。而且<font color='red'>新插入一个节点不会影响到其它节点的层级数，只需要修改插入节点前后的指针</font>，这就降低了插入操作的复杂度。</p>\n<p>skipList 指的就是除了最下面第 1 层链表之外，它会产生若干层稀疏的链表，这些链表里面的指针跳过了一些节点，并且越高层级的链表跳过的节点越多。<strong><font color='red'>在查找数据的时先在高层级链表中进行查找，然后逐层降低，最终可能会降到第 1 层链表来精确地确定数据位置</font></strong>。在这个过程中由于跳过了一些节点，从而加快了查找速度。</p>\n<h3 id=\"quicklist快速列表快表\"><a class=\"anchor\" href=\"#quicklist快速列表快表\">#</a> quickList（快速列表 / 快表）</h3>\n<blockquote>\n<p>从 Redis 3.2 开始成为是 List 的底层实现，替代了 zipList 和 LinkedList</p>\n</blockquote>\n<h4 id=\"原理-4\"><a class=\"anchor\" href=\"#原理-4\">#</a> 原理</h4>\n<p>quickList，快速列表， quickList 本身是一个<font color='red'>双向无循环链表</font>，它的 **<font color='red'>每个节点都是一个 zipList</font>**。</p>\n<p>zipList 与 linkedList 都存在有明显不足，而 quickList 则对它们进行了改进：吸取了 zipList 和 linkedList 的优点，避开了它们的不足。</p>\n<p>quickList 本质上 **<font color='red'>是 zipList 和 linkedList 的混合体</font>**，<font color='red'>将 linkedList 按段切分，每一段使用 zipList 来紧凑存储若干真正的数据元素，多个 zipList 之间使用双向指针串接起来</font>。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231207153821870.png\" alt=\"image-20231207153821870\" /></p>\n<p>当然，对于<font color='red'>每个 zipList 中最多可存放多大容量的数据元素</font>，在配置文件中通过  <code>list-max-ziplist-size</code>  属性可以指定。</p>\n<h4 id=\"检索操作\"><a class=\"anchor\" href=\"#检索操作\">#</a> 检索操作</h4>\n<p>为了更深入的理解 quickList 的工作原理，通过对检索、插入、删除等操作的实现分析来加深理解。</p>\n<p>对于 List 元素的检索，都是以其索引 index 为依据的。quickList 由一个个的 zipList 构成，每个 zipList 的 zllen 中记录的就是当前 zipList 中包含的 entry 的个数，即包含的真正数据元素的个数。<font color='red'>根据要检索元素的 index，从 quickList 的头节点开始，<strong>逐个对 zipList 的 zllen 做 sum 求和</strong>，直到找到第一个求和后 sum 大于 index 的 zipList，那么要检索的这个元素就在这个 zipList 中</font>。</p>\n<h4 id=\"插入操作\"><a class=\"anchor\" href=\"#插入操作\">#</a> 插入操作</h4>\n<p>由于 zipList 是有大小限制的，所以在 quickList 中插入一个元素在逻辑上相对就比较复杂一些。假设要插入的元素的大小为  <code>insertBytes</code> ，而查找到的插入位置所在的 zipList 当前的大小为  <code>zlBytes</code> ，那么具体可分为下面几种情况：</p>\n<ul>\n<li>情况一：<font color='red'>当 insertBytes + zlBytes &lt;= list-max-ziplist-size 时</font>， 直接插入到 zipList 中相应位置即可</li>\n<li>情况二：<font color='red'>当 insertBytes + zlBytes &gt; list-max-ziplist-size，且插入的位置位于该 zipList 的首部位置</font>，此时需要查看该 zipList 的前一个 zipList 的大小  <code>prev_zlBytes</code> 。\n<ul>\n<li>若 insertBytes + prev_zlBytes&lt;= list-max-ziplist-size 时，直接将元素插入到前一个 zipList 的尾部位置即可</li>\n<li>若 insertBytes + prev_zlBytes&gt; list-max-ziplist-size 时，直接将元素自己构建为一个新的 zipList，并连入 quickList 中</li>\n</ul>\n</li>\n<li>情况三：<font color='red'>当 insertBytes + zlBytes &gt; list-max-ziplist-size，且插入的位置位于该 zipList 的尾部位置</font>，此时需要查看该 zipList 的后一个 zipList 的大小  <code>next_zlBytes</code> 。\n<ul>\n<li>若 insertBytes + next_zlBytes&lt;= list-max-ziplist-size 时，直接将元素插入到后一个 zipList 的头部位置即可</li>\n<li>若 insertBytes + next_zlBytes&gt; list-max-ziplist-size 时，直接将元素自己构建为一个新的 zipList，并连入 quickList 中</li>\n</ul>\n</li>\n<li>情况四：<font color='red'>当 insertBytes + zlBytes &gt; list-max-ziplist-size，且插入的位置位于该 zipList 的中间位置</font>，则将当前 zipList 分割为两个 zipList 连接入 quickList 中，然后将元素插入到分割后的前面 zipList 的尾部位置。</li>\n</ul>\n<h4 id=\"删除操作\"><a class=\"anchor\" href=\"#删除操作\">#</a> 删除操作</h4>\n<p>对于删除操作，只需要注意一点，<font color='red'>在相应的 zipList 中删除元素后，如果该 zipList 中没有其它元素了，则将该 zipList 删除，将其前后两个 zipList 相连接</font>。</p>\n<h2 id=\"使用-bitmap-统计活跃用户\"><a class=\"anchor\" href=\"#使用-bitmap-统计活跃用户\">#</a> 使用 Bitmap 统计活跃用户</h2>\n<blockquote>\n<p>[Bitmap 应用](#Bitmap 应用)</p>\n</blockquote>\n<p>如果想要使用 Bitmap 统计活跃用户的话，<font color='red'>可以使用日期（精确到天）作为 key，然后用户 ID 为 offset，如果当日活跃过就设置为 1</font>。</p>\n<p>初始化数据：</p>\n<figure class=\"highlight sh\"><figcaption data-lang=\"sh\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token operator\">></span> SETBIT <span class=\"token number\">20210308</span> <span class=\"token number\">1</span> <span class=\"token number\">1</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">(</span>integer<span class=\"token punctuation\">)</span> <span class=\"token number\">0</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token operator\">></span> SETBIT <span class=\"token number\">20210308</span> <span class=\"token number\">2</span> <span class=\"token number\">1</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token punctuation\">(</span>integer<span class=\"token punctuation\">)</span> <span class=\"token number\">0</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token operator\">></span> SETBIT <span class=\"token number\">20210309</span> <span class=\"token number\">1</span> <span class=\"token number\">1</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token punctuation\">(</span>integer<span class=\"token punctuation\">)</span> <span class=\"token number\">0</span></pre></td></tr></table></figure><p>统计 20210308~20210309 总活跃用户数：</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token operator\">></span> BITOP and desk1 <span class=\"token number\">20210308</span> <span class=\"token number\">20210309</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">(</span>integer<span class=\"token punctuation\">)</span> <span class=\"token number\">1</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token operator\">></span> BITCOUNT desk1</pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token punctuation\">(</span>integer<span class=\"token punctuation\">)</span> <span class=\"token number\">1</span></pre></td></tr></table></figure><p>统计 20210308~20210309 在线活跃用户数：</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token operator\">></span> BITOP or desk2 <span class=\"token number\">20210308</span> <span class=\"token number\">20210309</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">(</span>integer<span class=\"token punctuation\">)</span> <span class=\"token number\">1</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token operator\">></span> BITCOUNT desk2</pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token punctuation\">(</span>integer<span class=\"token punctuation\">)</span> <span class=\"token number\">2</span></pre></td></tr></table></figure><h2 id=\"使用-hyperloglog-统计页面-uv独立访客\"><a class=\"anchor\" href=\"#使用-hyperloglog-统计页面-uv独立访客\">#</a> 使用 HyperLogLog 统计页面 UV（独立访客）</h2>\n<p>使用 HyperLogLog 统计页面 UV 主要需要用到下面这两个命令：</p>\n<ul>\n<li><code>PFADD key element1 element2 ...</code> ：添加一个或多个元素到 HyperLogLog 中。</li>\n<li><code>PFCOUNT key1 key2</code> ：获取一个或者多个 HyperLogLog 的唯一计数。</li>\n</ul>\n<p>1、将访问指定页面的每个用户 ID 添加到  <code>HyperLogLog</code>  中。</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>PFADD PAGE_1:UV USER1 USER2 <span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span> USERn</pre></td></tr></table></figure><p>2、统计指定页面的 UV。</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>PFCOUNT PAGE_1:UV</pre></td></tr></table></figure><h1 id=\"redis-持久化机制\"><a class=\"anchor\" href=\"#redis-持久化机制\">#</a> <mark>🌟Redis 持久化机制</mark></h1>\n<p>Redis 为什么需要持久化？Redis 是一个内存数据库，所以其运行效率非常高。但也存在一个问题：<font color='red'>内存中的数据是不持久的，若主机宕机或 Redis 关机重启，则内存中的数据全部丢失</font>。</p>\n<p>为了<font color='red'>重用数据（比如重启机器、机器故障之后恢复数据）</font>/<font color='red'>数据同步（比如 Redis 集群的主从节点通过 RDB 文件同步数据）</font>，Redis 需要持久化功能。</p>\n<p>Redis 会按照设置以<font color='cornflowerblue'>快照</font>或<font color='cornflowerblue'>操作日志</font>的形式将数据持久化到磁盘，对应两种持久化方式：RDB 与 AOF。但实际上，Redis 支持 3 种持久化方式：</p>\n<ul>\n<li><font color='gree'>RDB</font>（ <code>R</code> edis  <code>D</code> ata <code>B</code> ase）：快照</li>\n<li><font color='gree'>AOF</font>（ <code>A</code> ppend  <code>O</code> nly  <code>F</code> ile）：只追加文件</li>\n<li><font color='gree'>RDB + AOF</font>：RDB 和 AOF 的混合持久化 (Redis 4.0 新增)</li>\n</ul>\n<h2 id=\"持久化基本原理\"><a class=\"anchor\" href=\"#持久化基本原理\">#</a> 持久化基本原理</h2>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231207165444513.png\" alt=\"image-20231207165444513\" /></p>\n<p>Redis 持久化也称为<font color='red'> <code>钝化</code> ，是指将内存中数据库的状态描述信息保存到磁盘中</font>。只不过不同的持久化技术，对数据的状态描述信息是不同的，生成的持久化文件也是不同的。但它们的作用都是相同的：<font color='red'>避免数据意外丢失</font>。</p>\n<p>通过手动方式，或自动定时方式，或自动条件触发方式，将内存中数据库的状态描述信息写入到指定的持久化文件中。<font color='red'>当系统重新启动时，自动加载持久化文件，并根据文件中数 \\ 据库状态描述信息将数据恢复到内存中，这个数据恢复过程也称为 <code>激活</code> </font>。这个钝化与激活的过程就是 Redis 持久化的基本原理。</p>\n<p>不过从以上分析可知，对于 Redis 单机状态下，无论是手动方式，还是定时方式或条件触发方式，都存在<font color='red'> <code>数据丢失问题</code> ：在尚未手动 / 自动保存时发生了 Redis 宕机状况，那么从上次保存到宕机期间产生的数据就会丢失</font>。不同的持久化方式，其数据的丢失率也是不同的。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231207165853136.png\" alt=\"image-20231207165853136\" /></p>\n<p>需要注意的是，<strong><font color='red'>RDB 是默认持久化方式</font></strong>。但 Redis 允许 RDB 与 AOF 两种持久化技术同时开启，此时系统会使用 AOF 方式做持久化，即<font color='red'> AOF 持久化技术的优先级要更高</font>。同样的道理，两种技术同时开启状态下，系统启动时若两种持久化文件同时存在，则优先加载 AOF 持久化文件。</p>\n<h2 id=\"rdb-持久化\"><a class=\"anchor\" href=\"#rdb-持久化\">#</a> RDB 持久化</h2>\n<h3 id=\"rdb-简介\"><a class=\"anchor\" href=\"#rdb-简介\">#</a> RDB 简介</h3>\n<p>RDB（Redis DataBase）将内存中某一时刻的数据以 **<font color='red'>全量快照</font>** 的形式写入磁盘中的<font color='red'> rdb 文件</font>。RDB 持久化默认是开启的。当 Redis 启动时会自动读取 rdb 快照文件，将数据从硬盘载入到内存，以恢复 Redis 关机前的数据库状态。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230806005245328.png\" alt=\"image-20230806005245328\" /></p>\n<h3 id=\"rdb-快照的触发方式\"><a class=\"anchor\" href=\"#rdb-快照的触发方式\">#</a> RDB 快照的触发方式</h3>\n<h4 id=\"手动-save-命令\"><a class=\"anchor\" href=\"#手动-save-命令\">#</a> 手动 save 命令</h4>\n<blockquote>\n<p><strong>线上严禁使用！</strong></p>\n</blockquote>\n<p>通过在 redis-cli 客户端中手动执行 save 命令，可立即让 Redis 保存一次数据库的快照。<font color='red'>但是，save 命令在执行期间<strong>会阻塞</strong> redis-server 进程，导致 Redis 不能处理任何读写请求，无法对外提供缓存服务，直至持久化过程完毕</font>。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230806123508579.png\" alt=\"image-20230806123508579\" /></p>\n<h4 id=\"手动-bgsave-命令\"><a class=\"anchor\" href=\"#手动-bgsave-命令\">#</a> 手动 bgsave 命令</h4>\n<blockquote>\n<p>默认使用</p>\n</blockquote>\n<p>通过在 redis-cli 客户端中执行 bgsave 命令，可立即让 Redis 保存一次数据库的快照。不同于 save 命令的是，正如该命令的名称一样，background save，后台运行 save。<font color='red'>bgsave 命令会使服务器进程 redis-server 通过 fork () 生成一个子进程，由该子进程负责完成保存过程，<strong>不会阻塞</strong> redis-server 进程对客户端读写请求的处理</font>。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230806145215893.png\" alt=\"image-20230806145215893\" /></p>\n<h4 id=\"自动条件触发\"><a class=\"anchor\" href=\"#自动条件触发\">#</a> 自动条件触发</h4>\n<blockquote>\n<p>本质：<strong><font color='red'>定时自动执行 bgsave 命令</font></strong></p>\n</blockquote>\n<p>用户可修改配置文件  <code>redis.conf</code>  中 SNAPSHOTTING 的 save 参数，从而设置自动触发快照的时间间隔。比如  <code>save m n</code>  表示每隔 m 秒检测一次数据集，如果检测出超过 n 次变化时，自动触发 RDB 持久化条件，执行快照。</p>\n<blockquote>\n<p>注意，这里说的是<strong>每隔 m 秒检测一次，<font color='red'>对变化的计数是累加的</font>，只要在某次检测中发现变化数累加值达到 n 次，就会触发 RDB 持久化。<font color='red'>而不是要求 n 次变化都集中发生在某个 m 秒内！</font></strong></p>\n</blockquote>\n<p><strong><font color='cornflowerblue'>Redis 6.0.16 及之前</font></strong>：</p>\n<ul>\n<li>save 900 1：每隔 900s (15min) 检测一次，如果有超过 1 个 key 发生了变化，就写一份新的 RDB 文件</li>\n<li>save 300 10：每隔 300s (5min) 检测一次，如果有超过 10 个 key 发生了变化，就写一份新的 RDB 文件</li>\n<li>save 60 10000：每隔 60s (1min) 检测一次，如果有超过 10000 个 key 发生了变化，就写一份新的 RDB 文件</li>\n</ul>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230806010837837.png\" alt=\"image-20230806010837837\" /></p>\n<p><strong><font color='cornflowerblue'>Redis 6.0.16 以后至今</font></strong>：</p>\n<ul>\n<li>每隔 3600s（1hour）检测一次，如果有超过 1 处变化，就写一份新的 RDB 文件</li>\n<li>每隔 300s（5min）检测一次，如果有超过 100 处变化，就写一份新的 RDB 文件</li>\n<li>每隔 60s（1min）检测一次，如果有超过 10000 处变化，就写一份新的 RDB 文件</li>\n</ul>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230806010819707.png\" alt=\"image-20230806010819707\" /></p>\n<h3 id=\"rdb-持久化过程工作机制\"><a class=\"anchor\" href=\"#rdb-持久化过程工作机制\">#</a> RDB 持久化过程（工作机制）</h3>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230806145215893.png\" alt=\"image-20230806145215893\" /></p>\n<p>Redis 进行 bgsave 持久化时，服务器进程 redis-server 会执行以下操作:</p>\n<ul>\n<li>服务器进程（父进程）调用 <font color='red'>forks</font> 生成一个 bgsave 子进程</li>\n<li>bgsave 子进程调用 <font color='red'>dump</font> 将内存数据写入到一个 RDB 临时文件中</li>\n<li>新 RDB 文件<font color='red'>覆盖</font>原来的 RDB 文件</li>\n</ul>\n<p>bgsave 子进程以 **<font color='red'>异步方式</font>** 完成持久化，该过程<font color='red'>不会阻塞 redis-server 进程</font>，Redis 可以继续接收并处理用户的读写请求。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/Redis%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6.png\" alt=\"Redis写时复制\" /></p>\n<center>Redis写时复制</center>\n<p>其中，bgsave 子进程的详细工作原理如下：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231207202547716.png\" alt=\"image-20231207202547716\" /></p>\n<p>由于子进程可以继承父进程的所有资源，且父进程不能拒绝子进程的继承权。所以，bgsave 子进程有权读取到 redis-server 进程写入到内存中的用户数据，使得将内存数据持久化到 dump.rdb 成为可能。</p>\n<p>bgsave 子进程在持久化时首先会将内存中的全量数据 <font color='red'>copy</font> 到磁盘中的一个 RDB 临时文件，copy 结束后，再将该文件 <font color='red'>rename</font> 为 dump.rdb，替换掉原来的同名文件。</p>\n<p>不过，在进行持久化过程中，如果 redis-server 进程接收到了用户写请求，则系统会将内存中发生数据修改的物理块 copy 出一个副本。等内存中的全量数据 copy 结束后，会再将副本中的数据 copy 到 RDB 临时文件。这个副本的生成是由于 Linux 系统的<font color='red'><strong>写时复制技术</strong>（ <code>Copy-On-Write</code> ）</font>实现的。</p>\n<blockquote>\n<p>copy-on-write 是 Linux 系统的一种进程管理技术。</p>\n<p>原本在 Unix 系统中，当一个主进程通过 fork () 系统调用创建子进程后，内核进程会<font color='red'>复制主进程的整个内存空间中的数据，并将其分配给子进程</font>。这种方式存在的问题有以下几点：</p>\n<ul>\n<li>这个过程非常耗时</li>\n<li>这个过程降低了系统性能</li>\n<li>如果主进程修改了其内存数据，子进程副本中的数据是没有修改的。即出现了数据冗余，而冗余数据最大的问题是<font color='red'>数据一致性</font>无法保证。</li>\n</ul>\n<p>现代的 Linux 则采用了更为有效的方式：<strong><font color='#B32015'>写时复制</font></strong>。子进程会继承父进程的所有资源，其中就包括主进程的内存空间。即<font color='red'>子进程与父进程共享内存</font>。只要内存被共享，那么该内存就是只读的（写保护的）。而 **<font color='red'>写时复制则是在任何一方需要写入数据到共享内存时，都会出现异常，此时内核进程就会将需要写入的数据 copy 出一个副本，写入到另外一块非共享内存区域</font>**。</p>\n</blockquote>\n<h3 id=\"rdb-配置项\"><a class=\"anchor\" href=\"#rdb-配置项\">#</a> RDB 配置项</h3>\n<blockquote>\n<p>RDB 相关的配置在配置文件  <code>redis.conf</code>  中的 SNAPSHOTTING 部分</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>配置参数</th>\n<th>介绍</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>save</code>  &lt;seconds&gt; &lt;changes&gt;</td>\n<td>设置快照自动触发的条件（<font color='red'>时间间隔、变化数</font>）。默认情况下持久化条件为 save 3600 1 300 100 60 10000</td>\n<td><code>save m n</code>  表示每隔 m 秒检测一次数据集，如果检测出超过 n 次变化（累积）时，自动触发 RDB 持久化条件，执行快照。</td>\n</tr>\n<tr>\n<td><code>dbfilename</code></td>\n<td>设置 rdb 文件的名称，默认为 dump.rdb</td>\n<td>dbfilename dump.rdb</td>\n</tr>\n<tr>\n<td><code>dir</code></td>\n<td>设置 rdb 文件的保存路径，默认为 Redis 安装根目录</td>\n<td>dir ./</td>\n</tr>\n<tr>\n<td><code>stop-write-on-bgsave-error</code></td>\n<td>当子进程执行快照保存出现错误时，<font color='red'>是否让主进程停止接收新的写请求</font>，默认为 yes</td>\n<td>stop-write-on-bgsave-error yes</td>\n</tr>\n<tr>\n<td><code>rdbcompression</code></td>\n<td>对于存储到磁盘中的快照，<font color='red'>是否采用 LZF 算法对字符串对象进行压缩</font>，默认为 yes。可大幅降低文件的大小，方便保存到磁盘，加速主从集群中从节点的数据同步。</td>\n<td>rdbcompression yes</td>\n</tr>\n<tr>\n<td><code>rdbchecksum</code></td>\n<td><font color='red'>是否采用 CRC64 算法对快照文件进行数据校验</font>，默认为 yes</td>\n<td>rdbchecksum yes</td>\n</tr>\n<tr>\n<td><code>sanitize-dump-payload</code></td>\n<td>设置在加载 RDB 文件或进行持久化时<font color='red'>是否开启对 zipList、 listPack 等数据的全面安全检测</font>，该检测可以降低命令处理时发生系统崩溃的可能，默认为 no</td>\n<td>sanitize-dump-payload clients 表示只有当客户端连接时检测，排除了加载 RDB 文件与进行持久化时的检测。</td>\n</tr>\n<tr>\n<td><code>rdb-del-sync-files</code></td>\n<td><font color='red'>主从复制时，是否删除用于同步的从机上的 RDB 文件</font>。默认是 no，不删除。不过需要注意，只有当从机的 RDB 和 AOF 持久化功能都未开启时才生效。</td>\n<td>rdb-del-sync-files no</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"rdb-文件结构\"><a class=\"anchor\" href=\"#rdb-文件结构\">#</a> RDB 文件结构</h3>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231207205049480.png\" alt=\"image-20231207205049480\" /></p>\n<p>RDB 持久化文件 dump.rdb 由五部分构成：</p>\n<ul>\n<li>\n<p><font color='cornflowerblue'>SOF（文件开始标识）</font>：是一个长度为 5 的字符串常量 &quot;REDIS&quot;，标识 RDB 文件的开始，以便在加载 RDB 文件时可以迅速判断出文件是否是 RDB 文件。</p>\n</li>\n<li>\n<p><font color='cornflowerblue'>rdb_version（文件版本号）</font>：是一个长度为 4 字节的整数</p>\n</li>\n<li>\n<p><font color='cornflowerblue'>EOF（文件结束标识）</font>：长度为 1 字节的常量，用于标识 RDB 数据的结束，校验和的开始。</p>\n</li>\n<li>\n<p><font color='cornflowerblue'>check_sum（校验和）</font>：<font color='red'>用于判断 RDB 文件中是否出现数据异常</font>，采用的是 <font color='red'>CRC 校验算法</font>。</p>\n<blockquote>\n<p>CRC 校验算法：</p>\n<p>在持久化时，先将 SOF、rdb_version 及内存数据库中的数据快照这三者的二进制数据拼接起来，形成一个二进制数（假设称为数 a），然后再使用这个 a 除以校验和 check_sum，此时可获取到一个余数 b，然后再将这个 b 拼接到 a 的后面，形成 databases。</p>\n<p>在加载时，需要先使用 check_sum 对 RDB 文件进行数据损坏验证。验证过程：只需将 RDB 文件中除 EOF 与 check_sum 外的数据除以 check_sum。只要除得的余数不是 0，就说明文件发生损坏。当然，如果余数是 0，也不能肯定文件没有损坏。</p>\n<p><font color='red'>这种验证算法，是数据损坏校验，而不是数据没有损坏的校验</font>。</p>\n</blockquote>\n</li>\n<li>\n<p><strong><font color='cornflowerblue'>databases（数据库）</font></strong>：可以包含任意多个非空数据库 database，每个 database 又由三部分构成：</p>\n<ul>\n<li>\n<p><font color='blue'>SODB（数据库开始标识）</font></p>\n</li>\n<li>\n<p><font color='blue'>db_number（数据库编号）</font></p>\n</li>\n<li>\n<p><font color='blue'>key_value_pairs（键值对数据）</font>：每个键值对又由多个描述数据构成：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231207211310010.png\" alt=\"image-20231207211310010\" /></p>\n<ul>\n<li>VALUE_TYPE</li>\n<li>EXPIRETIME_UNIT（过期时间的单位）</li>\n<li>time（当前键值对的过期时间）</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"rdb-优缺点\"><a class=\"anchor\" href=\"#rdb-优缺点\">#</a> RDB 优缺点</h3>\n<p>RDB 持久化的优点：</p>\n<ul>\n<li>适合<font color='red'>大规模</font>的数据恢复</li>\n<li>按照业务，<font color='red'>定时备份</font></li>\n<li>对数据完整性和一致性要求不高</li>\n<li>dump.rdb 文件在内存中的<font color='red'>加载速度</font>要比 AOF 快得多</li>\n</ul>\n<p>RDB 持久化的缺点：</p>\n<ul>\n<li>一定间隔时间做一次备份，所以如果 Redis 意外 down 掉的话，就会丢失从当前至最近一次快照期间的数据，<strong><font color='red'>快照之间的数据会丢失</font></strong></li>\n<li>内存数据的全量同步，如果数据量太大会导致<font color='red'> I/O 严重影响服务器性能</font></li>\n<li>RDB 依赖于主进程的 fork，在更大的数据集中，这可能会导致<font color='red'>服务请求的瞬间延迟</font></li>\n<li>fork 的时候内存中的数据被克降了一份，<font color='red'>大致 2 倍的数据膨胀性</font>，需要考虑</li>\n</ul>\n<h3 id=\"如何禁用-rdb\"><a class=\"anchor\" href=\"#如何禁用-rdb\">#</a> 如何禁用 RDB</h3>\n<p>将配置文件中的 save 参数设置为空串 &quot;&quot;，有两种方式：</p>\n<ul>\n<li>\n<p>命令： <code>res-cli config set save &quot;&quot;</code></p>\n</li>\n<li>\n<p>修改配置文件：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230806152126685.png\" alt=\"image-20230806152126685\" /></p>\n</li>\n</ul>\n<h3 id=\"如何恢复-rdb-文件\"><a class=\"anchor\" href=\"#如何恢复-rdb-文件\">#</a> 如何恢复 RDB 文件</h3>\n<p>当 dump.rdb 文件破损时可以使用  <code>redis-check-rdb</code>  命令进行修复。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230806151515656.png\" alt=\"image-20230806151515656\" /></p>\n<h3 id=\"rdb-小结\"><a class=\"anchor\" href=\"#rdb-小结\">#</a> RDB 小结</h3>\n<img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230806153628002.png\" alt=\"image-20230806153628002\"  />\n<h2 id=\"aof-持久化\"><a class=\"anchor\" href=\"#aof-持久化\">#</a> AOF 持久化</h2>\n<h3 id=\"aof-简介\"><a class=\"anchor\" href=\"#aof-简介\">#</a> AOF 简介</h3>\n<blockquote>\n<p>动机：对于 RDB 持久化的快照，如果 Redis 因为某些原因而造成故障停机，那么服务器<font color='red'>将丢失最近写入、但仍未保存到快照中的那些数据</font>。因此，Redis 增加了一种 **<font color='red'>完全耐久、实时性更好</font>** 的持久化方式：AOF 持久化。</p>\n</blockquote>\n<p>AOF（ <code>A</code> ppend  <code>O</code> nly  <code>F</code> ile）<font color='red'>以<strong>日志文件</strong>（ <code>appendonly.aof</code>  文件）的形式来<strong>追加</strong>记录 Redis 执行过的每个<strong>写操作指令</strong></font>。Redis 重启时就根据日志文件的内容将写指令从前到后重新执行一次，以完成数据的恢复工作。</p>\n<p><font color='red'>Redis 6.0 之前默认关闭 AOF，Redis 6.0 之后默认开启 AOF</font>。开启 AOF 功能需要在配置文件  <code>redis.conf</code>  中设置配置:  <code>appendonly yes</code> 。</p>\n<h3 id=\"aof-文件格式\"><a class=\"anchor\" href=\"#aof-文件格式\">#</a> AOF 文件格式</h3>\n<p>从 Redis 7 开始，采用 <strong><font color='#B32015'>Multi Part AOF</font></strong> 机制，将原来的单个 AOF 文件拆分成三类多个 AOF 文件：</p>\n<ul>\n<li><font color='gree'>基本文件（base.rdb/aof）</font>：可以是 RDB / AOF 格式，默认为 RDB 格式，即混合式持久化。一般由子线程通过 rewrite 产生，该文件最多只有一个。</li>\n<li><font color='gree'>增量文件（incr.aof）</font>：以操作日志形式记录写命令，一般在 rewrite 开始执行时创建，该文件可以有多个。</li>\n<li>历史文件：由 BASE 和 INCR AOF 变化而来，每次 AOFRW 成功完成时，本次 AOFRW 之前对应的 BASE 和 INCR AOF 都将变为 HISTORY，HISTORY 类型的 AOF 会被 Redis 自动删除。</li>\n</ul>\n<p>此外，还有<font color='gree'>清单文件（manifest）</font>：该文件首先会按照 seq 序号列举出所有<font color='red'>基本文件</font>，基本文件 type 类型为 b，然后再按照 seq 序号再列举出所有<font color='red'>增量文件</font>，增量文件 type 类型为 i。对于 Redis 启动时的数据恢复，也会按照该文件由上到下依次加载它们中的数据。可以维护 AOF 文件的创建顺序，保障激活时的应用顺序。</p>\n<p>其中基本文件一般为 rdb 格式，在前面已经研究过了。下面就来看一下增量文件与清单文件的内容格式。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230806210712843.png\" alt=\"image-20230806210712843\" /></p>\n<h3 id=\"aof-配置项\"><a class=\"anchor\" href=\"#aof-配置项\">#</a> AOF 配置项</h3>\n<table>\n<thead>\n<tr>\n<th>配置参数</th>\n<th>介绍</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>appendonly</code></td>\n<td>是否开启 AOF</td>\n<td>appendonly yes</td>\n</tr>\n<tr>\n<td><code>appendfilename</code></td>\n<td>设置 AOF 文件的名称</td>\n<td>appendfilename &quot;appendonly.aof&quot;</td>\n</tr>\n<tr>\n<td><code>aof-use-rdb-preamble</code></td>\n<td>设置基本文件为 RDF 格式 / AOF 格式，<font color='red'>默认为 yes（RDB 格式），即混合式持久化</font></td>\n<td>aof-use-rdb-preamble yes</td>\n</tr>\n<tr>\n<td><code>appenddirname</code></td>\n<td>设置 AOF 文件目录，默认为 Redis 安装目录</td>\n<td>appenddirname &quot;appendonlydir&quot;</td>\n</tr>\n<tr>\n<td><code>appendfsync</code></td>\n<td>设置同步方式（刷盘时机）</td>\n<td>appendfsync <font color='red'>always/everysec/no</font></td>\n</tr>\n<tr>\n<td><code>no-appendfsync-on-rewrite</code></td>\n<td>AOF rewrite 期间是否同步（刷盘）</td>\n<td></td>\n</tr>\n<tr>\n<td><code>auto-aof-rewrite-percentage</code> </br> <code>auto-aof-rewrite-min-size</code></td>\n<td>rewrite 触发配置、文件重写策略</td>\n<td>auto-aof-rewrite-percentage 100</br>auto-aof-rewrite-min-size 64mb</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"aof-持久化过程工作基本流程\"><a class=\"anchor\" href=\"#aof-持久化过程工作基本流程\">#</a> AOF 持久化过程（工作基本流程）</h3>\n<p>AOF 持久化功能的实现可以简单分为 5 步：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231208165553752.png\" alt=\"image-20231208165553752\" /></p>\n<center>AOF 工作基本流程</center>\n<ol>\n<li>\n<p><strong><font color='#B32015'>命令追加（append）</font></strong>：所有的写命令会  <code>append</code>  到内存中的<font color='gree'> AOF 缓冲区</font>。</p>\n</li>\n<li>\n<p><strong><font color='#B32015'>文件写入（write）</font></strong>：将 AOF 缓冲区的数据写入到 AOF 文件中。这一步需要调用  <code>write</code>  函数（系统调用）将数据写入到了<font color='gree'>系统内核缓冲区</font>之后<font color='red'>直接返回了（延迟写）</font>。注意！！！<font color='red'>此时并没有同步到磁盘</font>。</p>\n</li>\n<li>\n<p><strong><font color='#B32015'>文件同步（fsync）</font></strong>：AOF 缓冲区根据对应的持久化方式（  <code>fsync</code>  策略）向<font color='gree'>硬盘</font>做同步操作。这一步需要调用  <code>fsync</code>  函数（系统调用），  <code>fsync</code>  针对单个文件操作，对其进行强制硬盘同步， <code>fsync</code>  将<font color='red'>阻塞</font>直到写入磁盘完成后返回，保证了数据持久化。</p>\n</li>\n<li>\n<p><strong><font color='#B32015'>文件重写（rewrite）</font></strong>：随着<font color='red'>磁盘上</font>的 AOF 文件越来越大，到达 rewrite 条件时，主线程会 fork 一个子线程 bgrewriteaof 定期 AOF 文件进行重写（<font color='red'>根据规则去合并写命令</font>），达到<font color='red'>压缩</font>的目的。</p>\n<blockquote>\n<p>如果在 rewrite 过程中又有写操作命令追加，那么这些数据会暂时写入 aof_rewrite_buf 缓冲区。等将全部 rewrite 计算结果写入临时文件后，会先将 aof_rewrite_buf 缓冲区中的数据写入临时文件，然后再 rename 为磁盘文件的原名称，覆盖原文件。</p>\n</blockquote>\n</li>\n<li>\n<p><strong><font color='#B32015'>重启加载（load）</font></strong>：当 Redis 重启时，可以加载磁盘上的 AOF 文件，执行其中的写命令，进行数据恢复。</p>\n</li>\n</ol>\n<blockquote>\n<p>Linux 系统直接提供了一些函数用于对文件和设备进行访问和控制，这些函数被称为<strong>系统调用（syscall）</strong>。</p>\n</blockquote>\n<p>这里对上面提到的一些 Linux 系统调用再做一遍解释：</p>\n<ul>\n<li><code>write</code> ：<font color='red'>写入系统内核缓冲区之后直接返回（仅仅是写到缓冲区），不会立即同步到硬盘</font>。虽然提高了效率，但也带来了<font color='red'>数据丢失的风险</font>。同步硬盘操作通常依赖于系统调度机制，Linux 内核通常为 30s 同步一次，具体值取决于写出的数据量和 I/O 缓冲区的状态。</li>\n<li><code>fsync</code> ：用于<font color='red'>强制刷新系统内核缓冲区（同步到到磁盘）</font>，会一直阻塞直到确保写磁盘操作结束才会返回。</li>\n</ul>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231208170306808.png\" alt=\"image-20231208170306808\" /></p>\n<h3 id=\"aof-缓冲区的三种写回刷盘策略fsync-策略\"><a class=\"anchor\" href=\"#aof-缓冲区的三种写回刷盘策略fsync-策略\">#</a> AOF 缓冲区的三种写回 / 刷盘策略（ <code>fsync</code>  策略）</h3>\n<blockquote>\n<p>主要区别在于 <strong><font color='red'>fsync 同步 AOF 文件的时机（刷盘）</font></strong></p>\n</blockquote>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231208165553752.png\" alt=\"image-20231208165553752\" /></p>\n<p>AOF 缓冲区需要将它保存的写命令写入磁盘上的 AOF 文件，可以修改配置文件中的 <code>参数 appendfsync</code> ，有三种策略：</p>\n<ul>\n<li><code>always</code> ：<strong><font color='gree'>同步写回</font></strong>，主线程调用 write 后，后台线程会立即调用 fsync 函数同步 AOF 文件（刷盘）。fsync 完成后线程返回，这会严重降低 Redis 的性能<font color='red'>（write + fsync）</font></li>\n<li><code>everysec</code> ：<strong><font color='gree'>每秒写回</font></strong>，主线程调用 write 后立即返回，由后台线程每秒调用 fsync 函数同步一次 AOF 文件<font color='red'>（write + fsync，其中 fsync 间隔为 1 秒）</font></li>\n<li><code>no</code> ：<strong><font color='gree'>操作系统控制的写回</font></strong>，主线程调用 write 后立即返回，让操作系统决定何时进行同步（刷盘）。Linux 中一般为 30 秒一次<font color='red'>（write 但不 fsync，其中 fsync 的时机由操作系统决定）</font></li>\n</ul>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230806200107294.png\" alt=\"image-20230806200107294\" /></p>\n<h3 id=\"aof-重写机制rewrite\"><a class=\"anchor\" href=\"#aof-重写机制rewrite\">#</a> <mark>🌟AOF 重写机制（Rewrite）</mark></h3>\n<h4 id=\"何为-rewrite\"><a class=\"anchor\" href=\"#何为-rewrite\">#</a> 何为 rewrite</h4>\n<p>当 AOF 变得太大时，Redis 能够在后台产生一个新的 AOF 文件，该文件与原有的 AOF 文件所保存的<font color='red'>数据库状态一样，但体积更小</font>。</p>\n<blockquote>\n<p>AOF 重写是一个有歧义的名字，该功能是通过读取数据库中的键值对来实现的，程序无须对现有 AOF 文件进行任何读入、分析或者写入操作。</p>\n</blockquote>\n<p><font color='orange'>AOF 重写机制</font>：启动 AOF 文件的内容压缩，<font color='red'>合并其中的命令，只保留可以恢复数据的最小指令集</font>。</p>\n<blockquote>\n<p><strong><font color='red'>重写完成后</font></strong>：</p>\n<ul>\n<li>重写结果被保存到一个新的 BASE AOF 文件中，文件名上的标号加 1。</li>\n<li>同时，新建一个空的 INCR AOF 文件，文件名上的标号加 1，旧的被删除。</li>\n</ul>\n</blockquote>\n<h4 id=\"rewrite-触发方式\"><a class=\"anchor\" href=\"#rewrite-触发方式\">#</a> rewrite 触发方式</h4>\n<p>AOF 重写机制有<font color='red'>两种触发方式</font>：</p>\n<ul>\n<li>\n<p><font color='cornflowerblue'>自动触发</font>：当 INCR AOF 文件<font color='red'>同时满足</font>以下两个条件时，Redis 就会<font color='red'>自动</font>启动重写机制，只保留可以恢复数据的最小指令集</p>\n<blockquote>\n<p>INCR AOF 文件负责记录从 AOF 缓冲区写回的写命令</p>\n</blockquote>\n<ul>\n<li>当 INCR AOF 文件的大小超过上一次重写结果（即 BASE AOF 文件）大小 1 倍（可以通过配置 <code>auto-aof-rewrite-percentage</code>  修改）</li>\n<li>当 INCR AOF 文件的大小超过 64MB（可以通过配置 <code>auto-aof-rewrite-min-size</code>  修改）</li>\n</ul>\n</li>\n<li>\n<p><font color='cornflowerblue'>手动触发</font>：可以手动使用命令  <code>bgrewriteaof</code>  来重写。</p>\n</li>\n</ul>\n<p>具体过程见脑图，这里只演示 AOF 重写后的效果：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230807004504357.png\" alt=\"image-20230807004504357\" /></p>\n<center>自动重写</center>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230807004613263.png\" alt=\"image-20230807004613263\" /></p>\n<center>手动重写</center>\n<p>结论：</p>\n<ul>\n<li>AOF 文件重写并不是对原文件进行重新整理，而是<font color='red'>直接读取服务器现有的键值对，然后用一条命令去代替之前记录这个键值对的多条命令</font>，生成一个新的文件后去替换原来的 AOF 文件。</li>\n<li>AOF 文件重写触发机制：通过 redis.conf 配置文件中的 <code>auto-aof-rewrite-percentage</code> : 默认值为 100，以及 <code>auto-aof-rewrite·min-size</code> : 64mb 配置，也就是说默认 Redis 会记录上次重写时的 AOF 大小，默认配置是当 AOF 文件大小是上次 rewrite 后大小的一倍<strong>且</strong>文件大于 64M 时触发。</li>\n</ul>\n<h4 id=\"rewrite-原理\"><a class=\"anchor\" href=\"#rewrite-原理\">#</a> rewrite 原理</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/2032648-20220207170749957-1755223036.png\" alt=\"img\" /></p>\n<ol>\n<li>\n<p>在重写开始前，Redis 会创建一个重写子进程  <code>bgrewriteaof</code> ，这个子进程会读取现有的 AOF 文件，并将其包含的指令进行<font color='red'>分析、压缩</font>，写入到一个临时文件中。</p>\n</li>\n<li>\n<p>与此同时，主进程会将新接收到的写指令一边累积到内存缓冲区中，一边继续写入到原有的 AOF 文件中，这样做是保证原有的 AOF 文件的可用性，避免在重写过程中出现意外。</p>\n</li>\n<li>\n<p>当重写子进程完成重写工作后，它会给父进程发一个信号，父进程收到信号后就会将内存中缓存的写指令追加到新 AOF 文件中</p>\n</li>\n<li>\n<p>当追加结束后，Redis 就会用新 AOF 文件来<font color='red'>代替</font>旧 AOF 文件，之后再有新的写指令，就都会追加到新的 AOF 文件中</p>\n</li>\n<li>\n<p>重写 AOF 文件的操作，并没有读取旧的 AOF 文件，而是将整个内存中的数据库内容用命令的方式重写了一个新的 AOF 文件，这点和快照有点类似</p>\n</li>\n</ol>\n<h3 id=\"aof-校验机制\"><a class=\"anchor\" href=\"#aof-校验机制\">#</a> AOF 校验机制</h3>\n<p>AOF 校验机制是 Redis 在启动时对 AOF 文件进行检查，以<font color='red'>判断文件是否完整，是否有损坏或者丢失的数据</font>。这个机制的原理其实非常简单，就是通过使用一种叫做 **<font color='#B32015'>校验和（checksum）</font>** 的数字来验证 AOF 文件。这个校验和是通过对整个 AOF 文件内容进行<font color='red'> CRC64 算法</font>计算得出的数字。如果文件内容发生了变化，那么校验和也会随之改变。因此，Redis 在启动时会比较计算出的校验和与文件末尾保存的校验和（计算的时候会把最后一行保存校验和的内容给忽略点），从而判断 AOF 文件是否完整。如果发现文件有问题，Redis 就会拒绝启动并提供相应的错误信息。AOF 校验机制十分简单有效，可以提高 Redis 数据的可靠性。</p>\n<p>类似地，<font color='red'>RDB 文件也有类似的校验机制</font>来保证 RDB 文件的正确性，这里就不重复进行介绍了。</p>\n<h3 id=\"aof-记录日志过程\"><a class=\"anchor\" href=\"#aof-记录日志过程\">#</a> AOF 记录日志过程</h3>\n<p>关系型数据库（如 MySQL）通常都是执行命令之前记录日志（方便故障恢复），而 <font color='red'>Redis AOF 持久化机制是在执行完命令之后再记录日志</font>。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/redis-aof-write-log-disc.png\" alt=\"AOF 记录日志过程\" /></p>\n<center>AOF 记录日志过程</center>\n<p><strong>为什么是在执行完命令之后记录日志呢？</strong></p>\n<ul>\n<li><font color='red'>避免额外的检查开销</font>，AOF 记录日志不会对命令进行语法检查；</li>\n<li>在命令执行完之后再记录，<font color='red'>不会阻塞当前的命令执行</font>。</li>\n</ul>\n<p>这样也带来了风险（我在前面介绍 AOF 持久化的时候也提到过）：</p>\n<ul>\n<li>如果刚执行完命令 Redis 就宕机<font color='red'>会导致对应的修改丢失</font>；</li>\n<li><font color='red'>可能会阻塞后续其他命令的执行</font>（AOF 记录日志是在 Redis 主线程中进行的）。</li>\n</ul>\n<h3 id=\"aof-优缺点\"><a class=\"anchor\" href=\"#aof-优缺点\">#</a> AOF 优缺点</h3>\n<p>AOF 有以下优点：</p>\n<ul>\n<li>\n<p>更好地保护数据不丢失</p>\n<blockquote>\n<p>使用 AOF Redis 更加持久∶您可以有<font color='red'>不同的 fsync 策略</font>：根本不 fsync、每秒 fsync、每次查询时 fsync。使用每秒 fsync 的默认策略，写入性能仍然很棒。fsync 是使用后台线程执行的，当没有 fsync 正在进行时，主线程将努力执行写入，因此您<font color='red'>只能丢失一秒钟的写入</font>。</p>\n</blockquote>\n</li>\n<li>\n<p>易修复</p>\n<blockquote>\n<p>AOF 日志是一个仅附加日志，因此不会出现寻道问题，也不会在断电时出现损坏问题。即使由于某种原因（磁盘已满或其他原因）日志以写一半的命令结尾， <code>redis-check-aof</code>  工具也能够轻松修复它。</p>\n</blockquote>\n</li>\n<li>\n<p>得益于 AOF 的重写机制，能够自我压缩</p>\n<blockquote>\n<p>当 AOF 变得太大时，Redis 能够在后台自动重写 AOF。重写是完全安全的，因为当 Redis 继续附加到旧文件时，会使用创建当前数据集所需的最少操作集生成一个全新的文件，一旦第二个文件准备就绪，Redis 就会切换两者并开始附加到新的那一个。</p>\n</blockquote>\n</li>\n<li>\n<p>性能高</p>\n</li>\n<li>\n<p>文件内容易理解</p>\n<blockquote>\n<p>AOF 以易于理解和解析的格式依次包含所有操作的日志。您甚至可以轻松导出 AOF 文件。</p>\n</blockquote>\n</li>\n<li>\n<p>可做紧急恢复</p>\n<blockquote>\n<p>即使您不小心使用该 <code>FLUSHALL</code>  命令刷新了所有内容，只要在此期间没有执行日志重写，您仍然可以通过停止服务器、<font color='red'>删除最新命令</font>并重新启动 Redis 来保存您的数据集。</p>\n</blockquote>\n</li>\n</ul>\n<p>AOF 有以下缺点：</p>\n<ul>\n<li>对于相同的数据集而言，aof 文件要 **<font color='red'>远大于 rdb 文件</font>，<font color='red'>恢复速度慢于 rdb</font>**</li>\n<li>aof**<font color='red'>运行效率要慢于 rdb</font>**，每秒同步策略效率较好，不同步效率和 rdb 相同</li>\n</ul>\n<h3 id=\"aof-小结\"><a class=\"anchor\" href=\"#aof-小结\">#</a> AOF 小结</h3>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230807005534144.png\" alt=\"image-20230807005534144\" /></p>\n<h2 id=\"rdb-aof-混合持久化\"><a class=\"anchor\" href=\"#rdb-aof-混合持久化\">#</a> RDB-AOF 混合持久化</h2>\n<p>Redis**<font color='red'>默认仅使用 RDB 持久化</font><strong>，禁用 AOF 持久化。但是，当我们</strong><font color='red'>手动启用 AOF 持久化后，AOF 的优先级高于 RDB</font>**！对应的数据恢复顺序和加载流程如下图：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231207165853136.png\" alt=\"image-20231207165853136\" /></p>\n<h2 id=\"rdb-与-aof-对比持久化技术选型\"><a class=\"anchor\" href=\"#rdb-与-aof-对比持久化技术选型\">#</a> <mark>🌟RDB 与 AOF 对比（持久化技术选型）</mark></h2>\n<blockquote>\n<p>RDB：定时一锅端</p>\n</blockquote>\n<p>二者各自的特点如下：</p>\n<ul>\n<li><font color='cornflowerblue'>RDB 持久化（定时一锅端）</font>：能够在指定的时间间隔对数据库进行全量快照存储</li>\n<li><font color='cornflowerblue'>AOF 持久化（实时记录写命令）</font>：记录每次对服务器写的操作，当服务器重启的时候会重新执行这些命令来恢复原始的数据，命令以 Redis 协议追加保存每次写的操作到文件末尾。</li>\n</ul>\n<p>RDB 优点：</p>\n<ul>\n<li>RDB 文件较小</li>\n<li>数据恢复速度快</li>\n</ul>\n<p>RDB 不足：</p>\n<ul>\n<li>数据安全性较差</li>\n<li>写时复制会降低性能</li>\n<li>RDB 文件的可读性较差</li>\n</ul>\n<p>AOF 优点：</p>\n<ul>\n<li>数据安全性高（仅追加新执行的写命令）</li>\n<li>AOF 文件的可读性强，以一种易于理解和解析的格式包含所有写操作的日志</li>\n</ul>\n<p>AOF 不足：</p>\n<ul>\n<li>AOF 文件较大</li>\n<li>数据恢复速度慢</li>\n<li>写操作会影响性能</li>\n</ul>\n<p>RDB + AOF 同时开启时的情况：</p>\n<ul>\n<li>当 redis 重启的时候会<font color='red'>优先载入 AOF 文件</font>来恢复原始的数据，因为在通常情况下 AOF 文件保存的数据集要比 RDB 文件保存的数据集<font color='red'>更完整</font></li>\n<li>RDB 的数据不实时，同时使用两者时服务器重启也只会找 AOF 文件。<font color='red'>但是作者建议不要只使用 AOF</font>，因为 RDB 更适合用于备份数据库 (AOF 在不断变化不好备份)，<font color='red'>留着 rdb 以防万一</font></li>\n</ul>\n<p>综上，</p>\n<ul>\n<li>\n<p><strong><font color='orange'>官方推荐 RDB+AOF 混合方式</font></strong>，既能快速加载又能避免丢失过多的数据。配置方式：</p>\n<ol>\n<li>\n<p>对应配置文件中的 <code>aof-use-rdb-preamble</code> ，默认为 yes</p>\n</li>\n<li>\n<p><font color='red'>开启 AOF 持久化</font>，对应配置文件中的 <code>appendonly</code>  设置为 yes，默认为 no</p>\n</li>\n</ol>\n</li>\n<li>\n<p>若对数据安全性要求不高，则推荐使用纯 RDB 持久化方式</p>\n</li>\n<li>\n<p>不推荐使用纯 AOF 持久化方式，因为 RDB 更适合备份数据库</p>\n</li>\n<li>\n<p>若 Redis 仅用于缓存，则无需使用任何持久化技术</p>\n</li>\n</ul>\n<blockquote>\n<p>采用 RDB+AOF 混合持久化时，<font color='red'>RDB 做<strong>全量</strong>持久化，AOF 做<strong>增量</strong>持久化</font>：</p>\n<ul>\n<li>先使用 RDB 进行快照存储</li>\n<li>然后使用 AOF 持久化记录所有的写操作</li>\n<li>当重写策略满足或手动触发重写的时候，将最新的数据存储为新的 RDB 记录。</li>\n<li>这样的话，重启服务的时候会从 RDB 和 AOF 两部分恢复数据，既保证了数据完整性，又提高了恢复数据的性能。</li>\n</ul>\n<p>简单来说：混合持久化方式产生的文件一部分是 RDB 格式，一部分是 AOF 格式。<strong>----》<font color='red'>AOF 包括了 RDB 头部 + AOF 混写</font></strong></p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230807011820642.png\" alt=\"image-20230807011820642\" /></p>\n</blockquote>\n<h2 id=\"纯缓存模式\"><a class=\"anchor\" href=\"#纯缓存模式\">#</a> 纯缓存模式</h2>\n<blockquote>\n<p>Redis 作为基于 key-value 的内存数据库，<strong>Redis 最主要的功能是用作缓存</strong>，而 Redis 持久化会消耗 Redis 的性能，因此可以<strong>同时关闭 RDB+AOF</strong>。</p>\n</blockquote>\n<p><strong><font color='cornflowerblue'>禁用 RDB</font></strong>：</p>\n<blockquote>\n<p>此时仍然可以手动使用命令 <code>SAVE</code>  和 <code>BGSAVE</code>  生成 rdb 文件</p>\n</blockquote>\n<ul>\n<li>\n<p>命令： <code>res-cli config set save &quot;&quot;</code></p>\n</li>\n<li>\n<p>修改配置文件：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230807012414863.png\" alt=\"image-20230807012414863\" /></p>\n</li>\n</ul>\n<p><strong><font color='cornflowerblue'>禁用 AOF</font></strong>：</p>\n<blockquote>\n<p>此时仍然可以手动使用命令 <code>BGREWRITEAOF</code>  生成 aof 文件</p>\n</blockquote>\n<ul>\n<li>命令： <code>res-cli config set appendonly no</code></li>\n<li>修改配置文件：将 <code>redis.conf</code>  中 APPEND ONLY MODE 模块下的 <code>参数appendonly</code>  设置为 no</li>\n</ul>\n<h1 id=\"redis-线程io模型\"><a class=\"anchor\" href=\"#redis-线程io模型\">#</a> Redis 线程（IO）模型</h1>\n<p>Redis 客户端提交的各种请求是如何最终被 Redis 处理的？<font color='red'>Redis 处理客户端请求所采用的处理架构，称为 Redis 的 IO 模型</font>。不同版本的 Redis 采用的 IO 模型是不同的。</p>\n<p>对于读写命令来说，Redis 一直是单线程模型。不过，<font color='red'>在 Redis 4.0 版本之后引入了多线程来执行一些大键值对的异步删除操作</font>，<font color='red'>Redis 6.0 版本之后引入了多线程来处理网络请求（提高网络 IO 读写性能）</font>。</p>\n<h2 id=\"单线程模型\"><a class=\"anchor\" href=\"#单线程模型\">#</a> 单线程模型</h2>\n<blockquote>\n<p>Redis 3.0 及其以前版本</p>\n</blockquote>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231208205447709.png\" alt=\"image-20231208205447709\" /></p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231208210519289.png\" alt=\"image-20231208210519289\" /></p>\n<p>Redis 的单线程模型：<font color='red'>所有客户端的请求全部由一个线程处理</font>，采用了 <strong><font color='#B32015'>IO 多路复用（multiplexing）技术</font></strong>。</p>\n<p>Redis 基于 Reactor 模式开发了自己的网络事件处理器：这个处理器被称为 **<font color='cornflowerblue'>文件事件处理器（file event handler）</font>**。</p>\n<ul>\n<li>文件事件处理器使用<font color='cornflowerblue'> I/O 多路复用程序</font>来同时监听多个<font color='cornflowerblue'>套接字（socket）</font>，并根据套接字目前执行的任务来为套接字关联不同的事件处理器。</li>\n<li>当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关闭（close）等操作时，与操作相对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。</li>\n</ul>\n<p>文件事件处理器（file event handler）主要是包含 4 个部分：</p>\n<ul>\n<li>多个 socket（客户端连接）</li>\n<li>IO 多路复用程序（支持多个客户端连接的关键）</li>\n<li>文件事件分派器（将 socket 关联到相应的事件处理器）</li>\n<li>事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）</li>\n</ul>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/redis-event-handler.png\" alt=\"文件事件处理器（file event handler）\" /></p>\n<center>文件事件处理器（file event handler）</center>\n<p><strong><font color='#B32015'>虽然文件事件处理器以单线程方式运行，但通过使用 I/O 多路复用程序来监听多个套接字</font></strong>，文件事件处理器既实现了高性能的网络通信模型，又可以很好地与 Redis 服务器中其他同样以单线程方式运行的模块进行对接，这保持了 Redis 内部单线程设计的简单性。</p>\n<blockquote>\n<p>IO 多路复用技术是一种处理多个 IO 流的技术。它允许单个进程同时监视多个文件描述符（file descriptor，fd），当一个或多个 fd 准备好读或写时，它就可以立即响应。这种技术可以提高系统的并发性和响应能力，减少系统资源的浪费。</p>\n<p>在 Linux 中，epoll、select、poll 都是 IO 多路复用的实现方式，都可以监视多个 fd，一旦某个 fd 就绪 (一般是读就绪或者写就绪)，能够通知程序进行相应的读写操作。</p>\n<p>对于 IO 多路复用的实现方式常见的有三种：</p>\n<ul>\n<li><font color='cornflowerblue'>select 模型</font>：最早的 IO 多路复用机制，<font color='red'>同时监视 fd 的数量不超过 1024 个，而且每次只能监视一部分 fd 的状态变化</font>。</li>\n<li><font color='cornflowerblue'>poll 模型</font>：与 select 类似，采用的是<font color='red'>轮询算法</font>，但是可以同时监视 fd 的数量更多（65536 个），该模型对客户端的就绪处理是有延迟的。</li>\n<li><font color='cornflowerblue'>epoll 模型</font>：是 Linux 所特有的，采用的是<font color='red'>回调方式</font>，支持更多的 fd 数量（8192 个），根据就绪事件发生后的处理方式的不同，又可分为 LT 模型与 ET 模型。</li>\n</ul>\n</blockquote>\n<p>每个<font color='gree'>客户端</font>若要向 Redis 提交请求，都需要与 Redis 建立一个 <font color='gree'>socket 连接</font>，并向<font color='gree'>事件分发器</font>注册一个事件。一旦该事件发生就表明该连接已经就绪。而一旦连接就绪，事件分发器就会感知到，然后获取客户端通过该连接发送的请求，并将由该事件分发器所绑定的这个<font color='red'>唯一的线程</font>来处理。如果该线程还在处理多个任务，则将该任务写入到<font color='gree'>任务队列</font>等待线程处理。</p>\n<p>之所以称为事件分发器，是因为它会根据不同的就绪事件，将任务交由不同的<font color='gree'>事件处理器</font>去处理。</p>\n<h2 id=\"混合线程模型\"><a class=\"anchor\" href=\"#混合线程模型\">#</a> 混合线程模型</h2>\n<blockquote>\n<p>Redis 4.0 开始</p>\n</blockquote>\n<p>从 Redis 4.0 版本开始，Redis 中就开始加入了多线程元素。处理客户端请求的仍是单线程模型，但<font color='red'>对于一些比较耗时但又不影响对客户端的响应的操作，就由后台其它线程来处理</font>。例如，持久化、对 AOF 的 rewrite、对失效连接的清理等。</p>\n<h2 id=\"多线程模型\"><a class=\"anchor\" href=\"#多线程模型\">#</a> 多线程模型</h2>\n<blockquote>\n<p>Redis 6.0 开始</p>\n</blockquote>\n<p><font color='red'>Redis 6.0 版本，才是真正意义上的多线程模型</font>。因为其 **<font color='red'>对于客户端请求的处理采用的是多线程模型</font>**。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231208211428194.png\" alt=\"image-20231208211428194\" /></p>\n<p>多线程 IO 模型中的<font color='red'>“多线程” 仅用于接受、解析客户端的请求，然后将解析出的请求写入到任务队列</font>。而 **<font color='red'>对具体任务（命令）的处理，仍是由主线程处理</font>**。这样做使得用户无需考虑线程安全问题，无需考虑事务控制，无需考虑像 LPUSH/LPOP 等命令的执行顺序问题。</p>\n<h2 id=\"优缺点总结\"><a class=\"anchor\" href=\"#优缺点总结\">#</a> 优缺点总结</h2>\n<p>单线程模型：</p>\n<ul>\n<li>优点：\n<ul>\n<li>可维护性高</li>\n<li>不存在并发读写情况，所以也就不存在执行顺序的不确定性，不存在线程切换开销，不存在死锁问题，不存在为了数据安全而进行的加锁 / 解锁<br />\n开销</li>\n</ul>\n</li>\n<li>缺点：\n<ul>\n<li>性能低</li>\n<li>会形成处理器浪费（单线程只能使用一个处理器）</li>\n</ul>\n</li>\n</ul>\n<p>多线程模型：</p>\n<ul>\n<li>优点：\n<ul>\n<li>结合了多线程与单线程的优点，避开了它们的所有不足</li>\n</ul>\n</li>\n<li>缺点：\n<ul>\n<li>非是一个真正意义上的 “多线程”，因为真正处理 “任务” 的线程仍是单线程。所以，其对性能也是有些影响的。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"redis-60-之前为什么不使用多线程\"><a class=\"anchor\" href=\"#redis-60-之前为什么不使用多线程\">#</a> Redis 6.0 之前为什么不使用多线程？</h2>\n<p>虽然说 Redis 是单线程模型，但是实际上，<strong>Redis 在 4.0 之后的版本中就已经加入了对多线程的支持。</strong></p>\n<p>不过，<font color='red'>Redis 4.0 增加的多线程主要是针对一些大键值对的删除操作的命令</font>，使用这些命令就会使用主线程之外的其他线程来 “异步处理”。</p>\n<p>为此，Redis 4.0 之后新增了 <code>UNLINK</code> （可以看作是  <code>DEL</code>  的异步版本）、 <code>FLUSHALL ASYNC</code> （清空所有数据库的所有 key，不仅仅是当前  <code>SELECT</code>  的数据库）、 <code>FLUSHDB ASYNC</code> （清空当前  <code>SELECT</code>  数据库中的所有 key）等异步命令。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/redis4.0-more-thread.png\" alt=\"redis4.0 more thread\" /></p>\n<center>redis4.0 more thread</center>\n<p>大体上来说，Redis 6.0 之前主要还是单线程处理。</p>\n<p><strong>那 Redis6.0 之前为什么不使用多线程？</strong> 我觉得主要原因有 3 点：</p>\n<ul>\n<li><font color='red'>单线程编程容易并且更容易维护</font>；</li>\n<li>Redis 的性能瓶颈不在 CPU ，主要在内存和网络；</li>\n<li><font color='red'>多线程就会存在死锁、线程上下文切换等问题</font>，甚至会影响性能。</li>\n</ul>\n<p>相关阅读：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kcmF2ZW5lc3MubWUvd2h5cy10aGUtZGVzaWduLXJlZGlzLXNpbmdsZS10aHJlYWQv\">为什么 Redis 选择单线程模型？</span></p>\n<h2 id=\"redis60-之后为何引入了多线程\"><a class=\"anchor\" href=\"#redis60-之后为何引入了多线程\">#</a> Redis6.0 之后为何引入了多线程？</h2>\n<p><strong><font color='red'>Redis6.0 引入多线程主要是为了提高网络 IO 读写性能</font></strong>，因为这个算是 Redis 中的一个性能瓶颈（Redis 的瓶颈主要受限于内存和网络）。</p>\n<p>虽然，Redis6.0 引入了多线程，<font color='red'>但是 Redis 的多线程只是在网络数据的读写这类耗时操作上使用了，执行命令仍然是单线程顺序执行</font>。因此，你也不需要担心线程安全问题。</p>\n<p><font color='red'>Redis6.0 的多线程默认是禁用的，只使用主线程</font>。如需开启需要设置 IO 线程数 &gt; 1，需要修改 redis 配置文件  <code>redis.conf</code> ：</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>io-threads <span class=\"token number\">4</span> <span class=\"token comment\">#设置 1 的话只会开启主线程，官网建议 4 核的机器建议设置为 2 或 3 个线程，8 核的建议设置为 6 个线程</span></pre></td></tr></table></figure><p>另外：</p>\n<ul>\n<li>io-threads 的个数一旦设置，不能通过 config 动态设置。</li>\n<li>当设置 ssl 后，io-threads 将不工作。</li>\n</ul>\n<p>开启多线程后，默认只会使用多线程进行 IO 写入 writes，即发送数据给客户端，如果需要开启多线程 IO 读取 reads，同样需要修改 redis 配置文件  <code>redis.conf</code>  :</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>io-threads-do-reads <span class=\"token function\">yes</span></pre></td></tr></table></figure><p>但是 **<font color='red'>官网描述开启多线程读并不能有太大提升，因此一般情况下并不建议开启</font>**。</p>\n<p>相关阅读：</p>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvRlp1M2Fjd0s2enJDQlpRXzNIb1Vndw==\">Redis 6.0 新特性 - 多线程连环 13 问！</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAzOTIyMzY5Ng==\">Redis 多线程网络模型全面揭秘</span>（推荐）</li>\n</ul>\n<h2 id=\"redis-后台线程了解吗\"><a class=\"anchor\" href=\"#redis-后台线程了解吗\">#</a> Redis 后台线程了解吗？</h2>\n<p>我们虽然经常说 Redis 是单线程模型（主要逻辑是单线程完成的），但实际还有一些后台线程用于执行一些比较耗时的操作：</p>\n<ul>\n<li><code>bio_close_file</code>  后台线程：释放 AOF / RDB 等过程中产生的临时文件资源。</li>\n<li><code>bio_aof_fsync</code>  后台线程：调用  <code>fsync</code>  函数将系统内核缓冲区还未同步到到磁盘的数据强制刷到磁盘（ AOF 文件）。</li>\n<li><code>bio_lazy_free</code>  后台线程：释放大对象（已删除）占用的内存空间。</li>\n</ul>\n<p>在  <code>bio.h</code>  文件中有定义（Redis 6.0 版本，源码地址：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3JlZGlzL3JlZGlzL2Jsb2IvNi4wL3NyYy9iaW8uaCVFRiVCQyU4OSVFRiVCQyU5QQ==\">https://github.com/redis/redis/blob/6.0/src/bio.h）：</span></p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>#ifndef __BIO_H</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>#define __BIO_H</pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token comment\">/* Exported API */</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">bioInit</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">bioCreateBackgroundJob</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> type<span class=\"token punctuation\">,</span> <span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>arg1<span class=\"token punctuation\">,</span> <span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>arg2<span class=\"token punctuation\">,</span> <span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>arg3<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>unsigned <span class=\"token keyword\">long</span> <span class=\"token keyword\">long</span> <span class=\"token function\">bioPendingJobsOfType</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> type<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>unsigned <span class=\"token keyword\">long</span> <span class=\"token keyword\">long</span> <span class=\"token function\">bioWaitStepOfType</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> type<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>time_t <span class=\"token function\">bioOlderJobOfType</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> type<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">bioKillThreads</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token comment\">/* Background job opcodes */</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>#define <span class=\"token constant\">BIO_CLOSE_FILE</span>    <span class=\"token number\">0</span> <span class=\"token comment\">/* Deferred close(2) syscall. */</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>#define <span class=\"token constant\">BIO_AOF_FSYNC</span>     <span class=\"token number\">1</span> <span class=\"token comment\">/* Deferred AOF fsync. */</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>#define <span class=\"token constant\">BIO_LAZY_FREE</span>     <span class=\"token number\">2</span> <span class=\"token comment\">/* Deferred objects freeing. */</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>#define <span class=\"token constant\">BIO_NUM_OPS</span>       <span class=\"token number\">3</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>#endif</pre></td></tr></table></figure><p>关于 Redis 后台线程的详细介绍可以查看 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC83MTAyNzgwNDM0NzM5NjI2MDE0\">Redis 6.0 后台线程有哪些？</span> 这篇就文章。</p>\n<h1 id=\"redis-内存管理缓存数据管理\"><a class=\"anchor\" href=\"#redis-内存管理缓存数据管理\">#</a> Redis 内存管理（缓存数据管理）</h1>\n<h2 id=\"redis-给缓存数据设置过期时间的意义\"><a class=\"anchor\" href=\"#redis-给缓存数据设置过期时间的意义\">#</a> Redis 给缓存数据设置过期时间的意义</h2>\n<p><font color='red'>因为内存是有限的</font>，如果缓存中的所有数据都是一直保存的话，分分钟直接 Out of memory。</p>\n<p>Redis 自带了给缓存数据设置过期时间的功能，比如：</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token number\">127.0</span>.0.1:637<span class=\"token operator\"><span class=\"token file-descriptor important\">9</span>></span> expire key <span class=\"token number\">60</span> <span class=\"token comment\"># 数据在 60s 后过期</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">(</span>integer<span class=\"token punctuation\">)</span> <span class=\"token number\">1</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token number\">127.0</span>.0.1:637<span class=\"token operator\"><span class=\"token file-descriptor important\">9</span>></span> setex key <span class=\"token number\">60</span> value <span class=\"token comment\"># 数据在 60s 后过期 (setex:[set] + [ex] pire)</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>OK</pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token number\">127.0</span>.0.1:637<span class=\"token operator\"><span class=\"token file-descriptor important\">9</span>></span> ttl key <span class=\"token comment\"># 查看数据还有多久过期</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token punctuation\">(</span>integer<span class=\"token punctuation\">)</span> <span class=\"token number\">56</span></pre></td></tr></table></figure><blockquote>\n<p>注意：<strong>Redis 中除了字符串类型有自己独有设置过期时间的命令  <code>setex</code>  外，其他方法都需要依靠  <code>expire</code>  命令来设置过期时间。另外， <code>persist</code>  命令可以移除一个键的过期时间。</strong></p>\n</blockquote>\n<p><strong>过期时间除了<font color='red'>有助于缓解内存的消耗</font>，还有什么其他用么？</strong></p>\n<p>很多时候，我们的 **<font color='red'>业务场景就是需要某个数据只在某一时间段内存在</font>**，比如我们的短信验证码可能只在 1 分钟内有效，用户登录的 Token 可能只在 1 天内有效。</p>\n<p>如果使用传统的数据库来处理的话，一般都是自己判断过期，这样更麻烦并且性能要差很多。</p>\n<h2 id=\"过期数据的判断\"><a class=\"anchor\" href=\"#过期数据的判断\">#</a> 过期数据的判断</h2>\n<p>Redis 通过一个叫做 **<font color='cornflowerblue'>过期字典</font>**（可以看作是 hash 表）来保存数据过期的时间。过期字典的<font color='red'>键指向 Redis 数据库中的某个 key (键)</font>，过期字典的<font color='red'>值是一个 long long 类型的整数</font>，这个整数保存了 key 所指向的数据库键的过期时间（毫秒精度的 UNIX 时间戳）。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/redis-expired-dictionary.png\" alt=\"redis过期字典\" /></p>\n<center>redis过期字典</center>\n<p>过期字典是存储在  <code>redisDb</code>  这个结构里的：</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">typedef</span> <span class=\"token keyword\">struct</span> <span class=\"token class-name\">redisDb</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    dict <span class=\"token operator\">*</span>dict<span class=\"token punctuation\">;</span>     <span class=\"token comment\">// 数据库键空间，保存着数据库中所有键值对</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    dict <span class=\"token operator\">*</span>expires   <span class=\"token comment\">// 过期字典，保存着键的过期时间</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">&#125;</span> redisDb<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h2 id=\"过期的数据的删除策略\"><a class=\"anchor\" href=\"#过期的数据的删除策略\">#</a> 过期的数据的删除策略</h2>\n<p>如果假设你设置了一批 key 只能存活 1 分钟，那么 1 分钟后，Redis 是怎么对这批 key 进行删除的呢？</p>\n<p>常用的过期数据的删除策略就两个（重要！自己造缓存轮子的时候需要格外考虑的东西）：</p>\n<ol>\n<li><strong><font color='cornflowerblue'>惰性删除</font></strong>：<font color='red'>只会在取出 key 的时候才对数据进行过期检查</font>。这样对 CPU 最友好，但是可能会造成太多过期 key 没有被删除。</li>\n<li><strong><font color='cornflowerblue'>定期删除</font></strong>：<font color='red'>每隔一段时间抽取一批 key 执行删除过期 key 操作</font>。并且，Redis 底层会通过限制删除操作执行的时长和频率来减少删除操作对 CPU 时间的影响。</li>\n</ol>\n<p>定期删除对内存更加友好，惰性删除对 CPU 更加友好。两者各有千秋，所以 Redis 采用的是 <strong><font color='cornflowerblue'>定期删除 + 惰性删除</font></strong> 。</p>\n<p>但是，仅仅通过给 key 设置过期时间还是有问题的。因为还是<font color='red'>可能存在定期删除和惰性删除漏掉了很多过期 key 的情况</font>。这样就导致大量过期 key 堆积在内存里，然后就 Out of memory 了。</p>\n<p>怎么解决这个问题呢？答案就是：<strong><font color='#B32015'>Redis 内存淘汰机制</font></strong>。</p>\n<h2 id=\"redis-内存淘汰机制\"><a class=\"anchor\" href=\"#redis-内存淘汰机制\">#</a> <mark>🌟Redis 内存淘汰机制</mark></h2>\n<blockquote>\n<p>相关问题：MySQL 里有 2000w 数据，Redis 中只存 20w 的数据，<font color='red'>如何保证 Redis 中的数据都是热点数据？</font></p>\n</blockquote>\n<p>Redis 提供 6 种数据淘汰策略：</p>\n<ol>\n<li><strong>volatile-lru（least recently used）</strong>：从<u>已设置过期时间的数据集</u>（ <code>server.db[i].expires</code> ）中挑选<font color='red'>最近最少使用的</font>数据淘汰。</li>\n<li><strong>volatile-ttl</strong>：从<u>已设置过期时间的数据集</u>（ <code>server.db[i].expires</code> ）中挑选<font color='red'>将要过期的</font>数据淘汰。</li>\n<li><strong>volatile-random</strong>：从<u>已设置过期时间的数据集</u>（ <code>server.db[i].expires</code> ）中<font color='red'>任意选择</font>数据淘汰。</li>\n<li><strong>allkeys-lru（least recently used）</strong>：当内存不足以容纳新写入数据时，在<u>键空间中</u>，移除<font color='red'>最近最少使用的</font> key（这个是<font color='gree'>最常用的</font>）。</li>\n<li><strong>allkeys-random</strong>：从数据集（ <code>server.db[i].dict</code> ）中<font color='red'>任意选择</font>数据淘汰。</li>\n<li><strong>no-eviction</strong>：<font color='red'>禁止驱逐数据</font>，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！</li>\n</ol>\n<p>Redis 4.0 版本后增加以下两种：</p>\n<ol start=\"7\">\n<li>\n<p><strong>volatile-lfu（least frequently used）</strong>：从<u>已设置过期时间的数据集</u>（ <code>server.db[i].expires</code> ）中挑选<font color='red'>最不经常使用的</font>数据淘汰。</p>\n</li>\n<li>\n<p><strong>allkeys-lfu（least frequently used）</strong>：当内存不足以容纳新写入数据时，在<u>键空间中</u>，移除<font color='red'>最不经常使用的</font> key。</p>\n</li>\n</ol>\n<h1 id=\"redis-事务\"><a class=\"anchor\" href=\"#redis-事务\">#</a> Redis 事务</h1>\n<h2 id=\"简介\"><a class=\"anchor\" href=\"#简介\">#</a> 简介</h2>\n<p>Redis 的事务的本质是 **<font color='red'>一组命令的批处理</font>**。这组命令在执行过程中会被<font color='red'>按顺序、一次性、串行化</font>全部执行完毕，只要没有出现语法错误，这组命令在执行期间是<font color='red'>不会被中断（其他命令无法插入）</font>。</p>\n<h2 id=\"常用命令\"><a class=\"anchor\" href=\"#常用命令\">#</a> 常用命令</h2>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>描述</th>\n<th>返回值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>MULTI</code></td>\n<td><font color='red'>标记一个事务块的开始</font>。随后的一系列指令将在执行 <code>EXEC</code>  时作为一个原子执行。</td>\n<td>OK</td>\n</tr>\n<tr>\n<td><code>WATCH key [key ...]</code></td>\n<td><font color='red'>监视若干个 key</font>，如果在事务执行前这些 key 发生改动，那么事务将被打断。在事务中有条件的执行（<font color='red'>乐观锁</font>）。</td>\n<td>OK</td>\n</tr>\n<tr>\n<td><code>EXEC</code></td>\n<td><font color='red'>执行事务块中所有在排队等待的指令</font>，并将链接状态恢复到正常。<br/>当使用 <code>WATCH</code>  时，只有当被监视的键没有被修改，且允许检查设定机制时， <code>EXEC</code>  会被执行。</td>\n<td>每个元素与原子事务中的指令一一对应。<br/>使用 <code>WATCH</code>  时，如果被终止， <code>EXEC</code>  则返回一个空的应答集合。</td>\n</tr>\n<tr>\n<td><code>UNWATCH </code></td>\n<td><font color='red'>释放所有被 <code>WATCH</code>  命令监视的 key</font><br/>如果执行 <code>EXEC</code>  或者 <code>DISCARD</code> ，则不需要手动执行该命令。</td>\n<td>OK</td>\n</tr>\n<tr>\n<td><code>DISCARD</code></td>\n<td><font color='red'>取消事务，放弃执行事务块中的所有指令</font>。<br/>同时，<font color='red'>释放所有被 <code>WATCH</code>  命令监视的 key</font>。</td>\n<td>OK</td>\n</tr>\n</tbody>\n</table>\n<p>Redis 可以通过  <code>MULTI</code> ， <code>EXEC</code> ， <code>DISCARD</code>  和  <code>WATCH</code>  等命令来实现事务 (Transaction) 功能。</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token operator\">></span> MULTI</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>OK</pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token operator\">></span> SET PROJECT <span class=\"token string\">\"JavaGuide\"</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>QUEUED</pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token operator\">></span> GET PROJECT</pre></td></tr><tr><td data-num=\"6\"></td><td><pre>QUEUED</pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token operator\">></span> EXEC</pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> OK</pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token string\">\"JavaGuide\"</span></pre></td></tr></table></figure><p><a href=\"https://redis.io/commands/multi\"> <code>MULTI</code> </a> 命令后可以输入多个命令，Redis 不会立即执行这些命令，而是将它们放到队列，当调用了 <a href=\"https://redis.io/commands/exec\"> <code>EXEC</code> </a> 命令后，再执行所有的命令。</p>\n<p>这个过程是这样的：</p>\n<ol>\n<li>开始事务（ <code>MULTI</code> ）；</li>\n<li>命令入队（批量操作 Redis 的命令，先进先出（FIFO）的顺序执行）；</li>\n<li>执行事务（ <code>EXEC</code> ）。</li>\n</ol>\n<p>你也可以通过 <a href=\"https://redis.io/commands/discard\"> <code>DISCARD</code> </a> 命令取消一个事务，它会清空事务队列中保存的所有命令。</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token operator\">></span> MULTI</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>OK</pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token operator\">></span> SET PROJECT <span class=\"token string\">\"JavaGuide\"</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>QUEUED</pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token operator\">></span> GET PROJECT</pre></td></tr><tr><td data-num=\"6\"></td><td><pre>QUEUED</pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token operator\">></span> DISCARD</pre></td></tr><tr><td data-num=\"8\"></td><td><pre>OK</pre></td></tr></table></figure><p>你可以通过 <a href=\"https://redis.io/commands/watch\"> <code>WATCH</code> </a> 命令监听指定的 Key，当调用  <code>EXEC</code>  命令执行事务时，如果一个被  <code>WATCH</code>  命令监视的 Key 被 <strong>其他客户端 / Session</strong> 修改的话，整个事务都不会被执行。</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># 客户端 1</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token operator\">></span> SET PROJECT <span class=\"token string\">\"RustGuide\"</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>OK</pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token operator\">></span> WATCH PROJECT</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>OK</pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token operator\">></span> MULTI</pre></td></tr><tr><td data-num=\"7\"></td><td><pre>OK</pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token operator\">></span> SET PROJECT <span class=\"token string\">\"JavaGuide\"</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>QUEUED</pre></td></tr><tr><td data-num=\"10\"></td><td><pre></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token comment\"># 客户端 2</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token comment\"># 在客户端 1 执行 EXEC 命令提交事务之前修改 PROJECT 的值</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token operator\">></span> SET PROJECT <span class=\"token string\">\"GoGuide\"</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre></pre></td></tr><tr><td data-num=\"15\"></td><td><pre><span class=\"token comment\"># 客户端 1</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre><span class=\"token comment\"># 修改失败，因为 PROJECT 的值被客户端 2 修改了</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre><span class=\"token operator\">></span> EXEC</pre></td></tr><tr><td data-num=\"18\"></td><td><pre><span class=\"token punctuation\">(</span>nil<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre><span class=\"token operator\">></span> GET PROJECT</pre></td></tr><tr><td data-num=\"20\"></td><td><pre><span class=\"token string\">\"GoGuide\"</span></pre></td></tr></table></figure><p>不过，如果 <strong>WATCH</strong> 与 <strong>事务</strong> 在同一个 Session 里，并且被 <strong>WATCH</strong> 监视的 Key 被修改的操作发生在事务内部，这个事务是可以被执行成功的（相关 issue：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL1NuYWlsY2xpbWIvSmF2YUd1aWRlL2lzc3Vlcy8xNzE0\">WATCH 命令碰到 MULTI 命令时的不同效果</span>）。</p>\n<p>事务内部修改 WATCH 监视的 Key：</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token operator\">></span> SET PROJECT <span class=\"token string\">\"JavaGuide\"</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>OK</pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token operator\">></span> WATCH PROJECT</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>OK</pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token operator\">></span> MULTI</pre></td></tr><tr><td data-num=\"6\"></td><td><pre>OK</pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token operator\">></span> SET PROJECT <span class=\"token string\">\"JavaGuide1\"</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>QUEUED</pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token operator\">></span> SET PROJECT <span class=\"token string\">\"JavaGuide2\"</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>QUEUED</pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token operator\">></span> SET PROJECT <span class=\"token string\">\"JavaGuide3\"</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>QUEUED</pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token operator\">></span> EXEC</pre></td></tr><tr><td data-num=\"14\"></td><td><pre><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> OK</pre></td></tr><tr><td data-num=\"15\"></td><td><pre><span class=\"token number\">2</span><span class=\"token punctuation\">)</span> OK</pre></td></tr><tr><td data-num=\"16\"></td><td><pre><span class=\"token number\">3</span><span class=\"token punctuation\">)</span> OK</pre></td></tr><tr><td data-num=\"17\"></td><td><pre><span class=\"token number\">127.0</span>.0.1:637<span class=\"token operator\"><span class=\"token file-descriptor important\">9</span>></span> GET PROJECT</pre></td></tr><tr><td data-num=\"18\"></td><td><pre><span class=\"token string\">\"JavaGuide3\"</span></pre></td></tr></table></figure><p>事务外部修改 WATCH 监视的 Key：</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token operator\">></span> SET PROJECT <span class=\"token string\">\"JavaGuide\"</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>OK</pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token operator\">></span> WATCH PROJECT</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>OK</pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token operator\">></span> SET PROJECT <span class=\"token string\">\"JavaGuide2\"</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>OK</pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token operator\">></span> MULTI</pre></td></tr><tr><td data-num=\"8\"></td><td><pre>OK</pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token operator\">></span> GET <span class=\"token environment constant\">USER</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>QUEUED</pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token operator\">></span> EXEC</pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token punctuation\">(</span>nil<span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>Redis 官网相关介绍 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9yZWRpcy5pby90b3BpY3MvdHJhbnNhY3Rpb25z\">https://redis.io/topics/transactions</span> 如下：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/redis-transactions.png\" alt=\"Redis 事务\" /></p>\n<h2 id=\"特性\"><a class=\"anchor\" href=\"#特性\">#</a> 特性</h2>\n<blockquote>\n<p>Redis 的事务和我们平时理解的关系型数据库的事务不同。我们知道事务具有四大特性：</p>\n<ol>\n<li>** 原子性（Atomicity）：** 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成（commit），要么完全不起作用（rollback）；</li>\n<li>** 一致性（Consistency）：** 执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的；</li>\n<li>** 隔离性（Isolation）：** 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</li>\n<li>** 持久性（Durability）：** 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li>\n</ol>\n</blockquote>\n<p><strong><font color='red'>Redis 事务仅保证了数据的一致性（C），不具有像 DBMS 一样的 ACID 特性</font></strong>。</p>\n<ul>\n<li>这组命令中的<font color='red'>某些命令的执行失败不会影响其它命令的执行，不会引发回滚，因此不具备原子性（A）</font>。</li>\n<li>这组命令<font color='red'>仅通过<strong>乐观锁机制</strong>实现了简单的隔离性</font>，没有复杂的隔离级别（I）。</li>\n<li>这组命令的<font color='red'>执行结果是被写入到内存的，是否持久（D）取决于 Redis 的持久化策略，与事务无关</font>。而且，Redis 的持久化策略也存在数据丢失的问题，更加没法保证持久性。</li>\n</ul>\n<h3 id=\"不具备原子性a\"><a class=\"anchor\" href=\"#不具备原子性a\">#</a> 不具备原子性（A）</h3>\n<p>Redis 事务在运行错误的情况下，除了执行过程中出现错误的命令外，其他命令都能正常执行。并且，<font color='red'>Redis 事务是不支持回滚（roll back）操作的</font>。因此，Redis 事务其实是不满足原子性的。</p>\n<p>Redis 官网也解释了自己为啥不支持回滚。简单来说就是<font color='red'> Redis 开发者们觉得没必要支持回滚，这样更简单便捷并且性能更好</font>。Redis 开发者觉得即使命令执行错误也应该在开发过程中就被发现而不是生产过程中。</p>\n<h3 id=\"实现了简单的隔离性i\"><a class=\"anchor\" href=\"#实现了简单的隔离性i\">#</a> 实现了简单的隔离性（I）</h3>\n<p>从 Redis 2.2 开始，允许以<font color='red'>乐观锁</font>的形式为 Redis 事务操作提供额外保证，其方式与  <code>check-and-set</code> （CAS）操作非常相似。稍后将对此进行记录，具体可见<a href=\"#%E9%9A%94%E7%A6%BB%E6%9C%BA%E5%88%B6\">隔离机制</a>。</p>\n<h3 id=\"无法保证持久性d\"><a class=\"anchor\" href=\"#无法保证持久性d\">#</a> 无法保证持久性（D）</h3>\n<p>Redis 不同于 Memcached 的很重要一点就是，Redis 支持持久化，而且支持 3 种持久化方式:</p>\n<ul>\n<li>快照（snapshotting，RDB）</li>\n<li>只追加文件（append-only file, AOF）</li>\n<li>RDB 和 AOF 的混合持久化 (Redis 4.0 新增)</li>\n</ul>\n<p>与 RDB 持久化相比，AOF 持久化的实时性更好。在 Redis 的配置文件中存在三种不同的 AOF 持久化方式（  <code>fsync</code>  策略），它们分别是：</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>appendfsync always    <span class=\"token comment\">#每次有数据修改发生时都会调用 fsync 函数同步 AOF 文件，fsync 完成后线程返回，这样会严重降低 Redis 的速度</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>appendfsync everysec  <span class=\"token comment\">#每秒钟调用 fsync 函数同步一次 AOF 文件</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>appendfsync no        <span class=\"token comment\">#让操作系统决定何时进行同步，一般为 30 秒一次</span></pre></td></tr></table></figure><p><font color='red'>AOF 持久化的  <code>fsync</code>  策略为 no、everysec 时都会存在数据丢失的情况</font>。always 下可以基本是可以满足持久性要求的，但性能太差，实际开发过程中不会使用。</p>\n<p>因此，Redis 事务的持久性也是没办法保证的。</p>\n<h2 id=\"异常处理\"><a class=\"anchor\" href=\"#异常处理\">#</a> 异常处理</h2>\n<h3 id=\"语法错误\"><a class=\"anchor\" href=\"#语法错误\">#</a> 语法错误</h3>\n<p><font color='red'>当事务中的命令出现语法错误时，整个事务在  <code>exec</code>  执行时会被取消</font>。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231209124406832.png\" alt=\"image-20231209124406832\" /></p>\n<p>exec 的提示是 exec 被忽略，事务被取消，因为之前的错误。</p>\n<p>此时访问 age 的值，发现其仍为 19，并没有变为事务中设置的 20。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231209124451759.png\" alt=\"image-20231209124451759\" /></p>\n<h3 id=\"执行异常\"><a class=\"anchor\" href=\"#执行异常\">#</a> 执行异常</h3>\n<p><font color='red'>如果事务中的命令没有语法错误，但在执行过程中出现异常，该异常不会影响其它命令的执行</font>。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231209124658817.png\" alt=\"image-20231209124658817\" /></p>\n<p>以上事务中第 2 条命令在执行时出现异常。因为 score 并非是整型，无法被增加 20 的操作。但该异常并不会影响其前后命令的正确执行。查看 score 与 name 的值，发现是执行成功的结果。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231209124800203.png\" alt=\"image-20231209124800203\" /></p>\n<h2 id=\"隔离机制\"><a class=\"anchor\" href=\"#隔离机制\">#</a> 隔离机制</h2>\n<h3 id=\"为什么需要隔离机制\"><a class=\"anchor\" href=\"#为什么需要隔离机制\">#</a> 为什么需要隔离机制</h3>\n<p>在并发场景下可能会出现多个客户端对同一个数据进行修改的情况。</p>\n<p>例如：有两个客户端 C 左与 C 右， C 左需要申请 40 个资源， C 右需要申请 30 个资源。它们首先查看了当前拥有的资源数量，即 resources 的值。它们查看到的都是 50，都感觉资源数量可以满足自己的需求，于是修改资源数量，以占有资源。但结果却是资源出现了 “超卖” 情况。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231209123019238.png\" alt=\"image-20231209123019238\" /></p>\n<p>为了解决这种情况，Redis 事务通过 **<font color='#B32015'>乐观锁机制</font>** 实现了多线程下的执行隔离。</p>\n<h3 id=\"隔离的实现\"><a class=\"anchor\" href=\"#隔离的实现\">#</a> 隔离的实现</h3>\n<p>Redis 通过  <code>watch</code>  命令再配合事务实现了多线程下的执行隔离。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231209123108530.png\" alt=\"image-20231209123108530\" /></p>\n<p>以上两个客户端执行的时间顺序为：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231209123147370.png\" alt=\"image-20231209123147370\" /></p>\n<p>当 C 左客户端在  <code>exec</code>  事务前发现其  <code>watch</code>  的数据发生了改动，则会打断事务执行。</p>\n<h3 id=\"实现原理\"><a class=\"anchor\" href=\"#实现原理\">#</a> <mark>🌟实现原理</mark></h3>\n<p>其内部的执行过程如下：</p>\n<ol>\n<li>\n<p>当某一客户端对 key 执行了  <code>watch</code>  后，系统就会为该 key 添加一个 <font color='gree'>version 乐观锁</font>，并初始化 version。例如初值为 1.0。</p>\n</li>\n<li>\n<p>此后客户端 C 左将对该 key 的修改语句写入到了事务命令队列中，虽未执行，但其将该 key 的 value 值与 version 进行了读取并保存到了当前客户端缓存。此时读取并保存的是 version 的初值 1.0。</p>\n</li>\n<li>\n<p>此后客户端 C 右对该 key 的值进行了修改，这个修改不仅修改了 key 的 value 本身，同时也增加了 version 的值，例如使其 version 变为了 2.0，并将该 version 记录到了该 key 信息中。</p>\n</li>\n<li>\n<p>此后客户端 C 左执行 exec，开始执行事务中的命令。不过，其在执行到对该 key 进行修改的命令时，该命令<font color='red'>首先对当前客户端缓存中保存的 version 值与当前 key 信息中的 version 值进行比较</font>。如果缓存 version 小于 key 的 version，则说明客户端缓存的 key 的 value 已经过时，该写操作如果执行可能会破坏数据的一致性。所以该写操作不执行。</p>\n</li>\n</ol>\n<h2 id=\"redis事务-vs-数据库事务\"><a class=\"anchor\" href=\"#redis事务-vs-数据库事务\">#</a> Redis 事务 v.s 数据库事务</h2>\n<ol>\n<li>\n<p><strong>单独的隔离操作</strong>：Redis 的事务仅仅是保证事务里的操作会被连续独占的执行，redis 命令执行是单线程架构，<font color='red'>在执行完事务内所有指令前，是不可能再去同时执行其他客户端的请求</font>的</p>\n</li>\n<li>\n<p><strong><font color='#B32015'>没有隔离级别的概念</font></strong>：因为<font color='red'>事务提交前任何指令都不会被实际执行</font>，也就不存在 “事务内的查询要看到事务里的更新，在事务外查询不能看到” 这种问题了</p>\n<blockquote>\n<p>因此<font color='red'>不存在 “三大读问题”：不可重复读、脏读、幻读</font></p>\n</blockquote>\n</li>\n<li>\n<p><strong><font color='#B32015'>不保证原子性</font></strong>：Redis 的事务 **<font color='red'>不保证原子性</font>**，也就是不保证所有指令同时成功或同时失败，只有决定是否开始执行全部指令的能力，<font color='red'>没有回滚能力</font></p>\n</li>\n<li>\n<p><strong>排它性</strong>：Redis 会保证一个事务内的命令依次执行，而<font color='red'>不会被其它命令插入</font></p>\n</li>\n</ol>\n<h2 id=\"如何解决-redis-事务的缺陷\"><a class=\"anchor\" href=\"#如何解决-redis-事务的缺陷\">#</a> 如何解决 Redis 事务的缺陷</h2>\n<p>Redis 从 2.6 版本开始支持执行 Lua 脚本，它的功能和事务非常类似。<font color='red'>可以利用 Lua 脚本来批量执行多条 Redis 命令</font>，这些 Redis 命令会被提交到 Redis 服务器一次性执行完成，大幅减小了网络开销。</p>\n<p>一段 Lua 脚本可以视作一条命令执行，<font color='red'>一段 Lua 脚本执行过程中不会有其他脚本或 Redis 命令同时执行</font>，保证了操作不会被其他指令插入或打扰。</p>\n<p>不过，<font color='red'>如果 Lua 脚本运行时出错并中途结束，出错之后的命令是不会被执行的</font>。并且，<font color='red'>出错之前执行的命令是无法被撤销的，无法实现类似关系型数据库执行失败可以回滚的那种原子性效果</font>。因此， 严格来说的话，<strong><font color='red'>通过 Lua 脚本来批量执行 Redis 命令实际也是不完全满足原子性的</font></strong>。</p>\n<p>如果想要让 Lua 脚本中的命令全部执行，必须保证语句语法和命令都是对的。</p>\n<p>另外，Redis 7.0 新增了 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9yZWRpcy5pby9kb2NzL21hbnVhbC9wcm9ncmFtbWFiaWxpdHkvZnVuY3Rpb25zLWludHJvLw==\">Redis functions</span> 特性，你可以将 Redis functions 看作是比 Lua 更强大的脚本。</p>\n<h1 id=\"redis-管道pipeline\"><a class=\"anchor\" href=\"#redis-管道pipeline\">#</a> Redis 管道（pipeline）</h1>\n<blockquote>\n<p>Redis 管道 与 Redis 事务 之间的关系，类似于雷锋与雷峰塔的关系，Java 与 JavaScript 的关系，<font color='red'>看上去相似，但实际没有任何关系！</font></p>\n</blockquote>\n<h2 id=\"引言\"><a class=\"anchor\" href=\"#引言\">#</a> 引言</h2>\n<p>如何优化命令频繁往返造成的性能瓶颈？</p>\n<p>Redis 是一种基于<font color='red'>客户端 - 服务端模型</font>以及请求 / 响应协议的 TCP 服务。一个请求会遵循以下步骤：</p>\n<ol>\n<li>\n<p><font color='red'>客户端向服务端发送命令</font>(分四步：发送命令→命令排队→命令执行→返回结果)，并监听 Socket 返回，通常<font color='red'>以<strong>阻塞模式</strong>等待服务端响应</font>。</p>\n</li>\n<li>\n<p><font color='red'>服务端处理命令，并将结果返回给客户端</font>。</p>\n</li>\n</ol>\n<p>上述两步的总耗时称为：<strong><font color='#B32015'>Round Trip Time（即 RTT，数据包往返于两端的时间)</font></strong>。</p>\n<blockquote>\n<p>如果同时需要执行大量的命令，那么就<font color='red'>要等待上一条命令应答后再执行</font>，这中间不仅仅多了 RTT（Round Time Trip），而且还频繁调用系统 IO，发送网络请求，同时需要 redis 调用多次 read () 和 write () 系统方法，系统方法会将数据从用户态转移到内核态，这样就会对进程上下文有比较大的影响了，<font color='red'>性能不太好</font>o(╥﹏╥)o</p>\n</blockquote>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230807140057973.png\" alt=\"image-20230807140057973\" /></p>\n<h2 id=\"简介-2\"><a class=\"anchor\" href=\"#简介-2\">#</a> 简介</h2>\n<blockquote>\n<p>通过 **<font color='red'>批处理 Redis 命令</font>** 来<font color='red'>优化往返时间 RTT</font></p>\n</blockquote>\n<p><strong>Redis 管道 (pipeline)</strong>：为了优化 RTT 往返时间，可以<font color='orange'>一次性打包发送多条命令</font>给服务端，而<font color='red'>无需等待对每个命令的响应</font>。等待服务端依次处理完完毕后，<font color='red'>通过一条响应一次性将结果返回</font>，通过减少客户端与 redis 的通信次数来实现降低往返延时时间。pipeline 的<font color='orange'>实现原理是队列</font>，先进先出特性就保证数据的顺序性。</p>\n<blockquote>\n<p>是<strong>一种批处理命令的变种优化措施</strong>，类似 Redis 原生的批命令（例如 mget 和 mset）。</p>\n</blockquote>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/1ffba84802bd4732b4a390d0aade8020.png\" alt=\"img\" /></p>\n<h2 id=\"案例\"><a class=\"anchor\" href=\"#案例\">#</a> 案例</h2>\n<ol>\n<li>将欲执行的命令全部写到一个 txt 文件中</li>\n<li>将 txt 文件的内容传递给 Redis 的 pipe 参数</li>\n</ol>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230807140935362.png\" alt=\"image-20230807140935362\" /></p>\n<h2 id=\"总结\"><a class=\"anchor\" href=\"#总结\">#</a> 总结</h2>\n<h3 id=\"管道-vs-原生批量操作命令\"><a class=\"anchor\" href=\"#管道-vs-原生批量操作命令\">#</a> 管道 vs 原生批量操作命令</h3>\n<table>\n<thead>\n<tr>\n<th>管道</th>\n<th>原生批量命令</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><font color='red'>非原子性</font></td>\n<td>原子性</td>\n</tr>\n<tr>\n<td>支持批量执行不同命令</td>\n<td>一次只能执行一种命令</td>\n</tr>\n<tr>\n<td>服务端与客户端共同完成</td>\n<td>服务端实现</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"管道-vs-redis-事务\"><a class=\"anchor\" href=\"#管道-vs-redis-事务\">#</a> 管道 vs Redis 事务</h3>\n<table>\n<thead>\n<tr>\n<th>管道</th>\n<th>Redis 事务</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>非原子性，pipeline 之间可以<font color='red'>交错执行</font></td>\n<td><font color='red'>可视为原子操作，但不满足原子性</font>，虽然两个不同的事务不会同时运行</td>\n</tr>\n<tr>\n<td>一次性发送多条命令到服务端，请求次数更少</td>\n<td>需要逐条发送命令到服务端</td>\n</tr>\n<tr>\n<td><font color='red'>非阻塞</font></td>\n<td>会阻塞其他命令的执行</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"使用管道的注意事项\"><a class=\"anchor\" href=\"#使用管道的注意事项\">#</a> 使用管道的注意事项</h3>\n<ul>\n<li>\n<p>pipeline 缓冲的指令只是会依次执行，<font color='red'>不保证原子性，如果执行中指令发生异常，将会继续执行后续的指令</font></p>\n<blockquote>\n<p>与 Redis 事务发生命令的运行时异常类似，冤头债主，不会连坐</p>\n</blockquote>\n</li>\n<li>\n<p>使用 pipeline 组装的<font color='red'>命令个数不能太多</font>（例如 10k），不然数据量过大客户端阻塞的时间可能过久，同时<font color='red'>服务端此时也被迫回复一个队列答复，占用很多内存</font></p>\n</li>\n</ul>\n<h1 id=\"redis-性能优化\"><a class=\"anchor\" href=\"#redis-性能优化\">#</a> <mark>🌟Redis 性能优化</mark></h1>\n<p>除了下面介绍的内容之外，再推荐两篇不错的文章：</p>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3Mvbk5FdVl3ME5sWUdodUtLS0tvV2ZjUQ==\">你的 Redis 真的变慢了吗？性能优化如何做 - 阿里开发者</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9qYXZhZ3VpZGUuY24vZGF0YWJhc2UvcmVkaXMvcmVkaXMtY29tbW9uLWJsb2NraW5nLXByb2JsZW1zLXN1bW1hcnkuaHRtbA==\">Redis 常见阻塞原因总结 - JavaGuide</span></li>\n</ul>\n<h2 id=\"使用批量操作减少网络传输\"><a class=\"anchor\" href=\"#使用批量操作减少网络传输\">#</a> 使用批量操作减少网络传输</h2>\n<p>一个 Redis 命令的执行可以简化为以下 4 步：</p>\n<ol>\n<li>发送命令</li>\n<li>命令排队</li>\n<li>命令执行</li>\n<li>返回结果</li>\n</ol>\n<p>其中，第 1 步和第 4 步耗费时间之和称为 <strong>Round Trip Time (RTT, 往返时间)</strong> ，也就是数据在网络上传输的时间。</p>\n<p><strong><font color='red'>使用批量操作可以减少网络传输次数，进而有效减小网络开销，大幅减少 RTT</font></strong>。</p>\n<p>另外，除了能减少 RTT 之外，发送一次命令的 socket I/O 成本也比较高（涉及上下文切换，存在 <code>read()</code>  和 <code>write()</code>  系统调用），<font color='red'>批量操作还可以减少 socket I/O 成本</font>。这个在官方对 pipeline 的介绍中有提到：[<span class=\"exturl\" data-url=\"aHR0cHM6Ly9yZWRpcy5pby9kb2NzL21hbnVhbC9waXBlbGluaW5nLw==\">https://redis.io/docs/manual/pipelining/</span> 。</p>\n<h3 id=\"原生批量操作命令\"><a class=\"anchor\" href=\"#原生批量操作命令\">#</a> 原生批量操作命令</h3>\n<p>Redis 中有一些原生支持批量操作的命令，比如：</p>\n<ul>\n<li><code>MGET</code>  (获取一个或多个指定 key 的值)、 <code>MSET</code>  (设置一个或多个指定 key 的值)</li>\n<li><code>HMGET</code>  (获取指定哈希表中一个或者多个指定字段的值)、 <code>HMSET</code>  (同时将一个或多个 field-value 对设置到指定哈希表中)、</li>\n<li><code>SADD</code> （向指定集合添加一个或多个元素）</li>\n<li>……</li>\n</ul>\n<p>不过，在 Redis 官方提供的分片集群解决方案 <font color='red'>Redis Cluster 下，使用这些原生批量操作命令可能会存在一些小问题需要解决</font>。就比如说  <code>MGET</code>  无法保证所有的 key 都在同一个 <strong>hash slot</strong>（哈希槽）上， <code>MGET</code>  可能还是需要多次网络传输，原子操作也无法保证了。不过，相较于非批量操作，还是可以节省不少网络传输次数。</p>\n<p>整个步骤的简化版如下（通常由 Redis 客户端实现，无需我们自己再手动实现）：</p>\n<ol>\n<li>找到 key 对应的所有 hash slot；</li>\n<li>分别向对应的 Redis 节点发起  <code>MGET</code>  请求获取数据；</li>\n<li>等待所有请求执行结束，重新组装结果数据，保持跟入参 key 的顺序一致，然后返回结果。</li>\n</ol>\n<p>如果想要解决这个多次网络传输的问题，比较常用的办法是自己维护 key 与 slot 的关系。不过这样不太灵活，虽然带来了性能提升，但同样让系统复杂性提升。</p>\n<h3 id=\"管道pipeline\"><a class=\"anchor\" href=\"#管道pipeline\">#</a> 管道（pipeline）</h3>\n<blockquote>\n<p>参考前文 [Redis 管道](#Redis 管道（pipeline）)</p>\n</blockquote>\n<p>对于不支持批量操作的命令，我们<font color='red'>可以利用 <strong>pipeline（流水线)</strong> 将一批 Redis 命令封装成一组，这些 Redis 命令会被一次性提交到 Redis 服务器，只需要一次网络传输</font>。不过，需要注意控制一次批量操作的 <strong>元素个数</strong> (例如 500 以内，实际也和元素字节数有关)，避免网络传输的数据量过大。</p>\n<p>与 <code>MGET</code> 、 <code>MSET</code>  等原生批量操作命令一样，<font color='red'>pipeline 同样在 Redis Cluster 上使用会存在一些小问题</font>。原因类似，无法保证所有的 key 都在同一个 <strong>hash slot</strong>（哈希槽）上。如果想要使用的话，客户端需要自己维护 key 与 slot 的关系。</p>\n<p>[pipeline 与原生批量操作命令的区别](# 管道 vs 原生批量操作命令)</p>\n<p>[pipeline 与 Redis 事务的区别](# 管道 vs Redis 事务)</p>\n<p>另外，<font color='red'>pipeline 不适用于执行顺序有依赖关系的一批命令</font>。就比如说，你需要将前一个命令的结果给后续的命令使用，pipeline 就没办法满足你的需求了。对于这种需求，我们可以使用 <strong>Lua 脚本</strong> 。</p>\n<img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/redis-pipeline-vs-transaction.png\" alt=\"img\" style=\"zoom:67%;\" />\n<h3 id=\"lua-脚本\"><a class=\"anchor\" href=\"#lua-脚本\">#</a> Lua 脚本</h3>\n<p><font color='red'>Lua 脚本同样支持批量操作多条命令，一段 Lua 脚本可以视作一条命令执行，可以看作是 <strong>原子操作</strong> </font>。也就是说，一段 Lua 脚本执行过程中不会有其他脚本或 Redis 命令同时执行，保证了操作不会被其他指令插入或打扰，这是 pipeline 所不具备的。</p>\n<p>并且，<font color='red'>Lua 脚本中支持一些简单的逻辑处理</font>，比如使用命令读取值并在 Lua 脚本中进行处理，这同样是 pipeline 所不具备的。</p>\n<p>不过，Lua 脚本依然存在下面这些缺陷：</p>\n<ul>\n<li><font color='red'>如果 Lua 脚本运行时出错并中途结束，之后的操作不会进行，但是之前已经发生的写操作不会撤销</font>，所以即使使用了 Lua 脚本，也不能实现类似数据库回滚的原子性。</li>\n<li>Redis Cluster 下 Lua 脚本的原子操作也无法保证了，原因同样是无法保证所有的 key 都在同一个 <strong>hash slot</strong>（哈希槽）上。</li>\n</ul>\n<h2 id=\"大量-key-集中过期问题\"><a class=\"anchor\" href=\"#大量-key-集中过期问题\">#</a> 大量 key 集中过期问题</h2>\n<p>我在前面提到过：对于过期 key，Redis 采用的是 <font color='cornflowerblue'>定期删除 + 惰性删除</font> 策略。</p>\n<p>定期删除执行过程中，如果<font color='red'>突然遇到大量过期 key </font>的话，客户端请求必须等待定期清理过期 key 任务线程执行完成，因为这个这个<font color='red'>定期任务线程是在 Redis 主线程中执行的</font>。这就导致客户端请求没办法被及时处理，响应速度会比较慢。</p>\n<p>下面是两种常见的解决方法：</p>\n<ol>\n<li>给 key 设置 **<font color='red'>随机过期时间</font>**。</li>\n<li><strong><font color='red'>开启 lazy-free（惰性删除）</font></strong>。该特性是 Redis 4.0 开始引入的，指的是让 Redis <font color='red'>采用异步方式延迟释放 key 使用的内存，将该操作交给单独的子线程处理，避免阻塞主线程</font>。</li>\n</ol>\n<p>个人建议不管是否开启 lazy-free，我们都<font color='red'>尽量给 key 设置随机过期时间</font>。</p>\n<h2 id=\"bigkey大-key\"><a class=\"anchor\" href=\"#bigkey大-key\">#</a> <mark>🌟bigkey（大 Key）</mark></h2>\n<h3 id=\"bigkey-是什么\"><a class=\"anchor\" href=\"#bigkey-是什么\">#</a> bigkey 是什么</h3>\n<p>简单来说，如果 **<font color='red'>一个 key 对应的 value 所占用的内存比较大</font>**，那这个 key 就可以看作是 bigkey。具体多大才算大呢？有一个不是特别精确的参考标准：</p>\n<ul>\n<li><font color='red'>String 类型的 value 超过 1MB</font></li>\n<li><font color='red'>复合类型（List、Hash、Set、Sorted Set 等）的 value 包含的元素超过 5000 个</font>（不过，对于复合类型的 value 来说，不一定包含的元素越多，占用的内存就越多）。</li>\n</ul>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/bigkey-criterion.png\" alt=\"bigkey 判定标准\" /></p>\n<center>bigkey 判定标准</center>\n<h3 id=\"bigkey-怎么产生的\"><a class=\"anchor\" href=\"#bigkey-怎么产生的\">#</a> bigkey 怎么产生的</h3>\n<p>bigkey 通常是由于下面这些原因产生的：</p>\n<ul>\n<li>程序设计不当，比如直接使用 String 类型存储较大的文件对应的二进制数据。</li>\n<li>对于业务的数据规模考虑不周到，比如使用集合类型的时候没有考虑到数据量的快速增长。</li>\n<li><font color='red'>未及时清理垃圾数据</font>，比如哈希中冗余了大量的无用键值对。</li>\n</ul>\n<h3 id=\"bigkey-的危害\"><a class=\"anchor\" href=\"#bigkey-的危害\">#</a> bigkey 的危害</h3>\n<p>bigkey 除了<font color='red'>会消耗更多的内存空间和带宽，还会对性能造成比较大的影响</font>。</p>\n<p>在<a href=\"\"> Redis 常见阻塞原因总结</a>这篇文章中我们提到：大 key 还会造成阻塞问题。具体来说，主要体现在下面三个方面：</p>\n<ol>\n<li><font color='red'>客户端超时阻塞</font>：由于 Redis 执行命令是单线程处理，然后在操作大 key 时会比较耗时，那么就会阻塞 Redis，从客户端这一视角看，就是很久很久都没有响应。</li>\n<li><font color='red'>网络阻塞</font>：每次获取大 key 产生的网络流量较大，如果一个 key 的大小是 1 MB，每秒访问量为 1000，那么每秒会产生 1000MB 的流量，这对于普通千兆网卡的服务器来说是灾难性的。</li>\n<li><font color='red'>工作线程阻塞</font>：如果使用 del 删除大 key 时，会阻塞工作线程，这样就没办法处理后续的命令。</li>\n</ol>\n<p>大 key 造成的阻塞问题还会<font color='red'>进一步影响到主从同步和集群扩容</font>。</p>\n<p>综上，大 key 带来的潜在问题是非常多的，我们应该尽量避免 Redis 中存在 bigkey。</p>\n<h3 id=\"如何发现-bigkey\"><a class=\"anchor\" href=\"#如何发现-bigkey\">#</a> 如何发现 bigkey</h3>\n<p><strong><font color='#B32015'>1、使用 Redis 自带的 --bigkeys 参数来查找</font></strong></p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># redis-cli -p 6379 --bigkeys</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token comment\"># Scanning the entire keyspace to find biggest keys as well as</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token comment\"># average sizes per key type.  You can use -i 0.1 to sleep 0.1 sec</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token comment\"># per 100 SCAN commands (not usually needed).</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">[</span>00.00%<span class=\"token punctuation\">]</span> Biggest string found so far <span class=\"token string\">'\"ballcat:oauth:refresh_auth:f6cdb384-9a9d-4f2f-af01-dc3f28057c20\"'</span> with <span class=\"token number\">4437</span> bytes</pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token punctuation\">[</span>00.00%<span class=\"token punctuation\">]</span> Biggest list   found so far <span class=\"token string\">'\"my-list\"'</span> with <span class=\"token number\">17</span> items</pre></td></tr><tr><td data-num=\"9\"></td><td><pre></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>-------- summary -------</pre></td></tr><tr><td data-num=\"11\"></td><td><pre></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>Sampled <span class=\"token number\">5</span> keys <span class=\"token keyword\">in</span> the keyspace<span class=\"token operator\">!</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>Total key length <span class=\"token keyword\">in</span> bytes is <span class=\"token number\">264</span> <span class=\"token punctuation\">(</span>avg len <span class=\"token number\">52.80</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>Biggest   list found <span class=\"token string\">'\"my-list\"'</span> has <span class=\"token number\">17</span> items</pre></td></tr><tr><td data-num=\"16\"></td><td><pre>Biggest string found <span class=\"token string\">'\"ballcat:oauth:refresh_auth:f6cdb384-9a9d-4f2f-af01-dc3f28057c20\"'</span> has <span class=\"token number\">4437</span> bytes</pre></td></tr><tr><td data-num=\"17\"></td><td><pre></pre></td></tr><tr><td data-num=\"18\"></td><td><pre><span class=\"token number\">1</span> lists with <span class=\"token number\">17</span> items <span class=\"token punctuation\">(</span><span class=\"token number\">20.00</span>% of keys, avg size <span class=\"token number\">17.00</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre><span class=\"token number\">0</span> hashs with <span class=\"token number\">0</span> fields <span class=\"token punctuation\">(</span>00.00% of keys, avg size <span class=\"token number\">0.00</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre><span class=\"token number\">4</span> strings with <span class=\"token number\">4831</span> bytes <span class=\"token punctuation\">(</span><span class=\"token number\">80.00</span>% of keys, avg size <span class=\"token number\">1207.75</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre><span class=\"token number\">0</span> streams with <span class=\"token number\">0</span> entries <span class=\"token punctuation\">(</span>00.00% of keys, avg size <span class=\"token number\">0.00</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre><span class=\"token number\">0</span> sets with <span class=\"token number\">0</span> members <span class=\"token punctuation\">(</span>00.00% of keys, avg size <span class=\"token number\">0.00</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre><span class=\"token number\">0</span> zsets with <span class=\"token number\">0</span> members <span class=\"token punctuation\">(</span>00.00% of keys, avg size <span class=\"token number\">0.00</span></pre></td></tr></table></figure><p>从这个命令的运行结果，我们可以看出：这个命令<font color='red'>会扫描 (Scan) Redis 中的所有 key</font> ，会对 Redis 的性能有一点影响。并且，这种方式<font color='red'>只能找出每种数据结构 top 1 bigkey</font>（占用内存最大的 String 数据类型，包含元素最多的复合数据类型）。然而，一个 key 的元素多并不代表占用内存也多，需要我们根据具体的业务情况来进一步判断。</p>\n<p>在线上执行该命令时，为了降低对 Redis 的影响，<font color='red'>需要指定  <code>-i</code>  参数控制扫描的频率</font>。 <code>redis-cli -p 6379 --bigkeys -i 3</code>  表示扫描过程中每次扫描后休息的时间间隔为 3 秒。</p>\n<p><strong><font color='#B32015'>2、使用 Redis 自带的 SCAN 命令</font></strong></p>\n<p><code>SCAN</code>  命令可以按照一定的模式、数量返回匹配的 key。获取了 key 之后，可以利用  <code>STRLEN</code> 、 <code>HLEN</code> 、 <code>LLEN</code>  等命令返回其长度或成员数量。</p>\n<table>\n<thead>\n<tr>\n<th>数据结构</th>\n<th>命令</th>\n<th>复杂度</th>\n<th>结果（对应 key）</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>String</td>\n<td>STRLEN</td>\n<td>O(1)</td>\n<td>字符串值的长度</td>\n</tr>\n<tr>\n<td>Hash</td>\n<td>HLEN</td>\n<td>O(1)</td>\n<td>哈希表中字段的数量</td>\n</tr>\n<tr>\n<td>List</td>\n<td>LLEN</td>\n<td>O(1)</td>\n<td>列表元素数量</td>\n</tr>\n<tr>\n<td>Set</td>\n<td>SCARD</td>\n<td>O(1)</td>\n<td>集合元素数量</td>\n</tr>\n<tr>\n<td>Sorted Set</td>\n<td>ZCARD</td>\n<td>O(1)</td>\n<td>有序集合的元素数量</td>\n</tr>\n</tbody>\n</table>\n<p>对于集合类型还可以使用  <code>MEMORY USAGE</code>  命令（Redis 4.0+），这个命令会返回键值对占用的内存空间。</p>\n<p><strong><font color='#B32015'>3、借助开源工具分析 RDB 文件</font></strong></p>\n<p>通过分析 RDB 文件来找出 big key。这种方案的前提是你的 Redis 采用的是 RDB 持久化。</p>\n<p>网上有现成的代码 / 工具可以直接拿来使用：</p>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3NyaXBhdGhpa3Jpc2huYW4vcmVkaXMtcmRiLXRvb2xz\">redis-rdb-tools</span>：Python 语言写的用来分析 Redis 的 RDB 快照文件用的工具</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3dlaXlhbndlaTQxMi9yZGJfYmlna2V5cw==\">rdb_bigkeys</span> : Go 语言写的用来分析 Redis 的 RDB 快照文件用的工具，性能更好。</li>\n</ul>\n<p><strong><font color='#B32015'>4、借助公有云的 Redis 分析服务</font></strong></p>\n<p>如果你用的是公有云的 Redis 服务的话，可以看看其是否提供了 key 分析功能（一般都提供了）。</p>\n<p>这里以阿里云 Redis 为例说明，它<font color='red'>支持 bigkey 实时分析、发现</font>，文档地址：<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWxpYmFiYWNsb3VkLmNvbS9oZWxwL3poL2Fwc2FyYWRiLWZvci1yZWRpcy9sYXRlc3QvdXNlLXRoZS1yZWFsLXRpbWUta2V5LXN0YXRpc3RpY3MtZmVhdHVyZQ==\">https://www.alibabacloud.com/help/zh/apsaradb-for-redis/latest/use-the-real-time-key-statistics-feature</span> 。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/aliyun-key-analysis.png\" alt=\"阿里云Key分析\" /></p>\n<center>阿里云Key分析</center>\n<h3 id=\"如何处理-bigkey\"><a class=\"anchor\" href=\"#如何处理-bigkey\">#</a> 如何处理 bigkey</h3>\n<p>bigkey 的常见处理以及优化办法如下（这些方法可以配合起来使用）：</p>\n<ul>\n<li><strong><font color='#B32015'>分割 bigkey</font></strong>：将一个 bigkey 分割为多个小 key。例如，将一个含有上万字段数量的 Hash 按照一定策略（比如二次哈希）拆分为多个 Hash。</li>\n<li><strong><font color='#B32015'>手动清理</font></strong>：Redis 4.0+ 可以使用  <code>UNLINK</code>  命令来异步删除一个或多个指定的 key。Redis 4.0 以下可以考虑使用  <code>SCAN</code>  命令结合  <code>DEL</code>  命令来分批次删除。</li>\n<li><strong><font color='#B32015'>采用合适的数据结构</font></strong>：例如，文件二进制数据不使用 String 保存、使用 HyperLogLog 统计页面 UV、Bitmap 保存状态信息（0/1）。</li>\n<li><strong><font color='#B32015'>开启 lazy-free（惰性删除 / 延迟释放）</font></strong>：lazy-free 特性是 Redis 4.0 开始引入的，指的是让 Redis 采用异步方式延迟释放 key 使用的内存，将该操作交给单独的子线程处理，避免阻塞主线程。</li>\n</ul>\n<h2 id=\"hotkey热-key\"><a class=\"anchor\" href=\"#hotkey热-key\">#</a> hotkey（热 Key）</h2>\n<h3 id=\"hotkey-是什么\"><a class=\"anchor\" href=\"#hotkey-是什么\">#</a> hotkey 是什么</h3>\n<p>如果 **<font color='red'>一个 key 的访问次数比较多且明显多于其他 key</font>** ，那这个 key 就可以看作是 hotkey（热 Key）。例如在 Redis 实例的每秒处理请求达到 5000 次，而其中某个 key 的每秒访问量就高达 2000 次，那这个 key 就可以看作是 hotkey。</p>\n<p>hotkey 出现的原因主要是<font color='red'>某个热点数据访问量暴增</font>，如重大的热搜事件、参与秒杀的商品。</p>\n<h3 id=\"hotkey-的危害\"><a class=\"anchor\" href=\"#hotkey-的危害\">#</a> hotkey 的危害</h3>\n<p>处理 hotkey 会<font color='red'>占用大量的 CPU 和带宽，可能会影响 Redis 实例对其他请求的正常处理</font>。此外，如果突然访问 hotkey 的请求超出了 Redis 的处理能力，<font color='red'>Redis 就会直接宕机</font>。这种情况下，大量请求将落到后面的数据库上，<font color='red'>可能会导致数据库崩溃</font>。</p>\n<p>因此，hotkey 很可能成为系统性能的瓶颈点，需要单独对其进行优化，以确保系统的高可用性和稳定性。</p>\n<h3 id=\"如何发现-hotkey\"><a class=\"anchor\" href=\"#如何发现-hotkey\">#</a> 如何发现 hotkey</h3>\n<p><strong><font color='#B32015'>1、使用 Redis 自带的 --hotkeys 参数来查找</font></strong></p>\n<p>Redis 4.0.3 版本中新增了  <code>hotkeys</code>  参数，该参数<font color='red'>能够返回所有 key 的被访问次数</font>。</p>\n<p>使用该方案的前提条件是 Redis Server 的  <code>maxmemory-policy</code>  <font color='red'>参数设置为 LFU 算法</font>，不然就会出现如下所示的错误。</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># redis-cli -p 6379 --hotkeys</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token comment\"># Scanning the entire keyspace to find hot keys as well as</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token comment\"># average sizes per key type.  You can use -i 0.1 to sleep 0.1 sec</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token comment\"># per 100 SCAN commands (not usually needed).</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>Error: ERR An LFU maxmemory policy is not selected, access frequency not tracked. Please note that when switching between policies at runtime LRU and LFU data will take some <span class=\"token function\">time</span> to adjust.</pre></td></tr></table></figure><p>Redis 中有两种 LFU 算法：</p>\n<ol>\n<li><strong>volatile-lfu（least frequently used）</strong>：从<u>已设置过期时间的数据集</u>（ <code>server.db[i].expires</code> ）中挑选<font color='red'>最不经常使用的</font>数据淘汰。</li>\n<li><strong>allkeys-lfu（least frequently used）</strong>：当内存不足以容纳新写入数据时，在<u>键空间中</u>，移除<font color='red'>最不经常使用的</font> key。</li>\n</ol>\n<p>以下是配置文件  <code>redis.conf</code>  中的示例：</p>\n<figure class=\"highlight properties\"><figcaption data-lang=\".properties\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># 使用 volatile-lfu 策略</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token key attr-name\">maxmemory-policy</span> <span class=\"token value attr-value\">volatile-lfu</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token comment\"># 或者使用 allkeys-lfu 策略</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token key attr-name\">maxmemory-policy</span> <span class=\"token value attr-value\">allkeys-lfu</span></pre></td></tr></table></figure><p>需要注意的是， <code>hotkeys</code>  参数命令也会增加 Redis 实例的 CPU 和内存消耗（全局扫描），因此需要谨慎使用。</p>\n<p><strong><font color='#B32015'>2、使用 MONITOR 命令</font></strong></p>\n<p><code>MONITOR</code>  命令是 Redis 提供的一种实时查看 Redis 的所有操作的方式，可以用于<font color='red'>实时监控 Redis 实例的操作情况，包括读写、删除等操作</font>。</p>\n<p>由于该命令对 Redis 性能的影响比较大，<font color='red'>因此禁止长时间开启</font>  <code>MONITOR</code> （生产环境中建议谨慎使用该命令）。</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre># redis<span class=\"token operator\">-</span>cli</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token number\">127.0</span><span class=\"token number\">.0</span><span class=\"token number\">.1</span><span class=\"token operator\">:</span><span class=\"token number\">6379</span><span class=\"token operator\">></span> <span class=\"token constant\">MONITOR</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token constant\">OK</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token number\">1683638260.637378</span> <span class=\"token punctuation\">[</span><span class=\"token number\">0</span> <span class=\"token number\">172.17</span><span class=\"token number\">.0</span><span class=\"token number\">.1</span><span class=\"token operator\">:</span><span class=\"token number\">61516</span><span class=\"token punctuation\">]</span> <span class=\"token string\">\"ping\"</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token number\">1683638267.144236</span> <span class=\"token punctuation\">[</span><span class=\"token number\">0</span> <span class=\"token number\">172.17</span><span class=\"token number\">.0</span><span class=\"token number\">.1</span><span class=\"token operator\">:</span><span class=\"token number\">61518</span><span class=\"token punctuation\">]</span> <span class=\"token string\">\"smembers\"</span> <span class=\"token string\">\"mySet\"</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token number\">1683638268.941863</span> <span class=\"token punctuation\">[</span><span class=\"token number\">0</span> <span class=\"token number\">172.17</span><span class=\"token number\">.0</span><span class=\"token number\">.1</span><span class=\"token operator\">:</span><span class=\"token number\">61518</span><span class=\"token punctuation\">]</span> <span class=\"token string\">\"smembers\"</span> <span class=\"token string\">\"mySet\"</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token number\">1683638269.551671</span> <span class=\"token punctuation\">[</span><span class=\"token number\">0</span> <span class=\"token number\">172.17</span><span class=\"token number\">.0</span><span class=\"token number\">.1</span><span class=\"token operator\">:</span><span class=\"token number\">61518</span><span class=\"token punctuation\">]</span> <span class=\"token string\">\"smembers\"</span> <span class=\"token string\">\"mySet\"</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token number\">1683638270.646256</span> <span class=\"token punctuation\">[</span><span class=\"token number\">0</span> <span class=\"token number\">172.17</span><span class=\"token number\">.0</span><span class=\"token number\">.1</span><span class=\"token operator\">:</span><span class=\"token number\">61516</span><span class=\"token punctuation\">]</span> <span class=\"token string\">\"ping\"</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token number\">1683638270.849551</span> <span class=\"token punctuation\">[</span><span class=\"token number\">0</span> <span class=\"token number\">172.17</span><span class=\"token number\">.0</span><span class=\"token number\">.1</span><span class=\"token operator\">:</span><span class=\"token number\">61518</span><span class=\"token punctuation\">]</span> <span class=\"token string\">\"smembers\"</span> <span class=\"token string\">\"mySet\"</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token number\">1683638271.926945</span> <span class=\"token punctuation\">[</span><span class=\"token number\">0</span> <span class=\"token number\">172.17</span><span class=\"token number\">.0</span><span class=\"token number\">.1</span><span class=\"token operator\">:</span><span class=\"token number\">61518</span><span class=\"token punctuation\">]</span> <span class=\"token string\">\"smembers\"</span> <span class=\"token string\">\"mySet\"</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token number\">1683638274.276599</span> <span class=\"token punctuation\">[</span><span class=\"token number\">0</span> <span class=\"token number\">172.17</span><span class=\"token number\">.0</span><span class=\"token number\">.1</span><span class=\"token operator\">:</span><span class=\"token number\">61518</span><span class=\"token punctuation\">]</span> <span class=\"token string\">\"smembers\"</span> <span class=\"token string\">\"mySet2\"</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token number\">1683638276.327234</span> <span class=\"token punctuation\">[</span><span class=\"token number\">0</span> <span class=\"token number\">172.17</span><span class=\"token number\">.0</span><span class=\"token number\">.1</span><span class=\"token operator\">:</span><span class=\"token number\">61518</span><span class=\"token punctuation\">]</span> <span class=\"token string\">\"smembers\"</span> <span class=\"token string\">\"mySet\"</span></pre></td></tr></table></figure><p>在发生紧急情况时，我们可以选择在合适的时机短暂执行  <code>MONITOR</code>  命令并将输出重定向至文件，在关闭  <code>MONITOR</code>  命令后通过对文件中请求进行归类分析即可找出这段时间中的 hotkey。</p>\n<p><strong><font color='#B32015'>3、借助开源项目</font></strong></p>\n<p>京东零售的 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRlZS5jb20vamQtcGxhdGZvcm0tb3BlbnNvdXJjZS9ob3RrZXk=\">hotkey</span> 这个项目不光支持 hotkey 的发现，还支持 hotkey 的处理。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/jd-hotkey.png\" alt=\"京东零售开源的 hotkey\" /></p>\n<center>京东零售开源的 hotkey</center>\n<p><strong>4、根据业务情况提前预估</strong></p>\n<p>可以根据业务情况来预估一些 hotkey，比如参与秒杀活动的商品数据等。不过，我们无法预估所有 hotkey 的出现，比如突发的热点新闻事件等。</p>\n<p><strong>5、业务代码中记录分析</strong></p>\n<p>在业务代码中添加相应的逻辑对 key 的访问情况进行记录分析。不过，这种方式会让业务代码的复杂性增加，一般也不会采用。</p>\n<p><strong><font color='#B32015'>6、借助公有云的 Redis 分析服务</font></strong></p>\n<p>如果你用的是公有云的 Redis 服务的话，可以看看其是否提供了 key 分析功能（一般都提供了）。</p>\n<p>这里以阿里云 Redis 为例说明，它<font color='red'>支持 hotkey 实时分析、发现</font>，文档地址：<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWxpYmFiYWNsb3VkLmNvbS9oZWxwL3poL2Fwc2FyYWRiLWZvci1yZWRpcy9sYXRlc3QvdXNlLXRoZS1yZWFsLXRpbWUta2V5LXN0YXRpc3RpY3MtZmVhdHVyZQ==\">https://www.alibabacloud.com/help/zh/apsaradb-for-redis/latest/use-the-real-time-key-statistics-feature</span> 。</p>\n<p><img data-src=\"https://oss.javaguide.cn/github/javaguide/database/redis/aliyun-key-analysis.png\" alt=\"阿里云Key分析\" /></p>\n<center>阿里云Key分析</center>\n<h3 id=\"如何解决-hotkey\"><a class=\"anchor\" href=\"#如何解决-hotkey\">#</a> 如何解决 hotkey</h3>\n<p>hotkey 的常见处理以及优化办法如下（这些方法可以配合起来使用）：</p>\n<ul>\n<li><strong><font color='#B32015'>读写分离</font></strong>：主节点处理写请求，从节点处理读请求。</li>\n<li><strong><font color='#B32015'>使用 Redis Cluster</font></strong>：将热点数据分散存储在多个 Redis 节点上。</li>\n<li><strong><font color='#B32015'>二级缓存</font></strong>：hotkey 采用二级缓存的方式进行处理，将 hotkey 存放一份到 JVM 本地内存中（可以用 Caffeine）。</li>\n</ul>\n<p>除了这些方法之外，如果你使用<font color='red'>公有云的 Redis 服务</font>话，还可以留意其提供的开箱即用的解决方案。</p>\n<p>这里以阿里云 Redis 为例说明，它<font color='red'>支持通过代理查询缓存功能（Proxy Query Cache）优化热点 Key 问题</font>。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/aliyun-hotkey-proxy-query-cache.png\" alt=\"通过阿里云的Proxy Query Cache优化热点Key问题\" /></p>\n<center>通过阿里云的Proxy Query Cache优化热点Key问题</center>\n<h2 id=\"慢查询命令\"><a class=\"anchor\" href=\"#慢查询命令\">#</a> 慢查询命令</h2>\n<h3 id=\"慢查询命令的产生原因\"><a class=\"anchor\" href=\"#慢查询命令的产生原因\">#</a> 慢查询命令的产生原因</h3>\n<p>我们知道一个 Redis 命令的执行可以简化为以下 4 步：</p>\n<ol>\n<li>发送命令</li>\n<li>命令排队</li>\n<li><font color='red'>命令执行</font></li>\n<li>返回结果</li>\n</ol>\n<p>Redis 慢查询统计的是命令执行这一步骤的耗时，<strong><font color='red'>慢查询命令也就是那些命令执行时间较长的命令</font></strong>。</p>\n<p>Redis 为什么会有慢查询命令呢？[O (n) 命令](#O (n) 命令)</p>\n<h3 id=\"如何发现慢查询命令\"><a class=\"anchor\" href=\"#如何发现慢查询命令\">#</a> 如何发现慢查询命令</h3>\n<p>在  <code>redis.conf</code>  文件中，我们可以使用  <code>slowlog-log-slower-than</code>  参数设置耗时命令的阈值，并使用  <code>slowlog-max-len</code>  参数设置耗时命令的最大记录条数。</p>\n<p><font color='red'>当 Redis 服务器检测到执行时间超过  <code>slowlog-log-slower-than</code>  阈值的命令时</font>，就会将该命令记录在 **<font color='#B32015'>慢查询日志 (slow log)</font>** 中，这点和 MySQL 记录慢查询语句类似。<font color='red'>当慢查询日志超过设定的最大记录条数  <code>slowlog-max-len</code>  之后，Redis 会把最早的执行命令依次舍弃</font>。</p>\n<p>⚠️注意：由于慢查询日志会占用一定内存空间，如果设置最大记录条数过大，可能会导致内存占用过高的问题。</p>\n<p><code>slowlog-log-slower-than</code>  和 <code>slowlog-max-len</code>  的默认配置如下 (可以自行修改)：</p>\n<figure class=\"highlight nginx\"><figcaption data-lang=\"nginx\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># The following time is expressed in microseconds, so 1000000 is equivalent</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token comment\"># to one second. Note that a negative number disables the slow log, while</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token comment\"># a value of zero forces the logging of every command.</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>slowlog-log-slower-than 10000</pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token comment\"># There is no limit to this length. Just be aware that it will consume memory.</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token comment\"># You can reclaim memory used by the slow log with SLOWLOG RESET.</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>slowlog-max-len 128</pre></td></tr></table></figure><p>除了修改配置文件之外，你也可以直接通过  <code>CONFIG</code>  命令直接设置：</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># 命令执行耗时超过 10000 微妙（即 10 毫秒）就会被记录</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>CONFIG SET slowlog-log-slower-than <span class=\"token number\">10000</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token comment\"># 只保留最近 128 条耗时命令</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>CONFIG SET slowlog-max-len <span class=\"token number\">128</span></pre></td></tr></table></figure><p>获取慢查询日志的内容很简单，直接使用  <code>SLOWLOG GET</code>  命令即可。</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token number\">127.0</span><span class=\"token number\">.0</span><span class=\"token number\">.1</span><span class=\"token operator\">:</span><span class=\"token number\">6379</span><span class=\"token operator\">></span> <span class=\"token constant\">SLOWLOG</span> <span class=\"token constant\">GET</span> #慢日志查询</pre></td></tr><tr><td data-num=\"2\"></td><td><pre> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span>integer<span class=\"token punctuation\">)</span> <span class=\"token number\">5</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>   <span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span>integer<span class=\"token punctuation\">)</span> <span class=\"token number\">1684326682</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>   <span class=\"token number\">3</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span>integer<span class=\"token punctuation\">)</span> <span class=\"token number\">12000</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>   <span class=\"token number\">4</span><span class=\"token punctuation\">)</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token string\">\"KEYS\"</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>      <span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token string\">\"*\"</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>   <span class=\"token number\">5</span><span class=\"token punctuation\">)</span> <span class=\"token string\">\"172.17.0.1:61152\"</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>   <span class=\"token number\">6</span><span class=\"token punctuation\">)</span> <span class=\"token string\">\"\"</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>  <span class=\"token comment\">// ...</span></pre></td></tr></table></figure><p>慢查询日志中的每个条目都由以下六个值组成：</p>\n<ol>\n<li>唯一渐进的<font color='gree'>日志标识符</font>。</li>\n<li>处理记录命令的<font color='gree'> Unix 时间戳</font>。</li>\n<li><font color='gree'>执行所需的时间量</font>，以微秒为单位。</li>\n<li>组成<font color='gree'>命令参数</font>的数组。</li>\n<li>客户端<font color='gree'> IP 地址和端口</font>。</li>\n<li>客户端<font color='gree'>名称</font>。</li>\n</ol>\n<p><code>SLOWLOG GET</code>  命令默认返回最近 10 条的的慢查询命令，你也自己可以指定返回的慢查询命令的数量  <code>SLOWLOG GET N</code> 。</p>\n<p>下面是其他比较常用的慢查询相关的命令：</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># 返回慢查询命令的数量</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token number\">127.0</span>.0.1:637<span class=\"token operator\"><span class=\"token file-descriptor important\">9</span>></span> SLOWLOG LEN</pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">(</span>integer<span class=\"token punctuation\">)</span> <span class=\"token number\">128</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token comment\"># 清空慢查询命令</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token number\">127.0</span>.0.1:637<span class=\"token operator\"><span class=\"token file-descriptor important\">9</span>></span> SLOWLOG RESET</pre></td></tr><tr><td data-num=\"6\"></td><td><pre>OK</pre></td></tr></table></figure><h2 id=\"redis-内存碎片\"><a class=\"anchor\" href=\"#redis-内存碎片\">#</a> Redis 内存碎片</h2>\n<h3 id=\"内存碎片是什么\"><a class=\"anchor\" href=\"#内存碎片是什么\">#</a> 内存碎片是什么</h3>\n<p>可以将内存碎片简单地理解为那些<font color='red'>不可用的空闲内存</font>。</p>\n<p>举个例子：操作系统为你分配了 32 字节的连续内存空间，而你存储数据实际只需要使用 24 字节内存空间，那这多余出来的 8 字节内存空间如果后续没办法再被分配存储其他数据的话，就可以被称为内存碎片。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/memory-fragmentation.png\" alt=\"内存碎片\" /></p>\n<center>内存碎片</center>\n<p>Redis 内存碎片<font color='red'>虽然不会影响 Redis 性能，但是会增加内存消耗</font>。</p>\n<h3 id=\"redis-内存碎片的产生原因\"><a class=\"anchor\" href=\"#redis-内存碎片的产生原因\">#</a> Redis 内存碎片的产生原因</h3>\n<p>Redis 内存碎片产生比较常见的 2 个原因：</p>\n<p><strong><font color='#B32015'>1、Redis 存储数据时，向操作系统申请的内存空间可能会大于数据实际需要的存储空间。</font></strong></p>\n<p>Redis 使用  <code>zmalloc</code>  方法（Redis 自己实现的内存分配方法) 进行内存分配的时候，除了要分配  <code>size</code>  大小的内存之外，还会多分配  <code>PREFIX_SIZE</code>  大小的内存。</p>\n<blockquote>\n<p><code>zmalloc</code>  方法源码如下（源码地址：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2FudGlyZXovcmVkaXMtdG9vbHMvYmxvYi9tYXN0ZXIvem1hbGxvYy5jJUVGJUJDJTg5\">https://github.com/antirez/redis-tools/blob/master/zmalloc.c）</span></p>\n</blockquote>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span><span class=\"token function\">zmalloc</span><span class=\"token punctuation\">(</span>size_t size<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>   <span class=\"token comment\">// 分配指定大小的内存</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>   <span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>ptr <span class=\"token operator\">=</span> <span class=\"token function\">malloc</span><span class=\"token punctuation\">(</span>size<span class=\"token operator\">+</span><span class=\"token constant\">PREFIX_SIZE</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>   <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>ptr<span class=\"token punctuation\">)</span> <span class=\"token function\">zmalloc_oom_handler</span><span class=\"token punctuation\">(</span>size<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>#ifdef <span class=\"token class-name\">HAVE_MALLOC_SIZE</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>   <span class=\"token function\">update_zmalloc_stat_alloc</span><span class=\"token punctuation\">(</span><span class=\"token function\">zmalloc_size</span><span class=\"token punctuation\">(</span>ptr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>   <span class=\"token keyword\">return</span> ptr<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>#<span class=\"token keyword\">else</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>   <span class=\"token operator\">*</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>size_t<span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>ptr<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> size<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>   <span class=\"token function\">update_zmalloc_stat_alloc</span><span class=\"token punctuation\">(</span>size<span class=\"token operator\">+</span><span class=\"token constant\">PREFIX_SIZE</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>   <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>ptr<span class=\"token operator\">+</span><span class=\"token constant\">PREFIX_SIZE</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>#endif</pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>另外，<font color='red'>Redis 可以使用多种内存分配器（libc、jemalloc、tcmalloc）来分配内存</font>，默认使用<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2plbWFsbG9jL2plbWFsbG9j\"> jemalloc</span>。而 jemalloc 按照一系列固定的大小（8 字节、16 字节、32 字节……）来分配内存的。jemalloc 划分的内存单元如下图所示：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/6803d3929e3e46c1b1c9d0bb9ee8e717.png\" alt=\"jemalloc 内存单元示意图\" /></p>\n<center>jemalloc 内存单元示意图</center>\n<p><font color='red'>当程序申请的内存最接近某个固定值时，jemalloc 会给它分配相应大小的空间</font>。就比如说程序需要申请 17 字节的内存，jemalloc 会直接给它分配 32 字节的内存，这样会导致有 15 字节内存的浪费。不过，<font color='red'>jemalloc 专门针对内存碎片问题做了优化，一般不会存在过度碎片化的问题</font>。</p>\n<p><strong><font color='#B32015'>2、频繁修改 Redis 中的数据也会产生内存碎片。</font></strong></p>\n<p><font color='red'>当 Redis 中的某个数据删除时，Redis 通常不会轻易释放内存给操作系统</font>。</p>\n<p>这个在 Redis 官方文档中也有对应的原话：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/redis-docs-memory-optimization.png\" alt=\"img\" /></p>\n<p>文档地址：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9yZWRpcy5pby90b3BpY3MvbWVtb3J5LW9wdGltaXphdGlvbg==\">https://redis.io/topics/memory-optimization</span> 。</p>\n<h3 id=\"如何查看-redis-内存碎片的信息\"><a class=\"anchor\" href=\"#如何查看-redis-内存碎片的信息\">#</a> 如何查看 Redis 内存碎片的信息</h3>\n<p>使用  <code>info memory</code>  命令即可查看 Redis 内存相关的信息。下图中每个参数具体的含义，Redis 官方文档有详细的介绍：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9yZWRpcy5pby9jb21tYW5kcy9JTkZP\">https://redis.io/commands/INFO</span> 。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/redis-info-memory.png\" alt=\"img\" /></p>\n<p>Redis 内存碎片率的计算公式： <code>mem_fragmentation_ratio</code>  （内存碎片率）=  <code>used_memory_rss</code>  (操作系统实际分配给 Redis 的物理内存空间大小)/  <code>used_memory</code>  (Redis 内存分配器为了存储数据实际申请使用的内存空间大小)</p>\n<p>也就是说， <code>mem_fragmentation_ratio</code>  （内存碎片率）的值越大代表内存碎片率越严重。</p>\n<p>一定不要误认为 <code>used_memory_rss</code>  减去  <code>used_memory</code>  值就是内存碎片的大小！！！这不仅包括内存碎片，还包括其他进程开销，以及共享库、堆栈等的开销。</p>\n<p>很多小伙伴可能要问了：“多大的内存碎片率才是需要清理呢？”。</p>\n<p>通常情况下，我们认为  <code>mem_fragmentation_ratio &gt; 1.5</code>  的话才需要清理内存碎片。  <code>mem_fragmentation_ratio &gt; 1.5</code>  意味着你使用 Redis 存储实际大小 2G 的数据需要使用大于 3G 的内存。</p>\n<p>如果想要快速查看内存碎片率的话，你还可以通过下面这个命令：</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token operator\">></span> redis-cli <span class=\"token parameter variable\">-p</span> <span class=\"token number\">6379</span> info <span class=\"token operator\">|</span> <span class=\"token function\">grep</span> mem_fragmentation_ratio</pre></td></tr></table></figure><p>另外，内存碎片率可能存在小于 1 的情况。这种情况我在日常使用中还没有遇到过，感兴趣的小伙伴可以看看这篇文章 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvZHJsRHZwN2JmcTVqdDJNNXBUcUpDdw==\">故障分析 | Redis 内存碎片率太低该怎么办？- 爱可生开源社区</span> 。</p>\n<h3 id=\"如何清理-redis-内存碎片\"><a class=\"anchor\" href=\"#如何清理-redis-内存碎片\">#</a> 如何清理 Redis 内存碎片？</h3>\n<p>Redis4.0-RC3 版本以后自带了内存整理，可以避免内存碎片率过大的问题。</p>\n<p><font color='red'>直接通过  <code>config set</code>  命令将  <code>activedefrag</code>  配置项设置为  <code>yes</code>  即可</font>。</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>config <span class=\"token builtin class-name\">set</span> activedefrag <span class=\"token function\">yes</span></pre></td></tr></table></figure><p>具体什么时候清理需要通过下面两个参数控制：</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># 内存碎片占用空间达到 500mb 的时候开始清理</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>config <span class=\"token builtin class-name\">set</span> active-defrag-ignore-bytes 500mb</pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token comment\"># 内存碎片率大于 1.5 的时候开始清理</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>config <span class=\"token builtin class-name\">set</span> active-defrag-threshold-lower <span class=\"token number\">50</span></pre></td></tr></table></figure><p>通过 Redis 自动内存碎片清理机制可能会对 Redis 的性能产生影响，我们可以通过下面两个参数来减少对 Redis 性能的影响：</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># 内存碎片清理所占用 CPU 时间的比例不低于 20%</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>config <span class=\"token builtin class-name\">set</span> active-defrag-cycle-min <span class=\"token number\">20</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token comment\"># 内存碎片清理所占用 CPU 时间的比例不高于 50%</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>config <span class=\"token builtin class-name\">set</span> active-defrag-cycle-max <span class=\"token number\">50</span></pre></td></tr></table></figure><p>另外，<font color='red'>重启节点可以做到内存碎片重新整理</font>。如果你采用的是高可用架构的 Redis 集群的话，你<font color='red'>可以将碎片率过高的主节点转换为从节点，以便进行安全重启</font>。</p>\n<h1 id=\"redis-生产问题高并发问题\"><a class=\"anchor\" href=\"#redis-生产问题高并发问题\">#</a> <mark>🌟Redis 生产问题（高并发问题）</mark></h1>\n<h2 id=\"缓存穿透\"><a class=\"anchor\" href=\"#缓存穿透\">#</a> 缓存穿透</h2>\n<h3 id=\"是什么-5\"><a class=\"anchor\" href=\"#是什么-5\">#</a> 是什么</h3>\n<p>缓存穿透说简单点就是 **<font color='#B32015'><font color='orange'>大量请求的 key 既不存在于缓存中，也不存在于数据库中</font>，进行了两次无用的查询，最终返回空数据</font>**。这就<font color='red'>导致这些请求直接到了数据库上，根本没有经过缓存这一层，对数据库造成了巨大的压力，可能直接就被这么多请求弄宕机了</font>。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/redis-cache-penetration.png\" alt=\"缓存穿透\" /></p>\n<center>缓存穿透</center>\n<p>举个例子：某个黑客故意制造一些非法的 key 发起大量请求，导致大量请求落到数据库，结果数据库上也没有查到对应的数据。也就是说这些请求最终都落到了数据库上，对数据库造成了巨大的压力。</p>\n<h3 id=\"如何解决\"><a class=\"anchor\" href=\"#如何解决\">#</a> 如何解决</h3>\n<p>最基本的就是<font color='red'>首先做好参数校验</font>，一些不合法的参数请求直接抛出异常信息返回给客户端。比如查询的数据库 id 不能小于 0、传入的邮箱格式不对的时候直接返回错误消息给客户端等等。</p>\n<h4 id=\"1缓存无效-key\"><a class=\"anchor\" href=\"#1缓存无效-key\">#</a> 1）缓存无效 key</h4>\n<p><font color='red'>将缓存和数据库都查不到某个 key 的数据写到 Redis 中，并设置过期时间</font>。具体命令如下： <code>SET key value EX 10086</code>  。这种方式可以解决请求的 key 变化不频繁的情况，如果黑客恶意攻击，每次构建不同的请求 key，会导致 Redis 中缓存大量无效的 key 。很明显，<strong><font color='red'>这种方案并不能从根本上解决此问题</font></strong>。如果非要用这种方式来解决穿透问题的话，尽量将无效的 key 的过期时间设置短一点比如 1 分钟。</p>\n<p>另外，这里多说一嘴，一般情况下我们是这样设计 key 的： <code>表名:列名:主键名:主键值</code> 。</p>\n<p>如果用 Java 代码展示的话，差不多是下面这样的：</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token class-name\">Object</span> <span class=\"token function\">getObjectInclNullById</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Integer</span> id<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token comment\">// 从缓存中获取数据</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token class-name\">Object</span> cacheValue <span class=\"token operator\">=</span> cache<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>id<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token comment\">// 缓存为空</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>cacheValue <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>        <span class=\"token comment\">// 从数据库中获取</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>        <span class=\"token class-name\">Object</span> storageValue <span class=\"token operator\">=</span> storage<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>        <span class=\"token comment\">// 缓存空对象</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>        cache<span class=\"token punctuation\">.</span><span class=\"token function\">set</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">,</span> storageValue<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>        <span class=\"token comment\">// 如果存储数据为空，需要设置一个过期时间 (300 秒)</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>storageValue <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>            <span class=\"token comment\">// 必须设置过期时间，否则有被攻击的风险</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>            cache<span class=\"token punctuation\">.</span><span class=\"token function\">expire</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">,</span> <span class=\"token number\">60</span> <span class=\"token operator\">*</span> <span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>        <span class=\"token keyword\">return</span> storageValue<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>    <span class=\"token keyword\">return</span> cacheValue<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h4 id=\"2布隆过滤器\"><a class=\"anchor\" href=\"#2布隆过滤器\">#</a> 2）布隆过滤器</h4>\n<blockquote>\n<p>常用方法</p>\n</blockquote>\n<p>布隆过滤器是一个非常神奇的数据结构，它将所有可能存在的数据哈希到一个足够大的  <code>bitmap</code>  中，<strong><font color='red'>一个一定不存在的数据会被拦截掉</font></strong>，从而避免了对底层存储系统的查询压力。通过它我们<font color='red'>可以非常方便地判断一个给定数据是否存在于海量数据中</font>。我们需要的就是<font color='red'>判断 key 是否合法</font>，有没有感觉布隆过滤器就是我们想要找的那个 “人”。</p>\n<p>具体是这样做的：把所有可能存在的请求值都存放在布隆过滤器中，当用户请求过来，先判断用户发来的请求值是否存在于布隆过滤器中。<font color='red'>不存在的话，直接返回请求参数错误信息给客户端</font>，存在的话才会走下面的流程。</p>\n<p>加入布隆过滤器之后的缓存处理流程图如下：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/redis-cache-penetration-bloom-filter.png\" alt=\"加入布隆过滤器之后的缓存处理流程图\" /></p>\n<center>加入布隆过滤器之后的缓存处理流程图</center>\n<p>但是，需要注意的是布隆过滤器可能会存在误判的情况。总结来说就是：<strong><font color='red'>布隆过滤器说某个元素存在，小概率会误判。布隆过滤器说某个元素不在，那么这个元素一定不在。</font></strong></p>\n<hr />\n<p><em>为什么会出现误判的情况呢？我们还要从布隆过滤器的原理来说！</em></p>\n<p>我们先来看一下，<strong>当一个元素加入布隆过滤器中的时候，会进行哪些操作：</strong></p>\n<ol>\n<li>使用布隆过滤器中的<font color='red'>哈希函数</font>对元素值进行计算，得到哈希值（有几个哈希函数得到几个哈希值）。</li>\n<li>根据得到的哈希值，在<font color='gree'>位数组</font>中把对应下标的值置为 1。</li>\n</ol>\n<p>我们再来看一下，<strong>当我们需要判断一个元素是否存在于布隆过滤器的时候，会进行哪些操作：</strong></p>\n<ol>\n<li>对给定元素再次进行相同的哈希计算；</li>\n<li>得到值之后判断位数组中的每个元素是否都为 1，如果值都为 1，那么说明这个值在布隆过滤器中，如果存在一个值不为 1，说明该元素不在布隆过滤器中。</li>\n</ol>\n<p>然后，一定会出现这样一种情况：<strong><font color='red'>不同的字符串可能哈希出来的位置相同。</font></strong> （可以适当增加位数组大小或者调整我们的哈希函数来降低概率）</p>\n<p>更多关于布隆过滤器的内容可以看我的这篇原创：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9qYXZhZ3VpZGUuY24vY3MtYmFzaWNzL2RhdGEtc3RydWN0dXJlL2Jsb29tLWZpbHRlci8=\">《不了解布隆过滤器？一文给你整的明明白白！》</span> ，强烈推荐，个人感觉网上应该找不到总结的这么明明白白的文章了。</p>\n<h2 id=\"缓存击穿\"><a class=\"anchor\" href=\"#缓存击穿\">#</a> 缓存击穿</h2>\n<h3 id=\"是什么-6\"><a class=\"anchor\" href=\"#是什么-6\">#</a> 是什么</h3>\n<p>缓存击穿中，<strong><font color='orange'>请求的 key 是<u>热点数据</u>，该数据存在于数据库中，但不存在于缓存中（通常因为缓存中的那份数据已经过期）</font></strong>。这就可能会导致瞬时大量的请求直接打到了数据库上，对数据库造成了巨大的压力，可能直接就被这么多请求弄宕机了。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/redis-cache-breakdown.png\" alt=\"缓存击穿\" /></p>\n<center>缓存击穿</center>\n<p>举个例子：秒杀进行过程中，缓存中的某个秒杀商品的数据突然过期，这就导致瞬时大量对该商品的请求直接落到数据库上，对数据库造成了巨大的压力。</p>\n<h3 id=\"如何解决-2\"><a class=\"anchor\" href=\"#如何解决-2\">#</a> 如何解决</h3>\n<ul>\n<li>\n<p>针对热点数据提前预热，<strong><font color='red'>将热点数据存入缓存中并设置合理的过期时间（永不过期 / 过期时间较长）</font></strong>。比如秒杀场景下的数据在秒杀结束之前不过期。</p>\n</li>\n<li>\n<p>请求数据库写数据到缓存之前，先<font color='red'>获取互斥锁 mutex</font>，保证只有一个请求会落到数据库上，减少数据库的压力。</p>\n</li>\n</ul>\n<h3 id=\"缓存穿透与缓存击穿的区别\"><a class=\"anchor\" href=\"#缓存穿透与缓存击穿的区别\">#</a> 缓存穿透与缓存击穿的区别</h3>\n<p>缓存穿透中，请求的 key 既不存在于缓存中，也不存在于数据库中。</p>\n<p>缓存击穿中，请求的 key 对应的是 <strong>热点数据</strong> ，该数据 <strong>存在于数据库中，但不存在于缓存中（通常是因为缓存中的那份数据已经过期）</strong> 。</p>\n<h2 id=\"缓存雪崩\"><a class=\"anchor\" href=\"#缓存雪崩\">#</a> 缓存雪崩</h2>\n<h3 id=\"是什么-7\"><a class=\"anchor\" href=\"#是什么-7\">#</a> 是什么</h3>\n<p>实际上，缓存雪崩描述的就是这样一个简单的场景：**<font color='#B32015'><font color='orange'>缓存在同一时间大面积失效</font>，导致大量的请求都直接落到了数据库上，对数据库造成了巨大的压力。</font>** 这就好比雪崩一样，摧枯拉朽之势，数据库的压力可想而知，可能直接就被这么多请求弄宕机了。</p>\n<p>另外，<font color='red'>缓存服务宕机也会导致缓存雪崩现象，导致所有的请求都落到了数据库上</font>。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/redis-cache-avalanche.png\" alt=\"缓存雪崩\" /></p>\n<center>缓存雪崩</center>\n<p>举个例子：数据库中的大量数据在同一时间过期，这个时候突然有大量的请求需要访问这些过期的数据。这就导致大量的请求直接落到数据库上，对数据库造成了巨大的压力。</p>\n<h3 id=\"如何解决-3\"><a class=\"anchor\" href=\"#如何解决-3\">#</a> 如何解决</h3>\n<p><strong>针对热点缓存失效的情况：</strong></p>\n<ol>\n<li>设置不同的失效时间，比如<font color='red'>随机设置缓存的失效时间</font>。</li>\n<li>缓存永不失效（不太推荐，实用性太差）。</li>\n<li><font color='red'>设置二级缓存</font>。</li>\n</ol>\n<p><strong>针对 Redis 服务不可用的情况：</strong></p>\n<ol>\n<li><font color='red'>采用 Redis 集群</font>，避免单机出现问题整个缓存服务都没办法使用。</li>\n<li><font color='red'>限流</font>，避免同时处理大量的请求。</li>\n</ol>\n<h3 id=\"缓存雪崩与缓存击穿的区别\"><a class=\"anchor\" href=\"#缓存雪崩与缓存击穿的区别\">#</a> 缓存雪崩与缓存击穿的区别</h3>\n<p>缓存雪崩和缓存击穿比较像，但<font color='red'>导致缓存雪崩的原因是缓存中的大量或者所有数据失效</font>，<font color='red'>导致缓存击穿的原因主要是某个热点数据不存在于缓存中（通常是因为缓存中的那份数据已经过期）</font>。</p>\n<h2 id=\"如何保证缓存和数据库数据的一致性\"><a class=\"anchor\" href=\"#如何保证缓存和数据库数据的一致性\">#</a> 如何保证缓存和数据库数据的一致性？</h2>\n<p>个人觉得引入缓存之后，如果为了短时间的不一致性问题，选择让系统设计变得更加复杂的话，完全没必要。</p>\n<p>下面单独对 **<font color='#B32015'>Cache Aside Pattern（旁路缓存模式）</font>** 来聊聊。</p>\n<p>Cache Aside Pattern 中遇到写请求是这样的：更新 DB，然后直接删除 cache 。</p>\n<p>如果更新数据库成功，而删除缓存这一步失败的情况的话，简单说两个解决方案：</p>\n<ol>\n<li><strong>缩短缓存失效时间（不推荐，治标不治本）</strong>：我们让缓存数据的过期时间变短，这样的话缓存就会从数据库中加载数据。另外，这种解决办法对于先操作缓存后操作数据库的场景不适用。</li>\n<li><strong><font color='#B32015'>增加 cache 更新重试机制（常用）</font></strong>：如果 cache 服务当前不可用导致缓存删除失败的话，我们就隔一段时间进行重试，重试次数可以自己定。如果多次重试还是失败的话，我们可以把当前更新失败的 key 存入队列中，等缓存服务可用之后，再将缓存中对应的 key 删除即可。</li>\n</ol>\n<p>相关文章推荐：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3M/X19iaXo9TXpJeU9UWXhOREk1T0E9PSZhbXA7bWlkPTIyNDc0ODczMTImYW1wO2lkeD0xJmFtcDtzbj1mYTE5NTY2ZjU3MjlkNjU5ODE1NWI1YzY3NmVlZTYyZCZhbXA7Y2hrc209ZThiZWI4ZTVkZmM5MzFmM2UzNTY1NWRhOWRhMGI2MWM3OWYyODQzMTAxYzEzMGNmMzg5OTY0NDY5NzUwMTRmOTU4YTY0ODFhYWNmMSZhbXA7c2NlbmU9MTc4JmFtcDtjdXJfYWxidW1faWQ9MTY5OTc2NjU4MDUzODAzMjEyOCNyZA==\">缓存和数据库一致性问题，看这篇就够了 - 水滴与银弹</span>。</p>\n<h2 id=\"redis-阻塞的常见原因\"><a class=\"anchor\" href=\"#redis-阻塞的常见原因\">#</a> Redis 阻塞的常见原因</h2>\n<h3 id=\"on-命令\"><a class=\"anchor\" href=\"#on-命令\">#</a> O (n) 命令</h3>\n<p>Redis 中的大部分命令都是 O (1) 时间复杂度，但也有少部分<font color='red'> O (n) 时间复杂度的命令</font>，例如：</p>\n<ul>\n<li><code>KEYS *</code> ：会返回所有符合规则的 key。</li>\n<li><code>HGETALL</code> ：会返回一个 Hash 中所有的键值对。</li>\n<li><code>LRANGE</code> ：会返回 List 中指定范围内的元素。</li>\n<li><code>SMEMBERS</code> ：返回 Set 中的所有元素。</li>\n<li><code>SINTER</code> / <code>SUNION</code> / <code>SDIFF</code> ：计算多个 Set 的交集 / 并集 / 差集。</li>\n<li>……</li>\n</ul>\n<p>由于这些命令时间复杂度是 O (n)，有时候也会全表扫描，随着 n 的增大，执行耗时也会越长。不过，这些命令并不是一定不能使用，但是需要明确 N 的值。另外，<font color='red'>有遍历的需求可以使用  <code>HSCAN</code> 、 <code>SSCAN</code> 、 <code>ZSCAN</code>  代替</font>。</p>\n<p>除了这些 O (n) 时间复杂度的命令可能会导致慢查询之外， 还有一些<font color='red'>时间复杂度可能在 O (N) 以上的命令</font>，例如：</p>\n<ul>\n<li><code>ZRANGE</code> / <code>ZREVRANGE</code> ：返回指定 Sorted Set 中指定排名范围内的所有元素。时间复杂度为 O (log (n)+m)，n 为所有元素的数量， m 为返回的元素数量，当 m 和 n 相当大时，O (n) 的时间复杂度更小。</li>\n<li><code>ZREMRANGEBYRANK</code> / <code>ZREMRANGEBYSCORE</code> ：移除 Sorted Set 中指定排名范围 / 指定 score 范围内的所有元素。时间复杂度为 O (log (n)+m)，n 为所有元素的数量， m 被删除元素的数量，当 m 和 n 相当大时，O (n) 的时间复杂度更小。</li>\n<li>……</li>\n</ul>\n<h3 id=\"save-创建-rdb-快照\"><a class=\"anchor\" href=\"#save-创建-rdb-快照\">#</a> SAVE 创建 RDB 快照</h3>\n<p>Redis 提供了两个命令来生成 RDB 快照文件：</p>\n<ul>\n<li><code>save</code>  : 同步保存操作，<strong><font color='red'>会阻塞 Redis 主线程</font></strong>；</li>\n<li><code>bgsave</code>  : fork 出一个子进程，子进程执行，<font color='red'>不会阻塞 Redis 主线程</font>，默认选项。</li>\n</ul>\n<p>默认情况下，Redis 默认配置会使用  <code>bgsave</code>  命令。如果手动使用  <code>save</code>  命令生成 RDB 快照文件的话，就会阻塞主线程。</p>\n<h3 id=\"aof\"><a class=\"anchor\" href=\"#aof\">#</a> AOF</h3>\n<h4 id=\"aof-日志记录阻塞\"><a class=\"anchor\" href=\"#aof-日志记录阻塞\">#</a> AOF 日志记录阻塞</h4>\n<p><strong><font color='red'>AOF 持久化机制是在执行完命令之后再记录日志</font></strong>，这和关系型数据库（如 MySQL）通常都是执行命令之前记录日志（方便故障恢复）不同。</p>\n<p><img data-src=\"https://oss.javaguide.cn/github/javaguide/database/redis/redis-aof-write-log-disc.png\" alt=\"AOF 记录日志过程\" /></p>\n<center>AOF 记录日志过程</center>\n<p>为什么是在执行完命令之后记录日志呢？</p>\n<ul>\n<li><font color='red'>避免额外的命令语法检查开销</font>，AOF 记录日志不会对命令进行语法检查；</li>\n<li>在命令执行完之后再记录，<font color='red'>不会阻塞当前的命令执行</font>。</li>\n</ul>\n<p>这样也带来了风险（我在前面介绍 AOF 持久化的时候也提到过）：</p>\n<ul>\n<li>如果刚执行完命令 Redis 就宕机，会导致对应的修改丢失；</li>\n<li><strong><font color='red'>由于 AOF 记录日志是在 Redis 主线程中进行的，因此可能会阻塞后续其他命令的执行</font></strong>。</li>\n</ul>\n<h4 id=\"aof-刷盘阻塞\"><a class=\"anchor\" href=\"#aof-刷盘阻塞\">#</a> AOF 刷盘阻塞</h4>\n<p>开启 AOF 持久化后，Redis 会将每条执行的写命令写入到 AOF 缓冲区  <code>server.aof_buf</code>  中，然后再根据  <code>appendfsync</code>  配置参数来决定何时将其同步到硬盘中的 AOF 文件（刷盘）。</p>\n<p>在 Redis 的配置文件中存在三种不同的 AOF 持久化方式（  <code>fsync</code>  策略）：</p>\n<ol>\n<li><code>always</code> ：主线程调用  <code>write</code>  执行写操作后，后台线程（  <code>aof_fsync</code>  线程）立即会调用  <code>fsync</code>  函数同步 AOF 文件（刷盘）， <code>fsync</code>  完成后线程返回，这样会严重降低 Redis 的性能（ <code>write</code>  +  <code>fsync</code> ）。</li>\n<li><code>everysec</code> ：主线程调用  <code>write</code>  执行写操作后立即返回，由后台线程（  <code>aof_fsync</code>  线程）每秒钟调用  <code>fsync</code>  函数（系统调用）同步一次 AOF 文件（ <code>write</code> + <code>fsync</code> ， <code>fsync</code>  间隔为 1 秒）</li>\n<li><code>no</code> ：主线程调用  <code>write</code>  执行写操作后立即返回，让操作系统决定何时进行同步，Linux 下一般为 30 秒一次（ <code>write</code>  但不 <code>fsync</code> ， <code>fsync</code>  的时机由操作系统决定）。</li>\n</ol>\n<p><font color='red'>当后台线程（  <code>aof_fsync</code>  线程）调用  <code>fsync</code>  函数同步 AOF 文件时，需要等待，直到写入完成</font>。当磁盘压力太大的时候，会导致  <code>fsync</code>  操作发生阻塞，主线程调用  <code>write</code>  函数时也会被阻塞。<font color='red'> <code>fsync</code>  完成后，主线程执行  <code>write</code>  才能成功返回</font>。</p>\n<p>关于 AOF 工作流程的详细介绍可以查看：[AOF 持久化](#AOF 持久化)，有助于理解 AOF 刷盘阻塞。</p>\n<h4 id=\"aof-重写阻塞\"><a class=\"anchor\" href=\"#aof-重写阻塞\">#</a> AOF 重写阻塞</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/2032648-20220207170749957-1755223036.png\" alt=\"img\" /></p>\n<ol>\n<li>主线程 fork 出一条子线程来将文件重写，在执行  <code>BGREWRITEAOF</code>  命令时，Redis 服务器会维护一个<font color='gree'> AOF 重写缓冲区</font>，该缓冲区会在子线程创建新 AOF 文件期间，记录服务器执行的所有写命令。</li>\n<li><font color='red'>当子线程完成创建新 AOF 文件的工作之后，服务器会将 AOF 重写缓冲区中的所有内容追加到新 AOF 文件的末尾</font>，使得新的 AOF 文件保存的数据库状态与现有的数据库状态一致。</li>\n<li>最后，服务器用新的 AOF 文件替换旧的 AOF 文件，以此来完成 AOF 文件重写操作。</li>\n</ol>\n<p>阻塞就是出现在第 2 步的过程中，将 AOF 重写缓冲区中的新数据写到新 AOF 文件的过程中会产生<strong>阻塞</strong>。</p>\n<p>相关阅读：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jbG91ZC50ZW5jZW50LmNvbS9kZXZlbG9wZXIvYXJ0aWNsZS8xNjMzMDc3\">Redis AOF 重写阻塞问题分析</span>。</p>\n<h3 id=\"bigkey\"><a class=\"anchor\" href=\"#bigkey\">#</a> bigkey</h3>\n<p>[bigkey 是什么](#bigkey 是什么)</p>\n<p>[bigkey 的危害](#bigkey 的危害)</p>\n<h4 id=\"查找-bigkey\"><a class=\"anchor\" href=\"#查找-bigkey\">#</a> 查找 bigkey</h4>\n<blockquote>\n<p>[如何发现 bigkey](# 如何发现 bigkey)</p>\n</blockquote>\n<p>当我们在使用 Redis 自带的  <code>--bigkeys</code>  参数查找大 key 时，<font color='red'>最好选择在从节点上执行该命令</font>，因为主节点上执行时，会<strong>阻塞</strong>主节点。</p>\n<ul>\n<li>我们还可以使用  <code>SCAN</code>  命令来查找大 key；</li>\n<li>通过分析 RDB 文件来找出 big key，这种方案的前提是 Redis 采用的是 RDB 持久化。网上有现成的工具：\n<ul>\n<li>redis-rdb-tools：Python 语言写的用来分析 Redis 的 RDB 快照文件用的工具</li>\n<li>rdb_bigkeys：Go 语言写的用来分析 Redis 的 RDB 快照文件用的工具，性能更好。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"删除-bigkey\"><a class=\"anchor\" href=\"#删除-bigkey\">#</a> 删除 bigkey</h4>\n<p>删除操作的本质是要释放键值对占用的内存空间。</p>\n<p>释放内存只是第一步，为了更加高效地管理内存空间，<strong><font color='red'>在应用程序释放内存时，操作系统需要把释放掉的内存块插入一个空闲内存块的链表，以便后续进行管理和再分配</font></strong>。这个过程本身需要一定时间，而且会 **<font color='red'>阻塞</font>** 当前释放内存的应用程序。</p>\n<p>所以，如果一下子释放了大量内存，空闲内存块链表操作时间就会增加，相应地就会造成 Redis 主线程的阻塞，如果主线程发生了阻塞，其他所有请求可能都会超时，超时越来越多，会造成 Redis 连接耗尽，产生各种异常。</p>\n<p>删除大 key 时建议采用<font color='cornflowerblue'>分批次删除</font>和<font color='cornflowerblue'>异步删除</font>的方式进行。</p>\n<h3 id=\"清空数据库\"><a class=\"anchor\" href=\"#清空数据库\">#</a> 清空数据库</h3>\n<p>清空数据库和上面 bigkey 删除也是同样道理，<font color='red'> <code>flushdb</code> 、 <code>flushall</code>  也涉及到删除和释放所有的键值对，也是 Redis 的阻塞点</font>。</p>\n<h3 id=\"集群扩容-缩容\"><a class=\"anchor\" href=\"#集群扩容-缩容\">#</a> 集群扩容、缩容</h3>\n<p>Redis 集群可以进行<font color='red'>节点的动态扩容、缩容</font>，这一过程目前还处于半自动状态，需要人工介入。</p>\n<p>在扩缩容的时候，需要进行<font color='red'>数据迁移</font>。而 Redis 为了保证迁移的一致性，<font color='red'>迁移所有操作都是同步操作</font>。</p>\n<p>执行迁移时，两端的 Redis 均会进入时长不等的<font color='red'>阻塞</font>状态，对于小 Key，该时间可以忽略不计，但如果一旦 Key 的内存使用过大，严重的时候会触发集群内的故障转移，造成不必要的切换。</p>\n<h3 id=\"swap内存交换\"><a class=\"anchor\" href=\"#swap内存交换\">#</a> Swap（内存交换）</h3>\n<p>Linux 中的 Swap 常被称为内存交换。类似于 Windows 中的虚拟内存，就是<font color='red'>当内存不足的时候，把一部分硬盘空间虚拟成内存使用，从而解决内存容量不足的情况</font>。因此，Swap 分区的作用就是<font color='red'>牺牲硬盘，增加内存</font>，解决 VPS 内存不够用或者爆满的问题。</p>\n<p><strong><font color='red'>Swap 对于 Redis 来说是非常致命的，因为 Redis 保证高性能的一个重要前提是所有的数据在内存中</font></strong>。如果操作系统把 Redis 使用的部分内存换出硬盘，由于内存与硬盘的读写速度差几个数量级，会导致发生交换后的 Redis 性能急剧下降。</p>\n<p>识别 Redis 发生 Swap 的检查方法如下：</p>\n<p>1、查询 Redis 进程号</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>reids-cli <span class=\"token parameter variable\">-p</span> <span class=\"token number\">6383</span> info server <span class=\"token operator\">|</span> <span class=\"token function\">grep</span> process_id</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>process_id: <span class=\"token number\">4476</span></pre></td></tr></table></figure><p>2、根据进程号查询内存交换信息</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">cat</span> /proc/4476/smaps <span class=\"token operator\">|</span> <span class=\"token function\">grep</span> Swap</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>Swap: 0kB</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>Swap: 0kB</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>Swap: 4kB</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>Swap: 0kB</pre></td></tr><tr><td data-num=\"6\"></td><td><pre>Swap: 0kB</pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span>.</pre></td></tr></table></figure><p>如果交换量都是 0KB 或者个别的是 4KB，则正常。</p>\n<p>预防内存交换的方法：</p>\n<ul>\n<li>保证机器充足的可用内存</li>\n<li>确保所有 Redis 实例设置最大可用内存 (maxmemory)，防止极端情况 Redis 内存不可控的增长</li>\n<li>降低系统使用 swap 优先级，如 <code>echo 10 &gt; /proc/sys/vm/swappiness</code></li>\n</ul>\n<h3 id=\"cpu-竞争\"><a class=\"anchor\" href=\"#cpu-竞争\">#</a> CPU 竞争</h3>\n<p><font color='red'>Redis 是典型的 CPU 密集型应用，不建议和其他多核 CPU 密集型服务部署在一起</font>。当其他进程过度消耗 CPU 时，将严重影响 Redis 的吞吐量。</p>\n<p>可以通过  <code>reids-cli --stat</code>  获取当前 Redis 使用情况。通过  <code>top</code>  命令获取进程对 CPU 的利用率等信息，通过  <code>info commandstats</code>  统计信息分析出命令不合理开销时间，查看是否是因为高算法复杂度或者过度的内存优化问题。</p>\n<h3 id=\"网络问题\"><a class=\"anchor\" href=\"#网络问题\">#</a> 网络问题</h3>\n<p>连接拒绝、网络延迟，网卡软中断等网络问题也可能会导致 Redis 阻塞。</p>\n<h1 id=\"redis-发布订阅pubsub\"><a class=\"anchor\" href=\"#redis-发布订阅pubsub\">#</a> Redis 发布订阅（pub/sub）</h1>\n<blockquote>\n<p>这是 Redis 的第一代消息中间件，第二代是 Stream，然而<strong>一般使用的都是更加成熟的第三方消息中间件</strong>。</p>\n<p><strong>了解即可</strong>，实际工作中用的很少，一般都是将 Redis 用作<strong>分布式缓存</strong>。</p>\n</blockquote>\n<h2 id=\"消息系统\"><a class=\"anchor\" href=\"#消息系统\">#</a> 消息系统</h2>\n<p>发布 / 订阅，即 pub/sub，是<font color='red'>一种消息通信模式</font>：发布者也称为消息生产者，生产和发送消息到存储系统；订阅者也称为消息消费者，从存储系统接收和消费消息。这个存储系统可以是文件系统 FS、消息中间件 MQ、数据管理系统 DBMS，也可以是 Redis。<font color='red'>整个消息发布者、订阅者、存储系统称为消息系统</font>。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231207161229390.png\" alt=\"image-20231207161229390\" /></p>\n<p>消息系统中的订阅者订阅了某类消息后，只要存储系统中存在该类消息，其就可不断的接收并消费这些消息。当存储系统中没有该消息后，订阅者的接收、消费阻塞。而当发布者将消息写入到存储系统后，会立即唤醒订阅者。当存储系统放满时，不同的发布者具有不同的处理方式：有的会阻塞发布者的发布，等待可用的存储空间；有的则会将多余的消息丢失。</p>\n<p>当然，不同的消息系统消息的发布 / 订阅方式也是不同的。例如 RocketMQ、 Kafka 等消息中间件构成的消息系统中，发布 / 订阅的消息都是以<font color='gree'>主题 Topic </font>分类的。而 Redis 构成的消息系统中，发布 / 订阅的消息都是以<font color='gree'>频道 Channel </font>分类的。</p>\n<h2 id=\"pubsub-简介\"><a class=\"anchor\" href=\"#pubsub-简介\">#</a> pub/sub 简介</h2>\n<p>Redis 发布订阅（pub/sub）是一种消息通信模式：<font color='red'>发送者 (PUBLISH) 发送消息，订阅者 (SUBSCRIBE) 接收消息</font>，可以实现进程间的消息传递。</p>\n<p>一言蔽之：Redis 可以通过发布订阅实现消息的引导和分流，实现消息中间件 MQ 的功能。但是<font color='red'>不推荐使用</font>该功能，专业的事情交给专业的中间件处理，redis 就做好分布式缓存功能。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230807173639960.png\" alt=\"image-20230807173639960\" /></p>\n<center>Redis客户端可以订阅任意数量的频道，类似微信关注多个公众号</center>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230807173711847.png\" alt=\"image-20230807173711847\" /></p>\n<center>当有新消息通过PUBLISH命令发送给频道时\n</center>\n<p>小结：发布 / 订阅其实是<strong>一个轻量的队列</strong>，只不过<strong>数据不会被持久化</strong>，一般<strong>用来处理实时性较高的异步消息</strong>。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230807173943443.png\" alt=\"image-20230807173943443\" /></p>\n<h2 id=\"相关命令\"><a class=\"anchor\" href=\"#相关命令\">#</a> 相关命令</h2>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>介绍</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>PUBLISH</code>  channel message</td>\n<td>发布一个频道的消息。返回值为接收到该消息的订阅者数量。</td>\n</tr>\n<tr>\n<td><code>SUBSCRIBE</code>  channel [channel ...]</td>\n<td>同时订阅任意数量的 channel。在输出了订阅了主题后，命令处于阻塞状态，等待相关 channel 的消息。</td>\n</tr>\n<tr>\n<td><code>PSUBSCRIBE</code>  pattern [pattern …]</td>\n<td>订阅一个或多个符合给定模式 pattern 的频道 channel。这里的 pattern 只能使用通配符 *。例如，it* 可以匹配所有以 it 开头的频道，像 it.news、it.blog、 it.tweets 等；news.* 可以匹配所有以 news. 开头的频道，像 news.global.today、<span class=\"exturl\" data-url=\"aHR0cDovL25ld3MuaXQ=\">news.it</span> 等。</td>\n</tr>\n<tr>\n<td><code>UNSUBSCRIBE</code>  [channel [channel …]]</td>\n<td>退订指定的频道。如果没有频道被指定，也就是一个无参数的 UNSUBSCRIBE 命令被执行，那么客户端使用 SUBSCRIBE 命令订阅的所有频道都会被退订。在这种情况下，命令会返回一个信息，告知客户端所有被退订的频道。</td>\n</tr>\n<tr>\n<td><code>PUNSUBSCRIBE</code>  [channel [channel …]]</td>\n<td>退订一个或多个符合给定模式的频道。这里的 pattern 也只能使用通配符 *。</td>\n</tr>\n<tr>\n<td><code>PUBSUB</code>  &lt;subcommand&gt; [argument [argument …]]</td>\n<td>PUBSUB 是一个<font color='red'>查看订阅与发布系统状态</font>的<font color='red'>内省命令集</font>，它由数个不同格式的子命令组成。</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"缺点-4\"><a class=\"anchor\" href=\"#缺点-4\">#</a> 缺点</h2>\n<ul>\n<li>\n<p>在 Redis 系统中 **<font color='red'>发布的消息不能持久化</font>**。因此，<font color='red'>必须先执行订阅，再等待消息发布</font>。如果先发布了消息，那么该消息由于没有订阅者，消息将被直接丢弃。</p>\n</li>\n<li>\n<p>消息只管发送，对于发布者而言消息是即发即失的，不管接收，也 **<font color='red'>没有 ACK 机制</font>**，无法保证消息的消费成功。</p>\n</li>\n<li>\n<p>以上的缺点导致 **<font color='#B32015'>Redis 的 Pub/Sub 模式就像个小玩具</font>**，在生产环境中几乎无用武之地。</p>\n<blockquote>\n<p>为此 Redis5.0 版本新增了 Stream 数据结构，不但支持多播，还支持数据持久化，相比 Pub/Sub 更加的强大，但是也不推荐使用。</p>\n</blockquote>\n</li>\n</ul>\n<h1 id=\"redis-集群高可用\"><a class=\"anchor\" href=\"#redis-集群高可用\">#</a> <mark>🌟Redis 集群（高可用）</mark></h1>\n<blockquote>\n<p>Redis 为了支持高可用（HA），有 2 套机制：</p>\n<ul>\n<li>主从复制（replica）+ 哨兵（sentinel）</li>\n<li>集群（cluster）</li>\n</ul>\n</blockquote>\n<p>为了避免 Redis 的单点故障问题，我们可以搭建一个 Redis 集群，将数据备份到集群中的其它节点上。若一个 Redis 节点宕机，则由集群中的其它节点顶上。</p>\n<h2 id=\"主从复制replica\"><a class=\"anchor\" href=\"#主从复制replica\">#</a> 主从复制（replica）</h2>\n<h3 id=\"是什么-8\"><a class=\"anchor\" href=\"#是什么-8\">#</a> 是什么</h3>\n<blockquote>\n<p>承上启下的一节，前文都是在单机场景下，从此开始介绍多台 Redis 机器的场景，即<strong>通过主从复制支持多可用性、故障转移</strong>。</p>\n</blockquote>\n<p>Redis 的主从集群是一个<font color='red'>“一主多从” 的读写分离集群</font>。集群中的 <strong><font color='red'>Master 节点负责处理客户端的读写请求，而 Slave 节点仅能处理客户端的读请求</font></strong>。之所以要将集群搭建为读写分离模式，主要原因是，对于数据库集群，写操作压力一般都较小，压力大多数来自于读操作请求。所以，只有一个节点负责处理写操作请求即可。</p>\n<p>当 Master 节点上的数据变化时，会自动将新数据<font color='red'>异步复制</font>到其他 Slave 节点上。</p>\n<h3 id=\"作用\"><a class=\"anchor\" href=\"#作用\">#</a> 作用</h3>\n<p>Redis 主从复制（replica）的功能如下：</p>\n<ul>\n<li><strong><font color='red'>读写分离</font></strong></li>\n<li><strong>容灾恢复</strong></li>\n<li><strong>数据备份</strong></li>\n<li><strong>水平扩容，支撑高并发</strong></li>\n</ul>\n<h3 id=\"基本命令\"><a class=\"anchor\" href=\"#基本命令\">#</a> 基本命令</h3>\n<ul>\n<li>\n<p><code>INFO replication</code> ：以一种易于理解和阅读的格式，<font color='red'>返回关于当前 Redis 服务器的<strong>直接主 / 从</strong>复制信息</font></p>\n</li>\n<li>\n<p><code>REPLICAOF masterIp masterPort</code> ：<font color='red'>修改当前 Redis 服务器的主 / 从复制设置（自动配置）</font></p>\n<blockquote>\n<p>一般写入进 redis.conf 配置文件内</p>\n</blockquote>\n</li>\n<li>\n<p><code>SLAVEOF masterIp masterPort</code> ：将当前 Redis 服务器<font color='red'>转变为指定服务器的从属服务器</font>（手动配置）</p>\n<ul>\n<li>每次与 master 断开之后，都需要<font color='red'>重新连接</font>，除非你配置进 redis.conf 文件</li>\n<li>在运行期间修改 slave 节点的信息，如果该数据库已经是某个主数据库的从数据库，那么会停止和原主数据库的同步关系，转而和新的主数据库同步，<font color='red'>改换门庭</font></li>\n</ul>\n</li>\n<li>\n<p><code>SLAVEOF NO ONE</code> ：将使得这个从属服务器关闭复制功能，并从从属服务器<font color='red'>转回主服务器，自立为王</font>，同时原来同步所得的数据集不会被丢弃。</p>\n</li>\n</ul>\n<h3 id=\"常用的3招\"><a class=\"anchor\" href=\"#常用的3招\">#</a> 常用的 3 招</h3>\n<p>配置方法：<strong><font color='#B32015'>配从不配主</font></strong></p>\n<ol>\n<li>\n<p>master 如果配置了  <code>requirepass</code>  参数，需要密码登陆</p>\n</li>\n<li>\n<p>那么 slave 就要配置  <code>masterauth</code>  来设置校验密码，否则 master 会拒绝 slave 的访问请求</p>\n</li>\n</ol>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230807183910365.png\" alt=\"image-20230807183910365\" /></p>\n<h4 id=\"一主二从\"><a class=\"anchor\" href=\"#一主二从\">#</a> 一主二从</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230807201752116.png\" alt=\"image-20230807201752116\" /></p>\n<h5 id=\"方案1配置文件固定写死\"><a class=\"anchor\" href=\"#方案1配置文件固定写死\">#</a> 方案 1：配置文件固定写死</h5>\n<ol>\n<li>\n<p>配从（6380 和 6381）不配主</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230807193239828.png\" alt=\"image-20230807193239828\" /></p>\n</li>\n<li>\n<p>依次启动 master 和两台 slave</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230807193418057.png\" alt=\"image-20230807193418057\" /></p>\n</li>\n<li>\n<p>查看主从关系</p>\n<ol>\n<li>\n<p>通过日志文件：通过 <code>vim 6379.log</code>  查看 master 日志，通过 <code> vim 6380/6381.log</code>  查看 slave 日志</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230807193701621.png\" alt=\"image-20230807193701621\" /></p>\n<center>master日志</center>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230807193733743.png\" alt=\"image-20230807193733743\" /></p>\n<center>slave日志</center>\n</li>\n<li>\n<p>通过命令： <code>info relication</code></p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230807193843707.png\" alt=\"image-20230807193843707\" /></p>\n<center>master的主从复制信息</center>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230807193915854.png\" alt=\"image-20230807193915854\" /></p>\n<center>slave的主从复制信息</center>\n</li>\n</ol>\n</li>\n</ol>\n<h5 id=\"主从复制问题演示\"><a class=\"anchor\" href=\"#主从复制问题演示\">#</a> 主从复制问题演示</h5>\n<ul>\n<li>\n<p>问题 1：<strong>slave 不能执行写命令！</strong></p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230807194936720.png\" alt=\"image-20230807194936720\" /></p>\n</li>\n<li>\n<p>问题 2：slave 切入点问题。当某台 slave shutdown 并重启后，<strong>slave 对 master 首次进行全量复制，然后进行增量复制</strong>。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230807194924560.png\" alt=\"image-20230807194924560\" /></p>\n</li>\n<li>\n<p>问题 3：master shutdown 后，slave 原地待命，数据仍可以正常使用，<strong>slave 等待 master 重启归来</strong>！</p>\n</li>\n<li>\n<p>问题 4：shutdown 后的<strong> master 重启归来，主从关系还在！slave 还能顺利复制！</strong></p>\n</li>\n</ul>\n<h5 id=\"方案2命令操作手动指定\"><a class=\"anchor\" href=\"#方案2命令操作手动指定\">#</a> 方案 2：命令操作手动指定</h5>\n<ol>\n<li>\n<p>slave 停机并去掉配置项，清空主从关系。此时 3 机都是 master，互不从属。</p>\n</li>\n<li>\n<p>在预设的 2 个 slave 上执行命令 <code>SLAVEOF masterIp masterHost</code>  指定 master</p>\n</li>\n</ol>\n<p>这种情况下，<strong><font color='red'>若 slave shutdown 并重启，主从关系就不存在了（因为没有设置配置文件）！</font></strong></p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230807200155294.png\" alt=\"image-20230807200155294\" /></p>\n<h5 id=\"配置-vs-命令\"><a class=\"anchor\" href=\"#配置-vs-命令\">#</a> 配置 vs 命令</h5>\n<p><strong><font color='red'>配置（即方案 1）持久稳定，命令（即方案 2）临时生效</font></strong>。</p>\n<h4 id=\"薪火相传\"><a class=\"anchor\" href=\"#薪火相传\">#</a> 薪火相传</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230807202217260.png\" alt=\"image-20230807202217260\" /></p>\n<p>要点：</p>\n<ul>\n<li>slave（6380）也可以作为其他 slave（6381）的 master，接收其连接和同步请求，可以<strong>有效减轻主 master（6379）的写压力</strong>。</li>\n<li>改变 master 的命令： <code>SLAVEOF newMasterIp newMasterPort</code></li>\n<li><strong><font color='red'>slave（6380）仍然无法执行写命令！</font></strong></li>\n<li>slave（6381）中途变更转向，master 从 6379 变为 6380，<strong><font color='red'>会清除之前 master（6379）的数据，重新建立拷贝新的 master（6380）的数据</font></strong>。</li>\n</ul>\n<h4 id=\"自立为王\"><a class=\"anchor\" href=\"#自立为王\">#</a> 自立为王</h4>\n<blockquote>\n<p>slave 转成 master</p>\n</blockquote>\n<p>命令 <code>SLAVEOF NO ONE</code> ：<strong><font color='red'>停止与其他数据库的同步，清空数据，转成 Master 数据库</font></strong>。</p>\n<h3 id=\"一主二从的案例演示\"><a class=\"anchor\" href=\"#一主二从的案例演示\">#</a> 一主二从的案例演示</h3>\n<h4 id=\"架构说明\"><a class=\"anchor\" href=\"#架构说明\">#</a> 架构说明</h4>\n<p>一主二从，一个 master，两个 slave，示意图如下：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230807185141276.png\" alt=\"image-20230807185141276\" /></p>\n<p>拷贝多份配置文件，分别命名为：</p>\n<ul>\n<li>redis6379.conf</li>\n<li>redis6380.conf</li>\n<li>redis6381.conf</li>\n</ul>\n<h4 id=\"口诀\"><a class=\"anchor\" href=\"#口诀\">#</a> <mark>口诀</mark></h4>\n<p>前提：三边网络互相 ping 通，同时注意防火墙配置。</p>\n<p>三大命令：</p>\n<ul>\n<li>主从复制： <code>REPLICAOF masterIp masterPort</code> ，配从不配主</li>\n<li>改换门庭： <code>SLAVEOF masterIp masterPort</code></li>\n<li>自立为王： <code>SLAVEOF NO ONE</code></li>\n</ul>\n<h4 id=\"修改配置文件的操作细节\"><a class=\"anchor\" href=\"#修改配置文件的操作细节\">#</a> 修改配置文件的操作细节</h4>\n<p>以 redis6379.conf 为例，步骤如下：</p>\n<ol>\n<li>\n<p>要求 Redis 后台运行，不要弹出命令行窗口： <code>daemonize yes</code></p>\n</li>\n<li>\n<p>取消 IP 的绑定，否则影响远程 IP 连接，注释掉 <code>bind 127.0.0.1</code></p>\n</li>\n<li>\n<p>关闭保护模式，否则影响远程访问 / 连接： <code>protected-mode no</code></p>\n</li>\n<li>\n<p>指定端口： <code>port 6379</code></p>\n</li>\n<li>\n<p>指定当前工作目录， <code>dir /myredis</code></p>\n</li>\n<li>\n<p>设置 pid（进程 id）文件的路径和名字： <code>pidfile /var/run/redis_6379.pid</code></p>\n</li>\n<li>\n<p>设置 log 文件的路径和名字： <code>logfile &quot;/myredis/6379.log&quot;</code></p>\n</li>\n<li>\n<p><font color='red'>设置 Redis 服务器的密码</font>： <code>requirepass 111111</code></p>\n<blockquote>\n<p>master、slave 均配置</p>\n</blockquote>\n</li>\n<li>\n<p>设置 rdb 文件的名称： <code>dbfilename dump6379.rdb</code></p>\n</li>\n<li>\n<p>若开启 AOF，还需设置 aof 文件的名字：appendfilename 。这里不开启了。</p>\n</li>\n<li>\n<p><font color='red'>slave 设置所访问的 master 的 IP 和端口： <code>replicaof masterIp 6379</code> ，并设置通行密码 <code>masterauth &quot;111111&quot;</code> </font></p>\n<blockquote>\n<p>slave 需要配置</p>\n</blockquote>\n</li>\n</ol>\n<h3 id=\"原理工作流程\"><a class=\"anchor\" href=\"#原理工作流程\">#</a> <mark>🌟原理（工作流程）</mark></h3>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/developer_1b16183.png\" alt=\"developer_1b16183\" /></p>\n<ol>\n<li>\n<p><strong><font color='#B32015'>slave 首次连接，请求完全同步（sync）</font></strong>：slave <font color='red'>首次连接</font> master 后会发送一个  <code>sync</code>  命令，<font color='red'>请求完全同步（全量复制）</font></p>\n<blockquote>\n<p>执行一次完全同步（<font color='red'>全量复制</font>），slave 自身原有数据会被<font color='red'>覆盖清除</font></p>\n</blockquote>\n</li>\n<li>\n<p><strong><font color='#B32015'>master 保存 RDB 快照，同时缓存写命令，响应给所有 slave 进行初始化（完全同步）</font></strong>：</p>\n<ul>\n<li>master 节点收到  <code>sync</code>  命令后会开始在后台<font color='red'>保存快照</font>(即 RDB 持久化，主从复制时会触发 RDB)，同时<font color='red'>缓存所有接收到的写命令</font>，master 节点执行 RDB 持久化完后，<font color='red'>master 将 rdb 快照文件和所有缓存的写命令发送到所有 slave</font>，以完成一次完全同步</li>\n<li>而 slave 服务在接收到数据库文件数据后，将其<font color='red'>存盘并加载到内存中</font>，从而<font color='red'>完成复制初始化</font></li>\n</ul>\n</li>\n<li>\n<p><strong><font color='#B32015'>心跳持续，保持通信</font></strong>：master 向 slave 发出 PING 包，周期默认 10 秒。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230807205137957.png\" alt=\"image-20230807205137957\" /></p>\n</li>\n<li>\n<p><strong><font color='#B32015'>进入平稳，增量复制</font></strong>：master 继续将新的所有收集到的写命令自动依次传给 slave，完成同步</p>\n</li>\n<li>\n<p><strong><font color='#B32015'>slave 下线，重连续传</font></strong>：假设某台 slave 宕机并重启了，master 会检查 backlog 里面的 <code>offset</code> ，master 和 slave 都会保存一个复制的  <code>offset</code>  和一个 masterId， <code>offset</code>  是保存在 backlog 中的。<font color='red'>master 只会把已经复制的  <code>offset</code>  后面的数据复制给 slave</font>，类似 **<font color='red'>断点续传</font>**。</p>\n</li>\n</ol>\n<h3 id=\"分级管理\"><a class=\"anchor\" href=\"#分级管理\">#</a> 分级管理</h3>\n<p>若 Redis 主从集群中的 Slave 较多时，它们的数据同步过程会对 Master 形成较大的性能压力。此时可以<font color='red'>对这些 Slave 进行分级管理</font>。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231210144213994.png\" alt=\"image-20231210144213994\" /></p>\n<p>设置方式很简单，只需要 **<font color='red'>让低级别 Slave 指定其 slaveof 的主机为其上一级 Slave 即可</font>**。不过，上一级 Slave 的状态仍为 Slave，只不过，其是更上一级的 Slave。</p>\n<p>例如，指定 6382 主机为 6381 主机的 Slave，而 6381 主机仍为真正的 Master 的 Slave。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231210144439772.png\" alt=\"image-20231210144439772\" /></p>\n<p>此时会发现， Master 的 Slave 只有 6381 一个主机。</p>\n<h3 id=\"容灾冷处理\"><a class=\"anchor\" href=\"#容灾冷处理\">#</a> 容灾冷处理</h3>\n<p>在 Master/Slave 的 Redis 集群中，<font color='red'>若 Master 出现宕机怎么办呢？</font>有两种处理方式：</p>\n<ul>\n<li><font color='red'>冷处理</font>：手工角色调整，使 Slave 晋升为 Master</li>\n<li><font color='red'>热处理（哨兵模式）</font>：实现 Redis 集群的高可用 HA</li>\n</ul>\n<p>无论 Master 是否宕机，Slave 都可通过 slaveof no one 将自己由 Slave 晋升为 Master。如果其原本就有下一级的 Slave，那么，其就直接变为了这些 Slave 的真正的 Master 了。而原来的 Master 也会失去这个原来的 Slave。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231210144722685.png\" alt=\"image-20231210144722685\" /></p>\n<h3 id=\"缺点-5\"><a class=\"anchor\" href=\"#缺点-5\">#</a> 缺点</h3>\n<ul>\n<li>\n<p><strong><font color='red'>复制（同步）延时</font></strong></p>\n<blockquote>\n<p>由于所有的写操作都是先在 Master 上操作，然后同步更新到 Slave 上，所以从 Master 同步到 Slave 机器有一定的延迟，当<font color='red'>系统很繁忙</font>的时候，延迟问题会更加严重，<font color='red'>Slave 机器数量的增加</font>也会使这个问题更加严重。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230807210259342.png\" alt=\"image-20230807210259342\" /></p>\n</blockquote>\n</li>\n<li>\n<p><strong><font color='red'>Master 宕机后群龙无首</font></strong>！默认情况下，<font color='red'>不会从 slave 中重选一个 master</font>，系统会陷入半瘫痪状态（<font color='red'>只能读取，不能写入</font>）那客户端的写命令如何执行啊？</p>\n<blockquote>\n<p>期待有一种高可用的备份、恢复机制，能够从剩下的 slave 中选出一个 master！（<strong><font color='#B32015'>无人值守安装：哨兵！</font></strong>）</p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"哨兵机制sentinel\"><a class=\"anchor\" href=\"#哨兵机制sentinel\">#</a> 哨兵机制（sentinel）</h2>\n<blockquote>\n<p>目的：为了实现主从集群中的 **<font color='red'>自动化的故障转移</font>**！</p>\n</blockquote>\n<p>普通的主从复制方案下，一旦 master 宕机，我们需要从 slave 中手动选择一个新的 master，同时需要修改应用方的主节点地址，还需要命令所有从节点去复制新的主节点，整个过程需要人工干预。人工干预大大增加了问题的处理时间以及出错的可能性。</p>\n<p>我们可以借助 Redis 官方的 Sentinel（哨兵）方案来帮助我们解决这个痛点，实现自动化的故障转移。</p>\n<h3 id=\"是什么-9\"><a class=\"anchor\" href=\"#是什么-9\">#</a> 是什么</h3>\n<p>Redis Sentinel 实现 Redis 集群高可用，<font color='red'>只是在主从复制实现集群的基础下，多了一个 Sentinel 角色来帮助我们监控 Redis 节点的运行状态，并自动实现故障转移</font>。</p>\n<p><strong><font color='red'>当 master 节点出现故障的时候，Sentinel 会自动根据一定的规则选出一个 slave 升级为 master，从而实现自动化的故障转移，确保整个 Redis 系统的高可用性（HA）</font></strong>。整个过程完全自动，不需要人工介入。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/redis-master-slave-sentinel.png\" alt=\"redis-master-slave-sentinel.png\" /></p>\n<h3 id=\"作用-2\"><a class=\"anchor\" href=\"#作用-2\">#</a> 作用</h3>\n<p>Sentinel 节点的功能如下：</p>\n<ul>\n<li><strong><font color='red'>监控</font></strong>：Sentinel 可以监控所有 Redis 节点（包括 Sentinel 节点自身）的<font color='red'>状态是否正常</font>。</li>\n<li><strong><font color='red'>故障转移</font></strong>：如果一个 master 出现故障，Sentinel 会帮助我们实现故障转移，<font color='red'>自动将某一台 slave 升级为 master</font>，确保整个 Redis 系统的可用性。</li>\n<li><strong><font color='red'>消息通知</font></strong>：<font color='red'>通知 slave 新的 master 连接信息</font>，让它们执行 replicaof 成为新的 master 的 slave。</li>\n<li><strong><font color='red'>配置中心</font></strong>：<font color='red'>客户端通过连接 sentinel 来获得 master 的地址</font>，如果发生故障转移，sentinel 会通知新的 master 链接信息给客户端。</li>\n</ul>\n<p>Sentinel 本身设计的就是一个分布式系统，<font color='red'>建议多个 sentinel 节点协作运行</font>，好处是：</p>\n<ul>\n<li>多个 sentinel 节点通过<font color='red'>投票</font>的方式来确定 master 节点是否真的不可用，<font color='red'>避免误判</font>（比如网络问题可能会导致误判）。</li>\n<li>Sentinel 自身就是<font color='red'>高可用</font>。</li>\n</ul>\n<h3 id=\"sentinel-配置文件sentinelconf\"><a class=\"anchor\" href=\"#sentinel-配置文件sentinelconf\">#</a> Sentinel 配置文件（sentinel.conf）</h3>\n<blockquote>\n<p>默认在 /opt/redis-7.0.0 目录下</p>\n</blockquote>\n<p>Sentinel（哨兵）只是 Redis 的一种运行模式，不提供读写服务，默认运行在 <font color='red'>26379</font> 端口上，依赖于 Redis 工作。</p>\n<p>Redis 在 Sentinel 这种特殊的运行模式下，使用专门的命令表，也就是说普通模式运行下的 Redis 命令将无法使用。</p>\n<p>通过下面的命令就可以<font color='red'>让 Redis 以 Sentinel 的方式运行</font>:</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>redis-sentinel /path/to/sentinel.conf</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>或者</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>redis-server /path/to/sentinel.conf <span class=\"token parameter variable\">--sentinel</span></pre></td></tr></table></figure><p>Redis 源码中的<font color='red'>  <code>sentinel.conf</code>  文件是用来配置 Sentinel 的</font>，一个常见的最小配置如下所示：</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">// 指定要监视的 master</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token comment\">// 127.0.0.1 6379 为 master 地址</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token comment\">// 2 表示当有 2 个 sentinel 认为 master 失效时，master 才算真正失效</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>sentinel monitor mymaster <span class=\"token number\">127.0</span><span class=\"token number\">.0</span><span class=\"token number\">.1</span> <span class=\"token number\">6379</span> <span class=\"token number\">2</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token comment\">//master 节点宕机多长时间才会被 sentinel 认为是失效</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>sentinel down<span class=\"token operator\">-</span>after<span class=\"token operator\">-</span>milliseconds mymaster <span class=\"token number\">60000</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>sentinel failover<span class=\"token operator\">-</span>timeout mymaster <span class=\"token number\">180000</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>sentinel parallel<span class=\"token operator\">-</span>syncs mymaster <span class=\"token number\">1</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>sentinel monitor resque <span class=\"token number\">192.168</span><span class=\"token number\">.1</span><span class=\"token number\">.3</span> <span class=\"token number\">6380</span> <span class=\"token number\">4</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>sentinel down<span class=\"token operator\">-</span>after<span class=\"token operator\">-</span>milliseconds resque <span class=\"token number\">10000</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>sentinel failover<span class=\"token operator\">-</span>timeout resque <span class=\"token number\">180000</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token comment\">// 在发生主备切换时最多可以有 5 个 slave 同时对新的 master 进行同步</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>sentinel parallel<span class=\"token operator\">-</span>syncs resque <span class=\"token number\">5</span></pre></td></tr></table></figure><p>重点参数说明：</p>\n<ul>\n<li>\n<p><code>bind</code> ：服务监听地址，用于客户端连接，默认为本机地址</p>\n</li>\n<li>\n<p><code>daemonize</code> ：是否以后台 daemon（后台进程）方式运行，设为 yes</p>\n</li>\n<li>\n<p><code>protected-mode</code> ：是否开启安全保护模式，设为 no，否则影响远程访问 / 连接</p>\n</li>\n<li>\n<p><code>port</code> ：端口，默认是 26379</p>\n</li>\n<li>\n<p><code>logfile</code> ：日志文件路径</p>\n</li>\n<li>\n<p><code>pidfile</code> ：pid 文件路径</p>\n</li>\n<li>\n<p><code>dir</code> ：工作目录</p>\n</li>\n<li>\n<p><strong> <code>sentinel monitor &lt;master-name&gt; &lt;master-ip&gt; &lt;master-port&gt; &lt;quorum&gt;</code> </strong>：<font color='red'>设置 Sentinel 要监控的 master</font></p>\n<ul>\n<li>\n<p><code>quorum</code> ：<strong><font color='red'>判定 master 失效（<font color='cornflowerblue'>客观下线</font>）最少需要的仲裁 Sentinel 节点数</font></strong>，即同意故障转移的法定<font color='red'>投票数</font>。例如 quorum 为 2 表示当有 2 个 sentinel 认为 master 失效时，master 才算真正失效。</p>\n<blockquote>\n<p><strong>sentinel 定时向 master 发出 PING 包</strong>来确认 master 是否挂掉。</p>\n<p>但网络是不可靠的，有时某个 sentinel 可能因为<strong>网络拥堵</strong>没收到 master 的响应，从而<strong>误以为 master 已挂掉</strong>。因此需要多个 sentinel 都一致认为 master 已挂，才可进行主从切换、故障转移，保证了公平性和高可用。</p>\n</blockquote>\n</li>\n</ul>\n</li>\n<li>\n<p><code>sentinel auth-pass &lt;master-name&gt; &lt;password&gt;</code> ：设置连接 master 服务器的密码</p>\n</li>\n<li>\n<p><strong> <code>sentinel down-after-milliseconds &lt;master-name&gt; &lt;milliseconds&gt;</code> </strong>：指定如果 master 在多少毫秒之后没有应答 sentinel，sentinel 则主观上认为 master 下线（<strong><font color='cornflowerblue'>主观下线</font></strong>）</p>\n</li>\n<li>\n<p><code>sentinel parallel-syncs &lt;master-name&gt; &lt;nums&gt;</code> ：表示允许并行同步的 slave 个数，当 master 挂了后，哨兵会选出新的 master，此时，剩余的 slave 会向新的 master 发起同步数据</p>\n</li>\n<li>\n<p><code>sentinel failover-timeout &lt;master-name&gt; &lt;milliseconds&gt;</code> ：故障转移的超时时间。进行故障转移时，如果超过设置的毫秒，表示故障转移失败</p>\n</li>\n<li>\n<p><code>sentinel notification-script &lt;master-name&gt; &lt;script-path&gt; </code> ：配置当某一事件发生时所需要执行的脚本</p>\n</li>\n<li>\n<p><code>sentinel client-reconfig-script &lt;master-name&gt; &lt;script-path&gt;</code> ：客户端重新配置 master 参数脚本</p>\n</li>\n</ul>\n<h3 id=\"案例演示\"><a class=\"anchor\" href=\"#案例演示\">#</a> 案例演示</h3>\n<h4 id=\"架构说明-2\"><a class=\"anchor\" href=\"#架构说明-2\">#</a> 架构说明</h4>\n<p>**<font color='red'>如果想要实现高可用，建议将哨兵 Sentinel 配置成单数，且大于等于 3 台。</font>** 好处有二：</p>\n<ul>\n<li>防止某台 sentinel 无法连接到 master，导致误切换</li>\n<li>利于投票选举</li>\n</ul>\n<p>一个最简易的 Redis Sentinel 集群如下所示（官方文档中的一个例子），其中：</p>\n<ul>\n<li>3 个 Sentinel 节点</li>\n<li>1 个 Master 节点，2 个 Slave 节点</li>\n</ul>\n<p>如果 Master 出现问题，只要 Sentinel 集群其中的两个投票赞同的话，就会开始故障转移工作，从 2 个 Slave 中重新选出一个作为 master。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230808002037403.png\" alt=\"image-20230808002037403\" /></p>\n<h4 id=\"配置说明\"><a class=\"anchor\" href=\"#配置说明\">#</a> 配置说明</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230808105627695.png\" alt=\"image-20230808105627695\" /></p>\n<p>由于机器硬件关系，我们的 3 个哨兵都同时配置进 192.168.111.169 同一台机器，即<font color='red'>3 个哨兵和 master 在一台机器上</font>。</p>\n<p>配置这 3 个哨兵的配置文件：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230808104641977.png\" alt=\"image-20230808104641977\" /></p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230808104655030.png\" alt=\"image-20230808104655030\" /></p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230808104707250.png\" alt=\"image-20230808104707250\" /></p>\n<p>master 配置文件说明：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230808104812771.png\" alt=\"image-20230808104812771\" /></p>\n<h4 id=\"先测试正常的主从复制\"><a class=\"anchor\" href=\"#先测试正常的主从复制\">#</a> 先测试正常的主从复制</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230807201752116.png\" alt=\"image-20230807201752116\" /></p>\n<ol>\n<li>169 机器上新建 redis6379.conf 配置文件，由于 6379 后续可能会变成从机，需要设置访问新主机的密码，请设置 masterauth 项访问密码为 111111，不然后续可能报错 master_link_status:down</li>\n<li>172 机器上新建 redis6380.conf 配置文件，设置好 <code>replicaof \\&lt;masterip&gt; \\&lt;masterport&gt;</code> ，以及 masterauth 项访问密码为 111111</li>\n<li>173 机器上新建 redis6381.conf 配置文件，设置好 <code>replicaof \\&lt;masterip&gt; \\&lt;masterport&gt;</code> ，以及 masterauth 项访问密码为 111111</li>\n<li>启动 3 台机器实例：\n<ol>\n<li><code>redis-cli -a 111111 -p 6379</code></li>\n<li><code>redis-cli -a 111111 -p 6380</code></li>\n<li><code>redis-cli -a 111111 -p 6381</code></li>\n</ol>\n</li>\n<li>测试</li>\n</ol>\n<h4 id=\"sentinel-来了\"><a class=\"anchor\" href=\"#sentinel-来了\">#</a> Sentinel 来了！</h4>\n<blockquote>\n<p>sentinel 之间通过 master 来获取：</p>\n<ul>\n<li>slave 信息</li>\n<li>其他 sentinel 信息</li>\n</ul>\n<p>从而实现通信。</p>\n</blockquote>\n<ol>\n<li>\n<p>在 master（6379）这台机器上<font color='red'>启动 3 个 sentinel</font>（26379/26380/26381），完成监控</p>\n<ol>\n<li><code>redis-sentinel sentinel26379.conf --sentinel</code></li>\n<li><code>redis-sentinel sentinel26380.conf --sentinel</code></li>\n<li><code>redis-sentinel sentinel26381.conf --sentinel</code></li>\n</ol>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230808110202022.png\" alt=\"image-20230808110202022\" /></p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230808110255818.png\" alt=\"image-20230808110255818\" /></p>\n</li>\n<li>\n<p>查看哨兵的日志文件 <code>sentinel26379.log</code> ，可以看到<font color='red'>当前 sentinel 的信息</font>、<font color='red'>所监控 master 以及 slave 的信息</font>、<font color='red'>其他 sentinel 的信息</font>：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230808111127304.png\" alt=\"image-20230808111127304\" /></p>\n</li>\n<li>\n<p>再测试一次主从复制，木有问题</p>\n</li>\n</ol>\n<h4 id=\"当-master-挂了\"><a class=\"anchor\" href=\"#当-master-挂了\">#</a> 当 master 挂了！</h4>\n<p>通过命令 <code>SHUTDOWN</code>  手动关闭 6379 服务器，模拟 master 挂掉。</p>\n<p>思考以下问题：</p>\n<ul>\n<li>\n<p>问题 1：<font color='red'>两台 slave 上的数据还 OK！</font></p>\n</li>\n<li>\n<p>问题 2：** 会从这两台 slave 上选出新的 master！** 具体信息可查看 sentinel 的 log 文件。</p>\n<blockquote>\n<p>在此过程中，哨兵配置文件 <code>sentinel.conf</code>  中会自动生成内容信息</p>\n</blockquote>\n</li>\n<li>\n<p>问题 3：<strong>down 机的旧 master 重启归来，也只能拜认新 master，作它的 slave！</strong></p>\n</li>\n</ul>\n<p>在 master6379 宕机后，会出现两种错误：</p>\n<ul>\n<li>\n<p>Error：Server closed the connection</p>\n</li>\n<li>\n<p>Error：Broken pipe</p>\n<blockquote>\n<p><strong>broken pipe</strong>：pipe 是管道的意思，管道里面是数据流，通常是从文件或网络套接字读取的数据。<font color='red'>当该管道从另一端突然关闭时，会发生数据突然中断</font>，即是 broken，对于 socket 来说，可能是网络被拔出或另一端的进程崩溃。</p>\n<p><strong>如何解决</strong>：当该异常产生的时候，<font color='red'>对于服务端来说，并没有多少影响</font>。因为可能是某个客户端突然中止了进程导致了该错误。</p>\n<p><strong>总结</strong>：这个异常是<font color='red'>客户端读取超时</font>关闭了连接，这时候服务器端再向客户端已经断开的连接写数据时就发生了 broken pipe 异常！</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230808113740061.png\" alt=\"image-20230808113740061\" /></p>\n</blockquote>\n</li>\n</ul>\n<p>针对本次案例，分析谁是 master：</p>\n<ol>\n<li>6381 被选为新 master，上位成功</li>\n<li>以前的 6379 从 master 降级变成了 slave</li>\n<li>6380 还是 slave，只不过换了个新老大 6381 (6379 变 6381)，6380 还是 slave</li>\n</ol>\n<h4 id=\"对比新老master的配置文件\"><a class=\"anchor\" href=\"#对比新老master的配置文件\">#</a> 对比新老 master 的配置文件</h4>\n<p>旧 master（6379）的配置文件  <code>redis6379.conf</code>  中会自动生成以下内容，让 其去做新 master（6381）的 slave：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230808115231877.png\" alt=\"image-20230808115231877\" /></p>\n<p>新 master（6381）的配置文件  <code>redis6381.conf</code>  中：</p>\n<ul>\n<li>自动删掉  <code>replicaof</code>  参数的配置</li>\n<li>自动生成以下内容：</li>\n</ul>\n<p>结论：</p>\n<ul>\n<li>conf 文件的内容会被 sentinel 动态更改</li>\n<li>Master-Slave 切换后，master_redis.conf、slave_redis.conf 和 sentinel.conf 的内容都会发生改变，即<font color='red'>master_redis.conf 中会多一行 slaveof 的配置</font>，<font color='red'>sentinel.conf 的监控目标会随之调换</font></li>\n</ul>\n<h4 id=\"其他备注\"><a class=\"anchor\" href=\"#其他备注\">#</a> 其他备注</h4>\n<ul>\n<li>生产都是不同机房不同服务器，<strong>很少出现 Sentinel 全挂掉的情况</strong></li>\n<li><strong>可以同时监控多个 master</strong>，一行一个</li>\n</ul>\n<h3 id=\"sentinel-原理\"><a class=\"anchor\" href=\"#sentinel-原理\">#</a> <mark>🌟Sentinel 原理</mark></h3>\n<h4 id=\"三个定时任务\"><a class=\"anchor\" href=\"#三个定时任务\">#</a> 三个定时任务</h4>\n<p>Sentinel 维护着三个定时任务以监测 Redis 节点及其它 Sentinel 节点的状态：</p>\n<ul>\n<li>\n<p><font color='cornflowerblue'>info 任务</font>：每个 Sentinel 每隔 10 秒就会向 Redis 集群中的每个节点发送  <code>info</code>  命令，以<font color='red'>获得最新的 Redis 拓扑结构</font>。</p>\n</li>\n<li>\n<p><font color='cornflowerblue'>ping 任务</font>：每个 Sentinel 每隔 1 秒就会向所有 Redis 节点及其它 Sentinel 节点发送一条  <code>ping</code>  命令，以<font color='red'>检测这些节点的存活状态</font>。该任务<font color='red'>是判断节点在线状态的重要依据</font>。</p>\n</li>\n<li>\n<p><font color='cornflowerblue'>pub/sub 任务</font>：</p>\n<p>​\t每个 Sentinel 节点在启动时都会<font color='red'>向所有 Redis 节点订阅  <code>__sentinel__:hello</code>  主题的信息</font>，当 Redis 节点中该主题的信息发生了变化，就会立即通知到所有订阅者。</p>\n<p>​\t启动后，每个 Sentinel 节点每 2 秒就会向每个 Redis 节点发布一条  <code>__sentinel__:hello</code>  主题的信息，该信息是<font color='red'>当前 Sentinel 对每个 Redis 节点在线状态的判断结果及当前 Sentinel 节点信息</font>。</p>\n<p>​\t当 Sentinel 节点接收到  <code>__sentinel__:hello</code>  主题信息后，就会读取并解析这些信息，然后主要完成以下三项工作：</p>\n<ul>\n<li>如果发现<font color='red'>有新的 Sentinel 节点加入</font>，则记录下新加入 Sentinel 节点信息，并与其建立连接。</li>\n<li>如果发现<font color='red'>有 Sentinel Leader 选举的选票信息</font>，则执行 Leader 选举过程。</li>\n<li><font color='red'>汇总其它 Sentinel 节点对当前 Redis 节点在线状态的判断结果</font>，作为 Redis 节点客观下线的判断依据。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"redis-节点下线down判断\"><a class=\"anchor\" href=\"#redis-节点下线down判断\">#</a> Redis 节点下线（DOWN）判断</h4>\n<p>对于每个 Redis 节点在线状态的监控是由 Sentinel 完成的。</p>\n<h5 id=\"主观下线subjectively-down\"><a class=\"anchor\" href=\"#主观下线subjectively-down\">#</a> 主观下线（Subjectively DOWN）</h5>\n<p>每个 Sentinel 节点每秒就会向每个 Redis 节点发送  <code>ping</code>  心跳检测，如果 Sentinel 在 [down-after-milliseconds] 时间内<font color='red'>没有收到某 Redis 节点的回复</font>，则 Sentinel 节点就会对该 Redis 节点做出 “下线状态” 的判断。这个判断 **<font color='red'>仅仅是当前 Sentinel 节点的 “一家之言”</font>**，所以称为主观下线。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/redis-master-slave-sentinel-ping-sdown.png\" alt=\"redis-master-slave-sentinel-ping-sdown.png\" /></p>\n<h5 id=\"客观下线objectively-down\"><a class=\"anchor\" href=\"#客观下线objectively-down\">#</a> 客观下线（Objectively DOWN）</h5>\n<p>当 Sentinel 主观下线的节点是 master 时，该 Sentinel 节点会向每个其它 Sentinel 节点发送  <code>sentinel is-master-down-by-addr</code>  命令，以询问其对 master 在线状态的判断结果。这些 Sentinel 节点在收到命令后会向这个发问 Sentinel 节点响应 0（在线）或 1（下线）。<strong><font color='red'>当 Sentinel 收到超过 quorum 个（通常为过半）下线判断后，就会对 master 做出客观下线判断</font></strong>。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/redis-master-slave-sentinel-ping-odown.png\" alt=\"redis-master-slave-sentinel-ping-odown.png\" /></p>\n<h4 id=\"sentinel-leader-选举raft-算法\"><a class=\"anchor\" href=\"#sentinel-leader-选举raft-算法\">#</a> Sentinel Leader 选举（Raft 算法）</h4>\n<p><font color='red'>当 Sentinel 节点对 master 做出客观下线判断后，<strong>由 Sentinel Leader 来完成后续的故障转移</strong></font>。即 Sentinel 集群中的节点也并非是对等节点，是存在 Leader 与 Follower 的。</p>\n<p>Sentinel Leader 的选举是通过 <strong><font color='orange'>Raft 算法</font></strong> 实现的。Raft 算法比较复杂，后面会详细学习，这里仅简单介绍一下 **<font color='red'>大致思路（先到先得）</font>**：</p>\n<ol>\n<li>每个 Sentinel 选举参与者都具有当选 Leader 的资格，当其完成了 “客观下线” 判断后，就会立即 <font color='red'>“毛遂自荐”</font> 推选自己做 Leader，将自己的提案发送给所有 Sentinel 参与者。</li>\n<li>其它参与者在收到提案后，<font color='red'>只要自己手中的选票没有投出去，其就会立即通过该提案</font>，并将同意结果反馈给提案者。</li>\n<li>后续再过来的提案会由于该参与者没有了选票而被拒绝。</li>\n<li>当提案者收到了同意反馈数量大于等于 max (quorum， sentinelNum/2+1) 时，该提案者当选 Leader。</li>\n</ol>\n<p>说明：</p>\n<ul>\n<li>在网络没有问题的前提下，基本就是谁先做出了 “客观下线” 判断，谁就会首先发起 Sentinel Leader 的选举，谁就会得到大多数参与者的支持，谁就会当选 Leader。</li>\n<li><font color='red'>Sentinel Leader 选举在故障转移发生之前进行</font>。</li>\n<li><font color='red'>故障转移结束后 Sentinel 不再维护这种 Leader-Follower 关系</font>。</li>\n</ul>\n<h4 id=\"master-选举\"><a class=\"anchor\" href=\"#master-选举\">#</a> Master 选举</h4>\n<p>在进行故障转移时，Sentinel Leader 需要从所有 Redis 的 Slave 节点中选择出新的 Master。其选择算法为：</p>\n<ol>\n<li>\n<p>过滤掉所有主观下线的，或心跳没有响应 Sentinel 的，或 replica-priority 值为 0 的 Redis 节点</p>\n</li>\n<li>\n<p><strong>slave 优先级</strong>：在剩余 Redis 节点中选择出 <font color='red'> <code>replica-priority</code>  最小</font>的的节点列表。如果只有一个节点，则直接返回，否则，继续</p>\n</li>\n<li>\n<p><strong>复制进度</strong>：从优先级相同的节点列表中选择<font color='red'>复制偏移量最大</font>的节点。如果只有一个节点，则直接返回，否则，继续</p>\n</li>\n<li>\n<p><strong>runid（运行 id）</strong>：从复制偏移值量相同的节点列表中选择<font color='red'>runid 最小</font>的节点返回</p>\n</li>\n</ol>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230808165640759.png\" alt=\"image-20230808165640759\" /></p>\n<h4 id=\"故障转移failover流程\"><a class=\"anchor\" href=\"#故障转移failover流程\">#</a> 故障转移（failover）流程</h4>\n<ol>\n<li>\n<p><strong>集群正常运行</strong>：3 个 sentinel 监控一主二从集群，正常运行中</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230808161905591.png\" alt=\"image-20230808161905591\" /></p>\n</li>\n<li>\n<p><strong><font color='cornflowerblue'>SDown 主观下线（Subjectively Down）</font></strong>：指的是<font color='red'>单个 Sentinel 实例</font>对 master 服务器做出的下线判断（有可能是接收不到订阅，之间的网络不通等等原因）。如果 master 服务器在 [ <code>sentinel down-after-milliseconds</code> ] 给定的毫秒数之内没有回应 PING 命令，或者返回一个错误消息，那么这个 Sentinel 会主观的 (<font color='red'>单方面的</font>) 认为这个 master 不可以用了。</p>\n<blockquote>\n<p>sentinel 配置文件中的 <code>sentinel down-after-milliseconds &lt;masterName&gt; &lt;timeout&gt;</code>  设置了判断主观下线的时间长度，表示 master 被当前 sentinel 实例认定为失效的间隔时间。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230808162539926.png\" alt=\"image-20230808162539926\" /></p>\n</blockquote>\n</li>\n<li>\n<p><strong><font color='cornflowerblue'>ODown 客观下线（Objectively Down）</font></strong>：需要一定数量的 sentinel，<font color='red'>多个 sentinel 达成一致意见</font>才能认为一个 master 客观上已经宕掉。</p>\n<blockquote>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230808162827271.png\" alt=\"image-20230808162827271\" /></p>\n<ul>\n<li><code>master-name</code>  是对某个 master+slave 组合的一个区分标识 (一套 sentinel 可以监听多组 master+slave 这样的组合)</li>\n<li><strong> <code>quorum</code>  这个参数是进行客观下线的一个依据</strong>，即法定人数 / 法定票数。意思是至少有 quorum 个 sentinel 认为这个 master 有故障才会对这个 master 进行下线以及故障转移。因为有的时候，某个 sentinel 节点可能因为自身网络原因导致无法连接 master，而此时 master 并没有出现故障，所以这就需要多个 sentinel 都一致认为该 master 有问题，才可以进行下一步操作，这就保证了公平性和高可用。</li>\n</ul>\n</blockquote>\n</li>\n<li>\n<p><strong>Sentinel Leader 选举</strong>：从 sentinel 集群中选出 <strong><font color='#B32015'>Sentinel Leader（兵王）</font></strong>：当 master 被判断 ODown 以后，各个 sentinel 节点会进行协商，先通过<font color='orange'>Raft 算法</font>选举出一个 Sentinel Leader，<font color='red'>由它进行 failover (故障迁移)</font>。</p>\n<blockquote>\n<p>监视该 Master 的所有 Sentinel 都有可能被选为 Leader，选举使用的算法是 Raft 算法，其基本思路是 **<font color='red'>先到先得</font>**：即在一轮选举中，Sentinel A 向 Sentinel B 发送成为 Leader 的申请，如果 Sentinel B 没有同意过其他 Sentinel，则它会同意 Sentinel A 成为 Leader</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230808164314705.png\" alt=\"image-20230808164314705\" /></p>\n</blockquote>\n<p>从三个 sentinel 实例的 log 文件中可以看见兵王的诞生过程以及兵王执行故障迁移的过程：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230808163922904.png\" alt=\"image-20230808163922904\" /></p>\n<center>sentinel26379.log</center>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230808163958440.png\" alt=\"image-20230808163958440\" /></p>\n<center><font color='red'>sentinel26380.log</font></font></center>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230808164037410.png\" alt=\"image-20230808164037410\" /></p>\n<center>sentinel26381.log</center>\n</li>\n<li>\n<p><strong><font color='orange'>故障转移，选举新的 master</font></strong>：</p>\n<ol>\n<li>\n<p><strong>新主登基</strong>：**<font color='orange'>新 master 选举算法</font>** 如下：</p>\n<ol>\n<li>\n<p><font color='gree'>优先级高</font>：所有 slave 中，根据 redis.conf 配置文件中的优先级 <code>slave-priority</code>  或者 <code>replica-priority</code> ，选择优先级最高的 slave 作为新 master。</p>\n<blockquote>\n<p>数字越小优先级越高</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230808170206385.png\" alt=\"image-20230808170206385\" /></p>\n</blockquote>\n</li>\n<li>\n<p><font color='gree'>复制偏移大</font>：所有 slave 中，根据复制偏移位置 <code>offset</code> ，该值最大的 slave 作为新 master。</p>\n</li>\n<li>\n<p><font color='gree'>Run ID 小</font>：所有 slave 中，选择 Run ID 最小的 slave 作为新 master，是按照字典顺序，ASCII 码。</p>\n</li>\n</ol>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230808165640759.png\" alt=\"image-20230808165640759\" /></p>\n</li>\n<li>\n<p><strong>群臣俯首</strong>：一朝天子一朝臣，换个码头重新拜</p>\n<ol>\n<li>Sentinel leader 会对选举出的 slave 执行  <code>SLAVEOF NO ONE</code>  命令，将其提拔为新 master</li>\n<li>Sentinel leader 向其余 slave 发送  <code>SLAVEOF</code>  命令，使它们成为新 master 的 slave</li>\n</ol>\n</li>\n<li>\n<p><strong>旧主拜服</strong>：老 master 回来也认怂</p>\n<ol>\n<li>老 master 成为新 master 的 slave</li>\n<li>Sentinel leader 会让老 master 降级为 slave，并恢复正常工作</li>\n</ol>\n</li>\n</ol>\n<p>总结：上述 failover（故障迁移）均由 sentinel 独自完成，无需人工干预，因此称之为<strong>无人值守安装</strong>！</p>\n</li>\n</ol>\n<h4 id=\"redis-节点上线\"><a class=\"anchor\" href=\"#redis-节点上线\">#</a> Redis 节点上线</h4>\n<p>不同的节点类型，其上线的方式也是不同的。</p>\n<h5 id=\"原节点上线\"><a class=\"anchor\" href=\"#原节点上线\">#</a> 原节点上线</h5>\n<p>无论是原下线的 master 节点还是原下线的 slave 节点，只要是原 Redis 集群中的节点上线，<font color='red'>只需启动 Redis 即可</font>。因为每个 Sentinel 中都保存有原来其监控的所有 Redis 节点列表，Sentinel 会定时查看这些 Redis 节点是否恢复。<font color='red'>如果 Sentinel 查看到其已经恢复，则会命其从当前 master 进行数据同步</font>。</p>\n<p>不过，<font color='red'>如果是原 master 上线，在新 master 晋升后 Sentinel Leader 会立即先将原 master 节点更新为 slave，然后才会定时查看其是否恢复</font>。</p>\n<h5 id=\"新节点上线\"><a class=\"anchor\" href=\"#新节点上线\">#</a> 新节点上线</h5>\n<p>如果需要在 Redis 集群中添加一个新的节点，其未曾出现在 Redis 集群中，则上线操作<font color='red'>只能手工完成</font>。即添加者在添加之前必须知道当前 master 是谁，然后在新节点启动后<font color='red'>运行  <code>slaveof</code>  命令加入集群</font>。</p>\n<h5 id=\"sentinel-节点上线\"><a class=\"anchor\" href=\"#sentinel-节点上线\">#</a> Sentinel 节点上线</h5>\n<p>如果要添加的是 Sentinel 节点，无论其是否曾经出现在 Sentinel 集群中，都需要<font color='red'>手工完成</font>。即添加者在添加之前必须知道当前 master 是谁，然后在配置文件中修改 sentinel monitor 属性，<font color='red'>指定要监控的 master，然后启动 Sentinel 即可</font>。</p>\n<h3 id=\"sentinel-使用建议\"><a class=\"anchor\" href=\"#sentinel-使用建议\">#</a> Sentinel 使用建议</h3>\n<ol>\n<li>\n<p><strong><font color='red'>哨兵的数量应为多个，且奇数</font></strong>。哨兵本身应该集群，保证高可用。</p>\n</li>\n<li>\n<p><strong><font color='red'>各个哨兵的配置应一致</font></strong>。</p>\n</li>\n<li>\n<p>如果哨兵部署在 Docker 等容器里面，尤其要<font color='red'>注意端口的正确映射</font>。</p>\n</li>\n<li>\n<p><code>主从复制 + 哨兵</code>  机制 **<font color='#B32015'>并不能确保数据零丢失</font>**。因为从 master 挂掉到选举出新 master 的这段时间内，无法执行写命令！</p>\n<blockquote>\n<p>引出<strong>集群（cluster）</strong></p>\n</blockquote>\n</li>\n</ol>\n<h2 id=\"分布式系统切片集群cluster\"><a class=\"anchor\" href=\"#分布式系统切片集群cluster\">#</a> 分布式系统 / 切片集群（cluster）</h2>\n<blockquote>\n<p>作为 Redis 实现高可用的一种方案，优于  <code>主从复制 + Sentinel</code>  方案！</p>\n</blockquote>\n<p>Redis 分布式系统，官方称为 Redis Cluster， Redis 集群，其是 Redis 3.0 开始推出的分布式解决方案。其可以<font color='red'>很好地解决不同 Redis 节点存放不同数据，并将用户请求方便地路由到不同 Redis 的问题</font>。</p>\n<h3 id=\"已经有主从复制-sentinel了为什么还需要-redis-cluster\"><a class=\"anchor\" href=\"#已经有主从复制-sentinel了为什么还需要-redis-cluster\">#</a> 已经有主从复制、Sentinel 了，为什么还需要 Redis Cluster？</h3>\n<p>主从复制和 Redis Sentinel 这两种方案本质都是通过增加主库（master）的副本（slave）数量的方式来提高 Redis 服务的整体可用性和读吞吐量，<font color='red'>都不支持横向扩展来缓解写压力，以及解决缓存数据量过大的问题</font>。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/f682fc80-930c-4e35-978b-496b856d790b.png\" alt=\"img\" /></p>\n<p>通常情况下，更建议使用 **<font color='#B32015'>Redis 切片集群（cluster）</font>** 这种方案，更能满足高并发场景下分布式缓存的要求。</p>\n<h3 id=\"是什么-10\"><a class=\"anchor\" href=\"#是什么-10\">#</a> 是什么</h3>\n<p>简单来说就是 **<font color='red'>部署多台 master，它们之间平等，每个 master 只存储整个数据库的一部分数据，同时对外提供读 / 写服务，实现负载均衡</font>**。<font color='red'>缓存的数据库相对均匀地分布在这些 Redis 实例上，客户端的请求通过 <code>路由规则</code> 转发到目标 master 上</font>。</p>\n<p>为了保障集群整体的高可用，我们需要保证集群中每一个 master 的高可用，<font color='red'>可以通过主从复制给每个 master 配置一个或者多个从节点（slave）</font>。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/bd28bbbd-0ed4-46e6-ba94-aba9c730934d.png\" alt=\"img\" /></p>\n<p><font color='red'>Redis 切片集群对于横向扩展非常友好，只需要增加 Redis 节点到集群中即可</font>。</p>\n<h3 id=\"作用-3\"><a class=\"anchor\" href=\"#作用-3\">#</a> 作用</h3>\n<p>Redis Cluster 的功能总结如下：</p>\n<ul>\n<li><strong><font color='#B32015'>支持多个 Master</font></strong>，每个 Master 又可以挂载多个 Slave。\n<ul>\n<li>读写分离</li>\n<li>支持数据的高可用</li>\n<li>支持海量数据的读写存储操作</li>\n</ul>\n</li>\n<li><strong><font color='#B32015'>自带故障转移（failover）机制</font></strong>，内置了高可用的支持，<font color='red'>无需再去使用哨兵功能</font>。</li>\n<li><strong>客户端只需连接集群中的任意一个可用 Master 节点即可</strong>，不需要连接集群中的所有 Master 节点。</li>\n<li><strong><font color='#B32015'>槽位 slot</font><strong>负责分配到各个物理服务节点，由对应的集群来负责</strong>维护 Redis 节点、插槽、数据之间的关系</strong>。</li>\n</ul>\n<p>Redis Cluster 通过 <strong><font color='#B32015'>分片（Sharding）</font></strong> 来进行数据管理，提供 <strong><font color='red'>主从复制（Master-Slave Replication）</font></strong>、<strong><font color='red'>故障转移（Failover）</font></strong> 等开箱即用的功能，可以非常方便地帮助我们解决 Redis 大数据量缓存以及 Redis 服务高可用的问题。</p>\n<p>Redis Cluster 这种方案可以很方便地进行 <strong><font color='red'>横向拓展（Scale Out）</font></strong>，内置了开箱即用的解决方案。当 Redis Cluster 的处理能力达到瓶颈无法满足系统要求的时候，<font color='red'>直接动态添加 Redis 节点到集群中即可</font>。根据官方文档中的介绍，Redis Cluster 支持扩展到 1000 个节点。反之，当 Redis Cluster 的处理能力远远满足系统要求，<font color='red'>同样可以动态删除集群中 Redis 节点，节省资源</font>。</p>\n<p><img data-src=\"D:%5C%E5%90%84%E4%B8%AA%E7%A7%91%E7%9B%AE%5CJava%5CJavaGuide%5C%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8C%97%5C%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8C%97.assets%5Cbef6547a-7325-4cdc-8fa5-b3db66826be2.png\" alt=\"img\" /></p>\n<p>可以说，<strong><font color='red'>Redis Cluster 的动态扩容和缩容是其最大的优势</font></strong>。</p>\n<h3 id=\"最基本架构\"><a class=\"anchor\" href=\"#最基本架构\">#</a> 最基本架构</h3>\n<p>为了保证高可用，Redis Cluster <font color='red'>至少需要 3 个 master 以及 3 个 slave</font>，也就是说每个 master 必须至少有 1 个 slave。master 和 slave 之间做<font color='red'>主从复制</font>，slave 会实时同步 master 上的数据。</p>\n<p>不同于普通的 Redis 主从架构，<strong><font color='red'>这里的 slave 不对外提供读服务，主要用来保障 master 的高可用，当 master 出现故障的时候替代它</font></strong>。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/7fefb5f3-1978-432b-9a6b-3e1608d033df.png\" alt=\"img\" /></p>\n<p>如果 master 只有一个 slave 的话，master 宕机之后就直接使用这个 slave 替代 master 继续提供服务，保证 Redis Cluster 的高可用。</p>\n<p>如果 master 有多个 slave 的话，Redis Cluster 中的其他节点会从这个 master 的所有 slave 中选出一个替代 master 继续提供服务。Redis Cluster 总是希望<font color='red'>数据最完整的</font> slave 被提升为新的 master。</p>\n<p>Redis Cluster 是<font color='red'>去中心化</font>的（各个节点基于  <code>Gossip</code>  进行通信），任何一个 master 出现故障，其它的 master 节点不受影响，因为 key 找的是 **<font color='red'>哈希槽（hash slot）</font>** 而不是 Redis 节点。不过，Redis Cluster 至少要保证宕机的 master 有一个 slave 可用。</p>\n<p><font color='red'>如果宕机的 master 无 slave 的话，为了保障集群的完整性，保证所有的哈希槽都指派给了可用的 master，整个集群将不可用</font>。这种情况下，还是想让集群保持可用的话，可以将  <code>cluster-require-full-coverage</code>  这个参数设置成 no，该参数表示需要 16384 个 slot 都正常被分配时 Redis Cluster 才可以对外提供服务。</p>\n<p><font color='red'>如果想要添加新的 master 节点，只需要重新分配 hash slot 即可</font>。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/d6eb12c9-d6a9-4f7b-b0b7-158b0d735042.png\" alt=\"img\" /></p>\n<p><font color='red'>如果想要移除某个 master 节点，需要先将该节点的 hash slot 移动到其他节点上，这样才可以进行删除，不然会报错</font>。</p>\n<h3 id=\"数据分片算法\"><a class=\"anchor\" href=\"#数据分片算法\">#</a> <mark>🌟数据分片算法</mark></h3>\n<blockquote>\n<p>类似的问题：</p>\n<ul>\n<li>\n<p>Redis Cluster 是如何分片的？</p>\n</li>\n<li>\n<p>Redis Cluster 中的数据是如何分布的？</p>\n</li>\n<li>\n<p>如何确定给定 key 应该分布到哪个哈希槽中？</p>\n</li>\n</ul>\n</blockquote>\n<p>常见的数据分区规则有两大类：</p>\n<ul>\n<li>\n<p><font color='cornflowerblue'>顺序分区</font>：将数据<font color='red'>按照某种顺序平均分配</font>到不同的节点。不同的顺序方式，产生了不同的分区算法。</p>\n<ul>\n<li>轮询：每产生一个数据，就依次分配到不同的节点。其分配的结果是，在数据总量非常庞大的情况下，每个节点中数据是很平均的。但生产者与数据节点间的连接要长时间保持。</li>\n<li>时间片轮转：在某固定长度的时间片内的数据都会分配到同一个节点。时间片结束，再产生的数据就会被分配到下一个节点。可能会出现节点数据不平均的情况（因为每个时间片内产生的数据量可能是不同的）。但生产者与节点间的连接只需占用当前正在使用的这个就可以，其它连接使用完毕后就立即释放。</li>\n<li>数据块：在整体数据总量确定的情况下，根据各个节点的存储能力，可以将连接的某一整块数据分配到某一节点。</li>\n<li>业务主题：数据可根据不同的业务主题，分配到不同的节点。</li>\n</ul>\n</li>\n<li>\n<p><font color='cornflowerblue'>哈希分区</font>：充分<font color='red'>利用数据的哈希值来完成分配</font>，对数据哈希值的不同使用方式产生了不同的哈希分区算法。</p>\n<ul>\n<li>\n<p>哈希取余</p>\n</li>\n<li>\n<p>一致性哈希</p>\n</li>\n<li>\n<p><strong><font color='orange'>哈希槽</font></strong></p>\n<blockquote>\n<p>Redis Cluster 采取的数据分片算法就是这种！</p>\n</blockquote>\n</li>\n</ul>\n</li>\n</ul>\n<p>这里仅展开介绍上述三种哈希分区算法！</p>\n<h4 id=\"哈希取余-分区算法\"><a class=\"anchor\" href=\"#哈希取余-分区算法\">#</a> 哈希取余 分区算法</h4>\n<blockquote>\n<p>小厂可用</p>\n</blockquote>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230809004525207.png\" alt=\"image-20230809004525207\" /></p>\n<p>该算法的前提是，每个节点都已分配好了一个唯一序号，对于 N 个节点的集群，其序号范围为 [0, N-1]。<font color='red'>选取数据本身或可以代表数据特征的数据的一部分作为 key，计算 hash (key) 与节点数量 N 的模，即  <code>hash(key) % N</code> ，计算结果决定了该数据的存储节点的序号</font>。</p>\n<p><font color='gree'>优点</font>：</p>\n<ul>\n<li>简单有效。只需要预估好数据规模，规划好节点，就能保证一段时间的数据支撑。</li>\n<li>负载均衡。使用 Hash 算法让固定的一部分请求落到同一台服务器上，这样<font color='red'>每台服务器固定处理一部分请求</font>（并维护这些请求的信息）。</li>\n</ul>\n<p><font color='gree'>缺点</font>：</p>\n<ul>\n<li><strong><font color='red'>Redis 节点的扩容 / 缩容麻烦</font></strong>。已经存储过的数据需要根据新的节点数量 N 进行<font color='red'>数据迁移</font>，否则用户根据 key 是无法再找到原来的数据的。生产中扩容一般采用翻倍扩容方式，以减少扩容时数据迁移的比例。</li>\n<li>某个 Redis 机器宕机了，由于台数数量变化，会导致 hash 取余全部数据重新洗牌。</li>\n</ul>\n<h4 id=\"一致性哈希-分区算法\"><a class=\"anchor\" href=\"#一致性哈希-分区算法\">#</a> 一致性哈希 分区算法</h4>\n<blockquote>\n<p>在哈希取余算法的基础上，<strong><font color='red'>固定了取余的分母为 2<sup>32</sup>-1（因此称之一致性）</font></strong>，而不再是 Master 节点数量。</p>\n</blockquote>\n<h5 id=\"设计思想\"><a class=\"anchor\" href=\"#设计思想\">#</a> 设计思想</h5>\n<p>为了解决<font color='red'>哈希取余分区算法中的数据变动和映射问题</font>（某个机器宕机导致分母数量改变了，自然取余数不 OK 了）。目的是<font color='red'>当 Redis 节点个数发生变动时，尽量减少客户端到服务器的映射关系的影响</font>。</p>\n<p>一致性哈希算法通过一个叫作 **<font color='#B32015'>一致性哈希环</font><strong>的数据结构实现。这个环的起点是 0，终点是 2<sup>32</sup> - 1，并且</strong><font color='red'>起点与终点重合</font><strong>。环中间的整数按逆 / 顺时针分布，故这个环的整数分布范围是</strong><font color='red'>[0, 2<sup>32</sup>-1]</font>**。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231210191026016.png\" alt=\"image-20231210191026016\" /></p>\n<p>上图中存在四个对象 o0、 o1、 o2、 o3，分别代表四个待分配的数据，红色方块是这四个数据的 hash (o) 在 Hash 环中的落点。同时，图上还存在三个节点 m0、 m1、 m2，绿色圆圈是这三节点的 hash (m) 在 Hash 环中的落点。</p>\n<p>现在要为数据分配其要存储的节点。<strong><font color='red'>该数据对象的 hash (o) 按照逆 / 顺时针方向距离哪个节点的 hash (m) 最近，就将该数据存储在哪个节点</font></strong>。这样就会形成上图所示的分配结果。</p>\n<h5 id=\"3大步骤\"><a class=\"anchor\" href=\"#3大步骤\">#</a> 3 大步骤</h5>\n<ol>\n<li>\n<p><strong>构建一致性哈希环</strong>：</p>\n<p>一致性哈希算法必然有个 hash 函数用于产生 hash 值，这个算法的所有可能哈希值会构成一个<font color='red'>全量集</font>，这个集合可以成为一个 **<font color='red'>hash 空间 [0,2<sup>32</sup>-1]</font><strong>，这个是一个线性空间，但是在算法中，我们通过适当的逻辑控制将它</strong><font color='red'>首尾相连 (0 = 2<sup>32</sup>)</font>**，这样让它形成了一个<font color='red'>逻辑上的环形空间</font>。</p>\n<p>它也是按照使用取模的方法，<font color='red'>前面介绍的是对 Redis 节点的数量进行取模</font>。而 **<font color='orange'>一致性哈希算法是对 2<sup>32</sup> 取模</font>（因为取余的分母是固定的，所以称其一致性）**。</p>\n<p>简单来说，一致性 Hash 算法将整个哈希值空间组织成一个虚拟的圆环，如假设某哈希函数的值空间为 [0,2<sup>32</sup>-1]（即哈希值是一个 32 位无符号整形），整个哈希环如下图：整个空间按顺时针方向组织，圆环的正上方的点代表 0，0 点右侧的第一个点代表 1，以此类推，2、3、4、…… 直到 2<sup>32</sup>-1，也就是说<font color='red'>0 点左侧的第一个点代表 2<sup>32</sup>-1</font>， 0 和 2<sup>32</sup>-1 在零点中方向重合，我们把这个 **<font color='red'>由 2<sup>32</sup> 个点组成</font>** 的圆环称为 <code>Hash环</code> 。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230809010605612.png\" alt=\"image-20230809010605612\" /></p>\n</li>\n<li>\n<p><strong>Redis 服务器节点 IP 映射</strong>：</p>\n<p>将集群中各个 Redis 节点的 IP 映射到环上的某一个位置。</p>\n<p>将各个 Redis 服务器的 IP 或主机名作为关键字使用 Hash 进行哈希，这样每台机器就能确定其在哈希环上的位置。假如 4 个 Redis 节点 NodeA、NodeB、NodeC、NodeD，经过<font color='red'>IP 地址的哈希函数计算 hash (ip)</font>，使用 IP 地址哈希后在环空间的位置如下：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230809114247849.png\" alt=\"image-20230809114247849\" /></p>\n</li>\n<li>\n<p><strong>落 key 规则</strong>：</p>\n<p>当我们需要存储一个键值对时，<font color='red'>首先计算 key 的 hash 值，hash (key)</font>，确定此数据在环上的位置，从此位置沿环 **<font color='red'>顺时针</font>**“行走”，<font color='red'>第一台遇到的 Redis 服务器</font>就是其应该定位到的服务器，并将该键值对存储在该节点上。</p>\n<p>如我们有 Object A、Object B、Object C、Object D 四个数据对象，经过哈希计算后，在环空间上的位置如下：根据一致性 Hash 算法，Object A 会被定为到 Node A 上，Object B 被定为到 Node B 上，Object C 被定为到 Node C 上，Object D 被定为到 Node D 上。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230809114625589.png\" alt=\"image-20230809114625589\" /></p>\n</li>\n</ol>\n<h5 id=\"优缺点\"><a class=\"anchor\" href=\"#优缺点\">#</a> 优缺点</h5>\n<p><font color='gree'>优点</font>：</p>\n<ul>\n<li>\n<p><strong><font color='#B32015'>容错性</font></strong></p>\n<blockquote>\n<p>假设 Node C 宕机，可以看到此时对象 A、B、D 不会受到影响。一般的，在一致性 Hash 算法中，如果一台服务器不可用，则受影响的数据仅仅是此服务器到其环空间中前一台服务器（即沿着逆时针方向行走遇到的第一台服务器）之间数据，其它不会受到影响。<font color='red'>简单说，就是 C 挂了，受到影响的只是 B、C 之间的数据，且这些数据会转移到 D 进行存储</font>。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230809115305990.png\" alt=\"image-20230809115305990\" /></p>\n</blockquote>\n</li>\n<li>\n<p><strong><font color='#B32015'>Redis 节点的扩容 / 缩容方便</font></strong></p>\n<blockquote>\n<p>随着数据量的增加，需要增加一台节点 NodeX，位置在 A 和 B 之间，<font color='red'>那受到影响的也就是 A 到 X 之间的数据，重新把 A 到 X 的数据录入到 X 上即可，不会导致 hash 取余全部数据重新洗牌</font>。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230809120153493.png\" alt=\"image-20230809120153493\" /></p>\n</blockquote>\n</li>\n</ul>\n<p><font color='gree'>缺点</font>：<strong>数据倾斜</strong>问题</p>\n<blockquote>\n<p><strong>当 Redis 服务节点太少时</strong>，容易因为<font color='red'>节点分布不均匀</font>而造成<strong>数据倾斜</strong>（被缓存的数据对象大部分集中缓存在某一台服务器上）问题。</p>\n<p>例如系统中只有两台服务器：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230809120432504.png\" alt=\"image-20230809120432504\" /></p>\n</blockquote>\n<h4 id=\"哈希槽slot-分区算法\"><a class=\"anchor\" href=\"#哈希槽slot-分区算法\">#</a> <mark>🌟哈希槽 (slot) 分区算法</mark></h4>\n<blockquote>\n<p>大厂都用它！而且 <strong>Redis Cluster 的数据分区采用的就是这种方式！</strong></p>\n</blockquote>\n<h5 id=\"设计思想javaguide\"><a class=\"anchor\" href=\"#设计思想javaguide\">#</a> 设计思想（JavaGuide）</h5>\n<p>Redis Cluster 并没有使用一致性哈希，采用的是 **<font color='#B32015'>哈希槽分区</font>** ，每一个键值对都属于一个 hash slot（哈希槽）。</p>\n<p>Redis Cluster 通常有 16384 个哈希槽 ，要计算给定 key 应该分布到哪个哈希槽中，我们只需要先对每个 key 计算 CRC-16（XMODEM） 校验码，然后再对这个校验码对 16384 (哈希槽的总数) 取模，得到的值即是 key 对应的哈希槽。</p>\n<p>哈希槽的计算公式如下：</p>\n<pre><code class=\"language-C\">HASH_SLOT = CRC16(key) mod 16384\n</code></pre>\n<p>创建并初始化 Redis Cluster 的时候，Redis 会自动平均分配这 16384 个哈希槽到各个节点，不需要我们手动分配。如果你想自己手动调整的话，Redis Cluster 也内置了相关的命令比如  <code>ADDSLOTS、ADDSLOTSRANGE</code> （后面会详细介绍到重新分配哈希槽相关的命令）。</p>\n<p>客户端连接 Redis Cluster 中任意一个 master 节点即可访问 Redis Cluster 的数据。<font color='red'>当客户端发送命令请求的时候，需要先根据 key 通过上面的计算公示找到的对应的哈希槽，然后再查询哈希槽和节点的映射关系，即可找到目标节点。</font></p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/06f32493-52dc-4c53-8522-fb98e72da782.png\" alt=\"img\" /></p>\n<p>如果哈希槽确实是当前节点负责，那就直接响应客户端的请求返回结果，<font color='red'>如果不由当前节点负责，就会返回  <code>-MOVED</code>  重定向错误，告知客户端当前哈希槽是由哪个节点负责，客户端向目标节点发送请求并更新缓存的哈希槽分配信息</font>。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231216122451496.png\" alt=\"image-20231216122451496\" /></p>\n<p>这个时候你可能就会疑问：<strong>为什么还会存在找错节点的情况呢？根据公式计算难道还会出错？</strong></p>\n<p>这是因为 Redis Cluster <font color='red'>内部可能会重新分配哈希槽，比如扩容缩容的时候</font>（后文中有详细介绍到 Redis Cluster 的扩容和缩容问题），这就可能会导致客户端缓存的哈希槽分配信息会有误。</p>\n<p>从上面的介绍中，我们可以简单总结出 Redis Cluster 哈希槽分区机制的优点：<strong><font color='#B32015'>解耦了数据和节点之间的关系，提升了集群的横向扩展性和容错性。</font></strong></p>\n<h5 id=\"设计思想-2\"><a class=\"anchor\" href=\"#设计思想-2\">#</a> 设计思想</h5>\n<p>为了解决<font color='red'>数据分配不均匀</font>的问题（数据倾斜），哈希槽分区算法<font color='red'>在数据和 Redis 节点之间加了一层哈希槽（slot）</font>，用于管理数据和 Redis 节点之间的关系，相当于是<font color='red'>把数据放入槽中，再把槽映射到 Redis 节点上</font>。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231210194354635.png\" alt=\"image-20231210194354635\" /></p>\n<p>该算法 **<font color='red'>首先虚拟出一个固定数量为 2<sup>14</sup>=16384 的整数集合，其中每个整数称为一个槽（slot）</font><strong>。这个槽的数量一般是远远大于节点数量的。然后</strong><font color='red'>再将所有槽平均映射到各个 Redis 节点之上</font>**。</p>\n<p>例如，Redis 分布式系统中共虚拟了 16384（即 2<sup>14</sup>） 个 slot 槽，其范围为 [0, 16383]。假设共有 3 个节点，那么 slot 槽与节点间的映射关系如下图所示：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231210192907595.png\" alt=\"image-20231210192907595\" /></p>\n<p><font color='red'>数据只与 slot 槽有关系，与 Redis 节点没有直接关系</font>。数据根据计算公式 <code>slot = hash(key) % slotNums</code>  映射到 slot 槽。这也是该算法的一个优点，<font color='red'>解耦了数据与节点，客户端无需维护节点，只需维护与 slot 槽的关系即可</font>。</p>\n<p>Redis Cluster 的数据分区采用的就是该算法。其计算槽点的公式为： <code>slot = CRC16(key) % 16384</code> 。 <strong><font color='red'>CRC16 () 是一种带有校验功能的、具有良好分散功能的、特殊的 hash 算法函数</font></strong>。 其实 Redis 中计算槽点的公式不是上面的那个，而是： <code>slot = CRC16(key) &amp; 16383</code> 。</p>\n<blockquote>\n<p>若要计算 a % b，如果 b 是 2 的整数次幂，那么 a % b = a &amp; (b-1)。</p>\n</blockquote>\n<h5 id=\"为什么哈希槽的数量是16384个\"><a class=\"anchor\" href=\"#为什么哈希槽的数量是16384个\">#</a> 为什么哈希槽的数量是 16384 个？</h5>\n<blockquote>\n<p><font color='red'><strong>CRC16 () 算法产生的哈希值有 16bit</strong>，即 2<sup>16</sup>=65536 个值，为什么 Redis 集群的算法只采用 2<sup>14</sup>=16384 个哈希槽？</font>在进行 mode 运算时，为什么是 <code>HASH_SLOT = CRC16(key) mod 16384</code>  而不是 <code>HASH_SLOT = CRC16(key) mod 65536</code> ？</p>\n</blockquote>\n<p><font color='gree'>作者的回复</font>：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230809132510614.png\" alt=\"image-20230809132510614\" /></p>\n<p><font color='gree'>消息头 clusterMsg 的结构</font>：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230809132604570.png\" alt=\"image-20230809132604570\" /></p>\n<p><strong><font color='gree'>标准回答</font></strong>：</p>\n<ul>\n<li>\n<p>正常的心跳包会携带一个节点的完整配置，它会以幂等的方式更新旧的配置，这意味着<font color='red'>心跳包会附带当前节点的负责的哈希槽的信息</font>。假设哈希槽采用 16384，则占空间 2k（16384/8）。假设哈希槽采用 65536，则占空间 8k (65536/8)，这是令人难以接受的内存占用。因此，<font color='red'>如果槽位为 65536，那么发送心跳信息的消息头大小达到 8k，<strong>发送的心跳包过于庞大，浪费带宽</strong>。</font></p>\n<blockquote>\n<p>在消息头中最占空间的是 <code>myslots[CLUSTER_SLOTS/8]</code> :</p>\n<ul>\n<li>当槽位为 65536 时，这块的大小是: 65536÷8÷1024=<font color='red'>8kb</font></li>\n<li>当槽位为 16384 时，这块的大小是: 16384÷8÷1024=<font color='red'>2kb</font></li>\n</ul>\n<p>因为每秒钟 redis 节点需要发送一定数量的 ping 消息作为心跳包，如果槽位为 65536，这个 <font color='red'>ping 消息的消息头太大了，浪费带宽</font>。</p>\n</blockquote>\n</li>\n<li>\n<p><font color='red'>对于基本不可能超过 1000 个 master 节点数量的 redi 集群而言，<strong>16384 个槽位就已经够用了</strong>。</font></p>\n<blockquote>\n<p>集群的节点越多，心跳包的消息体内携带的数据越多。如果节点过 1000 个，也会导致网络拥堵。因此 redis 作者不建议 redis cluster 节点数量超过 1000 个。那么，<font color='red'>对于节点数在 1000 以内的 redis cluster 集群，16384 个槽位够用了</font>。没有必要拓展到 65536 个。</p>\n</blockquote>\n</li>\n<li>\n<p><font color='red'>槽位越小，节点少的情况下，<strong>压缩比高，容易传输</strong></font></p>\n<blockquote>\n<p>Redis 的 master 节点的配置信息中它所负责的哈希槽是通过一张 bitmap 的形式来保存的，在传输过程中会对 bitmap 进行压缩，但是<font color='red'>如果 bitmap 的填充率 slots / N 很高的话 (N 表示节点数)，bitmap 的压缩率就很低</font>。如果节点数很少，而哈希槽数量很多的话，bitmap 的压缩率就很低。</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"集群操作案例演示\"><a class=\"anchor\" href=\"#集群操作案例演示\">#</a> 集群操作（案例演示）</h3>\n<h4 id=\"集群架构说明\"><a class=\"anchor\" href=\"#集群架构说明\">#</a> 集群架构说明</h4>\n<p>集群的架构是最简单的三主三从。即在 3 台虚拟机上新建 6 个独立的 Redis 实例服务，每台机器上一主一从，<font color='gree'>设计图</font>如下：</p>\n<blockquote>\n<p>注意：<strong><font color='red'>master 与 slave 的角色以及配对关系，实际上是在系统搭建成功后自动随机分配的</font></strong>。</p>\n</blockquote>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/IMG_8445(20230809-135635).JPEG\" alt=\"IMG_8445(20230809-135635)\" /></p>\n<h4 id=\"集群搭建\"><a class=\"anchor\" href=\"#集群搭建\">#</a> 集群搭建</h4>\n<blockquote>\n<p>接下来的操作中，Redis 节点从 6381~6386 变成了 6380~6385。</p>\n</blockquote>\n<h5 id=\"集群架构\"><a class=\"anchor\" href=\"#集群架构\">#</a> 集群架构</h5>\n<p>下面要搭建的 Redis 分布式系统由 6 个节点构成，这 6 个节点的地址及角色分别如下表所示。一个 master 配备一个 slave，不过 master 与 slave 的角色以及配对关系，实际上是在系统搭建成功后自动随机分配的。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231213190023854.png\" alt=\"image-20231213190023854\" /></p>\n<h5 id=\"删除持久化文件\"><a class=\"anchor\" href=\"#删除持久化文件\">#</a> 删除持久化文件</h5>\n<p>先将之前 “Redis 主从集群” 中在 Redis 安装目录下生成的<font color='red'> RDB 持久化文件</font> dump638*.conf 与<font color='red'> AOF 持久化文件</font>删除。因为<font color='red'> Redis 分布式系统要求创建在一个空的数据库之上</font>。注意， AOF 持久化文件全部在 appendonlydir 目录中。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231213190413135.png\" alt=\"image-20231213190413135\" /></p>\n<h5 id=\"创建目录\"><a class=\"anchor\" href=\"#创建目录\">#</a> 创建目录</h5>\n<p>在 Redis 安装目录中 mkdir 一个新的目录 cluster-dis，用作分布式系统的工作目录。</p>\n<h5 id=\"复制2个配置文件\"><a class=\"anchor\" href=\"#复制2个配置文件\">#</a> 复制 2 个配置文件</h5>\n<p>将 cluster 目录中的 redis.conf 与 redis6380.conf 文件复制到 cluster-dis 目录。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231213190509762.png\" alt=\"image-20231213190509762\" /></p>\n<h5 id=\"修改-redisconf\"><a class=\"anchor\" href=\"#修改-redisconf\">#</a> 修改 redis.conf</h5>\n<p>对于 redis.conf 配置文件，主要涉及到以下三个四个属性：</p>\n<ul>\n<li>\n<p><code>dir</code> ：指定<font color='red'>工作目录</font>为前面创建的 cluster-dis 目录。持久化文件、节点配置文件将来都会在工作目录中自动生成。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231213190633688.png\" alt=\"image-20231213190633688\" /></p>\n</li>\n<li>\n<p><code>cluster-enabled</code> ：开启 Redis 的<font color='red'>集群模式</font>。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231213190642530.png\" alt=\"image-20231213190642530\" /></p>\n</li>\n<li>\n<p><code>cluster-config-file</code> ：指定 “集群节点” 的<font color='red'>配置文件</font>。该文件会在第一次节点启动时自动生成，其生成的路径是在 dir 属性指定的工作目录中。在集群节点信息发生变化后（如节点下线、故障转移等），节点会自动将集群状态信息保存到该配置文件中。不过，该属性在这里仍保持注释状态。<font color='red'>在后面的每个节点单独的配置文件中配置它</font>。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231213190827903.png\" alt=\"image-20231213190827903\" /></p>\n</li>\n<li>\n<p><code>cluster-node-timeout</code> ：指定 “集群节点” 间<font color='red'>通信的超时时间阈值</font>，单位毫秒。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231213190925419.png\" alt=\"image-20231213190925419\" /></p>\n</li>\n</ul>\n<h5 id=\"修改-redis6380conf\"><a class=\"anchor\" href=\"#修改-redis6380conf\">#</a> 修改 redis6380.conf</h5>\n<p>仅添加一个 cluster-config-file 属性即可。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231213191005505.png\" alt=\"image-20231213191005505\" /></p>\n<h5 id=\"复制5个配置文件\"><a class=\"anchor\" href=\"#复制5个配置文件\">#</a> 复制 5 个配置文件</h5>\n<p>使用 redis6380.conf 复制出 5 个配置文件 redis6381.conf、redis6382.conf、redis6383.conf、redis6384.conf、 redis6385.conf。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231213191314724.png\" alt=\"image-20231213191314724\" /></p>\n<p>cluster-dis 中出现了 7 个配置文件。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231213191414191.png\" alt=\"image-20231213191414191\" /></p>\n<h5 id=\"修改5个配置文件\"><a class=\"anchor\" href=\"#修改5个配置文件\">#</a> 修改 5 个配置文件</h5>\n<p>修改 5 个配置文件 redis6381.conf、 redis6382.conf、 redis6383.conf、 redis6384.conf、redis6385.conf 的内容，将其中所有涉及的<font color='red'>端口号</font>全部替换为当前文件名称中的端口号。例如，下面的是 redis6381.conf 的配置文件内容。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231213191459568.png\" alt=\"image-20231213191459568\" /></p>\n<h4 id=\"集群启动与关闭\"><a class=\"anchor\" href=\"#集群启动与关闭\">#</a> 集群启动与关闭</h4>\n<h5 id=\"启动节点\"><a class=\"anchor\" href=\"#启动节点\">#</a> 启动节点</h5>\n<p>启动所有 Redis 节点。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231213193441641.png\" alt=\"image-20231213193441641\" /></p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231213193459669.png\" alt=\"image-20231213193459669\" /></p>\n<p>此时查看 cluster-dis 目录，可以看到生成了 6 个 nodes 的配置文件。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231213193536609.png\" alt=\"image-20231213193536609\" /></p>\n<h5 id=\"创建集群\"><a class=\"anchor\" href=\"#创建集群\">#</a> 创建集群</h5>\n<p>6 个节点启动后，它们仍是 6 个独立的 Redis，通过  <code>redis-cli --cluster create</code>  命令可将 6 个节点创建了一个分布式系统。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231213193647388.png\" alt=\"image-20231213193647388\" /></p>\n<p>该命令用于将指定的 6 个节点连接为一个分布式系统。  <code>--cluster replicas 1</code>  <font color='red'>指定每个 master 会带有一个 slave 作为副本</font>。</p>\n<p>回车后会立即看到如下日志：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231213193728569.png\" alt=\"image-20231213193728569\" /></p>\n<p>输入 yes 后回车，系统就会将以上显示的动态配置信息真正的应用到节点上，然后就可看到如下日志：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231213193902008.png\" alt=\"image-20231213193902008\" /></p>\n<h5 id=\"测试集群\"><a class=\"anchor\" href=\"#测试集群\">#</a> 测试集群</h5>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231213194244750.png\" alt=\"image-20231213194244750\" /></p>\n<p>通过  <code>cluster nodes</code>  命令可以<font color='red'>查看系统中各节点的关系及连接情况</font>。只要能看到每个节点给出 connected，就说明分布式系统已经成功搭建。不过，对于客户端连接命令 redis-cli，需要注意两点：</p>\n<ul>\n<li>参数 - c：表示这是要连接一个 “集群”，而非是一个节点。</li>\n<li>端口号：可以使用 6 个中的任意一个。</li>\n</ul>\n<h5 id=\"关闭集群\"><a class=\"anchor\" href=\"#关闭集群\">#</a> 关闭集群</h5>\n<p>对于分布式系统的关闭，只需将各个节点 shutdown 即可。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231213194413240.png\" alt=\"image-20231213194413240\" /></p>\n<h4 id=\"连接集群\"><a class=\"anchor\" href=\"#连接集群\">#</a> 连接集群</h4>\n<p>无论要怎样操作分布式系统，都需要首先连接上。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231213194657202.png\" alt=\"image-20231213194657202\" /></p>\n<p>与之前单机连接相比的唯一区别就是增加了参数 - c。</p>\n<h4 id=\"写入数据\"><a class=\"anchor\" href=\"#写入数据\">#</a> 写入数据</h4>\n<h5 id=\"key-单个写入\"><a class=\"anchor\" href=\"#key-单个写入\">#</a> key 单个写入</h5>\n<p>无论 value 类型为 String 还是 List、Set 等集合类型，只要写入时操作的是一个 key，那么在分布式系统中就没有问题。例如：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231213194800157.png\" alt=\"image-20231213194800157\" /></p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231213195107814.png\" alt=\"image-20231213195107814\" /></p>\n<h5 id=\"key-批量操作\"><a class=\"anchor\" href=\"#key-批量操作\">#</a> key 批量操作</h5>\n<p>对一次写入多个 key 的操作，<font color='red'>由于多个 key 会计算出多个 slot，多个 slot 可能会对应多个节点。而由于<strong>一次只能写入一个节点，所以该操作会报错</strong></font>。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231213195136514.png\" alt=\"image-20231213195136514\" /></p>\n<p>不过，系统也提供了一种对批量 key 的操作方案，<strong><font color='red'>为这些 key 指定一个统一的 group，让这个 group 作为计算 slot 的唯一值</font></strong>。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231213195151905.png\" alt=\"image-20231213195151905\" /></p>\n<h4 id=\"集群查询\"><a class=\"anchor\" href=\"#集群查询\">#</a> 集群查询</h4>\n<h5 id=\"查询-key-的-slot\"><a class=\"anchor\" href=\"#查询-key-的-slot\">#</a> 查询 key 的 slot</h5>\n<p>通过  <code>cluster keyslot</code>  可以<font color='red'>查询指定 key 的 slot</font>。例如，下面是查询 emp 的 slot。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231214003835665.png\" alt=\"image-20231214003835665\" /></p>\n<h5 id=\"查询-slot-中-key-的数量\"><a class=\"anchor\" href=\"#查询-slot-中-key-的数量\">#</a> 查询 slot 中 key 的数量</h5>\n<p>通过  <code>cluster countkeysinslot</code>  命令可以查看到指定 slot 所包含的 key 的个数。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231214003913529.png\" alt=\"image-20231214003913529\" /></p>\n<h5 id=\"查询-slot-中的-key\"><a class=\"anchor\" href=\"#查询-slot-中的-key\">#</a> 查询 slot 中的 key</h5>\n<p>通过  <code>cluster getkeysinslot</code>  命令可以查看到指定 slot 所包含的 key。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231214003941285.png\" alt=\"image-20231214003941285\" /></p>\n<h4 id=\"故障转移failover\"><a class=\"anchor\" href=\"#故障转移failover\">#</a> 故障转移（failover）</h4>\n<h5 id=\"模拟故障\"><a class=\"anchor\" href=\"#模拟故障\">#</a> 模拟故障</h5>\n<p>通过  <code>cluster nodes</code>  命令可以查看<font color='red'>集群的整体架构及连接情况</font>。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231214150028063.png\" alt=\"image-20231214150028063\" /></p>\n<p>当然，也可以通过  <code>info replication</code>  查看<font color='red'>当前客户端连接的节点的角色</font>。可以看到，6381 节点是 master，其 slave 为 6383 节点。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231214150155289.png\" alt=\"image-20231214150155289\" /></p>\n<p>为了模拟 6381 宕机，直接将其 shutdown。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231214150205563.png\" alt=\"image-20231214150205563\" /></p>\n<p>通过客户端连接上 6383 节点后可以查看到，<font color='red'>6383 节点已经自动晋升为了 master</font>。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231214150223922.png\" alt=\"image-20231214150223922\" /></p>\n<p>重启 6381 节点后查看其角色，发现<font color='red'> 6381 节点自动成为了 6383 节点的 slave</font>。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231214150239399.png\" alt=\"image-20231214150239399\" /></p>\n<h5 id=\"全覆盖需求\"><a class=\"anchor\" href=\"#全覆盖需求\">#</a> 全覆盖需求</h5>\n<p><font color='red'>如果某 slot 范围对应节点的 master 与 slave 全部宕机，那么整个分布式系统是否还可以对外提供读服务</font>，就取决于属性  <code>cluster-require-full-coverage</code>  的设置。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231214150545505.png\" alt=\"image-20231214150545505\" /></p>\n<p>该属性有两种取值：</p>\n<ul>\n<li><font color='gree'>yes</font>：默认值。要求所有 slot 节点必须全覆盖的情况下系统才能运行。</li>\n<li><font color='gree'>no</font>：<strong><font color='red'>slot 节点不全的情况下系统也可以提供查询服务</font></strong>。</li>\n</ul>\n<h4 id=\"集群扩容\"><a class=\"anchor\" href=\"#集群扩容\">#</a> 集群扩容</h4>\n<p>下面要在正在运行的分布式系统中添加两个新的节点：端口号为 6386 的节点为 master 节点，其下会有一个端口号为 6387 的 slave 节点。</p>\n<h5 id=\"复制并修改-2-个配置文件\"><a class=\"anchor\" href=\"#复制并修改-2-个配置文件\">#</a> 复制并修改 2 个配置文件</h5>\n<p>使用 redis6380.conf 复制出 2 个配置文件 redis6386.conf 与 redis6387.conf，并修改其中的各处端口号为相应端口号，为集群扩容做前期准备。</p>\n<h5 id=\"启动系统与-2-个节点\"><a class=\"anchor\" href=\"#启动系统与-2-个节点\">#</a> 启动系统与 2 个节点</h5>\n<p>由于要演示的是在分布式系统运行期间的动态扩容，所以这里先启动分布式系统。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231215172635503.png\" alt=\"image-20231215172635503\" /></p>\n<p>要添加的两个节点是两个 Redis，所以需要先将它们启动。只不过，在没有添加到分布式系统之前，它们两个是孤立节点，每个节点与其它任何节点都没有关系。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231215172655817.png\" alt=\"image-20231215172655817\" /></p>\n<h5 id=\"添加-master-节点\"><a class=\"anchor\" href=\"#添加-master-节点\">#</a> 添加 master 节点</h5>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231215172700376.png\" alt=\"image-20231215172700376\" /></p>\n<p>通过命令  <code>redis-cli --cluster add-node &#123;newHost&#125;:&#123;newPort&#125; &#123;existHost&#125;:&#123;existPort&#125;</code>  可以将新的节点添加到系统中。其中 {newHost}:{newPort} 是新添加节点的地址，{existHost}:{existPort} 是<font color='red'>原系统中的任意节点地址</font>。</p>\n<p>添加成功后可看到如下日志。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231215172848431.png\" alt=\"image-20231215172848431\" /></p>\n<p>添加成功后，通过  <code>redis-cli -c -p 6386 cluster nodes</code>  命令可以看到其它 master 节点都分配有 slot，只有新添加的 master 还没有相应的 slot。当然，通过该命令也可以看到该新节点的动态 ID。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231215172946229.png\" alt=\"image-20231215172946229\" /></p>\n<h5 id=\"分配-slot\"><a class=\"anchor\" href=\"#分配-slot\">#</a> 分配 slot</h5>\n<p>为新的 master 分配的 slot 来自于其它节点，总 slot 数量并不会改变。所以 slot 分配过程<font color='red'>本质是一个 slot 的移动过程</font>。</p>\n<p>通过  <code>redis-cli –c --cluster reshard &#123;existIP&#125;:&#123;existPort&#125;</code>  命令可 **<font color='red'>开启 slot 分配流程</font>**。其中地址 {existIP}:{existPort} 为分布式系统中的任意节点地址。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231215173057570.png\" alt=\"image-20231215173057570\" /></p>\n<p>该流程中会<font color='red'>首先查询出当前节点的 slot 分配情况</font>。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231215173132186.png\" alt=\"image-20231215173132186\" /></p>\n<p>然后<font color='red'>开始 Q&amp;A 交互</font>。一共询问了四个问题，这里有三个：</p>\n<ul>\n<li>准备移动多少 slot？</li>\n<li>准备由谁来接收移动的 slot？</li>\n<li>选择要移动 slot 的源节点，有两种方案。\n<ul>\n<li>如果选择键入 <font color='gree'>all</font>，则所有已存在 slot 的节点都将作为 slot 源节点，即该方案将进行一次 slot 全局大分配。</li>\n<li>也可以选择<font color='gree'>其它部分节点</font>作为 slot 源节点。此时将源节点的动态 ID 复制到这里，每个 ID 键入完毕后回车，然后再复制下一个 slot 源节点动态 ID，直至最后一个键入完毕回车后再键入 done。</li>\n</ul>\n</li>\n</ul>\n<p>这里键入的是 all，进行全局大分配。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231215175514516.png\" alt=\"image-20231215175514516\" /></p>\n<p>其首先会检测指定的 slot 源节点的数据，然后制定出 reshard 的方案。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231215180639548.png\" alt=\"image-20231215180639548\" /></p>\n<p>这里会再进行一次 Q&amp;A 交互，询问是否想继续处理推荐的方案。键入 yes，然后开始真正的全局分配，直至完成。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231215180704120.png\" alt=\"image-20231215180704120\" /></p>\n<p>此时再通过 redis-cli -c -p 6386 cluster nodes 命令查看节点信息，可以看到 6386 节点中已经分配了 slot，只不过分配的 slot 编号并不连续。 master 节点新增完成。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231215180725935.png\" alt=\"image-20231215180725935\" /></p>\n<h5 id=\"添加-slave-节点\"><a class=\"anchor\" href=\"#添加-slave-节点\">#</a> 添加 slave 节点</h5>\n<p>现要将 6387 节点添加为 6386 节点的 slave。 当然，首先要确保 6387 节点的 Redis 是启动状态。</p>\n<p>通过  <code>redis-cli --cluster add-node &#123;newHost&#125;:&#123;newPort&#125; &#123;existHost&#125;:&#123;existPort&#125; --cluster-slave --cluster-master-id masterID</code>  命令可将新添加的节点直接添加为指定 master 的 slave。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231215180849727.png\" alt=\"image-20231215180849727\" /></p>\n<p>回车后可看到如下的日志，说明添加成功。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231215180904899.png\" alt=\"image-20231215180904899\" /></p>\n<p>此时再通过 redis-cli -c -p 6386 cluster nodes 命令可以看到其已经添加成功，且为指定 master 的 slave。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231215180939876.png\" alt=\"image-20231215180939876\" /></p>\n<h4 id=\"集群缩容\"><a class=\"anchor\" href=\"#集群缩容\">#</a> 集群缩容</h4>\n<p>下面要将 slave 节点 6387 与 master 节点 6386 从分布式系统中删除。</p>\n<h5 id=\"删除-slave-节点\"><a class=\"anchor\" href=\"#删除-slave-节点\">#</a> 删除 slave 节点</h5>\n<p>对于 slave 节点，可以直接通过  <code>redis-cli --cluster del-node &lt;delHost&gt;:&lt;delPort&gt; delNodeID</code>  命令删除。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231216113753611.png\" alt=\"image-20231216113753611\" /></p>\n<p>此时再查看集群，发现已经没有了 6387 节点。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231216113855438.png\" alt=\"image-20231216113855438\" /></p>\n<h5 id=\"移出-master-的-slot\"><a class=\"anchor\" href=\"#移出-master-的-slot\">#</a> 移出 master 的 slot</h5>\n<p><strong><font color='red'>在删除一个 master 之前，必须要保证该 master 上没有分配有 slot，否则无法删除</font></strong>。所以，在删除一个 master 之前，需要先将其上分配的 slot 移出。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231216114101043.png\" alt=\"image-20231216114101043\" /></p>\n<p>以上交互指定的是将 6386 节点中的 1999 个 slot 移动到 6380 节点。</p>\n<p>注意：</p>\n<ul>\n<li>要删除的节点所包含的 slot 数量在前面检测结果中都是可以看到的，例如， 6386 中的并不是 2000 个，而是 1999 个</li>\n<li>What is the receiving node ID？仅能指定一个接收节点</li>\n</ul>\n<p>回车后继续。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231216114332934.png\" alt=\"image-20231216114332934\" /></p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231216114400814.png\" alt=\"image-20231216114400814\" /></p>\n<p>此时再查看发现，6386 节点中已经没有 slot 了。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231216121516825.png\" alt=\"image-20231216121516825\" /></p>\n<h5 id=\"删除-master-节点\"><a class=\"anchor\" href=\"#删除-master-节点\">#</a> 删除 master 节点</h5>\n<p>此时就可以删除 6386 节点了。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231216121543342.png\" alt=\"image-20231216121543342\" /></p>\n<p>此时再查看集群，发现已经没有了 6386 节点。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231216121555920.png\" alt=\"image-20231216121555920\" /></p>\n<h3 id=\"局限性\"><a class=\"anchor\" href=\"#局限性\">#</a> 局限性</h3>\n<p>Redis Cluster 存在一些使用限制：</p>\n<ul>\n<li>仅支持 0 号数据库</li>\n<li>批量 key 操作支持有限</li>\n<li>分区仅限于 key</li>\n<li>事务支持有限</li>\n<li>不支持分级管理</li>\n</ul>\n<h3 id=\"redis-cluster-在扩容缩容期间可以提供服务吗\"><a class=\"anchor\" href=\"#redis-cluster-在扩容缩容期间可以提供服务吗\">#</a> Redis Cluster 在扩容 / 缩容期间可以提供服务吗？</h3>\n<p><strong><font color='#B32015'>Redis Cluster 扩容和缩容本质是进行重新分片，动态迁移哈希槽。</font></strong></p>\n<p>为了保证 Redis Cluster 在扩容和缩容期间依然能够对外正常提供服务，Redis Cluster 提供了重定向机制，两种不同的类型：</p>\n<ul>\n<li><font color='gree'>ASK 重定向</font></li>\n<li><font color='gree'>MOVED 重定向</font></li>\n</ul>\n<p>从客户端的角度来看，ASK 重定向是下面这样的：</p>\n<ol>\n<li>客户端发送请求命令，如果请求的 key 对应的哈希槽还在当前节点的话，就直接响应客户端的请求。</li>\n<li><font color='red'>如果客户端请求的 key 对应的哈希槽当前正在迁移至新的节点，就会返回  <code>-ASK</code>  重定向错误，告知客户端要将请求发送到哈希槽被迁移到的目标节点</font>。</li>\n<li>客户端收到 -ASK 重定向错误后，将会临时（一次性）重定向，自动向目标节点发送一条 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9yZWRpcy5pby9jb21tYW5kcy9hc2tpbmcv\">ASKING</span> 命令。也就是说，接收到 ASKING 命令的节点会强制执行一次请求，下次再来需要重新提前发送 ASKING 命令。</li>\n<li>客户端发送真正的请求命令。</li>\n<li><font color='red'>ASK 重定向并不会同步更新客户端缓存的哈希槽分配信息</font>，也就是说，客户端对正在迁移的相同哈希槽的请求依然会发送到原节点而不是目标节点。</li>\n</ol>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/ca358827-2d14-40cd-ab6a-64ec1ea21428.png\" alt=\"img\" /></p>\n<p><font color='red'>如果客户端请求的 key 对应的哈希槽已经迁移完成的话，就会返回  <code>-MOVED</code>  重定向错误，告知客户端当前哈希槽是由哪个节点负责，客户端向目标节点发送请求并更新缓存的哈希槽分配信息</font>。</p>\n<h3 id=\"cap-定理\"><a class=\"anchor\" href=\"#cap-定理\">#</a> CAP 定理</h3>\n<h4 id=\"概念\"><a class=\"anchor\" href=\"#概念\">#</a> 概念</h4>\n<p>CAP 定理指的是 **<font color='#B32015'>在一个分布式系统中，一致性（C）、可用性（A）、分区容错性（P）三者不可兼得</font>**。</p>\n<ul>\n<li><font color='cornflowerblue'>一致性（Consistency）</font>：分布式系统中多个主机之间是否能够保持数据一致的特性。即，<font color='red'>当系统数据发生更新操作后，各个主机中的数据仍然处于一致的状态</font>。</li>\n<li><font color='cornflowerblue'>可用性（Availability）</font>：<font color='red'>系统提供的服务必须一直处于可用的状态</font>，即对于用户的每一个请求，系统总是可以在有限的时间内对用户做出响应。</li>\n<li><font color='cornflowerblue'>分区容错性（Partition tolerance）</font>：<font color='red'>分布式系统在遇到任何<strong>网络分区故障</strong>时，仍能够保证对外提供满足一致性和可用性的服务</font>。</li>\n</ul>\n<h4 id=\"定理\"><a class=\"anchor\" href=\"#定理\">#</a> 定理</h4>\n<p>CAP 定理的内容是：<font color='red'>对于分布式系统，网络环境相对是不可控的，出现网络分区是不可避免的，因此系统必须具备分区容错性</font>。但 **<font color='red'>系统不能同时保证一致性（C）与可用性（A）。即要么 CP，要么 AP</font>**。</p>\n<h4 id=\"base-理论\"><a class=\"anchor\" href=\"#base-理论\">#</a> BASE 理论</h4>\n<p><font color='red'>BASE 是对 CAP 中一致性和可用性权衡的结果</font>，其来源于对大规模互联网系统分布式实践的结论，是基于 CAP 定理逐步演化而来的，由以下三个短语的简写组成：</p>\n<ul>\n<li><font color='cornflowerblue'> <code>B</code> asically  <code>A</code> vailable（基本可用）</font>：分布式系统在出现不可预知故障的时候，<font color='red'>允许损失部分可用性</font></li>\n<li><font color='cornflowerblue'> <code>S</code> oft state（软状态）</font>：允许系统数据存在的中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即<font color='red'>允许系统主机间进行数据同步的过程存在一定延时</font>。软状态，其实就是一种灰度状态，过渡状态。</li>\n<li><font color='cornflowerblue'> <code>E</code> ventually consistent（最终一致性）</font>：强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。因此，最终一致性的本质是<font color='red'>需要系统保证最终数据能够达到一致，而不需要保证系统数据的实时一致性</font>。</li>\n</ul>\n<p>BASE 理论的核心思想是：<strong><font color='red'>即使无法做到强一致性，但每个系统都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性</font></strong>。</p>\n<h4 id=\"cap-应用\"><a class=\"anchor\" href=\"#cap-应用\">#</a> CAP 应用</h4>\n<h5 id=\"zookeepercp-模式\"><a class=\"anchor\" href=\"#zookeepercp-模式\">#</a> Zookeeper：CP 模式</h5>\n<p>Zookeeper 遵循的是 CP 模式，即保证了一致性（C），但牺牲了可用性（A）。<font color='red'>当 Leader 节点中的数据发生了变化后，在 Follower 还没有同步完成之前，整个 Zookeeper 集群是不对外提供服务的</font>。如果此时有客户端来访问数据，则客户端会因访问超时而发生重试。不过，由于 Leader 的选举非常快，所以这种重试对于用户来说几乎是感知不到的。所以说，Zookeeper 保证了一致性，但牺牲了可用性。</p>\n<h5 id=\"consulcp-模式\"><a class=\"anchor\" href=\"#consulcp-模式\">#</a> Consul：CP 模式</h5>\n<h5 id=\"redisap-模式\"><a class=\"anchor\" href=\"#redisap-模式\">#</a> Redis：AP 模式</h5>\n<p>Redis 遵循的是 AP 模式，即保证了可用性（A），但牺牲了一致性（C）。</p>\n<h5 id=\"eurekaap-模式\"><a class=\"anchor\" href=\"#eurekaap-模式\">#</a> Eureka：AP 模式</h5>\n<h5 id=\"nacosap-模式\"><a class=\"anchor\" href=\"#nacosap-模式\">#</a> Nacos：AP 模式</h5>\n<p>Nacos 在做注册中心时，默认是 AP 的。但其也支持 CP 模式，但需要用户提交请求进行转换。</p>\n<h1 id=\"使用规范\"><a class=\"anchor\" href=\"#使用规范\">#</a> 使用规范</h1>\n<p>实际使用 Redis 的过程中，我们尽量要准守一些常见的规范，比如：</p>\n<ol>\n<li><font color='red'>使用连接池</font>：避免频繁创建关闭客户端连接。</li>\n<li><font color='red'>尽量不使用 O (n) 指令</font>，使用 O (n) 命令时要关注 n 的数量：像  <code>KEYS *</code> 、 <code>HGETALL</code> 、 <code>LRANGE</code> 、 <code>SMEMBERS</code> 、 <code>SINTER</code> / <code>SUNION</code> / <code>SDIFF</code>  等 O (n) 命令并非不能使用，但是需要明确 n 的值。另外，有遍历的需求可以使用  <code>HSCAN</code> 、 <code>SSCAN</code> 、 <code>ZSCAN</code>  代替。</li>\n<li><font color='red'>使用批量操作，减少网络传输</font>：原生批量操作命令（比如  <code>MGET</code> 、 <code>MSET</code>  等等）、pipeline、Lua 脚本。</li>\n<li><font color='red'>尽量不用 Redis 事务，用 Lua 脚本代替</font>：Redis 事务实现的功能比较鸡肋，可以使用 Lua 脚本代替。</li>\n<li><font color='red'>禁止长时间开启 monitor</font>：对性能影响比较大。</li>\n<li><font color='red'>控制 key 的生命周期</font>：避免 Redis 中存放了太多不经常被访问的数据。</li>\n<li>……</li>\n</ol>\n<p>相关文章推荐：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIuYWxpeXVuLmNvbS9hcnRpY2xlLzUzMTA2Nw==\">阿里云 Redis 开发规范</span>。</p>\n<h1 id=\"lua-脚本-2\"><a class=\"anchor\" href=\"#lua-脚本-2\">#</a> Lua 脚本</h1>\n<h1 id=\"分布式锁\"><a class=\"anchor\" href=\"#分布式锁\">#</a> 分布式锁</h1>\n<h1 id=\"️重要知识点\"><a class=\"anchor\" href=\"#️重要知识点\">#</a> ⭐️重要知识点</h1>\n",
            "tags": [
                "数据库",
                "Redis"
            ]
        },
        {
            "id": "http://example.com/database/mysql/MySQL-JavaGuide/",
            "url": "http://example.com/database/mysql/MySQL-JavaGuide/",
            "title": "MySQL-JavaGuide",
            "date_published": "2023-11-17T11:50:54.442Z",
            "content_html": "<h1 id=\"mysql\"><a class=\"anchor\" href=\"#mysql\">#</a> MySQL</h1>\n<h2 id=\"数据库基础知识\"><a class=\"anchor\" href=\"#数据库基础知识\">#</a> 数据库基础知识</h2>\n<h3 id=\"数据库-数据库管理系统-数据库系统-数据库管理员\"><a class=\"anchor\" href=\"#数据库-数据库管理系统-数据库系统-数据库管理员\">#</a> 数据库，数据库管理系统，数据库系统，数据库管理员</h3>\n<ul>\n<li><strong>数据库</strong>（DataBase 简称  <code>DB</code> ）：就是信息的集合，或者说是由数据库管理系统管理的数据的集合。</li>\n<li><strong>数据库管理系统</strong>（Database Management System 简称  <code>DBMS</code> ）：是一种操纵和管理数据库的大型软件，通常用于建立、使用和维护数据库。</li>\n<li><strong>数据库系统</strong>（Data Base System，简称  <code>DBS</code> ）：通常由软件、数据库和数据管理员 (DBA) 组成。</li>\n<li><strong>数据库管理员</strong>（Database Administrator, 简称  <code>DBA</code> ）：负责全面管理和控制数据库系统。</li>\n</ul>\n<h3 id=\"元组-码-候选码-主码-外码-主属性-非主属性\"><a class=\"anchor\" href=\"#元组-码-候选码-主码-外码-主属性-非主属性\">#</a> 元组，码，候选码，主码，外码，主属性，非主属性</h3>\n<ul>\n<li><strong>元组</strong>（tuple）：是关系数据库中的基本概念，关系是一张表，表中的<font color='red'>每行（即数据库中的每条记录）就是一个元组</font>，每列就是一个属性。在二维表里，元组也称为行。</li>\n<li><strong>码</strong>：码就是<font color='red'>能唯一标识实体的属性</font>，对应表中的列。</li>\n<li><strong>候选码</strong>：若关系中的<font color='red'>某一属性或属性组的值能唯一标识一个元组，而其任何、子集都不能再标识</font>，则称该属性组为候选码。例如：在学生实体中，“学号” 是能唯一的区分学生实体的，同时又假设 “姓名”、“班级” 的属性组合足以区分学生实体，那么 {学号} 和 {姓名，班级} 都是候选码。</li>\n<li><strong>主码</strong>：主码也叫主键。主码是从候选码中选出来的。<font color='red'>一个实体集中只能有一个主码，但可以有多个候选码</font>。</li>\n<li><strong>外码</strong>：外码也叫外键。如果一个关系中的一个属性是另外一个关系中的主码则这个属性为外码。</li>\n<li><strong>主属性</strong>：<font color='red'>候选码中出现过的属性称为主属性</font>。比如关系 工人（工号，身份证号，姓名，性别，部门）. 显然工号和身份证号都能够唯一标示这个关系，所以都是候选码。工号、身份证号这两个属性就是主属性。如果主码是一个属性组，那么属性组中的属性都是主属性。</li>\n<li><strong>非主属性：</strong><font color='red'>不包含在任何一个候选码中的属性称为非主属性</font>。比如在关系 —— 学生（学号，姓名，年龄，性别，班级）中，主码是 “学号”，那么其他的 “姓名”、“年龄”、“性别”、“班级” 就都可以称为非主属性。</li>\n</ul>\n<h3 id=\"er-图\"><a class=\"anchor\" href=\"#er-图\">#</a> ER 图</h3>\n<p><strong>ER 图</strong> 全称是 Entity Relationship Diagram（<font color='red'>实体联系图</font>），提供了表示实体类型、属性和联系的方法，用来设计数据库。</p>\n<p>ER 图由下面 3 个要素组成：</p>\n<ul>\n<li><strong>实体</strong>：通常是现实世界的业务对象，当然使用一些逻辑对象也可以。比如对于一个校园管理系统，会涉及学生、教师、课程、班级等等实体。在 ER 图中，实体使用<font color='red'>矩形框</font>表示。</li>\n<li><strong>属性</strong>：即某个实体拥有的属性，属性用来描述组成实体的要素，对于产品设计来说可以理解为字段。在 ER 图中，属性使用<font color='red'>椭圆形</font>表示。</li>\n<li><strong>联系</strong>：即实体与实体之间的关系，在 ER 图中用<font color='red'>菱形</font>表示，这个关系不仅有业务关联关系，还能通过数字表示实体之间的数量对照关系。例如，一个班级会有多个学生就是一种实体间的联系。</li>\n</ul>\n<p>下图是一个学生选课的 ER 图，每个学生可以选若干门课程，同一门课程也可以被若干人选择，所以它们之间的关系是<font color='red'>多对多（M: N</font>）。另外，还有其他两种实体之间的关系是：<font color='red'>1 对 1（1:1）</font>、<font color='red'>1 对多（1: N）</font>。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231129163909791.png\" alt=\"image-20231129163909791\" /></p>\n<center>学生与课程之间联系的E-R图</center>\n<h3 id=\"数据库三大范式\"><a class=\"anchor\" href=\"#数据库三大范式\">#</a> <mark>🌟数据库三大范式</mark></h3>\n<p>数据库范式有 3 种：</p>\n<ul>\n<li>\n<p>1NF (第一范式)：<strong><font color='red'>属性不可再分</font></strong>，即每个属性都是不可分割的原子项。</p>\n</li>\n<li>\n<p>2NF (第二范式)：满足第一范式；且 **<font color='red'>不存在部分函数依赖</font>**，即<font color='red'>非主属性必须完全依赖于主属性</font>。</p>\n<blockquote>\n<p>主属性即主键；完全依赖是针对于联合主键的情况，非主键列不能只依赖于主键的一部分；</p>\n</blockquote>\n</li>\n<li>\n<p>3NF (第三范式)：满足第二范式；且 **<font color='red'>不存在传递函数依赖</font>**，即非主属性必须直接依赖于主属性。</p>\n</li>\n</ul>\n<h3 id=\"不推荐使用外键与级联\"><a class=\"anchor\" href=\"#不推荐使用外键与级联\">#</a> 不推荐使用外键与级联</h3>\n<p>对于外键和级联，阿里巴巴开发手册这样说到：</p>\n<blockquote>\n<p>【强制】<strong><font color='red'>不得使用外键与级联，一切外键概念必须在应用层解决</font></strong>。</p>\n<p>说明：以学生和成绩的关系为例，学生表中的 student_id 是主键，那么成绩表中的 student_id 则为外键。如果更新学生表中的 student_id，同时触发成绩表中的 student_id 更新，即为级联更新。</p>\n<ul>\n<li>外键与级联更新适用于单机低并发，<font color='red'>不适合分布式、高并发集群</font>；</li>\n<li><font color='red'>级联更新是强阻塞，存在数据库更新风暴的风险</font>；</li>\n<li><font color='red'>外键影响数据库的插入速度</font>；</li>\n</ul>\n</blockquote>\n<h3 id=\"存储过程\"><a class=\"anchor\" href=\"#存储过程\">#</a> 存储过程</h3>\n<p>我们可以把存储过程看成是<strong>一些 SQL 语句的集合，中间加了点逻辑控制语句</strong>。存储过程在业务比较复杂的时候是非常实用的，比如很多时候我们完成一个操作可能需要写一大串 SQL 语句，这时候我们就可以写有一个存储过程，这样也方便了我们下一次的调用。<font color='red'>存储过程一旦调试完成通过后就能稳定运行</font>，另外，<font color='red'>使用存储过程比单纯 SQL 语句执行要快，因为存储过程是预编译过的</font>。</p>\n<p>存储过程在互联网公司应用不多，因为<font color='red'>存储过程难以调试和扩展，而且没有移植性，还会消耗数据库资源</font>。</p>\n<p>阿里巴巴 Java 开发手册里要求 **<font color='red'>禁止使用存储过程</font>**。</p>\n<h3 id=\"drop-delete-与-truncate-的区别\"><a class=\"anchor\" href=\"#drop-delete-与-truncate-的区别\">#</a> drop、delete 与 truncate 的区别</h3>\n<h4 id=\"用法不同\"><a class=\"anchor\" href=\"#用法不同\">#</a> 用法不同</h4>\n<ul>\n<li><code>drop</code>  (丢弃数据):  <code>drop table 表名</code>  ，直接将表都删除掉，在<strong>删除表</strong>的时候使用。</li>\n<li><code>truncate</code>  (清空数据) :  <code>truncate table 表名</code>  ，只删除表中的数据，<font color='red'>再插入数据的时候自增长 id 又从 1 开始</font>，在<strong>清空表</strong>中数据的时候使用。</li>\n<li><code>delete</code> （删除数据） :  <code>delete from 表名 where 列名=值</code> ，<strong>删除某一行</strong>的数据，如果不加  <code>where</code>  子句和 <code>truncate table 表名</code> 作用类似。</li>\n</ul>\n<p>注意：<strong> <code>truncate</code>  和  <code>delete</code>  只删除数据不删除表的结构 (定义)，执行  <code>drop</code>  语句，此表的结构也会删除，也就是执行  <code>drop</code>  之后对应的表不复存在。</strong></p>\n<h4 id=\"属于不同的数据库语言\"><a class=\"anchor\" href=\"#属于不同的数据库语言\">#</a> 属于不同的数据库语言</h4>\n<ul>\n<li>\n<p><code>truncate</code>  和  <code>drop</code>  属于 **DDL (数据定义语言)** 语句，操作立即生效，原数据不放到 rollback segment 中，<font color='red'>不能回滚</font>，操作不触发 trigger。</p>\n</li>\n<li>\n<p>而  <code>delete</code>  语句是 **DML (数据库操作语言)** 语句，这个操作会放到 rollback segement 中，<font color='red'>可以回滚</font>，事务提交之后才生效。</p>\n</li>\n</ul>\n<p><strong>DML 语句和 DDL 语句区别：</strong></p>\n<ul>\n<li>DML 是数据库操作语言（Data Manipulation Language）的缩写，是指<font color='red'>对数据库中表记录的操作</font>，主要包括表记录的插入、更新、删除和查询，是开发人员日常使用最频繁的操作。</li>\n<li>DDL （Data Definition Language）是数据定义语言的缩写，简单来说，就是<font color='red'>对数据库内部的对象进行创建、删除、修改</font>的操作语言。</li>\n<li>二者最大区别：<strong><font color='red'> DML 只是对表内部数据的操作，而不涉及到表的定义、结构的修改</font></strong>，更不会涉及到其他对象。DDL 语句更多的被数据库管理员（DBA）所使用，一般的开发人员很少使用。</li>\n</ul>\n<p>另外，由于 <code>select</code>  不会对表进行破坏，所以有的地方也会把 <code>select</code>  单独区分开叫做数据库查询语言 DQL（Data Query Language）。</p>\n<h4 id=\"执行速度不同\"><a class=\"anchor\" href=\"#执行速度不同\">#</a> 执行速度不同</h4>\n<p>一般来说： <code>drop</code>  &gt;  <code>truncate</code>  &gt;  <code>delete</code> （这个我没有设计测试过）。</p>\n<ul>\n<li><code>delete</code>  命令执行的时候<font color='red'>会产生数据库的 <code>binlog</code>  日志，而日志记录是需要消耗时间的</font>，但是也有个<font color='red'>好处是方便数据回滚恢复</font>。</li>\n<li><code>truncate</code>  命令执行的时候<font color='red'>不会产生数据库日志</font>，因此比 <code>delete</code>  要快。除此之外，还<font color='red'>会把表的自增值重置和索引恢复到初始大小等</font>。</li>\n<li><code>drop</code>  命令会<font color='red'>把表占用的空间全部释放掉</font>。</li>\n</ul>\n<p>Tips：你应该更多地关注在使用场景上，而不是执行效率。</p>\n<h3 id=\"数据库设计通常分为哪几步\"><a class=\"anchor\" href=\"#数据库设计通常分为哪几步\">#</a> 数据库设计通常分为哪几步？</h3>\n<ol>\n<li><strong>需求分析</strong>：分析用户的需求，包括数据、功能和性能需求。</li>\n<li><strong>概念结构设计</strong>：主要采用 E-R 模型进行设计，包括画 <code> E-R 图</code> 。</li>\n<li><strong>逻辑结构设计</strong>：通过将 E-R 图转换成 <code>表</code> ，实现从 E-R 模型到关系模型的转换。</li>\n<li><strong>物理结构设计</strong>：主要是为所设计的数据库<font color='red'>选择合适的存储结构和存取路径</font>。</li>\n<li><strong>数据库实施</strong>：包括编程、测试和试运行</li>\n<li><strong>数据库的运行和维护</strong>：系统的运行与数据库的日常维护。</li>\n</ol>\n<h2 id=\"nosql非关系型数据库基础\"><a class=\"anchor\" href=\"#nosql非关系型数据库基础\">#</a> NoSQL（非关系型数据库）基础</h2>\n<h3 id=\"nosql-是什么\"><a class=\"anchor\" href=\"#nosql-是什么\">#</a> NoSQL 是什么？</h3>\n<p><code>NoSQL</code> （Not Only SQL）非关系型的数据库，主要针对的是<font color='red'>键值、文档、图形类型</font>数据存储。并且，NoSQL 数据库<font color='red'>天生支持分布式，数据冗余和数据分片</font>等特性，<font color='red'>旨在提供可扩展、高可用、高性能的数据存储解决方案</font>。</p>\n<p>一个常见的误解是 NoSQL 数据库或非关系型数据库不能很好地存储关系型数据。<font color='red'>NoSQL 数据库可以存储关系型数据</font>— 它们与关系型数据库的存储方式不同。</p>\n<p>NoSQL 数据库代表：HBase 、Cassandra、MongoDB、Redis。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/sql-nosql-tushi.png\" alt=\"img\" /></p>\n<h3 id=\"sql数据库-和-nosql数据库-的区别\"><a class=\"anchor\" href=\"#sql数据库-和-nosql数据库-的区别\">#</a> <mark>🌟SQL 数据库 和 NoSQL 数据库 的区别</mark></h3>\n<p>即关系型数据库与非关系型数据库的区别：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"></th>\n<th>SQL 数据库</th>\n<th>NoSQL 数据库</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">发展历程</td>\n<td>开发于 1970 年代，重点是<font color='red'>减少数据重复</font></td>\n<td>开发于 2000 年代后期，重点是<font color='red'>提升可扩展性</font>，<font color='red'>减少大规模数据的存储成本</font></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">例子</td>\n<td><code>Oracle</code> 、 <code>MySQL</code> 、Microsoft SQL Server 、PostgreSQL</td>\n<td>文档： <code>MongoDB</code> 、CouchDB，键值： <code>Redis</code>  、DynamoDB，宽列：Cassandra 、  <code>HBase</code> ，图表： <code>Neo4j </code> 、 Amazon Neptune、Giraph</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">数据存储模型</td>\n<td><font color='red'>结构化存储</font>，具有固定行和列的表格</td>\n<td><font color='red'>非结构化存储</font>。文档：JSON 文档，键值：键值对，宽列：包含行和动态列的表，图：节点和边</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">数据模式</td>\n<td><font color='red'>必须先定义好表结构，才能添加数据</font></td>\n<td><font color='red'>数据可以在任何时候任何地方添加，不需要预先定义</font></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">事务支持</td>\n<td>支持对事务原子性细粒度控制，并且易于回滚事务</td>\n<td><font color='red'>没有事务这个概念</font>，每一个数据集都是原子级别的</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ACID 属性</td>\n<td>提供<font color='red'>原子性、一致性、隔离性、持久性</font>(ACID) 属性</td>\n<td><font color='red'>通常不支持 ACID 事务</font>，为了可扩展、高性能进行了权衡，少部分支持比如 MongoDB 。不过，MongoDB 对 ACID 事务 的支持和 MySQL 还是有所区别的。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">查询速度</td>\n<td><font color='red'>数据存储在磁盘中，查询速度较慢</font></td>\n<td><font color='red'>数据存储在缓存中，且不需要经过 SQL 层的解析，查询速度较快</font></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">性能</td>\n<td>性能通常取决于磁盘子系统。要获得最佳性能，通常需要<font color='red'>优化查询、索引、表结构</font>。</td>\n<td>性能通常由底层硬件集群大小、网络延迟以及调用应用程序来决定。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">扩展</td>\n<td><font color='red'>垂直</font>（使用性能更强大的服务器进行扩展）、读写分离、分库分表</td>\n<td><font color='red'>横向</font>（增加服务器的方式横向扩展，通常是基于分片机制）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">用途</td>\n<td>普通企业级的项目的数据存储</td>\n<td>用途广泛比如图数据库支持分析和遍历连接数据之间的关系、键值数据库可以处理大量数据扩展和极高的状态变化</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">查询语法</td>\n<td><font color='red'>结构化查询语言 (SQL)</font></td>\n<td>数据访问语法可能<font color='red'>因数据库而异</font></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"nosql-数据库的优势\"><a class=\"anchor\" href=\"#nosql-数据库的优势\">#</a> NoSQL 数据库的优势</h3>\n<p>NoSQL 数据库非常适合许多现代应用程序，例如移动、Web 和游戏等应用程序，它们需要灵活、可扩展、高性能和功能强大的数据库以提供卓越的用户体验。</p>\n<ul>\n<li><strong>灵活性：</strong> NoSQL 数据库通常提供灵活的架构，以实现更快速、更多的迭代开发。<font color='red'>灵活的数据模型</font>使 NoSQL 数据库成为 **<font color='red'>半结构化和非结构化数据</font>** 的理想之选。</li>\n<li><strong>可扩展性：</strong> NoSQL 数据库通常被设计为<font color='red'>通过使用分布式硬件集群来横向扩展</font>，而不是通过添加昂贵和强大的服务器来纵向扩展。</li>\n<li><strong>高性能：</strong> NoSQL 数据库<font color='red'>针对特定的数据模型和访问模式进行了优化</font>，这与尝试使用关系数据库完成类似功能相比可实现更高的性能。</li>\n<li><strong>强大的功能：</strong> NoSQL 数据库提供功能<font color='red'>强大的 API 和数据类型</font>，专门针对其各自的数据模型而构建。</li>\n</ul>\n<h3 id=\"nosql-数据库有哪些类型\"><a class=\"anchor\" href=\"#nosql-数据库有哪些类型\">#</a> NoSQL 数据库有哪些类型？</h3>\n<p>NoSQL 数据库主要可以分为下面四种类型：</p>\n<ul>\n<li><strong>键值</strong> ：键值数据库是一种较简单的数据库，其中<font color='red'>每个项都包含键和值</font>。这是极为灵活的 NoSQL 数据库类型，因为应用可以完全控制 value 字段中存储的内容，没有任何限制。 <code>Redis</code>  和 DynanoDB 是两款非常流行的键值数据库。</li>\n<li><strong>文档</strong> ：文档数据库中的数据被存储在类似于  <code>JSON</code> （JavaScript 对象表示法）对象的文档中，非常清晰直观。<font color='red'>每个文档包含成对的字段和值</font>。这些值通常可以是各种类型，包括字符串、数字、布尔值、数组或对象等，并且它们的<font color='red'>结构通常与开发者在代码中使用的对象保持一致</font>。 <code>MongoDB</code>  就是一款非常流行的文档数据库。</li>\n<li><strong>图形</strong> ：图形数据库旨在轻松构建和运行与高度连接的数据集一起使用的应用程序。图形数据库的典型使用案例包括社交网络、推荐引擎、欺诈检测和知识图谱。 <code>Neo4j</code>  和 Giraph 是两款非常流行的图形数据库。</li>\n<li><strong>宽列</strong> ：宽列存储数据库<font color='red'>非常适合需要存储大量的数据</font>。Cassandra 和  <code>HBase</code>  是两款非常流行的宽列存储数据库。</li>\n</ul>\n<p>下面这张图片来源于 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWFybi5taWNyb3NvZnQuY29tL2VuLXVzL2RvdG5ldC9hcmNoaXRlY3R1cmUvY2xvdWQtbmF0aXZlL3JlbGF0aW9uYWwtdnMtbm9zcWwtZGF0YQ==\">微软的官方文档 | 关系数据与 NoSQL 数据</span>。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/types-of-nosql-datastores.png\" alt=\"NoSQL 数据模型\" /></p>\n<h2 id=\"mysql-常见面试题\"><a class=\"anchor\" href=\"#mysql-常见面试题\">#</a> MySQL 常见面试题</h2>\n<h3 id=\"mysql基础\"><a class=\"anchor\" href=\"#mysql基础\">#</a> MySQL 基础</h3>\n<h4 id=\"什么是关系型数据库\"><a class=\"anchor\" href=\"#什么是关系型数据库\">#</a> 什么是关系型数据库？</h4>\n<p>顾名思义， <code>关系型数据库（RDBMS，Relational Database Management System）</code> 就是<font color='red'>一种建立在<u>关系模型</u>的基础上的数据库</font>。关系模型表明了数据库中所存储的<font color='red'>数据之间的联系（一对一、一对多、多对多）</font>。</p>\n<p>关系型数据库中，我们的数据都被存放在了各种表中（比如用户表），表中的每一行就存放着一条数据（比如一个用户的信息）。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/5e3c1a71724a38245aa43b02_99bf70d46cc247be878de9d3a88f0c44.png\" alt=\"关系型数据库表关系\" /></p>\n<p>大部分关系型数据库都使用 SQL 来操作数据库中的数据。并且，大部分关系型数据库都支持<font color='red'>事务的四大特性 (ACID)</font>。</p>\n<p>常见的关系型数据库：MySQL、PostgreSQL、Oracle、SQL Server、SQLite（微信本地的聊天记录的存储就是用的 SQLite） ......。</p>\n<h4 id=\"什么是-sql\"><a class=\"anchor\" href=\"#什么是-sql\">#</a> 什么是 SQL？</h4>\n<p>SQL 是一种 <code>结构化查询语言(Structured Query Language)</code> ，专门用来与数据库打交道，目的是提供一种<font color='red'>从数据库中读写数据</font>的简单有效的方法。</p>\n<p>几乎所有的主流关系数据库都支持 SQL ，适用性非常强。并且，一些非关系型数据库也兼容 SQL 或者使用的是类似于 SQL 的查询语言。</p>\n<p>SQL 可以帮助我们：</p>\n<ul>\n<li>新建数据库、数据表、字段；</li>\n<li>在数据库中增加，删除，修改，查询数据；</li>\n<li>新建视图、函数、存储过程；</li>\n<li>对数据库中的数据进行简单的数据分析；</li>\n<li>搭配 Hive，Spark SQL 做大数据；</li>\n<li>搭配 SQLFlow 做机器学习；</li>\n<li>......</li>\n</ul>\n<h4 id=\"什么是-mysql\"><a class=\"anchor\" href=\"#什么是-mysql\">#</a> 什么是 MySQL？</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/20210327143351823.png\" alt=\"img\" /></p>\n<p><strong>MySQL 是一种关系型数据库，主要用于持久化存储我们的系统中的一些数据比如用户信息。</strong></p>\n<p>由于 MySQL 是开源免费并且比较成熟的数据库，因此，MySQL 被大量使用在各种系统中。任何人都可以在 GPL (General Public License) 的许可下下载并根据个性化的需要对其进行修改。MySQL 的默认端口号是<strong> 3306</strong>。</p>\n<h4 id=\"mysql-有什么优点\"><a class=\"anchor\" href=\"#mysql-有什么优点\">#</a> MySQL 有什么优点？</h4>\n<p>这个问题本质上是在问 MySQL 如此流行的原因。</p>\n<p>MySQL 主要具有下面这些优点：</p>\n<ol>\n<li>成熟稳定，功能完善。</li>\n<li>开源免费。</li>\n<li>文档丰富，既有详细的官方文档，又有非常多优质文章可供参考学习。</li>\n<li>开箱即用，操作简单，维护成本低。</li>\n<li>兼容性好，支持常见的操作系统，支持多种开发语言。</li>\n<li>社区活跃，生态完善。</li>\n<li><strong>事务支持</strong>优秀， InnoDB 存储引擎默认使用 REPEATABLE-READ 并不会有任何性能损失，并且 InnoDB 实现的 REPEATABLE-READ 隔离级别其实是可以解决幻读问题发生的。</li>\n<li>支持<strong>分库分表、读写分离、高可用</strong>。</li>\n</ol>\n<h4 id=\"mysql-中主键和-unique-的区别\"><a class=\"anchor\" href=\"#mysql-中主键和-unique-的区别\">#</a> <mark>MySQL 中主键和 unique 的区别</mark></h4>\n<p>主键和 UNIQUE 约束<font color='red'>都能保证某个列或者列组合的唯⼀性</font>，但是有以下不同：</p>\n<ul>\n<li>\n<p><font color='red'>⼀张表中只能定义⼀个主键</font>，却可以定义多个 UNIQUE 约束！</p>\n</li>\n<li>\n<p><font color='red'>主键列不允许存放 NULL</font>，⽽声明了 UNIQUE 属性的列可以存放 NULL ，⽽且 NULL 可以重复地出现在多条记录中！</p>\n</li>\n</ul>\n<h3 id=\"mysql字段类型\"><a class=\"anchor\" href=\"#mysql字段类型\">#</a> MySQL 字段类型</h3>\n<h4 id=\"整数类型的-unsigned-属性有什么用\"><a class=\"anchor\" href=\"#整数类型的-unsigned-属性有什么用\">#</a> 整数类型的 UNSIGNED 属性有什么用？</h4>\n<p><strong>UNSIGNED 属性来表示不允许负值的无符号整数，因此可以将正整数的上限提高一倍</strong>，因为它不需要存储负数值。</p>\n<p>例如， TINYINT UNSIGNED 类型的取值范围是 0 ~ 255，而普通的 TINYINT 类型的值范围是 -128 ~ 127。INT UNSIGNED 类型的取值范围是 0 ~ 4,294,967,295，而普通的 INT 类型的值范围是 2,147,483,648 ~ 2,147,483,647。</p>\n<p>对于<font color='red'>从 0 开始递增的 ID 列</font>，使用 UNSIGNED 属性可以非常适合，因为不允许负值并且可以拥有更大的上限范围，提供了更多的 ID 值可用。</p>\n<h4 id=\"char-和-varchar-的区别是什么\"><a class=\"anchor\" href=\"#char-和-varchar-的区别是什么\">#</a> CHAR 和 VARCHAR 的区别是什么？</h4>\n<p><strong>CHAR 是定长字符串，VARCHAR 是变长字符串。</strong></p>\n<ul>\n<li>CHAR 在存储时会在右边<font color='red'>填充空格</font>以达到指定的长度，检索时会<font color='red'>去掉空格</font>；VARCHAR 在存储时需要<font color='red'>使用 1 或 2 个额外字节记录字符串的长度</font>，检索时不需要处理。</li>\n<li>CHAR 更适合存储<font color='red'>长度较短或者长度都差不多</font>的字符串，例如 Bcrypt 算法、MD5 算法加密后的密码、身份证号码。VARCHAR 类型适合存储<font color='red'>长度不确定或者差异较大</font>的字符串，例如用户昵称、文章标题等。</li>\n<li>CHAR (M) 和 VARCHAR (M) 的 M 都代表能够保存的字符数的最大值，<font color='red'>无论是字母、数字还是中文，每个都只占用一个字符</font>。</li>\n</ul>\n<h4 id=\"varchar100和-varchar10的区别是什么\"><a class=\"anchor\" href=\"#varchar100和-varchar10的区别是什么\">#</a> VARCHAR (100) 和 VARCHAR (10) 的区别是什么？</h4>\n<p>VARCHAR (100) 和 VARCHAR (10) 都是变长类型，表示能存储最多 100 个字符和 10 个字符。因此，<font color='red'>VARCHAR (100) 可以满足更大范围的字符存储需求</font>，有更好的业务拓展性。而 VARCHAR (10) 存储超过 10 个字符时，就需要修改表结构才可以。</p>\n<p>虽说 VARCHAR (100) 和 VARCHAR (10) 能存储的字符范围不同，但二者存储相同的字符串，所占用磁盘的存储空间其实是一样的，这也是很多人容易误解的一点。</p>\n<p>不过，<font color='red'>VARCHAR (100) 会消耗更多的内存</font>。这是因为 VARCHAR 类型在内存中操作时，<font color='red'>通常会分配固定大小的内存块</font>来保存值，即使用字符类型中定义的长度。例如在进行排序的时候，VARCHAR (100) 是按照 100 这个长度来进行的，也就会消耗更多内存。</p>\n<h4 id=\"decimal-和-floatdouble-的区别是什么\"><a class=\"anchor\" href=\"#decimal-和-floatdouble-的区别是什么\">#</a> DECIMAL 和 FLOAT/DOUBLE 的区别是什么？</h4>\n<p><strong>DECIMAL 是定点数，可以存储精确的小数值；FLOAT/DOUBLE 是浮点数，只能存储近似的小数值。</strong></p>\n<p>在 Java 中，MySQL 的 DECIMAL 类型对应的是 Java 类  <code>java.math.BigDecimal</code> 。</p>\n<h4 id=\"为什么不推荐使用-text-和-blob\"><a class=\"anchor\" href=\"#为什么不推荐使用-text-和-blob\">#</a> 为什么不推荐使用 TEXT 和 BLOB？</h4>\n<p>TEXT 类型类似于 CHAR（0-255 字节）和 VARCHAR（0-65,535 字节），但可以存储更长的字符串，即<font color='cornflowerblue'>长文本数据</font>，例如博客内容。</p>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>可存储大小</th>\n<th>用途</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>TINYTEXT</td>\n<td>0-255 字节</td>\n<td>一般文本字符串</td>\n</tr>\n<tr>\n<td>TEXT</td>\n<td>0-65,535 字节</td>\n<td>长文本字符串</td>\n</tr>\n<tr>\n<td>MEDIUMTEXT</td>\n<td>0-16,772,150 字节</td>\n<td>较大文本数据</td>\n</tr>\n<tr>\n<td>LONGTEXT</td>\n<td>0-4,294,967,295 字节</td>\n<td>极大文本数据</td>\n</tr>\n</tbody>\n</table>\n<p>BLOB 类型主要用于存储<font color='cornflowerblue'>二进制大对象，例如图片、音视频等文件</font>。</p>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>可存储大小</th>\n<th>用途</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>TINYBLOB</td>\n<td>0-255 字节</td>\n<td>短文本二进制字符串</td>\n</tr>\n<tr>\n<td>BLOB</td>\n<td>0-65KB</td>\n<td>二进制字符串</td>\n</tr>\n<tr>\n<td>MEDIUMBLOB</td>\n<td>0-16MB</td>\n<td>二进制形式的长文本数据</td>\n</tr>\n<tr>\n<td>LONGBLOB</td>\n<td>0-4GB</td>\n<td>二进制形式的极大文本数据</td>\n</tr>\n</tbody>\n</table>\n<p>在日常开发中，很少使用 TEXT 类型，但偶尔会用到，而 BLOB 类型则基本不常用。<font color='red'>如果预期长度范围可以通过 VARCHAR 来满足，建议避免使用 TEXT</font>。</p>\n<p>数据库规范通常不推荐使用 BLOB 和 TEXT 类型，这两种类型具有一些缺点和限制，例如：</p>\n<ul>\n<li><font color='red'>不能有默认值</font></li>\n<li>在使用临时表时<font color='red'>无法使用内存临时表，只能在磁盘上创建临时表</font>（《高性能 MySQL》书中有提到）</li>\n<li><font color='red'>检索效率较低</font></li>\n<li><font color='red'>不能直接创建索引</font>，需要指定前缀长度</li>\n<li><font color='red'>会消耗大量的网络和 IO 带宽</font></li>\n<li>可能导致表上的<font color='red'> DML 操作变慢</font></li>\n<li>……</li>\n</ul>\n<h4 id=\"datetime-和-timestamp-的区别是什么\"><a class=\"anchor\" href=\"#datetime-和-timestamp-的区别是什么\">#</a> DATETIME 和 TIMESTAMP 的区别是什么？</h4>\n<p><strong>DATETIME 类型没有时区信息，TIMESTAMP 和时区有关</strong>。</p>\n<p><font color='red'>TIMESTAMP 只需要使用 4 个字节的存储空间，但是 DATETIME 需要耗费 8 个字节的存储空间</font>。但是，这样同样造成了一个问题，<font color='red'>Timestamp 表示的时间范围更小</font>。</p>\n<ul>\n<li>DATETIME：1000-01-01 00:00:00 ~ 9999-12-31 23:59:59</li>\n<li>Timestamp：1970-01-01 00:00:01 ~ 2037-12-31 23:59:59</li>\n</ul>\n<h4 id=\"null-和-的区别是什么\"><a class=\"anchor\" href=\"#null-和-的区别是什么\">#</a> NULL 和 '' 的区别是什么？</h4>\n<p><code>NULL</code>  跟  <code>''</code> (空字符串) 是两个完全不一样的值，区别如下：</p>\n<ul>\n<li><strong> <code>NULL</code>  代表一个不确定的值，但占用空间</strong>。就算是两个  <code>NULL</code> ，它俩也不一定相等。例如， <code>SELECT NULL=NULL</code>  的结果为 false，但是在我们使用 <code>DISTINCT</code> ， <code>GROUP BY</code> ， <code>ORDER BY</code>  时， <code>NULL</code>  又被认为是相等的。</li>\n<li><strong> <code>''</code>  是长度为 0 的字符串，不占用空间</strong>。</li>\n<li><font color='red'> <code>NULL</code>  会影响聚合函数的结果</font>。例如， <code>SUM</code> 、 <code>AVG</code> 、 <code>MIN</code> 、 <code>MAX</code>  等聚合函数会忽略  <code>NULL</code>  值。 <code>COUNT</code>  的处理方式取决于参数的类型。如果参数是  <code>*</code> ( <code>COUNT(*)</code> )，则会统计所有的记录数，包括  <code>NULL</code>  值；如果参数是某个字段名 ( <code>COUNT(列名)</code> )，则会忽略  <code>NULL</code>  值，只统计非空值的个数。</li>\n<li><font color='red'>查询  <code>NULL</code>  值时，必须使用  <code>IS NULL</code>  或  <code>IS NOT NULLl</code>  来判断</font>，而不能使用 =、!=、 &lt;、&gt; 之类的比较运算符。而 <code>''</code>  是可以使用这些比较运算符的。</li>\n</ul>\n<p><strong>因此，MySQL 不建议使用  <code>NULL</code>  作为列默认值。</strong></p>\n<h4 id=\"boolean-类型如何表示\"><a class=\"anchor\" href=\"#boolean-类型如何表示\">#</a> Boolean 类型如何表示？</h4>\n<p>MySQL 中没有专门的布尔类型，而是<strong>用 TINYINT (1) 类型来表示布尔值</strong>。TINYINT (1) 类型可以存储 0 或 1，分别对应 false 或 true。</p>\n<h3 id=\"mysql基础架构\"><a class=\"anchor\" href=\"#mysql基础架构\">#</a> MySQL 基础架构</h3>\n<blockquote>\n<p>配合 <a href=\"\">SQL 语句在 MySQL 中的执行过程</a> 这篇文章来理解 MySQL 基础架构。</p>\n</blockquote>\n<p>一个 SQL 语句在 MySQL 中的执行流程，包括 SQL 的查询在 MySQL 内部会怎么流转，SQL 语句的更新是怎么完成的。</p>\n<p>在分析之前先看看 MySQL 的基础架构，知道了 MySQL 由那些组件组成，以及这些组件的作用是什么，可以帮助我们理解和解决这些问题。</p>\n<h4 id=\"1-mysql-基础架构分析\"><a class=\"anchor\" href=\"#1-mysql-基础架构分析\">#</a> 1、MySQL 基础架构分析</h4>\n<h5 id=\"11-架构概览\"><a class=\"anchor\" href=\"#11-架构概览\">#</a> 1.1、架构概览</h5>\n<p>下图是 MySQL 的一个简要架构图，可以很清晰地看到客户端的一条 SQL 语句在 MySQL 内部是如何执行的。</p>\n<p>从图中可以看出，MySQL 主要由下面几部分构成：</p>\n<ul>\n<li><strong>连接器：</strong><font color='red'>连接管理、身份认证和权限</font>相关 (登录 MySQL 的时候)。</li>\n<li>** 查询缓存：** 执行查询语句的时候，会<font color='red'>先查询缓存，命中则直接返回</font>（<font color='red'>MySQL 8.0 版本后移除</font>，因为这个功能不太实用）。</li>\n<li><strong>分析器：</strong><font color='red'>对 SQL 语句进行词法分析、语法分析</font>。说白了就是要先看 SQL 语句要干嘛，再检查 SQL 语句语法是否正确。</li>\n<li><strong>优化器：</strong><font color='red'>执行计划生产，索引选择</font>。按照 MySQL 认为<font color='red'>最优的方案</font>去执行。</li>\n<li>** 执行器：** 执行语句，然后<font color='red'>从存储引擎返回数据</font>。</li>\n<li><strong>插件式存储引擎</strong>：主要负责<font color='red'>数据的存储和读取</font>，采用的是 <code>插件式架构</code> ，支持 InnoDB、MyISAM、Memory 等多种存储引擎。</li>\n</ul>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/13526879-3037b144ed09eb88.png\" alt=\"img\" /></p>\n<center>MySQL 简要架构图</center>\n<p>MySQL 主要分为 Server 层和存储引擎层：</p>\n<ul>\n<li><strong>Server 层</strong>：主要包括<font color='red'>连接器、查询缓存、分析器、优化器、执行器</font>等，所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图，函数等，还有一个通用的日志模块 **<font color='red'> binlog 日志模块</font>**。</li>\n<li><strong>存储引擎层</strong>：主要负责<font color='red'>数据的存储和读取</font>，采用可以替换的插件式架构，支持 <font color='red'>InnoDB、MyISAM、Memory</font> 等多个存储引擎。其中 InnoDB 引擎有自有的日志模块 **<font color='red'> redolog 日志模块</font><strong>。</strong><font color='red'>现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5 版本开始就被当做默认存储引擎了</font>**。</li>\n</ul>\n<h5 id=\"12-server-层的组件介绍\"><a class=\"anchor\" href=\"#12-server-层的组件介绍\">#</a> 1.2、Server 层的组件介绍</h5>\n<h6 id=\"1连接器\"><a class=\"anchor\" href=\"#1连接器\">#</a> 1）连接器</h6>\n<p>连接器主要和 **<font color='red'>身份认证和权限相关</font>** 的功能相关，就好比一个级别很高的门卫一样。</p>\n<p>主要负责用户登录数据库，进行用户的身份认证，包括校验账户密码，权限等操作。如果用户账户密码已通过，连接器会到权限表中查询该用户的所有权限，之后在这个连接里的权限逻辑判断都<font color='red'>仅依赖起始连接成功时读取到的权限数据</font>。也就是说，<font color='red'>后续只要这个连接不断开，即使管理员修改了该用户的权限，该用户也是不受影响的</font>。</p>\n<h6 id=\"2查询缓存\"><a class=\"anchor\" href=\"#2查询缓存\">#</a> 2）查询缓存</h6>\n<blockquote>\n<p><strong>从 MySQL8.0 后移除</strong></p>\n</blockquote>\n<p>查询缓存主要 **<font color='red'>用来缓存所执行的 SELECT 语句以及该语句的结果集</font>**。</p>\n<p>若连接成功建立，<font color='red'>执行查询语句的时候，会先查询缓存</font>。</p>\n<ul>\n<li>MySQL 会先校验这个 SQL 是否执行过，<font color='red'>以 Key-Value 的形式缓存在内存中，Key 是查询语句，Value 是结果集</font>。</li>\n<li>如果缓存 key 被命中，就会直接返回给客户端。</li>\n<li>如果缓存 key 没有命中，就会执行后续的操作，<font color='red'>完成后也会把结果缓存起来，方便下一次调用</font>。</li>\n</ul>\n<p><strong><font color='red'>MySQL 查询不建议使用缓存，因为表更新会清空表上的所有查询缓存，导致查询缓存频繁失效</font></strong>。假如你对一个表更新的话，这个表上的所有的查询缓存都会被清空。对于不经常更新的数据来说，使用缓存还是可以的。</p>\n<p>MySQL 8.0 版本后删除了缓存的功能，官方也是认为该功能在实际的应用场景比较少，所以干脆直接删掉了。</p>\n<h6 id=\"3分析器\"><a class=\"anchor\" href=\"#3分析器\">#</a> 3）分析器</h6>\n<p><font color='red'>MySQL 没有命中缓存，那么就会进入分析器</font>。</p>\n<p><strong><font color='red'>第一步，词法分析</font></strong>：一条 SQL 语句有多个字符串组成，首先要<font color='red'>提取关键字</font>，比如 select，提出查询的表，提出字段名，提出查询条件等等。</p>\n<p><strong><font color='red'>第二步，语法分析</font></strong>：主要就是判断你输入的 SQL 是否正确，<font color='red'>判断是否符合 MySQL 的语法</font>。</p>\n<p>完成这 2 步之后，MySQL 就准备开始执行了，但是如何执行，怎么执行是最好的结果呢？这个时候就需要优化器上场了。</p>\n<h6 id=\"4优化器\"><a class=\"anchor\" href=\"#4优化器\">#</a> 4）优化器</h6>\n<p>优化器的作用就是 **<font color='red'>按照它认为的最优执行方案去执行</font>**，比如多个索引的时候该<font color='red'>如何选择索引</font>，多表查询的时候<font color='red'>如何选择关联顺序</font>等。</p>\n<p>可以说，经过了优化器之后，这个语句具体该如何执行就已经定下来。</p>\n<h6 id=\"5执行器\"><a class=\"anchor\" href=\"#5执行器\">#</a> 5）执行器</h6>\n<p>当选择了执行方案后，MySQL 就准备开始执行了。首先执行前会校验该用户有没有权限，如果没有权限，就会返回错误信息。<strong><font color='red'>如果有权限，就会去调用存储引擎的接口，返回执行结果</font></strong>。</p>\n<h4 id=\"2-sql-执行过程分析\"><a class=\"anchor\" href=\"#2-sql-执行过程分析\">#</a> 2、SQL 执行过程分析</h4>\n<h5 id=\"21-dql-查询语句\"><a class=\"anchor\" href=\"#21-dql-查询语句\">#</a> 2.1、DQL 查询语句</h5>\n<blockquote>\n<p>select</p>\n</blockquote>\n<p>针对 select 语句：</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">select</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">from</span> tb_student  A <span class=\"token keyword\">where</span> A<span class=\"token punctuation\">.</span>age<span class=\"token operator\">=</span><span class=\"token string\">'18'</span> <span class=\"token operator\">and</span> A<span class=\"token punctuation\">.</span>name<span class=\"token operator\">=</span><span class=\"token string\">' 张三 '</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>结合上面的说明，我们分析下这个语句的执行流程：</p>\n<ol>\n<li><strong>检查该语句是否有权限</strong>：\n<ul>\n<li>如果没有权限，直接返回错误信息。</li>\n<li>如果有权限，在 MySQL8.0 版本以前，会<strong>查询缓存</strong>，以这条 SQL 语句为 key 在内存中查询是否有结果，有则直接返回，无则执行下一步。</li>\n</ul>\n</li>\n<li><strong>通过分析器对 SQL 语句进行词法分析、语法分析</strong>。\n<ul>\n<li><font color='red'>提取关键元素</font>，比如提取上面这个语句是查询 select，提取需要查询的表名为 tb_student，需要查询所有的列，查询条件是这个表的 id='1'。</li>\n<li><font color='red'>判断是否有语法错误</font>，比如关键词是否正确等等，如果检查没问题就执行下一步。</li>\n</ul>\n</li>\n<li><strong>优化器确定执行方案</strong>。上面的 SQL 语句，可以有两种执行方案：a. 先查询学生表中姓名为 “张三” 的学生，然后判断是否年龄是 18。b. 先找出学生中年龄 18 岁的学生，然后再查询姓名为 “张三” 的学生。那么<font color='red'>优化器根据优化算法选择执行效率最好的一个方案（优化器认为，有时候不一定最好）</font>。那么确认了执行计划后就准备开始执行了。</li>\n<li>执行语句之前，先进行权限校验，如果没有权限就会返回错误信息。<strong>如果有权限，执行器就会调用存储引擎接口，返回执行结果</strong>。</li>\n</ol>\n<h5 id=\"22-dml-更新语句\"><a class=\"anchor\" href=\"#22-dml-更新语句\">#</a> 2.2、DML 更新语句</h5>\n<blockquote>\n<p>以 update 为例</p>\n</blockquote>\n<p>针对 update 语句：</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">update</span> tb_student A <span class=\"token keyword\">set</span> A<span class=\"token punctuation\">.</span>age<span class=\"token operator\">=</span><span class=\"token string\">'19'</span> <span class=\"token keyword\">where</span> A<span class=\"token punctuation\">.</span>name<span class=\"token operator\">=</span><span class=\"token string\">' 张三 '</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p><font color='red'>这条语句也基本上会沿着上一个查询的流程走，只不过<strong>执行更新的时候肯定要记录日志</strong>，这就会引入日志模块了</font>。</p>\n<p>MySQL 自带的日志模块是 <strong><font color='cornflowerblue'>binlog（归档日志）</font></strong>，所有的存储引擎都可以使用。而常用的 InnoDB 引擎还自带了一个日志模块 <strong><font color='cornflowerblue'>redo log（重做日志）</font></strong>。</p>\n<p>我们就以 InnoDB 模式下来探讨这个语句的执行流程：</p>\n<ol>\n<li>\n<p><font color='red'>先查询到这一条数据</font>（根据 name = 张三），如果有缓存，也是会用到缓存。</p>\n</li>\n<li>\n<p>然后拿到查询的语句，<font color='red'>把 age 改为 19</font>，然后<font color='red'>调用存储引擎 API 接口，写入这一行数据</font>。InnoDB 引擎把数据保存在内存中，同时 **<font color='red'>InnoDB 引擎记录 redo log，此时 redo log 进入 prepare 状态</font>**。然后告诉执行器，执行完成了，随时可以提交。</p>\n</li>\n<li>\n<p><strong><font color='red'>执行器收到 InnoDB 引擎的通知后，记录 binlog</font></strong>。然后 **<font color='red'>执行器调用引擎接口，提交 redo log 为提交状态</font>**。</p>\n</li>\n<li>\n<p>更新完成。</p>\n</li>\n</ol>\n<hr />\n<p>为什么要用两个日志模块，用一个日志模块不行吗？</p>\n<p>这是因为最开始 MySQL 并没有 InnoDB 引擎（InnoDB 引擎是其他公司以插件形式插入 MySQL 的），MySQL 自带的引擎是 MyISAM。但是我们知道<font color='red'> redo log 是 InnoDB 引擎特有的，其他存储引擎都没有，这就导致会没有 crash-safe 的能力</font>（crash-safe 的能力即使数据库发生异常重启，之前提交的记录都不会丢失），<font color='red'>而 binlog 日志只能用来归档</font>。</p>\n<p>并不是说只用一个日志模块不可以，只是 **<font color='red'> InnoDB 引擎就是通过 redo log 来支持事务的</font>**。那么，又会有同学问，我用两个日志模块，但是不要这么复杂行不行，为什么 redo log 要引入 prepare 预提交状态？这里我们用反证法来说明下为什么要这么做？</p>\n<ul>\n<li>先写 redo log 直接提交，然后写 binlog：假设写完 redo log 后，机器挂了，binlog 日志没有被写入，那么机器重启后，这台机器会通过 redo log 恢复数据，但是这个时候 binlog 并没有记录该数据，后续进行机器备份的时候，就会丢失这一条数据，同时主从同步也会丢失这一条数据。</li>\n<li>先写 binlog，然后写 redo log：假设写完了 binlog，机器异常重启了，由于没有 redo log，本机是无法恢复这一条记录的，但是 binlog 又有记录，那么和上面同样的道理，就会产生数据不一致的情况。</li>\n</ul>\n<p><strong><font color='red'>redo log 两阶段提交的方式可以保证数据的一致性</font></strong>。写完 binlog 后，然后再提交 redo log 就会防止出现上述的问题，从而保证了数据的一致性。那么问题来了，有没有一个极端的情况呢？<font color='red'>假设 redo log 处于 prepare 状态，binlog 也已经写完了，这个时候发生了异常重启会怎么样呢？</font> 这个就要依赖于 MySQL 的处理机制了：</p>\n<ul>\n<li>判断 redo log 是否完整，如果判断是完整的，就立即提交。</li>\n<li>如果 redo log 只是 prepare，但不是 commit 状态，这个时候就会去判断 binlog 是否完整，如果完整就提交 redo log, 不完整就回滚事务。</li>\n</ul>\n<p>这样就解决了数据一致性的问题。</p>\n<h4 id=\"3-小结\"><a class=\"anchor\" href=\"#3-小结\">#</a> 3、小结</h4>\n<ul>\n<li>MySQL 主要分为 <font color='cornflowerblue'>Server 层</font>和<font color='cornflowerblue'>引擎层</font>，Server 层主要包括<font color='red'>连接器、查询缓存、分析器、优化器、执行器</font>，同时还有一个<font color='red'>归档日志模块（binlog）</font>，这个日志模块所有执行引擎都可以共用，<font color='red'>而重做日志模块（redolog）只有 InnoDB 有</font>。</li>\n<li>Server 层中各组件的功能：\n<ul>\n<li><strong>连接器</strong>：管理连接、权限验证；</li>\n<li><strong>查询缓存</strong>：命中缓存则直接返回结果；</li>\n<li><strong>分析器</strong>：对 SQL 进行词法分析、语法分析；</li>\n<li><strong>优化器</strong>：执行计划生成、选择索引；</li>\n<li><strong>执行器</strong>：操作引擎、返回结果；</li>\n<li><strong>存储引擎</strong>：存储数据、提供读写接口。</li>\n</ul>\n</li>\n<li>引擎层是插件式的，目前主要包括，<font color='red'>MyISAM、InnoDB、Memory</font>等。</li>\n<li><font color='gree'>查询语句</font>的执行流程如下：<font color='red'>权限校验 ---&gt; 查询缓存（如果命中，直接返回）---&gt; 分析器 ---&gt; 优化器 ---&gt;<strong> 权限校验</strong> ---&gt; 执行器 ---&gt; 引擎</font></li>\n<li><font color='gree'>更新语句</font>执行流程如下：<font color='red'>分析器 ----&gt; 权限校验 ----&gt; 执行器 ---&gt; 引擎 ---<strong>redo log (prepare 状态)</strong>---&gt;<strong>binlog</strong>---&gt;<strong>redo log (commit 状态)</strong></font></li>\n<li>笼统点的回答，<strong>一条 SQL 的执行过程</strong>：\n<ol>\n<li>客户端请求 -&gt;</li>\n<li>连接器（验证用户身份，给予权限） -&gt;</li>\n<li>查询缓存（存在缓存则直接返回，不存在则执行后续操作）-&gt;</li>\n<li>分析器（对 SQL 进行词法分析、语法分析） -&gt;</li>\n<li>优化器（选择最优的 SQL 执行方案） -&gt;</li>\n<li>执行器（先检查用户是否有执行权限，有的话才调用引擎接口，执行 SQL）-&gt;</li>\n<li>从引擎层获取数据返回（如果开启查询缓存，则会缓存查询结果）</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"mysql存储引擎\"><a class=\"anchor\" href=\"#mysql存储引擎\">#</a> MySQL 存储引擎</h3>\n<h4 id=\"mysql-体系结构\"><a class=\"anchor\" href=\"#mysql-体系结构\">#</a> MySQL 体系结构</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231125095453053.png\" alt=\"image-20231125095453053\" /></p>\n<ol>\n<li>\n<p>连接层：负责客户端和连接服务，例如连接处理、授权认证、及相关的安全方案</p>\n</li>\n<li>\n<p>服务层：负责 SQL 接口，SQL 的解析和优化，并完成缓存的查询，部分内置函数的执行。</p>\n<blockquote>\n<p>所有跨存储引擎的功能也在这一层实现，如过程、函数等。</p>\n</blockquote>\n</li>\n<li>\n<p>引擎层：负责 MySQL 中数据的存储和读取，根据需要选择合适的存储引擎，索引就是在这一层实现的。</p>\n</li>\n<li>\n<p>存储层：负责将数据持久化地存储到文件系统中，并完成与存储引擎的交互。</p>\n</li>\n</ol>\n<h4 id=\"存储引擎介绍\"><a class=\"anchor\" href=\"#存储引擎介绍\">#</a> 存储引擎介绍</h4>\n<p>存储引擎的特点：</p>\n<ul>\n<li>存储引擎就是<font color='red'>存储数据、<strong>建立索引</strong>、更新 / 查询数据</font>的实现方式。</li>\n<li>存储引擎<font color='red'>是基于表的</font>，而不是基于库的。</li>\n<li><font color='red'>默认的存储引擎是 InnoDB</font>。</li>\n</ul>\n<p>与存储引擎有关的 SQL 语句：</p>\n<ul>\n<li>\n<p>建表时指定存储引擎：</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">create</span> <span class=\"token keyword\">table</span> 表名<span class=\"token punctuation\">(</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">)</span> <span class=\"token keyword\">engine</span><span class=\"token operator\">=</span><span class=\"token keyword\">InnoDB</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure></li>\n<li>\n<p>查询建表语句：</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">show</span> <span class=\"token keyword\">create</span> <span class=\"token keyword\">table</span> 表名<span class=\"token punctuation\">;</span></pre></td></tr></table></figure></li>\n<li>\n<p>查看当前数据库支持的存储引擎：</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">show</span> engines<span class=\"token punctuation\">;</span></pre></td></tr></table></figure></li>\n</ul>\n<h4 id=\"常用的存储引擎\"><a class=\"anchor\" href=\"#常用的存储引擎\">#</a> <mark>常用的存储引擎</mark></h4>\n<p>重点介绍三种存储引擎 InnoDB、MyISAM、Memory 的特点。</p>\n<h5 id=\"innodb\"><a class=\"anchor\" href=\"#innodb\">#</a> InnoDB</h5>\n<p>（1）介绍</p>\n<p>MySQL 5.5 版本开始，<strong><font color='red'>默认使用 InnoDB 作为存储引擎</font></strong>。它<font color='red'>擅长处理事务，具有崩溃恢复的特性</font>，是一种兼顾<font color='red'>高可靠性、高性能</font>的通用存储引擎。</p>\n<p>（2）特点</p>\n<ul>\n<li><strong><font color='#B32015'>支持事务</font></strong>：\n<ul>\n<li>DML 操作遵循 ACID 模型</li>\n<li>实现了 SQL 标准定义了<font color='red'>四个隔离级别</font>，具有<font color='red'>提交 (commit) 和回滚 (rollback) 事务</font>的能力</li>\n<li>提供<font color='red'>一组用来记录事务性活动的日志文件</font></li>\n<li>InnoDB 默认使用的 REPEATABLE-READ（可重读）隔离级别是<font color='red'>可以解决幻读问题</font>发生的（基于 MVCC 和 Next-Key Lock）</li>\n</ul>\n</li>\n<li><strong><font color='#B32015'>支持行级锁</font></strong>：因此 InnoDB <font color='red'>并发写的性能更高</font></li>\n<li><strong><font color='#B32015'>支持外键</font></strong>：<font color='red'>能维护数据的一致性和完整性</font>（级联删除、级联更新），<font color='red'>但对性能有一定的损耗</font>。但阿里的《Java 开发手册》明令禁止使用外键！</li>\n</ul>\n<p>（3）存储文件</p>\n<ul>\n<li><code>.sdi</code> ：表结构</li>\n<li><mark> <code>.ibd 表空间文件</code> </mark>：数据、索引。每张 InnoDB 表对应一个 .ibd 表空间文件</li>\n</ul>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231125113620280.png\" alt=\"image-20231125113620280\" /></p>\n<p>（4）逻辑存储结构</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231125111944812.png\" alt=\"image-20231125111944812\" /></p>\n<ul>\n<li><strong>表空间（Tablespace）</strong>：即<font color='red'> ibd 文件</font>，由多个 Segment 组成</li>\n<li><strong>段（Segment）</strong>：分为<font color='red'>数据段、索引段、回滚段</font>等，由 InnoDB 自身管理，由多个 Extent 组成</li>\n<li><strong>区（Extent）</strong>：<font color='red'>固定大小为 1M，由 64 个连续的 Page 组成</font></li>\n<li><strong>页（Page）</strong>：<font color='red'>固定大小为 16 KB</font>，是 InnoDB 磁盘管理的最小单元</li>\n<li><strong>行（Row）</strong>：<font color='red'>存放行记录数据</font>，由最后一次事务的 id、回滚指针、各个字段的值组成</li>\n</ul>\n<h5 id=\"myisam\"><a class=\"anchor\" href=\"#myisam\">#</a> MyISAM</h5>\n<p>（1）介绍</p>\n<p>MyISAM 是 MySQL <font color='red'>早期的</font>默认存储引擎。</p>\n<p>（2）特点</p>\n<ul>\n<li>不支持事务与外键，仅支持表级锁</li>\n<li>灵活的 AUTO_INCREMENT 字段处理</li>\n<li>可被转换为压缩、只读表来节省空间</li>\n</ul>\n<p>（3）存储文件</p>\n<ul>\n<li><code>.sdi</code> ：表结构</li>\n<li><code>.MYD</code> ：数据</li>\n<li><code>.MYI</code> ：索引</li>\n</ul>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231125113606459.png\" alt=\"image-20231125113606459\" /></p>\n<h5 id=\"memory\"><a class=\"anchor\" href=\"#memory\">#</a> Memory</h5>\n<p>（1）介绍</p>\n<p>Memory 引擎表的 **<font color='red'>数据存储在内存中</font>**，由于受到硬件问题、或断电问题的影响，只能将这些表作为<font color='red'>临时表或缓存</font>使用。</p>\n<p>（2）特点</p>\n<ul>\n<li>数据存放在内存中</li>\n<li>默认采用 <font color='red'>hash 索引</font> 结构</li>\n</ul>\n<p>（3）文件</p>\n<ul>\n<li><code>.sdi</code> ：表结构</li>\n</ul>\n<h5 id=\"特点对比\"><a class=\"anchor\" href=\"#特点对比\">#</a> <mark>特点对比</mark></h5>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231125113958109.png\" alt=\"image-20231125113958109\" /></p>\n<p>MySQL 中常用的三种存储引擎分别是：InnoDB、MyISAM、MEMORY，区别如下：</p>\n<ul>\n<li><font color='cornflowerblue'>InnoDB</font>：<strong><font color='red'>支持事务处理、行级锁、外键，拥有崩溃修复能力、并发控制</font></strong>。如果需要<font color='red'>对事务的完整性要求比较高</font>（比如银行），<font color='red'>要求实现并发控制</font>（比如售票），那选择 InnoDB 有很大的优势。如果<font color='red'>需要频繁的更新、删除操作</font>的数据库，也可以选择 InnoDB，因为支持事务的提交（commit）和回滚（rollback）。</li>\n<li><font color='cornflowerblue'>MyISAM</font>：<strong><font color='red'>插入数据快，空间和内存使用比较低</font></strong>。如果表主要是用于<font color='red'>插入新记录和读出记录</font>，那么选择 MyISAM 能实现处理高效率。如果应用的<font color='red'>完整性、并发性要求比较低</font>，也可以使用。</li>\n<li><font color='cornflowerblue'>MEMORY</font>：<strong><font color='red'>所有的数据都在内存中，数据的处理速度快，但是安全性不高</font></strong>。如果<font color='red'>需要很快的读写速度，对数据的安全性要求较低</font>，可以选择 MEMOEY。它对表的大小有要求，<font color='red'>不能建立太大的表</font>。所以，这类数据库只使用在相对较小的数据库表。如果只是<font color='red'>临时存放数据，数据量不大，并且不需要较高的数据安全性</font>，可以选择将数据保存在内存中的 Memory 引擎，MySQL 中使用该引擎 **<font color='red'>作为临时表，存放查询的中间结果</font>**。</li>\n</ul>\n<h4 id=\"存储引擎选择\"><a class=\"anchor\" href=\"#存储引擎选择\">#</a> 存储引擎选择</h4>\n<ul>\n<li>InnoDB：适用于<font color='red'>较多的数据更新操作</font>，对<font color='red'>事务、并发、数据完整性</font>要求较高的核心数据。</li>\n<li>MyISAM：适用于<font color='red'>大量的数据读操作</font>，常被 MongoDB 取代。</li>\n<li>Memory：因为访问速度快，适用于<font color='red'>临时表、缓存</font>，但<font color='red'>对表大小有限制</font>（太大的表无法缓存到内存中），并且<font color='red'>无法保障数据的安全性</font>，常被 Redis 取代。</li>\n</ul>\n<h4 id=\"面试题\"><a class=\"anchor\" href=\"#面试题\">#</a> 面试题</h4>\n<h5 id=\"mysql-支持哪些存储引擎默认使用哪个\"><a class=\"anchor\" href=\"#mysql-支持哪些存储引擎默认使用哪个\">#</a> MySQL 支持哪些存储引擎？默认使用哪个？</h5>\n<p>MySQL 支持多种存储引擎，你可以通过  <code>show engines</code>  命令来查看 MySQL 支持的所有存储引擎。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20220510105408703.png\" alt=\"查看 MySQL 提供的所有存储引擎\" /></p>\n<p>从上图我们可以查看出，<strong>MySQL 5.5.5 之后，默认的存储引擎是 InnoDB</strong>。并且，<strong>只有 InnoDB 支持事务、行级锁、外键</strong>。</p>\n<p>MySQL 5.5.5 之前，MyISAM 是 MySQL 的默认存储引擎。5.5.5 版本之后，InnoDB 是 MySQL 的默认存储引擎。</p>\n<h5 id=\"mysql-存储引擎架构了解吗\"><a class=\"anchor\" href=\"#mysql-存储引擎架构了解吗\">#</a> MySQL 存储引擎架构了解吗？</h5>\n<p>MySQL 存储引擎采用的是<strong>插件式架构，支持多种存储引擎</strong>。我们甚至可以为不同的数据库表设置不同的存储引擎以适应不同场景的需要。<strong>存储引擎是基于表的，而不是数据库。</strong></p>\n<h5 id=\"myisam-和-innodb-有什么区别\"><a class=\"anchor\" href=\"#myisam-和-innodb-有什么区别\">#</a> <mark>MyISAM 和 InnoDB 有什么区别？</mark></h5>\n<p>MySQL 5.5 之前，MyISAM 引擎是 MySQL 的默认存储引擎，可谓是风光一时。</p>\n<p>虽然，MyISAM 的性能还行，各种特性也还不错（比如全文索引、压缩、空间函数等）。但是，<strong><font color='red'>MyISAM 不支持事务、行级锁和外键，而且最大的缺陷就是崩溃后无法自动恢复数据</font></strong>。</p>\n<p>MySQL 5.5 版本之后，InnoDB 是 MySQL 的默认存储引擎。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231108152443561.png\" alt=\"image-20231108152443561\" /></p>\n<p>言归正传！咱们下面还是来简单对比一下两者：</p>\n<p><strong>1. 是否支持事务</strong></p>\n<ul>\n<li>\n<p>MyISAM 不支持事务，但<font color='red'>每次查询都是原子的</font>；</p>\n</li>\n<li>\n<p>InnoDB 支持 ACID 的事务，实现了四种隔离级别。具有提交 ( <code>commit</code> ) 和回滚 ( <code>rollback</code> ) 事务的能力；</p>\n<blockquote>\n<p>并且 InnoDB 默认的 RR 隔离级别是可以解决幻读问题发生的（基于 MVCC 和 Next-Key Lock）。</p>\n</blockquote>\n</li>\n</ul>\n<p>关于 MySQL 事务的详细介绍：<a href=\"#==4%E7%A7%8D%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB==\">4 种隔离级别</a>。</p>\n<p><strong>2. 是否支持行级锁</strong></p>\n<ul>\n<li>MyISAM 只支持表级锁，即每次操作都是对整个表加锁；</li>\n<li>InnoDB 不仅支持表级锁，<font color='red'>还支持行级锁（默认），因此支持并发写</font>；</li>\n</ul>\n<p><strong>3. 是否支持外键</strong></p>\n<ul>\n<li>MyISAM 不支持外键约束；</li>\n<li><font color='red'>InnoDB 支持外键约束</font>；</li>\n</ul>\n<p>外键对于维护数据一致性非常有帮助，但是<font color='red'>外键对性能有一定的损耗</font>。因此，通常情况下，我们是不建议在实际生产项目中使用外键的，在业务代码中进行约束即可！</p>\n<p><strong>4. 是否存储表的总行数</strong></p>\n<ul>\n<li><font color='red'>MyISAM 存储表的总行数</font></li>\n<li>InnoDB 不存储表的总行数</li>\n</ul>\n<p><strong>5. 存储文件</strong></p>\n<ul>\n<li>一个 MyISAM 表有三个文件：表结构文件（.sdi)、数据文件（.MYD）、索引文件（.MYI）</li>\n<li>一个 InnoDB 表有两个文件：表结构文件（.sdi)、<font color='red'>数据和索引文件（ <code>.ibd 表空间文件</code> ）</font></li>\n</ul>\n<p><strong>6. 是否采用聚集索引</strong></p>\n<ul>\n<li><font color='red'>MyISAM 采用非聚集索引</font>，索引文件的数据域存储的是指向数据文件的指针。辅索引与主索引基本一致，但是辅索引不用保证唯一性；</li>\n<li><font color='red'>InnoDB 主键索采用聚集索引（索引的数域存数据文件本身），辅助索引的数域存储主键的值</font>。因此从索引查找数据时，需要先通过辅助索引找到主键值，再访问聚集索引。因此最好使用自增主键，防止插入数据时乱序，导致页分裂，性能低下。</li>\n</ul>\n<p><strong>7. 是否支持数据库异常崩溃后的安全恢复</strong></p>\n<ul>\n<li>\n<p>MyISAM 不支持</p>\n</li>\n<li>\n<p><font color='red'>InnoDB 支持数据库异常崩溃后的安全恢复</font></p>\n<blockquote>\n<p>使用 InnoDB 的数据库在异常崩溃后，数据库重新启动时会保证数据库恢复到崩溃前的状态。这个恢复的过程依赖于 InnoDB 的<strong>重做日志模块 <code>redo log</code> </strong>。</p>\n</blockquote>\n</li>\n</ul>\n<p><strong>8. 是否支持 MVCC</strong></p>\n<p><font color='red'>MVCC 可以看作是行级锁的一个升级，可以有效减少加锁操作，提高性能</font>。</p>\n<ul>\n<li>MyISAM 不支持，它连行级锁都不支持</li>\n<li><font color='red'>InnoDB 支持 MVCC</font></li>\n</ul>\n<p><strong>9. 索引实现不一样</strong></p>\n<p>虽然 MyISAM 引擎和 InnoDB 引擎<font color='red'>都是使用 B+Tree 作为索引结构</font>，但是两者的实现方式不太一样。</p>\n<ul>\n<li>\n<p>MyISAM 中，B+Tree 叶节点的 data 域存放的是<font color='gree'>数据记录的地址</font>。在索引检索的时候，首先按照 B+Tree 搜索算法搜索索引，如果指定的 Key 存在，则取出其 data 域的值，然后以 data 域的值为地址读取相应的数据记录。这被称为 **<font color='#B32015'>非聚集索引</font>**。</p>\n</li>\n<li>\n<p>InnoDB 中，<font color='red'>其数据文件本身就是（主）索引文件</font>，按 B+Tree 组织的一个索引结构，树的叶节点中 key 域是主键，data 域是<font color='gree'>完整的数据记录</font>，这被称为 **<font color='#B32015'>聚集索引</font><strong>。而<font color='red'>其余的索引都作为</strong>辅助索引 **</font>，树的叶节点中 key 域是非主键字段，data 域存放的是<font color='gree'>主键</font>。</p>\n<blockquote>\n<ul>\n<li>\n<p>在根据主索引搜索时，直接找到 key 所在的节点即可取出完整的数据记录；</p>\n</li>\n<li>\n<p>而在根据辅助索引查找时，则需要先取出主键的值，然后再走一遍主索引，称为<strong>二次查询（回表）</strong>。</p>\n</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n<p><strong>10. 性能有差别</strong></p>\n<ul>\n<li>\n<p>MyISAM 的读写不能并发，<font color='red'>它的处理能力跟核数没关系</font></p>\n</li>\n<li>\n<p><font color='red'>InnoDB 的性能比 MyISAM 更强大</font>，不管是在读写混合模式下还是只读模式下。且随着 CPU 核数的增加，InnoDB 的读写能力呈线性增长。</p>\n</li>\n</ul>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/innodb-myisam-performance-comparison.png\" alt=\"InnoDB 和 MyISAM 性能对比\" /></p>\n<p><strong>总结</strong> ：</p>\n<ul>\n<li><strong>InnoDB 支持事务处理，而 MyISAM 不支持</strong>。</li>\n<li><strong>InnoDB 支持行级锁，而 MyISAM 只支持表级锁</strong>。</li>\n<li><strong>InnoDB 支持外键，而 MyISAM 不支持</strong>。</li>\n<li><font color='red'>InnoDB 支持 MVCC</font>，而 MyISAM 不支持。</li>\n<li>虽然 MyISAM 引擎和 InnoDB 引擎都是使用 B+Tree 作为索引结构，但是<font color='red'>两者的索引实现方式不太一样</font>。</li>\n<li><font color='red'>InnoDB 支持数据库异常崩溃后的安全恢复</font>，而 MyISAM 不支持。</li>\n<li><font color='red'>InnoDB 的性能比 MyISAM 更强大</font>。</li>\n</ul>\n<p>最后，再分享一张图片给你，这张图片详细对比了常见的几种 MySQL 存储引擎。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/comparison-of-common-mysql-storage-engines.png\" alt=\"常见的几种 MySQL 存储引擎对比\" /></p>\n<h5 id=\"myisam-和-innodb-如何选择\"><a class=\"anchor\" href=\"#myisam-和-innodb-如何选择\">#</a> MyISAM 和 InnoDB 如何选择？</h5>\n<p><strong>大多数情况使用的都是 InnoDB 存储引擎</strong>。在某些读密集的情况下，使用 MyISAM 也是合适的。不过，前提是你的项目不介意<font color='red'> MyISAM 不支持事务、崩溃恢复</font>等缺点（可是～我们一般都会介意啊！）。</p>\n<h3 id=\"innodb-引擎\"><a class=\"anchor\" href=\"#innodb-引擎\">#</a> <mark>🌟InnoDB 引擎</mark></h3>\n<p>从 MySQL 5.5 版本开始默认使用 InnoDB 作为存储引擎，它擅长处理事务，具有自动崩溃恢复的特性，在日常开发中使用非常广泛。</p>\n<h4 id=\"逻辑存储结构\"><a class=\"anchor\" href=\"#逻辑存储结构\">#</a> 逻辑存储结构</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231125111944812.png\" alt=\"image-20231125111944812\" /></p>\n<ul>\n<li><strong>表空间（Tablespace）</strong>：\n<ul>\n<li>是 InnoDB 逻辑存储结构的最高层</li>\n<li><font color='red'>每张表都有一个对应的表空间</font>（.ibd 文件），前提是用户启用了参数 innodb_file_per_table（在 8.0 版本中默认开启）</li>\n<li>即<font color='red'> ibd 文件</font>，由多个 Segment 组成</li>\n</ul>\n</li>\n<li><strong>段（Segment）</strong>：\n<ul>\n<li>分为<font color='red'>数据段（Leaf node segment）、索引段（Non-leaf node segment）、回滚段（Rollback segment）</font>等</li>\n<li>数据段即 B + 树的叶子节点，索引段即 B + 树的非叶子节点</li>\n<li>由 InnoDB 自身管理，由多个 Extent 组成</li>\n</ul>\n</li>\n<li><strong>区（Extent）</strong>：\n<ul>\n<li>是表空间的单元结构</li>\n<li><font color='red'>固定大小为 1M，由 64 个连续的 Page 组成</font></li>\n</ul>\n</li>\n<li><strong>页（Page）</strong>：\n<ul>\n<li>是 InnoDB 磁盘管理的最小单元</li>\n<li><font color='red'>固定大小为 16 KB</font></li>\n<li>为了保证页的连续性，InnoDB 一次性从磁盘申请 4~5 个区</li>\n</ul>\n</li>\n<li><strong>行（Row）</strong>：\n<ul>\n<li>InnoDB 的数据是按行存放的，Row 存放的就是<font color='red'>行记录数据</font></li>\n<li>组成情况：\n<ul>\n<li><font color='red'>Trx_id</font>：最后一次事务的 id。每次对某行记录改动时，都会把对应的事务 id 赋值给 Trx_id</li>\n<li><font color='red'>Roll_pointer</font>：回滚指针。每次对某行记录改动时，都会把旧版本写入 undo 日志中，该列相当于一个指针，指向该记录修改前的信息</li>\n<li><font color='red'>各个字段的值</font></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"架构\"><a class=\"anchor\" href=\"#架构\">#</a> <mark>🌟架构</mark></h4>\n<h5 id=\"概述\"><a class=\"anchor\" href=\"#概述\">#</a> 概述</h5>\n<p>下面是 InnoDB 架构图，左侧为内存结构，右侧为磁盘结构。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231125133202521.png\" alt=\"image-20231125133202521\" /></p>\n<h5 id=\"内存结构\"><a class=\"anchor\" href=\"#内存结构\">#</a> 内存结构</h5>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231125133305129.png\" alt=\"image-20231125133305129\" /></p>\n<h6 id=\"buffer-pool缓冲池\"><a class=\"anchor\" href=\"#buffer-pool缓冲池\">#</a> Buffer Pool（缓冲池)</h6>\n<p>简称 BP，<font color='red'>是主内存中的一块区域</font>，<strong><font color='red'>作用是缓存表数据与索引</font></strong>。InnoDB 是基于磁盘文件存储的，为了弥补在物理硬盘与内存之间的 IO 访问速度差值，<font color='red'>需要把经常使用的数据加载到 BP 中</font>，避免每次访问都进行磁盘 IO。具体地，在执行增删改查时，<font color='red'>先操作 BP 中的数据（若无则从磁盘加载并缓存），然后再以一定频率刷新到磁盘</font>，从而减少磁盘 IO，加快处理速度。</p>\n<hr />\n<p><strong><font color='b'>Buffer Pool 的组成：</font></strong></p>\n<ul>\n<li><font color='cornflowerblue'>缓存页（Page）</font>：用于缓存<font color='red'>表数据与索引</font></li>\n<li><font color='cornflowerblue'>控制块</font>：用来描述缓存页，与缓存页一一对应。存储着<font color='red'>对应缓存页的所属表空间、数据页编号、以及在 Buffer Pool 中的地址</font>等信息。</li>\n</ul>\n<p><font color='red'>BP 以 Page 为单位，默认大小是 128 M</font>，Page 默认大小是 16 K，而<font color='red'>控制块的大小约为 Page 的 5%，大概是 800 byte</font>。</p>\n<blockquote>\n<p>注：BP 大小为 128M 指的就是缓存页（Page）的大小。而控制块则一般占 5%，所以每次会多申请 6M 的内存空间。</p>\n</blockquote>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/1680014940345-c4b81c48-94d1-46cd-97bd-fa4f242e91cf.jpeg\" alt=\"03.jpg\" /></p>\n<p>在专用服务器上，通常将多达 80％ 的物理内存分配给 Buffer Pool。可以通过以下参数设置：</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">show</span> variables <span class=\"token operator\">like</span> <span class=\"token string\">'innodb_buffer_pool_size'</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><hr />\n<p><strong><font color='b'>如何判断一个页是否缓存在 BP 中？</font></strong></p>\n<p>MySQL 中有一个哈希表数据结构，它的 k-v 结构是<font color='red'>（表空间号 + 数据页号，缓冲页对应的控制块）</font>。</p>\n<p>因此，当需要访问某个页的数据时，先从哈希表中根据 表空间号 + 数据页号 看看是否存在对应缓冲页的控制块。</p>\n<ul>\n<li>如果有，则直接使用；</li>\n<li>如果没有，就从<font color='red'>free 链表</font>中选出一个空闲的缓冲页，然后把磁盘中对应的页加载到该缓冲页的位置；</li>\n</ul>\n<img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/1680015043156-2f7c1410-3f41-4d8f-892c-d8384a8cd752.jpeg\" alt=\"10.jpg\" style=\"zoom:67%;\" />\n<hr />\n<p><strong><font color='b'>Page 分类</font></strong></p>\n<p><font color='red'>Buffer Pool 以 Page 为单位</font>，底层采用 <strong><font color='red'>链表</font></strong> 来管理 Page。在 InnoDB 访问表记录和索引时会在 Page 中缓存，以后使用时，可以减少磁盘 IO 操作。</p>\n<p>根据状态，将 Page 分为三种类型：</p>\n<ul>\n<li><font color='cornflowerblue'>free page</font>：空闲 page，未被使用。</li>\n<li><font color='cornflowerblue'>clean page</font>：被使用 page，但<font color='red'>数据在刷盘后没有被修改过</font>，与磁盘的数据保持一致。</li>\n<li><strong><font color='cornflowerblue'>dirty page</font></strong>：<font color='red'>脏页</font>，被使用 page，但<font color='red'>数据在刷盘后被修改过</font>，与磁盘的数据产生了不一致。</li>\n</ul>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/1680015221485-20f5036b-94b6-4125-8cf9-304a2deaf4e7.jpeg\" alt=\"05.jpg\" /></p>\n<hr />\n<p><strong><font color='b'>Page 管理</font></strong></p>\n<p>InnoDB 通过三种链表结构来维护和管理上述三类 Page 对应的<font color='red'>控制块</font>：</p>\n<ul>\n<li>\n<p><font color='cornflowerblue'>free list</font>：**<font color='red'>空闲</font>** 缓冲区，管理 free page</p>\n<ul>\n<li>Buffer Pool 的初始化过程中，先向操作系统申请连续的内存空间，然后把它划分成若干个【控制块 &amp; 缓冲页】的键值对</li>\n<li><font color='red'>free list 把所有<u>空闲的缓冲页对应的控制块</u>作为一个个的节点放到链表中</font></li>\n<li><font color='red'>基节点</font>: free list 中只有一个基节点，它不记录任何缓存页的信息（单独申请空间），只记录当前 free list 的头节点地址、尾节点地址，以及当前 free list 的节点个数</li>\n<li>从磁盘中将数据页进行缓存的流程：\n<ol>\n<li>从 free list 中取出一个空闲的控制块（对应缓冲页）</li>\n<li>根据数据页所在的表空间、页号之类的信息，填写该控制块的信息</li>\n<li>把该缓冲页对应的 free list 节点（即控制块）从链表中移除，表示该缓冲页已经被使用了</li>\n</ol>\n</li>\n</ul>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/1680015343358-c3d841dd-7c74-4b96-b01f-56109ffa94bc.jpeg\" alt=\"07.jpg\" /></p>\n</li>\n<li>\n<p><font color='cornflowerblue'>flush list</font>：**<font color='red'>需要刷盘</font>** 的缓冲区，管理 dirty page，按修改时间排序</p>\n<blockquote>\n<p>注：脏页既存在于 flush list，也在 LRU list 中，但是两种互不影响。<font color='red'>LRU list 负责管理 page 的可用性和释放，而 flush list 负责管理脏页的刷盘操作</font>。</p>\n</blockquote>\n<ul>\n<li>InnoDB 为了提高处理效率，在每次修改缓冲页后，并不是立刻把修改刷新到磁盘上，而是在未来的某个时间点进行刷盘操作。</li>\n<li>所以需要使用 flush list 存储脏页，凡是<font color='red'><u>被修改过的缓冲页对应的控制块</u></font>都会作为节点加入到 flush list 中。</li>\n<li>flush list 的结构与 free list 相似</li>\n</ul>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/1680015501833-6f3d1fcb-2894-4f32-b551-fd4495b9788c.jpeg\" alt=\"08.jpg\" /></p>\n</li>\n<li>\n<p><font color='cornflowerblue'>lru list</font>：**<font color='red'>正在使用</font>** 的缓冲区，管理 clean page 和 dirty page</p>\n<blockquote>\n<p>有点复杂，略了...</p>\n</blockquote>\n</li>\n</ul>\n<hr />\n<h6 id=\"change-buffer更改缓冲区\"><a class=\"anchor\" href=\"#change-buffer更改缓冲区\">#</a> Change Buffer（更改缓冲区）</h6>\n<blockquote>\n<p>略了...</p>\n</blockquote>\n<p>可以在 Buffer Pool 中进行合并处理，减少磁盘 IO。</p>\n<h6 id=\"adaptive-hash-index自适应hash索引\"><a class=\"anchor\" href=\"#adaptive-hash-index自适应hash索引\">#</a> Adaptive Hash Index（自适应 hash 索引）</h6>\n<blockquote>\n<p>参数：adaptive_hash_index</p>\n</blockquote>\n<p>InnoDB 会监控对表上各索引页的查询，<font color='red'>如果观察到 hash 索引可以提升索引页的查询速度，则自动建立 hash 索引</font>，无需人工参与，称之为自适应 hash 索引。</p>\n<ul>\n<li><font color='red'>hash 索引的等值匹配性能高于 B + 树的</font>：因为 hash 索引一般只需要一次 IO 即可；而 B + 树，可能需要几次匹配</li>\n<li>但是，<font color='red'>hash 索引又不适合做范围查询、模糊匹配等</font></li>\n</ul>\n<h6 id=\"log-buffer日志缓冲区\"><a class=\"anchor\" href=\"#log-buffer日志缓冲区\">#</a> Log Buffer（日志缓冲区）</h6>\n<p>作用：</p>\n<ul>\n<li>\n<p><font color='red'>用来保存要写入到磁盘中的日志数据（ <code>redo log</code> 、 <code>undo log</code> ），数据会定期刷新到磁盘中</font>，默认大小为 16MB。如果需要更新、插入或删除许多行的事务，增加日志缓冲区的大小可以节省磁盘 I/O</p>\n</li>\n<li>\n<p>用来优化每次更新操作之后都要写入 redo log 而产生的磁盘 IO 问题</p>\n</li>\n<li>\n<p>Log Buffer 空间满了后会自动写入磁盘。可以通过将 <code>innodb_log_buffer_size</code>  参数调大，以减少磁盘 IO 频率</p>\n</li>\n</ul>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/1680016593449-c23ff9d8-4c0f-48d4-9a55-b66b0a922895.jpeg\" alt=\"14.jpg\" /></p>\n<h5 id=\"磁盘结构\"><a class=\"anchor\" href=\"#磁盘结构\">#</a> 磁盘结构</h5>\n<blockquote>\n<p>实在是太抽象了，略了。。。</p>\n</blockquote>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231125133316649.png\" alt=\"image-20231125133316649\" /></p>\n<h6 id=\"system-tablespace系统表空间\"><a class=\"anchor\" href=\"#system-tablespace系统表空间\">#</a> System Tablespace (系统表空间)</h6>\n<h6 id=\"file-per-table-tablespaces每个表的文件表空间\"><a class=\"anchor\" href=\"#file-per-table-tablespaces每个表的文件表空间\">#</a> File-Per-Table Tablespaces（每个表的文件表空间）</h6>\n<h6 id=\"general-tablespaces通用表空间\"><a class=\"anchor\" href=\"#general-tablespaces通用表空间\">#</a> General Tablespaces（通用表空间）</h6>\n<h6 id=\"undo-tablespaces撤销表空间\"><a class=\"anchor\" href=\"#undo-tablespaces撤销表空间\">#</a> Undo Tablespaces（撤销表空间）</h6>\n<h6 id=\"temporary-tables临时表空间\"><a class=\"anchor\" href=\"#temporary-tables临时表空间\">#</a> Temporary Tables（临时表空间）</h6>\n<h6 id=\"doublewrite-buffer-files双写缓冲区文件\"><a class=\"anchor\" href=\"#doublewrite-buffer-files双写缓冲区文件\">#</a> Doublewrite Buffer Files（双写缓冲区文件）</h6>\n<h6 id=\"redo-log重做日志\"><a class=\"anchor\" href=\"#redo-log重做日志\">#</a> Redo Log（重做日志）</h6>\n<h5 id=\"后台线程\"><a class=\"anchor\" href=\"#后台线程\">#</a> 后台线程</h5>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231125133329251.png\" alt=\"image-20231125133329251\" /></p>\n<h6 id=\"master-thread核心后台线程\"><a class=\"anchor\" href=\"#master-thread核心后台线程\">#</a> Master Thread（核心后台线程）</h6>\n<p><font color='red'>负责调度其他线程</font>，还<font color='red'>负责将缓冲池中的数据异步刷新到磁盘中</font>，保持数据的一致性，还包括<font color='red'>脏页的刷新、合并插入缓存、undo 页的回收</font>。</p>\n<h6 id=\"io-threadio线程\"><a class=\"anchor\" href=\"#io-threadio线程\">#</a> IO Thread（IO 线程）</h6>\n<p>在 InnoDB 存储引擎中大量使用了 AIO 来处理 IO 请求，这样可以极大地提高数据库的性能，而 IO Thread 主要<font color='red'>负责这些 IO 请求的回调</font>。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231125150451252.png\" alt=\"image-20231125150451252\" /></p>\n<h6 id=\"purge-thread回收线程\"><a class=\"anchor\" href=\"#purge-thread回收线程\">#</a> Purge Thread（回收线程）</h6>\n<p>主要用于<font color='red'>回收事务已经提交了的 undo log</font>，在事务提交之后，undo log 可能不用了，就用它来回收。</p>\n<h6 id=\"page-cleaner-thread脏页刷新线程\"><a class=\"anchor\" href=\"#page-cleaner-thread脏页刷新线程\">#</a> Page Cleaner Thread（脏页刷新线程）</h6>\n<p>协助 Master Thread <font color='red'>刷新脏页</font>到磁盘，可以减轻 Master Thread 的工作压力，减少阻塞。</p>\n<h4 id=\"事务原理\"><a class=\"anchor\" href=\"#事务原理\">#</a> <mark>🌟事务原理</mark></h4>\n<h5 id=\"事务基础\"><a class=\"anchor\" href=\"#事务基础\">#</a> 事务基础</h5>\n<p>关于事务的基础知识，具体可见<a href=\"#==MySQL%E4%BA%8B%E5%8A%A1==\"> MySQL 事务</a>。</p>\n<ul>\n<li>\n<p><strong>原子性</strong>（ <code>Atomicity</code> ）：事务是不可分割的最小操作单元，内部的所有操作要么全部成功，要么全部失败（要么全部 commit 成功，要么全部失败 rollback）；</p>\n</li>\n<li>\n<p><strong>一致性</strong>（ <code>Consistency</code> ）：事务完成前后，数据库必须保持一致状态，即都是合理的数据状态。例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；</p>\n</li>\n<li>\n<p><strong>隔离性</strong>（ <code>Isolation</code> ）：数据库提供的隔离机制，可以保证事务在不受外部并发操作影响的独立环境下运行。即并发访问数据库时，一个事务不会干扰其他事务的运行，该事务所做的修改在最终提交前，对其他事务是不可见的。各并发事务之间，数据库是独立的；</p>\n</li>\n<li>\n<p><strong>持久性</strong>（ <code>Durability</code> ）：事务一旦提交，它对数据库中数据的更改就是持久的。即使数据库发生故障，这种更改也不会丢失。</p>\n</li>\n</ul>\n<p>那么实际上，<font color='red'>InnoDB 引擎是如何保证事务的四大特性（ACID）的呢？</font>而对于这四大特性，实际上分为两个部分：</p>\n<ul>\n<li>原子性（A）、一致性（C）、持久性（D）：由 InnoDB 中的 <font color='red'>redo log 日志和 undo log 日志</font>来保证</li>\n<li>隔离性（I）：通过数据库的<font color='red'>锁和 MVCC</font>来保证的</li>\n</ul>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231125152532382.png\" alt=\"image-20231125152532382\" /></p>\n<h5 id=\"redo-log\"><a class=\"anchor\" href=\"#redo-log\">#</a> redo log</h5>\n<p>redo log 是重做日志，<strong><font color='red'>记录事务提交时数据页的物理修改</font></strong>。当刷新脏页到磁盘发生错误时，进行数据恢复，用来实现事务的持久性。由两部分组成：</p>\n<ul>\n<li><font color='cornflowerblue'>redo log buffer</font>：<font color='red'>在内存中</font>的缓冲区</li>\n<li><font color='cornflowerblue'>redo log file</font>：<font color='red'>在磁盘中</font>的文件</li>\n</ul>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/1680016593449-c23ff9d8-4c0f-48d4-9a55-b66b0a922895.jpeg\" alt=\"14.jpg\" /></p>\n<p><img data-src=\"https://oss.javaguide.cn/github/javaguide/03.png\" alt=\"img\" /></p>\n<hr />\n<p><strong><font color='b'>如果没有 redo log，可能会存在什么问题？</font></strong></p>\n<p>在 InnoDB 中的内存结构中，主要的内存区域就是 Buffer Pool（缓冲池），在缓冲池中缓存了很多的数据页。</p>\n<p>当我们在一个事务中，执行多个增删改的操作时，InnoDB 会先操作缓冲池中的数据，如果缓冲区没有对应的数据，会通过后台线程将磁盘中的数据加载到缓冲区中，然后修改缓冲池中的数据，修改后的数据页我们称为<font color='red'>脏页</font>。而脏页则会在一定的时机，通过后台线程刷新到磁盘中，从而保证缓冲区与磁盘的数据一致。</p>\n<p>但缓冲区的脏页数据并不是实时刷新的，而是一段时间之后将缓冲区的数据刷新到磁盘中，<font color='red'>假如将脏页刷盘的过程出错了，但提示给用户事务提交成功，而数据却没有持久化下来，这就出现问题了，<strong>没有保证事务的持久性</strong></font>。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231126165158628.png\" alt=\"image-20231126165158628\" /></p>\n<p><strong><font color='b'>redo log 是如何确保事务的持久性的？</font></strong></p>\n<p>有了 redo log 之后，</p>\n<ul>\n<li><font color='red'>当对缓冲区的数据进行增删改之后，会首先将对缓冲页的变化记录在  <code>redo log buffer</code>  中</font></li>\n<li><font color='red'>在<u>每次</u>事务提交时，会将内存中的  <code>redo log buffer</code>  的数据刷新到磁盘文件  <code>redo log file</code>  中</font></li>\n<li>过一段时间之后，<strong><font color='red'>如果刷新缓冲区的脏页到磁盘时发生错误，此时就可以借助于 redo log 进行数据恢复，这样就保证了事务的持久性</font></strong></li>\n<li>而<font color='red'>如果脏页成功刷新到磁盘，或者涉及到的数据已经落盘，此时 redo log 就可以删除了，所以存在的两个 redo log 文件是循环写的</font></li>\n</ul>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231126165234873.png\" alt=\"image-20231126165234873\" /></p>\n<p><strong><font color='b'>为什么每次提交事务，要刷新 redo log 到磁盘中，而不是直接将 buffer pool 中的脏页刷新到磁盘呢？</font></strong></p>\n<p>因为在业务操作中，我们<font color='red'>操作数据一般都是随机读写磁盘的</font>，而不是顺序读写磁盘。 而 redo log 在向磁盘文件中写入数据，<font color='red'>日志文件都是顺序写的</font>。<strong><font color='red'>顺序写的效率，要远大于随机写</font></strong>。这种<font color='red'>先写日志的方式</font>，称之为 <code>WAL（Write-Ahead Logging）</code> 。</p>\n<hr />\n<h5 id=\"undo-log\"><a class=\"anchor\" href=\"#undo-log\">#</a> undo log</h5>\n<p>undo log（回滚日志）是在执行 DML 语句的时候产生的便于数据回滚的日志，用于<font color='red'>记录数据被修改前的信息</font>。</p>\n<p>与 redo log 记录物理日志不一样，<font color='red'>undo log 是逻辑日志，记录的是逻辑相反的操作信息</font>。可以认为当 delete 一条记录时，undo log 中会记录一条对应的 insert 记录；反之亦然，当 update 一条记录时，它记录一条对应相反的 update 记录。<font color='red'>当执行 rollback 时，就可以从 undo log 中的逻辑记录读取到相应的内容并进行回滚</font>。</p>\n<p>undo log 主要有两个作用：</p>\n<ol>\n<li>\n<p><strong><font color='red'>提供事务回滚（保证事务的原子性）</font></strong>：当事务回滚时将数据恢复到修改前的样子</p>\n</li>\n<li>\n<p><strong><font color='red'>MVCC（多版本并发控制）</font></strong>：当读取记录时，若该记录被其他事务占用，或者当前版本对该事务不可见，则可以通过 undo log <font color='red'>读取之前的版本数据</font>，以此实现非锁定读</p>\n</li>\n</ol>\n<p>undo log 销毁：undo log 在事务执行时产生，事务提交时，并不会立即删除 undo log，因为这些日志可能还用于 MVCC。</p>\n<p>undo log 存储：undo log 采用段的方式进行管理和记录，存放在前面介绍的 rollback segment 回滚段中，内部包含 1024 个 undo log segment。</p>\n<h5 id=\"innodb-如何实现事务\"><a class=\"anchor\" href=\"#innodb-如何实现事务\">#</a> <mark>🌟InnoDB 如何实现事务</mark></h5>\n<p>InnoDB 通过 Buffer Pool、Log Buffer、Redo Log、Undo Log 来实现事务，以一条 update 语句为例：</p>\n<ol>\n<li>\n<p>InnoDB 在收到一条 update 语句后，会先根据条件找到数据所在的页，并将该页缓存在  <code>Buffer Pool</code>  中</p>\n</li>\n<li>\n<p>针对 update 语句生成  <code>Undo Log</code>  日志，用于后续事务回滚</p>\n</li>\n<li>\n<p><code>执行器</code> 执行 update 语句，修改 Buffer Pool 中的数据，即内存中的数据</p>\n</li>\n<li>\n<p>针对 update 语句生成一个  <code>Redo Log</code>  对象，并写入  <code>Log Buffer</code>  中</p>\n</li>\n<li>\n<p>如果事务提交，那么将 Log Buffer 中的 Redo Log 对象持久化到磁盘中的  <code>Redo Log File</code>  中</p>\n<blockquote>\n<p>后续还有其他机制将 Buffer Pool 中所修改的数据页持久化到磁盘中（脏页刷盘）</p>\n</blockquote>\n</li>\n<li>\n<p>如果事务回滚，则利用 Undo Log 日志进行回滚</p>\n</li>\n</ol>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/1680016593449-c23ff9d8-4c0f-48d4-9a55-b66b0a922895.jpeg\" alt=\"14.jpg\" /></p>\n<h4 id=\"对-mvcc-的实现方式\"><a class=\"anchor\" href=\"#对-mvcc-的实现方式\">#</a> <mark>🌟对 MVCC 的实现方式</mark></h4>\n<h5 id=\"innodb-为什么要采用-mvcc快照读\"><a class=\"anchor\" href=\"#innodb-为什么要采用-mvcc快照读\">#</a> <mark>🌟InnoDB 为什么要采用 MVCC 快照读 ？</mark></h5>\n<p>这是因为一个事务的操作有可能成功 commit，也有可能失败 rollback。在一个事务 commit 之前，被其他事务读到还没提交的变更记录，会产生数据不一样的现象（<font color='red'>脏读</font>），这种情况就是 InnoDB 最低的隔离级别 READ UNCOMMITTED，可以读到没有 commit 的数据。</p>\n<p><font color='red'>那么如果想要不产生脏读，容易想到的是采用锁的方式</font>，当一个事务更改某行记录，就加上锁，其他并发事务等待该事务执行完毕才能读取到该行记录。但是这样做的话 **<font color='red'>会产生大量的锁占用与等待，效率是非常低下的，因此 InnoDB 采用了 MVCC 的方式</font>**。</p>\n<p>简单的说，在 RU 隔离级别下，若 A 事务变更某行记录，InnoDB 会产生对应的 undo log，如果接下来 A 事务进行回滚，InnoDB 可以根据 undo log 将记录回滚到事务开始之前的状态。在 A 事务没有结束时，如果 B 事务来查询该行记录，B 事务会根据 A 事务变更后的记录值（在内存中）加上 undo log “计算” 出 A 事务开始前的该行记录值，从而读取到该行记录的一个快照，其中<font color='red'>并不会产生锁与等待</font>。</p>\n<p>如果是 RR 的隔离级别（默认隔离级别），B 事务进行过程中看到的始终会是 B 事务开始前的记录行快照信息，不管 B 事务进行过程中 A 事务有没有完成；</p>\n<p>如果是 RC 的隔离级别，B 事务进行过程中，可以看到 A 事务提交对记录行修改值（即如果 A 事务没有完成，B 查询到的是 A 事务开始前的记录值，如果 A 事务完成了，B 事务查询到的是 A 事务完成后的记录值），在这种情况下会产生不可重复读的现象，即同一次事务中多次查询看到的结果会不一样。</p>\n<h5 id=\"基本概念\"><a class=\"anchor\" href=\"#基本概念\">#</a> 基本概念</h5>\n<h6 id=\"快照读一致性u非锁定读u\"><a class=\"anchor\" href=\"#快照读一致性u非锁定读u\">#</a> 快照读（一致性<u>非锁定读</u>）</h6>\n<p>就是<font color='red'>简单的  <code>SELECT</code>  语句（不加锁）</font>，是非阻塞读。</p>\n<p><font color='red'>快照即记录的历史版本</font>，每行记录可能存在多个历史版本（多版本技术），读取的是记录数据的可见版本。</p>\n<p>快照读的情况下，如果读取的记录正在执行 UPDATE/DELETE 操作，<font color='red'>读取操作不会因此去等待记录上 X 锁的释放，而是会去读取行的一个快照（历史数据）</font>。</p>\n<p>只有在事务隔离级别 RC (读取已提交) 和 RR（可重读）下，InnoDB 才会使用快照读（一致性非锁定读）：</p>\n<ul>\n<li><font color='gree'>在 RC 级别下</font>，快照读总是<font color='red'>读取被锁定行的最新一份快照数据</font>。</li>\n<li><font color='gree'>在 RR 级别下</font>，快照读总是 **<font color='red'>读取本事务开始时的行数据版本（快照）</font>**。</li>\n<li><font color='gree'>在 SERIALIZABLE 级别下</font>，<font color='red'>快照读退化成当前读</font>。</li>\n</ul>\n<p>快照读比较<font color='red'>适合对数据一致性要求不是特别高，且追求极致性能的业务场景</font>。</p>\n<hr />\n<p>对于快照读的实现，通常做法是加一个 **<font color='red'>版本号或者时间戳字段</font>**，</p>\n<ul>\n<li>更新数据时，<font color='red'>版本号 + 1 或者更新时间戳</font>。</li>\n<li>查询数据时，将当前可见的版本号与对应记录的版本号进行比对，<font color='red'>如果记录的版本小于可见版本，则表示该记录可见</font></li>\n</ul>\n<p>在 InnoDB 中，<font color='cornflowerblue'>多版本控制（multi versioning）</font>就是对快照读的实现。如果读取的行正在执行  <code>DELETE</code>  或  <code>UPDATE</code>  操作，这时读取操作不会去等待行上 X 锁的释放。相反地，InnoDB 会去读取行的一个快照数据，对于这种读取历史数据的方式，我们叫它快照读（snapshot read）。</p>\n<h6 id=\"当前读一致性u锁定读u\"><a class=\"anchor\" href=\"#当前读一致性u锁定读u\">#</a> 当前读（一致性<u>锁定读</u>）</h6>\n<p><font color='red'>读取行记录时会添加 X 锁或 S 锁</font>，以防其他并发事务修改当前记录，因此 **<font color='red'>读取的是记录的最新版本</font>**，是悲观锁的一种操作。</p>\n<ul>\n<li><code>select ... lock in share mode</code> ：对记录加  <code>S</code>  锁，其它事务也可以加  <code>S</code>  锁，但如果加  <code>X</code>  锁则会被阻塞</li>\n<li><code>select ... for update</code> 、 <code>insert</code> 、 <code>update</code> 、 <code>delete</code> ：对记录加  <code>X</code>  锁，且其它事务不能加任何锁</li>\n</ul>\n<p>当前读的一些常见 SQL 语句类型如下：</p>\n<blockquote>\n<p><code>select ... for update</code>  仅适用于 InnoDB，且必须在事务块 (BEGIN/COMMIT) 中才能生效。在进行事务操作时，通过 for update 语句，MySQL 会对查询结果集中每行数据都添加 **<font color='#B32015'>排他锁</font>**，<font color='red'>其他线程对该记录的更新与删除操作都会阻塞</font>。排他锁包含行锁、表锁。</p>\n<p>InnoDB 行锁是通过给索引上的索引项加锁来实现的，只有通过索引条件检索数据，InnoDB 才使用行级锁，否则，InnoDB 将使用表锁。</p>\n<p><code>select ... for share</code> ：我选择一些记录，这些记录可以 share，<font color='red'>其他事务也可以读</font>，但是如果你要修改，不好意思，我加了一个 s 锁，你是<font color='red'>不可以修改</font>的。这个语句的应用场景之一是 **<font color='red'>用来读取到最新的数据</font>**。</p>\n<p><code>select ... for update</code> ：我选择一些记录，这些 select 的记录是我下一步要 update 的，你要读或者修改这些记录，不好意思，我加的是 x 锁，你<font color='red'>读不了也改不了</font>。只有我当前事务提交了，这些记录你才可以读到或者修改。这个语句的应用场景之一是 **<font color='red'>为了防止更新丢失</font>**。</p>\n</blockquote>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># 对读的记录加一个 S 锁（MySQL 5.7 和 MySQL 8.0）</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">SELECT</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">LOCK</span> <span class=\"token operator\">IN</span> <span class=\"token keyword\">SHARE</span> <span class=\"token keyword\">MODE</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token comment\"># 对读的记录加一个 S 锁（MySQL 8.0）</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">SELECT</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">FOR</span> <span class=\"token keyword\">SHARE</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token comment\"># 对读的记录加一个 X 锁</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token keyword\">SELECT</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">FOR</span> <span class=\"token keyword\">UPDATE</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token comment\"># 对修改的记录加一个 X 锁</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token keyword\">INSERT</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token keyword\">UPDATE</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token keyword\">DELETE</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr></table></figure><hr />\n<p>在快照读下，即时读取的记录已被其它事务加上  <code>X</code>  锁，这时记录也是可以被读取的，即读取的快照数据。上面说了，在 RR 隔离级别下 MVCC 防止了部分幻读。这里的 “部分” 是指在 <code>快照读</code> 情况下，只能读取到第一次查询之前所插入的数据（根据 Read View 判断数据可见性，Read View 在第一次查询时生成）。</p>\n<p>但是！<font color='red'>如果是 <code>当前读</code> ，每次读取的都是最新数据，这时如果两次查询中间有其它事务插入数据，就会产生幻读</font>。</p>\n<p>所以，<strong><font color='#B32015'>InnoDB 在实现 RR 隔离级别时，如果执行的是 <code>当前读</code> ，则会对读取的记录使用  <code>临键锁（Next-key Lock）</code> ，来防止其它并发事务在间隙间插入数据</font></strong>。</p>\n<hr />\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231127104552414.png\" alt=\"image-20231127104552414\" /></p>\n<p>在测试中，即使是在默认的 RR 隔离级别下，事务 A 中依然可以读取到事务 B 最新提交的内容，因为在查询语句后面加上了  <code>lock in share mode</code>  共享锁，此时是当前读操作。当然，当我们加排他锁的时候，也是当前读操作。</p>\n<h6 id=\"mvcc多版本并发控制\"><a class=\"anchor\" href=\"#mvcc多版本并发控制\">#</a> MVCC（多版本并发控制）</h6>\n<p>MVCC 的全称是  <code>Multi-Version Concurrency Control</code> ，是一种并发控制机制，用于在多个并发事务同时读写数据库时保持数据的一致性和隔离性。<strong><font color='#B32015'>MVCC 在每个数据行上维护多个版本的数据，形成一条由 undo log 组成的版本链</font></strong>，使得读写操作没有冲突。</p>\n<p>MVCC 解决的问题：<strong><font color='#B32015'>读 — 写冲突的无锁并发控制</font></strong>。为事务分配单向增长的时间戳，为每个数据修改保存一个版本（与事务时间戳相关联）。读操作只读取该事务开始前的数据库快照。</p>\n<ul>\n<li>\n<p><font color='red'>能解决并发读 - 写问题</font>：可以做到读操作不阻塞写操作，同时写操作也不会阻塞读操作</p>\n</li>\n<li>\n<p><font color='red'>能解决脏读、幻读、不可重复读</font>等一致性问题，但<font color='red'>不能解决写 - 写中的修改丢失问题</font>。</p>\n</li>\n</ul>\n<hr />\n<p>1、读操作（SELECT）：</p>\n<p>当一个事务执行读操作时，它会使用<font color='red'>快照读取</font>。<strong><font color='red'>在 InnoDB 默认的 RR 隔离级别下，快照读取是基于事务开始时数据库中的状态创建的</font></strong>，因此事务不会读取到其他事务尚未提交的修改。具体工作情况如下：</p>\n<blockquote>\n<p>在 RR 级别下</p>\n</blockquote>\n<ul>\n<li>对于读取操作，事务会查找符合条件的数据行，并选择符合事务开始时间的数据版本进行读取。</li>\n<li>如果某个数据行有多个版本，事务会<font color='red'>选择不晚于事务开始时间的最新版本</font>，确保事务只读取在它开始之前已经存在的数据。</li>\n<li><font color='red'>事务读取的是快照数据，因此其他并发事务对数据行的修改不会影响当前事务的读取操作，当前事务对快照数据的修改也不会影响实际的数据行</font>。</li>\n</ul>\n<p>2、写操作（INSERT、UPDATE、DELETE）：</p>\n<p><strong><font color='red'>当一个事务执行写操作时，它会为要修改的数据行创建一个新的版本（快照数据），对其修改后再写入数据库</font></strong>。具体工作情况如下：</p>\n<ul>\n<li>对于写操作，事务会为要修改的数据行创建一个新的版本，并将修改后的数据写入新版本。</li>\n<li><font color='red'>新版本的数据会带有当前事务的版本号</font>，以便其他事务能够正确读取相应版本的数据。</li>\n<li><font color='red'>原始版本的数据仍然存在，供其他事务使用快照读取，这保证了其他事务不受当前事务的写操作影响</font>。</li>\n</ul>\n<p>3、事务的提交和回滚（COMMIT、ROLLBACK）：</p>\n<ul>\n<li>当一个事务提交时，它所做的修改将成为数据库的最新版本，并且对其他事务可见。</li>\n<li>当一个事务回滚时，它所做的修改将被撤销，对其他事务不可见。</li>\n</ul>\n<p>4、版本的回收：</p>\n<p><font color='red'>为了防止数据库中的版本无限增长，MVCC 会定期进行版本的回收。回收机制会删除已经不再需要的旧版本数据，从而释放空间</font>。</p>\n<p><strong><font color='#B32015'>MVCC 通过<u>创建数据的多个版本</u>和使用<u>快照读取</u>来实现并发控制</font></strong>。<font color='red'>读操作使用旧版本数据的快照，写操作创建新版本，并确保原始版本仍然可用</font>。这样，不同的事务可以在一定程度上并发执行，而不会相互干扰，从而提高了数据库的并发性能和数据一致性。</p>\n<h5 id=\"innodb-对-mvcc-的实现方式\"><a class=\"anchor\" href=\"#innodb-对-mvcc-的实现方式\">#</a> <mark>🌟InnoDB 对 MVCC 的实现方式</mark></h5>\n<p>InnoDB 对 MVCC 的具体实现依赖于：<strong>隐藏字段、ReadView、undo log</strong>。</p>\n<ul>\n<li>在内部实现中，InnoDB 通过数据行的  <code>DB_TRX_ID</code>  和  <code>ReadView</code>  来判断数据的可见性。</li>\n<li>如不可见，则通过数据行的  <code>DB_ROLL_PTR</code>  找到  <code>undo log</code>  中的历史版本。</li>\n<li>每个事务读到的数据版本可能是不一样的，在同一个事务中，用户只能看到该事务创建  <code>ReadView</code>  之前已经提交的修改和该事务本身做的修改。</li>\n</ul>\n<blockquote>\n<p>这里看不懂没关系，先看下文</p>\n</blockquote>\n<h6 id=\"隐藏字段\"><a class=\"anchor\" href=\"#隐藏字段\">#</a> 隐藏字段</h6>\n<p>InnoDB 为每行记录添加了三个隐藏字段：</p>\n<blockquote>\n<p>前两个字段是肯定会添加的，是否添加最后一个字段 DB_ROW_ID，得看当前表有没有主键或者唯一非空索引，若有则不会添加该隐藏字段。</p>\n</blockquote>\n<ul>\n<li>\n<p><code>DB_TRX_ID</code> （6 字节）：<font color='red'>插入这行记录或者最后一次修改该记录的事务 id</font>；</p>\n<blockquote>\n<p>delete 操作在内部被视为更新（即逻辑删除），会在记录头 Record header 中的 deleted_flag 字段将其标记为已删除</p>\n</blockquote>\n</li>\n<li>\n<p><code>DB_ROLL_PTR</code> （7 字节）：<font color='red'>回滚指针，指向该行对应的 undo log，即上一个版本（存于回滚段中）</font></p>\n<blockquote>\n<p>如果该行记录未被更新，则为空；</p>\n</blockquote>\n</li>\n<li>\n<p><code>DB_ROW_ID</code> （6 字节）：<font color='red'>当前行记录隐含的自增 ID</font>，如果当前表没有设置主键且没有唯一非空索引时，InnoDB 会使用 DB_ROW_ID 来<strong>生成一个聚集索引</strong>；</p>\n</li>\n</ul>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/816762-20210616144139574-1740941399.jpg\" alt=\"img\" /></p>\n<p>如上图，DB_ROW_ID 是数据库默认为该行记录生成的唯一隐式主键，DB_TRX_ID 是当前操作该记录的事务 ID，而 DB_ROLL_PTR 是一个回滚指针，用于配合 undo log，指向上一个旧版本。</p>\n<h6 id=\"undo-log-2\"><a class=\"anchor\" href=\"#undo-log-2\">#</a> undo log</h6>\n<p><strong><font color='b'>undo log 介绍</font></strong></p>\n<p>undo log（回滚日志）是在执行 DML 语句的时候产生的便于数据回滚的日志，用于<font color='red'>记录数据被修改前的信息</font>。</p>\n<p>与 redo log 记录物理日志不同，<font color='red'>undo log 是逻辑日志，记录的是逻辑相反的操作信息</font>。因此当执行 rollback 时，就可以直接从 undo log 中的逻辑记录读取到相应的内容并进行回滚。</p>\n<p>undo log 主要有两个作用：</p>\n<ol>\n<li>\n<p><strong><font color='red'>提供事务回滚（保证事务的原子性）</font></strong>：当事务回滚时将数据恢复到修改前的样子</p>\n</li>\n<li>\n<p><strong><font color='red'>MVCC（多版本并发控制）</font></strong>：当读取记录时，若该记录被其他事务占用，或者当前版本对该事务不可见，则可以通过 undo log <font color='red'>读取之前的版本数据</font>，以此实现非锁定读</p>\n</li>\n</ol>\n<p>在 InnoDB 中 undo log 分为两种：</p>\n<ul>\n<li>\n<p><code>insert undo log</code> ：在<font color='red'> insert 操作</font>中产生的 undo log。因为 insert 操作的记录只对事务本身可见，只在回滚时需要，因此<font color='red'> insert undo log 在事务提交后可以直接删除，不需要进行 purge 操作</font>。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/317e91e1-1ee1-42ad-9412-9098d5c6a9ad-dc43aed3.png\" alt=\"img\" /></p>\n<center>（insert 时的数据初始状态）</center>\n</li>\n<li>\n<p><code>update undo log</code> ：<font color='red'>update 或 delete 操作</font>中产生的 undo log。update undo log 不仅在回滚时需要，可能需要提供 MVCC 机制，因此不能在事务提交时就进行删除。<font color='red'>事务提交时放入 undo log 链表，等待 purge 线程进行最后的删除</font>。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/c52ff79f-10e6-46cb-b5d4-3c9cbcc1934a-b60a6e78.png\" alt=\"img\" /></p>\n<center>（数据第一次被修改时）</center>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/6a276e7a-b0da-4c7b-bdf7-c0c7b7b3b31c-2e496ea1.png\" alt=\"img\" /></p>\n<center>（数据第二次被修改时）</center>\n</li>\n</ul>\n<hr />\n<p><strong><font color='b'>版本链</font></strong></p>\n<p><strong><font color='red'>不同事务或者相同事务对同一记录行的修改，会使该记录行的 undo log 成为一条链表，链首就是最新的记录，链尾就是最早的旧记录</font></strong>。</p>\n<p>有一张表原始数据为：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231128102126782.png\" alt=\"image-20231128102126782\" /></p>\n<blockquote>\n<p><code>DB_TRX_ID</code> ：代表最近修改事务 ID，记录插入这条记录或最后一次修改该记录的事务 ID，是自增的。<br />\n <code>DB_ROLL_PTR</code> ：由于这条数据是刚刚才插入的，没有被更新过，所以该字段值为 null。</p>\n</blockquote>\n<p>然后，有四个并发事务同时在访问这张表。</p>\n<p>A. 第一步：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231128102320440.png\" alt=\"image-20231128102320440\" /></p>\n<p>当事务 2 执行第一条修改语句时：</p>\n<ol>\n<li>先记录 undo log 日志，记录数据变更之前的样子；</li>\n<li>然后更新记录，并且记录本次操作的事务 ID 与回滚指针。其中回滚指针用来指定如果发生回滚，回滚到哪一个版本；</li>\n</ol>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231128102520925.png\" alt=\"image-20231128102520925\" /></p>\n<p>B. 第二步</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231128102822352.png\" alt=\"image-20231128102822352\" /></p>\n<p>当事务 3 执行第一条修改语句时：</p>\n<ol>\n<li>先记录 undo log 日志，记录数据变更之前的样子；</li>\n<li>然后更新记录，并且记录本次操作的事务 ID 与回滚指针；</li>\n</ol>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231128103013206.png\" alt=\"image-20231128103013206\" /></p>\n<p>C. 第三步</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231128103104640.png\" alt=\"image-20231128103104640\" /></p>\n<p>当事务 4 执行第一条修改语句时：</p>\n<ol>\n<li>先记录 undo log 日志，记录数据变更之前的样子；</li>\n<li>然后更新记录，并且记录本次操作的事务 ID 与回滚指针；</li>\n</ol>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231128103205546.png\" alt=\"image-20231128103205546\" /></p>\n<h6 id=\"read-view\"><a class=\"anchor\" href=\"#read-view\">#</a> Read View</h6>\n<p>Read View 说白了就是<font color='red'>事务进行快照读操作时产生的读视图</font>。在该事务执行快照读的那一刻，会生成一个当前数据库系统的快照，该快照记录并维护了系统当前活跃事务的 ID（当每个事务开启时，都会被分配一个 ID, 这个 ID 是递增的，所以最新的事务，ID 值越大）。</p>\n<p>Read View 是用来做 **<font color='red'>可见性判断</font><strong>的，里面保存了</strong><font color='red'>当前对本事务不可见的其他活跃的（未提交的）事务</font>**。当某个事务执行快照读的时候，会对该记录创建一个 Read View，把它比作条件<font color='red'>用来判断当前事务能够看到哪个版本的数据</font>，既可能是当前最新的数据，也有可能是该行记录在 undo log 里面的某个版本的数据。</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">class</span> <span class=\"token class-name\">ReadView</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>  <span class=\"token comment\">/* ... */</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">private</span><span class=\"token operator\">:</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>  trx_id_t m_low_limit_id<span class=\"token punctuation\">;</span>      <span class=\"token comment\">/* 表示目前出现过的最大的事务 ID + 1，大于等于这个 ID 的事务均不可见 */</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>  trx_id_t m_up_limit_id<span class=\"token punctuation\">;</span>       <span class=\"token comment\">/* 表示活跃事务列表 m_ids 中最小的事务 ID，小于这个 ID 的事务均可见 */</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>  trx_id_t m_creator_trx_id<span class=\"token punctuation\">;</span>    <span class=\"token comment\">/* 创建该 Read View 的事务 ID */</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>  trx_id_t m_low_limit_no<span class=\"token punctuation\">;</span>      <span class=\"token comment\">/* 事务 Number, 小于该 Number 的 Undo Logs 均可以被 Purge */</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>  ids_t m_ids<span class=\"token punctuation\">;</span>                  <span class=\"token comment\">/* 创建 Read View 时的活跃事务列表 */</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>  m_closed<span class=\"token punctuation\">;</span>                     <span class=\"token comment\">/* 标记 Read View 是否 close */</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>主要有以下字段：</p>\n<ul>\n<li>\n<p><code>m_ids</code> ：<font color='red'>ReadView 创建时，其他活跃的（即未提交的）事务 ID 列表</font>。创建 ReadView 时，将当前所有未提交的事务的 ID 记录下来，后续即使它们修改了行记录的值，对于当前事务也是不可见的</p>\n<blockquote>\n<p>不包括当前事务自己和已提交的事务（正在内存中）</p>\n</blockquote>\n</li>\n<li>\n<p><code>m_low_limit_id</code> ：<font color='red'>目前出现过的最大的事务 ID + 1</font>，即下一个将被分配的事务 ID</p>\n<blockquote>\n<p>大于等于这个 ID 的数据版本均不可见</p>\n</blockquote>\n</li>\n<li>\n<p><code>m_up_limit_id</code> ：<font color='red'>活跃事务列表 m_ids 中最小的事务 ID</font>，如果 m_ids 为空，则  <code>m_up_limit_id = m_low_limit_id</code></p>\n<blockquote>\n<p>小于这个 ID 的数据版本均可见</p>\n</blockquote>\n</li>\n<li>\n<p><code>m_creator_trx_id</code> ：<font color='red'>创建该 ReadView 的事务 ID</font></p>\n</li>\n</ul>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/trans_visible-048192c5.png\" alt=\"trans_visible\" /></p>\n<center>事务可见性示意图</center>\n<h6 id=\"数据可见性算法\"><a class=\"anchor\" href=\"#数据可见性算法\">#</a> 数据可见性算法</h6>\n<p>在 InnoDB 中，<font color='red'>创建一个新事务后，执行每个 select 语句前，都会创建一个 Read View</font>。<strong><font color='#B32015'>Read View 中保存了当前数据库系统中正处于活跃（即没有 commit）的事务的 ID 号</font></strong>。</p>\n<p>简单的说，保存的是系统中当前不应该被本事务看到的其他事务的 ID 列表（即 m_ids）。<font color='red'>当用户在本事务中要读取某个记录行的时候，InnoDB 会将该记录行的  <code>DB_TRX_ID</code>  与 Read View 中的一些变量及当前事务 ID 进行比较，判断是否满足可见性条件</font>。具体的比较算法如下：</p>\n<blockquote>\n<p>参与比较的对象：</p>\n<ol>\n<li><code>DB_TRX_ID</code> ：<font color='red'>表示插入这行记录或者最后一次修改该行记录的事务 id</font></li>\n<li><code>m_creator_trx_id</code> ：<font color='red'>表示创建该 ReadView 的事务 ID</font></li>\n<li><code>m_up_limit_id</code> ：ReadView 中的一个变量，<font color='red'>表示活跃事务列表 m_ids 中最小的事务 ID</font>。事务 ID 小于它的事务均已提交，因此小于这个 ID 的数据版本均可见</li>\n<li><code>m_low_limit_id</code> ：ReadView 中的一个变量，表示下一个将被分配的事务 ID，即<font color='red'>目前出现过的最大的事务 ID + 1</font>。事务 ID 大于它的事务均未提交，因此大于等于这个 ID 的数据版本均不可见</li>\n</ol>\n</blockquote>\n<p><code>changes_visible()</code>  返回 true 代表可见， false 代表不可见。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231128104943951.png\" alt=\"image-20231128104943951\" /></p>\n<table>\n<thead>\n<tr>\n<th>步骤</th>\n<th>条件</th>\n<th>是否可以访问该版本</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0</td>\n<td>DB_TRX_ID == m_creator_trx_id</td>\n<td>可见</td>\n<td>表明最新修改该行记录的事务（DB_TRX_ID）就是创建 ReadView 的当前事务！</td>\n</tr>\n<tr>\n<td>1</td>\n<td>DB_TRX_ID &lt; m_up_limit_id</td>\n<td>可见</td>\n<td>表明最新修改该行记录的事务（DB_TRX_ID）在<u>当前事务</u>创建  ReadView 之前就提交了，因此该行记录的值对当前事务是可见的。</td>\n</tr>\n<tr>\n<td>2</td>\n<td>DB_TRX_ID &gt;= m_low_limit_id</td>\n<td>不可见</td>\n<td>表明最新修改该行的事务（DB_TRX_ID）在<u>当前事务</u>创建 ReadView 之后才修改该行，所以该记录行的值对当前事务不可见。<font color='red'>跳到步骤 5</font></td>\n</tr>\n<tr>\n<td>3</td>\n<td>m_ids 为空</td>\n<td>可见</td>\n<td>说明当前不存在活跃的事务，表明在当前事务创建 ReadView 之前，修改该行的事务就已经提交了，所以该记录行的值对当前事务是可见的</td>\n</tr>\n<tr>\n<td>4</td>\n<td>m_up_limit_id &lt;= DB_TRX_ID &lt; m_low_limit_id</td>\n<td>1. 如果 DB_TRX_ID 在 m_ids 中，不可见；</br>2. 如果 DB_TRX_ID 不在 m_ids 中，可见；</td>\n<td>表明最新修改该行的事务（DB_TRX_ID）在<u>当前事务</u>创建 ReadView 的时候可能处于 “活动状态” 或者 “已提交状态”，因此就要对活跃事务列表 m_ids 进行查找，分为两种情况：</br>1. 如果在活跃事务列表 m_ids 中能找到 DB_TRX_ID，表明：① 在当前事务创建 ReadView 前，该记录行的值被事务 ID 为 DB_TRX_ID 的事务修改了，但没有提交；或者 ② 在当前事务创建 ReadView 后，该记录行的值被事务 ID 为 DB_TRX_ID 的事务修改了。这些情况下，这个记录行的值对当前事务都是不可见的。<font color='red'>跳到步骤 5</font></br>2. 在活跃事务列表中找不到，则表明 “id 为 DB_TRX_ID 的事务” 在修改 “该记录行的值” 后，在 “当前事务” 创建 ReadView 前就已经提交了，所以记录行对当前事务可见</td>\n</tr>\n<tr>\n<td>5</td>\n<td></td>\n<td></td>\n<td>在该行记录的 DB_ROLL_PTR 指针所指向的 undo log 取出快照记录，用其中的 DB_TRX_ID <font color='red'>跳到步骤 1</font> 重新开始判断，直到找到满足的快照版本或返回空</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"rc-和-rr-下-mvcc-的差异\"><a class=\"anchor\" href=\"#rc-和-rr-下-mvcc-的差异\">#</a> <mark>🌟RC 和 RR 下 MVCC 的差异</mark></h5>\n<p>在事务隔离级别 RC 和 RR 下，虽然 InnoDB 都通过 MVCC 来读取快照数据（一致性非锁定读），但它们<font color='red'>生成 ReadView 的时机不同</font>：</p>\n<ul>\n<li>RC：<strong>在事务中的<font color='red'>每一次执行快照读时</font>，都会生成并设置新的 Read View，所以会导致不可重复读</strong>！</li>\n<li>RR：<strong>仅在事务中的<font color='red'>第一次执行快照读时</font>，生成一个 Read View（m_ids 列表），后续复用该 ReadView。<font color='red'>因此在一个事务中，执行两次相同的 select 语句，查询到的结果是一样的</font></strong>。</li>\n</ul>\n<h6 id=\"rc-下-readview-的生成情况\"><a class=\"anchor\" href=\"#rc-下-readview-的生成情况\">#</a> RC 下 ReadView 的生成情况</h6>\n<p>具体示例略了...</p>\n<h6 id=\"rr-下-readview-的生成情况\"><a class=\"anchor\" href=\"#rr-下-readview-的生成情况\">#</a> RR 下 ReadView 的生成情况</h6>\n<p>具体示例略了...</p>\n<h5 id=\"mvccnext-key-lock-防止幻读\"><a class=\"anchor\" href=\"#mvccnext-key-lock-防止幻读\">#</a> <mark>🌟MVCC➕Next-key Lock 防止幻读</mark></h5>\n<blockquote>\n<p>幻读：一个事务读取了几行数据，接着另一个并发事务<font color='red'>插入</font>了一些数据。第一个事务在随后的查询中就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</p>\n</blockquote>\n<p><strong><font color='#B32015'>InnoDB 在 RR 级别下通过 MVCC 和 临键锁（Next-key Lock）来解决幻读问题</font></strong>：</p>\n<p>1、<strong><font color='red'>执行普通 select 时会以 MVCC <u>快照读</u>的方式读取数据</font></strong></p>\n<blockquote>\n<p>理所当然能防止 “幻读”</p>\n</blockquote>\n<p>在快照读的情况下，RR 隔离级别只会在事务开启后的第一次查询时生成 Read View ，并复用直至事务提交。所以在生成 Read View 之后其它事务所做的更新、插入记录版本对当前事务并不可见，实现了可重复读和<font color='red'>防止快照读下的 “幻读”</font>。</p>\n<p>2、<strong><font color='red'>执行 select...for update/lock in share mode、insert、update、delete 等当前读</font></strong></p>\n<blockquote>\n<p>得益于临键锁（Next-key Lock）才能防止 “幻读”</p>\n</blockquote>\n<p>在当前读下，读取的都是最新的数据，如果其它事务有插入新的记录，并且刚好在当前事务查询范围内，就会产生幻读！InnoDB 使用 <strong><font color='red'>临键锁（Next-key Lock）</font></strong> 来防止幻读。<strong><font color='red'>当执行当前读时，会锁定读取到的记录，同时会锁定它们的间隙，防止其它并发事务在查询范围内插入数据</font></strong>。只要我不让你插入，就不会发生幻读。</p>\n<h3 id=\"mysql索引\"><a class=\"anchor\" href=\"#mysql索引\">#</a> <mark>🌟MySQL 索引</mark></h3>\n<h4 id=\"索引原理\"><a class=\"anchor\" href=\"#索引原理\">#</a> <mark>🌟索引原理</mark></h4>\n<p>索引（Index）是<font color='red'>一种帮助 MySQL 高效获取数据的有序数据结构</font>，协助 MySQL 快速查询、更新表中数据。MySQL 支持多种类型的索引，包括 B-tree 索引、哈希索引、全文索引等。</p>\n<p>索引的基本原理如下：</p>\n<ol>\n<li>把创建索引列的内容进行排序</li>\n<li>对排序的结果生成倒排表</li>\n<li>在倒排表内容上拼接上数据行地址</li>\n<li>查询数据时，先拿到倒排表内容，在取出数据行地址，从而拿到具体的数据</li>\n</ol>\n<p>数据是以文件的形式存放在磁盘上面的，每一行数据都有它的磁盘地址，如果没有索引的话，我们要从千万行数据里面检索一条数据，只能依次遍历这张表的全部数据， 直到找到这条数据。</p>\n<p>但是有了索引之后，只需要在索引里面去检索这条数据就行了，因为它是特殊的专门用来快速检索的数据结构，我们找到数据存放的磁盘地址以后，就可以拿到数据了。</p>\n<h4 id=\"索引介绍\"><a class=\"anchor\" href=\"#索引介绍\">#</a> 索引介绍</h4>\n<p><strong>索引是一种帮助存储引擎快速查询和检索数据的数据结构（有序）。</strong></p>\n<p>索引的底层数据结构存在很多种类型，常见的索引结构有：红黑树、B 树、B + 树、Hash。</p>\n<p><font color='red'>在 MySQL 中，Innodb 和 MyIsam，都使用 B + 树 作为索引结构</font>。</p>\n<h4 id=\"索引的优缺点\"><a class=\"anchor\" href=\"#索引的优缺点\">#</a> 索引的优缺点</h4>\n<p><strong>优点</strong>：</p>\n<ul>\n<li>使用索引可以大大<font color='red'>加快数据的检索速度</font>（大大减少检索的数据量），这也是创建索引的最主要的原因。</li>\n<li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</li>\n</ul>\n<p><strong>缺点</strong>：</p>\n<ul>\n<li><font color='red'>创建和维护索引需要耗费许多时间</font>。当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低 SQL 执行效率。</li>\n<li>索引需要使用物理文件存储，也会耗费一定空间。</li>\n</ul>\n<h4 id=\"索引的底层数据结构选型\"><a class=\"anchor\" href=\"#索引的底层数据结构选型\">#</a> <mark>🌟索引的底层数据结构选型</mark></h4>\n<p>不同存储引擎对索引结构的支持情况：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231117203129938.png\" alt=\"image-20231117203129938\" /></p>\n<h5 id=\"hash-表\"><a class=\"anchor\" href=\"#hash-表\">#</a> Hash 表</h5>\n<p>哈希索引使用哈希算法<font color='red'>将索引列的值映射到哈希表中</font>，然后通过哈希表的查找算法快速定位到目标数据。哈希索引的优点是查找速度非常快，但是它<font color='red'>不支持范围查找，只适用于等值查找</font>。</p>\n<p>哈希表是键值对的集合，通过键 (key) 即可快速取出对应的值 (value)，因此哈希表可以快速检索数据（接近 O（1））。</p>\n<p>通过哈希算法，我们可以快速找到 key 对应的 index，找到了 index 也就找到了对应的 value。</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>hash <span class=\"token operator\">=</span> <span class=\"token function\">hashfunc</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>index <span class=\"token operator\">=</span> hash <span class=\"token operator\">%</span> array_size</pre></td></tr></table></figure><p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/mysql20210513092328171.png\" alt=\"img\" /></p>\n<p>但是！哈希算法有个 <strong>Hash 冲突</strong> 问题，也就是说多个不同的 key 最后得到的 index 相同。通常情况下，我们常用的解决办法是<strong>链地址法</strong>。链地址法就<font color='red'>是将哈希冲的突数据存放在链表中</font>。</p>\n<p>比如 JDK1.8 之前  <code>HashMap</code>  就是通过链地址法来解决哈希冲突的。不过，JDK1.8 以后  <code>HashMap</code>  为了减少链表过长时搜索时间过长引入了红黑树。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/mysql20210513092224836.png\" alt=\"img\" /></p>\n<p>为了减少 Hash 冲突的发生，一个好的哈希函数应该 “均匀地” 将数据分布在整个可能的哈希值集合中。</p>\n<hr />\n<p>InnoDB 存储引擎不直接支持常规的哈希索引，但存在一种特殊的<strong>自适应哈希索引（Adaptive Hash Index）</strong>，结合了 B+Tree 和哈希索引的特点，以便更好地适应实际应用中的数据访问模式和性能需求。自适应哈希索引的<font color='red'>每个哈希桶实际上是一个小型的 B+Tree 结构</font>。这个 B+Tree 结构可以存储多个键值对，而不仅仅是一个键。这有助于减少哈希冲突链的长度，提高了索引的效率。关于 Adaptive Hash Index 的详细介绍，可以查看 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvcmE0djFYUjVwelNXYy1xdEdPLWRCZw==\">MySQL 各种 “Buffer” 之 Adaptive Hash Index</span> 这篇文章。</p>\n<p>既然哈希表这么快，为什么 MySQL 没有使用其作为索引的数据结构呢？主要是<strong>因为 Hash 索引不支持排序、范围查询</strong>。假如我们要对表中的数据进行排序或者进行范围查询，那 Hash 索引可就不行了。并且，每次 IO 只能取一个。</p>\n<p>试想一种情况:</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token constant\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token constant\">FROM</span> tb1 <span class=\"token constant\">WHERE</span> id <span class=\"token operator\">&lt;</span> <span class=\"token number\">500</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>在这种范围查询中，直接遍历比 500 小的叶子节点就够了。而 Hash 索引是根据 hash 算法来定位的，难不成还要把 1 - 499 的数据，每个都进行一次 hash 计算来定位吗？这就是 Hash 最大的缺点了。</p>\n<h5 id=\"全文索引full-text\"><a class=\"anchor\" href=\"#全文索引full-text\">#</a> 全文索引（Full-text）</h5>\n<p>全文索引是一种特殊的索引类型，它可以用于对文本数据进行全文检索。全文索引的基本原理是<font color='red'>将文本数据分词，然后将每个词作为关键字建立索引</font>。全文索引可以用于<font color='red'>对文本数据进行模糊匹配、关键字搜索</font>等操作。</p>\n<h5 id=\"二叉查找树bst\"><a class=\"anchor\" href=\"#二叉查找树bst\">#</a> 二叉查找树（BST）</h5>\n<p>二叉查找树（Binary Search Tree）是一种基于二叉树的数据结构，它具有以下特点：</p>\n<ol>\n<li>左子树所有节点的值均小于根节点的值。</li>\n<li>右子树所有节点的值均大于根节点的值。</li>\n<li>左右子树也分别为二叉查找树。</li>\n</ol>\n<p>二叉查找树的时间复杂度：</p>\n<ul>\n<li>当二叉查找树平衡时，也就是树的每个节点的左右子树深度相差不超过 1 的时候，查询的时间复杂度为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(logn)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span>，具有比较高的效率。</li>\n<li>然而，当二叉查找树不平衡时，例如在最坏情况下（有序插入节点），树会退化成线性链表（也被称为<font color='red'>斜树</font>），相当于<font color='red'>全表扫描</font>，导致查询效率急剧下降，时间复杂退化为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mtext>（</mtext><mi>N</mi><mtext>）</mtext></mrow><annotation encoding=\"application/x-tex\">O（N）</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mord cjk_fallback\">（</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mord cjk_fallback\">）</span></span></span></span>。</li>\n</ul>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/oblique-tree.png\" alt=\"斜树\" /></p>\n<center>斜树</center>\n<p>也就是说，<strong>二叉查找树的性能非常依赖于它的平衡程度，这就导致其不适合作为 MySQL 底层索引的数据结构。</strong></p>\n<p>为了解决这个问题，并提高查询效率，人们发明了多种在二叉查找树基础上的改进型数据结构，如平衡二叉树、B-Tree、B+Tree 等。</p>\n<h5 id=\"avl-树自平衡的bst\"><a class=\"anchor\" href=\"#avl-树自平衡的bst\">#</a> AVL 树（自平衡的 BST）</h5>\n<p>AVL 树的特点是<font color='red'>保证任何节点的左右子树高度之差不超过 1</font>，因此也被称为高度平衡二叉树。<font color='red'>它的查找、插入和删除在平均和最坏情况下的时间复杂度都是 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(logn)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></font>。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/avl-tree.png\" alt=\"AVL 树\" /></p>\n<p>AVL 树采用了<font color='red'>旋转操作</font>来保持平衡。主要有四种旋转操作：LL 旋转、RR 旋转、LR 旋转和 RL 旋转。其中 LL 旋转和 RR 旋转分别用于处理左左和右右失衡，而 LR 旋转和 RL 旋转则用于处理左右和右左失衡。</p>\n<p>由于 AVL 树<font color='red'>需要频繁地进行旋转操作来保持平衡</font>，因此会有较大的计算开销进而降低了查询性能。并且， 在使用 AVL 树时，每个树节点仅存储一个数据，而每次进行磁盘 IO 时只能读取一个节点的数据，如果需要查询的数据分布在多个节点上，那么就需要进行多次磁盘 IO。 <strong>磁盘 IO 是一项耗时的操作，在设计数据库索引时，我们需要优先考虑如何最大限度地减少磁盘 IO 操作的次数。</strong></p>\n<p>实际应用中，AVL 树使用的并不多。</p>\n<h5 id=\"红黑树自平衡的bst\"><a class=\"anchor\" href=\"#红黑树自平衡的bst\">#</a> 红黑树（自平衡的 BST）</h5>\n<p>与 AVL 树一样，红黑树也是一种自平衡二叉查找树，通过在插入和删除节点时进行<font color='red'>颜色变换、旋转操作</font>，使得树始终保持平衡状态，它具有以下特点：</p>\n<ol>\n<li>每个节点非红即黑；</li>\n<li>根节点总是黑色的；</li>\n<li>每个叶子节点都是黑色的空节点（NIL 节点）；</li>\n<li>如果节点是红色的，则它的子节点必须是黑色的（反之不一定）；</li>\n<li>从根节点到叶节点或空子节点的每条路径，必须包含相同数目的黑色节点（即相同的黑色高度）。</li>\n</ol>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/red-black-tree.png\" alt=\"红黑树\" /></p>\n<p>和 AVL 树不同的是，<strong><font color='red'>红黑树并不追求严格的平衡，而是大致的平衡，因此红黑树的查询效率稍有下降</font></strong>。因为红黑树的平衡性相对较弱，可能会导致树的高度较高，这可能会导致一些数据需要进行多次磁盘 IO 操作才能查询到，这也是 MySQL 没有选择红黑树的主要原因。</p>\n<p>也正因如此，<strong><font color='red'>红黑树的插入和删除操作效率大大提高了</font></strong><font color='red'>，因为红黑树在插入和删除节点时只需进行 O (1) 次数的旋转和变色操作，即可保持基本平衡状态</font>，而不需要像 AVL 树一样进行 O (logn) 次数的旋转操作。</p>\n<p>红黑树的应用还是比较广泛的，<font color='red'>TreeMap、TreeSet 以及 JDK1.8 的 HashMap 底层都用到了红黑树</font>。对于数据在内存中的这种情况来说，红黑树的表现是非常优异的。</p>\n<h5 id=\"b树-b树\"><a class=\"anchor\" href=\"#b树-b树\">#</a> <mark>🌟B 树 &amp; B + 树</mark></h5>\n<blockquote>\n<p>最常用</p>\n</blockquote>\n<p>B 树全称为<strong>多路平衡查找树</strong> ，B+ 树是 B 树的一种变体，其中 B 是  <code>Balanced</code> （平衡）的意思。</p>\n<p><font color='red'>目前大部分数据库系统及文件系统都采用 B-Tree 或其变种 B+Tree 作为<u>索引结构</u></font>。</p>\n<p>B-tree 索引可以在<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(log n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span> 的时间复杂度内查找数据，基本原理如下：</p>\n<ol>\n<li>将索引列的值按照一定的顺序存储在 B-tree 中</li>\n<li>然后通过 B-tree 的查找算法快速定位到目标数据</li>\n<li>B-tree 索引的叶子节点存储了指向数据行的指针，因此可以通过 B-tree 索引快速定位到目标数据行</li>\n</ol>\n<p><strong>B 树与 B + 树的区别</strong>：</p>\n<ul>\n<li>\n<p><strong><font color='red'>B 树的所有节点都存放<u>索引列值（key）</u>和数据（data）</font></strong>；而 **<font color='red'> B+ 树只有叶子节点才同时存放 key 和 data，其他内节点只存放 key</font>**。</p>\n<blockquote>\n<p>这样 B+ 树中每个内节点可以存储更多 key 值，从而降低 B + 树的高度，提高检索效率。</p>\n</blockquote>\n</li>\n<li>\n<p><font color='red'>B 树的叶子节点都是独立的</font>；而 <strong><font color='red'>B+ 树的所有叶子节点构成一个<u>有序的双向链表</u></font></strong>。</p>\n<blockquote>\n<p>因此 B+ 树可以按照 key 来有序遍历全部记录，且便于区间查找和搜索。</p>\n</blockquote>\n</li>\n<li>\n<p>B 树的检索的过程相当于对范围内的每个节点的 key 做二分查找，可能还没有到达叶子节点，检索就结束了。而 <strong><font color='red'>B+ 树的检索效率就很稳定了，任何查找都是从根节点到叶子节点的过程，叶子节点的顺序检索很明显</font></strong>。</p>\n</li>\n<li>\n<p>在 B 树中进行范围查询时，首先找到要查找的下限，然后对 B 树进行中序遍历，直到找到查找的上限；而 <strong><font color='red'>B+ 树的范围查询，只需要对有序的双向链表进行遍历即可</font></strong>。</p>\n</li>\n</ul>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/249993-20170525154141810-591706803.png\" alt=\"img\" /></p>\n<center>B树索引（3阶）</center>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/249993-20170531161139243-491884410.png\" alt=\"img\" /></p>\n<center>（B+树索引）</center>\n<p>综上，B + 树与 B 树相比，具备 **<font color='red'>更高，更稳定的查询效率、更适用于范围查询</font>** 这些优势。</p>\n<h5 id=\"mysql-选择-b-树作为索引结构的原因\"><a class=\"anchor\" href=\"#mysql-选择-b-树作为索引结构的原因\">#</a> <mark>🌟MySQL 选择 B+ 树作为索引结构的原因</mark></h5>\n<p><strong>1、为什么不使用二叉查找树（BST）？</strong></p>\n<p>二叉查找树可能因为失衡严重出现<font color='red'>“斜树”，退化为线性链表，相当于全表扫描</font>，高度太高了，查找效率不稳定。</p>\n<p><strong>2、为什么不使用平衡二叉树？</strong></p>\n<p>平衡二叉树解决了二叉树高度太高，查找效率不稳定的问题。但是，平衡二叉树的<font color='red'>每个节点只存储一个键值和数据，如果数据非常的多，二叉树的结点将会非常多，高度也会很高，查找效率降低</font>。</p>\n<p><strong>3、为什么不使用 B 树？</strong></p>\n<ul>\n<li>\n<p><strong><font color='red'>B 树只适合随机检索</font></strong>，而 B + 树同时支持随机检索和顺序 / 范围检索；</p>\n</li>\n<li>\n<p><strong><font color='red'>B + 树的空间利用率更高</font></strong>：因为 B + 树的内部节点（非叶子节点，也称索引节点）不存储数据，只存储索引值，相比较 B 树来说，B + 树一个节点可存储更多的索引值，使得整颗 B + 树变得更矮，减少 I/O 次数，磁盘读写代价更低，I/O 读写次数是影响索引检索效率的最大因素；</p>\n</li>\n<li>\n<p><strong><font color='red'>B + 树查询效率更加稳定</font></strong>：因为在 B + 树中，顺序检索比较明显，随机检索时，由于 B + 树所有的 data 域（结点中存储数据元素的部分）都在根节点，任何关键字的查找都必须走一条从根节点到叶节点的路，所有关键字的查找路径相同，导致每一个关键字的查询效率基本相同，时间复杂度固定为 O (log n)；而 B 树搜索有可能会在非叶子节点结束，越靠近根节点的记录查找时间越短，其性能等价于在关键字全集内做一次二分查找，查询时间复杂度不固定，与 key 在树中的位置有关，最好情况为 O (1)；</p>\n</li>\n<li>\n<p><strong><font color='red'>B + 树范围查询性能更优</font></strong>：因为 B + 树的叶子节点使用了指针顺序（链表）从小到大地连接在一起，B + 树叶节点两两相连可大大增加区间访问性，只要遍历叶子节点就可以实现整棵树的遍历；而 B 树的叶子节点是相互独立的，每个节点 key（索引）和 data 在一起，则无法查找区间；</p>\n<p>根据空间局部性原理：如果一个存储器的某个位置被访问，那么将它附近的位置也会被访问。若访问节点 key 为 50，则 key 为 55、60、62 的节点将来也可能被访问，可利用磁盘预读原理提前将这些数据读入内存，减少了磁盘 IO 的次数。当然 B + 树也能够很好的完成范围查询，比如同时也会查询 key 值在 50-70 之间的节点。</p>\n</li>\n<li>\n<p><strong><font color='red'>B + 树增删文件（节点）时效率更高</font></strong>：因为 B + 树的叶子节点包含了所有关键字，并以有序的链表结构存储。</p>\n</li>\n</ul>\n<h4 id=\"索引分类\"><a class=\"anchor\" href=\"#索引分类\">#</a> 索引分类</h4>\n<p>按照<font color='gree'>数据结构</font>分类：</p>\n<ul>\n<li><strong><font color='cornflowerblue'>B + 树索引</font></strong>：MySQL 里<font color='red'>默认的</font>索引类型。<font color='red'>只有叶子节点存储 value，非叶子节点只有指针和 key</font>。存储引擎 MyISAM 和 InnoDB 实现索引都是使用 B+Tree，但二者实现方式不一样。</li>\n<li><font color='cornflowerblue'>hash 索引</font>：类似键值对的形式，一次即可定位。</li>\n<li><font color='cornflowerblue'>R 树索引</font>：一般不会使用，<font color='red'>仅支持 geometry 数据类型</font>，优势在于范围查找，效率较低，通常使用搜索引擎如 ElasticSearch 代替。</li>\n<li><font color='cornflowerblue'>全文索引</font>：<font color='red'>对文本的内容进行分词，进行搜索</font>。目前只有  <code>CHAR</code> 、 <code>VARCHAR</code>  ， <code>TEXT</code>  列上可以创建全文索引。<font color='red'>一般不会使用，效率较低</font>，通常使用搜索引擎如 ElasticSearch 代替。</li>\n</ul>\n<p>按照<font color='gree'>底层存储方式</font>划分：</p>\n<ul>\n<li>\n<p><strong><font color='cornflowerblue'>聚集索引</font></strong>：聚集索引的<strong>叶子节点存储的是<u>整行记录</u></strong>。<font color='red'>可以直接查找到数据，查询速度快。每个表只能有一个聚集索引</font>。例如 <font color='red'>InnoDB 引擎中的主键索引</font>。</p>\n<blockquote>\n<p>在 MySQL 中，InnoDB 引擎表的  <code>.ibd</code>  表空间文件包含了该表的索引和数据，因此该表的索引 (B + 树) 的每个非叶子节点存储索引，叶子节点存储索引和索引对应的数据。</p>\n</blockquote>\n</li>\n<li>\n<p><strong><font color='cornflowerblue'>非聚集索引</font></strong>：非聚集索引的<strong>叶子节点存储的是<u>索引列的值、指向对应行记录的指针</u></strong>。查询速度相对较慢。<font color='red'>MyISAM 引擎，无论主键还是非主键，使用的都是非聚集索引</font>。</p>\n</li>\n</ul>\n<p>按照<font color='gree'>应用维度</font>划分：</p>\n<ul>\n<li><font color='cornflowerblue'>主键索引</font>：加速查询 + 列值唯一（不可以有 NULL）+ 表中只有一个。</li>\n<li><font color='cornflowerblue'>普通索引</font>：仅加速查询。</li>\n<li><font color='cornflowerblue'>唯一索引</font>：加速查询 + 列值唯一（可以有 NULL）。</li>\n<li><font color='cornflowerblue'>覆盖索引</font>：一个索引包含（或者说覆盖）所有需要查询的字段的值。</li>\n<li><font color='cornflowerblue'>联合索引</font>：<font color='red'>多列值组成一个索引</font>，专门用于组合搜索，其效率大于索引合并。</li>\n<li><font color='cornflowerblue'>全文索引</font>：对文本的内容进行分词，进行搜索。目前只有  <code>CHAR</code> 、 <code>VARCHAR</code>  ， <code>TEXT</code>  列上可以创建全文索引。一般不会使用，效率较低，通常使用搜索引擎如 ElasticSearch 代替。</li>\n</ul>\n<p>MySQL 8.x 中实现的<font color='gree'>索引新特性</font>：</p>\n<ul>\n<li><font color='cornflowerblue'>隐藏索引</font>：也称为不可见索引，不会被优化器使用，但是仍然需要维护，通常会软删除和灰度发布的场景中使用。主键不能设置为隐藏（包括显式设置或隐式设置）。</li>\n<li><font color='cornflowerblue'>降序索引</font>：之前的版本就支持通过 desc 来指定索引为降序，但实际上创建的仍然是常规的升序索引。直到 MySQL 8.x 版本才开始真正支持降序索引。另外，在 MySQL 8.x 版本中，不再对 GROUP BY 语句进行隐式排序。</li>\n<li><font color='cornflowerblue'>函数索引</font>：从 MySQL 8.0.13 版本开始支持在索引中使用函数或者表达式的值，也就是在索引中可以包含函数或者表达式。</li>\n</ul>\n<h5 id=\"主键索引\"><a class=\"anchor\" href=\"#主键索引\">#</a> 主键索引</h5>\n<p>数据表的<font color='red'>主键列</font>使用的就是主键索引。</p>\n<p>一张数据表有只能有一个主键，并且主键不能为 null，不能重复。</p>\n<p>在 MySQL 的 InnoDB 的表中，当没有显示的指定表的主键时，InnoDB 会自动先检查表中是否有唯一索引且不允许存在 null 值的字段，如果有，则选择该字段为默认的主键，否则 InnoDB 将会自动创建一个 6 Byte 的自增主键。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/cluster-index.png\" alt=\"主键索引\" /></p>\n<center>主键索引</center>\n<h5 id=\"二级索引\"><a class=\"anchor\" href=\"#二级索引\">#</a> 二级索引</h5>\n<p>二级索引（Secondary Index）又称为辅助索引，是一种非聚集索引，因为<strong>二级索引的叶子节点仅仅存储<u>索引列的值、对应行记录的主键 key</u></strong>。也就是说，<font color='red'>通过二级索引，可以定位主键的位置，再根据主键索引查找行记录 data，这就是<strong>二次查询（回表）</strong>，因此二级索引的查询速度较慢</font>。</p>\n<p>唯一索引，普通索引，前缀索引、全文索引都属于二级索引：</p>\n<ol>\n<li><font color='cornflowerblue'>唯一索引 (Unique Key)</font>：唯一索引也是一种约束。<font color='red'>唯一索引的属性列不能出现重复的数据，但是允许数据为 NULL，一张表允许创建多个唯一索引</font>。建立唯一索引的目的大部分时候都是<font color='red'>为了该属性列的数据的唯一性，而不是为了查询效率</font>。</li>\n<li><font color='cornflowerblue'>普通索引 (Index)</font>：普通索引的唯一作用就是<font color='red'>为了快速查询数据</font>，一张表允许创建多个普通索引，并允许数据重复和 NULL。</li>\n<li><font color='cornflowerblue'>前缀索引 (Prefix)</font>：前缀索引只适用于字符串类型的数据。前缀索引是<font color='red'>对文本的前几个字符创建索引，相比普通索引建立的数据更小</font>，因为只取前几个字符。</li>\n<li><font color='cornflowerblue'>全文索引 (Full Text)</font>：全文索引主要是<font color='red'>为了检索大文本数据中的关键字信息</font>，是目前搜索引擎数据库使用的一种技术。Mysql 5.6 之前只有 MYISAM 引擎支持全文索引，5.6 之后 InnoDB 也支持了全文索引。</li>\n</ol>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/no-cluster-index.png\" alt=\"二级索引\" /></p>\n<center>二级索引</center>\n<h5 id=\"聚集索引\"><a class=\"anchor\" href=\"#聚集索引\">#</a> 聚集索引</h5>\n<p>聚集索引（Clustered Index）的<strong>叶子节点存储的是<u>整行记录</u></strong>。<font color='red'>可以直接查找到数据，查询速度快。每个表只能有一个聚集索引</font>。例如 <font color='red'>InnoDB 引擎中的主键索引</font>。</p>\n<p>在 MySQL 中，<font color='red'>InnoDB 引擎的表的  <code>.ibd</code>  表空间文件就包含了该表的索引和数据</font>，对于 InnoDB 引擎表来说，该表的索引 (B + 树) 的每个非叶子节点存储索引，叶子节点存储索引和索引对应的数据。</p>\n<p>优点：</p>\n<ul>\n<li><strong>查询速度非常快</strong>：因为整个 B+ 树本身就是一颗多叉平衡树，叶子节点也都是有序的，定位到索引的节点，就相当于定位到了数据。<font color='red'>相比于非聚集索引， 聚集索引少了一次读取数据的 IO 操作</font>。</li>\n<li><strong>对排序查找和范围查找优化</strong>：对于主键的排序查找和范围查找速度非常快。</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li><strong>依赖于有序的数据</strong>：因为 B+ 树是多路平衡树，如果索引的数据不是有序的，那么就<font color='red'>需要在插入时排序</font>，如果数据是整型还好，否则类似于字符串或 UUID 这种又长又难比较的数据，<font color='red'>插入或查找的速度肯定比较慢</font>。</li>\n<li><strong>修改更新的代价大</strong>：如果索引列的数据被修改，那么对应的索引也将会被修改，而且聚集索引的叶子节点还存放着数据，修改代价肯定是较大的。所以对于主键索引来说，主键一般都是不可被修改的。</li>\n</ul>\n<h5 id=\"非聚集索引\"><a class=\"anchor\" href=\"#非聚集索引\">#</a> 非聚集索引</h5>\n<p>非聚集索引（Non-Clustered Index）的<strong>叶子节点存储的是<u>索引列的值、指向对应行记录的指针</u></strong>。查询速度相对较慢。二级索引 (辅助索引) 就属于非聚集索引。<font color='red'>MyISAM 引擎，无论主键还是非主键，使用的都是非聚集索引</font>。</p>\n<p>非聚集索引的叶子节点并不一定存放数据的指针，因为<font color='red'>二级索引的叶子节点就存放的是主键，根据主键再回表查数据</font>。</p>\n<p>优点：</p>\n<ul>\n<li><strong>更新代价比聚集索引要小</strong>：因为非聚集索引的<font color='red'>叶子节点是不存放数据的</font></li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>\n<p><strong>依赖于有序的数据</strong>：跟聚簇索引一样，非聚簇索引也依赖于有序的数据</p>\n</li>\n<li>\n<p><strong><font color='orange'>可能会二次查询 (回表查询)</font></strong>: 这应该是非聚簇索引最大的缺点了。<strong><font color='red'>当查到非聚集索引对应的指针或主键后，可能还需要根据指针或主键再到数据文件或表中查询</font></strong>。</p>\n<blockquote>\n<p><strong>非聚集索引不一定回表查询。</strong></p>\n<p>试想一种情况，用户准备使用 SQL 查询用户名，而用户名字段正好建立了索引。</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">SELECT</span> name <span class=\"token keyword\">FROM</span> <span class=\"token keyword\">table</span> <span class=\"token keyword\">WHERE</span> name<span class=\"token operator\">=</span><span class=\"token string\">'guang19'</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>那么这个<font color='red'>索引的 key 本身就是要查询的字段</font>，查到对应的 name 直接返回就行了，无需回表查询。</p>\n<p>即使是 MYISAM 也是这样，虽然 MYISAM 的主键索引确实需要回表，因为它的主键索引的叶子节点存放的是指针。但是！<strong>如果 SQL 查的就是主键呢？</strong></p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">SELECT</span> id <span class=\"token keyword\">FROM</span> <span class=\"token keyword\">table</span> <span class=\"token keyword\">WHERE</span> id<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>主键索引本身的 key 就是主键，查到返回就行了。这种情况就称之为<strong>覆盖索引</strong>了。</p>\n</blockquote>\n</li>\n</ul>\n<p>这是 MySQL 的 InnoDB、MyISAM 表的文件截图：</p>\n<blockquote>\n<p><strong>InnoDB、MyISAM、Memory 这三种存储引擎的存储文件内容</strong>：</p>\n<ul>\n<li>无论哪种引擎，<font color='gree'>表的结构</font>都存储在  <code>.sdi</code>  文件中</li>\n<li>对于 InnoDB，表的索引和数据都存储在  <code>.ibd 表空间文件</code> 中</li>\n<li>对于 MyISAM，表的索引存储在  <code>.MYI</code>  文件中，表的数据存储在  <code>.MYD</code>  文件中</li>\n<li>对于 Memory，表的索引和数据都存储在 <code>内存</code> 中</li>\n</ul>\n</blockquote>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/mysql20210420165311654.png\" alt=\"MySQL 表的文件\" /></p>\n<h5 id=\"聚集索引和非聚集索引的区别\"><a class=\"anchor\" href=\"#聚集索引和非聚集索引的区别\">#</a> <mark>🌟聚集索引和非聚集索引的区别</mark></h5>\n<p>聚集索引：</p>\n<ul>\n<li>\n<p>数据存储方式：表中的数据与索引按顺序存放在一块，<font color='red'>找到索引也就找到了数据</font>，即数据的物理存放顺序与索引顺序是一致的</p>\n</li>\n<li>\n<p>叶节点的 k-v：<font color='red'>（主键，行记录）</font></p>\n</li>\n<li>\n<p>唯一性：<font color='red'>表中只能有一个聚集索引，通常是主键</font>（因为主键要求其值在表中唯一且非空）</p>\n</li>\n<li>\n<p>查询性能：<font color='red'>范围查询、排序查询的性能高</font>，但<font color='red'>插入速度严重依赖于插入顺序</font>；<font color='red'>更新主键的代价很高</font>。</p>\n<blockquote>\n<p><font color='red'>按照主键顺序插入</font>是最快的方式，否则将会出现<font color='red'>页分裂</font>，严重影响性能。因此，对于 InnoDB 表，我们一般都会定义一个<font color='red'>自增的 ID 列为主键</font>。</p>\n<p>更新主键会导致被更新的行移动。因此对于 InnoDB 表，<font color='red'>一般定义主键为不可更新</font>。</p>\n</blockquote>\n</li>\n</ul>\n<p>非聚集索引：</p>\n<ul>\n<li>数据存储方式：<font color='red'>索引和实际数据的物理存储是分离的</font>，索引中存储了指向实际数据行的指针</li>\n<li>叶节点的 k-v：<font color='red'>（索引列，指向行记录的指针）</font></li>\n<li>唯一性：<font color='red'>表可以有多个非聚集索引，包括唯一索引</font>。非聚集索引不要求索引列的值唯一</li>\n<li>查询性能：<font color='red'>插入数据的速度快</font>，但<font color='red'>查询可能涉及回表，速度较慢</font></li>\n</ul>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231119111458997.png\" alt=\"image-20231119111458997\" /></p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/mysql20210420165326946.png\" alt=\"聚簇索引和非聚簇索引\" /></p>\n<h5 id=\"倒排索引\"><a class=\"anchor\" href=\"#倒排索引\">#</a> <mark>🌟倒排索引</mark></h5>\n<p>先讲正排索引，意思就是我们的所有文档都有唯一一个文档 id，根据文档里的内容算出每个文档中关键字的内容和次数，类似于通过 key 去找 value 的形式，如果正牌索引，我们每次寻找关键字查询，就得搜索所有的文档去看是否有这个关键字，这样查询效率太慢了。</p>\n<p>于是有了倒排索引，是通过关键字去查文档，我们建立一个索引库，里面的 key 是关键字，value 是每个文档的 id，倒排在构建索引的时候较为耗时且维护成本较高，但是搜索耗时短，所以我们可以定时去更新索引库。</p>\n<p>正排索引和倒排索引是搜索引擎中的两种索引类型。</p>\n<ul>\n<li>正排索引：每个文档都有一个唯一的文档 ID，<font color='red'>按照文档 ID 等有序的方式将每个文档存储在索引中</font>，通过文档 ID 进行检索。这种方式类似于数据库表的行，可以很方便地根据文档 ID 检索到具体的文档，但是<font color='red'>不适合处理大规模文档库的情况</font>。</li>\n<li>倒排索引：<font color='red'>按照单词或关键字将文档进行索引</font>，并记录包含该词汇的文档列表。</li>\n</ul>\n<p><font color='red'>倒排索引的优势在于查找包含某个项的文档，即用于搜索查询</font>；相反，<font color='red'>正排索引的优势是确定哪些项是否存在单个文档里</font>。</p>\n<p>二者均是在 index-time 时创建，保存在 Lucene 文件中（序列化到磁盘）。</p>\n<h5 id=\"覆盖索引\"><a class=\"anchor\" href=\"#覆盖索引\">#</a> <mark>🌟覆盖索引</mark></h5>\n<blockquote>\n<p>我们都知道 InnoDB 中索引分为两类：</p>\n<ul>\n<li><font color='red'>聚集索引（主键索引）</font>：（<font color='gree'>主键</font>，除主键外的完整行记录）</li>\n<li><font color='red'>非聚集索引（辅助索引 / 普通索引）</font>：（索引列的值，<font color='gree'>主键</font>）</li>\n</ul>\n<p>想要搞清除什么是覆盖索引，首先得弄懂 **<font color='#B32015'>回表查询</font>**：当使用<u>普通索引（辅助索引）</u>进行查询时，先得到行记录的主键值（<font color='red'>但仍未得到所需的所有列数据</font>），然后再根据主键值到<u>聚集索引（主键索引）</u>中找到对应的完整行记录。</p>\n<p>由于<font color='red'>回表导致多次扫描索引树，会降低查询效率</font>。那么如何避免回表查询？</p>\n<p><font color='red'>常用的方法是：将查询需要的字段添加到索引中，建立<u>联合索引</u></font>。比如上面提到的查询语句，可以将 (NAME,CITY) 做成一个联合索引，这样在首次扫描索引树的时候就能从索引树本身获取到需要的所有信息，从而避免了回表。这里使用的方法就是<strong>覆盖索引</strong>。</p>\n<hr />\n<p>举个回表查询的例子，对于 InnoDB 表 EMPLOYEE，由三个字段（ID、NAME、CITY）组成，其中在 ID 上建立了主键索引（聚集索引），在 NAME 上建立了普通索引。</p>\n<p>现在需要进行一次如下的查询：</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">select</span> NAME<span class=\"token punctuation\">,</span>CITY <span class=\"token keyword\">from</span> EMPLOYEE <span class=\"token keyword\">where</span> NAME<span class=\"token operator\">=</span><span class=\"token string\">\"Lee\"</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>首先通过普通索引去找到 NAME=&quot;Lee&quot; 对应的叶节点，获取到行记录的主键值（ID=8）。而该查询语句还需要获取 CITY 字段的值，于是 MySQL 要再根据该主键值（ID=8）通过主键索引查找，从而获得完整的数据。这个过程就是所谓的<strong>回表查询</strong>。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/4cfbd83c40884036b46e895d31a70726.png\" alt=\"在这里插入图片描述\" /></p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/28608822ef07481187c583b22bc3c80a.png\" alt=\"在这里插入图片描述\" /></p>\n</blockquote>\n<p>如果一个 **<font color='#B32015'>索引包含了所有需要查询的字段</font>**，就称之为覆盖索引（Covering Index）。在 InnoDB 中，如果不是主键索引，叶子节点存储的是索引列值 + 主键。最终还是要 “回表”，也就是要通过主键再查找一次，这样就会比较慢。<font color='red'>而覆盖索引就是把要查询出的列和索引是对应的，不做回表操作！因为所查询的字段都在当前索引的叶子节点上存在，可以直接作为结果返回了。</font></p>\n<p>** 覆盖索引，即需要查询的字段正好是索引的字段，那么直接根据该索引就可以查到数据了，而无需回表查询。** 因此，<font color='red'>应该尽量使用覆盖索引，减少 <code>select *</code> </font>。</p>\n<blockquote>\n<p>如主键索引，如果一条 SQL 需要查询主键，那么正好根据主键索引就可以查到主键。再如普通索引，如果一条 SQL 需要查询 name，name 字段正好有索引，那么直接根据这个索引就可以查到数据，也无需回表。</p>\n</blockquote>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/mysql20210420165341868.png\" alt=\"覆盖索引\" /></p>\n<h5 id=\"联合索引\"><a class=\"anchor\" href=\"#联合索引\">#</a> 联合索引</h5>\n<p>使用表中的<strong>多个字段创建索引</strong>，就是 联合索引，也叫 组合索引 或 复合索引。</p>\n<p>以  <code>score</code>  和  <code>name</code>  两个字段建立联合索引：</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">ALTER</span> <span class=\"token keyword\">TABLE</span> <span class=\"token identifier\"><span class=\"token punctuation\">`</span>cus_order<span class=\"token punctuation\">`</span></span> <span class=\"token keyword\">ADD</span> <span class=\"token keyword\">INDEX</span> id_score_name<span class=\"token punctuation\">(</span>score<span class=\"token punctuation\">,</span> name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h4 id=\"最左前缀匹配原则\"><a class=\"anchor\" href=\"#最左前缀匹配原则\">#</a> <mark>🌟最左前缀匹配原则</mark></h4>\n<p>最左前缀法则：<strong><font color='#B32015'>查询条件中的各个列必须是联合索引中从最左边开始的连续子列。</font></strong></p>\n<ul>\n<li><font color='red'>如果跳跃了<u>中间的某一列</u>，那么联合索引将会<u>部分失效</u>（后面的字段索引都失效）。</font></li>\n<li><strong>如果跳跃了<u>最左列</u>，那么联合索引将会<u>全部失效</u>，转而进行全表扫描！</strong></li>\n</ul>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231117221133910.png\" alt=\"image-20231117221133910\" /></p>\n<blockquote>\n<p>注意：<strong>联合索引的最左边字段必须在 SQL 的查询条件中存在，但是与 SQL 的查询条件中编写的字段先后顺序无关</strong>。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231117221449634.png\" alt=\"image-20231117221449634\" /></p>\n<center>因此对于这种情况，联合索引是全部生效的！</center>\n</blockquote>\n<p>所以，<strong>在使用联合索引时，可以将区分度高的字段放在最左边，这也可以过滤更多数据</strong>。</p>\n<p><strong>在联合索引的使用中，如果 SQL 出现范围查询（如  <code>&gt;</code> 、 <code>&lt;</code>  ），那么范围查询右侧的列索引会失效！</strong></p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231117221945853.png\" alt=\"image-20231117221945853\" /></p>\n<blockquote>\n<p>但对于 <strong> <code>&gt;=</code> </strong>、<strong> <code>&lt;=</code> </strong>、<strong> <code>BETWEEN</code> </strong>、<strong> <code>like</code> </strong> 前缀匹配的范围查询，并不会停止匹配。</p>\n</blockquote>\n<h4 id=\"索引下推\"><a class=\"anchor\" href=\"#索引下推\">#</a> 索引下推</h4>\n<p><strong>索引下推（Index Condition Pushdown）</strong> 是 <strong>MySQL 5.6</strong> 版本中提供的一项索引优化功能，可以在非聚簇索引遍历过程中，对索引中包含的字段先做判断，过滤掉不符合条件的记录，减少回表次数。</p>\n<h4 id=\"索引失效\"><a class=\"anchor\" href=\"#索引失效\">#</a> <mark>🌟索引失效</mark></h4>\n<p><strong><font color='red'>索引失效后导致使用全表扫描来查询数据</font></strong>，这也是慢查询的主要原因之一，查询中导致索引失效的常见情况有这些：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/iaIdQfEric9Twmk46GNqLLRSboGCk9Pkk48jba0ibtuuic2ic9elp0r52TBmB0AbBKFK0sOZ9gf3GWPLicL34Chqrevw\" alt=\"img\" /></p>\n<ol>\n<li><strong><font color='#B32015'>MySQL 自身评估使用全表扫描的查询速度比使用索引的更快</font></strong>：MySQL 在查询时，会评估全表扫描的查询效率与使用索引的效率，如果全表扫描更快，则放弃索引，走全表扫描。这种情况一般是  <code>SELECT *</code>  语句。</li>\n</ol>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231118133740655.png\" alt=\"image-20231118133740655\" /></p>\n<ol start=\"2\">\n<li>\n<p><strong><font color='#B32015'>创建了联合索引，但查询条件未遵循<u>最左前缀匹配原则</u>，或者涉及范围查询（如 <code>&gt;</code> 、 <code>&lt;</code> ）</font></strong>。</p>\n<blockquote>\n<p>指路→<a href=\"#==%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80%E5%8C%B9%E9%85%8D%E5%8E%9F%E5%88%99==\">最左前缀匹配原则</a></p>\n</blockquote>\n</li>\n</ol>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231118133951572.png\" alt=\"image-20231118133951572\" /></p>\n<center>未遵循最左前缀匹配原则</center>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231117221945853.png\" alt=\"image-20231117221945853\" /></p>\n<center>涉及范围查询</center>\n<ol start=\"3\">\n<li><strong><font color='#B32015'>查询条件中，对索引列进行了数学运算、函数等操作</font></strong>：<font color='red'>因为索引保存的是索引字段的原始值</font>，而不是表达式计算后的值 / 函数计算后的值，自然无法走索引了，只能通过把索引字段的取值都取出来，然后依次进行表达式计算 / 函数计算来进行条件判断，因此采用的就是<font color='red'>全表扫描</font>的方式。</li>\n</ol>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231118133046959.png\" alt=\"image-20231118133046959\" /></p>\n<ol start=\"4\">\n<li><strong><font color='#B32015'>查询条件中，对索引列进行以 % 开头的 LIKE 模糊查询</font></strong>：当我们使用左或者左右模糊匹配的时候，也就是 like % xx 或者 like % xx% 这两种方式都会造成索引失效。<font color='red'>因为索引 B+ 树是按照「索引值」有序排列存储的，只能根据前缀进行比较</font>。</li>\n</ol>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231118133112182.png\" alt=\"image-20231118133112182\" /></p>\n<ol start=\"5\">\n<li><strong><font color='#B32015'>查询条件中，OR 前后存在非索引的列</font></strong>：因为 OR 的含义就是两个只要满足一个即可，因此只有一个条件列是索引列是没有意义的，<font color='red'>只要有一个条件列不是索引列，就会进行全表扫描</font>。要想使用 OR，又想让索引生效，只能将 OR 条件中的每个列都加上索引。</li>\n</ol>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231118133312921.png\" alt=\"image-20231118133312921\" /></p>\n<center>age没有索引，id、phone有索引</center>\n<ol start=\"6\">\n<li>\n<p><strong><font color='#B32015'>查询条件中，IN /NOT IN 的取值范围较大</font></strong>：导致索引失效，走全表扫描；</p>\n</li>\n<li>\n<p><strong><font color='#B32015'>发生<span class=\"exturl\" data-url=\"aHR0cHM6Ly9qYXZhZ3VpZGUuY24vZGF0YWJhc2UvbXlzcWwvaW5kZXgtaW52YWxpZGF0aW9uLWNhdXNlZC1ieS1pbXBsaWNpdC1jb252ZXJzaW9uLmh0bWw=\">隐式类型转换</span></font></strong>：<font color='red'>当索引列是字符串类型时，若查询条件中数据不加单引号，虽然对于查询结果没什么影响，但是数据库会进行隐式类型转换，导致索引列失效</font>。</p>\n</li>\n</ol>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231118132957838.png\" alt=\"image-20231118132957838\" /></p>\n<ol start=\"8\">\n<li>……</li>\n</ol>\n<p>推荐阅读这篇文章：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvbXdNRTNxdWtIQkZ1bDU3V1FMa09ZZw==\">美团暑期实习一面：MySQl 索引失效的场景有哪些？</span>。</p>\n<h4 id=\"索引的正确使用建议\"><a class=\"anchor\" href=\"#索引的正确使用建议\">#</a> <mark>🌟索引的正确使用建议</mark></h4>\n<blockquote>\n<p>索引设计原则</p>\n</blockquote>\n<h5 id=\"避免索引失效\"><a class=\"anchor\" href=\"#避免索引失效\">#</a> 避免索引失效</h5>\n<blockquote>\n<p>上一节</p>\n</blockquote>\n<h5 id=\"针对数据量大且查询频繁的表建立索引\"><a class=\"anchor\" href=\"#针对数据量大且查询频繁的表建立索引\">#</a> 针对数据量大，且查询频繁的表建立索引</h5>\n<p>基数较小的表，索引效果较差，没有必要在此列建立索引。</p>\n<h5 id=\"选择合适的字段创建索引\"><a class=\"anchor\" href=\"#选择合适的字段创建索引\">#</a> 选择合适的字段创建索引</h5>\n<ul>\n<li>\n<p><strong>不为 NULL 的字段</strong>：索引字段的数据应该尽量不为 NULL，因为<font color='red'>对于数据值为 NULL 的字段，数据库较难优化</font>。如果字段频繁被查询，但又避免不了为 NULL，<font color='red'>建议使用 0,1,true,false </font>这样语义较为清晰的短值或短字符作为替代。</p>\n</li>\n<li>\n<p><strong>被频繁查询的字段</strong>：我们创建索引的字段应该是查询操作非常频繁的字段。</p>\n</li>\n<li>\n<p><strong>常作为查询条件（where）、排序（order by）、分组（group by）操作的字段</strong>：被作为 WHERE 条件查询的字段，应该被考虑建立索引。索引已经排序，这样查询可以利用索引的排序，加快排序查询时间。</p>\n</li>\n<li>\n<p><strong>被经常频繁用于连接子句中的字段</strong>：经常用于连接的字段可能是一些外键列，对于外键列并不一定要建立外键，只是说该列涉及到表与表的关系。对于频繁被连接查询的字段，可以考虑建立索引，<font color='red'>提高多表连接查询的效率</font>。</p>\n</li>\n</ul>\n<h5 id=\"被频繁更新的字段应该慎重建立索引\"><a class=\"anchor\" href=\"#被频繁更新的字段应该慎重建立索引\">#</a> 被频繁更新的字段应该慎重建立索引</h5>\n<p>因为字段的更新会导致索引的更新，而维护索引的成本也是不小的。因此如果一个字段不被经常查询，反而被经常修改，那么就更不应该在这种字段上建立索引了。</p>\n<h5 id=\"限制每张表上的索引数量\"><a class=\"anchor\" href=\"#限制每张表上的索引数量\">#</a> 限制每张表上的索引数量</h5>\n<p>索引需要额外的磁盘空间，并降低写操作的性能。<font color='red'>在修改表内容的时候，索引会进行更新甚至重构，索引列越多，这个时间就会越长</font>。所以只保持需要的索引有利于查询即可。</p>\n<p><font color='red'>建议单张表索引不超过 5 个！</font></p>\n<p><font color='red'>索引可以增加查询效率，但同样也会降低插入和更新的效率</font>，甚至有些情况下会降低查询效率。</p>\n<h5 id=\"尽量考虑联合索引而不是单列索引\"><a class=\"anchor\" href=\"#尽量考虑联合索引而不是单列索引\">#</a> 尽量考虑联合索引，而不是单列索引</h5>\n<p>因为索引是需要占用磁盘空间的，可以简单理解为每个索引都对应着一颗 B+ 树。如果一个表的字段过多，索引过多，那么当这个表的数据达到一个体量后，索引占用的空间也是很多的，且修改索引时，耗费的时间也是较多的。<font color='red'>如果是联合索引，多个字段在一个索引上，那么将会节约很大磁盘空间，且修改数据的操作效率也会提升</font>。</p>\n<h5 id=\"注意避免冗余索引\"><a class=\"anchor\" href=\"#注意避免冗余索引\">#</a> 注意避免冗余索引</h5>\n<p>冗余索引指的是索引的功能相同，能够命中索引 (a, b) 就肯定能命中索引 (a) ，那么索引 (a) 就是冗余索引。如（name,city ）和（name ）这两个索引就是冗余索引，能够命中前者的查询肯定是能够命中后者的。在大多数情况下，都应该尽量扩展已有的索引而不是创建新索引。</p>\n<h5 id=\"针对字符串类型的字段使用前缀索引短索引\"><a class=\"anchor\" href=\"#针对字符串类型的字段使用前缀索引短索引\">#</a> 针对字符串类型的字段，使用前缀索引（短索引）</h5>\n<p><font color='red'>前缀索引（短索引）仅限于字符串类型，只对字符串的一部分前缀建立索引，大大节约索引空间，提高索引效率</font>。</p>\n<h5 id=\"删除长期未使用的索引\"><a class=\"anchor\" href=\"#删除长期未使用的索引\">#</a> 删除长期未使用的索引</h5>\n<p>不用的索引会造成不必要的性能损耗。MySQL 5.7 可以通过查询  <code>sys</code>  库的  <code>schema_unused_indexes</code>  视图来查询哪些索引从未被使用。</p>\n<h5 id=\"不能有效区分数据的字段不适合做索引列\"><a class=\"anchor\" href=\"#不能有效区分数据的字段不适合做索引列\">#</a> 不能有效区分数据的字段不适合做索引列</h5>\n<p>如性别（男 / 女 / 未知），最多也就三种，区分度实在太低。</p>\n<h5 id=\"利用-explain-命令分析-sql-是否走索引查询\"><a class=\"anchor\" href=\"#利用-explain-命令分析-sql-是否走索引查询\">#</a> 利用 EXPLAIN 命令分析 SQL 是否走索引查询</h5>\n<p>我们可以使用 <strong> <code>EXPLAIN</code>  命令</strong>来分析 SQL 的<strong>执行计划</strong> ，这样就知道语句是否命中索引了。执行计划是指<strong>一条 SQL 语句在经过 MySQL 查询优化器的优化后，具体的执行方式</strong>。</p>\n<p><code>EXPLAIN</code>  并不会真的去执行相关的语句，而是通过 <strong>查询优化器</strong> 对语句进行分析，找出最优的查询方案，并显示对应的信息。</p>\n<p><code>EXPLAIN</code>  的输出格式如下：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231118141340551.png\" alt=\"image-20231118141340551\" /></p>\n<p>各个字段的含义如下：</p>\n<table>\n<thead>\n<tr>\n<th><strong>列名</strong></th>\n<th><strong>含义</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>id</td>\n<td>SELECT 查询的序列标识符</td>\n</tr>\n<tr>\n<td>select_type</td>\n<td>SELECT 关键字对应的查询类型</td>\n</tr>\n<tr>\n<td>table</td>\n<td>用到的表名</td>\n</tr>\n<tr>\n<td>partitions</td>\n<td>匹配的分区，对于未分区的表，值为 NULL</td>\n</tr>\n<tr>\n<td><strong>type</strong></td>\n<td><font color='red'>表的访问方法</font></td>\n</tr>\n<tr>\n<td>possible_keys</td>\n<td><font color='red'>可能用到的索引</font></td>\n</tr>\n<tr>\n<td><strong>key</strong></td>\n<td><font color='red'>实际用到的索引</font></td>\n</tr>\n<tr>\n<td>key_len</td>\n<td><font color='red'>所选索引的长度</font></td>\n</tr>\n<tr>\n<td>ref</td>\n<td>当使用索引等值查询时，与索引作比较的列或常量</td>\n</tr>\n<tr>\n<td>rows</td>\n<td>预计要读取的行数</td>\n</tr>\n<tr>\n<td>filtered</td>\n<td>按表条件过滤后，留存的记录数的百分比</td>\n</tr>\n<tr>\n<td><strong>Extra</strong></td>\n<td><font color='red'>附加信息</font></td>\n</tr>\n</tbody>\n</table>\n<p>篇幅问题，我这里只是简单介绍了一下 MySQL 执行计划，详细介绍请看：<a href=\"\">MySQL 执行计划分析</a>这篇文章。</p>\n<h3 id=\"mysql执行计划\"><a class=\"anchor\" href=\"#mysql执行计划\">#</a> MySQL 执行计划</h3>\n<h4 id=\"各个字段\"><a class=\"anchor\" href=\"#各个字段\">#</a> 各个字段</h4>\n<h5 id=\"id\"><a class=\"anchor\" href=\"#id\">#</a> id</h5>\n<p>SELECT 标识符，是查询中 SELECT 的序号，用来标识整个查询中 SELELCT 语句的顺序。</p>\n<ul>\n<li><font color='red'>id 如果相同，从上往下依次执行</font>。</li>\n<li>id 不同，<font color='red'>id 值越大，执行优先级越高</font>，如果行引用其他行的并集结果，则该值可以为 NULL。</li>\n</ul>\n<h5 id=\"select_type\"><a class=\"anchor\" href=\"#select_type\">#</a> select_type</h5>\n<p>查询的类型，主要用于区分普通查询、联合查询、子查询等复杂的查询，常见的值有：</p>\n<ul>\n<li><strong>SIMPLE</strong>：<font color='red'>简单查询</font>，不包含 UNION 或者子查询。</li>\n<li><strong>PRIMARY</strong>：查询中如果包含子查询或其他部分，<font color='red'>外层的 SELECT </font>将被标记为 PRIMARY。</li>\n<li><strong>SUBQUERY</strong>：<font color='red'>子查询中的第一个 SELECT</font>。</li>\n<li><strong>UNION</strong>：在 UNION 语句中，<font color='red'>UNION 之后出现的 SELECT</font>。</li>\n<li><strong>DERIVED</strong>：<font color='red'>在 FROM 中出现的子查询</font>将被标记为 DERIVED。</li>\n<li><strong>UNION RESULT</strong>：UNION 查询的结果。</li>\n</ul>\n<h5 id=\"table\"><a class=\"anchor\" href=\"#table\">#</a> table</h5>\n<p>查询用到的表名，每行都有对应的表名，表名除了正常的表之外，也可能是以下列出的值：</p>\n<ul>\n<li><strong> <code>&lt;unionM,N&gt;</code> </strong> : 本行引用了 id 为 M 和 N 的行的 UNION 结果；</li>\n<li><strong> <code>&lt;derivedN&gt;</code> </strong> : 本行引用了 id 为 N 的表所产生的的派生表结果。派生表有可能产生自 FROM 语句中的子查询。</li>\n<li><strong> <code>&lt;subqueryN&gt;</code> </strong> : 本行引用了 id 为 N 的表所产生的的物化子查询结果。</li>\n</ul>\n<h5 id=\"type重要\"><a class=\"anchor\" href=\"#type重要\">#</a> <mark>type（重要）</mark></h5>\n<p>查询执行的类型，描述了查询是如何执行的。所有值的顺序从最优到最差排序为：system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL</p>\n<p>常见的几种类型具体含义如下（<strong>按照执行效率从低到高的顺序</strong>）：</p>\n<ul>\n<li>\n<p><font color='cornflowerblue'>All（全表扫描）</font>：最坏的情况，因为采用了<font color='red'>全表扫描</font>的方式</p>\n</li>\n<li>\n<p><font color='cornflowerblue'>index（全索引扫描）</font>：<font color='red'>查询遍历了整棵索引树</font>，和 all 差不多，只不过扫描的是索引，而索引一般在内存中，速度更快。只不过 index <font color='red'>对索引表进行全扫描</font>。这样做的好处是不再需要对数据进行排序，但是开销依然很大。</p>\n<blockquote>\n<p>所以要尽量避免全表扫描和全索引扫描。</p>\n</blockquote>\n</li>\n<li>\n<p><font color='cornflowerblue'>range（对索引进行范围扫描）</font>：一般在 where 子句中使用 &lt;、&gt;、in、between 等关键词，只检索给定范围的行，属于范围查找。执行计划中的 key 列表示哪个索引被使用了。</p>\n<blockquote>\n<p><strong><font color='red'>从这一级别开始，索引的作用会越来越明显，因此我们需要尽量让 SQL 查询可以使用到 range 这一级别及以上的 type 访问方式</font></strong>。</p>\n</blockquote>\n</li>\n<li>\n<p><font color='cornflowerblue'>ref（非唯一索引扫描）</font>：<font color='red'>采用了非唯一索引，或者是唯一索引的非唯一性前缀</font>，<font color='red'>查询结果可能返回多条符合条件的行</font>。因为虽然使用了索引，但<font color='red'>该索引列的值并不唯一，有重复</font>。这样即使使用索引快速查找到了第一条数据，仍然不能停止，要进行目标值附近的小范围扫描。但它的<font color='red'>好处是它并不需要扫全表，因为索引是有序的，即便有重复值，也是在一个非常小的范围内扫描</font>。</p>\n</li>\n<li>\n<p><font color='cornflowerblue'>eq_ref（唯一索引扫描）</font>：<font color='red'>使用主键索引或唯一索引</font>时产生的访问方式，<font color='red'>通常使用在多表联查中</font>。比如，对两张表进行联查，关联条件是两张表的 user_id 相等，且 user_id 是唯一索引，那么使用 EXPLAIN 进行执行计划查看的时候，type 就会显示 eq_ref。</p>\n</li>\n<li>\n<p><font color='cornflowerblue'>const</font>：<font color='red'>使用了主键或者唯一索引与常量值进行比较</font>，表中最多只有一行匹配的记录，一次查询就可以找到。比如 select name from product where id=1。</p>\n</li>\n</ul>\n<p>需要说明的是 const 类型和 eq_ref 都使用了主键或唯一索引，不过这两个类型有所区别，<strong><font color='red'>const 是与常量进行比较，查询效率会更快；而 eq_ref 通常用于多表联查中</font></strong>。</p>\n<ul>\n<li><font color='cornflowerblue'>system</font>：如果表使用的引擎对于表行数统计是精确的（如：MyISAM），且表中只有一行记录的情况下，访问方法是 system ，是 const 的一种特例。</li>\n</ul>\n<p>下面这个不知道性能如何...</p>\n<ul>\n<li><strong>index_merge</strong>：当查询条件使用了多个索引时，表示开启了 Index Merge 优化，此时执行计划中的 key 列列出了使用到的索引。</li>\n</ul>\n<h5 id=\"possible_keys\"><a class=\"anchor\" href=\"#possible_keys\">#</a> possible_keys</h5>\n<p>possible_keys 列表示<font color='red'> MySQL 执行查询时可能用到的索引</font>。如果这一列为 NULL ，则表示没有可能用到的索引；这种情况下，需要检查 WHERE 语句中所使用的的列，看是否可以通过给这些列中某个或多个添加索引的方法来提高查询性能。</p>\n<h5 id=\"key重要\"><a class=\"anchor\" href=\"#key重要\">#</a> key（重要）</h5>\n<p>key 列表示<font color='red'> MySQL 实际使用到的索引</font>。如果为 NULL，则表示未用到索引。</p>\n<h5 id=\"key_len\"><a class=\"anchor\" href=\"#key_len\">#</a> key_len</h5>\n<p>key_len 列表示 MySQL 实际使用的索引的最大长度；当使用到联合索引时，有可能是多个列的长度和。在满足需求的前提下越短越好。如果 key 列显示 NULL ，则 key_len 列也显示 NULL 。</p>\n<h5 id=\"rows\"><a class=\"anchor\" href=\"#rows\">#</a> rows</h5>\n<p>rows 列表示根据表统计信息及选用情况，大致估算出找到所需的记录或所需读取的行数，数值越小越好。</p>\n<h5 id=\"extra重要\"><a class=\"anchor\" href=\"#extra重要\">#</a> <mark>Extra（重要）</mark></h5>\n<p>这列包含了 MySQL 解析查询的额外信息，通过这些信息，可以更准确的理解 MySQL 到底是如何执行查询的。常见的值如下：</p>\n<ul>\n<li><strong><font color='cornflowerblue'>Using filesort</font></strong>：在排序时使用了外部的索引排序，没有用到表内索引进行排序。</li>\n<li><strong><font color='cornflowerblue'>Using temporary</font></strong>：MySQL 需要创建临时表来存储查询的结果，常见于 ORDER BY 和 GROUP BY。</li>\n<li><strong><font color='cornflowerblue'>Using index</font></strong>：表明查询使用了覆盖索引，不用回表，查询效率非常高。</li>\n<li><strong>Using index condition</strong>：表示查询优化器选择使用了索引条件下推这个特性。</li>\n<li><strong>Using where</strong>：表明查询使用了 WHERE 子句进行条件过滤。一般在没有使用到索引的时候会出现。</li>\n<li><strong>Using join buffer (Block Nested Loop)</strong>：连表查询的方式，表示当被驱动表的没有使用索引的时候，MySQL 会先将驱动表读出来放到 join buffer 中，再遍历被驱动表与驱动表进行查询。</li>\n</ul>\n<p>这里提醒下，当 Extra 列包含 Using filesort 或 Using temporary 时，MySQL 的性能可能会存在问题，需要尽可能避免。</p>\n<h4 id=\"explain的结果有哪些有哪些信息去告诉你怎么优化\"><a class=\"anchor\" href=\"#explain的结果有哪些有哪些信息去告诉你怎么优化\">#</a> <mark>🌟explain 的结果有哪些？有哪些信息去告诉你怎么优化？</mark></h4>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231130210942311.png\" alt=\"image-20231130210942311\" /></p>\n<p>对于执行计划，参数有：</p>\n<ul>\n<li><code>possible_keys</code> ：可能用到的索引；</li>\n<li><code>key</code> ：<font color='red'>实际用的索引</font>。如果这一项为 NULL，说明没有使用索引；</li>\n<li><code>key_len</code> ：索引的长度；</li>\n<li><code>rows</code> ：扫描的数据行数；</li>\n<li><code>type</code> ：<font color='red'>数据扫描类型</font>；</li>\n<li><code>Extra</code> ：<font color='red'>MySQL 解析查询的额外信息</font>；</li>\n</ul>\n<h5 id=\"type-字段\"><a class=\"anchor\" href=\"#type-字段\">#</a> type 字段</h5>\n<p>type 字段描述了<font color='red'>找到所需数据时使用的扫描方式</font>是什么，常见扫描类型的 **<font color='#B32015'>执行效率从低到高的顺序为</font>**：</p>\n<ul>\n<li>\n<p><font color='cornflowerblue'>All（全表扫描）</font>：最坏的情况，因为采用了<font color='red'>全表扫描</font>的方式</p>\n</li>\n<li>\n<p><font color='cornflowerblue'>index（全索引扫描）</font>： 和 all 差不多，只不过 index <font color='red'>对索引表进行全扫描</font>。这样做的好处是不再需要对数据进行排序，但是开销依然很大。</p>\n<blockquote>\n<p>所以要尽量避免全表扫描和全索引扫描。</p>\n</blockquote>\n</li>\n<li>\n<p><font color='cornflowerblue'>range（索引范围扫描）</font>：一般在 where 子句中使用 &lt;、&gt;、in、between 等关键词，只检索给定范围的行，属于范围查找。</p>\n<blockquote>\n<p><strong><font color='red'>从这一级别开始，索引的作用会越来越明显，因此我们需要尽量让 SQL 查询可以使用到 range 这一级别及以上的 type 访问方式</font></strong>。</p>\n</blockquote>\n</li>\n<li>\n<p><font color='cornflowerblue'>ref（非唯一索引扫描）</font>：采用了非唯一索引，或者是唯一索引的非唯一性前缀，<font color='red'>返回的数据可能是多条</font>。因为虽然使用了索引，但<font color='red'>该索引列的值并不唯一，有重复</font>。这样即使使用索引快速查找到了第一条数据，仍然不能停止，要进行目标值附近的小范围扫描。但它的<font color='red'>好处是它并不需要扫全表，因为索引是有序的，即便有重复值，也是在一个非常小的范围内扫描</font>。</p>\n</li>\n<li>\n<p><font color='cornflowerblue'>eq_ref（唯一索引扫描）</font>：<font color='red'>使用主键索引或唯一索引</font>时产生的访问方式，<font color='red'>通常使用在多表联查中</font>。比如，对两张表进行联查，关联条件是两张表的 user_id 相等，且 user_id 是唯一索引，那么使用 EXPLAIN 进行执行计划查看的时候，type 就会显示 eq_ref。</p>\n</li>\n<li>\n<p><font color='cornflowerblue'>const（结果只有一条的主键或唯一索引扫描）</font>：<font color='red'>使用了主键或者唯一索引与常量值进行比较</font>，比如 select name from product where id=1。</p>\n</li>\n</ul>\n<p>需要说明的是 const 类型和 eq_ref 都使用了主键或唯一索引，不过这两个类型有所区别，<strong><font color='red'>const 是与常量进行比较，查询效率会更快；而 eq_ref 通常用于多表联查中</font></strong>。</p>\n<h5 id=\"extra-字段\"><a class=\"anchor\" href=\"#extra-字段\">#</a> Extra 字段</h5>\n<p>这里说几个重要的参考指标：</p>\n<ul>\n<li><font color='cornflowerblue'>Using filesort</font>：当查询语句中包含 group by 操作，而且无法利用索引完成排序操作的时候，这时<font color='red'>不得不选择相应的排序算法进行，甚至可能会通过文件排序，效率是很低的</font>，所以要避免这种问题的出现。</li>\n<li><font color='cornflowerblue'>Using temporary</font>：<font color='red'>使用临时表保存中间结果</font>，MySQL 在对查询结果排序时使用临时表，常见于排序 order by 和分组查询 group by。效率低，要避免这种问题的出现。</li>\n<li><font color='cornflowerblue'>Using index</font>：所需数据只需在索引即可全部获得，不须要再到表中取数据，也就是<font color='red'>使用了覆盖索引，避免了回表操作</font>，效率不错。</li>\n</ul>\n<h3 id=\"mysql查询缓存\"><a class=\"anchor\" href=\"#mysql查询缓存\">#</a> MySQL 查询缓存</h3>\n<h4 id=\"介绍\"><a class=\"anchor\" href=\"#介绍\">#</a> 介绍</h4>\n<p><font color='red'>执行查询语句的时候，会先查询缓存</font>。不过，<strong><font color='#B32015'>MySQL 8.0 版本后移除</font></strong>，因为这个功能不太实用。</p>\n<p><code>my.cnf</code>  加入以下配置，重启 MySQL 开启查询缓存：</p>\n<figure class=\"highlight properties\"><figcaption data-lang=\".properties\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token key attr-name\">query_cache_type</span><span class=\"token punctuation\">=</span><span class=\"token value attr-value\">1</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token key attr-name\">query_cache_size</span><span class=\"token punctuation\">=</span><span class=\"token value attr-value\">600000</span></pre></td></tr></table></figure><p>MySQL 执行以下命令也可以开启查询缓存：</p>\n<figure class=\"highlight properties\"><figcaption data-lang=\".properties\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token key attr-name\">set</span> <span class=\"token value attr-value\">global  query_cache_type=1;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token key attr-name\">set</span> <span class=\"token value attr-value\">global  query_cache_size=600000;</span></pre></td></tr></table></figure><p>如上，<strong><font color='red'>开启查询缓存后，在同样的查询条件以及数据情况下，会直接在缓存中返回结果</font></strong>。这里的查询条件包括查询本身、当前要查询的数据库、客户端协议版本号等一些可能影响结果的信息。</p>\n<p><strong>查询缓存不命中的情况：</strong></p>\n<ol>\n<li><font color='red'>任何两个查询在任何字符上的不同</font>都会导致缓存不命中。</li>\n<li>如果查询中包含任何<font color='red'>用户自定义函数、存储函数、用户变量、临时表、MySQL 库中的系统表</font>，其查询结果也不会被缓存。</li>\n<li>缓存建立之后，MySQL 的查询缓存系统会跟踪查询中涉及的每张表，<font color='red'>如果这些表（数据或结构）发生变化，那么相关的所有缓存数据都将失效</font>。</li>\n</ol>\n<p>** 缓存虽然能够提升数据库的查询性能，但是缓存同时也带来了额外的开销，每次查询后都要做一次缓存操作，失效后还要销毁。** 因此，开启查询缓存要谨慎，尤其对于写密集的应用来说更是如此。如果开启，要注意合理控制缓存空间大小，一般来说其大小设置为几十 MB 比较合适。</p>\n<p>此外，还可以通过  <code>sql_cache</code>  和  <code>sql_no_cache</code>  来控制某个查询语句是否需要缓存：</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">select</span> sql_no_cache <span class=\"token function\">count</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">from</span> usr<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h4 id=\"总结\"><a class=\"anchor\" href=\"#总结\">#</a> 总结</h4>\n<p><font color='red'>MySQL 中的查询缓存虽然能够提升数据库的查询性能，但是查询同时也带来了额外的开销，每次查询后都要做一次缓存操作，失效后还要销毁</font>。</p>\n<p>查询缓存是一个适用较少情况的缓存机制。如果你的应用对数据库的更新很少，那么查询缓存将会作用显著。比较典型的如博客系统，一般博客<font color='red'>更新相对较慢，数据表相对稳定不变，这时候查询缓存的作用会比较明显</font>。</p>\n<p>简单总结一下查询缓存的<font color='gree'>适用场景</font>：</p>\n<ul>\n<li>表数据修改不频繁、数据较静态</li>\n<li>查询（Select）重复度高</li>\n<li>查询结果集小于 1 MB</li>\n</ul>\n<p>对于一个更新频繁的系统来说，查询缓存缓存的作用是很微小的，在某些情况下开启查询缓存会带来性能的下降。</p>\n<p>简单总结一下查询缓存<font color='gree'>不适用的场景</font>：</p>\n<ul>\n<li>表中的数据、表结构或者索引变动频繁</li>\n<li>重复的查询很少</li>\n<li>查询的结果集很大</li>\n</ul>\n<p>《高性能 MySQL》这样写到：</p>\n<blockquote>\n<p>根据我们的经验，<strong><font color='red'>在高并发压力环境中查询缓存会导致系统性能的下降，甚至僵死</font></strong>。如果你一定要使用查询缓存，那么不要设置太大内存，而且只有在明确收益的时候才使用（数据库内容修改次数较少）。</p>\n</blockquote>\n<p>确实是这样的！<strong><font color='red'>实际项目中，更建议使用本地缓存（比如 Caffeine）或者分布式缓存（比如 Redis），性能更好，更通用一些。</font></strong></p>\n<h3 id=\"mysql三大日志\"><a class=\"anchor\" href=\"#mysql三大日志\">#</a> <mark>🌟MySQL 三大日志</mark></h3>\n<blockquote>\n<p>binlog、redo log、undo log</p>\n</blockquote>\n<h4 id=\"简介\"><a class=\"anchor\" href=\"#简介\">#</a> <mark>🌟简介</mark></h4>\n<p><code>MySQL</code>  日志 主要包括错误日志、查询日志、事务日志、二进制日志几大类。其中，比较重要的还要属：</p>\n<ul>\n<li>二进制日志： <code>binlog</code> （归档日志）</li>\n<li>事务日志： <code>redo log</code> （重做日志）、  <code>undo log</code> （回滚日志）</li>\n</ul>\n<p>下面对这三种日志进行简介：</p>\n<ul>\n<li><strong><font color='cornflowerblue'>binlog（二进制日志 / 归档日志）</font></strong>：<font color='red'>是逻辑日志，记录了语句的原始逻辑</font>。无论用哪种存储引擎，<font color='red'>只要表发生了数据更新，都会产生 binlog 日志</font>。<strong><font color='red'>主要用于主从复制（读写分离）</font></strong>，在主从复制中，从库利用主库上的 binlog 进行重播，实现主从数据同步。</li>\n<li><strong><font color='cornflowerblue'>redo log（重做日志）</font></strong>：<font color='red'>是物理日志，记录了在某个数据页上做了什么修改</font>。防止在发生故障的时间点，尚有脏页未写入磁盘，在重启 mysql 服务的时候，<strong><font color='red'>根据 redo log 进行重做，从而确保事务的持久性（D）</font></strong>。</li>\n<li><strong><font color='cornflowerblue'>undo log（回滚日志）</font></strong>：<font color='red'>是逻辑日志，记录的是逻辑相反的操作信息</font>。可以 **<font color='red'>用于回滚</font><strong>，当执行 rollback 时，就可以从 undo log 中的逻辑记录读取到相应的内容并进行回滚，以确保事务的原子性（A）。同时</strong><font color='red'>可以提供 MVCC 下的读（即非锁定读 / 快照读）</font>**。</li>\n</ul>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/01.png\" alt=\"img\" /></p>\n<h4 id=\"redo-log重做日志-2\"><a class=\"anchor\" href=\"#redo-log重做日志-2\">#</a> redo log（重做日志）</h4>\n<p><code>redo log</code> （重做日志）<font color='red'>是 InnoDB 存储引擎独有的</font>，它让 <code>MySQL</code>  拥有了<strong>崩溃恢复能力</strong>。</p>\n<p>比如  <code>MySQL</code>  实例挂了或宕机了，重启时， <code>InnoDB</code>  存储引擎会使用 <code>redo log</code>  恢复数据，保证数据的持久性与完整性。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/02.png\" alt=\"img\" /></p>\n<p>InnoDB 表的读写流程：</p>\n<ol>\n<li><font color='red'>MySQL 中数据以页为单位</font>，你查询一条记录，会从硬盘把一页的数据加载出来，加载出来的数据叫<strong>数据页</strong>，会放入到 <strong>缓冲池 Buffer Pool</strong> 中。</li>\n<li>后续的查询都是先从 缓冲池 Buffer Pool 中找，没有命中再去硬盘加载，减少硬盘  <code>IO</code>  开销，提升性能。更新表数据的时候，也是如此，发现缓冲池 Buffer Pool 里存在要更新的数据，就直接在缓冲池 Buffer Pool 里更新。</li>\n<li>然后会把 “在某个数据页上做了什么修改” 记录到 ** 重做日志缓存（ <code>redo log buffer</code> ）** 里</li>\n<li>最后，清空 redo log buffer，并刷盘到 <strong>redo log file</strong> 中</li>\n</ol>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/03.png\" alt=\"img\" /></p>\n<h5 id=\"刷盘时机\"><a class=\"anchor\" href=\"#刷盘时机\">#</a> 刷盘时机</h5>\n<blockquote>\n<p>小贴士：<font color='red'>每条 redo 记录由 “表空间号 + 数据页号 + 偏移量 + 修改数据长度 + 具体修改的数据” 组成</font>。</p>\n</blockquote>\n<p>InnoDB 将 redo log buffer 刷到磁盘上有几种情况：</p>\n<ol>\n<li>\n<p><strong>事务提交</strong>：当事务提交时，redo log buffer 里的 redo log 会被刷新到磁盘（可以通过 <code>innodb_flush_log_at_trx_commit</code>  参数控制，后文会提到）。</p>\n</li>\n<li>\n<p><strong>log buffer 空间不足时</strong>：当 log buffer 的容量被占满大约一半时，就需要把这些日志刷新到磁盘上。</p>\n</li>\n<li>\n<p><strong>事务日志缓冲区（transaction log buffer）满时</strong>：InnoDB 使用一个事务日志缓冲区来暂时存储事务的重做日志条目。当缓冲区满时，会触发日志的刷新，将日志写入磁盘。</p>\n</li>\n<li>\n<p><strong>定期执行 Checkpoint（检查点）操作时</strong>：InnoDB 定期会执行检查点操作，将内存中的<font color='red'>脏数据（已修改但尚未写入磁盘的数据）</font>刷新到磁盘，并且会将相应的重做日志一同刷新，以确保数据的一致性。</p>\n</li>\n<li>\n<p><strong><font color='#B32015'>后台线程会周期性刷盘</font></strong>：InnoDB 启动了一个后台线程，负责周期性（每隔 1 秒）地把 redo log buffer 中的内容写到<strong>文件系统缓存（page cache）</strong>，然后调用 <strong> <code>fsync</code> </strong> 刷盘。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/04.png\" alt=\"img\" /></p>\n</li>\n<li>\n<p><strong>正常关闭服务器时</strong>：MySQL 关闭的时候，redo log 都会刷入到磁盘里去。</p>\n</li>\n</ol>\n<p>总之，InnoDB 在多种情况下会刷新重做日志，以保证数据的持久性和一致性。</p>\n<hr />\n<p>我们要注意设置正确的 **<font color='red'>刷盘策略参数  <code>innodb_flush_log_at_trx_commit</code> </font>**。根据 MySQL 配置的刷盘策略的不同，MySQL 宕机之后可能会存在轻微的数据丢失问题。该参数的取值有 3 种，也就是共有 3 种刷盘策略：</p>\n<ul>\n<li>\n<p><strong>0</strong>：设置为 0 的时候，表示<font color='red'>每次事务提交时不进行刷盘操作</font>，而是等待后台线程定期（1 秒）刷盘。这种方式性能最高，但是也最不安全，因为如果 MySQL 挂了或宕机了，可能会丢失最近 1 秒内的事务。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/06.png\" alt=\"img\" /></p>\n</li>\n<li>\n<p><strong>1</strong>：设置为 1 的时候，表示<font color='red'>每次事务提交时都将进行刷盘操作</font>。这种方式性能最低，但是也最安全，因为只要事务提交成功，redo log 记录就一定在磁盘里，不会有任何数据丢失。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/07.png\" alt=\"img\" /></p>\n</li>\n<li>\n<p><strong>2</strong>：设置为 2 的时候，表示<font color='red'>每次事务提交时都只把 log buffer 里的 redo log 内容写入 page cache（文件系统缓存）</font>。page cache 是专门用来缓存文件的，这里被缓存的文件就是 redo log 文件。这种方式的性能和安全性都介于前两者中间。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/09.png\" alt=\"img\" /></p>\n</li>\n</ul>\n<h5 id=\"日志文件组\"><a class=\"anchor\" href=\"#日志文件组\">#</a> 日志文件组</h5>\n<p>硬盘上存储的  <code>redo log</code>  是以一个<strong>日志文件组</strong>的形式出现的，每个日志文件的大小都一样。</p>\n<p>比如可以配置为一组 4 个文件，每个文件的大小是 1GB，那么整个  <code>redo log</code>  日志文件组可以记录 4G 的内容。</p>\n<p>它采用的是<font color='red'>环形数组形式</font>，从头开始写，写到末尾又回到头循环写，如下图所示。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/10.png\" alt=\"img\" /></p>\n<p>在日志文件组中还有两个重要的属性：</p>\n<ul>\n<li><strong>write pos</strong> ：当前记录的写入位置，一边写一边后移</li>\n<li><strong>checkpoint</strong>：当前要擦除的位置，也是往后推移</li>\n</ul>\n<p>每次刷盘  <code>redo log</code>  记录到<strong>日志文件组</strong>中， <code>write pos</code>  位置就会后移更新。</p>\n<p>每次 MySQL 加载<strong>日志文件组</strong>恢复数据时，会清空加载过的  <code>redo log</code>  记录，并把  <code>checkpoint</code>  后移更新。</p>\n<p><code>write pos</code>  和  <code>checkpoint</code>  之间的还空着的部分可以用来写入新的  <code>redo log</code>  记录。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/11.png\" alt=\"img\" /></p>\n<p>如果  <code>write pos</code>  追上  <code>checkpoint</code>  ，表示<strong>日志文件组</strong>满了，这时候不能再写入新的  <code>redo log</code>  记录， <code>MySQL</code>  得停下来，清空一些记录，把  <code>checkpoint</code>  推进一下。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/12.png\" alt=\"img\" /></p>\n<p>在 MySQL 8.0.30 之前，可以通过  <code>innodb_log_files_in_group</code>  和  <code>innodb_log_file_size</code>  配置日志文件组的文件数和文件大小。</p>\n<p>但在 MySQL 8.0.30 及之后的版本中，这两个变量已被废弃，即使被指定也是用来计算  <code>innodb_redo_log_capacity</code>  的值。而<font color='red'>日志文件组的文件数则固定为 32，文件大小则为  <code>innodb_redo_log_capacity / 32</code> </font>。</p>\n<h5 id=\"小结\"><a class=\"anchor\" href=\"#小结\">#</a> 小结</h5>\n<p>思考一个问题：<strong>只要每次把修改后的数据页直接刷盘不就好了，还有  <code>redo log</code>  什么事？</strong></p>\n<p>它们不都是刷盘么？差别在哪里？</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token number\">1</span> <span class=\"token class-name\">Byte</span> <span class=\"token operator\">=</span> <span class=\"token number\">8</span>bit</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token number\">1</span> <span class=\"token constant\">KB</span> <span class=\"token operator\">=</span> <span class=\"token number\">1024</span> <span class=\"token class-name\">Byte</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token number\">1</span> <span class=\"token constant\">MB</span> <span class=\"token operator\">=</span> <span class=\"token number\">1024</span> <span class=\"token constant\">KB</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token number\">1</span> <span class=\"token constant\">GB</span> <span class=\"token operator\">=</span> <span class=\"token number\">1024</span> <span class=\"token constant\">MB</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token number\">1</span> <span class=\"token constant\">TB</span> <span class=\"token operator\">=</span> <span class=\"token number\">1024</span> <span class=\"token constant\">GB</span></pre></td></tr></table></figure><p>实际上，<font color='red'>数据页大小是 <code>16KB</code> ，刷盘比较耗时</font>，可能就修改了数据页里的几  <code>Byte</code>  数据，有必要把完整的数据页刷盘吗？</p>\n<p>而且数据页刷盘是随机写，因为一个数据页对应的位置可能在硬盘文件的随机位置，所以性能是很差。</p>\n<p>如果是写  <code>redo log</code> ，一行记录可能就占几十  <code>Byte</code> ，只包含表空间号、数据页号、磁盘文件偏移量、更新值，再加上是顺序写，所以刷盘速度很快。</p>\n<p>所以<font color='red'>用  <code>redo log</code>  形式记录修改内容，性能会远远超过刷数据页的方式，这也让数据库的并发能力更强</font>。</p>\n<blockquote>\n<p>其实内存的数据页在一定时机也会刷盘，我们把这称为<strong>页合并</strong>，讲  <code>Buffer Pool</code>  的时候会对这块细说</p>\n</blockquote>\n<h4 id=\"binlog归档日志\"><a class=\"anchor\" href=\"#binlog归档日志\">#</a> binlog（归档日志）</h4>\n<p><code>redo log</code>  它是物理日志，记录内容是 “在某个数据页上做了什么修改”，属于  <code>InnoDB</code>  存储引擎。</p>\n<p>而 <font color='red'> <code>binlog</code>  是逻辑日志，记录内容是语句的原始逻辑，会记录所有涉及更新数据的逻辑操作，并且是顺序写。</font>类似于 “给 ID=2 这一行的 c 字段加 1”，属于 <code>MySQL Server</code>  层。</p>\n<p>不管用什么存储引擎，<font color='red'>只要发生了表数据更新，都会产生  <code>binlog</code>  日志</font>。</p>\n<p>可以说 <code>MySQL</code>  数据库的<font color='red'>数据备份、主备、主主、主从</font>都离不开 <code>binlog</code> ，需要依靠 <code>binlog</code>  来<strong>同步数据，保证数据一致性</strong>。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/01-20220305234724956.png\" alt=\"img\" /></p>\n<h5 id=\"记录格式\"><a class=\"anchor\" href=\"#记录格式\">#</a> 记录格式</h5>\n<p><code>binlog</code>  日志有三种格式，可以通过 <code>binlog_format</code>  参数指定。</p>\n<ul>\n<li>\n<p><strong>statement</strong>：记录的是 **<font color='red'>SQL 语句原文</font>**。比如执行一条 <code>update T set update_time=now() where id=1</code> ，记录的内容如下：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/02-20220305234738688.png\" alt=\"img\" /></p>\n<p>同步数据时，会执行记录的 SQL 语句，但是有个问题， <code>update_time=now()</code>  这里会获取当前系统时间，直接执行会导致与原库的数据不一致。为了解决这种问题，我们需要指定为 <code>row</code> 。</p>\n</li>\n<li>\n<p><strong>row</strong>：<font color='red'>防止数据不一致</font>，记录的是 **<font color='red'>包含具体操作数据的 SQL 语句</font>**，需要通过工具 <code>mysqlbinlog</code>  解析。这样就能保证同步数据的一致性，通常情况下都是指定为 <code>row</code> ，这样可以<font color='red'>为数据库的恢复与同步带来更好的可靠性</font>。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/03-20220305234742460.png\" alt=\"img\" /></p>\n<p>但是这种格式，<font color='red'>需要更大的容量来记录，比较占用空间</font>，恢复与同步时会更消耗 IO 资源，影响执行速度。</p>\n</li>\n<li>\n<p><strong>mixed</strong>：一种折中的方案，记录的是 **<font color='red'>前两者的混合</font>**。MySQL 会<font color='red'>判断这条 SQL 语句是否可能引起数据不一致，如果是，就用 <code>row</code>  格式，否则就用 <code>statement</code>  格式</font>。</p>\n</li>\n</ul>\n<h5 id=\"写入机制\"><a class=\"anchor\" href=\"#写入机制\">#</a> 写入机制</h5>\n<p><code>binlog</code>  的写入时机也非常简单，<strong>事务执行过程中，先把日志写到 <code>binlog cache</code> ，事务提交的时候，再把 <code>binlog cache</code>  写到 <code>binlog</code>  文件中</strong>。</p>\n<p>因为一个事务的 <code>binlog</code>  不能被拆开，无论这个事务多大，也要确保一次性写入，所以系统会给每个线程分配一个块内存作为 <code>binlog cache</code> 。</p>\n<p>我们可以通过 <code>binlog_cache_size</code>  参数控制单个线程 binlog cache 大小，如果存储内容超过了这个参数，就要暂存到磁盘（ <code>Swap</code> ）。</p>\n<hr />\n<p><code>binlog</code>  日志刷盘流程如下：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/04-20220305234747840.png\" alt=\"img\" /></p>\n<ul>\n<li><strong>write：把 binlog 日志写入到文件系统的 page cache，并没有把数据持久化到磁盘，所以速度比较快</strong></li>\n<li><strong>fsync：将数据持久化到磁盘的操作</strong></li>\n</ul>\n<hr />\n<p>write 和 fsync 的时机，可以由 ** 参数 <code>sync_binlog</code> ** 控制，默认是 1。</p>\n<p>为 0 的时候，表示每次提交事务都只 <code>write</code> ，由系统自行判断什么时候执行 <code>fsync</code> 。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/05-20220305234754405.png\" alt=\"img\" /></p>\n<p>虽然性能得到提升，但是机器宕机， <code>page cache</code>  里面的 binlog 会丢失。</p>\n<p>为了安全起见，可以设置为 <code>1</code> ，表示每次提交事务都会执行 <code>fsync</code> ，就如同 <strong>redo log 日志刷盘流程</strong> 一样。</p>\n<hr />\n<p>还有一种折中方式，可以设置为 <code>N(N&gt;1)</code> ，表示每次提交事务都 <code>write</code> ，但累积 <code>N</code>  个事务后才 <code>fsync</code> 。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/06-20220305234801592.png\" alt=\"img\" /></p>\n<p>在出现 <code>IO</code>  瓶颈的场景里，将 <code>sync_binlog</code>  设置成一个比较大的值，可以提升性能。</p>\n<p>同样的，如果机器宕机，会丢失最近 <code>N</code>  个事务的 <code>binlog</code>  日志。</p>\n<h4 id=\"两阶段提交\"><a class=\"anchor\" href=\"#两阶段提交\">#</a> <mark>🌟两阶段提交</mark></h4>\n<blockquote>\n<p>解决 redo log 和 binlog 的一致性问题</p>\n</blockquote>\n<p>在执行更新语句过程，会记录  <code>redo log</code>  与  <code>binlog</code>  两块日志，以基本的事务为单位，<font color='red'> <code>redo log</code>  在事务执行过程中可以不断写入，而 <code>binlog</code>  只有在提交事务时才写入</font>，所以 <code>redo log</code>  与 <code>binlog</code>  的写入时机不一样。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/01-20220305234816065.png\" alt=\"img\" /></p>\n<hr />\n<p>为了解决两份日志之间的逻辑一致问题， <code>InnoDB</code>  存储引擎使用 <strong>两阶段提交</strong> 方案。原理很简单，<font color='red'>将  <code>redo log</code>  的写入拆成了两个步骤  <code>prepare</code>  和  <code>commit</code>  </font>。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/04-20220305234956774.png\" alt=\"img\" /></p>\n<p><font color='red'>使用两阶段提交后，写入  <code>binlog</code>  时发生异常也不会有影响，因为 MySQL 根据  <code>redo log</code>  日志恢复数据时，发现  <code>redo log</code>  还处于  <code>prepare</code>  阶段，并且没有对应  <code>binlog</code>  日志，就会回滚该事务</font>。</p>\n<hr />\n<p>再看一个场景， <code>redo log</code>  设置  <code>commit</code>  阶段发生异常，此时不会回滚事务。它会执行下图框住的逻辑，虽然 <code>redo log</code>  是处于 <code>prepare</code>  阶段，但是能通过事务 <code>id</code>  找到对应的 <code>binlog</code>  日志，所以 <code>MySQL</code>  认为是完整的，就会提交事务恢复数据。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/06-20220305234907651.png\" alt=\"img\" /></p>\n<hr />\n<p>这意味着一个事务到底有没有成功，看  <code>redo log</code>  里面有没有 commit 记录，如果有 commit 记录，那么  <code>binlog</code>  一定是持久化成功了，也就是说事务成功了。</p>\n<h4 id=\"undo-log回滚日志\"><a class=\"anchor\" href=\"#undo-log回滚日志\">#</a> undo log（回滚日志）</h4>\n<p>我们知道如果想要保证事务的原子性，就需要在异常发生时，对已经执行的操作进行<strong>回滚</strong>。在 MySQL 中，恢复机制是通过 ** 回滚日志（undo log）** 实现的。</p>\n<p>所有事务进行的修改都会先记录到这个回滚日志中，然后再执行相关的操作。如果执行过程中遇到异常的话，我们直接利用回滚日志中的信息将数据回滚到修改之前的样子即可！</p>\n<p>并且，回滚日志会先于数据持久化到磁盘上。这样就保证了即使遇到数据库突然宕机等情况，当用户再次启动数据库的时候，数据库还能够通过查询回滚日志来回滚将之前未完成的事务。</p>\n<p>另外， <code>MVCC</code>  的实现依赖于：<strong>隐藏字段、Read View、undo log</strong>。在内部实现中， <code>InnoDB</code>  通过数据行的  <code>DB_TRX_ID</code>  和  <code>Read View</code>  来判断数据的可见性，如不可见，则通过数据行的  <code>DB_ROLL_PTR</code>  找到  <code>undo log</code>  中的历史版本。每个事务读到的数据版本可能是不一样的，在同一个事务中，用户只能看到该事务创建  <code>Read View</code>  之前已经提交的修改和该事务本身做的修改。</p>\n<h4 id=\"总结-2\"><a class=\"anchor\" href=\"#总结-2\">#</a> 总结</h4>\n<p>InnoDB 引擎使用 <strong>redo log (重做日志)</strong> 保证事务的<strong>持久性</strong>，使用 <strong>undo log (回滚日志)</strong> 来保证事务的<strong>原子性</strong>。</p>\n<p>MySQL 数据库的<strong>数据备份、主备、主主、主从</strong>都离不开 <code>binlog</code> ，需要依靠 <code>binlog</code>  来同步数据，保证数据一致性。</p>\n<h4 id=\"常见面试题\"><a class=\"anchor\" href=\"#常见面试题\">#</a> 常见面试题</h4>\n<h5 id=\"mysql-中常见的日志有哪些\"><a class=\"anchor\" href=\"#mysql-中常见的日志有哪些\">#</a> <mark>MySQL 中常见的日志有哪些？</mark></h5>\n<p>MySQL 中常见的日志有以下几种：</p>\n<ul>\n<li><strong><font color='cornflowerblue'>归档日志（binlog）</font></strong>：记录了所有修改了数据库结构或数据内容的操作，以便在主从复制时将这些操作同步到从库。二进制日志是<font color='red'>逻辑日志</font>，记录的是对<font color='red'>数据库结构或数据内容</font>的修改。</li>\n<li><strong><font color='cornflowerblue'>重做日志（redo log）</font></strong>：redo log 是 MySQL 的一种日志，<strong>是 InnoDB 存储引擎独有的，它让 MySQL 拥有了崩溃恢复能力</strong>。<font color='red'>redo log 只记录该存储引擎中表的修改，而 binlog 是在数据库层面产生的，所有存储引擎对数据库进行修改都会产生 binlog</font>。redo log 是<font color='red'>物理日志</font>，记录的是对<font color='red'>数据页</font>的修改，而不是对数据的修改。</li>\n<li><strong><font color='cornflowerblue'>回滚日志（undo log）</font></strong>：<strong>是 InnoDB 存储引擎独有的</strong>，记录了所有修改了数据的操作，以便在事务回滚时撤销这些操作。回滚日志是<font color='red'>逻辑日志</font>，记录的是对<font color='red'>数据</font>的修改，而不是对数据页的修改。</li>\n<li>错误日志（errorlog）：记录了 MySQL 服务器启动、运行过程中出现的错误信息。</li>\n<li><font color='cornflowerblue'>慢查询日志（slow query log）</font>：<font color='red'>记录了执行时间超过指定阈值的 DQL 语句</font>，因此可以查看该日志来优化 DQL 语句。慢查询日志<font color='red'>默认是不开启的</font>。</li>\n<li>一般查询日志（general log）：记录了 MySQL 服务器接收到的所有 SQL 语句，包括执行时间、执行结果等信息。一般查询日志可以用于调试和安全审计。</li>\n<li>中继日志（relay log）：是 MySQL 主从复制结构中<font color='red'>从节点上的日志，用于保存主节点传输过来的数据变更事件，然后将这些事件应用于从节点</font>。</li>\n</ul>\n<h5 id=\"慢查询日志有什么用\"><a class=\"anchor\" href=\"#慢查询日志有什么用\">#</a> 慢查询日志有什么用？</h5>\n<p>用来<font color='red'>记录在 MySQL 中响应时间超过阀值的语句</font>，具体指运行时间超过 long_query_time 值的 SQL，则会被记录到慢查询日志中。long_query_time 的默认值为 10，意思是运行 10 秒以上的 SQL 语句。慢查询日志<font color='red'>可以帮助开发人员找出哪些语句的执行效率低，以便进行优化</font>。</p>\n<h5 id=\"mysql-如何优化一个慢查询语句\"><a class=\"anchor\" href=\"#mysql-如何优化一个慢查询语句\">#</a> <mark>MySQL 如何优化一个慢查询语句？</mark></h5>\n<p>指路→<a href=\"#==%E6%85%A2%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E4%BC%98%E5%8C%96==\">慢查询语句优化</a></p>\n<h5 id=\"binlog-主要记录了什么\"><a class=\"anchor\" href=\"#binlog-主要记录了什么\">#</a> binlog 主要记录了什么？</h5>\n<p>binlog 是 MySQL 的二进制日志，主要<font color='red'>记录了对 MySQL 数据库进行的所有更改操作，包括插入、更新和删除操作</font>。binlog 可以用于数据恢复、数据同步和数据备份等方面 。</p>\n<h5 id=\"介绍一下redo-log以及它如何保证事务的持久性\"><a class=\"anchor\" href=\"#介绍一下redo-log以及它如何保证事务的持久性\">#</a> 介绍一下 redo log，以及它如何保证事务的持久性？</h5>\n<p>redo log 是 MySQL 的一种日志，<strong>是 InnoDB 存储引擎独有的，它让 MySQL 拥有了崩溃恢复能力</strong>。<font color='red'>redo log 只记录该存储引擎中表的修改，而 binlog 是在数据库层面产生的，所有存储引擎对数据库进行修改都会产生 binlog</font>。</p>\n<p>redo log 是 MySQL 数据库用于保证事务的持久性的机制之一。在执行一个事务时，<font color='red'>MySQL 会将事务所做出的修改操作先写入 redo log 而不是直接保存到磁盘</font>，也就是 <code>WAL（write ahead log)机制</code> 。这是因为将数据直接写入磁盘的开销较大，而将修改操作写入 redo log 可以大幅减少磁盘 IO 的次数。</p>\n<blockquote>\n<p>WAL（write ahead log）机制的基本思想：</p>\n<p>在修改数据之前，先将修改操作记录到一个日志文件中，然后再将修改操作应用到数据库中。这样，即使在修改数据的过程中出现了故障，也可以通过日志文件来恢复数据 。</p>\n</blockquote>\n<p>当一个事务提交后，<font color='red'>MySQL 会从 redo log 中读取相应的修改操作，并将其写入磁盘</font>。<font color='red'>只要 redo log 已经持久化（即已经写入磁盘），那么就可以保证故障发生后能够完成数据恢复</font>。如果 MySQL 在执行修改操作时遇到了宕机等问题，在重启后会重新应用 redo log 里未被应用的操作，从而实现事务的持久性。</p>\n<h5 id=\"数据页是什么\"><a class=\"anchor\" href=\"#数据页是什么\">#</a> 数据页是什么？</h5>\n<p>数据页是 InnoDB 存储引擎中的一个重要概念，它<strong>是 InnoDB 存储引擎中的最小存储单位。InnoDB 存储引擎将表空间分为多个大小相等的数据页，每个数据页默认大小为 16KB</strong>。在 InnoDB 存储引擎中，每个表都有一个独立的表空间，表空间由多个数据文件组成。当表中的数据发生变化时，InnoDB 存储引擎会将修改操作记录到 redo log 中，并将修改操作应用到内存中的数据页中。当内存中的数据页被修改后，InnoDB 存储引擎会将修改操作异步刷新到磁盘上的数据文件中，从而保证了数据的持久性。</p>\n<h5 id=\"页修改之后为什么不直接刷盘呢\"><a class=\"anchor\" href=\"#页修改之后为什么不直接刷盘呢\">#</a> 页修改之后为什么不直接刷盘呢？</h5>\n<p>在数据库中，将修改的数据直接刷盘（写入磁盘）可能会产生一些性能开销。这是因为在执行随机磁盘 IO 的过程中，磁盘的寻址时间和磁道切换时间等所需的开销较大，说明磁盘 IO 时需要耗费较长的时间。因此<strong>直接刷盘会导致大量的磁盘 I/O，降低系统的性能</strong>。</p>\n<p>为了避免这种情况，InnoDB 存储引擎采用了一种称为 “ <code>脏页刷盘</code> ” 的机制。<font color='red'>在数据库缓存中，如果一个数据页上的数据已经被修改了，但还没有被同步写入磁盘，那么这个数据页就被称为 “ <code>脏页</code> ”</font>。 <code>脏页刷盘</code> 机制是指 InnoDB 存储引擎在<font color='red'>将内存中的数据页刷新到磁盘上</font>时，会根据一定的策略来决定哪些数据页需要被刷新到磁盘上，哪些数据页可以暂时不刷新。</p>\n<ul>\n<li><font color='red'>当内存中的数据页被修改前，InnoDB 存储引擎会将修改操作记录到 redo log 中，并将修改操作应用到内存中的数据页中</font>。</li>\n<li><font color='red'>当内存中的数据页被修改后，InnoDB 存储引擎会将修改操作异步刷新到磁盘上的数据文件中，从而保证了数据的持久性</font>。在这个过程中，InnoDB 存储引擎会根据一定的策略来决定哪些数据页需要被刷新到磁盘上，哪些数据页可以暂时不刷新。这样可以避免大量的磁盘 I/O，提高系统的性能。</li>\n</ul>\n<h5 id=\"binlog-和-redolog-有什么区别\"><a class=\"anchor\" href=\"#binlog-和-redolog-有什么区别\">#</a> binlog 和 redolog 有什么区别？</h5>\n<p>binlog 和 redolog 都是 MySQL 数据库中的日志文件，用于记录数据库的修改操作。它们的主要区别在于：</p>\n<ol>\n<li>\n<p>binlog 是 MySQL 的归档日志，用于<font color='red'>记录所有的修改操作，包括数据的增删改操作和表结构的变更操作等</font>。binlog 的作用是<font color='red'>用于数据恢复、主从复制和数据同步</font>等场景。</p>\n</li>\n<li>\n<p>redolog 是 InnoDB 存储引擎的事务日志，用于<font color='red'>记录事务的修改操作</font>。redolog 的作用是<font color='red'>用于保证事务的原子性、一致性和持久性</font>。当一个事务提交时，会将该事务所做的所有修改操作先记录在 redo log 中并刷到磁盘上，然后再将这些修改操作同步到数据库的数据文件中。</p>\n</li>\n</ol>\n<p>区别:</p>\n<ul>\n<li>binlog 是整个<font color='red'>数据库实例级别</font>的，记录了对整个数据库实例进行的所有更改操作，而 redolog 是每个<font color='red'>InnoDB 存储引擎实例级别</font>的，只记录了在该存储引擎实例中发生的事务更改操作。</li>\n<li>binlog 是对<font color='red'>数据库执行的语句级别</font>的日志，redolog 是对<font color='red'>事务级别</font>的日志，记录了事务的具体操作信息。</li>\n<li>binlog 通常<font color='red'>用于 JDBC 等客户端进行异地灾难恢复</font>，而 redolog<font color='red'>用于保证事务的 ACID 属性（原子性、一致性、隔离性和持久性）</font>。</li>\n</ul>\n<p>因为<font color='red'> binlog 记录了所有的修改操作，所以它比 redolog 更加全面，但也更加耗费磁盘空间</font>。而 <font color='red'>redolog 只记录了事务的修改操作，所以它比 binlog 更加高效，但也更加局限</font>。</p>\n<h5 id=\"undo-log-如何保证事务的原子性\"><a class=\"anchor\" href=\"#undo-log-如何保证事务的原子性\">#</a> undo log 如何保证事务的原子性？</h5>\n<p>undo log <font color='red'>是 InnoDB 存储引擎的</font>回滚日志，<font color='red'>用于记录事务的回滚操作</font>。</p>\n<p>当一个事务需要回滚时，InnoDB 存储引擎会根据 undo log 中的信息将数据页恢复到事务开始之前的状态。因此，undo log 可以保证事务的原子性。</p>\n<p>在 InnoDB 存储引擎中，每个事务都有一个对应的 undo log，用于记录该事务所做的修改操作。当事务提交时，InnoDB 存储引擎会将 undo log 中的信息删除，从而释放磁盘空间。如果事务回滚，则 InnoDB 存储引擎会根据 undo log 中的信息将数据页恢复到事务开始之前的状态。这样可以保证事务的原子性。</p>\n<h3 id=\"mysql事务\"><a class=\"anchor\" href=\"#mysql事务\">#</a> <mark>🌟MySQL 事务</mark></h3>\n<h4 id=\"事务\"><a class=\"anchor\" href=\"#事务\">#</a> 事务</h4>\n<p><font color='red'>事务是一个完整的业务逻辑，内部的所有操作要么全部成功，要么全部失败</font>。</p>\n<h4 id=\"数据库事务\"><a class=\"anchor\" href=\"#数据库事务\">#</a> 数据库事务</h4>\n<p><font color='red'>对于数据库来说，事务是由批量的 DML 语句所构成的逻辑整体，要么全执行成功，要么全执行失败</font>。</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># 开启一个事务</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">START</span> <span class=\"token keyword\">TRANSACTION</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token comment\"># 多条 SQL 语句</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>SQL1<span class=\"token punctuation\">,</span>SQL2<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token comment\">## 提交事务</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token keyword\">COMMIT</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230424112420132.png\" alt=\"image-20230424112420132\" /></p>\n<h4 id=\"acid-特征\"><a class=\"anchor\" href=\"#acid-特征\">#</a> <mark>🌟ACID 特征</mark></h4>\n<p>关系型数据库（例如： <code>MySQL</code> 、 <code>SQL Server</code> 、 <code>Oracle</code>  等）事务都有 <strong>ACID</strong> 特性：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230424112518237.png\" alt=\"image-20230424112518237\" /></p>\n<ul>\n<li>\n<p><strong>原子性</strong>（ <code>Atomicity</code> ）：事务是不可分割的最小操作单元，内部的所有操作要么全部成功，要么全部失败；</p>\n<blockquote>\n<p><font color='red'>由 Undo Log 日志保证</font>，记录了需要回滚的日志信息，事务回滚时撤销已经执行成功的 SQL 语句。</p>\n</blockquote>\n</li>\n<li>\n<p><strong>一致性</strong>（ <code>Consistency</code> ）：事务完成前后，数据库必须保持一致状态，即都是合理的数据状态。例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；</p>\n<blockquote>\n<p><font color='red'>由 A、I、D 共同保证</font></p>\n</blockquote>\n</li>\n<li>\n<p><strong>隔离性</strong>（ <code>Isolation</code> ）：数据库提供的隔离机制，可以保证事务在不受外部并发操作影响的独立环境下运行。即并发访问数据库时，一个事务所做的修改在最终提交前，对其他并发事务是不可见的。各并发事务之间，数据库是独立的；</p>\n<blockquote>\n<p><font color='red'>由 MVCC 保证</font></p>\n</blockquote>\n</li>\n<li>\n<p><strong>持久性</strong>（ <code>Durability</code> ）：事务一旦提交，它对数据库中数据的更改就是持久的。即使数据库发生故障，这种更改也不会丢失。</p>\n<blockquote>\n<p><font color='red'>由 内存 + Redo Log 保证</font>，MySQL 修改数据同时在内存和 Redo Log 记录这次操作，宕机时可从 Redo Log 恢复数据。</p>\n</blockquote>\n</li>\n</ul>\n<blockquote>\n<p>**A、I、D 是手段，C 才是目的！** 只有保证了事务的原子性、隔离性、持久性之后，一致性才能得到保障。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230424112548870.png\" alt=\"image-20230424112548870\" /></p>\n</blockquote>\n<h4 id=\"4个一致性问题\"><a class=\"anchor\" href=\"#4个一致性问题\">#</a> <mark>🌟4 个一致性问题</mark></h4>\n<p>多个事务并发运行，经常会操作相同的数据来完成各自的任务（例如多个客户端并发地访问同一个表），如果事务之间没有设置合理的隔离级别，可能会导致以下 4 种问题。</p>\n<h5 id=\"脏读dirty-read\"><a class=\"anchor\" href=\"#脏读dirty-read\">#</a> 脏读（Dirty read）</h5>\n<p>一个事务读取并修改了数据，这个修改对其他并发事务来说是可见的，即使该事务还没有提交。这时另一个并发事务读取了这个还未提交的数据，但是第一个事务突然回滚，导致数据并没有被提交到数据库。那第二个事务读取到的就是脏数据，这也就是脏读的由来。</p>\n<p>例如：事务 1 读取某表中的数据 A=20，事务 1 修改 A=A-1，事务 2 读取到 A = 19, 事务 1 回滚导致对 A 的修改并为提交到数据库， A 的值还是 20。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230424112618536.png\" alt=\"脏读\" /></p>\n<center> 脏读（Dirty read）</center>\n<h5 id=\"丢失修改lost-to-modify\"><a class=\"anchor\" href=\"#丢失修改lost-to-modify\">#</a> 丢失修改（Lost to modify）</h5>\n<p>在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。</p>\n<p>例如：事务 1 读取某表中的数据 A=20，事务 2 也读取 A=20，事务 1 先修改 A=A-1，事务 2 后来也修改 A=A-1，最终结果 A=19，事务 1 的修改被丢失。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230424112636565.png\" alt=\"image-20230424112636565\" /></p>\n<center>丢失修改（Lost to modify）</center>\n<h5 id=\"不可重复读unrepeatable-read\"><a class=\"anchor\" href=\"#不可重复读unrepeatable-read\">#</a> 不可重复读（Unrepeatable read）</h5>\n<p>在一个事务内多次读同一数据。在一个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。</p>\n<p>例如：事务 1 读取某表中的数据 A=20，事务 2 也读取 A=20，事务 1 修改 A=A-1，事务 2 再次读取 A =19，此时读取的结果和第一次读取的结果不同。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230424112650372.png\" alt=\"image-20230424112650372\" /></p>\n<center>不可重复读（Unrepeatable read）</center>\n<h5 id=\"幻读phantom-read\"><a class=\"anchor\" href=\"#幻读phantom-read\">#</a> 幻读（Phantom read）</h5>\n<p>一个事务读取了几行数据，接着另一个并发事务<font color='red'>插入</font>了一些数据时。第一个事务在随后的查询中就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</p>\n<p>例如：事务 2 读取某个范围的数据，事务 1 在这个范围插入了新的数据，事务 2 再次读取这个范围的数据发现相比于第一次读取的结果多了新的数据。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20230424112700267.png\" alt=\"image-20230424112700267\" /></p>\n<center>幻读（Phantom read）</center>\n<h4 id=\"不可重复读和幻读的区别\"><a class=\"anchor\" href=\"#不可重复读和幻读的区别\">#</a> 不可重复读和幻读的区别</h4>\n<ul>\n<li><font color='red'>不可重复读的重点是<u>字段值修改</u>或<u>记录减少</u></font>。比如多次读取一条记录，发现其中某些字段的值被修改了。</li>\n<li><font color='red'>幻读的重点在于<u>记录新增</u></font>。比如多次执行同一条查询语句（DQL）时，发现查到的记录增加了。</li>\n</ul>\n<p>幻读其实可以看作是不可重复读的一种特殊情况，区分二者的原因是二者的解决方案不一样。</p>\n<p>举个例子：执行  <code>delete</code>  和  <code>update</code>  操作的时候，可以直接对记录加锁，保证事务安全。而执行  <code>insert</code>  操作的时候，由于记录锁（Record Lock）只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁（Gap Lock）。也就是说执行  <code>insert</code>  操作的时候需要依赖 Next-Key Lock（Record Lock+Gap Lock） 进行加锁来保证不出现幻读。</p>\n<h4 id=\"并发事务的控制方式隔离性\"><a class=\"anchor\" href=\"#并发事务的控制方式隔离性\">#</a> 并发事务的控制方式（隔离性）</h4>\n<p>MySQL 中并发事务的控制方式无非就两种：<strong>锁</strong> 和 <strong>多版本并发控制（MVCC）</strong>。</p>\n<p>锁可以看作是悲观控制的模式，多版本并发控制（MVCC，Multiversion concurrency control）可以看作是乐观控制的模式。</p>\n<h5 id=\"锁\"><a class=\"anchor\" href=\"#锁\">#</a> 锁</h5>\n<p>通过锁来显示地控制共享资源，而不是通过调度手段。MySQL 中主要是通过<strong>读写锁</strong>来实现并发控制。</p>\n<ul>\n<li><strong>共享锁（S 锁）</strong>：又称<font color='red'>读锁</font>。事务在读取记录的时候获取共享锁，允许多个事务同时获取（锁兼容）。</li>\n<li><strong>排他锁（X 锁）</strong>：又称<font color='red'>写锁 / 独占锁</font>。事务在修改记录的时候获取排他锁，不允许多个事务同时获取。如果一个记录已经被加了排他锁，那其他事务不能再对这条记录加任何类型的锁（锁不兼容）。</li>\n</ul>\n<p>读写锁可以做到读读并行，但是<font color='red'>无法做到读写并行、写写并行</font>。</p>\n<p>另外，根据根据锁粒度的不同，又被分为<strong>表级锁 (table-level locking)<strong> 和</strong>行级锁 (row-level locking)</strong>。<font color='red'>InnoDB 不光支持表级锁，还支持行级锁</font>，默认为行级锁。行级锁的粒度更小，仅对相关的记录上锁即可（对一行或者多行记录加锁）。所以对于并发写入操作来说，InnoDB 的性能更高。</p>\n<p><font color='red'>不论是表级锁还是行级锁，都存在共享锁（Share Lock，S 锁）和排他锁（Exclusive Lock，X 锁）这两类</font>。</p>\n<h5 id=\"多版本并发控制mvcc\"><a class=\"anchor\" href=\"#多版本并发控制mvcc\">#</a> 多版本并发控制（MVCC）</h5>\n<p><strong>MVCC</strong> 是多版本并发控制方法，即<font color='red'>对一份数据会存储多个版本</font>，通过事务的可见性来保证事务能看到自己应该看到的版本。<font color='red'>通常会有一个全局的版本分配器来为每一行数据设置版本号，版本号是唯一的</font>。</p>\n<p>MVCC 在 MySQL 中实现所依赖的手段主要是：</p>\n<ul>\n<li><strong>undo log</strong>：记录某行数据的多个版本的数据。</li>\n<li><strong>read view</strong> 和 <strong>隐藏字段</strong>：判断当前版本数据的可见性。</li>\n</ul>\n<p>关于 InnoDB 对 MVCC 的具体实现可以看这篇文章：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9qYXZhZ3VpZGUuY24vZGF0YWJhc2UvbXlzcWwvaW5ub2RiLWltcGxlbWVudGF0aW9uLW9mLW12Y2MuaHRtbA==\">InnoDB 存储引擎对 MVCC 的实现</span> 。</p>\n<h4 id=\"4种隔离级别\"><a class=\"anchor\" href=\"#4种隔离级别\">#</a> <mark>🌟4 种隔离级别</mark></h4>\n<p>SQL 标准为事务定义了四种隔离级别：</p>\n<ul>\n<li>\n<p><strong>READ-UNCOMMITTED（读未提交）</strong>：最低的隔离级别，<font color='red'>允许当前事务读取其他并发事务尚未提交的数据</font>，存在脏读、不可重复读、幻读问题。</p>\n<blockquote>\n<p>用户本来应该读取到 id=1 的用户 age 应该是 10，结果读取到了其他事务还没有提交的事务，结果读取 age=20，这就是脏读。</p>\n</blockquote>\n</li>\n<li>\n<p><strong>READ-COMMITTED（读已提交）</strong>：<font color='red'>允许当前事务读取其他并发事务已经提交的数据</font>。可以避免脏读，但是存在不可重复读、幻读问题。</p>\n<blockquote>\n<p>用户开启事务读取 id=1 的用户，查询到 age=16，再次读取发现结果 age=20，在同一个事务里同一个查询读取到不同的结果，叫做不可重复读。</p>\n</blockquote>\n</li>\n<li>\n<p><strong>REPEATABLE-READ（可重复读）</strong>：MySQL 的默认隔离级别，<font color='red'>当前事务对同一数据的多次读取结果都是一样的</font>（都是复用事务刚开始时的数据读取结果副本），除非数据被本身事务所修改。可以避免脏读和不可重复读，但幻读仍有可能发生。</p>\n</li>\n<li>\n<p><strong>SERIALIZABLE（串行化 / 序列化）</strong>：最高的隔离级别，完全服从 ACID 的隔离级别。<font color='red'>所有的事务依次串行执行</font>，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。</p>\n</li>\n</ul>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231118212951118.png\" alt=\"image-20231118212951118\" /></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">隔离级别</th>\n<th style=\"text-align:center\">脏读</th>\n<th style=\"text-align:center\">不可重复读</th>\n<th style=\"text-align:center\">幻读</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">READ-UNCOMMITTED</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">READ-COMMITTED</td>\n<td style=\"text-align:center\">×</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">REPEATABLE-READ</td>\n<td style=\"text-align:center\">×</td>\n<td style=\"text-align:center\">×</td>\n<td style=\"text-align:center\">√/×（InnoDB）</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">SERIALIZABLE</td>\n<td style=\"text-align:center\">×</td>\n<td style=\"text-align:center\">×</td>\n<td style=\"text-align:center\">×</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"mysql-的隔离级别是基于锁和-mvcc-机制共同实现的\"><a class=\"anchor\" href=\"#mysql-的隔离级别是基于锁和-mvcc-机制共同实现的\">#</a> MySQL 的隔离级别是基于锁和 MVCC 机制共同实现的</h4>\n<p>SERIALIZABLE 隔离级别是通过锁来实现的，READ-COMMITTED 和 REPEATABLE-READ 隔离级别是基于 MVCC 实现的。不过，SERIALIZABLE 之外的其他隔离级别可能也需要用到锁机制，就比如 REPEATABLE-READ 在当前读情况下需要使用加锁读来保证不会出现幻读。</p>\n<h4 id=\"mysqlinnodb的默认隔离级别是-repeatable-read可重读\"><a class=\"anchor\" href=\"#mysqlinnodb的默认隔离级别是-repeatable-read可重读\">#</a> MySQL（InnoDB）的默认隔离级别是 REPEATABLE-READ（可重读）</h4>\n<p>MySQL（InnoDB）默认支持的隔离级别是 <strong>REPEATABLE-READ（可重读）</strong>。</p>\n<p>可以通过 <code>SELECT @@tx_isolation;</code>  命令来查看，MySQL 8.0 该命令改为 <code>SELECT @@transaction_isolation;</code></p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>mysql<span class=\"token operator\">></span> <span class=\"token keyword\">SELECT</span> @<span class=\"token variable\">@tx_isolation</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token operator\">+</span><span class=\"token comment\">-----------------+</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token operator\">|</span> @<span class=\"token variable\">@tx_isolation</span>  <span class=\"token operator\">|</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token operator\">+</span><span class=\"token comment\">-----------------+</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token operator\">|</span> <span class=\"token keyword\">REPEATABLE</span><span class=\"token operator\">-</span><span class=\"token keyword\">READ</span> <span class=\"token operator\">|</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token operator\">+</span><span class=\"token comment\">-----------------+</span></pre></td></tr></table></figure><p>关于 MySQL 事务隔离级别的详细介绍，可以看看我写的这篇文章：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9qYXZhZ3VpZGUuY24vZGF0YWJhc2UvbXlzcWwvdHJhbnNhY3Rpb24taXNvbGF0aW9uLWxldmVsLmh0bWw=\">MySQL 事务隔离级别详解</span>。</p>\n<h4 id=\"mysql-事务隔离级别与一致性问题的演示\"><a class=\"anchor\" href=\"#mysql-事务隔离级别与一致性问题的演示\">#</a> MySQL 事务隔离级别与一致性问题的演示</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/2019-31-1%25E8%2584%258F%25E8%25AF%25BB(%25E8%25AF%25BB%25E6%259C%25AA%25E6%258F%2590%25E4%25BA%25A4)%25E5%25AE%259E%25E4%25BE%258B.jpg\" alt=\"img\" /></p>\n<center>脏读（读未提交）</center>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/2019-31-2%25E8%25AF%25BB%25E5%25B7%25B2%25E6%258F%2590%25E4%25BA%25A4%25E5%25AE%259E%25E4%25BE%258B.jpg\" alt=\"img\" /></p>\n<center>避免脏读（读已提交）</center>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/2019-32-1%25E4%25B8%258D%25E5%258F%25AF%25E9%2587%258D%25E5%25A4%258D%25E8%25AF%25BB%25E5%25AE%259E%25E4%25BE%258B.jpg\" alt=\"img\" /></p>\n<center>不可重复读（读已提交）</center>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/2019-33-2%25E5%258F%25AF%25E9%2587%258D%25E5%25A4%258D%25E8%25AF%25BB.jpg\" alt=\"img\" /></p>\n<center>可重复读</center>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/phantom_read.png\" alt=\"img\" /></p>\n<center>幻读</center>\n<p>SQL 脚本 1 在第一次查询工资为 500 的记录时只有一条，SQL 脚本 2 插入了一条工资为 500 的记录，提交之后；SQL 脚本 1 在同一个事务中再次使用当前读查询发现出现了两条工资为 500 的记录这种就是幻读。</p>\n<p><font color='red'>幻读的解决方法：核心思想就是一个事务在操作某张表数据的时候，另外一个事务不允许新增或者删除这张表中的数据了</font>。解决幻读的方式主要有以下几种：</p>\n<ol>\n<li>将事务隔离级别调整为  <code>SERIALIZABLE</code>  。</li>\n<li>在可重复读的事务级别下，给事务操作的这张表添加<font color='red'>表锁</font>。</li>\n<li>在可重复读的事务级别下，给事务操作的这张表添加  <code>Next-key Lock（Record Lock+Gap Lock）</code> 。</li>\n</ol>\n<h3 id=\"mysql锁\"><a class=\"anchor\" href=\"#mysql锁\">#</a> <mark>🌟MySQL 锁</mark></h3>\n<h4 id=\"概述-2\"><a class=\"anchor\" href=\"#概述-2\">#</a> 概述</h4>\n<p>在数据库中，数据是一种供许多用户共享的资源，必须保证数据并发访问的一致性、有效性。</p>\n<p>MySQL 中的锁，按照锁的粒度分，分为以下三类：</p>\n<ul>\n<li>\n<p><font color='cornflowerblue'>全局锁</font>：锁定<font color='red'>整个数据库</font>。</p>\n</li>\n<li>\n<p><font color='cornflowerblue'>表级锁</font>：每次操作锁住<font color='red'>整张表</font>。</p>\n<ul>\n<li>表锁：</li>\n<li>元数据锁（meta data lock，MDL）：加锁过程是系统自动控制的</li>\n<li>意向锁：不与行级锁冲突，由 InnoDB 自动添加，无需用户干预。\n<ul>\n<li>意向共享锁（IS）</li>\n<li>意向排他锁（IX）</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><font color='cornflowerblue'>行级锁</font>：每次操作锁住对应的<font color='red'>行数据</font>，其<font color='red'>实现依赖于索引</font>，而不是记录。</p>\n<ul>\n<li>行锁 / 记录锁（Record Lock）：存在于包括主键索引在内的唯一索引中，锁定<font color='red'>单条索引记录</font></li>\n<li>间隙锁（Gap Lock）：存在于非唯一索引中，锁定<font color='red'>开区间</font>范围内的一段间隔</li>\n<li>临键锁（Next-Key Lock）：存在于非唯一索引中，锁定<font color='red'>左开右闭</font>的索引区间</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"全局锁\"><a class=\"anchor\" href=\"#全局锁\">#</a> 全局锁</h4>\n<h5 id=\"介绍-2\"><a class=\"anchor\" href=\"#介绍-2\">#</a> 介绍</h5>\n<p>全局锁就是<font color='red'>对整个数据库实例加锁，加锁后整个实例就处于只读状态，后续的 DML 的写语句，DDL 语句，已经更新操作的事务提交语句都将被阻塞</font>。</p>\n<p>典型的使用场景是做<font color='red'>全库的逻辑备份</font>，对所有的表进行锁定，从而获取一致性视图，保证数据的完整性。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231119154827391.png\" alt=\"image-20231119154827391\" /></p>\n<center>不加MySQL全局锁会导致备份数据的不一致</center>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231119154907407.png\" alt=\"image-20231119154907407\" /></p>\n<center>加了MySQL全局锁后只能执行DQL语句，数据库处于只读状态，保证了数据的一致性和完整性</center>\n<h5 id=\"语法\"><a class=\"anchor\" href=\"#语法\">#</a> 语法</h5>\n<ol>\n<li>\n<p>添加全局锁：</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>flush <span class=\"token keyword\">tables</span> <span class=\"token keyword\">with</span> <span class=\"token keyword\">read</span> <span class=\"token keyword\">lock</span> <span class=\"token punctuation\">;</span></pre></td></tr></table></figure></li>\n<li>\n<p>数据备份（退出 mysql，在 Windows 的 cmd 窗口中执行）：</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>mysqldump <span class=\"token parameter variable\">-uroot</span> –p1234 itcast <span class=\"token operator\">></span> itcast.sql <span class=\"token punctuation\">;</span></pre></td></tr></table></figure></li>\n<li>\n<p>释放锁：</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">unlock</span> <span class=\"token keyword\">tables</span> <span class=\"token punctuation\">;</span></pre></td></tr></table></figure></li>\n</ol>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231119155453030.png\" alt=\"image-20231119155453030\" /></p>\n<h5 id=\"特点\"><a class=\"anchor\" href=\"#特点\">#</a> 特点</h5>\n<p>数据库中加全局锁，是一个比较重的操作，存在以下问题：</p>\n<ul>\n<li>如果在<font color='gree'>主库</font>上备份，那么<font color='red'>在备份期间都不能执行更新，业务基本上就得停摆</font>。</li>\n<li>如果在<font color='gree'>从库</font>上备份，那么<font color='red'>在备份期间从库不能执行主库同步过来的二进制日志（binlog），会导致主从延迟</font>。</li>\n</ul>\n<p>为了解决上述问题，在 InnoDB 引擎中可以在备份时加上参数  <code>--single-transaction</code>  参数来完成 **<font color='#B32015'>不加锁的一致性数据备份</font>**。</p>\n<blockquote>\n<p><strong>快照读</strong></p>\n</blockquote>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>mysqldump --single-transaction <span class=\"token parameter variable\">-uroot</span> –p123456 itcast <span class=\"token operator\">></span> itcast.sql</pre></td></tr></table></figure><h4 id=\"表级锁\"><a class=\"anchor\" href=\"#表级锁\">#</a> 表级锁</h4>\n<h5 id=\"介绍-3\"><a class=\"anchor\" href=\"#介绍-3\">#</a> 介绍</h5>\n<p>表级锁，即锁住整张表，MyISAM、InnoDB、BDB 等存储引擎都支持，主要分为以下三类：</p>\n<blockquote>\n<p><strong>每类表级锁，都分为<font color='cyan'>共享锁（S 锁 / 读锁）</font>和<font color='cyan'>排他锁（X 锁 / 写锁）</font></strong></p>\n</blockquote>\n<ul>\n<li><font color='cornflowerblue'>表锁</font></li>\n<li><font color='cornflowerblue'>元数据锁</font>（meta data lock，MDL）</li>\n<li><font color='cornflowerblue'>意向锁</font></li>\n</ul>\n<h5 id=\"表锁\"><a class=\"anchor\" href=\"#表锁\">#</a> 表锁</h5>\n<p>对于表锁，分为两类：</p>\n<blockquote>\n<p>结论:</p>\n<ul>\n<li>读锁不会阻塞其他客户端的读，但是会阻塞写。</li>\n<li>写锁既会阻塞其他客户端的读，又会阻塞其他客户端的写。</li>\n</ul>\n</blockquote>\n<ul>\n<li>\n<p><font color='cyan'>表锁共享锁（Shared）</font>：又称<font color='red'>读锁</font></p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231119161818290.png\" alt=\"image-20231119161818290\" /></p>\n<center>左侧为客户端一，对指定表加了读锁，只能读不能写。<font color='red'>不会影响右侧客户端二的读，但是会阻塞右侧客户端的写</font></font>。</center>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231119161947749.png\" alt=\"image-20231119161947749\" /></p>\n</li>\n<li>\n<p><font color='cyan'>表锁排他锁（eXclusive）</font>：又称<font color='red'>写锁</font></p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231119162023867.png\" alt=\"image-20231119162023867\" /></p>\n<center>左侧为客户端一，对指定表加了写锁，可以读和写。<font color='red'>但是会阻塞右侧客户端的读和写</font>。</center>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231119162246255.png\" alt=\"image-20231119162246255\" /></p>\n</li>\n</ul>\n<p>语法：</p>\n<ul>\n<li>\n<p>加锁：</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">lock</span> <span class=\"token keyword\">tables</span> 表名<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> <span class=\"token keyword\">read</span><span class=\"token operator\">/</span><span class=\"token keyword\">write</span></pre></td></tr></table></figure></li>\n<li>\n<p>释放锁：客户端断开连接，或者</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">unlock</span> <span class=\"token keyword\">tables</span></pre></td></tr></table></figure></li>\n</ul>\n<h5 id=\"元数据锁\"><a class=\"anchor\" href=\"#元数据锁\">#</a> 元数据锁</h5>\n<blockquote>\n<p>全称为 meta data lock，简写 MDL，这里的元数据，大家可以简单理解为就是一张表的表结构。</p>\n</blockquote>\n<p><strong><font color='red'>MDL 加锁过程是系统自动控制的</font></strong>，无需显式使用，在访问一张表的时候会自动加上。</p>\n<p>MDL 锁<font color='red'>主要作用是维护表元数据的数据一致性，在表上有活动事务的时候，不可以对元数据进行写入操作</font>。<strong><font color='#B32015'>为了避免 DML 与 DDL 冲突，保证读写的正确性</font></strong>。也就是说，某一张表涉及到未提交的事务时，是不能够修改这张表的表结构的。</p>\n<p>在 MySQL5.5 中引入了 MDL，</p>\n<ul>\n<li><font color='red'>当对一张表的数据进行增删改查（DML、DQL）的时候，加<font color='cyan'> MDL 共享锁</font></font></li>\n<li><font color='red'>当对表结构进行变更操作（DDL）的时候，加<font color='cyan'> MDL 排他锁</font></font></li>\n</ul>\n<p>举个例子，对于常见的 SQL 操作，所添加的 MDL 锁：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231119172457594.png\" alt=\"image-20231119172457594\" /></p>\n<h5 id=\"意向锁\"><a class=\"anchor\" href=\"#意向锁\">#</a> 意向锁</h5>\n<h6 id=\"介绍-4\"><a class=\"anchor\" href=\"#介绍-4\">#</a> 介绍</h6>\n<p>为了避免 DML 在执行时，加的行锁与表锁的冲突，在 InnoDB 中引入了意向锁，<font color='red'>使得表锁不用检查每行数据是否加锁</font>，减少表锁的检查。</p>\n<p>意向锁的工作机制如下：</p>\n<ol>\n<li>客户端在<font color='red'>执行 DML 时，会对涉及的记录加行锁，同时对该表加上<u>意向锁</u></font></li>\n<li>其他客户端在尝试对该表加表锁时，<font color='red'>会根据该表上所加的<u>意向锁</u>来判定是否可以成功加表锁，而不用逐行判断行锁情况了</font>。</li>\n</ol>\n<h6 id=\"分类\"><a class=\"anchor\" href=\"#分类\">#</a> 分类</h6>\n<blockquote>\n<p><font color='red'>意向锁之间不会互斥。并且一旦事务提交了，意向锁就自动释放了</font>。</p>\n</blockquote>\n<ul>\n<li>\n<p><font color='cyan'>意向共享锁 (IS)</font>: 由语句 <code>select ... lock in share mode</code>  添加。</p>\n<blockquote>\n<p>与表锁共享锁 (read) 兼容，与表锁排他锁 (write) 互斥。</p>\n</blockquote>\n</li>\n<li>\n<p><font color='cyan'>意向排他锁 (IX)</font>: 由 <code>insert</code> 、 <code>update</code> 、 <code>delete</code> 、 <code>select...for update</code>  添加。</p>\n<blockquote>\n<p>与表锁共享锁 (read) 及表锁排他锁 (write) 都互斥。</p>\n</blockquote>\n</li>\n</ul>\n<h6 id=\"演示\"><a class=\"anchor\" href=\"#演示\">#</a> 演示</h6>\n<p>可以通过以下 SQL，查看意向锁及行锁的加锁情况：</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">select</span> object_schema<span class=\"token punctuation\">,</span>object_name<span class=\"token punctuation\">,</span>index_name<span class=\"token punctuation\">,</span>lock_type<span class=\"token punctuation\">,</span>lock_mode<span class=\"token punctuation\">,</span>lock_data <span class=\"token keyword\">from</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>performance_schema<span class=\"token punctuation\">.</span>data_locks<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231119185250184.png\" alt=\"image-20231119185250184\" /></p>\n<center>意向共享锁与表锁共享锁(read)是兼容的</center>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231119185354166.png\" alt=\"image-20231119185354166\" /></p>\n<center>意向排他锁与表锁共享锁(read)、表锁排他锁(write)都是互斥的</center>\n<h4 id=\"行级锁\"><a class=\"anchor\" href=\"#行级锁\">#</a> 行级锁</h4>\n<h5 id=\"介绍-5\"><a class=\"anchor\" href=\"#介绍-5\">#</a> 介绍</h5>\n<p>行级锁，每次操作<font color='red'>锁住对应的行数据</font>。锁定粒度最小，<font color='red'>发生锁冲突的概率最低，并发度最高</font>。</p>\n<p><strong><font color='#B32015'>只有 InnoDB 存储引擎支持行级锁</font></strong>。InnoDB 的数据是基于索引组织的，<strong><font color='red'>行锁是通过对索引上的索引项加锁来实现的，而不是对记录加的锁</font></strong>。</p>\n<p>对于行级锁，主要分为以下三类：</p>\n<ul>\n<li>\n<p><font color='cornflowerblue'>行锁（Record Lock）</font>：也称记录锁，<font color='red'>锁定单个行记录</font>，防止其他事务对此行进行 <code>update</code>  和 <code>delete</code> 。</p>\n<blockquote>\n<p>在 RC、RR 隔离级别下都支持。</p>\n<p><strong>与表级锁类似，行锁也分为<font color='cyan'>共享锁（S 锁 / 读锁）</font>和<font color='cyan'>排他锁（X 锁 / 写锁）</font></strong></p>\n</blockquote>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231119190445520.png\" alt=\"image-20231119190445520\" /></p>\n<ul>\n<li>\n<p><font color='cyan'>行锁共享锁（S）</font>：允许一个事务去读一行，阻止其他事务获得相同数据集的排它锁。</p>\n</li>\n<li>\n<p><font color='cyan'>行锁排他锁（X）</font>：允许获取排他锁的事务更新数据，阻止其他事务获得相同数据集的共享锁和排他锁。</p>\n<blockquote>\n<p>两种行锁的兼容情况如下：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231119192050128.png\" alt=\"image-20231119192050128\" /></p>\n<p>对于常见的 SQL 语句，在执行时，所加的行锁如下：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231119192231878.png\" alt=\"image-20231119192231878\" /></p>\n</blockquote>\n</li>\n</ul>\n</li>\n<li>\n<p><font color='cornflowerblue'>间隙锁（Gap Lock）</font>：<font color='red'>锁定索引记录的间隙（不含记录）</font>，确保索引记录间隙不变，<strong><font color='#B32015'>防止其他事务在这个间隙进行 <code>insert</code> ，产生幻读</font></strong>。</p>\n<blockquote>\n<p>在 RR 隔离级别下支持。</p>\n</blockquote>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231119191003502.png\" alt=\"image-20231119191003502\" /></p>\n</li>\n<li>\n<p><font color='cornflowerblue'>临键锁（Next-Key Lock）</font>：<font color='red'>行锁和间隙锁组合，锁住记录的同时也锁住数据前面的所有间隙</font>。</p>\n<blockquote>\n<p>在 RR 隔离级别下支持。还记得在 MySQL 事务的隔离级别中提到的下表吗？当时之所以说<strong> InnoDB 引擎中的 RR 隔离级别可以避免幻读现象</strong>，就是因为 InnoDB 引擎支持行级锁中的临键锁（next-key）！</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231119190721496.png\" alt=\"image-20231119190721496\" /></p>\n</blockquote>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231119191537038.png\" alt=\"image-20231119191537038\" /></p>\n</li>\n</ul>\n<h5 id=\"行锁演示\"><a class=\"anchor\" href=\"#行锁演示\">#</a> 行锁演示</h5>\n<ul>\n<li>针对唯一索引进行检索时，对已存在的记录进行等值匹配时，将会自动将临键锁（next-key）<font color='red'>优化为行锁</font>。</li>\n<li>InnoDB 的行锁是针对于索引加的锁，不通过索引条件检索数据，那么 InnoDB 将对表中的所有记录加锁，此时就会<font color='red'>升级为表锁</font>。</li>\n</ul>\n<hr />\n<p>可以通过以下 SQL，查看意向锁及行锁的加锁情况：</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">select</span> object_schema<span class=\"token punctuation\">,</span>object_name<span class=\"token punctuation\">,</span>index_name<span class=\"token punctuation\">,</span>lock_type<span class=\"token punctuation\">,</span>lock_mode<span class=\"token punctuation\">,</span>lock_data <span class=\"token keyword\">from</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>performance_schema<span class=\"token punctuation\">.</span>data_locks<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231119193115917.png\" alt=\"image-20231119193115917\" /></p>\n<center>普通的select语句，执行时，不会加锁。</center>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231119193133442.png\" alt=\"image-20231119193133442\" /></p>\n<center>select...lock in share mode，加共享锁，共享锁与共享锁之间兼容。</center>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231119193207569.png\" alt=\"image-20231119193207569\" /></p>\n<center>共享锁与排他锁之间互斥。</center>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231119193242470.png\" alt=\"image-20231119193242470\" /></p>\n<center>排他锁之间互斥</center>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231119193535207.png\" alt=\"image-20231119193535207\" /></p>\n<center>根据name字段进行更新时，由于name字段是没有索引的，此时行锁会升级为表锁（因为行锁是对索引项加的锁）</center>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231119193708274.png\" alt=\"image-20231119193708274\" /></p>\n<center><font color='red'>对name字段创建索引，再对其进行更新，可以避免行锁升级为表锁</font></center>\n<h5 id=\"间隙锁临键锁演示\"><a class=\"anchor\" href=\"#间隙锁临键锁演示\">#</a> 间隙锁 &amp; 临键锁演示</h5>\n<p>默认情况下，InnoDB 的事务隔离级别为 <font color='red'>REPEATABLE-READ（可重复读）</font>，InnoDB 使用 <font color='cornflowerblue'>临键锁（next-key）</font>进行搜索和索引扫描，以防出现幻读。</p>\n<ul>\n<li>\n<p>索引上的等值查询（唯一索引），给不存在的记录加锁时，优化为间隙锁</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231119195154766.png\" alt=\"image-20231119195154766\" /></p>\n</li>\n<li>\n<p>索引上的等值查询（非唯一的普通索引），向右遍历时最后一个值不满足查询需求时，临键锁（next-key）退化为间隙锁</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231119195335874.png\" alt=\"image-20231119195335874\" /></p>\n</li>\n<li>\n<p>索引上的范围查询 (唯一索引)-- 会访问到不满足条件的第一个值为止</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231119195724781.png\" alt=\"image-20231119195724781\" /></p>\n</li>\n</ul>\n<blockquote>\n<p><strong>间隙锁唯一目的是防止其他事务插入间隙</strong>。</p>\n<p><strong>间隙锁可以共存</strong>，一个事务采用的间隙锁不会阻止另一个事务在同一间隙上采用间隙锁。</p>\n</blockquote>\n<h4 id=\"总结-3\"><a class=\"anchor\" href=\"#总结-3\">#</a> 总结</h4>\n<img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231119200231781.png\" alt=\"image-20231119200231781\" style=\"zoom: 67%;\" />\n<h4 id=\"面试题-2\"><a class=\"anchor\" href=\"#面试题-2\">#</a> 面试题</h4>\n<p>锁是一种常见的并发事务的控制方式。</p>\n<h5 id=\"表级锁和行级锁了解吗有什么区别\"><a class=\"anchor\" href=\"#表级锁和行级锁了解吗有什么区别\">#</a> 表级锁和行级锁了解吗？有什么区别？</h5>\n<p><font color='red'>MyISAM 仅仅支持表级锁</font>，在并发写的情况下性能非常差。<strong><font color='red'>InnoDB 不仅支持表级锁，还支持行级锁</font></strong>，默认为行级锁。</p>\n<p>行级锁的粒度更小，仅对相关的记录上锁即可（一行或者多行记录），所以对于并发写操作来说，InnoDB 的性能更高。</p>\n<ul>\n<li>\n<p><strong>表级锁：</strong></p>\n<ul>\n<li>是 **<font color='red'>针对非索引字段</font>** 加的锁，对当前操作的整张表加锁</li>\n<li>优点：<font color='red'>加锁快，资源消耗也比较少，不会出现死锁</font>。</li>\n<li>缺点：<font color='red'>触发锁冲突的概率最高，高并发下效率极低</font>。</li>\n<li><font color='red'>MyISAM 和 InnoDB 引擎都支持表级锁</font>。</li>\n</ul>\n</li>\n<li>\n<p><strong>行级锁：</strong></p>\n<ul>\n<li>MySQL 中锁定粒度最小的一种锁，是 **<font color='#B32015'>针对索引字段</font>** 加的锁，只针对当前操作的行记录进行加锁。</li>\n<li>优点：<font color='red'>能大大减少数据库操作的锁冲突</font>。其加锁粒度最小，<font color='red'>并发度高</font>。</li>\n<li>缺点：<font color='red'>加锁慢，加锁的开销大，会出现死锁</font>。</li>\n<li><font color='red'>行级锁和存储引擎有关，仅有 InnoDB 引擎支持行级锁</font>。</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"行级锁的使用有什么注意事项\"><a class=\"anchor\" href=\"#行级锁的使用有什么注意事项\">#</a> 行级锁的使用有什么注意事项？</h5>\n<p>InnoDB 的行锁是针对索引字段加的锁，表级锁是针对非索引字段加的锁。</p>\n<p><strong><font color='#B32015'>行级锁退化成表级锁</font></strong>：<font color='red'>当我们执行  <code>UPDATE</code> 、 <code>DELETE</code>  语句时，如果  <code>WHERE</code>  条件中字段没有命中唯一索引或者索引失效的话，就会导致扫描全表对表中的所有行记录进行加锁</font>。这个在我们日常工作开发中经常会遇到，一定要多多注意！！！</p>\n<p>不过，很多时候<font color='red'>即使用了索引也有可能会走全表扫描，这是因为 MySQL 优化器的原因，它认为全表扫描的效率比使用索引更高</font>。</p>\n<h5 id=\"innodb-有哪几类行级锁\"><a class=\"anchor\" href=\"#innodb-有哪几类行级锁\">#</a> InnoDB 有哪几类行级锁？</h5>\n<p>InnoDB 行级锁是通过对索引数据页上的<font color='red'>索引项</font>加锁实现的，MySQL InnoDB 支持三种行锁定方式：</p>\n<ul>\n<li><strong><font color='#B32015'>记录锁（Record Lock）</font></strong>：也被称为行锁，锁的是已经存在的单个行记录。</li>\n<li><strong><font color='#B32015'>间隙锁（Gap Lock）</font></strong>：锁定一个范围，不包括记录本身。<font color='red'>为了避免插入新记录</font>，需要依赖间隙锁。</li>\n<li><strong><font color='#B32015'>临键锁（Next-Key Lock）</font></strong>：可以理解为<font color='red'>行锁 + 间隙锁</font> 的组合，锁定一个行记录，及其之前的所有间隙范围。主要目的是 **<font color='red'>为了解决幻读问题</font>**（MySQL 事务部分提到过）。</li>\n</ul>\n<p><strong>在 InnoDB 默认的隔离级别 REPEATABLE-READ（可重复读）下，行级锁默认使用的是<u>临键锁（Next-Key）</u>。</strong></p>\n<blockquote>\n<p>但是，如果操作的索引是唯一索引或主键，InnoDB 会将临键锁（Next-Key）降级为<u>记录锁（Record Lock）</u>，即仅锁住索引本身，而不是范围。</p>\n</blockquote>\n<h5 id=\"共享锁和排他锁呢\"><a class=\"anchor\" href=\"#共享锁和排他锁呢\">#</a> 共享锁和排他锁呢？</h5>\n<p><font color='red'>不论是表级锁还是行级锁</font>，都存在共享锁（Share Lock，S 锁）和排他锁（eXclusive Lock，X 锁）这两类：</p>\n<ul>\n<li><strong>共享锁（S 锁）</strong>：又称<font color='red'>读锁</font>，事务在读取记录的时候获取共享锁，允许多个事务同时获取（锁兼容）。</li>\n<li><strong>排他锁（X 锁）</strong>：又称<font color='red'>写锁 / 独占锁</font>，事务在修改记录的时候获取排他锁，不允许多个事务同时获取。如果一个记录已经被加了排他锁，那其他事务不能再对这条事务加任何类型的锁（锁不兼容）。</li>\n</ul>\n<p><font color='red'>排他锁与任何的锁都不兼容，共享锁仅和共享锁兼容</font>。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"></th>\n<th style=\"text-align:left\">S 锁</th>\n<th style=\"text-align:left\">X 锁</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">S 锁</td>\n<td style=\"text-align:left\"><font color='red'>不冲突</font></td>\n<td style=\"text-align:left\">冲突</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">X 锁</td>\n<td style=\"text-align:left\">冲突</td>\n<td style=\"text-align:left\">冲突</td>\n</tr>\n</tbody>\n</table>\n<p><font color='red'>由于 MVCC（多版本并发控制）的存在，对于一般的  <code>SELECT</code>  语句，InnoDB 不会加任何锁</font>。不过，可以通过以下语句<font color='red'>显式地加共享锁或排他锁</font>：</p>\n<ul>\n<li>共享锁（MySQL 5.7 和 MySQL 8.0）： <code>SELECT ... LOCK IN SHARE MODE;</code></li>\n<li>共享锁（MySQL 8.0）： <code>SELECT ... FOR SHARE;</code></li>\n<li>排他锁： <code>SELECT ... FOR UPDATE;</code></li>\n</ul>\n<h5 id=\"意向锁有什么作用\"><a class=\"anchor\" href=\"#意向锁有什么作用\">#</a> 意向锁有什么作用？</h5>\n<p>意向锁是一种表级锁，<strong><font color='red'>作用是快速判断是否可以对某个表使用表锁，而不用逐行检查是否有行级锁</font></strong>。</p>\n<blockquote>\n<p><font color='red'>意向锁之间不会互斥。并且一旦事务提交了，意向锁就自动释放了</font>。</p>\n</blockquote>\n<ul>\n<li>\n<p><font color='cyan'>意向共享锁 (IS 锁)</font>: 事务有意向对表中的某些记录加共享锁（S 锁），加共享锁前必须先取得该表的 IS 锁。由语句 <code>select ... lock in share mode</code>  添加。</p>\n<blockquote>\n<p>与表锁共享锁 (read) 兼容，与表锁排他锁 (write) 互斥。</p>\n</blockquote>\n</li>\n<li>\n<p><font color='cyan'>意向排他锁 (IX 锁)</font>: 事务有意向对表中的某些记录加排他锁（X 锁），加排他锁之前必须先取得该表的 IX 锁。由 <code>insert</code> 、 <code>update</code> 、 <code>delete</code> 、 <code>select...for update</code>  添加。</p>\n<blockquote>\n<p>与表锁共享锁 (read) 及表锁排他锁 (write) 都互斥。</p>\n</blockquote>\n</li>\n</ul>\n<p><strong>意向锁是由存储引擎自己维护的，用户无法手动操作意向锁。<font color='red'>在为数据行加共享锁 / 排他锁之前，InooDB 会先获取该数据行所在数据表的对应意向锁</font>。</strong></p>\n<p><font color='red'>意向锁之间是互相兼容的</font>。</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>IS 锁</th>\n<th>IX 锁</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>IS 锁</td>\n<td>兼容</td>\n<td>兼容</td>\n</tr>\n<tr>\n<td>IX 锁</td>\n<td>兼容</td>\n<td>兼容</td>\n</tr>\n</tbody>\n</table>\n<p><font color='red'>意向锁与表级别的共享锁和排它锁的互斥情况如下：</font></p>\n<blockquote>\n<p>意向锁不会与行级别的共享锁和排他锁互斥</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>IS 锁</th>\n<th>IX 锁</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>S 锁</td>\n<td><font color='red'>兼容</font></td>\n<td>互斥</td>\n</tr>\n<tr>\n<td>X 锁</td>\n<td>互斥</td>\n<td>互斥</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"快照读和当前读有什么区别\"><a class=\"anchor\" href=\"#快照读和当前读有什么区别\">#</a> 快照读和当前读有什么区别？</h5>\n<p><strong><font color='#B32015'>快照读</font></strong>（<font color='red'>一致性<u>非锁定读</u></font>）就是<font color='red'>简单的  <code>SELECT</code>  语句</font>。</p>\n<p><font color='red'>快照即记录的历史版本</font>，每行记录可能存在多个历史版本（多版本技术）。</p>\n<p>快照读的情况下，如果读取的记录正在执行 UPDATE/DELETE 操作，<font color='red'>读取操作不会因此去等待记录上 X 锁的释放，而是会去读取行的一个快照</font>。</p>\n<p>只有在事务隔离级别 RC (读取已提交) 和 RR（可重读）下，InnoDB 才会使用快照读（一致性非锁定读）：</p>\n<ul>\n<li><font color='gree'>在 RC 级别下</font>，对于快照数据，一致性非锁定读总是<font color='red'>读取被锁定行的最新一份快照数据</font>。</li>\n<li><font color='gree'>在 RR 级别下</font>，对于快照数据，一致性非锁定读总是 **<font color='red'>读取本事务开始时的行数据版本</font>**。</li>\n</ul>\n<p>快照读比较<font color='red'>适合对数据一致性要求不是特别高，且追求极致性能的业务场景</font>。</p>\n<hr />\n<p><strong><font color='#B32015'>当前读</font></strong>（<font color='red'>一致性<u>锁定读</u></font>）就是<font color='red'>给行记录加 X 锁或 S 锁</font>。</p>\n<p>当前读的一些常见 SQL 语句类型如下：</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># 对读的记录加一个 X 锁</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">SELECT</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">FOR</span> <span class=\"token keyword\">UPDATE</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token comment\"># 对读的记录加一个 S 锁（MySQL 5.7 和 MySQL 8.0）</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">SELECT</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">LOCK</span> <span class=\"token operator\">IN</span> <span class=\"token keyword\">SHARE</span> <span class=\"token keyword\">MODE</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token comment\"># 对读的记录加一个 S 锁（MySQL 8.0）</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token keyword\">SELECT</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">FOR</span> <span class=\"token keyword\">SHARE</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token comment\"># 对修改的记录加一个 X 锁</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token keyword\">INSERT</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token keyword\">UPDATE</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token keyword\">DELETE</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr></table></figure><h3 id=\"mysql性能优化\"><a class=\"anchor\" href=\"#mysql性能优化\">#</a> MySQL 性能优化</h3>\n<h4 id=\"能用-mysql-直接存储文件比如图片吗\"><a class=\"anchor\" href=\"#能用-mysql-直接存储文件比如图片吗\">#</a> 能用 MySQL 直接存储文件（比如图片）吗？</h4>\n<p>虽然可以直接将文件对应的二进制数据存储到 MySQL 中，不过还是建议不要在数据库中存储文件。因为会<font color='red'>严重影响数据库性能，消耗过多存储空间</font>。</p>\n<p>可以选择使用云服务厂商提供的开箱即用的 **<font color='#B32015'>文件存储服务</font>**，成熟稳定，价格也比较低。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/oss-search.png\" alt=\"img\" /></p>\n<p>也可以选择<font color='red'>自建文件存储服务</font>，实现起来也不难，基于 FastDFS、MinIO（推荐） 等开源项目就可以实现分布式文件服务。</p>\n<p><strong><font color='#B32015'>数据库只存储文件地址信息，文件本身由文件存储服务负责存储。</font></strong></p>\n<p>相关阅读：<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuNTFjdG8uY29tL2FydGljbGUvNzE2OTc4Lmh0bWw=\">Spring Boot 整合 MinIO 实现分布式文件服务</span> 。</p>\n<h4 id=\"mysql-如何存储-ip-地址\"><a class=\"anchor\" href=\"#mysql-如何存储-ip-地址\">#</a> MySQL 如何存储 IP 地址？</h4>\n<p>可以将 IP 地址 **<font color='red'>转换成整形数据存储</font>**，性能更好，占用空间也更小。</p>\n<p>MySQL 提供了两个（互逆的）方法来处理 ip 地址：</p>\n<ul>\n<li><code>INET_ATON()</code> ：把 ip 转为无符号整型（4-8 位）</li>\n<li><code>INET_NTOA()</code> ：把整型的 ip 转为地址</li>\n</ul>\n<p>插入数据前，先用  <code>INET_ATON()</code>  把 ip 地址转为整型。显示数据时，使用  <code>INET_NTOA()</code>  把整型的 ip 地址转为地址显示即可。</p>\n<h4 id=\"常见的-sql-优化手段\"><a class=\"anchor\" href=\"#常见的-sql-优化手段\">#</a> 常见的 SQL 优化手段</h4>\n<blockquote>\n<p>指路→<a href=\"#==SQL%E4%BC%98%E5%8C%96==\">SQL 优化</a></p>\n</blockquote>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/javamianshizhibei-sql-optimization.png\" alt=\"常见的 SQL 优化手段\" /></p>\n<h4 id=\"如何分析-sql-的性能\"><a class=\"anchor\" href=\"#如何分析-sql-的性能\">#</a> 如何分析 SQL 的性能？</h4>\n<p>可以使用  <code>EXPLAIN</code>  命令来分析 SQL 的 <strong><font color='#B32015'>执行计划</font></strong> 。执行计划是指一条 SQL 语句在经过 MySQL 查询优化器的优化后的具体的执行方式。</p>\n<p><code>EXPLAIN</code>  并不会真的去执行相关的语句，而是通过 <strong><font color='#B32015'>查询优化器</font></strong> 对语句进行分析，找出最优的查询方案，并显示对应的信息。</p>\n<blockquote>\n<p>指路→[利用 EXPLAIN 命令分析 SQL 是否走索引查询](# 利用 EXPLAIN 命令分析 SQL 是否走索引查询)</p>\n</blockquote>\n<h4 id=\"读写分离-分库分表\"><a class=\"anchor\" href=\"#读写分离-分库分表\">#</a> <mark>🌟读写分离、分库分表</mark></h4>\n<h5 id=\"读写分离\"><a class=\"anchor\" href=\"#读写分离\">#</a> 读写分离</h5>\n<blockquote>\n<p>解决的问题：<font color='red'>数据库读并发</font></p>\n</blockquote>\n<h6 id=\"什么是读写分离\"><a class=\"anchor\" href=\"#什么是读写分离\">#</a> 什么是读写分离？</h6>\n<p>见名思意，根据读写分离的名字，我们就可以知道：读写分离主要是为了 **<font color='#B32015'>将对数据库的读写操作分散到不同的数据库节点上。</font>** 这样的话，就能够<font color='red'>小幅提升写性能，大幅提升读性能</font>。</p>\n<p>我简单画了一张图来帮助不太清楚读写分离的小伙伴理解。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/read-and-write-separation.png\" alt=\"读写分离示意图\" /></p>\n<center>读写分离示意图</center>\n<p>一般情况下，我们都会选择 **<font color='#B32015'>一主多从</font>**，也就是<font color='red'>一台主数据库负责写，其他的从数据库负责读</font>。<font color='red'>主库和从库之间会进行数据实时同步（<strong>主从复制</strong>），以保证从库中数据的准确性</font>。这样的架构实现起来比较简单，并且也符合系统的<font color='red'>写少读多</font>的特点。</p>\n<h6 id=\"如何实现读写分离\"><a class=\"anchor\" href=\"#如何实现读写分离\">#</a> 如何实现读写分离？</h6>\n<p>不论是使用哪一种读写分离具体的实现方案，想要实现读写分离一般包含如下几步：</p>\n<ol>\n<li>部署多台数据库，选择其中的一台作为主数据库，其他的一台或者多台作为从数据库。</li>\n<li>保证主数据库和从数据库之间的数据是实时同步的（主从复制）。</li>\n<li>系统将写请求交给主数据库处理，读请求交给从数据库处理。</li>\n</ol>\n<p>落实到项目本身的话，常用的方式有两种：</p>\n<ol>\n<li>\n<p><strong><font color='cornflowerblue'>代理方式</font></strong></p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/read-and-write-separation-proxy.png\" alt=\"代理方式实现读写分离\" /></p>\n<center>代理方式实现读写分离</center>\n<p>我们可以在应用和数据中间加了一个 **<font color='red'>代理层</font>**。</p>\n<p>应用程序所有的数据请求都交给代理层处理，<font color='red'>代理层负责分离读写请求，将它们路由到对应的数据库中</font>。</p>\n<p>提供类似功能的中间件有 <strong>MySQL Router</strong>（官方）、<strong>Atlas</strong>（基于 MySQL Proxy）、<strong>MaxScale</strong>、<strong>MyCat</strong>。</p>\n</li>\n<li>\n<p><strong><font color='cornflowerblue'>第三方组件方式</font></strong></p>\n<blockquote>\n<p>推荐的方式</p>\n</blockquote>\n<p>在这种方式中，我们可以通过引入第三方组件来帮助我们读写请求。</p>\n<p>这也是我比较<font color='red'>推荐的一种方式</font>。这种方式目前在各种互联网公司中用的最多的，相关的实际的案例也非常多。</p>\n<p>如果你要采用这种方式的话，推荐使用  <code>sharding-jdbc</code>  ，直接引入 jar 包即可使用，非常方便。同时，也节省了很多运维的成本。</p>\n<blockquote>\n<p>你可以在 shardingsphere 官方找到 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9zaGFyZGluZ3NwaGVyZS5hcGFjaGUub3JnL2RvY3VtZW50L2xlZ2FjeS8zLngvZG9jdW1lbnQvY24vbWFudWFsL3NoYXJkaW5nLWpkYmMvdXNhZ2UvcmVhZC13cml0ZS1zcGxpdHRpbmcv\">sharding-jdbc 关于读写分离的操作</span>。</p>\n</blockquote>\n</li>\n</ol>\n<h6 id=\"主从复制的原理\"><a class=\"anchor\" href=\"#主从复制的原理\">#</a> <mark>🌟主从复制的原理</mark></h6>\n<p><font color='red'>MySQL  <code>binlog</code> （二进制日志文件）主要记录了 MySQL 数据库中数据的所有变化（数据库执行的所有 DDL 和 DML 语句）</font>。</p>\n<p>binlog 主要有两个作用：</p>\n<ol>\n<li><strong><font color='#B32015'>主从复制</font></strong></li>\n<li><strong><font color='#B32015'>数据恢复</font></strong></li>\n</ol>\n<p>因此，<strong><font color='red'>可以根据主库的 MySQL binlog 日志就能够将主库的数据同步复制到从库中</font></strong>。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231129103209731.png\" alt=\"image-20231129103209731\" /></p>\n<center>MySQL主从复制</center>\n<ol>\n<li>\n<p>master 将数据库中数据的变化写入到  <code>binlog</code>  中</p>\n</li>\n<li>\n<p>slave 连接 master</p>\n</li>\n<li>\n<p>slave 会创建一个  <code>I/O 线程</code>  向 master 请求更新的 binlog</p>\n</li>\n<li>\n<p>master 会创建一个  <code>binlog dump 线程</code>  来发送 binlog，由 slave 中的 I/O 线程负责接收</p>\n</li>\n<li>\n<p>slave 的 I/O 线程将接收的 binlog 写入到  <code>relay log</code> （中继日志）中</p>\n</li>\n<li>\n<p>slave 的  <code>SQL 线程</code>  读取 relay log 同步数据本地（也就是再执行一遍 SQL ）</p>\n</li>\n</ol>\n<blockquote>\n<p>扩展：阿里开源的一个叫做 canal 的工具可以帮助我们同步 MySQL 数据到其他数据源（例如 Elasticsearch/MySQL）。其原理就是模拟 MySQL 主从复制的过程，解析 binlog 将数据同步到其他的数据源。</p>\n<p>另外，像咱们常用的分布式缓存组件 Redis 也是通过主从复制实现的读写分离。</p>\n</blockquote>\n<p>小结一下：</p>\n<p><strong><font color='#B32015'>MySQL 主从复制依赖于 binlog。另外，常见的一些同步 MySQL 数据到其他数据源的工具（比如 canal）的底层一般也是依赖 binlog 。</font></strong></p>\n<h6 id=\"如何避免主从同步延迟\"><a class=\"anchor\" href=\"#如何避免主从同步延迟\">#</a> 如何避免主从同步延迟？</h6>\n<p>读写分离对于提升数据库的并发非常有效，但也同时引来一个问题：主库和从库的数据存在延迟，比如你写完主库之后，主库的数据同步到从库是需要时间的，这个时间差就导致了主库和从库的数据不一致性问题。这也就是我们经常说的 **<font color='#B32015'>主从同步延迟</font>** 。</p>\n<p>如果我们的业务场景无法容忍主从同步延迟的话，应该<u>如何避免</u>呢？</p>\n<p>这里提供两种方案：</p>\n<p>（1）<strong><font color='cornflowerblue'>强制将读请求路由到 master 处理</font></strong></p>\n<blockquote>\n<p>使用最多的一种方式</p>\n</blockquote>\n<p>既然 slave 的数据过期了，那就直接从 master 读取呗！这种方案虽然会增加 master 的压力，但是实现起来比较简单，也是我了解到的 **<font color='red'>使用最多的一种方式</font>**。</p>\n<p>比如  <code>Sharding-JDBC</code>  就是采用的这种方案。通过使用 Sharding-JDBC 的  <code>HintManager</code>  分片键值管理器，我们可以强制使用 master。</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token class-name\">HintManager</span> hintManager <span class=\"token operator\">=</span> <span class=\"token class-name\">HintManager</span><span class=\"token punctuation\">.</span><span class=\"token function\">getInstance</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>hintManager<span class=\"token punctuation\">.</span><span class=\"token function\">setMasterRouteOnly</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token comment\">// 继续 JDBC 操作</span></pre></td></tr></table></figure><p>对于这种方案，<font color='red'>可以将那些必须获取最新数据的读请求都交给 master 处理</font>。</p>\n<p>（2）<font color='cornflowerblue'>延迟读取</font></p>\n<blockquote>\n<p>没办法完全避免主从延迟，只能说可以减少出现延迟的概率而已，实际项目中一般不会使用</p>\n</blockquote>\n<p>还有一些朋友肯定会想既然主从同步存在延迟，那我就在延迟之后读取啊，比如主从同步延迟 0.5s, 那我就 1s 之后再读取数据。这样多方便啊！<strong><font color='red'>方便是方便，但是也很扯淡</font></strong>。</p>\n<p>不过，如果你是这样设计业务流程就会好很多：对于一些对数据比较敏感的场景，<font color='red'>可以在完成写请求之后，避免立即进行请求操作</font>。比如你支付成功之后，跳转到一个支付成功的页面，当你点击返回之后才返回自己的账户。</p>\n<h6 id=\"主从同步延迟的原因如何尽量减少延迟\"><a class=\"anchor\" href=\"#主从同步延迟的原因如何尽量减少延迟\">#</a> 主从同步延迟的原因？如何尽量减少延迟？</h6>\n<p>MySQL 主从同步延迟指的是<font color='red'>从库的数据落后于主库的数据</font>。这种情况可能有以下<font color='gree'>2 个原因</font>：</p>\n<ol>\n<li>从库 I/O 线程接收 binlog 的速度跟不上主库写入 binlog 的速度，导致从库 relay log 的数据滞后于主库 binlog 的数据；</li>\n<li>从库 SQL 线程执行 relay log 的速度跟不上从库 I/O 线程接收 binlog 的速度，导致从库的数据滞后于从库 relay log 的数据。</li>\n</ol>\n<p>与主从同步有关的<font color='gree'>3 个时间点</font>：</p>\n<ol>\n<li>主库执行完一个事务，写入 binlog，将这个时刻记为 T1；</li>\n<li>从库 I/O 线程接收到 binlog 并写入 relay log 的时刻记为 T2；</li>\n<li>从库 SQL 线程读取 relay log 同步数据本地的时刻记为 T3。</li>\n</ol>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231129113009937.png\" alt=\"image-20231129113009937\" /></p>\n<p>结合我们上面讲到的主从复制原理，可以得出<font color='gree'>2 个结论</font>：</p>\n<ul>\n<li>T2 和 T1 的差值反映了<font color='red'>从库 I/O 线程的性能和网络传输的效率</font>，这个差值越小说明从库 I/O 线程的性能和网络传输效率越高。</li>\n<li>T3 和 T2 的差值反映了<font color='red'>从库 SQL 线程执行的速度</font>，这个差值越小，说明从库 SQL 线程执行速度越快。</li>\n</ul>\n<p>这里列举主从同步延迟的<font color='gree'>几种常见情况</font>：</p>\n<ol>\n<li><strong>从库机器性能比主库差</strong>：从库接收 binlog 并写入 relay log 以及执行 SQL 语句的速度会比较慢（也就是 T2-T1 和 T3-T2 的值会较大），进而导致延迟。解决方法是<font color='red'>选择与主库一样规格或更高规格的机器作为从库，或者对从库进行性能优化</font>，比如调整参数、增加缓存、使用 SSD 等。</li>\n<li><strong>从库处理的读请求过多</strong>：从库需要执行主库的所有写操作，同时还要响应读请求，如果读请求过多，会占用从库的 CPU、内存、网络等资源，影响从库的复制效率（也就是 T2-T1 和 T3-T2 的值会较大，和前一种情况类似）。解决方法是<font color='red'>引入缓存（推荐）、使用一主多从的架构，将读请求分散到不同的从库，或者使用其他系统来提供查询的能力</font>，比如将 binlog 接入到 Hadoop、Elasticsearch 等系统中。</li>\n<li><strong>大事务</strong>：<font color='red'>运行时间比较长，长时间未提交的事务</font>就可以称为大事务。由于大事务执行时间长，并且从库上的大事务会比主库上的大事务花费更多的时间和资源，因此非常容易造成主从延迟。解决办法是<font color='red'>避免大批量修改数据，尽量分批进行</font>。类似的情况还有执行时间较长的慢 SQL，实际项目<font color='red'>遇到慢 SQL 应该进行优化</font>。</li>\n<li><strong>从库太多</strong>：主库需要将 binlog 同步到所有的从库，如果从库数量太多，会增加同步的时间和开销（也就是 T2-T1 的值会比较大，但这里是因为主库同步压力大导致的）。解决方案是<font color='red'>减少从库的数量，或者将从库分为不同的层级，让上层的从库再同步给下层的从库，减少主库的压力</font>。</li>\n<li><strong>网络延迟</strong>：如果主从之间的网络传输速度慢，或者出现丢包、抖动等问题，那么就会影响 binlog 的传输效率，导致从库延迟。解决方法是<font color='red'>优化网络环境</font>，比如提升带宽、降低延迟、增加稳定性等。</li>\n<li><strong>单线程复制</strong>：MySQL5.5 及之前，只支持单线程复制。为了优化复制性能，MySQL 5.6 引入了 <strong>多线程复制</strong>，MySQL 5.7 还进一步完善了多线程复制。</li>\n<li><strong>复制模式</strong>：<font color='red'>MySQL 默认的复制是异步的，必然会存在延迟问题</font>。全同步复制不存在延迟问题，但性能太差了。<font color='red'>半同步复制是一种折中方案，相对于异步复制，半同步复制提高了数据的安全性，减少了主从延迟（还是有一定程度的延迟）</font>。MySQL 5.5 开始，MySQL 以插件的形式支持 <strong>semi-sync 半同步复制</strong>。并且，MySQL 5.7 引入了 <strong>增强半同步复制</strong> 。</li>\n<li>……</li>\n</ol>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly90aW1lLmdlZWtiYW5nLm9yZy9jb2x1bW4vaW50cm8vMTAwMDIwODAxP2NvZGU9aWVZOEhlUlNsRHNGYnVSdGdnYkJRR3hkVGgtMWpNQVNxRUllcXpIQUtySSUzRA==\">《MySQL 实战 45 讲》</span>这个专栏中的<span class=\"exturl\" data-url=\"aHR0cHM6Ly90aW1lLmdlZWtiYW5nLm9yZy9jb2x1bW4vYXJ0aWNsZS83NzYzNg==\">读写分离有哪些坑？</span>这篇文章也有对主从延迟解决方案这一话题进行探讨，感兴趣的可以阅读学习一下。</p>\n<h5 id=\"分库分表\"><a class=\"anchor\" href=\"#分库分表\">#</a> 分库分表</h5>\n<blockquote>\n<p>解决的问题：<font color='red'>数据库存储</font></p>\n</blockquote>\n<p>读写分离主要应对的是数据库读并发，没有解决数据库存储问题。试想一下：** 如果 MySQL 一张表的数据量过大怎么办？** 换言之，<strong>我们该如何解决 MySQL 的存储压力呢？</strong></p>\n<p>答案之一就是 **<font color='#B32015'>分库分表</font>**。</p>\n<h6 id=\"分库\"><a class=\"anchor\" href=\"#分库\">#</a> 分库</h6>\n<p>分库就是<font color='red'>将数据库中的数据分散到不同的数据库上</font>，可以分为两种：</p>\n<ul>\n<li>\n<p><strong><font color='cornflowerblue'>垂直分库</font></strong></p>\n<p>就是把单一数据库 **<font color='red'>按照业务进行划分</font>**，不同的业务使用不同的数据库，进而将一个数据库的压力分担到多个数据库。</p>\n<p>举个例子：说你将数据库中的用户表、订单表和商品表分别单独拆分为用户数据库、订单数据库和商品数据库。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231129114419366.png\" alt=\"image-20231129114419366\" /></p>\n<center>垂直分库</center>\n</li>\n<li>\n<p><strong><font color='cornflowerblue'>水平分库</font></strong></p>\n<p>就是把同一个表 **<font color='red'>按一定规则拆分</font>** 到不同的数据库中，每个库可以位于不同的服务器上，这样就实现了水平扩展，解决了单表的存储和性能瓶颈的问题。</p>\n<p>举个例子：订单表数据量太大，你对订单表进行了水平切分（水平分表），然后将切分后的 2 张订单表分别放在两个不同的数据库。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/horizontal-slicing-database-53fbc43a.png\" alt=\"水平分库\" /></p>\n<center>水平分库</center>\n</li>\n</ul>\n<h6 id=\"分表\"><a class=\"anchor\" href=\"#分表\">#</a> 分表</h6>\n<p>分表就是<font color='red'>对单表的数据进行拆分</font>，也可以分为两种：</p>\n<ul>\n<li>\n<p><strong><font color='cornflowerblue'>垂直分表</font></strong></p>\n<p>是 **<font color='red'>对列的拆分</font>**，把一张列比较多的表拆分为多张表。</p>\n<p>举个例子：我们可以将用户信息表中的一些列单独抽出来作为一个表。</p>\n</li>\n<li>\n<p><strong><font color='cornflowerblue'>水平分表</font></strong></p>\n<p>是 **<font color='red'>对行的拆分</font>**，把一张行比较多的表拆分为多张表，可以解决单一表数据量过大的问题。</p>\n<p>举个例子：我们可以将用户信息表拆分成多个用户信息表。</p>\n<p>水平拆分只能解决单表数据量大的问题，为了提升性能，我们通常会选择将拆分后的多张表放在不同的数据库中。也就是说，<font color='red'>水平分表通常和水平分库同时出现</font>。</p>\n</li>\n</ul>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/two-forms-of-sub-table-3475ce44.png\" alt=\"分表\" /></p>\n<center>分表</center>\n<h6 id=\"什么情况下需要分库分表\"><a class=\"anchor\" href=\"#什么情况下需要分库分表\">#</a> 什么情况下需要分库分表？</h6>\n<p>遇到下面几种场景可以考虑分库分表：</p>\n<ul>\n<li>单表的数据达到千万级别以上，数据库读写速度比较缓慢</li>\n<li>数据库中的数据占用的空间越来越大，备份时间越来越长</li>\n<li>应用的并发量太大</li>\n</ul>\n<h6 id=\"常见的分片算法\"><a class=\"anchor\" href=\"#常见的分片算法\">#</a> 常见的分片算法</h6>\n<p>分片算法主要 **<font color='red'>解决了数据被水平分片之后，数据究竟该存放在哪个表的问题</font>**。</p>\n<ul>\n<li><strong><font color='cornflowerblue'>哈希分片</font></strong>：求指定 key（比如 id） 的哈希，然后根据哈希值确定数据应被放置在哪个表中。哈希分片比较<font color='red'>适合随机读写的场景，不太适合经常需要范围查询的场景</font>。</li>\n<li><strong><font color='cornflowerblue'>范围分片</font></strong>：按照特性的范围区间（比如时间区间、ID 区间）来分配数据，比如 将 id 为 1~299999 的记录分到第一个库， 300000~599999 的分到第二个库。范围分片<font color='red'>适合需要经常进行范围查找的场景，不太适合随机读写的场景（数据未被分散，容易出现热点数据的问题）</font>。</li>\n<li><strong><font color='cornflowerblue'>地理位置分片</font></strong>：很多 NewSQL 数据库都支持地理位置分片算法，也就是<font color='red'>根据地理位置（如城市、地域）来分配数据</font>。</li>\n<li><strong><font color='cornflowerblue'>融合算法</font></strong>：<font color='red'>灵活组合多种分片算法</font>，比如将哈希分片和范围分片组合。</li>\n<li>……</li>\n</ul>\n<h6 id=\"分库分表会带来什么问题\"><a class=\"anchor\" href=\"#分库分表会带来什么问题\">#</a> 分库分表会带来什么问题？</h6>\n<p>记住，你在公司做的任何技术决策，不光是要考虑这个技术能不能满足我们的要求，是否适合当前业务场景，还要重点考虑其带来的成本。</p>\n<p>引入分库分表之后，会给系统带来什么挑战呢？</p>\n<ul>\n<li><strong><font color='red'>join 操作</font></strong>：同一个数据库中的表分布在了不同的数据库中，导致无法使用 join 操作。这样就导致我们需要手动进行数据的封装，比如你在一个数据库中查询到一个数据之后，再根据这个数据去另外一个数据库中找对应的数据。不过，很多大厂的资深 DBA 都是建议<font color='red'>尽量不要使用 join 操作</font>。因为 join 的效率低，并且会对分库分表造成影响。对于需要用到 join 操作的地方，<font color='red'>可以采用多次查询业务层进行数据组装的方法</font>。不过，这种方法需要考虑业务上多次查询的事务性的容忍度。</li>\n<li><strong><font color='red'>事务问题</font></strong>：同一个数据库中的表分布在了不同的数据库中，如果单个操作涉及到多个数据库，那么数据库自带的事务就无法满足我们的要求了。这个时候，我们就<font color='red'>需要引入分布式事务</font>了。关于分布式事务常见解决方案总结，网站上也有对应的总结：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9qYXZhZ3VpZGUuY24vZGlzdHJpYnV0ZWQtc3lzdGVtL2Rpc3RyaWJ1dGVkLXRyYW5zYWN0aW9uLmh0bWw=\">https://javaguide.cn/distributed-system/distributed-transaction.html</span> 。</li>\n<li><strong><font color='red'>分布式 ID</font></strong>：分库之后，数据遍布在不同服务器上的数据库，数据库的<font color='red'>自增主键已经没办法满足生成的主键唯一了</font>。我们如何为不同的数据节点生成全局唯一主键呢？这个时候，我们就需要为我们的系统<font color='red'>引入分布式 ID </font>了。关于分布式 ID 的详细介绍 &amp; 实现方案总结，网站上也有对应的总结：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9qYXZhZ3VpZGUuY24vZGlzdHJpYnV0ZWQtc3lzdGVtL2Rpc3RyaWJ1dGVkLWlkLmh0bWw=\">https://javaguide.cn/distributed-system/distributed-id.html</span> 。</li>\n<li><strong><font color='red'>跨库聚合查询问题</font></strong>：分库分表会导致常规聚合查询操作，如 group by，order by 等变得异常复杂。这是因为这些操作需要在多个分片上进行数据汇总和排序，而不是在单个数据库上进行。为了实现这些操作，<font color='red'>需要编写复杂的业务代码，或者使用中间件来协调分片间的通信和数据传输</font>。这样会增加开发和维护的成本，以及影响查询的性能和可扩展性。</li>\n<li>……</li>\n</ul>\n<p>另外，<font color='red'>引入分库分表之后，一般需要 DBA 的参与，同时还需要更多的数据库服务器</font>，这些都属于成本。</p>\n<h6 id=\"分库分表有没有什么比较推荐的方案\"><a class=\"anchor\" href=\"#分库分表有没有什么比较推荐的方案\">#</a> 分库分表有没有什么比较推荐的方案？</h6>\n<p>Apache  <code>ShardingSphere</code>  是一款分布式的数据库生态系统，<strong><font color='red'>可以将任意数据库转换为分布式数据库，并通过数据分片、弹性伸缩、加密等能力对原有数据库进行增强</font></strong>。</p>\n<p>ShardingSphere 项目（包括 Sharding-JDBC、Sharding-Proxy 和 Sharding-Sidecar）是当当捐入 Apache 的，目前主要由京东数科的一些巨佬维护。</p>\n<p>**ShardingSphere 绝对可以说是当前分库分表的首选！**ShardingSphere 的功能完善，<font color='red'>除了支持读写分离和分库分表，还提供分布式事务、数据库治理、影子库、数据加密和脱敏等功能</font>。</p>\n<p>ShardingSphere 提供的功能如下：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/shardingsphere-features.png\" alt=\"ShardingSphere 提供的功能\" /></p>\n<p>ShardingSphere 的优势如下：</p>\n<ul>\n<li>极致性能：驱动程序端历经长年打磨，效率接近原生 JDBC，性能极致。</li>\n<li>生态兼容：代理端支持任何通过 MySQL/PostgreSQL 协议的应用访问，驱动程序端可对接任意实现 JDBC 规范的数据库。</li>\n<li>业务零侵入：面对数据库替换场景，ShardingSphere 可满足业务无需改造，实现平滑业务迁移。</li>\n<li>运维低成本：在保留原技术栈不变前提下，对 DBA 学习、管理成本低，交互友好。</li>\n<li>安全稳定：基于成熟数据库底座之上提供增量能力，兼顾安全性及稳定性。</li>\n<li>弹性扩展：具备计算、存储平滑在线扩展能力，可满足业务多变的需求。</li>\n<li>开放生态：通过多层次（内核、功能、生态）插件化能力，为用户提供可定制满足自身特殊需求的独有系统。</li>\n</ul>\n<p>另外，ShardingSphere 的生态体系完善，社区活跃，文档完善，更新和发布比较频繁。</p>\n<p>艿艿之前写了一篇分库分表的实战文章，各位朋友可以看看：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvQTJNWU9GVDdTUC03a0dPb244cUphdw==\">《芋道 Spring Boot 分库分表入门》</span> 。</p>\n<h6 id=\"分库分表后数据怎么迁移呢\"><a class=\"anchor\" href=\"#分库分表后数据怎么迁移呢\">#</a> 分库分表后，数据怎么迁移呢？</h6>\n<p>分库分表之后，我们<font color='red'>如何将老库（单库单表）的数据迁移到新库（分库分表后的数据库系统）呢？</font></p>\n<p>比较简单同时也是<font color='red'>非常常用</font>的方案就是 **<font color='cornflowerblue'>停机迁移</font>**，写个脚本将老库的数据写到新库中。比如你在凌晨 2 点，系统使用的人数非常少的时候，挂一个公告说系统要维护升级预计 1 小时。然后，你写一个脚本将老库的数据都同步到新库中。</p>\n<p>如果你<font color='red'>不想停机迁移数据的话</font>，也可以考虑 **<font color='cornflowerblue'>双写方案</font>**。双写方案是针对那种不能停机迁移的场景，实现起来要稍微麻烦一些。具体原理是这样的：</p>\n<ul>\n<li>我们<font color='red'>对老库的更新操作（增删改），同时也要写入新库（双写）</font>。如果操作的数据不存在于新库的话，需要插入到新库中。这样就能保证，咱们新库里的数据是最新的。</li>\n<li>在迁移过程，双写只会让被更新操作过的老库中的数据同步到新库，我们<font color='red'>还需要自己写脚本将老库中的数据和新库的数据做比对</font>。如果新库中没有，那咱们就把数据插入到新库。如果新库有，旧库没有，就把新库对应的数据删除（冗余数据清理）。</li>\n<li>重复上一步的操作，<font color='red'>直到老库和新库的数据一致为止</font>。</li>\n</ul>\n<p>想要在项目中实施双写还是比较麻烦的，很容易会出现问题。我们<font color='red'>可以借助上面提到的数据库同步工具 Canal 做增量数据迁移</font>（还是依赖 binlog，开发和维护成本较低）。</p>\n<h5 id=\"总结-4\"><a class=\"anchor\" href=\"#总结-4\">#</a> 总结</h5>\n<ul>\n<li>\n<p><font color='red'>读写分离主要是为了将对数据库的读写操作分散到不同的数据库节点上</font>。这样的话，就能够小幅提升写性能，大幅提升读性能。</p>\n</li>\n<li>\n<p><font color='red'>读写分离基于主从复制，而 MySQL 主从复制依赖于  <code>binlog</code> </font>。</p>\n</li>\n<li>\n<p>分库就是将数据库中的数据分散到不同的数据库上。分表就是对单表的数据进行拆分，可以是垂直拆分，也可以是水平拆分。</p>\n</li>\n<li>\n<p>引入分库分表之后，需要系统解决事务、分布式 id、无法 join 操作问题。</p>\n</li>\n<li>\n<p><font color='red'>ShardingSphere 绝对可以说是当前分库分表的首选</font>！ShardingSphere 的功能完善，除了支持读写分离和分库分表，还提供分布式事务、数据库治理等功能。另外，ShardingSphere 的生态体系完善，社区活跃，文档完善，更新和发布比较频繁。</p>\n</li>\n</ul>\n<h2 id=\"mysql-高性能优化规范建议\"><a class=\"anchor\" href=\"#mysql-高性能优化规范建议\">#</a> MySQL 高性能优化规范建议</h2>\n<h3 id=\"命名规范\"><a class=\"anchor\" href=\"#命名规范\">#</a> 命名规范</h3>\n<ul>\n<li>\n<p>所有数据库对象名称必须使用<font color='red'>小写字母</font>并用<font color='red'>下划线分割</font></p>\n</li>\n<li>\n<p>所有数据库对象名称<font color='red'>禁止使用 MySQL 保留关键字</font>（如果表名中包含关键字查询时，需要将其用单引号括起来）</p>\n</li>\n<li>\n<p>数据库对象的命名要能做到<font color='red'>见名识意，并且最后不要超过 32 个字符</font></p>\n</li>\n<li>\n<p><font color='red'>临时库表必须以  <code>tmp_</code>  为前缀并以日期为后缀</font>，<font color='red'>备份表必须以  <code>bak_</code>  为前缀并以日期 (时间戳) 为后缀</font></p>\n</li>\n<li>\n<p>所有存储相同数据的列名和列类型必须一致（一般作为关联列，<font color='red'>如果查询时关联列类型不一致会自动进行数据类型隐式转换，造成列上的索引失效</font>，导致查询效率降低）</p>\n</li>\n</ul>\n<h3 id=\"基本设计规范\"><a class=\"anchor\" href=\"#基本设计规范\">#</a> 基本设计规范</h3>\n<h4 id=\"所有表必须使用-innodb-存储引擎\"><a class=\"anchor\" href=\"#所有表必须使用-innodb-存储引擎\">#</a> 所有表必须使用 InnoDB 存储引擎</h4>\n<p>没有特殊要求（即 InnoDB 无法满足的功能如：列存储，存储空间数据等）的情况下，所有表必须使用 InnoDB 存储引擎（MySQL5.5 之前默认使用 MyISAM，5.6 以后默认的为 InnoDB）。</p>\n<p><font color='red'>InnoDB 支持事务、行级锁、外键约束，有更好的恢复性，高并发下性能更好</font>。</p>\n<h4 id=\"数据库和表的字符集统一使用-utf8\"><a class=\"anchor\" href=\"#数据库和表的字符集统一使用-utf8\">#</a> 数据库和表的字符集统一使用 UTF8</h4>\n<p>兼容性更好，统一字符集可以避免由于字符集转换产生的乱码，<font color='red'>不同的字符集进行比较前需要进行转换会造成索引失效</font>。</p>\n<p>如果数据库中有存储 emoji 表情的需要，字符集需要采用 utf8mb4 字符集。</p>\n<h4 id=\"所有表和字段都需要添加注释\"><a class=\"anchor\" href=\"#所有表和字段都需要添加注释\">#</a> 所有表和字段都需要添加注释</h4>\n<p>使用 comment 从句添加表和列的备注，从一开始就进行<font color='red'>数据字典的维护</font>。</p>\n<h4 id=\"尽量控制单表数据量的大小建议控制在-500-万以内\"><a class=\"anchor\" href=\"#尽量控制单表数据量的大小建议控制在-500-万以内\">#</a> 尽量控制单表数据量的大小，建议控制在 500 万以内</h4>\n<p>500 万并不是 MySQL 数据库的限制，过大会造成修改表结构，备份，恢复都会有很大的问题。</p>\n<p>可以用<font color='red'>历史数据归档（应用于日志数据）</font>，<font color='red'>分库分表（应用于业务数据）</font>等手段来控制数据量大小。</p>\n<h4 id=\"谨慎使用-mysql-分区表\"><a class=\"anchor\" href=\"#谨慎使用-mysql-分区表\">#</a> 谨慎使用 MySQL 分区表</h4>\n<p>分区表在物理上表现为多个文件，在逻辑上表现为一个表；</p>\n<p>谨慎选择分区键，<font color='red'>跨分区查询效率可能更低</font>；</p>\n<p><font color='red'>建议采用物理分表</font>的方式管理大数据。</p>\n<h4 id=\"经常一起使用的列放到一个表中\"><a class=\"anchor\" href=\"#经常一起使用的列放到一个表中\">#</a> 经常一起使用的列放到一个表中</h4>\n<p>避免更多的关联操作。</p>\n<h4 id=\"禁止在表中建立预留字段\"><a class=\"anchor\" href=\"#禁止在表中建立预留字段\">#</a> 禁止在表中建立预留字段</h4>\n<ul>\n<li>预留字段的命名<font color='red'>很难做到见名识义</font>。</li>\n<li>预留字段<font color='red'>无法确认存储的数据类型</font>，所以无法选择合适的类型。</li>\n<li>对预留字段类型的修改，会对表进行锁定。</li>\n</ul>\n<h4 id=\"禁止在数据库中存储文件比如图片这类大的二进制数据\"><a class=\"anchor\" href=\"#禁止在数据库中存储文件比如图片这类大的二进制数据\">#</a> 禁止在数据库中存储文件（比如图片）这类大的二进制数据</h4>\n<p>在数据库中存储文件<font color='red'>会严重影响数据库性能，消耗过多存储空间</font>。</p>\n<p>这类大的二进制数据文件（比如图片）<font color='red'>通常存储于文件服务器，数据库只存储文件地址信息</font>。</p>\n<h4 id=\"不要被数据库范式所束缚\"><a class=\"anchor\" href=\"#不要被数据库范式所束缚\">#</a> 不要被数据库范式所束缚</h4>\n<p>一般来说，设计关系数据库时需要满足第三范式，但<font color='red'>为了满足第三范式，我们可能会拆分出多张表</font>。而在进行查询时需要对多张表进行关联查询，<font color='red'>有时为了提高查询效率，会降低范式的要求，在表中保存一定的冗余信息，也叫做反范式</font>。但要注意反范式一定要适度。</p>\n<h4 id=\"禁止在线上做数据库压力测试\"><a class=\"anchor\" href=\"#禁止在线上做数据库压力测试\">#</a> 禁止在线上做数据库压力测试</h4>\n<h4 id=\"禁止从开发环境-测试环境直接连接生产环境数据库\"><a class=\"anchor\" href=\"#禁止从开发环境-测试环境直接连接生产环境数据库\">#</a> 禁止从开发环境、测试环境直接连接生产环境数据库</h4>\n<p>安全隐患极大，要对生产环境抱有敬畏之心！</p>\n<h3 id=\"字段设计规范\"><a class=\"anchor\" href=\"#字段设计规范\">#</a> 字段设计规范</h3>\n<h4 id=\"优先选择符合存储需要的最小的数据类型\"><a class=\"anchor\" href=\"#优先选择符合存储需要的最小的数据类型\">#</a> 优先选择符合存储需要的最小的数据类型</h4>\n<p>存储字节越小，占用也就空间越小，性能也越好。</p>\n<p><strong>a. 某些字符串可以转换成数字类型存储，比如可以将 IP 地址转换成整型数据。</strong></p>\n<p>数字是连续的，性能更好，占用空间也更小。</p>\n<p>MySQL 提供了两个方法来处理 ip 地址</p>\n<ul>\n<li><code>INET_ATON()</code> ：把 ip 转为无符号整型 (4-8 位)</li>\n<li><code>INET_NTOA()</code>  : 把整型的 ip 转为地址</li>\n</ul>\n<p>插入数据前，先用  <code>INET_ATON()</code>  把 ip 地址转为整型，显示数据时，使用  <code>INET_NTOA()</code>  把整型的 ip 地址转为地址显示即可。</p>\n<p><strong>b. 对于非负型的数据 (如自增 ID、整型 IP、年龄) 来说，要优先使用无符号整型来存储。</strong></p>\n<p><font color='red'>无符号相对于有符号可以多出一倍的存储空间</font></p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>SIGNED <span class=\"token keyword\">INT</span> <span class=\"token operator\">-</span><span class=\"token number\">2147483648</span><span class=\"token operator\">~</span><span class=\"token number\">2147483647</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">UNSIGNED</span> <span class=\"token keyword\">INT</span> <span class=\"token number\">0</span><span class=\"token operator\">~</span><span class=\"token number\">4294967295</span></pre></td></tr></table></figure><p><strong>c. 小数值类型（比如年龄、状态表示如 0/1）优先使用 TINYINT 类型。</strong></p>\n<h4 id=\"避免使用-text-blob-数据类型最常见的-text-类型可以存储-64k-的数据\"><a class=\"anchor\" href=\"#避免使用-text-blob-数据类型最常见的-text-类型可以存储-64k-的数据\">#</a> 避免使用 TEXT、BLOB 数据类型，最常见的 TEXT 类型可以存储 64k 的数据</h4>\n<p><strong>a. 建议把 BLOB 或是 TEXT 列分离到单独的扩展表中。</strong></p>\n<p>MySQL <font color='red'>内存临时表不支持 TEXT、BLOB 这样的大数据类型</font>，如果查询中包含这样的数据，在排序等操作时，就不能使用内存临时表，<font color='red'>必须使用磁盘临时表进行</font>。而且对于这种数据，MySQL 还是要进行二次查询，会使 sql 性能变得很差，但是不是说一定不能使用这样的数据类型。</p>\n<p><font color='red'>如果一定要使用，建议把 BLOB 或是 TEXT 列分离到单独的扩展表中</font>，查询时一定不要使用  <code>select *</code>  而只需要取出必要的列，不需要 TEXT 列的数据时不要对该列进行查询。</p>\n<p><strong>2、TEXT 或 BLOB 类型只能使用前缀索引</strong></p>\n<p>因为 MySQL 对索引字段长度是有限制的，所以 TEXT 类型只能使用前缀索引，并且 TEXT 列上是不能有默认值的。</p>\n<h4 id=\"避免使用-enum-类型\"><a class=\"anchor\" href=\"#避免使用-enum-类型\">#</a> 避免使用 ENUM 类型</h4>\n<ul>\n<li><font color='red'>修改 ENUM 值需要使用 ALTER 语句</font>；</li>\n<li>ENUM 类型的 <font color='red'>ORDER BY 操作效率低</font>，需要额外操作；</li>\n<li>ENUM 数据类型存在一些限制，比如建议不要使用数值作为 ENUM 的枚举值。</li>\n</ul>\n<p>相关阅读：<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzQwNDQyMjI1NS9hbnN3ZXIvMTY2MTY5ODQ5OQ==\">是否推荐使用 MySQL 的 enum 类型？ - 架构文摘 - 知乎</span></p>\n<h4 id=\"尽可能把所有列定义为-not-null\"><a class=\"anchor\" href=\"#尽可能把所有列定义为-not-null\">#</a> 尽可能把所有列定义为 NOT NULL</h4>\n<p>除非有特别的原因使用 NULL 值，应该总是让字段保持 NOT NULL。</p>\n<ul>\n<li>索引 NULL 列需要额外的空间来保存，所以要占用更多的空间；</li>\n<li>进行比较和计算时要对 NULL 值做特别的处理。</li>\n</ul>\n<p>相关阅读：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9vcGVuc291cmNlLmFjdGlvbnNreS5jb20vMjAxOTA3MTAtbXlzcWwv\">技术分享 | MySQL 默认值选型（是空，还是 NULL）</span></p>\n<h4 id=\"一定不要用字符串存储日期\"><a class=\"anchor\" href=\"#一定不要用字符串存储日期\">#</a> 一定不要用字符串存储日期</h4>\n<p>对于日期类型来说，一定不要用字符串存储日期。<font color='red'>可以考虑 DATETIME、TIMESTAMP、数值型时间戳</font>。</p>\n<p>这三种方式都有各自的优势，根据实际场景选择最合适的才是王道。下面再对这三种方式做一个简单的对比，以供大家实际开发中选择正确的存放时间的数据类型：</p>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>存储空间</th>\n<th>日期格式</th>\n<th>日期范围</th>\n<th>是否带时区信息</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>DATETIME</td>\n<td>5~8 字节</td>\n<td>YYYY-MM-DD hh:mm:ss[.fraction]</td>\n<td>1000-01-01 00:00:00[.000000] ～ 9999-12-31 23:59:59[.999999]</td>\n<td>否</td>\n</tr>\n<tr>\n<td>TIMESTAMP</td>\n<td>4~7 字节</td>\n<td>YYYY-MM-DD hh:mm:ss[.fraction]</td>\n<td>1970-01-01 00:00:01[.000000] ～ 2038-01-19 03:14:07[.999999]</td>\n<td>是</td>\n</tr>\n<tr>\n<td>数值型时间戳</td>\n<td>4 字节</td>\n<td>全数字如 1578707612</td>\n<td>1970-01-01 00:00:01 之后的时间</td>\n<td>否</td>\n</tr>\n</tbody>\n</table>\n<p>MySQL 时间类型选择的详细介绍请看这篇：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9qYXZhZ3VpZGUuY24vZGF0YWJhc2UvbXlzcWwvc29tZS10aG91Z2h0cy1vbi1kYXRhYmFzZS1zdG9yYWdlLXRpbWUuaHRtbA==\">MySQL 时间类型数据存储建议</span>。</p>\n<h4 id=\"财务相关的金额类数据必须使用-decimal-类型\"><a class=\"anchor\" href=\"#财务相关的金额类数据必须使用-decimal-类型\">#</a> 财务相关的金额类数据必须使用 decimal 类型</h4>\n<ul>\n<li><strong>非精准浮点</strong>：float、double</li>\n<li><strong><font color='#B32015'>精准浮点</font></strong>：decimal</li>\n</ul>\n<p>decimal 类型为精准浮点数，<font color='red'>在计算时不会丢失精度</font>。占用空间由定义的宽度决定，每 4 个字节可以存储 9 位数字，并且小数点要占用一个字节。并且，<font color='red'>decimal 可用于存储比 bigint 更大的整型数据</font>。</p>\n<p>不过，由于 decimal <font color='red'>需要额外的空间和计算开销</font>，应该尽量只在需要对数据进行精确计算时才使用 decimal 。</p>\n<h4 id=\"单表不要包含过多字段\"><a class=\"anchor\" href=\"#单表不要包含过多字段\">#</a> 单表不要包含过多字段</h4>\n<p>如果一个表包含过多字段的话，可以考虑将其<font color='red'>垂直分表</font>，必要时增加中间表进行关联。</p>\n<h3 id=\"索引设计规范\"><a class=\"anchor\" href=\"#索引设计规范\">#</a> 索引设计规范</h3>\n<h4 id=\"限制每张表上的索引数量建议单张表索引不超过-5-个\"><a class=\"anchor\" href=\"#限制每张表上的索引数量建议单张表索引不超过-5-个\">#</a> 限制每张表上的索引数量，建议单张表索引不超过 5 个</h4>\n<p>索引并不是越多越好！索引可以提高效率同样可以降低效率。</p>\n<p><font color='red'>索引可以增加查询效率，但同样也会降低插入和更新的效率</font>，甚至有些情况下会降低查询效率。</p>\n<p>因为 MySQL 优化器在选择如何优化查询时，会根据统一信息，对每一个可以用到的索引来进行评估，以生成出一个最好的执行计划，如果同时有很多个索引都可以用于查询，就会增加<font color='red'> MySQL 优化器生成执行计划的时间</font>，同样会降低查询性能。</p>\n<h4 id=\"禁止使用全文索引\"><a class=\"anchor\" href=\"#禁止使用全文索引\">#</a> 禁止使用全文索引</h4>\n<p>全文索引不适用于 OLTP（联机事务处理）场景。</p>\n<h4 id=\"禁止给表中的每一列都建立单独的索引\"><a class=\"anchor\" href=\"#禁止给表中的每一列都建立单独的索引\">#</a> 禁止给表中的每一列都建立单独的索引</h4>\n<p>5.6 版本之前，一个 sql 只能使用到一个表中的一个索引；5.6 以后，虽然有了合并索引的优化方式，但是还是远远没有使用一个联合索引的查询方式好。</p>\n<h4 id=\"每个-innodb-表必须有个主键\"><a class=\"anchor\" href=\"#每个-innodb-表必须有个主键\">#</a> 每个 InnoDB 表必须有个主键</h4>\n<p>InnoDB 是一种索引组织表：<font color='red'>数据存储的逻辑顺序和索引的顺序是相同的</font>。每个表都可以有多个索引，但是表的存储顺序只能有一种。</p>\n<p>InnoDB 是 **<font color='red'>按照主键索引的顺序来组织表</font>** 的</p>\n<ul>\n<li>不要使用更新频繁的列作为主键，不使用多列主键（相当于联合索引）</li>\n<li>不要使用 UUID,MD5,HASH, 字符串列作为主键（无法保证数据的顺序增长）</li>\n<li><font color='red'>主键建议使用自增 ID 值</font></li>\n</ul>\n<h4 id=\"常见索引列建议\"><a class=\"anchor\" href=\"#常见索引列建议\">#</a> 常见索引列建议</h4>\n<ul>\n<li>\n<p>出现在 WHERE 子句中的列</p>\n</li>\n<li>\n<p>包含在 ORDER BY、GROUP BY、DISTINCT 中的字段</p>\n</li>\n<li>\n<p><font color='red'>通常将上述两种情况的字段建立<u>联合索引</u>，效果更好</font></p>\n</li>\n<li>\n<p>多表 join 的<font color='red'>关联列</font></p>\n</li>\n</ul>\n<h4 id=\"如何选择联合索引中的列顺序\"><a class=\"anchor\" href=\"#如何选择联合索引中的列顺序\">#</a> 如何选择联合索引中的列顺序</h4>\n<p>建立索引的目的是：希望通过索引进行数据查找，减少随机 IO，增加查询性能，<font color='red'>索引能过滤出越少的数据，则从磁盘中读入的数据也就越少</font>。</p>\n<ul>\n<li>\n<p><font color='red'>区分度最高的列</font>放在联合索引的最左侧</p>\n<blockquote>\n<p>区分度 = 列中不同值的数量 / 列的总行数</p>\n</blockquote>\n</li>\n<li>\n<p>尽量把<font color='red'>字段长度小的列</font>放在联合索引的最左侧</p>\n<blockquote>\n<p>因为字段长度越小，一页能存储的数据量越大，IO 性能也就越好</p>\n</blockquote>\n</li>\n<li>\n<p><font color='red'>使用最频繁的列</font>放到联合索引的左侧</p>\n<blockquote>\n<p>这样可以比较少的建立一些索引</p>\n</blockquote>\n</li>\n</ul>\n<h4 id=\"避免建立冗余索引-重复索引\"><a class=\"anchor\" href=\"#避免建立冗余索引-重复索引\">#</a> 避免建立冗余索引、重复索引</h4>\n<blockquote>\n<p>增加了查询优化器生成执行计划的时间</p>\n</blockquote>\n<ul>\n<li>重复索引示例：primary key (id)、index (id)、unique index (id)</li>\n<li>冗余索引示例：index (a,b,c)、index (a,b)、index (a)</li>\n</ul>\n<h4 id=\"对于频繁的查询优先考虑覆盖索引\"><a class=\"anchor\" href=\"#对于频繁的查询优先考虑覆盖索引\">#</a> 对于频繁的查询，优先考虑覆盖索引</h4>\n<blockquote>\n<p>覆盖索引：<font color='red'>包含了所有查询字段</font> (where,select,order by,group by 包含的字段) 的索引。</p>\n</blockquote>\n<p>覆盖索引的好处：</p>\n<ul>\n<li><strong><font color='red'>避免二次查询（回表）</font></strong>：InnoDB 是以聚集索引的顺序来存储的，对于 InnoDB 来说，二级索引在叶子节点中所保存的是行的主键信息。<font color='red'>如果是用二级索引查询数据的话，在查找到相应的主键后，还要通过聚集索引进行二次查询才能获取我们真实所需要的数据</font>。而在覆盖索引中，二级索引的键值中可以获取所有的数据，避免了对主键的二次查询，减少了 IO 操作，提升了查询效率。</li>\n<li><strong>可以把随机 IO 变成顺序 IO 加快查询效率:</strong> 由于覆盖索引是按键值的顺序存储的，对于 IO 密集型的范围查找来说，对比随机从磁盘读取每一行的数据 IO 要少的多。因此利用覆盖索引在访问时也可以把磁盘的随机读取的 IO 转变成索引查找的顺序 IO。</li>\n</ul>\n<h4 id=\"索引-set-规范\"><a class=\"anchor\" href=\"#索引-set-规范\">#</a> 索引 SET 规范</h4>\n<p><strong><font color='red'>尽量避免使用外键约束</font></strong></p>\n<ul>\n<li>不建议使用外键约束（foreign key），但<font color='red'>一定要在表与表之间的关联键上建立索引</font></li>\n<li>外键可用于保证数据的参照完整性，但<font color='red'>建议在业务端实现外键约束</font></li>\n<li><font color='red'>外键会影响父表和子表的写操作</font>，从而降低性能</li>\n</ul>\n<h3 id=\"sql-开发规范\"><a class=\"anchor\" href=\"#sql-开发规范\">#</a> SQL 开发规范</h3>\n<h4 id=\"尽量不在数据库做运算复杂运算需移到业务应用里完成\"><a class=\"anchor\" href=\"#尽量不在数据库做运算复杂运算需移到业务应用里完成\">#</a> 尽量不在数据库做运算，复杂运算需移到业务应用里完成</h4>\n<p>避免数据库的负担过重，影响数据库的性能和稳定性。数据库的主要作用是存储和管理数据，而不是处理数据。</p>\n<h4 id=\"优化对性能影响较大的-sql-语句\"><a class=\"anchor\" href=\"#优化对性能影响较大的-sql-语句\">#</a> 优化对性能影响较大的 SQL 语句</h4>\n<p>要找到最需要优化的 SQL 语句。要么是<font color='red'>使用最频繁</font>的语句，要么是<font color='red'>优化后提高最明显</font>的语句，可以通过查询 MySQL 的 **<font color='red'>慢查询日志</font>** 来发现需要进行优化的 SQL 语句。</p>\n<h4 id=\"充分利用表上已经存在的索引\"><a class=\"anchor\" href=\"#充分利用表上已经存在的索引\">#</a> 充分利用表上已经存在的索引</h4>\n<p>避免使用双 % 号的查询条件。如： <code>a like '%123%'</code> ，（如果无前置 %, 只有后置 %，是可以用到列上的索引的）</p>\n<p>一个 SQL 只能利用到复合索引中的一列进行范围查询。如：有 a,b,c 列的联合索引，在查询条件中有 a 列的范围查询，则在 b,c 列上的索引将不会被用到。</p>\n<p>在定义联合索引时，如果 a 列要用到范围查找的话，就要把 a 列放到联合索引的右侧，使用 left join 或 not exists 来优化 not in 操作，因为 not in 也通常会使用索引失效。</p>\n<h4 id=\"禁止使用-select-查询\"><a class=\"anchor\" href=\"#禁止使用-select-查询\">#</a> 禁止使用 SELECT * 查询</h4>\n<ul>\n<li>\n<p><code>SELECT *</code>  会消耗更多的 CPU</p>\n</li>\n<li>\n<p><code>SELECT *</code>  无用字段增加网络带宽资源消耗，增加数据传输时间，尤其是大字段（如 varchar、blob、text）</p>\n</li>\n<li>\n<p><code>SELECT *</code>  <font color='red'>无法使用 MySQL 优化器覆盖索引的优化</font>（基于 MySQL 优化器的 “覆盖索引” 策略又是速度极快，效率极高，业界极为推荐的查询优化方式）</p>\n</li>\n<li>\n<p><code>SELECT &lt;字段列表&gt;</code>  可减少表结构变更带来的影响</p>\n</li>\n</ul>\n<h4 id=\"禁止使用不含字段列表的-insert-语句\"><a class=\"anchor\" href=\"#禁止使用不含字段列表的-insert-语句\">#</a> 禁止使用不含字段列表的 INSERT 语句</h4>\n<p>如：</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">insert</span> <span class=\"token keyword\">into</span> t <span class=\"token keyword\">values</span> <span class=\"token punctuation\">(</span><span class=\"token string\">'a'</span><span class=\"token punctuation\">,</span><span class=\"token string\">'b'</span><span class=\"token punctuation\">,</span><span class=\"token string\">'c'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>应使用：</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">insert</span> <span class=\"token keyword\">into</span> t<span class=\"token punctuation\">(</span>c1<span class=\"token punctuation\">,</span>c2<span class=\"token punctuation\">,</span>c3<span class=\"token punctuation\">)</span> <span class=\"token keyword\">values</span> <span class=\"token punctuation\">(</span><span class=\"token string\">'a'</span><span class=\"token punctuation\">,</span><span class=\"token string\">'b'</span><span class=\"token punctuation\">,</span><span class=\"token string\">'c'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h4 id=\"建议使用预编译语句进行数据库操作\"><a class=\"anchor\" href=\"#建议使用预编译语句进行数据库操作\">#</a> 建议使用预编译语句进行数据库操作</h4>\n<ul>\n<li>\n<p>预编译语句可以重复使用这些计划，<font color='red'>减少 SQL 编译所需要的时间</font>，还可以<font color='red'>解决动态 SQL 所带来的 SQL 注入的问题</font></p>\n</li>\n<li>\n<p><font color='red'>只传参数</font>，比传递 SQL 语句更高效</p>\n</li>\n<li>\n<p>相同语句可以<font color='red'>一次解析，多次使用</font>，提高处理效率</p>\n</li>\n</ul>\n<h4 id=\"避免数据类型的隐式转换\"><a class=\"anchor\" href=\"#避免数据类型的隐式转换\">#</a> 避免数据类型的隐式转换</h4>\n<p>隐式转换<font color='red'>会导致索引失效</font>如:</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">select</span> name<span class=\"token punctuation\">,</span>phone <span class=\"token keyword\">from</span> customer <span class=\"token keyword\">where</span> id <span class=\"token operator\">=</span> <span class=\"token string\">'111'</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>详细解读可以看：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9qYXZhZ3VpZGUuY24vZGF0YWJhc2UvbXlzcWwvaW5kZXgtaW52YWxpZGF0aW9uLWNhdXNlZC1ieS1pbXBsaWNpdC1jb252ZXJzaW9uLmh0bWw=\">MySQL 中的隐式转换造成的索引失效</span> 这篇文章。</p>\n<h4 id=\"避免使用子查询可以把子查询优化为-join-操作\"><a class=\"anchor\" href=\"#避免使用子查询可以把子查询优化为-join-操作\">#</a> 避免使用子查询，可以把子查询优化为 join 操作</h4>\n<p>通常子查询在 in 子句中，且子查询中为简单 SQL (不包含 union、group by、order by、limit 从句) 时，才可以把子查询转化为关联查询进行优化。</p>\n<p>子查询性能差的原因：<strong><font color='red'>子查询的结果集通常被存储到临时表中，不论是内存临时表还是磁盘临时表都不会存在索引</font></strong>，所以查询性能会受到一定的影响。特别是对于返回结果集比较大的子查询，其对查询性能的影响也就越大。由于子查询会产生大量的临时表也没有索引，所以会消耗过多的 CPU 和 IO 资源，产生大量的慢查询。</p>\n<h4 id=\"避免使用-join-关联太多的表\"><a class=\"anchor\" href=\"#避免使用-join-关联太多的表\">#</a> 避免使用 JOIN 关联太多的表</h4>\n<ul>\n<li>\n<p>对于 MySQL 来说，是存在<font color='red'>关联缓存</font>的，缓存的大小可以由  <code>join_buffer_size</code>  参数进行设置。</p>\n</li>\n<li>\n<p>在 MySQL 中，对于同一个 SQL，多关联（join）一个表，就会多分配一个关联缓存，如果在<font color='red'>一个 SQL 中关联的表越多，所占用的内存也就越大</font>。</p>\n</li>\n<li>\n<p>如果程序中大量的使用了多表关联的操作，同时 join_buffer_size 设置的也不合理的情况下，就<font color='red'>容易造成服务器内存溢出</font>的情况，就会影响到服务器数据库性能的稳定性。</p>\n</li>\n<li>\n<p>同时对于关联操作来说，会产生临时表操作，影响查询效率，<font color='red'>MySQL 最多允许关联 61 个表，建议不超过 5 个</font>。</p>\n</li>\n</ul>\n<h4 id=\"减少同数据库的交互次数\"><a class=\"anchor\" href=\"#减少同数据库的交互次数\">#</a> 减少同数据库的交互次数</h4>\n<p>数据库更适合处理批量操作，<font color='red'>合并多个相同的操作到一起</font>，可以提高处理效率。</p>\n<h4 id=\"对应同一列进行-or-判断时使用-in-代替-or\"><a class=\"anchor\" href=\"#对应同一列进行-or-判断时使用-in-代替-or\">#</a> 对应同一列进行 or 判断时，使用 in 代替 or</h4>\n<p>in 的值不要超过 500 个，in 操作可以更有效的利用索引，or 大多数情况下很少能利用到索引。</p>\n<h4 id=\"禁止使用-order-by-rand-进行随机排序\"><a class=\"anchor\" href=\"#禁止使用-order-by-rand-进行随机排序\">#</a> 禁止使用 order by rand () 进行随机排序</h4>\n<p>order by rand () 会把表中所有符合条件的数据装载到内存中，然后在内存中对所有数据根据随机生成的值进行排序，并且可能会对每一行都生成一个随机值，如果满足条件的数据集非常大，就会消耗大量的 CPU 和 IO 及内存资源。</p>\n<p>推荐在程序中获取一个随机值，然后从数据库中获取数据的方式。</p>\n<h4 id=\"where-从句中禁止对列进行函数转换和计算\"><a class=\"anchor\" href=\"#where-从句中禁止对列进行函数转换和计算\">#</a> WHERE 从句中禁止对列进行函数转换和计算</h4>\n<p>对列进行函数转换或计算时<font color='red'>会导致索引失效</font></p>\n<p>不推荐：</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">where</span> <span class=\"token keyword\">date</span><span class=\"token punctuation\">(</span>create_time<span class=\"token punctuation\">)</span><span class=\"token operator\">=</span><span class=\"token string\">'20190101'</span></pre></td></tr></table></figure><p>推荐：</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">where</span> create_time <span class=\"token operator\">>=</span> <span class=\"token string\">'20190101'</span> <span class=\"token operator\">and</span> create_time <span class=\"token operator\">&lt;</span> <span class=\"token string\">'20190102'</span></pre></td></tr></table></figure><h4 id=\"在明显不会有重复值时使用-union-all-而不是-union\"><a class=\"anchor\" href=\"#在明显不会有重复值时使用-union-all-而不是-union\">#</a> 在明显不会有重复值时，使用 UNION ALL 而不是 UNION</h4>\n<ul>\n<li>UNION：把两个结果集的所有数据<font color='red'>放到临时表中，再进行去重操作</font></li>\n<li>UNION ALL：<font color='red'>不会再对结果集进行去重操作</font></li>\n</ul>\n<h4 id=\"拆分复杂的大-sql-为多个小-sql\"><a class=\"anchor\" href=\"#拆分复杂的大-sql-为多个小-sql\">#</a> 拆分复杂的大 SQL 为多个小 SQL</h4>\n<ul>\n<li>大 SQL 逻辑上比较复杂，需要占用大量 CPU 进行计算的 SQL</li>\n<li>MySQL 中，一个 SQL 只能使用一个 CPU 进行计算</li>\n<li>SQL 拆分后可以通过<font color='red'>并行执行</font>来提高处理效率</li>\n</ul>\n<h4 id=\"程序连接不同的数据库使用不同的账号禁止跨库查询\"><a class=\"anchor\" href=\"#程序连接不同的数据库使用不同的账号禁止跨库查询\">#</a> 程序连接不同的数据库使用不同的账号，禁止跨库查询</h4>\n<ul>\n<li>为数据库迁移和分库分表留出余地</li>\n<li>降低业务耦合度</li>\n<li>避免权限过大而产生的安全风险</li>\n</ul>\n<h3 id=\"操作行为规范\"><a class=\"anchor\" href=\"#操作行为规范\">#</a> 操作行为规范</h3>\n<h4 id=\"超-100-万行的批量写-updatedeleteinsert-操作要分批多次进行操作\"><a class=\"anchor\" href=\"#超-100-万行的批量写-updatedeleteinsert-操作要分批多次进行操作\">#</a> 超 100 万行的批量写 (UPDATE,DELETE,INSERT) 操作，要分批多次进行操作</h4>\n<p><strong><font color='red'>大批量操作可能会造成严重的主从延迟</font></strong></p>\n<p>主从环境中，大批量操作可能会造成严重的主从延迟，大批量的写操作一般都需要执行一定长的时间，而只有当主库上执行完成后，才会在其他从库上执行，所以会造成主库与从库长时间的延迟情况</p>\n<p><strong><font color='red'>binlog 日志为 row 格式时会产生大量的日志</font></strong></p>\n<p>大批量写操作会产生大量日志，特别是对于 row 格式二进制数据而言，由于<font color='red'>在 row 格式中会记录每一行数据的修改</font>，我们一次修改的数据越多，产生的日志量也就会越多，日志的传输和恢复所需要的时间也就越长，这也是造成主从延迟的一个原因</p>\n<p><strong><font color='red'>避免产生大事务操作</font></strong></p>\n<p>大批量修改数据，一定是在一个事务中进行的，这就<font color='red'>会造成表中大批量数据进行锁定，从而导致大量的阻塞</font>，阻塞会对 MySQL 的性能产生非常大的影响。</p>\n<p>特别是<font color='red'>长时间的阻塞会占满所有数据库的可用连接</font>，这会使生产环境中的其他应用无法连接到数据库，因此一定要注意大批量写操作要进行分批</p>\n<h4 id=\"对于大表使用-pt-online-schema-change-修改表结构\"><a class=\"anchor\" href=\"#对于大表使用-pt-online-schema-change-修改表结构\">#</a> 对于大表使用 pt-online-schema-change 修改表结构</h4>\n<ul>\n<li>避免大表修改产生的主从延迟</li>\n<li>避免在对表字段进行修改时进行锁表</li>\n</ul>\n<p><font color='red'>对大表数据结构的修改一定要谨慎，会造成严重的锁表操作</font>，尤其是生产环境，是不能容忍的。</p>\n<p><code>pt-online-schema-change</code> <font color='red'> 首先会建立一个与原表结构相同的新表，并且在新表上进行表结构的修改，然后再把原表中的数据复制到新表中，并在原表中增加一些触发器。把原表中新增的数据也复制到新表中，在所有数据复制完成之后，把新表命名成原表，并把原来的表删除掉。</font>把原来一个 DDL 操作，分解成多个小的批次进行。</p>\n<h4 id=\"禁止为程序使用的账号赋予-super-权限\"><a class=\"anchor\" href=\"#禁止为程序使用的账号赋予-super-权限\">#</a> 禁止为程序使用的账号赋予 super 权限</h4>\n<ul>\n<li>当达到最大连接数限制时，还运行 1 个有 super 权限的用户连接</li>\n<li><font color='red'>super 权限只能留给 DBA 处理问题的账号使用</font></li>\n</ul>\n<h4 id=\"对于程序连接数据库账号遵循权限最小原则\"><a class=\"anchor\" href=\"#对于程序连接数据库账号遵循权限最小原则\">#</a> 对于程序连接数据库账号，遵循权限最小原则</h4>\n<ul>\n<li>程序使用数据库账号只能在一个 DB 下使用，不准跨库</li>\n<li>程序使用的账号原则上不准有 drop 权限</li>\n</ul>\n<h2 id=\"sql\"><a class=\"anchor\" href=\"#sql\">#</a> SQL</h2>\n<h3 id=\"sql语法基础\"><a class=\"anchor\" href=\"#sql语法基础\">#</a> SQL 语法基础</h3>\n<h4 id=\"基本概念-2\"><a class=\"anchor\" href=\"#基本概念-2\">#</a> 基本概念</h4>\n<h5 id=\"数据库术语\"><a class=\"anchor\" href=\"#数据库术语\">#</a> 数据库术语</h5>\n<ul>\n<li><code>数据库（database）</code>  - 保存有组织的数据的容器（通常是一个文件或一组文件）。</li>\n<li><code>数据表（table）</code>  - 某种特定类型数据的结构化清单。</li>\n<li><code>模式（schema）</code>  - <font color='red'>关于数据库和表的布局及特性的信息</font>。模式<font color='red'>定义了数据在表中如何存储</font>，包含存储什么样的数据，数据如何分解，各部分信息如何命名等信息。数据库和表都有模式。</li>\n<li><code>列（column）</code>  - 表中的一个字段。所有表都是由一个或多个列组成的。</li>\n<li><code>行（row）</code>  - 表中的一个记录。</li>\n<li><code>主键（primary key）</code>  - 一列（或一组列），其值能够唯一标识表中每一行。</li>\n</ul>\n<h5 id=\"sql-语法\"><a class=\"anchor\" href=\"#sql-语法\">#</a> SQL 语法</h5>\n<p><code>SQL（Structured Query Language)</code> ，标准 SQL 由 ANSI 标准委员会管理，从而称为 ANSI SQL。各个 DBMS 都有自己的实现，如 PL/SQL、Transact-SQL 等。</p>\n<h6 id=\"sql-语法结构\"><a class=\"anchor\" href=\"#sql-语法结构\">#</a> SQL 语法结构</h6>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/cb684d4c75fc430e92aaee226069c7da%7Etplv-k3u1fbpfcp-zoom-1.image\" alt=\"img\" /></p>\n<p>SQL 语法结构包括：</p>\n<ul>\n<li><strong> <code>子句</code> </strong> - 是语句和查询的组成成分。（在某些情况下，这些都是可选的。）</li>\n<li><strong> <code>表达式</code> </strong> - 可以产生任何标量值，或由列和行的数据库表</li>\n<li><strong> <code>谓词</code> </strong> - 给需要评估的 SQL 三值逻辑（3VL）（true/false/unknown）或布尔真值指定条件，并限制语句和查询的效果，或改变程序流程。</li>\n<li><strong> <code>查询</code> </strong> - 基于特定条件检索数据。这是 SQL 的一个重要组成部分。</li>\n<li><strong> <code>语句</code> </strong> - 可以持久地影响纲要和数据，也可以控制数据库事务、程序流程、连接、会话或诊断。</li>\n</ul>\n<h6 id=\"sql-语法要点\"><a class=\"anchor\" href=\"#sql-语法要点\">#</a> SQL 语法要点</h6>\n<ul>\n<li><strong>SQL 语句不区分大小写</strong>，但是数据库表名、列名和值是否区分，依赖于具体的 DBMS 以及配置。例如： <code>SELECT</code>  与  <code>select</code>  、 <code>Select</code>  是相同的。</li>\n<li><strong>多条 SQL 语句必须以分号（ <code>;</code> ）分隔</strong>。</li>\n<li>处理 SQL 语句时，<strong>所有空格都被忽略</strong>。</li>\n</ul>\n<p>SQL 语句可以写成一行，也可以分写为多行。</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">-- 一行 SQL 语句</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">UPDATE</span> <span class=\"token keyword\">user</span> <span class=\"token keyword\">SET</span> username<span class=\"token operator\">=</span><span class=\"token string\">'robot'</span><span class=\"token punctuation\">,</span> password<span class=\"token operator\">=</span><span class=\"token string\">'robot'</span> <span class=\"token keyword\">WHERE</span> username <span class=\"token operator\">=</span> <span class=\"token string\">'root'</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token comment\">-- 多行 SQL 语句</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token keyword\">UPDATE</span> <span class=\"token keyword\">user</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token keyword\">SET</span> username<span class=\"token operator\">=</span><span class=\"token string\">'robot'</span><span class=\"token punctuation\">,</span> password<span class=\"token operator\">=</span><span class=\"token string\">'robot'</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token keyword\">WHERE</span> username <span class=\"token operator\">=</span> <span class=\"token string\">'root'</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>SQL 支持三种注释：</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">## 注释 1</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token comment\">-- 注释 2</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token comment\">/* 注释 3 */</span></pre></td></tr></table></figure><h5 id=\"sql-分类\"><a class=\"anchor\" href=\"#sql-分类\">#</a> SQL 分类</h5>\n<h6 id=\"数据定义语言ddl\"><a class=\"anchor\" href=\"#数据定义语言ddl\">#</a> 数据定义语言（DDL）</h6>\n<p>数据定义语言（Data Definition Language，DDL）是 SQL 语言集中负责数据结构定义与数据库对象定义的语言。</p>\n<p>DDL 的主要功能是<strong>定义数据库对象</strong>。</p>\n<p>DDL 的核心指令是  <code>CREATE</code> 、 <code>ALTER</code> 、 <code>DROP</code> 。</p>\n<h6 id=\"数据操纵语言dml\"><a class=\"anchor\" href=\"#数据操纵语言dml\">#</a> 数据操纵语言（DML）</h6>\n<p>数据操纵语言（Data Manipulation Language, DML）是用于数据库操作，对数据库其中的对象和数据运行访问工作的编程语句。</p>\n<p>DML 的主要功能是 访问数据，因此其语法都是以<strong>读写数据库</strong>为主。</p>\n<p>DML 的核心指令是  <code>INSERT</code> 、 <code>DELETE</code> 、 <code>UPDATE</code> 、 <code>SELECT</code> 。这四个指令合称 CRUD (Create, Read, Update, Delete)，即增删改查。</p>\n<h6 id=\"事务控制语言tcl\"><a class=\"anchor\" href=\"#事务控制语言tcl\">#</a> 事务控制语言（TCL）</h6>\n<p>事务控制语言 (Transaction Control Language, TCL) 用于<strong>管理数据库中的事务</strong>。这些用于管理由 DML 语句所做的更改。它还允许将语句分组为逻辑事务。</p>\n<p>TCL 的核心指令是  <code>COMMIT</code> 、 <code>ROLLBACK</code> 。</p>\n<h6 id=\"数据控制语言dcl\"><a class=\"anchor\" href=\"#数据控制语言dcl\">#</a> 数据控制语言（DCL）</h6>\n<p>数据控制语言 (Data Control Language, DCL) 是一种可对数据访问权进行控制的指令，它可以控制特定用户账户对数据表、查看表、预存程序、用户自定义函数等数据库对象的控制权。</p>\n<p>DCL 的核心指令是  <code>GRANT</code> 、 <code>REVOKE</code> 。</p>\n<p>DCL 以<strong>控制用户的访问权限</strong>为主，因此其指令作法并不复杂，可利用 DCL 控制的权限有： <code>CONNECT</code> 、 <code>SELECT</code> 、 <code>INSERT</code> 、 <code>UPDATE</code> 、 <code>DELETE</code> 、 <code>EXECUTE</code> 、 <code>USAGE</code> 、 <code>REFERENCES</code> 。</p>\n<p>根据不同的 DBMS 以及不同的安全性实体，其支持的权限控制也有所不同。</p>\n<p><strong>我们先来介绍 DML 语句用法。 DML 的主要功能是读写数据库实现增删改查。</strong></p>\n<h4 id=\"增删改查\"><a class=\"anchor\" href=\"#增删改查\">#</a> 增删改查</h4>\n<p>增删改查，又称为 CRUD，数据库基本操作中的基本操作。</p>\n<h5 id=\"插入数据\"><a class=\"anchor\" href=\"#插入数据\">#</a> 插入数据</h5>\n<p><code>INSERT INTO</code>  语句用于向表中插入新记录。</p>\n<p><strong>插入完整的行</strong></p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># 插入一行</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">INSERT</span> <span class=\"token keyword\">INTO</span> <span class=\"token keyword\">user</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">VALUES</span> <span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'root'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'root'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'xxxx@163.com'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token comment\"># 插入多行</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">INSERT</span> <span class=\"token keyword\">INTO</span> <span class=\"token keyword\">user</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token keyword\">VALUES</span> <span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'root'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'root'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'xxxx@163.com'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token number\">12</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'user1'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'user1'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'xxxx@163.com'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token number\">18</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'user2'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'user2'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'xxxx@163.com'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p><strong>插入行的一部分</strong></p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">INSERT</span> <span class=\"token keyword\">INTO</span> <span class=\"token keyword\">user</span><span class=\"token punctuation\">(</span>username<span class=\"token punctuation\">,</span> password<span class=\"token punctuation\">,</span> email<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">VALUES</span> <span class=\"token punctuation\">(</span><span class=\"token string\">'admin'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'admin'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'xxxx@163.com'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p><strong>插入查询出来的数据</strong></p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">INSERT</span> <span class=\"token keyword\">INTO</span> <span class=\"token keyword\">user</span><span class=\"token punctuation\">(</span>username<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">SELECT</span> name</pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">FROM</span> account<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h5 id=\"更新数据\"><a class=\"anchor\" href=\"#更新数据\">#</a> 更新数据</h5>\n<p><code>UPDATE</code>  语句用于更新表中的记录。</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">UPDATE</span> <span class=\"token keyword\">user</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">SET</span> username<span class=\"token operator\">=</span><span class=\"token string\">'robot'</span><span class=\"token punctuation\">,</span> password<span class=\"token operator\">=</span><span class=\"token string\">'robot'</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">WHERE</span> username <span class=\"token operator\">=</span> <span class=\"token string\">'root'</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h5 id=\"删除数据\"><a class=\"anchor\" href=\"#删除数据\">#</a> 删除数据</h5>\n<ul>\n<li><code>DELETE</code>  语句用于删除表中的记录。</li>\n<li><code>TRUNCATE TABLE</code>  可以清空表，也就是删除所有行。</li>\n</ul>\n<p><strong>删除表中的指定数据</strong></p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">DELETE</span> <span class=\"token keyword\">FROM</span> <span class=\"token keyword\">user</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">WHERE</span> username <span class=\"token operator\">=</span> <span class=\"token string\">'robot'</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p><strong>清空表中的数据</strong></p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">TRUNCATE</span> <span class=\"token keyword\">TABLE</span> <span class=\"token keyword\">user</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h5 id=\"查询数据\"><a class=\"anchor\" href=\"#查询数据\">#</a> 查询数据</h5>\n<p><code>SELECT</code>  语句用于从数据库中查询数据。</p>\n<p><code>DISTINCT</code>  用于返回唯一不同的值。它<font color='red'>作用于所有列</font>，也就是说所有列的值都相同才算相同。</p>\n<p><code>LIMIT</code>  限制返回的行数。可以有两个参数，<strong><font color='red'>第一个参数为起始行从 0 开始</font></strong>；<font color='red'>第二个参数为返回的总行数</font>。</p>\n<ul>\n<li><code>ASC</code>  ：升序（默认）</li>\n<li><code>DESC</code>  ：降序</li>\n</ul>\n<p><strong>查询单列</strong></p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">SELECT</span> prod_name</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">FROM</span> products<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p><strong>查询多列</strong></p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">SELECT</span> prod_id<span class=\"token punctuation\">,</span> prod_name<span class=\"token punctuation\">,</span> prod_price</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">FROM</span> products<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p><strong>查询所有列</strong></p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">FROM</span> products<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p><strong>查询不同的值</strong></p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">SELECT</span> <span class=\"token keyword\">DISTINCT</span> vend_id </pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">FROM</span> products<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p><strong>限制查询结果</strong></p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">-- 返回前 5 行</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> mytable <span class=\"token keyword\">LIMIT</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> mytable <span class=\"token keyword\">LIMIT</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token comment\">-- 返回第 3 ~ 5 行</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> mytable <span class=\"token keyword\">LIMIT</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h4 id=\"排序\"><a class=\"anchor\" href=\"#排序\">#</a> 排序</h4>\n<p><code>order by</code>  用于对结果集按照一个列或者多个列进行排序。 <code>默认升序</code> 对记录进行排序，如果需要按照降序对记录进行排序，可以使用  <code>desc</code>  关键字。</p>\n<p><code>order by</code>  对多列排序的时候，先排序的列放前面，后排序的列放后面。并且，<font color='red'>不同的列可以有不同的排序规则</font>。</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> products</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">ORDER</span> <span class=\"token keyword\">BY</span> prod_price <span class=\"token keyword\">DESC</span><span class=\"token punctuation\">,</span> prod_name <span class=\"token keyword\">ASC</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h4 id=\"分组\"><a class=\"anchor\" href=\"#分组\">#</a> 分组</h4>\n<p><strong> <code>group by</code> </strong> ：</p>\n<ul>\n<li><code>group by</code>  子句将记录分组到汇总行中。</li>\n<li><code>group by</code>  为每个组返回一个记录。</li>\n<li><code>group by</code>  通常还涉及聚合 <code>count</code> ， <code>max</code> ， <code>sum</code> ， <code>avg</code>  等。</li>\n<li><code>group by</code>  可以按一列或多列进行分组。</li>\n<li><code>group by</code>  按分组字段进行排序后， <code>order by</code>  可以以汇总字段来进行排序。</li>\n</ul>\n<p><strong>分组</strong></p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">SELECT</span> cust_name<span class=\"token punctuation\">,</span> <span class=\"token function\">COUNT</span><span class=\"token punctuation\">(</span>cust_address<span class=\"token punctuation\">)</span> <span class=\"token keyword\">AS</span> addr_num</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">FROM</span> Customers <span class=\"token keyword\">GROUP</span> <span class=\"token keyword\">BY</span> cust_name<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p><strong>分组后排序</strong></p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">SELECT</span> cust_name<span class=\"token punctuation\">,</span> <span class=\"token function\">COUNT</span><span class=\"token punctuation\">(</span>cust_address<span class=\"token punctuation\">)</span> <span class=\"token keyword\">AS</span> addr_num</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">FROM</span> Customers <span class=\"token keyword\">GROUP</span> <span class=\"token keyword\">BY</span> cust_name</pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">ORDER</span> <span class=\"token keyword\">BY</span> cust_name <span class=\"token keyword\">DESC</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p><strong> <code>having</code> </strong>：</p>\n<ul>\n<li><code>having</code>  <font color='red'>用于对汇总的  <code>group by</code>  结果进行过滤</font>。</li>\n<li><code>having</code>  一般都是和  <code>group by</code>  连用。</li>\n<li><code>where</code>  和  <code>having</code>  可以在相同的查询中。</li>\n</ul>\n<p><strong>使用 WHERE 和 HAVING 过滤数据</strong></p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">SELECT</span> cust_name<span class=\"token punctuation\">,</span> <span class=\"token function\">COUNT</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">AS</span> num</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">FROM</span> Customers</pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">WHERE</span> cust_email <span class=\"token operator\">IS</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">GROUP</span> <span class=\"token keyword\">BY</span> cust_name</pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">HAVING</span> <span class=\"token function\">COUNT</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">>=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p><strong> <code>having</code>  vs  <code>where</code> </strong> ：</p>\n<ul>\n<li><code>where</code> ：\n<ul>\n<li><font color='red'>过滤指定的<u>行</u></font></li>\n<li><font color='red'>后面不能加聚合函数</font>（分组函数）</li>\n<li><font color='red'>在 <code>group by</code>  前使用</font></li>\n</ul>\n</li>\n<li><code>having</code> ：\n<ul>\n<li><font color='red'>过滤<u>分组</u></font></li>\n<li>一般都是和  <code>group by</code>  连用，<font color='red'>不能单独使用</font></li>\n<li><font color='red'>在  <code>group by</code>  之后使用</font></li>\n</ul>\n</li>\n</ul>\n<h4 id=\"子查询\"><a class=\"anchor\" href=\"#子查询\">#</a> 子查询</h4>\n<p>子查询是嵌套在较大查询中的 SQL 查询，也称内部查询或内部选择，包含子查询的语句也称为外部查询或外部选择。简单来说，子查询就是指<font color='red'>将一个  <code>select</code>  查询（子查询）的结果作为另一个 SQL 语句（主查询）的<u>数据来源</u>或者<u>判断条件</u></font>。</p>\n<p>子查询可以嵌入  <code>SELECT</code> 、 <code>INSERT</code> 、 <code>UPDATE</code>  和  <code>DELETE</code>  语句中，也可以和  <code>=</code> 、 <code>&lt;</code> 、 <code>&gt;</code> 、 <code>IN</code> 、 <code>BETWEEN</code> 、 <code>EXISTS</code>  等运算符一起使用。</p>\n<p>子查询常用在  <code>WHERE</code>  子句和  <code>FROM</code>  子句后边：</p>\n<ul>\n<li>\n<p>当用于 <strong> <code>WHERE</code> </strong> 子句后边时，根据不同的运算符，子查询可以返回单行单列、多行单列、单行多列数据。子查询就是要<font color='red'>返回能够作为  <code>WHERE</code>  子句查询条件的值</font>。</p>\n<blockquote>\n<p>用于  <code>WHERE</code>  子句的子查询的基本语法如下：</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">select</span> column_name <span class=\"token punctuation\">[</span><span class=\"token punctuation\">,</span> column_name <span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">from</span>   table1 <span class=\"token punctuation\">[</span><span class=\"token punctuation\">,</span> table2 <span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">where</span>  column_name operator</pre></td></tr><tr><td data-num=\"4\"></td><td><pre> <span class=\"token punctuation\">(</span><span class=\"token keyword\">select</span> column_name <span class=\"token punctuation\">[</span><span class=\"token punctuation\">,</span> column_name <span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre> <span class=\"token keyword\">from</span> table1 <span class=\"token punctuation\">[</span><span class=\"token punctuation\">,</span> table2 <span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre> <span class=\"token punctuation\">[</span><span class=\"token keyword\">where</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><ul>\n<li>子查询需要放在括号 <code>( )</code>  内。</li>\n<li><code>operator</code>  表示用于 where 子句的运算符。</li>\n</ul>\n</blockquote>\n</li>\n<li>\n<p>当用于 <strong> <code>FROM</code> </strong> 子句后边时，一般返回多行多列数据，相当于<font color='red'>返回一张临时表</font>，这样才符合  <code>FROM</code>  后面是表的规则。这种做法能够实现<font color='red'>多表联合查询</font>。</p>\n<blockquote>\n<p>用于  <code>FROM</code>  子句的子查询的基本语法如下：</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">select</span> column_name <span class=\"token punctuation\">[</span><span class=\"token punctuation\">,</span> column_name <span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">from</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">select</span> column_name <span class=\"token punctuation\">[</span><span class=\"token punctuation\">,</span> column_name <span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>   <span class=\"token keyword\">from</span> table1 <span class=\"token punctuation\">[</span><span class=\"token punctuation\">,</span> table2 <span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>   <span class=\"token punctuation\">[</span><span class=\"token keyword\">where</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">as</span> temp_table_name</pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">where</span>  condition</pre></td></tr></table></figure><p>用于  <code>FROM</code>  的子查询返回的结果相当于一张临时表，所以<strong>需要使用  <code>AS</code>  关键字为该临时表起一个名字</strong>。</p>\n</blockquote>\n</li>\n</ul>\n<blockquote>\n<p>注意：MYSQL 数据库从 4.1 版本才开始支持子查询，早期版本是不支持的。</p>\n</blockquote>\n<p><strong>子查询的子查询</strong></p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">SELECT</span> cust_name<span class=\"token punctuation\">,</span> cust_contact</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">FROM</span> customers</pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">WHERE</span> cust_id <span class=\"token operator\">IN</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">SELECT</span> cust_id</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>                  <span class=\"token keyword\">FROM</span> orders</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>                  <span class=\"token keyword\">WHERE</span> order_num <span class=\"token operator\">IN</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">SELECT</span> order_num</pre></td></tr><tr><td data-num=\"6\"></td><td><pre>                                      <span class=\"token keyword\">FROM</span> orderitems</pre></td></tr><tr><td data-num=\"7\"></td><td><pre>                                      <span class=\"token keyword\">WHERE</span> prod_id <span class=\"token operator\">=</span> <span class=\"token string\">'RGAN01'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>内部查询首先在其父查询之前执行，以便可以将内部查询的结果传递给外部查询。执行过程可以参考下图：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/c439da1f5d4e4b00bdfa4316b933d764%7Etplv-k3u1fbpfcp-zoom-1.image\" alt=\"img\" /></p>\n<h5 id=\"where\"><a class=\"anchor\" href=\"#where\">#</a> WHERE</h5>\n<ul>\n<li><code>WHERE</code>  子句用于过滤记录，即缩小访问数据的范围。</li>\n<li><code>WHERE</code>  后跟一个返回  <code>true</code>  或  <code>false</code>  的条件。</li>\n<li><code>WHERE</code>  可以与  <code>SELECT</code> ， <code>UPDATE</code>  和  <code>DELETE</code>  一起使用。</li>\n<li>可以在  <code>WHERE</code>  子句中使用的操作符。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>运算符</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>=</td>\n<td>等于</td>\n</tr>\n<tr>\n<td>&lt;&gt;</td>\n<td>不等于。注释：在 SQL 的一些版本中，该操作符可被写成！=</td>\n</tr>\n<tr>\n<td>&gt;</td>\n<td>大于</td>\n</tr>\n<tr>\n<td>&lt;</td>\n<td>小于</td>\n</tr>\n<tr>\n<td>&gt;=</td>\n<td>大于等于</td>\n</tr>\n<tr>\n<td>&lt;=</td>\n<td>小于等于</td>\n</tr>\n<tr>\n<td>BETWEEN</td>\n<td>在某个范围内</td>\n</tr>\n<tr>\n<td>LIKE</td>\n<td>搜索某种模式</td>\n</tr>\n<tr>\n<td>IN</td>\n<td>指定针对某个列的多个可能值</td>\n</tr>\n</tbody>\n</table>\n<p><strong> <code>SELECT</code>  语句中的  <code>WHERE</code>  子句</strong></p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> Customers</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">WHERE</span> cust_name <span class=\"token operator\">=</span> <span class=\"token string\">'Kids Place'</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p><strong> <code>UPDATE</code>  语句中的  <code>WHERE</code>  子句</strong></p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">UPDATE</span> Customers</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">SET</span> cust_name <span class=\"token operator\">=</span> <span class=\"token string\">'Jack Jones'</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">WHERE</span> cust_name <span class=\"token operator\">=</span> <span class=\"token string\">'Kids Place'</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p><strong> <code>DELETE</code>  语句中的  <code>WHERE</code>  子句</strong></p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">DELETE</span> <span class=\"token keyword\">FROM</span> Customers</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">WHERE</span> cust_name <span class=\"token operator\">=</span> <span class=\"token string\">'Kids Place'</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h5 id=\"in-和-between\"><a class=\"anchor\" href=\"#in-和-between\">#</a> IN 和 BETWEEN</h5>\n<ul>\n<li><code>IN</code>  操作符在  <code>WHERE</code>  子句中使用，作用是<font color='red'>在指定的几个特定值中任选一个值</font>。</li>\n<li><code>BETWEEN</code>  操作符在  <code>WHERE</code>  子句中使用，作用是<font color='red'>选取介于某个范围内的值</font>。</li>\n</ul>\n<p><strong>IN 示例</strong></p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">FROM</span> products</pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">WHERE</span> vend_id <span class=\"token operator\">IN</span> <span class=\"token punctuation\">(</span><span class=\"token string\">'DLL01'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'BRS01'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p><strong>BETWEEN 示例</strong></p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">FROM</span> products</pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">WHERE</span> prod_price <span class=\"token operator\">BETWEEN</span> <span class=\"token number\">3</span> <span class=\"token operator\">AND</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h5 id=\"and-or-not\"><a class=\"anchor\" href=\"#and-or-not\">#</a> AND、OR、NOT</h5>\n<ul>\n<li><code>AND</code> 、 <code>OR</code> 、 <code>NOT</code>  是用于对过滤条件的逻辑处理指令。</li>\n<li><font color='red'> <code>AND</code>  优先级高于  <code>OR</code> </font>，为了明确处理顺序，可以使用  <code>()</code> 。</li>\n<li><code>AND</code>  操作符表示左右条件都要满足。</li>\n<li><code>OR</code>  操作符表示左右条件满足任意一个即可。</li>\n<li><code>NOT</code>  操作符用于否定一个条件。</li>\n</ul>\n<p><strong>AND 示例</strong></p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">SELECT</span> prod_id<span class=\"token punctuation\">,</span> prod_name<span class=\"token punctuation\">,</span> prod_price</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">FROM</span> products</pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">WHERE</span> vend_id <span class=\"token operator\">=</span> <span class=\"token string\">'DLL01'</span> <span class=\"token operator\">AND</span> prod_price <span class=\"token operator\">&lt;=</span> <span class=\"token number\">4</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p><strong>OR 示例</strong></p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">SELECT</span> prod_id<span class=\"token punctuation\">,</span> prod_name<span class=\"token punctuation\">,</span> prod_price</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">FROM</span> products</pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">WHERE</span> vend_id <span class=\"token operator\">=</span> <span class=\"token string\">'DLL01'</span> <span class=\"token operator\">OR</span> vend_id <span class=\"token operator\">=</span> <span class=\"token string\">'BRS01'</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p><strong>NOT 示例</strong></p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">FROM</span> products</pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">WHERE</span> prod_price <span class=\"token operator\">NOT</span> <span class=\"token operator\">BETWEEN</span> <span class=\"token number\">3</span> <span class=\"token operator\">AND</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h5 id=\"like\"><a class=\"anchor\" href=\"#like\">#</a> LIKE</h5>\n<ul>\n<li><code>LIKE</code>  操作符在  <code>WHERE</code>  子句中使用，作用是<font color='red'>确定字符串是否匹配模式</font>。</li>\n<li>只有字段是文本值时才使用  <code>LIKE</code> 。</li>\n<li><code>LIKE</code>  支持两个通配符匹配选项： <code>%</code>  和  <code>_</code> 。</li>\n<li>不要滥用通配符，通配符位于开头处匹配会非常慢。</li>\n<li><code>%</code>  表示任何字符<font color='red'>出现任意次数</font>。</li>\n<li><code>_</code>  表示任何字符<font color='red'>出现一次</font>。</li>\n</ul>\n<p><strong>% 示例</strong></p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">SELECT</span> prod_id<span class=\"token punctuation\">,</span> prod_name<span class=\"token punctuation\">,</span> prod_price</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">FROM</span> products</pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">WHERE</span> prod_name <span class=\"token operator\">LIKE</span> <span class=\"token string\">'%bean bag%'</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p><strong>_ 示例</strong></p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">SELECT</span> prod_id<span class=\"token punctuation\">,</span> prod_name<span class=\"token punctuation\">,</span> prod_price</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">FROM</span> products</pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">WHERE</span> prod_name <span class=\"token operator\">LIKE</span> <span class=\"token string\">'__ inch teddy bear'</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h4 id=\"连接\"><a class=\"anchor\" href=\"#连接\">#</a> 连接</h4>\n<h5 id=\"简介-2\"><a class=\"anchor\" href=\"#简介-2\">#</a> 简介</h5>\n<p><code>JOIN</code>  是 “连接” 的意思，顾名思义，SQL JOIN 子句用于将两个或者多个表联合起来进行查询。</p>\n<p>连接表时<font color='red'>需要在每个表中选择一个字段，并对这些字段的值进行比较，值相同的两条记录将合并为一条</font>。<strong>连接表的本质就是将不同表的记录合并起来，形成一张新表。当然，这张新表只是临时的，它仅存在于本次查询期间</strong>。</p>\n<h5 id=\"语法-2\"><a class=\"anchor\" href=\"#语法-2\">#</a> 语法</h5>\n<p>使用  <code>JOIN</code>  连接两个表的基本语法如下：</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">select</span> table1<span class=\"token punctuation\">.</span>column1<span class=\"token punctuation\">,</span> table2<span class=\"token punctuation\">.</span>column2<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">from</span> table1 <span class=\"token keyword\">join</span> table2</pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">on</span> table1<span class=\"token punctuation\">.</span>common_column1 <span class=\"token operator\">=</span> table2<span class=\"token punctuation\">.</span>common_column2<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p><code>table1.common_column1 = table2.common_column2</code>  是<font color='red'>连接条件</font>，只有满足此条件的记录才会合并为一行。您可以使用多个运算符来连接表，例如 =、&gt;、&lt;、&lt;&gt;、&lt;=、&gt;=、!=、 <code>between</code> 、 <code>like</code>  或者  <code>not</code> ，但是最常见的是使用 =。</p>\n<p><font color='red'>当两个表中有同名的字段时，为了帮助数据库引擎区分是哪个表的字段，在书写同名字段名时需要加上表名</font>。当然，如果书写的字段名在两个表中是唯一的，也可以不使用以上格式，只写字段名即可。</p>\n<p>另外，<font color='red'>如果两张表的关联字段名相同，也可以使用  <code>USING</code>  子句来代替  <code>ON</code> </font>，举个例子：</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># join....on</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">select</span> c<span class=\"token punctuation\">.</span>cust_name<span class=\"token punctuation\">,</span> o<span class=\"token punctuation\">.</span>order_num</pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">from</span> Customers c <span class=\"token keyword\">inner</span> <span class=\"token keyword\">join</span> Orders o</pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">on</span> c<span class=\"token punctuation\">.</span>cust_id <span class=\"token operator\">=</span> o<span class=\"token punctuation\">.</span>cust_id</pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">order</span> <span class=\"token keyword\">by</span> c<span class=\"token punctuation\">.</span>cust_name<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token comment\"># 如果两张表的关联字段名相同，也可以使用 USING 子句：join....using ()</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token keyword\">select</span> c<span class=\"token punctuation\">.</span>cust_name<span class=\"token punctuation\">,</span> o<span class=\"token punctuation\">.</span>order_num</pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token keyword\">from</span> Customers c <span class=\"token keyword\">inner</span> <span class=\"token keyword\">join</span> Orders o</pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token keyword\">using</span><span class=\"token punctuation\">(</span>cust_id<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token keyword\">order</span> <span class=\"token keyword\">by</span> c<span class=\"token punctuation\">.</span>cust_name<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p><strong> <code>ON</code>  和  <code>WHERE</code>  的区别</strong>：</p>\n<ul>\n<li>连接表时，SQL 会根据连接条件生成一张新的临时表。<font color='red'> <code>ON</code>  是连接条件</font>，它决定临时表的生成。</li>\n<li><code>WHERE</code>  是在临时表生成以后，再对临时表中的数据进行过滤，生成最终的结果集，这个时候已经没有 JOIN-ON 了。</li>\n</ul>\n<p>所以总结来说就是：<strong><font color='#B32015'>SQL 先根据 ON 生成一张临时表，然后再根据 WHERE 对临时表进行筛选</font></strong>。</p>\n<h5 id=\"分类-2\"><a class=\"anchor\" href=\"#分类-2\">#</a> 分类</h5>\n<p>SQL 允许在  <code>JOIN</code>  左边加上一些修饰性的关键词，从而形成不同类型的连接，如下表所示：</p>\n<table>\n<thead>\n<tr>\n<th>连接类型</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>(INNER) JOIN</code> ：内连接</td>\n<td>（<strong>默认连接方式</strong>）只有当<font color='red'>两个表都存在满足条件</font>的记录时才会返回行。</td>\n</tr>\n<tr>\n<td><code>LEFT (OUTER) JOIN</code> ：左 (外) 连接</td>\n<td>以左表为基础，将左表中的所有记录与右表进行连接。即使右表中没有与左表匹配的记录，左连接仍然会 **<font color='red'>返回左表中的所有记录，而右表中未匹配的对应列值则为 NULL</font>**.</td>\n</tr>\n<tr>\n<td><code>RIGHT (OUTER) JOIN</code> ：右 (外) 连接</td>\n<td>以右表为基础，将右表中的所有记录与左表进行连接。即使左表中没有与右表匹配的记录，右连接仍然会 **<font color='red'>返回右表中的所有记录，而左表中未匹配的对应列值则为 NULL</font>**。</td>\n</tr>\n<tr>\n<td><code>FULL (OUTER) JOIN</code> ：全 (外) 连接</td>\n<td>只要<font color='red'>其中有一个表存在满足条件</font>的记录，就返回行。</td>\n</tr>\n<tr>\n<td><code>SELF JOIN</code> ：自连接</td>\n<td><font color='red'>将一个表连接到自身</font>，就像该表是两个表一样。为了区分两个表，在 SQL 语句中需要至少重命名一个表。</td>\n</tr>\n<tr>\n<td><code>CROSS JOIN</code> ：交叉连接</td>\n<td>从两个或者多个连接表中返回记录集的<font color='red'>笛卡尔积</font>。</td>\n</tr>\n</tbody>\n</table>\n<p>下图展示了 LEFT JOIN、RIGHT JOIN、INNER JOIN、OUTER JOIN 相关的 7 种用法。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/701670942f0f45d3a3a2187cd04a12ad~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"\" /></p>\n<p>对于  <code>(INNER) JOIN</code>  来说，还有一种隐式的写法，称为 “<strong>隐式内连接</strong>”，也就是没有  <code>(INNER) JOIN</code>  关键字，使用  <code>WHERE</code>  语句实现内连接的功能</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># 隐式内连接</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">select</span> c<span class=\"token punctuation\">.</span>cust_name<span class=\"token punctuation\">,</span> o<span class=\"token punctuation\">.</span>order_num</pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">from</span> Customers c<span class=\"token punctuation\">,</span> Orders o</pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">where</span> c<span class=\"token punctuation\">.</span>cust_id <span class=\"token operator\">=</span> o<span class=\"token punctuation\">.</span>cust_id</pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">order</span> <span class=\"token keyword\">by</span> c<span class=\"token punctuation\">.</span>cust_name<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token comment\"># 显式内连接</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token keyword\">select</span> c<span class=\"token punctuation\">.</span>cust_name<span class=\"token punctuation\">,</span> o<span class=\"token punctuation\">.</span>order_num</pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token keyword\">from</span> Customers c <span class=\"token keyword\">inner</span> <span class=\"token keyword\">join</span> Orders o</pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token keyword\">using</span><span class=\"token punctuation\">(</span>cust_id<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token keyword\">order</span> <span class=\"token keyword\">by</span> c<span class=\"token punctuation\">.</span>cust_name<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h4 id=\"组合\"><a class=\"anchor\" href=\"#组合\">#</a> 组合</h4>\n<p><code>UNION</code>  运算符<font color='red'>将两个或更多查询的结果组合起来，并生成一个结果集</font>，其中包含来自  <code>UNION</code>  中参与查询的提取行。</p>\n<p><code>UNION</code>  基本规则：</p>\n<ul>\n<li>所有查询的<font color='red'>列数和列顺序必须相同</font>。</li>\n<li>每个查询中涉及表的<font color='red'>列的数据类型必须相同或兼容</font>。</li>\n<li>通常<font color='red'>返回的列名取自第一个查询</font>。</li>\n</ul>\n<p>默认地， <code>UNION</code>  操作符选取不同的值。如果允许重复的值，请使用  <code>UNION ALL</code> 。</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">SELECT</span> column_name<span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span> <span class=\"token keyword\">FROM</span> table1</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">UNION</span> <span class=\"token keyword\">ALL</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">SELECT</span> column_name<span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span> <span class=\"token keyword\">FROM</span> table2<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p><code>UNION</code>  结果集中的列名总是等于  <code>UNION</code>  中第一个  <code>SELECT</code>  语句中的列名。</p>\n<p><code>JOIN</code>  vs  <code>UNION</code> ：</p>\n<ul>\n<li><code>JOIN</code>  中连接表的列可能不同，但在  <code>UNION</code>  中，所有查询的列数和列顺序必须相同。</li>\n<li><code>UNION</code>  将查询之后的行放在一起（<font color='red'>垂直放置</font>），但  <code>JOIN</code>  将查询之后的列放在一起（水平放置），即它构成一个笛卡尔积。</li>\n</ul>\n<h4 id=\"函数\"><a class=\"anchor\" href=\"#函数\">#</a> 函数</h4>\n<p>不同数据库的函数往往各不相同，因此不可移植。本节主要<font color='red'>以 MysSQL 的函数为例</font>。</p>\n<h5 id=\"文本处理\"><a class=\"anchor\" href=\"#文本处理\">#</a> 文本处理</h5>\n<table>\n<thead>\n<tr>\n<th>函数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>LEFT()</code> 、 <code>RIGHT()</code></td>\n<td>左边或者右边的字符</td>\n</tr>\n<tr>\n<td><code>LOWER()</code> 、 <code>UPPER()</code></td>\n<td>转换为小写或者大写</td>\n</tr>\n<tr>\n<td><code>LTRIM()</code> 、 <code>RTRIM()</code></td>\n<td>去除左边或者右边的空格</td>\n</tr>\n<tr>\n<td><code>LENGTH()</code></td>\n<td>长度</td>\n</tr>\n<tr>\n<td><code>SOUNDEX()</code></td>\n<td><font color='red'>转换为语音值</font></td>\n</tr>\n</tbody>\n</table>\n<p>其中， <strong> <code>SOUNDEX()</code> </strong> 可以将一个字符串转换为描述其语音表示的字母数字模式。</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">FROM</span> mytable</pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">WHERE</span> SOUNDEX<span class=\"token punctuation\">(</span>col1<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> SOUNDEX<span class=\"token punctuation\">(</span><span class=\"token string\">'apple'</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><h5 id=\"日期和时间处理\"><a class=\"anchor\" href=\"#日期和时间处理\">#</a> 日期和时间处理</h5>\n<ul>\n<li>日期格式： <code>YYYY-MM-DD</code></li>\n<li>时间格式： <code>HH:MM:SS</code></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>函 数</th>\n<th>说 明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>AddDate()</code></td>\n<td>增加一个日期（天、周等）</td>\n</tr>\n<tr>\n<td><code>AddTime()</code></td>\n<td>增加一个时间（时、分等）</td>\n</tr>\n<tr>\n<td><code>CurDate()</code></td>\n<td>返回当前日期</td>\n</tr>\n<tr>\n<td><code>CurTime()</code></td>\n<td>返回当前时间</td>\n</tr>\n<tr>\n<td><code>Date()</code></td>\n<td>返回日期时间的日期部分</td>\n</tr>\n<tr>\n<td><code>DateDiff()</code></td>\n<td>计算两个日期之差</td>\n</tr>\n<tr>\n<td><code>Date_Add()</code></td>\n<td>高度灵活的日期运算函数</td>\n</tr>\n<tr>\n<td><code>Date_Format()</code></td>\n<td>返回一个格式化的日期或时间串</td>\n</tr>\n<tr>\n<td><code>Day()</code></td>\n<td>返回一个日期的天数部分</td>\n</tr>\n<tr>\n<td><code>DayOfWeek()</code></td>\n<td>对于一个日期，返回对应的星期几</td>\n</tr>\n<tr>\n<td><code>Hour()</code></td>\n<td>返回一个时间的小时部分</td>\n</tr>\n<tr>\n<td><code>Minute()</code></td>\n<td>返回一个时间的分钟部分</td>\n</tr>\n<tr>\n<td><code>Month()</code></td>\n<td>返回一个日期的月份部分</td>\n</tr>\n<tr>\n<td><code>Now()</code></td>\n<td>返回当前日期和时间</td>\n</tr>\n<tr>\n<td><code>Second()</code></td>\n<td>返回一个时间的秒部分</td>\n</tr>\n<tr>\n<td><code>Time()</code></td>\n<td>返回一个日期时间的时间部分</td>\n</tr>\n<tr>\n<td><code>Year()</code></td>\n<td>返回一个日期的年份部分</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"数值处理\"><a class=\"anchor\" href=\"#数值处理\">#</a> 数值处理</h5>\n<table>\n<thead>\n<tr>\n<th>函数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>SIN()</td>\n<td>正弦</td>\n</tr>\n<tr>\n<td>COS()</td>\n<td>余弦</td>\n</tr>\n<tr>\n<td>TAN()</td>\n<td>正切</td>\n</tr>\n<tr>\n<td>ABS()</td>\n<td>绝对值</td>\n</tr>\n<tr>\n<td>SQRT()</td>\n<td>平方根</td>\n</tr>\n<tr>\n<td>MOD()</td>\n<td>余数</td>\n</tr>\n<tr>\n<td>EXP()</td>\n<td>指数</td>\n</tr>\n<tr>\n<td>PI()</td>\n<td>圆周率</td>\n</tr>\n<tr>\n<td>RAND()</td>\n<td>随机数</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"汇总\"><a class=\"anchor\" href=\"#汇总\">#</a> 汇总</h5>\n<table>\n<thead>\n<tr>\n<th>函 数</th>\n<th>说 明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>AVG()</code></td>\n<td>返回某列的平均值</td>\n</tr>\n<tr>\n<td><code>COUNT()</code></td>\n<td>返回某列的行数</td>\n</tr>\n<tr>\n<td><code>MAX()</code></td>\n<td>返回某列的最大值</td>\n</tr>\n<tr>\n<td><code>MIN()</code></td>\n<td>返回某列的最小值</td>\n</tr>\n<tr>\n<td><code>SUM()</code></td>\n<td>返回某列值之和</td>\n</tr>\n</tbody>\n</table>\n<p><code>AVG()</code>  会忽略 NULL 行。</p>\n<p>使用  <code>DISTINCT</code>  可以让汇总函数值汇总不同的值。</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">SELECT</span> <span class=\"token function\">AVG</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">DISTINCT</span> col1<span class=\"token punctuation\">)</span> <span class=\"token keyword\">AS</span> avg_col</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">FROM</span> mytable</pre></td></tr></table></figure><p><strong>接下来，我们来介绍 DDL 语句用法。DDL 的主要功能是定义数据库对象（如：数据库、数据表、视图、索引等）</strong></p>\n<h4 id=\"数据定义\"><a class=\"anchor\" href=\"#数据定义\">#</a> <mark>数据定义</mark></h4>\n<h5 id=\"数据库database\"><a class=\"anchor\" href=\"#数据库database\">#</a> 数据库（DATABASE）</h5>\n<h6 id=\"创建数据库\"><a class=\"anchor\" href=\"#创建数据库\">#</a> 创建数据库</h6>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">DATABASE</span> test<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h6 id=\"删除数据库\"><a class=\"anchor\" href=\"#删除数据库\">#</a> 删除数据库</h6>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">DROP</span> <span class=\"token keyword\">DATABASE</span> test<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h6 id=\"选择数据库\"><a class=\"anchor\" href=\"#选择数据库\">#</a> 选择数据库</h6>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">USE</span> test<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h5 id=\"数据表table\"><a class=\"anchor\" href=\"#数据表table\">#</a> 数据表（TABLE）</h5>\n<h6 id=\"创建数据表\"><a class=\"anchor\" href=\"#创建数据表\">#</a> 创建数据表</h6>\n<p><strong>普通创建</strong></p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">TABLE</span> <span class=\"token keyword\">user</span> <span class=\"token punctuation\">(</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>  id <span class=\"token keyword\">int</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">unsigned</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span> <span class=\"token keyword\">COMMENT</span> <span class=\"token string\">'Id'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>  username <span class=\"token keyword\">varchar</span><span class=\"token punctuation\">(</span><span class=\"token number\">64</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span> <span class=\"token keyword\">DEFAULT</span> <span class=\"token string\">'default'</span> <span class=\"token keyword\">COMMENT</span> <span class=\"token string\">'用户名'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>  password <span class=\"token keyword\">varchar</span><span class=\"token punctuation\">(</span><span class=\"token number\">64</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span> <span class=\"token keyword\">DEFAULT</span> <span class=\"token string\">'default'</span> <span class=\"token keyword\">COMMENT</span> <span class=\"token string\">'密码'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>  email <span class=\"token keyword\">varchar</span><span class=\"token punctuation\">(</span><span class=\"token number\">64</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span> <span class=\"token keyword\">DEFAULT</span> <span class=\"token string\">'default'</span> <span class=\"token keyword\">COMMENT</span> <span class=\"token string\">'邮箱'</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token punctuation\">)</span> <span class=\"token keyword\">COMMENT</span><span class=\"token operator\">=</span><span class=\"token string\">'用户表'</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p><strong>根据已有的表创建新表</strong></p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">TABLE</span> vip_user <span class=\"token keyword\">AS</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> <span class=\"token keyword\">user</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h6 id=\"删除数据表\"><a class=\"anchor\" href=\"#删除数据表\">#</a> 删除数据表</h6>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">DROP</span> <span class=\"token keyword\">TABLE</span> <span class=\"token keyword\">user</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h6 id=\"修改数据表\"><a class=\"anchor\" href=\"#修改数据表\">#</a> 修改数据表</h6>\n<p><strong>添加列</strong></p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">ALTER</span> <span class=\"token keyword\">TABLE</span> <span class=\"token keyword\">user</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">ADD</span> age <span class=\"token keyword\">int</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p><strong>删除列</strong></p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">ALTER</span> <span class=\"token keyword\">TABLE</span> <span class=\"token keyword\">user</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">DROP</span> <span class=\"token keyword\">COLUMN</span> age<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p><strong>修改列</strong></p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">ALTER</span> <span class=\"token keyword\">TABLE</span> <span class=\"token identifier\"><span class=\"token punctuation\">`</span>user<span class=\"token punctuation\">`</span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">MODIFY</span> <span class=\"token keyword\">COLUMN</span> age <span class=\"token keyword\">tinyint</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p><strong>添加主键</strong></p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">ALTER</span> <span class=\"token keyword\">TABLE</span> <span class=\"token keyword\">user</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">ADD</span> <span class=\"token keyword\">PRIMARY</span> <span class=\"token keyword\">KEY</span> <span class=\"token punctuation\">(</span>id<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p><strong>删除主键</strong></p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">ALTER</span> <span class=\"token keyword\">TABLE</span> <span class=\"token keyword\">user</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">DROP</span> <span class=\"token keyword\">PRIMARY</span> <span class=\"token keyword\">KEY</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h5 id=\"视图view\"><a class=\"anchor\" href=\"#视图view\">#</a> 视图（VIEW）</h5>\n<p>定义：</p>\n<ul>\n<li>视图是基于 SQL 语句的结果集的可视化的表。</li>\n<li>视图是<strong>虚拟的表，本身不包含数据</strong>，也就不能对其进行索引操作。对视图的操作和对普通表的操作一样。</li>\n</ul>\n<p>作用：</p>\n<ul>\n<li>简化复杂的 SQL 操作，比如复杂的联结；</li>\n<li>只使用实际表的一部分数据；</li>\n<li><font color='red'>通过只给用户访问视图的权限，保证数据的安全性</font>；</li>\n<li>更改数据格式和表示。</li>\n</ul>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/ec4c975296ea4a7097879dac7c353878%7Etplv-k3u1fbpfcp-zoom-1.image\" alt=\"mysql视图\" /></p>\n<h6 id=\"创建视图\"><a class=\"anchor\" href=\"#创建视图\">#</a> 创建视图</h6>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">VIEW</span> top_10_user_view <span class=\"token keyword\">AS</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">SELECT</span> id<span class=\"token punctuation\">,</span> username</pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">FROM</span> <span class=\"token keyword\">user</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">WHERE</span> id <span class=\"token operator\">&lt;</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h6 id=\"删除视图\"><a class=\"anchor\" href=\"#删除视图\">#</a> 删除视图</h6>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">DROP</span> <span class=\"token keyword\">VIEW</span> top_10_user_view<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h5 id=\"索引index\"><a class=\"anchor\" href=\"#索引index\">#</a> 索引（INDEX）</h5>\n<p><strong>索引是一种用于快速查询和检索数据的数据结构，其本质可以看成是一种排序好的数据结构。</strong></p>\n<p>索引的作用就<font color='red'>相当于书的目录</font>。打个比方：我们在查字典的时候，如果没有目录，那我们就只能一页一页的去找我们需要查的那个字，速度很慢。如果有目录了，我们只需要先去目录里查找字的位置，然后直接翻到那一页就行了。</p>\n<p><strong>优点</strong> ：</p>\n<ul>\n<li>使用索引可以大大<font color='red'>加快数据的检索速度</font>（大大减少检索的数据量）, 这也是创建索引的最主要的原因。</li>\n<li>通过创建<font color='red'>唯一性索引，可以保证数据库表中每一行数据的唯一性</font>。</li>\n</ul>\n<p><strong>缺点</strong> ：</p>\n<ul>\n<li>创建索引和维护索引需要耗费许多时间。当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低 SQL 执行效率。</li>\n<li>索引需要使用物理文件存储，也会耗费一定空间。</li>\n</ul>\n<p>但是，<strong>使用索引一定能提高查询性能吗？</strong></p>\n<p>大多数情况下，索引查询都是比全表扫描要快的。但是<font color='red'>如果数据库的数据量不大，那么使用索引也不一定能够带来很大提升</font>。</p>\n<p>关于索引的详细介绍，请看我写的 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9qYXZhZ3VpZGUuY24vZGF0YWJhc2UvbXlzcWwvbXlzcWwtaW5kZXguaHRtbA==\">MySQL 索引详解 open in new window</span> 这篇文章。</p>\n<h6 id=\"创建索引\"><a class=\"anchor\" href=\"#创建索引\">#</a> 创建索引</h6>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">INDEX</span> user_index</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">ON</span> <span class=\"token keyword\">user</span> <span class=\"token punctuation\">(</span>id<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h6 id=\"添加索引\"><a class=\"anchor\" href=\"#添加索引\">#</a> 添加索引</h6>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">ALTER</span> <span class=\"token keyword\">table</span> <span class=\"token keyword\">user</span> <span class=\"token keyword\">ADD</span> <span class=\"token keyword\">INDEX</span> user_index<span class=\"token punctuation\">(</span>id<span class=\"token punctuation\">)</span></pre></td></tr></table></figure><h6 id=\"创建唯一索引\"><a class=\"anchor\" href=\"#创建唯一索引\">#</a> 创建唯一索引</h6>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">UNIQUE</span> <span class=\"token keyword\">INDEX</span> user_index</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">ON</span> <span class=\"token keyword\">user</span> <span class=\"token punctuation\">(</span>id<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h6 id=\"删除索引\"><a class=\"anchor\" href=\"#删除索引\">#</a> 删除索引</h6>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">ALTER</span> <span class=\"token keyword\">TABLE</span> <span class=\"token keyword\">user</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">DROP</span> <span class=\"token keyword\">INDEX</span> user_index<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h5 id=\"约束\"><a class=\"anchor\" href=\"#约束\">#</a> 约束</h5>\n<p>SQL 约束<strong>用于规定表中的数据规则</strong>。</p>\n<p>如果存在违反约束的数据行为，行为会被约束终止。</p>\n<p>约束可以在创建表时规定（通过 CREATE TABLE 语句），或者在表创建之后规定（通过 ALTER TABLE 语句）。</p>\n<p>约束类型：</p>\n<ul>\n<li><code>NOT NULL</code>  - 指示某列不能存储 NULL 值。</li>\n<li><code>UNIQUE</code>  - 保证某列的每行必须有唯一的值。</li>\n<li><code>PRIMARY KEY</code>  - NOT NULL 和 UNIQUE 的结合。确保某列（或两个列多个列的结合）有唯一标识，有助于更容易更快速地找到表中的一个特定的记录。</li>\n<li><code>FOREIGN KEY</code>  - 保证一个表中的数据匹配另一个表中的值的参照完整性。</li>\n<li><code>CHECK</code>  - 保证列中的值符合指定的条件。</li>\n<li><code>DEFAULT</code>  - 规定没有给列赋值时的默认值。</li>\n</ul>\n<p>创建表时使用约束条件：</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">TABLE</span> Users <span class=\"token punctuation\">(</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>  Id <span class=\"token keyword\">INT</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">UNSIGNED</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span> <span class=\"token keyword\">AUTO_INCREMENT</span> <span class=\"token keyword\">COMMENT</span> <span class=\"token string\">'自增Id'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>  Username <span class=\"token keyword\">VARCHAR</span><span class=\"token punctuation\">(</span><span class=\"token number\">64</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span> <span class=\"token keyword\">UNIQUE</span> <span class=\"token keyword\">DEFAULT</span> <span class=\"token string\">'default'</span> <span class=\"token keyword\">COMMENT</span> <span class=\"token string\">'用户名'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>  Password <span class=\"token keyword\">VARCHAR</span><span class=\"token punctuation\">(</span><span class=\"token number\">64</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span> <span class=\"token keyword\">DEFAULT</span> <span class=\"token string\">'default'</span> <span class=\"token keyword\">COMMENT</span> <span class=\"token string\">'密码'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>  Email <span class=\"token keyword\">VARCHAR</span><span class=\"token punctuation\">(</span><span class=\"token number\">64</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span> <span class=\"token keyword\">DEFAULT</span> <span class=\"token string\">'default'</span> <span class=\"token keyword\">COMMENT</span> <span class=\"token string\">'邮箱地址'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>  Enabled <span class=\"token keyword\">TINYINT</span><span class=\"token punctuation\">(</span><span class=\"token number\">4</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">DEFAULT</span> <span class=\"token boolean\">NULL</span> <span class=\"token keyword\">COMMENT</span> <span class=\"token string\">'是否有效'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>  <span class=\"token keyword\">PRIMARY</span> <span class=\"token keyword\">KEY</span> <span class=\"token punctuation\">(</span>Id<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token punctuation\">)</span> <span class=\"token keyword\">ENGINE</span><span class=\"token operator\">=</span><span class=\"token keyword\">InnoDB</span> <span class=\"token keyword\">AUTO_INCREMENT</span><span class=\"token operator\">=</span><span class=\"token number\">2</span> <span class=\"token keyword\">DEFAULT</span> <span class=\"token keyword\">CHARSET</span><span class=\"token operator\">=</span>utf8mb4 <span class=\"token keyword\">COMMENT</span><span class=\"token operator\">=</span><span class=\"token string\">'用户表'</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p><strong>接下来，我们来介绍 TCL 语句用法。TCL 的主要功能是管理数据库中的事务。</strong></p>\n<h4 id=\"事务处理\"><a class=\"anchor\" href=\"#事务处理\">#</a> 事务处理</h4>\n<p>不能回退  <code>SELECT</code>  语句，回退  <code>SELECT</code>  语句也没意义；也不能回退  <code>CREATE</code>  和  <code>DROP</code>  语句。</p>\n<p><strong>MySQL 默认是隐式提交</strong>，每执行一条语句就把这条语句当成一个事务然后进行提交。当出现  <code>START TRANSACTION</code>  语句时，会关闭隐式提交；当  <code>COMMIT</code>  或  <code>ROLLBACK</code>  语句执行后，事务会自动关闭，重新恢复隐式提交。</p>\n<p>通过  <code>set autocommit=0</code>  可以取消自动提交，直到  <code>set autocommit=1</code>  才会提交；<font color='red'> <code>autocommit</code>  标记是针对每个连接而不是针对服务器的</font>。</p>\n<p>指令：</p>\n<ul>\n<li><code>START TRANSACTION</code>  - 指令用于<font color='red'>标记事务的起始点</font>。</li>\n<li><code>SAVEPOINT</code>  - 指令用于<font color='red'>创建保留点</font>。</li>\n<li><code>ROLLBACK TO</code>  - 指令用于<font color='red'>回滚到指定的保留点</font>；如果没有设置保留点，则回退到  <code>START TRANSACTION</code>  语句处。</li>\n<li><code>COMMIT</code>  - <font color='red'>提交事务</font>。</li>\n</ul>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">-- 开始事务</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">START</span> <span class=\"token keyword\">TRANSACTION</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token comment\">-- 插入操作 A</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">INSERT</span> <span class=\"token keyword\">INTO</span> <span class=\"token identifier\"><span class=\"token punctuation\">`</span>user<span class=\"token punctuation\">`</span></span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token keyword\">VALUES</span> <span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'root1'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'root1'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'xxxx@163.com'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token comment\">-- 创建保留点 updateA</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token keyword\">SAVEPOINT</span> updateA<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token comment\">-- 插入操作 B</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token keyword\">INSERT</span> <span class=\"token keyword\">INTO</span> <span class=\"token identifier\"><span class=\"token punctuation\">`</span>user<span class=\"token punctuation\">`</span></span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token keyword\">VALUES</span> <span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'root2'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'root2'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'xxxx@163.com'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre></pre></td></tr><tr><td data-num=\"15\"></td><td><pre><span class=\"token comment\">-- 回滚到保留点 updateA</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre><span class=\"token keyword\">ROLLBACK</span> <span class=\"token keyword\">TO</span> updateA<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre></pre></td></tr><tr><td data-num=\"18\"></td><td><pre><span class=\"token comment\">-- 提交事务，只有操作 A 生效</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre><span class=\"token keyword\">COMMIT</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p><strong>接下来，我们来介绍 DCL 语句用法。DCL 的主要功能是控制用户的访问权限。</strong></p>\n<h4 id=\"权限控制\"><a class=\"anchor\" href=\"#权限控制\">#</a> 权限控制</h4>\n<p>要授予用户帐户权限，可以用 <code>GRANT</code>  命令。有撤销用户的权限，可以用 <code>REVOKE</code>  命令。这里以 MySQl 为例，介绍权限控制实际应用。</p>\n<p><code>GRANT</code>  授予权限语法：</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">GRANT</span> privilege<span class=\"token punctuation\">,</span><span class=\"token punctuation\">[</span>privilege<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> <span class=\"token keyword\">ON</span> privilege_level</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">TO</span> <span class=\"token keyword\">user</span> <span class=\"token punctuation\">[</span>IDENTIFIED <span class=\"token keyword\">BY</span> password<span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">[</span><span class=\"token keyword\">REQUIRE</span> tsl_option<span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token punctuation\">[</span><span class=\"token keyword\">WITH</span> <span class=\"token punctuation\">[</span>GRANT_OPTION <span class=\"token operator\">|</span> resource_option<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>简单解释一下：</p>\n<ol>\n<li>在 <code>GRANT</code>  关键字后指定一个或多个权限。如果授予用户多个权限，则每个权限由逗号分隔。</li>\n<li><code>ON privilege_level</code>  确定权限应用级别。MySQL 支持 global（ <code>*.*</code> ），database（ <code>database.*</code> ），table（ <code>database.table</code> ）和列级别。如果使用列权限级别，则必须在每个权限之后指定一个或逗号分隔列的列表。</li>\n<li><code>user</code>  是要授予权限的用户。如果用户已存在，则 <code>GRANT</code>  语句将修改其权限。否则， <code>GRANT</code>  语句将创建一个新用户。可选子句 <code>IDENTIFIED BY</code>  允许您为用户设置新的密码。</li>\n<li><code>REQUIRE tsl_option</code>  指定用户是否必须通过 SSL，X059 等安全连接连接到数据库服务器。</li>\n<li>可选  <code>WITH GRANT OPTION</code>  子句允许您授予其他用户或从其他用户中删除您拥有的权限。此外，您可以使用 <code>WITH</code>  子句分配 MySQL 数据库服务器的资源，例如，设置用户每小时可以使用的连接数或语句数。这在 MySQL 共享托管等共享环境中非常有用。</li>\n</ol>\n<p><code>REVOKE</code>  撤销权限语法：</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">REVOKE</span>   privilege_type <span class=\"token punctuation\">[</span><span class=\"token punctuation\">(</span>column_list<span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>        <span class=\"token punctuation\">[</span><span class=\"token punctuation\">,</span> priv_type <span class=\"token punctuation\">[</span><span class=\"token punctuation\">(</span>column_list<span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">ON</span> <span class=\"token punctuation\">[</span>object_type<span class=\"token punctuation\">]</span> privilege_level</pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">FROM</span> <span class=\"token keyword\">user</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">user</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr></table></figure><p>简单解释一下：</p>\n<ol>\n<li>在  <code>REVOKE</code>  关键字后面指定要从用户撤消的权限列表。您需要用逗号分隔权限。</li>\n<li>指定在  <code>ON</code>  子句中撤销特权的特权级别。</li>\n<li>指定要撤消  <code>FROM</code>  子句中的权限的用户帐户。</li>\n</ol>\n<p><code>GRANT</code>  和  <code>REVOKE</code>  可在几个层次上控制访问权限：</p>\n<ul>\n<li>整个服务器，使用  <code>GRANT ALL</code>  和  <code>REVOKE ALL</code> ；</li>\n<li>整个数据库，使用  <code>ON database.*</code> ；</li>\n<li>特定的表，使用  <code>ON database.table</code> ；</li>\n<li>特定的列；</li>\n<li>特定的存储过程。</li>\n</ul>\n<p>新创建的账户没有任何权限。账户用  <code>username@host</code>  的形式定义， <code>username@%</code>  使用的是默认主机名。MySQL 的账户信息保存在 mysql 这个数据库中。</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">USE</span> mysql<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">SELECT</span> <span class=\"token keyword\">user</span> <span class=\"token keyword\">FROM</span> <span class=\"token keyword\">user</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>下表说明了可用于 <code>GRANT</code>  和 <code>REVOKE</code>  语句的所有允许权限：</p>\n<table>\n<thead>\n<tr>\n<th><strong>特权</strong></th>\n<th><strong>说明</strong></th>\n<th><strong>级别</strong></th>\n<th></th>\n<th></th>\n<th></th>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>全局</strong></td>\n<td>数据库</td>\n<td><strong>表</strong></td>\n<td><strong>列</strong></td>\n<td><strong>程序</strong></td>\n<td><strong>代理</strong></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>ALL [PRIVILEGES]</td>\n<td>授予除 GRANT OPTION 之外的指定访问级别的所有权限</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>ALTER</td>\n<td>允许用户使用 ALTER TABLE 语句</td>\n<td>X</td>\n<td>X</td>\n<td>X</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>ALTER ROUTINE</td>\n<td>允许用户更改或删除存储的例程</td>\n<td>X</td>\n<td>X</td>\n<td></td>\n<td></td>\n<td>X</td>\n<td></td>\n</tr>\n<tr>\n<td>CREATE</td>\n<td>允许用户创建数据库和表</td>\n<td>X</td>\n<td>X</td>\n<td>X</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>CREATE ROUTINE</td>\n<td>允许用户创建存储的例程</td>\n<td>X</td>\n<td>X</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>CREATE TABLESPACE</td>\n<td>允许用户创建，更改或删除表空间和日志文件组</td>\n<td>X</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>CREATE TEMPORARY TABLES</td>\n<td>允许用户使用 CREATE TEMPORARY TABLE 创建临时表</td>\n<td>X</td>\n<td>X</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>CREATE USER</td>\n<td>允许用户使用 CREATE USER，DROP USER，RENAME USER 和 REVOKE ALL PRIVILEGES 语句。</td>\n<td>X</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>CREATE VIEW</td>\n<td>允许用户创建或修改视图。</td>\n<td>X</td>\n<td>X</td>\n<td>X</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>DELETE</td>\n<td>允许用户使用 DELETE</td>\n<td>X</td>\n<td>X</td>\n<td>X</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>DROP</td>\n<td>允许用户删除数据库，表和视图</td>\n<td>X</td>\n<td>X</td>\n<td>X</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>EVENT</td>\n<td>启用事件计划程序的事件使用。</td>\n<td>X</td>\n<td>X</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>EXECUTE</td>\n<td>允许用户执行存储的例程</td>\n<td>X</td>\n<td>X</td>\n<td>X</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>FILE</td>\n<td>允许用户读取数据库目录中的任何文件。</td>\n<td>X</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>GRANT OPTION</td>\n<td>允许用户拥有授予或撤消其他帐户权限的权限。</td>\n<td>X</td>\n<td>X</td>\n<td>X</td>\n<td></td>\n<td>X</td>\n<td>X</td>\n</tr>\n<tr>\n<td>INDEX</td>\n<td>允许用户创建或删除索引。</td>\n<td>X</td>\n<td>X</td>\n<td>X</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>INSERT</td>\n<td>允许用户使用 INSERT 语句</td>\n<td>X</td>\n<td>X</td>\n<td>X</td>\n<td>X</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>LOCK TABLES</td>\n<td>允许用户对具有 SELECT 权限的表使用 LOCK TABLES</td>\n<td>X</td>\n<td>X</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>PROCESS</td>\n<td>允许用户使用 SHOW PROCESSLIST 语句查看所有进程。</td>\n<td>X</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>PROXY</td>\n<td>启用用户代理。</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>REFERENCES</td>\n<td>允许用户创建外键</td>\n<td>X</td>\n<td>X</td>\n<td>X</td>\n<td>X</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>RELOAD</td>\n<td>允许用户使用 FLUSH 操作</td>\n<td>X</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>REPLICATION CLIENT</td>\n<td>允许用户查询以查看主服务器或从属服务器的位置</td>\n<td>X</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>REPLICATION SLAVE</td>\n<td>允许用户使用复制从属从主服务器读取二进制日志事件。</td>\n<td>X</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>SELECT</td>\n<td>允许用户使用 SELECT 语句</td>\n<td>X</td>\n<td>X</td>\n<td>X</td>\n<td>X</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>SHOW DATABASES</td>\n<td>允许用户显示所有数据库</td>\n<td>X</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>SHOW VIEW</td>\n<td>允许用户使用 SHOW CREATE VIEW 语句</td>\n<td>X</td>\n<td>X</td>\n<td>X</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>SHUTDOWN</td>\n<td>允许用户使用 mysqladmin shutdown 命令</td>\n<td>X</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>SUPER</td>\n<td>允许用户使用其他管理操作，例如 CHANGE MASTER TO，KILL，PURGE BINARY LOGS，SET GLOBAL 和 mysqladmin 命令</td>\n<td>X</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>TRIGGER</td>\n<td>允许用户使用 TRIGGER 操作。</td>\n<td>X</td>\n<td>X</td>\n<td>X</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>UPDATE</td>\n<td>允许用户使用 UPDATE 语句</td>\n<td>X</td>\n<td>X</td>\n<td>X</td>\n<td>X</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>USAGE</td>\n<td>相当于 “没有特权”</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"创建账户\"><a class=\"anchor\" href=\"#创建账户\">#</a> 创建账户</h5>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">USER</span> myuser IDENTIFIED <span class=\"token keyword\">BY</span> <span class=\"token string\">'mypassword'</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h5 id=\"修改账户名\"><a class=\"anchor\" href=\"#修改账户名\">#</a> 修改账户名</h5>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">UPDATE</span> <span class=\"token keyword\">user</span> <span class=\"token keyword\">SET</span> <span class=\"token keyword\">user</span><span class=\"token operator\">=</span><span class=\"token string\">'newuser'</span> <span class=\"token keyword\">WHERE</span> <span class=\"token keyword\">user</span><span class=\"token operator\">=</span><span class=\"token string\">'myuser'</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>FLUSH <span class=\"token keyword\">PRIVILEGES</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h5 id=\"删除账户\"><a class=\"anchor\" href=\"#删除账户\">#</a> 删除账户</h5>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">DROP</span> <span class=\"token keyword\">USER</span> myuser<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h5 id=\"查看权限\"><a class=\"anchor\" href=\"#查看权限\">#</a> 查看权限</h5>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">SHOW</span> GRANTS <span class=\"token keyword\">FOR</span> myuser<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h5 id=\"授予权限\"><a class=\"anchor\" href=\"#授予权限\">#</a> 授予权限</h5>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">GRANT</span> <span class=\"token keyword\">SELECT</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">INSERT</span> <span class=\"token keyword\">ON</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">.</span><span class=\"token operator\">*</span> <span class=\"token keyword\">TO</span> myuser<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h5 id=\"删除权限\"><a class=\"anchor\" href=\"#删除权限\">#</a> 删除权限</h5>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">REVOKE</span> <span class=\"token keyword\">SELECT</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">INSERT</span> <span class=\"token keyword\">ON</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">.</span><span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> myuser<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h5 id=\"更改密码\"><a class=\"anchor\" href=\"#更改密码\">#</a> 更改密码</h5>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">SET</span> PASSWORD <span class=\"token keyword\">FOR</span> myuser <span class=\"token operator\">=</span> <span class=\"token string\">'mypass'</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h4 id=\"存储过程-2\"><a class=\"anchor\" href=\"#存储过程-2\">#</a> 存储过程</h4>\n<p><img data-src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/60afdc9c9a594f079727ec64a2e698a3~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"mysql存储过程\" /></p>\n<p>使用存储过程的好处：</p>\n<ul>\n<li>代码封装，保证了一定的安全性；</li>\n<li><font color='red'>代码复用</font>；</li>\n<li>由于是<font color='red'>预先编译</font>，因此具有很高的性能。</li>\n</ul>\n<p>创建存储过程：</p>\n<ul>\n<li>命令行中创建存储过程需要自定义分隔符，因为命令行是以  <code>;</code>  为结束符，而存储过程中也包含了分号，因此会错误把这部分分号当成是结束符，造成语法错误。</li>\n<li>包含  <code>in</code> 、 <code>out</code>  和  <code>inout</code>  三种参数。</li>\n<li>给变量赋值都需要用  <code>select into</code>  语句。</li>\n<li>每次只能给一个变量赋值，不支持集合的操作。</li>\n</ul>\n<p>需要注意的是：<strong>阿里巴巴《Java 开发手册》强制禁止使用存储过程。因为存储过程难以调试和扩展，更没有移植性。</strong></p>\n<p><img data-src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/93a5e011ade4450ebfa5d82057532a49~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"img\" /></p>\n<p>至于到底要不要在项目中使用，还是要看项目实际需求，权衡好利弊即可！</p>\n<h5 id=\"创建存储过程\"><a class=\"anchor\" href=\"#创建存储过程\">#</a> 创建存储过程</h5>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">DROP</span> <span class=\"token keyword\">PROCEDURE</span> <span class=\"token keyword\">IF</span> <span class=\"token keyword\">EXISTS</span> <span class=\"token identifier\"><span class=\"token punctuation\">`</span>proc_adder<span class=\"token punctuation\">`</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">DELIMITER</span> <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">DEFINER</span><span class=\"token operator\">=</span><span class=\"token identifier\"><span class=\"token punctuation\">`</span>root<span class=\"token punctuation\">`</span></span><span class=\"token variable\">@`localhost`</span> <span class=\"token keyword\">PROCEDURE</span> <span class=\"token identifier\"><span class=\"token punctuation\">`</span>proc_adder<span class=\"token punctuation\">`</span></span><span class=\"token punctuation\">(</span><span class=\"token operator\">IN</span> a <span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">IN</span> b <span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">OUT</span> sum <span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">BEGIN</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token keyword\">DECLARE</span> c <span class=\"token keyword\">int</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token keyword\">if</span> a <span class=\"token operator\">is</span> <span class=\"token boolean\">null</span> <span class=\"token keyword\">then</span> <span class=\"token keyword\">set</span> a <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token keyword\">end</span> <span class=\"token keyword\">if</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token keyword\">if</span> b <span class=\"token operator\">is</span> <span class=\"token boolean\">null</span> <span class=\"token keyword\">then</span> <span class=\"token keyword\">set</span> b <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token keyword\">end</span> <span class=\"token keyword\">if</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    <span class=\"token keyword\">set</span> sum  <span class=\"token operator\">=</span> a <span class=\"token operator\">+</span> b<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token keyword\">END</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre><span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre><span class=\"token keyword\">DELIMITER</span> <span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h5 id=\"使用存储过程\"><a class=\"anchor\" href=\"#使用存储过程\">#</a> 使用存储过程</h5>\n<figure class=\"highlight less\"><figcaption data-lang=\"less\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>set <span class=\"token variable\">@b</span>=5<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>call proc_<span class=\"token function\">adder</span><span class=\"token punctuation\">(</span>2<span class=\"token punctuation\">,</span><span class=\"token variable\">@b</span><span class=\"token punctuation\">,</span><span class=\"token variable\">@s</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>select <span class=\"token variable\">@s</span> as sum<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h4 id=\"游标\"><a class=\"anchor\" href=\"#游标\">#</a> 游标</h4>\n<p>游标（cursor）是<strong>一个存储在 DBMS 服务器上的数据库查询，它不是一条  <code>SELECT</code>  语句，而是被该语句检索出来的结果集</strong>。</p>\n<p>在存储过程中使用游标可以对一个结果集进行移动遍历。</p>\n<p>游标主要用于交互式应用，其中用户需要滚动屏幕上的数据，并对数据进行浏览或做出更改。</p>\n<p>使用游标的几个明确步骤：</p>\n<ul>\n<li>在使用游标前，必须<font color='red'>声明 (定义)</font>它。这个过程实际上没有检索数据， 它只是定义要使用的  <code>SELECT</code>  语句和游标选项。</li>\n<li>一旦声明，就必须<font color='red'>打开游标以供使用</font>。这个过程用前面定义的 SELECT 语句把数据实际检索出来。</li>\n<li>对于填有数据的游标，根据需要<font color='red'>取出 (检索) 各行</font>。</li>\n<li>在结束游标使用时，必须<font color='red'>关闭游标</font>，可能的话，<font color='red'>释放游标</font>(有赖于具体的 DBMS)。</li>\n</ul>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">DELIMITER</span> $</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">CREATE</span>  <span class=\"token keyword\">PROCEDURE</span> getTotal<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">BEGIN</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token keyword\">DECLARE</span> total <span class=\"token keyword\">INT</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token comment\">-- 创建接收游标数据的变量</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token keyword\">DECLARE</span> sid <span class=\"token keyword\">INT</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token keyword\">DECLARE</span> sname <span class=\"token keyword\">VARCHAR</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token comment\">-- 创建总数变量</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token keyword\">DECLARE</span> sage <span class=\"token keyword\">INT</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token comment\">-- 创建结束标志变量</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token keyword\">DECLARE</span> done <span class=\"token keyword\">INT</span> <span class=\"token keyword\">DEFAULT</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    <span class=\"token comment\">-- 创建游标</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    <span class=\"token keyword\">DECLARE</span> cur <span class=\"token keyword\">CURSOR</span> <span class=\"token keyword\">FOR</span> <span class=\"token keyword\">SELECT</span> id<span class=\"token punctuation\">,</span>name<span class=\"token punctuation\">,</span>age <span class=\"token keyword\">from</span> cursor_table <span class=\"token keyword\">where</span> age<span class=\"token operator\">></span><span class=\"token number\">30</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    <span class=\"token comment\">-- 指定游标循环结束时的返回值</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    <span class=\"token keyword\">DECLARE</span> <span class=\"token keyword\">CONTINUE</span> <span class=\"token keyword\">HANDLER</span> <span class=\"token keyword\">FOR</span> <span class=\"token operator\">NOT</span> FOUND <span class=\"token keyword\">SET</span> done <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>    <span class=\"token keyword\">SET</span> total <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>    <span class=\"token keyword\">OPEN</span> cur<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>    <span class=\"token keyword\">FETCH</span> cur <span class=\"token keyword\">INTO</span> sid<span class=\"token punctuation\">,</span> sname<span class=\"token punctuation\">,</span> sage<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>    <span class=\"token keyword\">WHILE</span><span class=\"token punctuation\">(</span><span class=\"token operator\">NOT</span> done<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>    <span class=\"token keyword\">DO</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>        <span class=\"token keyword\">SET</span> total <span class=\"token operator\">=</span> total <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>        <span class=\"token keyword\">FETCH</span> cur <span class=\"token keyword\">INTO</span> sid<span class=\"token punctuation\">,</span> sname<span class=\"token punctuation\">,</span> sage<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>    <span class=\"token keyword\">END</span> <span class=\"token keyword\">WHILE</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>    <span class=\"token keyword\">CLOSE</span> cur<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>    <span class=\"token keyword\">SELECT</span> total<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre><span class=\"token keyword\">END</span> $</pre></td></tr><tr><td data-num=\"28\"></td><td><pre><span class=\"token keyword\">DELIMITER</span> <span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre></pre></td></tr><tr><td data-num=\"30\"></td><td><pre><span class=\"token comment\">-- 调用存储过程</span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre><span class=\"token keyword\">call</span> getTotal<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h4 id=\"触发器\"><a class=\"anchor\" href=\"#触发器\">#</a> 触发器</h4>\n<p>触发器是一种与表操作有关的数据库对象，<font color='red'>当触发器所在表上出现指定事件时，将调用该对象</font>，即表的操作事件触发表上的触发器的执行。</p>\n<p>触发器<font color='red'>可以用来进行审计跟踪，把修改记录到另外一张表中</font>。</p>\n<p>使用触发器的优点：</p>\n<ul>\n<li>SQL 触发器提供了另一种检查数据完整性的方法。</li>\n<li>SQL 触发器可以捕获数据库层中业务逻辑中的错误。</li>\n<li>SQL 触发器提供了另一种运行计划任务的方法。通过使用 SQL 触发器，您不必等待运行计划任务，因为在对表中的数据进行更改之前或之后会自动调用触发器。</li>\n<li>SQL 触发器对于审计表中数据的更改非常有用。</li>\n</ul>\n<p>使用触发器的缺点：</p>\n<ul>\n<li>SQL 触发器只能提供扩展验证，并且不能替换所有验证。必须在应用程序层中完成一些简单的验证。例如，您可以使用 JavaScript 在客户端验证用户的输入，或者使用服务器端脚本语言（如 JSP，PHP，<span class=\"exturl\" data-url=\"aHR0cDovL0FTUC5ORVQ=\">ASP.NET</span>，Perl）在服务器端验证用户的输入。</li>\n<li>从客户端应用程序调用和执行 SQL 触发器是不可见的，因此很难弄清楚数据库层中发生了什么。</li>\n<li>SQL 触发器可能会增加数据库服务器的开销。</li>\n</ul>\n<p><strong>MySQL 不允许在触发器中使用 CALL 语句 ，也就是不能调用存储过程</strong>。</p>\n<blockquote>\n<p>注意：在 MySQL 中，分号  <code>;</code>  是语句结束的标识符，遇到分号表示该段语句已经结束，MySQL 可以开始执行了。因此，解释器遇到触发器执行动作中的分号后就开始执行，然后会报错，因为没有找到和 BEGIN 匹配的 END。</p>\n<p>这时就会用到  <code>DELIMITER</code>  命令（DELIMITER 是定界符，分隔符的意思）。它是一条命令，不需要语句结束标识，语法为： <code>DELIMITER new_delemiter</code> 。 <code>new_delemiter</code>  可以设为 1 个或多个长度的符号，默认的是分号  <code>;</code> ，我们可以把它修改为其他符号，如  <code>$</code>  -  <code>DELIMITER $</code>  。在这之后的语句，以分号结束，解释器不会有什么反应，只有遇到了  <code>$</code> ，才认为是语句结束。注意，使用完之后，我们还应该记得把它给修改回来。</p>\n</blockquote>\n<p>在 MySQL 5.7.2 版之前，可以为每个表定义最多六个触发器。</p>\n<ul>\n<li><code>BEFORE INSERT</code>  - 在将数据插入表格之前激活。</li>\n<li><code>AFTER INSERT</code>  - 将数据插入表格后激活。</li>\n<li><code>BEFORE UPDATE</code>  - 在更新表中的数据之前激活。</li>\n<li><code>AFTER UPDATE</code>  - 更新表中的数据后激活。</li>\n<li><code>BEFORE DELETE</code>  - 在从表中删除数据之前激活。</li>\n<li><code>AFTER DELETE</code>  - 从表中删除数据后激活。</li>\n</ul>\n<p>但是，从 MySQL 版本 5.7.2 + 开始，可以为同一触发事件和操作时间定义多个触发器。</p>\n<p><strong> <code>NEW</code>  和  <code>OLD</code> </strong> ：</p>\n<ul>\n<li>MySQL 中定义了  <code>NEW</code>  和  <code>OLD</code>  关键字，用来<strong>表示触发器的所在表中，触发了触发器的那一行数据</strong>。</li>\n<li>在  <code>INSERT</code>  型触发器中， <code>NEW</code>  用来表示将要（ <code>BEFORE</code> ）或已经（ <code>AFTER</code> ）插入的新数据；</li>\n<li>在  <code>UPDATE</code>  型触发器中， <code>OLD</code>  用来表示将要或已经被修改的原数据， <code>NEW</code>  用来表示将要或已经修改为的新数据；</li>\n<li>在  <code>DELETE</code>  型触发器中， <code>OLD</code>  用来表示将要或已经被删除的原数据；</li>\n<li>使用方法：  <code>NEW.columnName</code>  （columnName 为相应数据表某一列名）</li>\n</ul>\n<h5 id=\"创建触发器\"><a class=\"anchor\" href=\"#创建触发器\">#</a> 创建触发器</h5>\n<blockquote>\n<p>提示：为了理解触发器的要点，有必要先了解一下创建触发器的指令。</p>\n</blockquote>\n<p><code>CREATE TRIGGER</code>  指令用于创建触发器。</p>\n<p>语法：</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">TRIGGER</span> trigger_name</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>trigger_time</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>trigger_event</pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">ON</span> table_name</pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">FOR EACH ROW</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token keyword\">BEGIN</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>  trigger_statements</pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token keyword\">END</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>说明：</p>\n<ul>\n<li><code>trigger_name</code>  ：触发器名</li>\n<li><code>trigger_time</code>  : 触发器的触发时机。取值为  <code>BEFORE</code>  或  <code>AFTER</code> 。</li>\n<li><code>trigger_event</code>  : 触发器的监听事件。取值为  <code>INSERT</code> 、 <code>UPDATE</code>  或  <code>DELETE</code> 。</li>\n<li><code>table_name</code>  : 触发器的监听目标。指定在哪张表上建立触发器。</li>\n<li><code>FOR EACH ROW</code> : 行级监视，Mysql 固定写法，其他 DBMS 不同。</li>\n<li><code>trigger_statements</code> : 触发器执行动作。是一条或多条 SQL 语句的列表，列表内的每条语句都必须用分号  <code>;</code>  来结尾。</li>\n</ul>\n<p>当触发器的触发条件满足时，将会执行  <code>BEGIN</code>  和  <code>END</code>  之间的触发器执行动作。</p>\n<p>示例：</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">DELIMITER</span> $</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">TRIGGER</span> <span class=\"token identifier\"><span class=\"token punctuation\">`</span>trigger_insert_user<span class=\"token punctuation\">`</span></span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">AFTER</span> <span class=\"token keyword\">INSERT</span> <span class=\"token keyword\">ON</span> <span class=\"token identifier\"><span class=\"token punctuation\">`</span>user<span class=\"token punctuation\">`</span></span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">FOR EACH ROW</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">BEGIN</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token keyword\">INSERT</span> <span class=\"token keyword\">INTO</span> <span class=\"token identifier\"><span class=\"token punctuation\">`</span>user_history<span class=\"token punctuation\">`</span></span><span class=\"token punctuation\">(</span>user_id<span class=\"token punctuation\">,</span> operate_type<span class=\"token punctuation\">,</span> operate_time<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token keyword\">VALUES</span> <span class=\"token punctuation\">(</span>NEW<span class=\"token punctuation\">.</span>id<span class=\"token punctuation\">,</span> <span class=\"token string\">'add a user'</span><span class=\"token punctuation\">,</span>  <span class=\"token function\">now</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token keyword\">END</span> $</pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token keyword\">DELIMITER</span> <span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h5 id=\"查看触发器\"><a class=\"anchor\" href=\"#查看触发器\">#</a> 查看触发器</h5>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">SHOW</span> TRIGGERS<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h5 id=\"删除触发器\"><a class=\"anchor\" href=\"#删除触发器\">#</a> 删除触发器</h5>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">DROP</span> <span class=\"token keyword\">TRIGGER</span> <span class=\"token keyword\">IF</span> <span class=\"token keyword\">EXISTS</span> trigger_insert_user<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h3 id=\"sql优化\"><a class=\"anchor\" href=\"#sql优化\">#</a> <mark>🌟SQL 优化</mark></h3>\n<h4 id=\"慢查询语句优化\"><a class=\"anchor\" href=\"#慢查询语句优化\">#</a> <mark>🌟慢查询语句优化</mark></h4>\n<ol>\n<li><font color='red'>尽量覆盖索引</font>，避免 select *，减少回表</li>\n<li><font color='red'>避免索引失效</font>，例如：联合索引需要满足最左前缀匹配原则、不要使用左模糊匹配、表达式运算、函数计算、隐式类型转换等...</li>\n<li><font color='red'>分页查询优化</font>：该方案适用于主键自增的表，可以把 Limit 查询转换成某个位置的查询。select * from tb_sku where id&gt;20000 limit 10;</li>\n<li><font color='red'>将字段多的表分解成多个表</font>：有些字段使用频率高，有些低，数据量大时，会由于使用频率低的存在而变慢，可以考虑分开</li>\n<li><font color='red'>对于经常联合查询的表，可以考虑建立中间表</font></li>\n<li><font color='red'>优化器使用 MRR【Multi-Range Read】</font>：将 ID 或键值读到 buffer 排序，通过<font color='red'>把「随机磁盘读」，转化为「顺序磁盘读」，减少磁盘 IO</font>，从而提高了索引查询的性能</li>\n<li><font color='red'>读写分离（主库写，从库读）</font></li>\n<li>检查<font color='red'>所查字段是否冗余</font></li>\n<li>检查<font color='red'>表中数据是否过多</font>，是否应该进行分库分表了</li>\n<li>检查<font color='red'>数据库实例所在机器的性能是否太低</font>，是否可以适当增加资源</li>\n</ol>\n<h4 id=\"插入数据-2\"><a class=\"anchor\" href=\"#插入数据-2\">#</a> 插入数据</h4>\n<h5 id=\"insert\"><a class=\"anchor\" href=\"#insert\">#</a> insert</h5>\n<p>如果我们需要一次性往数据库表中插入多条记录，</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">insert</span> <span class=\"token keyword\">into</span> tb_test <span class=\"token keyword\">values</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token string\">'tom'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">insert</span> <span class=\"token keyword\">into</span> tb_test <span class=\"token keyword\">values</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token string\">'cat'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">insert</span> <span class=\"token keyword\">into</span> tb_test <span class=\"token keyword\">values</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token string\">'jerry'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr></table></figure><p>可以从以下三个方面进行优化：</p>\n<ol>\n<li>\n<p><font color='red'>批量插入</font></p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">Insert</span> <span class=\"token keyword\">into</span> tb_test <span class=\"token keyword\">values</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token string\">'Tom'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token string\">'Cat'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token string\">'Jerry'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure></li>\n<li>\n<p><font color='red'>手动控制事务</font>：避免事务的频繁开启与提交</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">start</span> <span class=\"token keyword\">transaction</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">insert</span> <span class=\"token keyword\">into</span> tb_test <span class=\"token keyword\">values</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token string\">'Tom'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token string\">'Cat'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token string\">'Jerry'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">insert</span> <span class=\"token keyword\">into</span> tb_test <span class=\"token keyword\">values</span><span class=\"token punctuation\">(</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span><span class=\"token string\">'Tom'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">,</span><span class=\"token string\">'Cat'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">(</span><span class=\"token number\">6</span><span class=\"token punctuation\">,</span><span class=\"token string\">'Jerry'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">insert</span> <span class=\"token keyword\">into</span> tb_test <span class=\"token keyword\">values</span><span class=\"token punctuation\">(</span><span class=\"token number\">7</span><span class=\"token punctuation\">,</span><span class=\"token string\">'Tom'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">(</span><span class=\"token number\">8</span><span class=\"token punctuation\">,</span><span class=\"token string\">'Cat'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">(</span><span class=\"token number\">9</span><span class=\"token punctuation\">,</span><span class=\"token string\">'Jerry'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">commit</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure></li>\n<li>\n<p><font color='red'>主键顺序插入</font>：性能要高于乱序插入</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>主键乱序插入 : <span class=\"token number\">8</span> <span class=\"token number\">1</span> <span class=\"token number\">9</span> <span class=\"token number\">21</span> <span class=\"token number\">88</span> <span class=\"token number\">2</span> <span class=\"token number\">4</span> <span class=\"token number\">15</span> <span class=\"token number\">89</span> <span class=\"token number\">5</span> <span class=\"token number\">7</span> <span class=\"token number\">3</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>主键顺序插入 : <span class=\"token number\">1</span> <span class=\"token number\">2</span> <span class=\"token number\">3</span> <span class=\"token number\">4</span> <span class=\"token number\">5</span> <span class=\"token number\">7</span> <span class=\"token number\">8</span> <span class=\"token number\">9</span> <span class=\"token number\">15</span> <span class=\"token number\">21</span> <span class=\"token number\">88</span> <span class=\"token number\">89</span></pre></td></tr></table></figure></li>\n</ol>\n<h5 id=\"批量插入\"><a class=\"anchor\" href=\"#批量插入\">#</a> 批量插入</h5>\n<p>如果一次性需要插入大批量数据 (比如：几百万的记录)，使用 insert 语句插入性能较低，此时可以使用 MySQL 数据库提供的 <font color='red'> <code>load</code>  指令</font>进行插入。</p>\n<blockquote>\n<p>在 load 时，主键顺序插入性能高于乱序插入</p>\n</blockquote>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">-- 客户端连接服务端时，加上参数 -–local-infile</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>mysql –<span class=\"token operator\">-</span><span class=\"token keyword\">local</span><span class=\"token operator\">-</span><span class=\"token keyword\">infile</span> <span class=\"token operator\">-</span>u root <span class=\"token operator\">-</span>p</pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token comment\">-- 设置全局参数 local_infile 为 1，开启从本地加载文件导入数据的开关</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">set</span> <span class=\"token keyword\">global</span> local_infile <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token comment\">-- 执行 load 指令将准备好的数据，加载到表结构中</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token keyword\">load</span> <span class=\"token keyword\">data</span> <span class=\"token keyword\">local</span> <span class=\"token keyword\">infile</span> <span class=\"token string\">'/root/sql1.log'</span> <span class=\"token keyword\">into</span> <span class=\"token keyword\">table</span> tb_user <span class=\"token keyword\">fields</span> <span class=\"token keyword\">terminated</span> <span class=\"token keyword\">by</span> <span class=\"token string\">','</span> <span class=\"token keyword\">lines</span> <span class=\"token keyword\">terminated</span> <span class=\"token keyword\">by</span> <span class=\"token string\">'\\n'</span> <span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h4 id=\"主键优化\"><a class=\"anchor\" href=\"#主键优化\">#</a> <mark>🌟主键优化</mark></h4>\n<blockquote>\n<p>想知道为什么主键顺序插入的效率比主键乱序插入的更高，首先得明白主键是如何设计的！</p>\n</blockquote>\n<h5 id=\"innodb表数据的组织方式\"><a class=\"anchor\" href=\"#innodb表数据的组织方式\">#</a> InnoDB 表数据的组织方式</h5>\n<p><font color='red'>在 InnoDB 存储引擎中，表数据都是根据<u>主键顺序</u>组织存放的</font>，这种存储方式的表称为<strong>索引组织表 (index organized table IOT)</strong>。</p>\n<p><font color='red'>行数据，都是存储在聚集索引的叶子节点上的</font>。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231119103453582.png\" alt=\"image-20231119103453582\" /></p>\n<p>之前也讲解过 InnoDB 的逻辑结构图：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231119103710336.png\" alt=\"image-20231119103710336\" /></p>\n<p><font color='red'>在 InnoDB 引擎中，row 数据是记录在逻辑结构 page 页中的</font>，而每一个页的大小是固定的，默认 16K。也就意味着，一个页中所存储的行也是有限的，<font color='red'>如果插入的 row 数据在该页存储不下，将会存储到下一个页中，页与页之间会通过指针连接</font>。</p>\n<h5 id=\"页分裂\"><a class=\"anchor\" href=\"#页分裂\">#</a> 页分裂</h5>\n<blockquote>\n<p>主键乱序插入时会产生的操作，比较耗费性能！</p>\n</blockquote>\n<p>页可以为空，也可以填充一半，也可以填充 100%。每个页包含了 2-N 行数据 (如果一行数据过大，会行溢出)，<font color='red'>页内的行数据根据主键排列</font>。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231119104317288.png\" alt=\"image-20231119104317288\" /></p>\n<center>按照主键顺序插入</center>\n<p><strong>页分裂</strong>：当行数据是<font color='red'>按照主键乱序插入</font>时，<strong><font color='red'>由于索引结构的叶子节点需要维护有序</font></strong>，在插入某行数据时，如果<font color='red'>当前所有页都满了</font>，会导致<font color='red'>某页需要将后一半数据移动到一个新开辟的页中</font>，然后<font color='red'>再插入行数据</font>，最后需要<font color='red'>重新设置页之间的指针</font>。</p>\n<p>因此，<strong><font color='red'>页分裂是一种比较耗费性能的操作，所以尽量按照主键顺序插入！</font></strong></p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231119105153488.png\" alt=\"image-20231119105153488\" /></p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231119105216568.png\" alt=\"image-20231119105216568\" /></p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231119105221673.png\" alt=\"image-20231119105221673\" /></p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231119105227518.png\" alt=\"image-20231119105227518\" /></p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231119105234837.png\" alt=\"image-20231119105234837\" /></p>\n<center>按照主键乱序插入</center>\n<h5 id=\"页合并\"><a class=\"anchor\" href=\"#页合并\">#</a> 页合并</h5>\n<p>当删除一条行记录时，并非物理删除，而是将其标记（flaged）为<font color='red'>逻辑删除</font>，并且它的空间变得允许被其他行记录声明使用。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231119110526526.png\" alt=\"image-20231119110526526\" /></p>\n<p><strong><font color='red'>当页中删除的记录达到 MERGE_THRESHOLD（默认为页的 50%），InnoDB 会开始寻找最靠近的页看看是否可以将两个页合并，以优化空间使用</font></strong>。</p>\n<blockquote>\n<p>MERGE_THRESHOLD：合并页的阈值，可以自己设置，在创建表或者创建索引时指定。</p>\n</blockquote>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231119110615283.png\" alt=\"image-20231119110615283\" /></p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231119110628033.png\" alt=\"image-20231119110628033\" /></p>\n<p>删除数据，并将页合并之后，再次插入新的数据 21，则直接插入 3# 页。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231119110703491.png\" alt=\"image-20231119110703491\" /></p>\n<h5 id=\"主键使用原则\"><a class=\"anchor\" href=\"#主键使用原则\">#</a> 主键使用原则</h5>\n<ul>\n<li>\n<p><strong>尽量降低主键的长度</strong>：对于一张表，只有一个主键索引，可以有多个二级索引。而二级索引的叶子节点中存放的就是主键，因此<font color='red'>如果主键的长度较长，会导致二级索引占用大量磁盘空间，查询时也会耗费较多的磁盘 IO</font>。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231119111458997.png\" alt=\"image-20231119111458997\" /></p>\n</li>\n<li>\n<p><strong>尽量按照主键顺序插入数据</strong>：能够避免按照主键乱序插入数据时的页分裂操作，提高插入性能！</p>\n</li>\n<li>\n<p><strong>尽量选择使用 AUTO_INCREMENT 自增主键</strong>：不要使用 UUID 做主键，或者其他自然主键，如身份证号。因为它们都是<font color='red'>无序</font>的，导致乱序插入，存在页分裂现象。而且它们的<font color='red'>长度较长</font>，构建索引需要的空间较大，在查询时会耗费大量的磁盘 IO。</p>\n</li>\n<li>\n<p><strong>尽量避免对主键的修改</strong>：修改主键，还需要修改对应的主键索引、二级索引，代价较大！</p>\n</li>\n</ul>\n<h4 id=\"order-by-优化\"><a class=\"anchor\" href=\"#order-by-优化\">#</a> order by 优化</h4>\n<p>MySQL 有两种排序方式：</p>\n<ul>\n<li><code>Using filesort</code> ：通过表的索引或全表扫描读取满足条件的数据行，然后<font color='red'>在 sort buffer（排序缓冲区）中完成排序操作</font>，所有不是通过索引直接返回排序结果的排序都叫 FileSort 排序。</li>\n<li><code>Using index</code> ：<font color='red'>通过有序索引顺序扫描直接返回有序数据</font>，<font color='red'>不需要额外排序，操作效率高</font>。</li>\n</ul>\n<p>因此在优化排序操作时，<font color='red'>尽量优化为 Using index</font>。</p>\n<p>经过测试（黑马 MySQL - 进阶篇），总结一下 order by 优化原则：</p>\n<ul>\n<li><strong>根据排序字段建立合适的索引</strong>：这样才会 Using index 排序</li>\n<li>多字段排序时，也遵循<strong>联合索引的最左前缀匹配法则</strong>；</li>\n<li><strong>尽量使用覆盖索引</strong>：避免 select * ；</li>\n<li>多字段排序，一个升序一个降序，此时需要注意<strong>联合索引在创建时的规则（ASC/DESC）</strong>；</li>\n<li>如果不可避免的出现 filesort，大数据量排序时，可以<strong>适当增大排序缓冲区大小 sort_buffer_size</strong> (默认 256k)，否则会在磁盘空间中排序，效率低！</li>\n</ul>\n<h4 id=\"group-by-优化\"><a class=\"anchor\" href=\"#group-by-优化\">#</a> group by 优化</h4>\n<p>在分组操作中，需要通过以下两点进行优化：</p>\n<ul>\n<li>可以<strong>通过索引来提高效率</strong></li>\n<li>联合索引的使用，也需要<strong>遵循最左前缀法则</strong>的</li>\n</ul>\n<h4 id=\"limit-优化\"><a class=\"anchor\" href=\"#limit-优化\">#</a> limit 优化</h4>\n<p>在数据量比较大时，进行 limit 分页查询存在问题：越往后，分页查询效率越低。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231119121326947.png\" alt=\"image-20231119121326947\" /></p>\n<p>优化思路：<strong>覆盖索引 + 子查询</strong></p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">explain</span> <span class=\"token keyword\">select</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">from</span> tb_sku t <span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">select</span> id <span class=\"token keyword\">from</span> tb_sku <span class=\"token keyword\">order</span> <span class=\"token keyword\">by</span> id <span class=\"token keyword\">limit</span> <span class=\"token number\">2000000</span><span class=\"token punctuation\">,</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span> a <span class=\"token keyword\">where</span> t<span class=\"token punctuation\">.</span>id <span class=\"token operator\">=</span> a<span class=\"token punctuation\">.</span>id<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h4 id=\"count-优化\"><a class=\"anchor\" href=\"#count-优化\">#</a> count 优化</h4>\n<p>如果数据量很大，在执行 count 操作时，是非常耗时的。</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">select</span> <span class=\"token function\">count</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">from</span> tb_user <span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>下面对比一下 MyISAM、InnoDB 是如何执行 count 操作的：</p>\n<ul>\n<li>\n<p><font color='cornflowerblue'>MyISAM 引擎</font>：<font color='red'>把表的总行数存在了磁盘上</font>，因此执行 count (*) 的时候会直接返回这个数，效率很高。但是如果是带条件的 count，MyISAM 也慢。</p>\n</li>\n<li>\n<p><font color='cornflowerblue'>InnoDB 引擎</font>：执行 count (*) 的时候，需要<font color='red'>把数据一行一行地从引擎里面读出来，然后累积计数</font>。</p>\n<blockquote>\n<p>InnoDB 对 count 的优化思路：<font color='red'>自己维护计数</font>（可以借助于 redis 进行，但是如果是带条件的 count 又比较麻烦了）。</p>\n</blockquote>\n</li>\n</ul>\n<p>count () 是一个聚合函数，对于返回的结果集，一行行地判断，如果 count 函数的参数不是 NULL，累计值就加 1，否则不加，最后返回累计值。</p>\n<p>count 用法：count（*）、count（主键）、count（字段）、count（数字）</p>\n<blockquote>\n<p>按照效率排序的话，count (字段) &lt; count (主键 id) &lt; count (1) ≈ count (*)，所以<strong>尽量使用 count (*)</strong></p>\n</blockquote>\n<p><img data-src=\"https://raw.githubusercontent.com/hjx159/picture-bed/main/img/image-20231119131552752.png\" alt=\"image-20231119131552752\" /></p>\n<h4 id=\"update-优化\"><a class=\"anchor\" href=\"#update-优化\">#</a> update 优化</h4>\n<p>执行 Update 语句时，条件一定要根据索引字段进行更新，否则会出现行锁升级为表锁，导致并发性能降低！</p>\n<p>InnoDB 的行锁是针对索引加的锁，不是针对记录加的锁，并且该索引不能失效，否则会从行锁升级为表锁。</p>\n<h4 id=\"一些优化原则\"><a class=\"anchor\" href=\"#一些优化原则\">#</a> 一些优化原则</h4>\n<h5 id=\"尽量使用覆盖索引避免-select\"><a class=\"anchor\" href=\"#尽量使用覆盖索引避免-select\">#</a> 尽量使用覆盖索引，避免 select *</h5>\n<p>** 覆盖索引，即需要查询的字段正好是索引的字段，那么直接根据该索引，就可以查到数据了，而无需回表查询。** 因此，<font color='red'>应该尽量使用覆盖索引，减少 <code>select *</code> </font>。</p>\n<h5 id=\"分页优化\"><a class=\"anchor\" href=\"#分页优化\">#</a> 分页优化</h5>\n<h5 id=\"尽量避免多表做join\"><a class=\"anchor\" href=\"#尽量避免多表做join\">#</a> 尽量避免多表做 join</h5>\n<h5 id=\"建议不要使用外键与级联\"><a class=\"anchor\" href=\"#建议不要使用外键与级联\">#</a> 建议不要使用外键与级联</h5>\n<h5 id=\"选择合适的字段类型\"><a class=\"anchor\" href=\"#选择合适的字段类型\">#</a> 选择合适的字段类型</h5>\n<h5 id=\"尽量用-union-all-代替-union\"><a class=\"anchor\" href=\"#尽量用-union-all-代替-union\">#</a> 尽量用 UNION ALL 代替 UNION</h5>\n<h5 id=\"批量操作\"><a class=\"anchor\" href=\"#批量操作\">#</a> 批量操作</h5>\n<h5 id=\"show-profle-分析-sql-执行性能\"><a class=\"anchor\" href=\"#show-profle-分析-sql-执行性能\">#</a> Show Profle 分析 SQL 执行性能</h5>\n<h5 id=\"正确使用索引\"><a class=\"anchor\" href=\"#正确使用索引\">#</a> 正确使用索引</h5>\n<blockquote>\n<p>指路→<a href=\"#%E7%B4%A2%E5%BC%95%E7%9A%84%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8%E5%BB%BA%E8%AE%AE\">索引的正确使用建议</a></p>\n</blockquote>\n<h3 id=\"sql常见面试题\"><a class=\"anchor\" href=\"#sql常见面试题\">#</a> SQL 常见面试题</h3>\n",
            "tags": [
                "数据库",
                "MySQL"
            ]
        },
        {
            "id": "http://example.com/photography/%E6%97%A5%E8%90%BD%E6%94%B6%E9%9B%86%E8%AE%A1%E5%88%92/",
            "url": "http://example.com/photography/%E6%97%A5%E8%90%BD%E6%94%B6%E9%9B%86%E8%AE%A1%E5%88%92/",
            "title": "日落收集计划",
            "date_published": "2023-11-14T16:39:51.099Z",
            "content_html": "<p><img data-src=\"https://pic.imgdb.cn/item/6553a0abc458853aef3aa4f3.jpg\" alt=\"\" /><br />\n<img data-src=\"https://pic.imgdb.cn/item/6553a403c458853aef45fdc7.jpg\" alt=\"落日窗花\" title=\"落日窗花\" /></p>\n",
            "tags": [
                "摄影"
            ]
        },
        {
            "id": "http://example.com/photography/%E8%88%B9%E5%A4%AB%E8%9C%80%E9%BB%8D/",
            "url": "http://example.com/photography/%E8%88%B9%E5%A4%AB%E8%9C%80%E9%BB%8D/",
            "title": "船夫蜀黍",
            "date_published": "2023-11-14T16:37:21.388Z",
            "content_html": "<p><img data-src=\"https://pic.imgdb.cn/item/6553a275c458853aef40b302.jpg\" alt=\"上船！\" title=\"上船！\" /><br />\n<img data-src=\"https://pic.imgdb.cn/item/6553a275c458853aef40b256.jpg\" alt=\"看啥呢\" title=\"看啥呢\" /></p>\n",
            "tags": [
                "摄影"
            ]
        },
        {
            "id": "http://example.com/photography/%E4%B8%80%E4%BA%9B%E8%93%9D%E8%89%B2/",
            "url": "http://example.com/photography/%E4%B8%80%E4%BA%9B%E8%93%9D%E8%89%B2/",
            "title": "一些蓝色",
            "date_published": "2023-11-14T16:30:42.887Z",
            "content_html": "<p><img data-src=\"https://pic.imgdb.cn/item/6553a0aac458853aef3aa386.jpg\" alt=\"1号蓝嘉宾\" title=\"1号蓝嘉宾\" /><br />\n<img data-src=\"https://pic.imgdb.cn/item/6553a0abc458853aef3aa631.jpg\" alt=\"2号蓝嘉宾\" title=\"2号蓝嘉宾\" /></p>\n<p><img data-src=\"https://pic.imgdb.cn/item/6553a0abc458853aef3aa4aa.jpg\" alt=\"3号蓝嘉宾\" title=\"3号蓝嘉宾\" /></p>\n",
            "tags": [
                "摄影"
            ]
        },
        {
            "id": "http://example.com/photography/%E8%93%9D%E4%B8%8E%E9%BB%84/",
            "url": "http://example.com/photography/%E8%93%9D%E4%B8%8E%E9%BB%84/",
            "title": "蓝与黄",
            "date_published": "2023-11-14T16:20:56.108Z",
            "content_html": "<p><img data-src=\"https://pic.imgdb.cn/item/65539e35c458853aef322d09.jpg\" alt=\"一直在用的头像\" title=\"一直在用的头像hh\" /><br />\n<img data-src=\"https://pic.imgdb.cn/item/65539e33c458853aef3224f3.jpg\" alt=\"老电影的最后一幕\" title=\"老电影的最后一幕\" /></p>\n",
            "tags": [
                "摄影"
            ]
        },
        {
            "id": "http://example.com/photography/%E6%9C%9D%E9%98%B3%E5%85%AC%E5%9B%AD/",
            "url": "http://example.com/photography/%E6%9C%9D%E9%98%B3%E5%85%AC%E5%9B%AD/",
            "title": "朝阳公园",
            "date_published": "2023-11-12T08:06:56.973Z",
            "content_html": "<p><img data-src=\"https://pic.imgdb.cn/item/6554c7d9c458853aefd85660.jpg\" alt=\"&quot;婚纱照&quot;\" title=\"婚纱照\" /></p>\n<p><img data-src=\"https://pic.imgdb.cn/item/6554c7d9c458853aefd857b8.jpg\" alt=\"&quot;鸽子&quot;\" title=\"鸽子\" /></p>\n<p><img data-src=\"https://pic.imgdb.cn/item/6554c7d9c458853aefd85a3b.jpg\" alt=\"灯塔？喇叭？\" title=\"灯塔？喇叭？\" /><br />\n<img data-src=\"https://pic.imgdb.cn/item/6554c7dac458853aefd85b87.jpg\" alt=\"旋转跳跃~\" title=\"旋转跳跃~\" height=\"700px\" /></p>\n<p><img data-src=\"https://pic.imgdb.cn/item/6554c873c458853aefdaf78e.jpg\" alt=\"&quot;我不停歇~&quot;\" title=\"我不停歇~\" height=\"700px\" /></p>\n<p><img data-src=\"https://pic.imgdb.cn/item/6554c872c458853aefdaf5dd.jpg\" alt=\"&quot;波光粼粼粼粼粼&quot;\" title=\"波光粼粼粼粼粼\" height=\"700px\" /></p>\n<p><img data-src=\"https://pic.imgdb.cn/item/6554c8c4c458853aefdc3eb4.png\" alt=\"1681754285877.png\" height=\"700px\" /></p>\n<p><img data-src=\"https://pic.imgdb.cn/item/6554c8c4c458853aefdc402e.jpg\" alt=\"&quot;野蛮生长&quot;\" title=\"野蛮生长\" /></p>\n<p><img data-src=\"https://pic.imgdb.cn/item/6554c873c458853aefdafa16.jpg\" alt=\"&quot;光影出版社&quot;\" title=\"光影出版社\" /></p>\n<p><img data-src=\"https://pic.imgdb.cn/item/6554c873c458853aefdaf8ee.jpg\" alt=\"&quot;&quot;\" /></p>\n<p><img data-src=\"https://pic.imgdb.cn/item/6554c7d8c458853aefd854e9.jpg\" alt=\"&quot;售票亭&quot;\" title=\"售票亭\" /></p>\n<p><img data-src=\"https://pic.imgdb.cn/item/6554c8c3c458853aefdc3a13.jpg\" alt=\"&quot;麦门!&quot;\" title=\"麦门!\" /></p>\n",
            "tags": [
                "摄影"
            ]
        }
    ]
}